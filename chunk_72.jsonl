{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hash(self):\n        '''\n        :rtype: int\n        :return: hash of the field\n        '''\n        hashed = super(RandomBits, self).hash()\n        return khash(hashed, self._min_length, self._max_length, self._num_mutations, self._step, self._seed)", "response": "Returns the hash of the field\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstopping the thread return after thread stopped", "response": "def stop(self):\n        '''\n        stop the thread, return after thread stopped\n        '''\n        self._stop_event.set()\n        if self._func_stop_event is not None:\n            self._func_stop_event.set()\n        self.join(timeout=1)\n        if self.isAlive():\n            print('Failed to stop thread')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _initialize(self):\n        '''\n        We override _initialize, as we want to resolve the field each time\n        '''\n        if self._field_name:\n            self._field = self.resolve_field(self._field_name)\n        if not self._field:\n            raise KittyException('Could not resolve field name %s' % self._field_name)", "response": "Override _initialize to resolve the field name and set the _field attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render(self, ctx=None):\n        '''\n        Render the current value into a :class:`bitstring.Bits` object\n\n        :rtype: :class:`bitstring.Bits`\n        :return: the rendered field\n        '''\n        self._initialize()\n        if ctx is None:\n            ctx = RenderContext()\n        #\n        # if we are called from within render, return a dummy object...\n        #\n        if self in ctx:\n            self._current_rendered = self._in_render_value()\n        else:\n            ctx.push(self)\n            if self.dependency_type == Calculated.VALUE_BASED:\n                self._rendered_field = self._field.render(ctx)\n            self._render()\n            ctx.pop()\n        return self._current_rendered", "response": "Render the current value into a bitstring. Bits object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hash(self):\n        '''\n        :rtype: int\n        :return: hash of the field\n        '''\n        hashed = super(Calculated, self).hash()\n        return khash(hashed, self._field_name)", "response": "Returns the hash of the field\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _calculate(self, field):\n        '''\n        We want to avoid trouble, so if the field is not enclosed by any other field,\n        we just return 0.\n        '''\n        encloser = field.enclosing\n        if encloser:\n            rendered = encloser.get_rendered_fields(RenderContext(self))\n            if field not in rendered:\n                value = len(rendered)\n            else:\n                value = rendered.index(field)\n        else:\n            value = 0\n        return value", "response": "Calculate the value of a resource s key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _calculate(self, field):\n        '''\n        If the offset is unknown, return 0\n        '''\n        base_offset = 0\n        if self.base_field is not None:\n            base_offset = self.base_field.offset\n        target_offset = self._field.offset\n        if (target_offset is None) or (base_offset is None):\n            return 0\n        return target_offset - base_offset", "response": "Calculate the offset of the record."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntransmitting a single payload and receive response if expected.", "response": "def transmit(self, payload):\n        '''\n        Transmit single payload, and receive response, if expected.\n        The actual implementation of the send/receive should be in\n        ``_send_to_target`` and ``_receive_from_target``.\n\n        :type payload: str\n        :param payload: payload to send\n        :rtype: str\n        :return: the response (if received)\n        '''\n        response = None\n        trans_report_name = 'transmission_0x%04x' % self.transmission_count\n        trans_report = Report(trans_report_name)\n        self.transmission_report = trans_report\n        self.report.add(trans_report_name, trans_report)\n        try:\n            trans_report.add('request (hex)', hexlify(payload).decode())\n            trans_report.add('request (raw)', '%s' % payload)\n            trans_report.add('request length', len(payload))\n            trans_report.add('request time', time.time())\n\n            request = hexlify(payload).decode()\n            request = request if len(request) < 100 else (request[:100] + ' ...')\n            self.logger.info('request(%d): %s' % (len(payload), request))\n            self._send_to_target(payload)\n            trans_report.success()\n\n            if self.expect_response:\n                try:\n                    response = self._receive_from_target()\n                    trans_report.add('response time', time.time())\n                    trans_report.add('response (hex)', hexlify(response).decode())\n                    trans_report.add('response (raw)', '%s' % response)\n                    trans_report.add('response length', len(response))\n                    printed_response = hexlify(response).decode()\n                    printed_response = printed_response if len(printed_response) < 100 else (printed_response[:100] + ' ...')\n                    self.logger.info('response(%d): %s' % (len(response), printed_response))\n                except Exception as ex2:\n                    trans_report.failed('failed to receive response: %s' % ex2)\n                    trans_report.add('traceback', traceback.format_exc())\n                    self.logger.error('target.transmit - failure in receive (exception: %s)' % ex2)\n                    self.logger.error(traceback.format_exc())\n                    self.receive_failure = True\n            else:\n                response = ''\n        except Exception as ex1:\n            trans_report.failed('failed to send payload: %s' % ex1)\n            trans_report.add('traceback', traceback.format_exc())\n            self.logger.error('target.transmit - failure in send (exception: %s)' % ex1)\n            self.logger.error(traceback.format_exc())\n            self.send_failure = True\n        self.transmission_count += 1\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntriggering the target to start communication with the fuzzer.", "response": "def trigger(self):\n        '''\n        Trigger the target (e.g. the victim application) to start communication with the fuzzer.\n        '''\n        assert(self.controller)\n        self._trigger()\n        self.logger.debug('Waiting for mutation response. (timeout = %d)'\n                          % self.mutation_server_timeout)\n        res = self.response_sent_event.wait(self.mutation_server_timeout)\n        if not res:\n            # mark the controller's report as failed since we did not get a response from the stack\n            # self.controller.report.add('failed', False) ## so it will not appear in the UI\n            # self.controller.report.add('failure_reason', 'trigger timed out')\n            # raise Exception('[%s] Error: trigger timed out (%d)'\n            #                 % (self.name, self.mutation_server_timeout))\n            self.report.error('trigger timed out')\n            self.logger.error('Failure: trigger timed out')\n        else:\n            time.sleep(self.post_fuzz_delay)\n        self.response_sent_event.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strToBytes(value):\n    '''\n    :type value: ``str``\n    :param value: value to encode\n    '''\n    kassert.is_of_types(value, (bytes, bytearray, six.string_types))\n    if isinstance(value, six.string_types):\n        return bytes(bytearray([ord(x) for x in value]))\n    elif isinstance(value, bytearray):\n        return bytes(value)\n    return value", "response": "Convert a string to bytes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strToUtf8(value):\n    '''\n    :type value: ``str``\n    :param value: value to encode\n    '''\n    kassert.is_of_types(value, str)\n    if sys.version_info < (3,):\n        return ''.join([unichr(ord(x)) for x in value])\n    return value", "response": "converts a string to UTF - 8"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nencodes the passed in value into a bitstring.", "response": "def encode(self, value):\n        '''\n        :param value: value to encode\n        '''\n        encoded = strToBytes(value) + b'\\x00'\n        return Bits(bytes=encoded)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode(self, value, length, signed):\n        '''\n        :param value: value to encode\n        :param length: length of value in bits\n        :param signed: is value signed\n        '''\n        if (length % 8 != 0) and self._mode:\n            raise Exception('cannot use endianess for non bytes aligned int')\n        pre = '' if signed else 'u'\n        fmt = '%sint%s:%d=%d' % (pre, self._mode, length, value)\n        return Bits(fmt)", "response": "Encodes the value in bits\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode(self, value, length, signed):\n        '''\n        :param value: value to encode\n        :param length: length of value in bits\n        :param signed: is value signed\n        '''\n        if signed:\n            raise KittyException('Signed MultiBytes not supported yet, sorry')\n\n        # split to septets\n        if value:\n            bytes_arr = []\n            while value:\n                bytes_arr.append((value & 0x7f) | 0x80)\n                value >>= 7\n        else:\n            bytes_arr = [0]\n\n        # reverse if big endian endian\n        if self._mode == 'be':\n            bytes_arr.reverse()\n\n        # remove msb from last byte\n        bytes_arr[-1] = bytes_arr[-1] & 0x7f\n\n        multi_bytes = ''.join(chr(x) for x in bytes_arr)\n        return Bits(bytes=strToBytes(multi_bytes))", "response": "Encodes the value in bits\nAttributeNames to a single byte string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding the nagle_cache_tag field into a string.", "response": "def encode(self, value):\n        '''\n        :param value: value to encode\n        '''\n        kassert.is_of_types(value, Bits)\n        remainder = len(value) % 8\n        if remainder:\n            value += Bits(bin='0' * (8 - remainder))\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencoding the value to a bit array.", "response": "def encode(self, value):\n        '''\n        :param value: value to encode\n        '''\n        kassert.is_of_types(value, Bits)\n        result = BitArray(value)\n        result.reverse()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding the passed in value into a byte string.", "response": "def encode(self, value):\n        '''\n        :param value: value to encode\n        '''\n        kassert.is_of_types(value, Bits)\n        if len(value) % 8 != 0:\n            raise KittyException('this encoder cannot encode bits that are not byte aligned')\n        return self._encoder.encode(value.bytes)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encode(self, value):\n        '''\n        :param value: value to encode\n        '''\n        packed = pack(self.fmt, value)\n        return Bits(bytes=packed)", "response": "Encodes the passed value into a bitstring."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a hash of the given iterable of arguments.", "response": "def khash(*args):\n    '''\n    hash arguments. khash handles None in the same way accross runs (which is good :))\n    '''\n    ksum = sum([hash(arg if arg is not None else -13371337) for arg in args])\n    return hash(str(ksum))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the report from the metadata", "response": "def get_report(self):\n        '''\n        need to wrap get_report, since we need to parse the report\n        '''\n        report_dict = self._meta_get_report()\n        report = Report.from_dict(report_dict)\n        return report"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake sure the target is ready for fuzzing including monitors and controllers.", "response": "def setup(self):\n        '''\n        Make sure the target is ready for fuzzing, including monitors and\n        controllers\n        '''\n        if self.controller:\n            self.controller.setup()\n        for monitor in self.monitors:\n            monitor.setup()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef teardown(self):\n        '''\n        Clean up the target once all tests are completed\n        '''\n        if self.controller:\n            self.controller.teardown()\n        for monitor in self.monitors:\n            monitor.teardown()", "response": "Clean up the target once all tests are completed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstopping the fuzzing session", "response": "def stop(self):\n        '''\n        Stop the fuzzing session\n        '''\n        self.logger.info('Stopping client fuzzer')\n        self._target_control_thread.stop()\n        self.target.signal_mutated()\n        super(ClientFuzzer, self).stop()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if we should fuzz the node.", "response": "def _should_fuzz_node(self, fuzz_node, stage):\n        '''\n        The matching stage is either the name of the last node, or ClientFuzzer.STAGE_ANY.\n\n        :return: True if we are in the correct model node\n        '''\n        if stage == ClientFuzzer.STAGE_ANY:\n            return True\n        if fuzz_node.name.lower() == stage.lower():\n            if self._index_in_path == len(self._fuzz_path) - 1:\n                return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_mutation(self, stage, data):\n        '''\n        Get the next mutation, if in the correct stage\n\n        :param stage: current stage of the stack\n        :param data: a dictionary of items to pass to the model\n        :return: mutated payload if in apropriate stage, None otherwise\n        '''\n        payload = None\n        # Commented out for now: we want to return the same\n        # payload - while inside the same test\n        # if self._keep_running() and self._do_fuzz.is_set():\n        if self._keep_running():\n            fuzz_node = self._fuzz_path[self._index_in_path].dst\n            if self._should_fuzz_node(fuzz_node, stage):\n                fuzz_node.set_session_data(data)\n                payload = fuzz_node.render().tobytes()\n                self._last_payload = payload\n            else:\n                self._update_path_index(stage)\n        if payload:\n            self._notify_mutated()\n        self._requested_stages.append((stage, payload))\n        return payload", "response": "Get the next mutation if in the correct stage"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsign 64 - bit field", "response": "def SInt64(value, min_value=None, max_value=None, encoder=ENC_INT_DEFAULT, fuzzable=True, name=None, full_range=False):\n    '''Signed 64-bit field'''\n    return BitField(value, 64, signed=True, min_value=min_value, max_value=max_value, encoder=encoder, fuzzable=fuzzable, name=name, full_range=full_range)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef BE16(value, min_value=None, max_value=None, fuzzable=True, name=None, full_range=False):\n    '''16-bit field, Big endian encoded'''\n    return UInt16(value, min_value=min_value, max_value=max_value, encoder=ENC_INT_BE, fuzzable=fuzzable, name=name, full_range=full_range)", "response": "16 - bit field Big endian encoded"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a Size field which holds the size in bytes of the sized field.", "response": "def SizeInBytes(sized_field, length, encoder=ENC_INT_DEFAULT, fuzzable=False, name=None):\n    '''\n    :rtype: :class:`~kitty.model.low_level.calculated.Size`\n    :return: Size field, which holds the size in bytes of the sized field\n    '''\n    return Size(sized_field=sized_field, length=length, calc_func=lambda x: len(x) // 8, encoder=encoder, fuzzable=fuzzable, name=name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Md5(depends_on, encoder=ENC_STR_DEFAULT, fuzzable=False, name=None):\n    '''\n    :rtype: :class:`~kitty.model.low_level.calculated.Hash`\n    :return: MD5 hash field\n    '''\n    return Hash(depends_on=depends_on, algorithm='md5', encoder=encoder, fuzzable=fuzzable, name=name)", "response": "Returns a MD5 hash of the given field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrying a system call interrupted by EINTR", "response": "def _eintr_retry(func, *args):\n    \"\"\"restart a system call interrupted by EINTR\"\"\"\n    while True:\n        try:\n            return func(*args)\n        except (OSError, select.error) as e:\n            if e.args[0] != errno.EINTR:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle one request at a time until shutdown.", "response": "def serve_forever(self, poll_interval=0.5):\n        \"\"\"\n        Handle one request at a time until shutdown.\n        Polls for shutdown every poll_interval seconds. Ignores\n        self.timeout. If you need to do periodic tasks, do them in\n        another thread.\n        \"\"\"\n        self.__is_shut_down.clear()\n        try:\n            while not self.__shutdown_request:\n                r, w, e = _eintr_retry(select.select, [self], [], [], poll_interval)\n                if self in r:\n                    self._handle_request_noblock()\n\n        finally:\n            self.__shutdown_request = False\n            self.__is_shut_down.set()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling one request without blocking.", "response": "def _handle_request_noblock(self):\n        \"\"\"\n        Handle one request, without blocking.\n        \"\"\"\n\n        try:\n            request, client_address = self.get_request()\n        except socket.error:\n            return\n\n        if self.verify_request(request, client_address):\n            try:\n                self.process_request(request, client_address)\n            except:\n                self.handle_error(request, client_address)\n                self.shutdown_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbinds the socket to the server address.", "response": "def server_bind(self):\n        \"\"\"\n        Called by constructor to bind the socket.\n        \"\"\"\n\n        if self.allow_reuse_address:\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.socket.bind(self.server_address)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef shutdown_request(self, request):\n\n        try:\n            request.shutdown(socket.SHUT_WR)\n        except socket.error:\n            pass\n\n        self.close_request(request)", "response": "Called to shutdown and close an individual request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_error(self, request, client_address):\n        self.logger.error('-' * 40)\n        self.logger.error('Exception happened during processing of request from %s:%s' % (client_address[0], client_address[1]))\n        self.logger.error(traceback.format_exc())\n        self.logger.error('-' * 40)\n        self.stop()", "response": "Handle an error during processing of a request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_of_types(obj, the_types):\n    '''\n    :param obj: object to assert\n    :param the_types: iterable of types, or a signle type\n    :raise: an exception if obj is not an instance of types\n    '''\n    if not isinstance(obj, the_types):\n        raise KittyException('object type (%s) is not one of (%s)' % (type(obj), the_types))", "response": "asserts that obj is an instance of the_types"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_description(self):\n        '''\n        :return: description string (with listening host:port)\n        '''\n        return '%(description)s listening on %(host)s:%(port)s' % {\n            'description': super(WebInterface, self).get_description(),\n            'host': self._host,\n            'port': self._port\n        }", "response": "returns a string with description of the current object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect(self, src, dst=None, callback=None):\n        '''\n        :param src: source node, if dst is None it will be destination node and the root (dummy) node will be source\n        :param dst: destination node (default: None)\n        :type callback: func(fuzzer, edge, response) -> None\n        :param callback: a function to be called after the response for src received and before dst is sent\n        '''\n        assert src\n        if dst is None:\n            dst = src\n            src = self._root\n        src_id = src.hash()\n        dst_id = dst.hash()\n        if src_id not in self._graph:\n            raise KittyException('source node id (%#x) (%s) is not in the node list ' % (src_id, src))\n        self._graph[src_id].append(Connection(src, dst, callback))\n        if dst_id not in self._graph:\n            self._graph[dst_id] = []", "response": "Connect a source node to a destination node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_loops_in_grpah(self, current=None, visited=[]):\n        '''\n        :param current: current node to check if visited\n        :param visited: list of visited fields\n        :raise: KittyException if loop found\n        '''\n        if current in visited:\n            path = ' -> '.join(v.get_name() for v in (visited + [current]))\n            raise KittyException('loop detected in model: %s' % path)\n        current = current if current else self._root\n        for conn in self._graph[current.hash()]:\n            self.check_loops_in_grpah(conn.dst, visited + [conn.src])", "response": "Check if loops are in GRPAH."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stages(self):\n        '''\n        :return: dictionary of information regarding the stages in the fuzzing session\n\n        .. note::\n\n            structure: { current: ['stage1', 'stage2', 'stage3'], 'stages': {'source1': ['dest1', 'dest2'], 'source2': ['dest1', 'dest3']}}\n        '''\n        sequence = self.get_sequence()\n        stages = {}\n        for seq in self._sequences:\n            for e in seq:\n                if e.src.get_name() not in stages:\n                    stages[e.src.get_name()] = []\n                if e.dst.get_name() not in stages[e.src.get_name()]:\n                    stages[e.src.get_name()].append(e.dst.get_name())\n        return {\n            'current': [e.dst.get_name() for e in sequence],\n            'stages': stages\n        }", "response": "Returns a dictionary of information regarding the stages in the fuzzing session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the report to its defaults. This will clear the report, keeping only the name and setting the failure status to the default.", "response": "def clear(self):\n        '''\n        Set the report to its defaults.\n        This will clear the report, keeping only the name and setting the\n        failure status to the default.\n        '''\n        self._data_fields = {}\n        self._sub_reports = {}\n        self.set_status(Report.FAILED if self._default_failed else Report.PASSED)\n        self.add('name', self._name)\n        self.add('sub_reports', [])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef passed(self):\n        '''\n        Set the report status to PASSED\n        '''\n        self.set_status(Report.PASSED)\n        if 'reason' in self._data_fields:\n            del self._data_fields['reason']", "response": "Sets the status to PASSED and clears the reason field"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef failed(self, reason=None):\n        '''\n        Set the test status to Report.FAILED, and set the failure reason\n\n        :param reason: failure reason (default: None)\n        '''\n        self.set_status(Report.FAILED)\n        if reason:\n            self.add('reason', reason)", "response": "Set the test status to Report. FAILED and set the failure reason"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef error(self, reason=None):\n        '''\n        Set the test status to Report.ERROR, and set the error reason\n\n        :param reason: error reason (default: None)\n        '''\n        self.set_status(Report.ERROR)\n        if reason:\n            self.add('reason', reason)", "response": "Set the test status to Report. ERROR and set the error reason"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the status of the report.", "response": "def set_status(self, new_status):\n        '''\n        Set the status of the report.\n\n        :param new_status: the new status of the report (either PASSED, FAILED or ERROR)\n        '''\n        if new_status not in Report.allowed_statuses:\n            raise Exception('status must be one of: %s' % (', '.join(Report.allowed_statuses)))\n        self._data_fields['status'] = new_status.lower()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds an entry to the report", "response": "def add(self, key, value):\n        '''\n        Add an entry to the report\n\n        :param key: entry's key\n        :param value: the actual value\n\n        :example:\n\n            ::\n\n                my_report.add('retry count', 3)\n        '''\n        if key in self.reserved_keys:\n            raise Exception('You cannot add the key %s directly, use %s' % (key, self.reserved_keys[key]))\n        if isinstance(value, Report):\n            self._sub_reports[key] = value\n            self._data_fields['sub_reports'].append(key)\n        else:\n            self._data_fields[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, key):\n        '''\n        Get a value for a given key\n\n        :param key: entry's key\n        :return: corresponding value\n        '''\n        if key in self._data_fields:\n            return self._data_fields[key]\n        if key in self._sub_reports:\n            return self._sub_reports[key]\n        return None", "response": "Get a value for a given key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary representation of the report.", "response": "def to_dict(self, encoding='base64'):\n        '''\n        Return a dictionary version of the report\n\n        :param encoding: required encoding for the string values (default: 'base64')\n        :rtype: dictionary\n        :return: dictionary representation of the report\n        '''\n        res = {}\n        for k, v in self._data_fields.items():\n            if isinstance(v, (bytes, bytearray, six.string_types)):\n                v = StrEncodeEncoder(encoding).encode(v).tobytes().decode()\n            res[k] = v\n        for k, v in self._sub_reports.items():\n            res[k] = v.to_dict(encoding)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a Report object from a dictionary.", "response": "def from_dict(cls, d, encoding='base64'):\n        '''\n        Construct a ``Report`` object from dictionary.\n\n        :type d: dictionary\n        :param d: dictionary representing the report\n        :param encoding: encoding of strings in the dictionary (default: 'base64')\n        :return: Report object\n        '''\n        report = Report(Report._decode(d['name'], encoding))\n        report.set_status(Report._decode(d['status'], encoding))\n        sub_reports = Report._decode(d['sub_reports'], encoding)\n        del d['sub_reports']\n        for k, v in d.items():\n            if k in sub_reports:\n                report.add(k, Report.from_dict(v))\n            else:\n                if k.lower() == 'status':\n                    report.set_status(Report._decode(v, encoding))\n                else:\n                    report.add(k, Report._decode(v, encoding))\n\n        return report"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the status of the report and its sub - reports.", "response": "def get_status(self):\n        '''\n        Get the status of the report and its sub-reports.\n\n        :rtype: str\n        :return: report status ('passed', 'failed' or 'error')\n        '''\n        status = self.get('status')\n        if status == Report.PASSED:\n            for sr_name in self._sub_reports:\n                sr = self._sub_reports[sr_name]\n                sr_status = sr.get_status()\n                reason = sr.get('reason')\n                if sr_status == Report.ERROR:\n                    self.error(reason)\n                    break\n                if sr_status == Report.FAILED:\n                    self.failed(reason)\n                    break\n            status = self.get('status')\n        return status"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes sure the monitor is ready for fuzzing", "response": "def setup(self):\n        '''\n        Make sure the monitor is ready for fuzzing\n        '''\n        super(BaseMonitor, self).setup()\n        self.monitor_thread = LoopFuncThread(self._monitor_func)\n        self.monitor_thread.start()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self):\n        '''\n        :return: a copy of the container\n        '''\n        dup = super(Container, self).copy()\n        dup._fields = [field.copy() for field in self._fields]\n        dup._fields_dict = {field.get_name(): field for field in dup._fields if field.get_name() is not None}\n        dup._containers = []\n        for container in self._containers:\n            idx = self._fields.index(container)\n            dup._containers.append(dup._fields[idx])\n        for field in dup._fields:\n            field.enclosing = dup\n        return dup", "response": "returns a copy of the container\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hash(self):\n        '''\n        :rtype: int\n        :return: hash of the container\n        '''\n        hashed = super(Container, self).hash()\n        for f in self._fields:\n            f_hashed = f.hash()\n            hashed = khash(hashed + f_hashed)\n        return hashed", "response": "returns the hash of the container\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the number of mutations in the container", "response": "def num_mutations(self):\n        '''\n        :return: number of mutations in the container\n        '''\n        self._initialize()\n        res = super(Container, self).num_mutations()\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render(self, ctx=None):\n        '''\n        :param ctx: rendering context in which the method was called\n        :rtype: `Bits`\n        :return: rendered value of the container\n        '''\n        self._initialize()\n        render_count = 1\n        if ctx is None:\n            ctx = RenderContext()\n            if self._need_second_pass:\n                render_count = 2\n        ctx.push(self)\n        if self.is_default():\n            self._current_rendered = self._default_rendered\n        else:\n            if self.offset is None:\n                self.offset = 0\n            for i in range(render_count):\n                offset = self.offset\n                rendered = BitArray()\n                for field in self._fields:\n                    field.set_offset(offset)\n                    frendered = field.render(ctx)\n                    if not isinstance(frendered, Bits):\n                        raise KittyException('the field %s:%s was rendered to type %s, you should probably wrap it with appropriate encoder' % (\n                            field.get_name(), type(field), type(frendered)))\n                    rendered.append(frendered)\n                    offset += len(frendered)\n                self.set_current_value(rendered)\n        ctx.pop()\n        return self._current_rendered", "response": "render the container and return the rendered value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_offset(self, offset):\n        '''\n        Set the absolute offset of current field,\n        if the field should have default value,\n        set the offset of the sub fields as well.\n\n        :param offset: absolute offset of this field (in bits)\n        '''\n        super(Container, self).set_offset(offset)\n        if self.is_default():\n            for field in self._fields:\n                field.set_offset(offset)\n                offset += len(field._current_rendered)", "response": "Set the absolute offset of the current field and all sub fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset(self):\n        '''\n        Reset the state of the container and its internal fields\n        '''\n        super(Container, self).reset()\n        for field in self._fields:\n            field.reset()\n        self._field_idx = 0", "response": "Reset the state of the container and its internal fields."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scan_for_field(self, field_key):\n        '''\n        Scan for a field in the container and its enclosed fields\n\n        :param field_key: name of field to look for\n        :return: field with name that matches field_key, None if not found\n        '''\n        if field_key == self.get_name():\n            return self\n        if field_key in self._fields_dict:\n            return self._fields_dict[field_key]\n        for field in self._fields:\n            if isinstance(field, Container):\n                resolved = field.scan_for_field(field_key)\n                if resolved:\n                    return resolved\n        return None", "response": "Scan for a field in the container and its enclosed fields and return the name that matches the field_key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset session data in the container enclosed fields", "response": "def set_session_data(self, session_data):\n        '''\n        Set session data in the container enclosed fields\n\n        :param session_data: dictionary of session data\n        '''\n        if session_data:\n            for field in self._fields:\n                if isinstance(field, (Container, Dynamic)):\n                    field.set_session_data(session_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the field is in its default form", "response": "def is_default(self):\n        '''\n        Checks if the field is in its default form\n\n        :return: True if field is in default form\n        '''\n        for field in self._fields:\n            if not field.is_default():\n                return False\n        return super(Container, self).is_default()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _init(self):\n        '''\n        Prepare to run (if not ready)\n        '''\n        num = 0\n        for field in self._fields:\n            field._initialize()\n            self._need_second_pass |= field._need_second_pass\n        for field in self._fields:\n            num += field.num_mutations()\n        self._calculate_mutations(num)\n        self._initialize_default_buffer()", "response": "Initialize the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_field_by_name(self, name):\n        '''\n        :param name: name of field to get\n        :return: direct sub-field with the given name\n        :raises: :class:`~kitty.core.KittyException` if no direct subfield with this name\n        '''\n        if name in self._fields_dict:\n            return self._fields_dict[name]\n        raise KittyException('field named (%s) was not found in (%s)' % (self, name))", "response": "Returns the direct sub - field with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef append_fields(self, new_fields):\n        '''\n        Add fields to the container\n\n        :param new_fields: fields to append\n        '''\n        for field in new_fields:\n            self.push(field)\n            if isinstance(field, Container):\n                self.pop()", "response": "Adds new_fields to the container\n\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_rendered_fields(self, ctx=None):\n        '''\n        :param ctx: rendering context in which the method was called\n        :return: ordered list of the fields that will be rendered\n        '''\n        if ctx is None:\n            ctx = RenderContext()\n        ctx.push(self)\n        result = []\n        for f in self._fields:\n            if len(f.render(ctx)):\n                result.append(f)\n        ctx.pop()\n        return result", "response": "returns a list of the fields that will be rendered"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_info(self):\n        '''\n        Get info regarding the current fuzzed enclosed node\n\n        :return: info dictionary\n        '''\n        field = self._current_field()\n        if field:\n            info = field.get_info()\n            info['path'] = '%s/%s' % (self.name if self.name else '<no name>', info['path'])\n        else:\n            info = super(Container, self).get_info()\n        return info", "response": "Get info regarding the current fuzzed enclosed node\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pop(self):\n        '''\n        Remove a the top container from the container stack\n        '''\n        if not self._containers:\n            raise KittyException('no container to pop')\n        self._containers.pop()\n        if self._container():\n            self._container().pop()", "response": "Remove a the top container from the container stack"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef push(self, field):\n        '''\n        Add a field to the container, if the field is a Container itself, it should be poped() when done pushing into it\n\n        :param field: BaseField to push\n        '''\n        kassert.is_of_types(field, BaseField)\n        container = self._container()\n        field.enclosing = self\n        if isinstance(field, Container):\n            self._containers.append(field)\n        if container:\n            container.push(field)\n        else:\n            name = field.get_name()\n            if name in self._fields_dict:\n                raise KittyException('field with the name (%s) already exists in this container' % (name))\n            if name:\n                self._fields_dict[name] = field\n            self._fields.append(field)\n        return True", "response": "Adds a field to the container"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the hash of the container", "response": "def hash(self):\n        '''\n        :rtype: int\n        :return: hash of the container\n        '''\n        hashed = super(ForEach, self).hash()\n        return khash(hashed + self._mutated_field.hash())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresetting the state of the container and its internal fields.", "response": "def reset(self, reset_mutated=True):\n        '''\n        Reset the state of the container and its internal fields\n\n        :param reset_mutated: should reset the mutated field too (default: True)\n        '''\n        super(ForEach, self).reset()\n        if reset_mutated:\n            self._mutated_field.reset()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_rendered_fields(self, ctx=None):\n        '''\n        :param ctx: rendering context in which the method was called\n        :return: ordered list of the fields that will be rendered\n        '''\n        res = []\n        if ctx is None:\n            ctx = RenderContext()\n        if self._evaluate_condition(ctx):\n            ctx.push(self)\n            res = super(Conditional, self).get_rendered_fields(ctx)\n            ctx.pop()\n        return res", "response": "returns a list of the fields that will be rendered"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy(self):\n        '''\n        Copy the container, put an invalidated copy of the condition in the new container\n        '''\n        dup = super(Conditional, self).copy()\n        condition = self._condition.copy()\n        condition.invalidate(self)\n        dup._condition = condition\n        return dup", "response": "Copy the container put an invalidated copy of the condition in the new container"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the hash of the container", "response": "def hash(self):\n        '''\n        :rtype: int\n        :return: hash of the container\n        '''\n        hashed = super(Conditional, self).hash()\n        return khash(hashed, self._condition.hash())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender the current value of the current container.", "response": "def render(self, ctx=None):\n        '''\n        :param ctx: rendering context in which the method was called\n        :rtype: `Bits`\n        :return: rendered value of the container, padded if needed\n        '''\n        super(Pad, self).render(ctx)\n        self.set_current_value(self._pad_buffer(self._current_rendered))\n        return self._current_rendered"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hash(self):\n        '''\n        :rtype: int\n        :return: hash of the container\n        '''\n        hashed = super(Pad, self).hash()\n        return khash(hashed, self._pad_length, self._pad_data)", "response": "Returns the hash of the container\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_times(self, min_times, max_times, step):\n        '''\n        Make sure that the arguments are valid\n\n        :raises: KittyException if not valid\n        '''\n        kassert.is_int(min_times)\n        kassert.is_int(max_times)\n        kassert.is_int(step)\n        if not((min_times >= 0) and (max_times > 0) and (max_times >= min_times) and (step > 0)):\n            raise KittyException('one of the checks failed: min_times(%d)>=0, max_times(%d)>0, max_times>=min_times, step > 0' % (min_times, max_times))", "response": "Check that the arguments are valid."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering the current value of the container.", "response": "def render(self, ctx=None):\n        '''\n        :param ctx: rendering context in which the method was called\n        :rtype: `Bits`\n        :return: rendered value of the container, repeated\n        '''\n        self._initialize()\n        times = self._min_times\n        if self._mutating() and self._in_repeat_stage():\n            times += (self._current_index) * self._step\n        rendered = super(Repeat, self).render(ctx)\n        self.set_current_value(rendered * times)\n        return self._current_rendered"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_rendered_fields(self, ctx=None):\n        '''\n        :param ctx: rendering context in which the method was called\n        :return: ordered list of the fields that will be rendered\n        '''\n        times = self._min_times\n        if self._mutating() and self._in_repeat_stage():\n            times += (self._current_index) * self._step\n        return super(Repeat, self).get_rendered_fields(ctx) * times", "response": "Returns the list of rendered fields for this repeat."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the hash of the container .", "response": "def hash(self):\n        '''\n        :rtype: int\n        :return: hash of the container\n        '''\n        hashed = super(Repeat, self).hash()\n        return khash(hashed, self._min_times, self._max_times, self._step, self._repeats)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenders only the mutated field or the first one", "response": "def render(self, ctx=None):\n        '''\n        Render only the mutated field (or the first one if not in mutation)\n\n        :param ctx: rendering context in which the method was called\n        :rtype: `Bits`\n        :return: rendered value of the container\n        '''\n        if ctx is None:\n            ctx = RenderContext()\n        ctx.push(self)\n        self._initialize()\n        offset = self.offset if self.offset else 0\n        self._fields[self._field_idx].set_offset(offset)\n        rendered = self._fields[self._field_idx].render(ctx)\n        self.set_current_value(rendered)\n        ctx.pop()\n        return self._current_rendered"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the list of rendered fields", "response": "def get_rendered_fields(self, ctx=None):\n        '''\n        :param ctx: rendering context in which the method was called\n        :return: ordered list of the fields that will be rendered\n        '''\n        if ctx is None:\n            ctx = RenderContext()\n        ctx.push(self)\n        current = self._fields[self._field_idx]\n        res = current.get_rendered_fields(ctx)\n        ctx.pop()\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender only a single field", "response": "def render(self, ctx=None):\n        '''\n        Render only a single field (see class docstring for more details)\n\n        :param ctx: rendering context in which the method was called\n        :rtype: `Bits`\n        :return: rendered value of the container\n        '''\n        if ctx is None:\n            ctx = RenderContext()\n        ctx.push(self)\n        self._initialize()\n        offset = self.offset if self.offset else 0\n        if self._mutating():\n            field_idx = self._field_idx\n        else:\n            key_field = self.resolve_field(self._key_field)\n            key_from_key_field = key_field._current_value\n            if key_from_key_field in self._keys:\n                field_idx = self._keys.index(key_from_key_field)\n            else:\n                field_idx = 0  # default value\n        self._fields[field_idx].set_offset(offset)\n        rendered = self._fields[field_idx].render(ctx)\n        self.set_current_value(rendered)\n        ctx.pop()\n        return self._current_rendered"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrebuild the internal fields of the class.", "response": "def _rebuild_fields(self):\n        '''\n        We take the original fields and create subsets of them, each subset will be set into a container.\n        all the resulted containers will then replace the original _fields, since we inherit from OneOf each time only one of them will be mutated and used.\n        This is super ugly and dangerous, any idea how to implement it in a better way is welcome.\n        '''\n        # generate new lists\n        new_field_lists = []\n        field_list_len = self.min_elements\n        while not field_list_len > self.max_elements:\n            how_many = self.max_elements + 1 - field_list_len\n            i = 0\n            while i < how_many:\n                current = self.random.sample(self._fields, field_list_len)\n                if current not in new_field_lists:\n                    new_field_lists.append(current)\n                    i += 1\n            field_list_len += 1\n        # put each list in a container\n        new_containers = []\n        for i, fields in enumerate(new_field_lists):\n            # self.logger.info(fields)\n            dup_fields = [field.copy() for field in fields]\n            if self.get_name():\n                name = '%s_sublist_%d' % (self.get_name(), i)\n            else:\n                name = 'sublist_%d' % (i)\n            new_containers.append(Container(fields=dup_fields, encoder=self.subcontainer_encoder, name=name))\n        self.replace_fields(new_containers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reset(self):\n        '''\n        Reset the state of the container and its internal fields\n        '''\n        super(TakeFrom, self).reset()\n        self.random.seed(self.seed * self.max_elements + self.min_elements)", "response": "Reset the state of the container and its internal fields\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hash(self):\n        '''\n        :rtype: int\n        :return: hash of the container\n        '''\n        hashed = super(TakeFrom, self).hash()\n        return khash(hashed, self.min_elements, self.max_elements, self.seed)", "response": "Returns the hash of the take from container entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_info(self):\n        '''\n        Get info regarding the current template state\n\n        :return: info dictionary\n        '''\n        self.render()\n        info = super(Template, self).get_info()\n        res = {}\n        res['name'] = self.get_name()\n        res['mutation'] = {\n            'current_index': self._current_index,\n            'total_number': self.num_mutations()\n        }\n        res['value'] = {\n            'rendered': {\n                'base64': b64encode(self._current_rendered.tobytes()).decode(),\n                'length_in_bytes': len(self._current_rendered.tobytes()),\n            }\n        }\n        res['hash'] = self.hash()\n        res['field'] = info\n        return res", "response": "Get info regarding the current template state state\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render(self, ctx=None):\n        '''\n        :param ctx: rendering context in which the method was called\n        :rtype: `Bits`\n        :return: rendered value of the container\n        '''\n        super(Trunc, self).render(ctx)\n        self._current_value = self._current_rendered\n        self._current_rendered = self._current_rendered[:self._max_size]\n        return self._current_rendered", "response": "Render the current value of the container\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hash(self):\n        '''\n        :rtype: int\n        :return: hash of the container\n        '''\n        hashed = super(Trunc, self).hash()\n        return khash(hashed, self._max_size)", "response": "Returns the hash of the container\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef invalidate(self, container):\n        '''\n        :param container: the container that tries to invalidate the condition\n        '''\n        self._get_ready(container)\n        field_name = self._field.get_name()\n        if field_name is None:\n            raise KittyException('Cannot invalidate field without name')\n        self._field_name = field_name\n        self._field = None", "response": "invalidates the current condition"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the condition applies to the caller s container.", "response": "def applies(self, container, ctx):\n        '''\n        Subclasses should not override `applies`, but instead they should override `_applies`, which has the same syntax as `applies`.\n        In the `_applies` method the condition is guaranteed to have a reference to the desired field, as `self._field`.\n\n        :type container: :class:`~kitty.model.low_level.container.Container`\n        :param container: the caller\n        :param ctx: rendering context in which applies was called\n        :return: True if condition applies, False otherwise\n        '''\n        self._get_ready(container)\n        return self._applies(container, ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the hash of the condition", "response": "def hash(self):\n        '''\n        :rtype: int\n        :return: hash of the condition\n        '''\n        hashed = super(Compare, self).hash()\n        return khash(hashed, self._comp_value, self._comp_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_keypair(keysize, id, output):\n    log(\"Generating a paillier keypair with keysize of {}\".format(keysize))\n    pub, priv = phe.generate_paillier_keypair(n_length=keysize)\n\n    log(\"Keys generated\")\n\n    date = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    jwk_public = {\n        'kty': \"DAJ\",\n        'alg': \"PAI-GN1\",\n        \"key_ops\": [\"encrypt\"],\n        'n': phe.util.int_to_base64(pub.n),\n        'kid': \"Paillier public key generated by pheutil on {}\".format(date)\n    }\n\n    jwk_private = {\n        'kty': \"DAJ\",\n        'key_ops': [\"decrypt\"],\n        'p': phe.util.int_to_base64(priv.p),\n        'q': phe.util.int_to_base64(priv.q),\n        'pub': jwk_public,\n        'kid': \"Paillier private key generated by pheutil on {}\".format(date)\n    }\n\n    json.dump(jwk_private, output)\n    output.write('\\n')\n\n    log(\"Private key written to {}\".format(output.name))", "response": "Generate a paillier private key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract public key from private key file.", "response": "def extract(input, output):\n    \"\"\"Extract public key from private key.\n\n    Given INPUT a private paillier key file as generated by generate, extract the\n    public key portion to OUTPUT.\n\n    Use \"-\" to output to stdout.\n    \"\"\"\n    log(\"Loading paillier keypair\")\n    priv = json.load(input)\n    error_msg = \"Invalid private key\"\n    assert 'pub' in priv, error_msg\n    assert priv['kty'] == 'DAJ', error_msg\n    json.dump(priv['pub'], output)\n    output.write('\\n')\n    log(\"Public key written to {}\".format(output.name))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encrypt(public, plaintext, output=None):\n    num = float(plaintext)\n\n    log(\"Loading public key\")\n    publickeydata = json.load(public)\n    pub = load_public_key(publickeydata)\n\n    log(\"Encrypting: {:+.16f}\".format(num))\n    enc = pub.encrypt(num)\n    serialised = serialise_encrypted(enc)\n    print(serialised, file=output)", "response": "Encrypt a number with public key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_encrypted(public, encrypted_a, encrypted_b, output):\n    log(\"Loading public key\")\n    publickeydata = json.load(public)\n    pub = load_public_key(publickeydata)\n\n    log(\"Loading first encrypted number\")\n    enc_a = load_encrypted_number(encrypted_a, pub)\n\n    log(\"Loading second encrypted number\")\n    enc_b = load_encrypted_number(encrypted_b, pub)\n\n    log(\"Adding encrypted numbers together\")\n\n    enc_result = enc_a + enc_b\n    serialised_result = serialise_encrypted(enc_result)\n    print(serialised_result, file=output)", "response": "Add two encrypted numbers together."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmultiply encrypted num with unencrypted num.", "response": "def multiply_encrypted_to_plaintext(public, encrypted, plaintext, output):\n    \"\"\"Multiply encrypted num with unencrypted num.\n\n    Requires a PUBLIC key file, a number ENCRYPTED with that public key\n    also as a file, and the PLAINTEXT number to multiply.\n\n    Creates a new encrypted number.\n    \"\"\"\n    log(\"Loading public key\")\n    publickeydata = json.load(public)\n    pub = load_public_key(publickeydata)\n\n    log(\"Loading encrypted number\")\n    enc = load_encrypted_number(encrypted, pub)\n\n    log(\"Loading unencrypted number\")\n    num = float(plaintext)\n\n    log(\"Multiplying\")\n    enc_result = enc * num\n\n    serialised_result = serialise_encrypted(enc_result)\n    print(serialised_result, file=output)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading two sets of Enron1 spam and ham e - mails from the same folder.", "response": "def download_data():\n    \"\"\"Download two sets of Enron1 spam/ham e-mails if they are not here\n    We will use the first as trainset and the second as testset.\n    Return the path prefix to us to load the data from disk.\"\"\"\n\n    n_datasets = 2\n    for d in range(1, n_datasets + 1):\n        if not os.path.isdir('enron%d' % d):\n\n            URL = url[d-1]\n            print(\"Downloading %d/%d: %s\" % (d, n_datasets, URL))\n            folderzip = 'enron%d.zip' % d\n\n            with urlopen(URL) as remotedata:\n                with open(folderzip, 'wb') as z:\n                    z.write(remotedata.read())\n\n            with ZipFile(folderzip) as z:\n                z.extractall()\n            os.remove(folderzip)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef preprocess_data():\n\n    print(\"Importing dataset from disk...\")\n    path = 'enron1/ham/'\n    ham1 = [open(path + f, 'r', errors='replace').read().strip(r\"\\n\")\n            for f in os.listdir(path) if os.path.isfile(path + f)]\n    path = 'enron1/spam/'\n    spam1 = [open(path + f, 'r', errors='replace').read().strip(r\"\\n\")\n             for f in os.listdir(path) if os.path.isfile(path + f)]\n    path = 'enron2/ham/'\n    ham2 = [open(path + f, 'r', errors='replace').read().strip(r\"\\n\")\n            for f in os.listdir(path) if os.path.isfile(path + f)]\n    path = 'enron2/spam/'\n    spam2 = [open(path + f, 'r', errors='replace').read().strip(r\"\\n\")\n             for f in os.listdir(path) if os.path.isfile(path + f)]\n\n    # Merge and create labels\n    emails = ham1 + spam1 + ham2 + spam2\n    y = np.array([-1] * len(ham1) + [1] * len(spam1) +\n                 [-1] * len(ham2) + [1] * len(spam2))\n\n    # Words count, keep only frequent words\n    count_vect = CountVectorizer(decode_error='replace', stop_words='english',\n                                 min_df=0.001)\n    X = count_vect.fit_transform(emails)\n\n    print('Vocabulary size: %d' % X.shape[1])\n\n    # Shuffle\n    perm = np.random.permutation(X.shape[0])\n    X, y = X[perm, :], y[perm]\n\n    # Split train and test\n    split = 500\n    X_train, X_test = X[-split:, :], X[:-split, :]\n    y_train, y_test = y[-split:], y[:-split]\n\n    print(\"Labels in trainset are {:.2f} spam : {:.2f} ham\".format(\n        np.mean(y_train == 1), np.mean(y_train == -1)))\n\n    return X_train, y_train, X_test, y_test", "response": "Read the enron e - mails from disk and merge them as bag - of - words."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the score of x by multiplying with the encrypted model and the encrypted model weights.", "response": "def encrypted_score(self, x):\n        \"\"\"Compute the score of `x` by multiplying with the encrypted model,\n        which is a vector of `paillier.EncryptedNumber`\"\"\"\n        score = self.intercept\n        _, idx = x.nonzero()\n        for i in idx:\n            score += x[0, i] * self.weights[i]\n        return score"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_data(n_clients):\n    print(\"Loading data\")\n    diabetes = load_diabetes()\n    y = diabetes.target\n    X = diabetes.data\n    # Add constant to emulate intercept\n    X = np.c_[X, np.ones(X.shape[0])]\n\n    # The features are already preprocessed\n    # Shuffle\n    perm = np.random.permutation(X.shape[0])\n    X, y = X[perm, :], y[perm]\n\n    # Select test at random\n    test_size = 50\n    test_idx = np.random.choice(X.shape[0], size=test_size, replace=False)\n    train_idx = np.ones(X.shape[0], dtype=bool)\n    train_idx[test_idx] = False\n    X_test, y_test = X[test_idx, :], y[test_idx]\n    X_train, y_train = X[train_idx, :], y[train_idx]\n\n    # Split train among multiple clients.\n    # The selection is not at random. We simulate the fact that each client\n    # sees a potentially very different sample of patients.\n    X, y = [], []\n    step = int(X_train.shape[0] / n_clients)\n    for c in range(n_clients):\n        X.append(X_train[step * c: step * (c + 1), :])\n        y.append(y_train[step * c: step * (c + 1)])\n\n    return X, y, X_test, y_test", "response": "Load the data from sklearn and split them into training target lists for n_clients and a holdout test set."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_gradient(self):\n        delta = self.predict(self.X) - self.y\n        return delta.dot(self.X) / len(self.X)", "response": "Compute the gradient of the current model using the training set\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute and encrypt gradient.", "response": "def encrypted_gradient(self, sum_to=None):\n        \"\"\"Compute and encrypt gradient.\n\n        When `sum_to` is given, sum the encrypted gradient to it, assumed\n        to be another vector of the same size\n        \"\"\"\n        gradient = self.compute_gradient()\n        encrypted_gradient = encrypt_vector(self.pubkey, gradient)\n\n        if sum_to is not None:\n            return sum_encrypted_vectors(sum_to, encrypted_gradient)\n        else:\n            return encrypted_gradient"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a new public key and private key.", "response": "def generate_paillier_keypair(private_keyring=None, n_length=DEFAULT_KEYSIZE):\n    \"\"\"Return a new :class:`PaillierPublicKey` and :class:`PaillierPrivateKey`.\n\n    Add the private key to *private_keyring* if given.\n\n    Args:\n      private_keyring (PaillierPrivateKeyring): a\n        :class:`PaillierPrivateKeyring` on which to store the private\n        key.\n      n_length: key size in bits.\n\n    Returns:\n      tuple: The generated :class:`PaillierPublicKey` and\n      :class:`PaillierPrivateKey`\n    \"\"\"\n    p = q = n = None\n    n_len = 0\n    while n_len != n_length:\n        p = getprimeover(n_length // 2)\n        q = p\n        while q == p:\n            q = getprimeover(n_length // 2)\n        n = p * q\n        n_len = n.bit_length()\n\n    public_key = PaillierPublicKey(n)\n    private_key = PaillierPrivateKey(public_key, p, q)\n\n    if private_keyring is not None:\n        private_keyring.add(private_key)\n\n    return public_key, private_key"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encrypt(self, value, precision=None, r_value=None):\n\n        if isinstance(value, EncodedNumber):\n            encoding = value\n        else:\n            encoding = EncodedNumber.encode(self, value, precision)\n\n        return self.encrypt_encoded(encoding, r_value)", "response": "Encode and Paillier encrypt a real number or float."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encrypt_encoded(self, encoding, r_value):\n        # If r_value is None, obfuscate in a call to .obfuscate() (below)\n        obfuscator = r_value or 1\n        ciphertext = self.raw_encrypt(encoding.encoding, r_value=obfuscator)\n        encrypted_number = EncryptedNumber(self, ciphertext, encoding.exponent)\n        if r_value is None:\n            encrypted_number.obfuscate()\n        return encrypted_number", "response": "Paillier encrypt an encoded value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_totient(public_key, totient):\n        p_plus_q = public_key.n - totient + 1\n        p_minus_q = isqrt(p_plus_q * p_plus_q - public_key.n * 4)\n        q = (p_plus_q - p_minus_q) // 2\n        p = p_plus_q - q\n        if not p*q == public_key.n:\n            raise ValueError('given public key and totient do not match.')\n        return PaillierPrivateKey(public_key, p, q)", "response": "given the totient one can factorize the modulus\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the :class:`EncodedNumber` decrypted from *encrypted_number*. Args: encrypted_number (EncryptedNumber): an :class:`EncryptedNumber` with a public key that matches this private key. Encoding (class): A class to use instead of :class:`EncodedNumber`, the encoding used for the *encrypted_number* - used to support alternative encodings. Returns: :class:`EncodedNumber`: The decrypted plaintext. Raises: TypeError: If *encrypted_number* is not an :class:`EncryptedNumber`. ValueError: If *encrypted_number* was encrypted against a different key.", "response": "def decrypt_encoded(self, encrypted_number, Encoding=None):\n        \"\"\"Return the :class:`EncodedNumber` decrypted from *encrypted_number*.\n\n        Args:\n          encrypted_number (EncryptedNumber): an\n            :class:`EncryptedNumber` with a public key that matches this\n            private key.\n          Encoding (class): A class to use instead of :class:`EncodedNumber`, the\n            encoding used for the *encrypted_number* - used to support alternative\n            encodings.\n\n        Returns:\n          :class:`EncodedNumber`: The decrypted plaintext.\n\n        Raises:\n          TypeError: If *encrypted_number* is not an\n            :class:`EncryptedNumber`.\n          ValueError: If *encrypted_number* was encrypted against a\n            different key.\n        \"\"\"\n        if not isinstance(encrypted_number, EncryptedNumber):\n            raise TypeError('Expected encrypted_number to be an EncryptedNumber'\n                            ' not: %s' % type(encrypted_number))\n\n        if self.public_key != encrypted_number.public_key:\n            raise ValueError('encrypted_number was encrypted against a '\n                             'different key!')\n\n        if Encoding is None:\n            Encoding = EncodedNumber\n\n        encoded = self.raw_decrypt(encrypted_number.ciphertext(be_secure=False))\n        return Encoding(self.public_key, encoded,\n                             encrypted_number.exponent)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the h - function as defined in Paillier s paper page 12.", "response": "def h_function(self, x, xsquare):\n        \"\"\"Computes the h-function as defined in Paillier's paper page 12,\n        'Decryption using Chinese-remaindering'.\n        \"\"\"\n        return invert(self.l_function(powmod(self.public_key.g, x - 1, xsquare),x), x)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a key to the keyring.", "response": "def add(self, private_key):\n        \"\"\"Add a key to the keyring.\n\n        Args:\n          private_key (PaillierPrivateKey): a key to add to this keyring.\n        \"\"\"\n        if not isinstance(private_key, PaillierPrivateKey):\n            raise TypeError(\"private_key should be of type PaillierPrivateKey, \"\n                            \"not %s\" % type(private_key))\n        self.__keyring[private_key.public_key] = private_key"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decrypt(self, encrypted_number):\n        relevant_private_key = self.__keyring[encrypted_number.public_key]\n        return relevant_private_key.decrypt(encrypted_number)", "response": "Decrypts the plaintext of encrypted_number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ciphertext(self, be_secure=True):\n        if be_secure and not self.__is_obfuscated:\n            self.obfuscate()\n\n        return self.__ciphertext", "response": "Return the ciphertext of the EncryptedNumber."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decrease_exponent_to(self, new_exp):\n        if new_exp > self.exponent:\n            raise ValueError('New exponent %i should be more negative than '\n                             'old exponent %i' % (new_exp, self.exponent))\n        multiplied = self * pow(EncodedNumber.BASE, self.exponent - new_exp)\n        multiplied.exponent = new_exp\n        return multiplied", "response": "Return an EncryptedNumber with same value but lower exponent."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef obfuscate(self):\n        r = self.public_key.get_random_lt_n()\n        r_pow_n = powmod(r, self.public_key.n, self.public_key.nsquare)\n        self.__ciphertext = self.__ciphertext * r_pow_n % self.public_key.nsquare\n        self.__is_obfuscated = True", "response": "Disguise ciphertext by multiplying by r ** n with random r."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_scalar(self, scalar):\n        encoded = EncodedNumber.encode(self.public_key, scalar,\n                                       max_exponent=self.exponent)\n\n        return self._add_encoded(encoded)", "response": "Adds a scalar to the internal representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _add_encoded(self, encoded):\n        if self.public_key != encoded.public_key:\n            raise ValueError(\"Attempted to add numbers encoded against \"\n                             \"different public keys!\")\n\n        # In order to add two numbers, their exponents must match.\n        a, b = self, encoded\n        if a.exponent > b.exponent:\n            a = self.decrease_exponent_to(b.exponent)\n        elif a.exponent < b.exponent:\n            b = b.decrease_exponent_to(a.exponent)\n\n        # Don't bother to salt/obfuscate in a basic operation, do it\n        # just before leaving the computer.\n        encrypted_scalar = a.public_key.raw_encrypt(b.encoding, 1)\n\n        sum_ciphertext = a._raw_add(a.ciphertext(False), encrypted_scalar)\n        return EncryptedNumber(a.public_key, sum_ciphertext, a.exponent)", "response": "Adds an encoded number to the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_encrypted(self, other):\n        if self.public_key != other.public_key:\n            raise ValueError(\"Attempted to add numbers encrypted against \"\n                             \"different public keys!\")\n\n        # In order to add two numbers, their exponents must match.\n        a, b = self, other\n        if a.exponent > b.exponent:\n            a = self.decrease_exponent_to(b.exponent)\n        elif a.exponent < b.exponent:\n            b = b.decrease_exponent_to(a.exponent)\n\n        sum_ciphertext = a._raw_add(a.ciphertext(False), b.ciphertext(False))\n        return EncryptedNumber(a.public_key, sum_ciphertext, a.exponent)", "response": "Adds two encrypted numbers."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the integer E(a * plaintext), where E(a) = ciphertext Args: plaintext (int): number by which to multiply the `EncryptedNumber`. *plaintext* is typically an encoding. 0 <= *plaintext* < :attr:`~PaillierPublicKey.n` Returns: int: Encryption of the product of `self` and the scalar encoded in *plaintext*. Raises: TypeError: if *plaintext* is not an int. ValueError: if *plaintext* is not between 0 and :attr:`PaillierPublicKey.n`.", "response": "def _raw_mul(self, plaintext):\n        \"\"\"Returns the integer E(a * plaintext), where E(a) = ciphertext\n\n        Args:\n          plaintext (int): number by which to multiply the\n            `EncryptedNumber`. *plaintext* is typically an encoding.\n            0 <= *plaintext* < :attr:`~PaillierPublicKey.n`\n\n        Returns:\n          int: Encryption of the product of `self` and the scalar\n            encoded in *plaintext*.\n\n        Raises:\n          TypeError: if *plaintext* is not an int.\n          ValueError: if *plaintext* is not between 0 and\n            :attr:`PaillierPublicKey.n`.\n        \"\"\"\n        if not isinstance(plaintext, int):\n            raise TypeError('Expected ciphertext to be int, not %s' %\n                type(plaintext))\n\n        if plaintext < 0 or plaintext >= self.public_key.n:\n            raise ValueError('Scalar out of bounds: %i' % plaintext)\n\n        if self.public_key.n - self.public_key.max_int <= plaintext:\n            # Very large plaintext, play a sneaky trick using inverses\n            neg_c = invert(self.ciphertext(False), self.public_key.nsquare)\n            neg_scalar = self.public_key.n - plaintext\n            return powmod(neg_c, neg_scalar, self.public_key.nsquare)\n        else:\n            return powmod(self.ciphertext(False), plaintext, self.public_key.nsquare)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode(cls, public_key, scalar, precision=None, max_exponent=None):\n        # Calculate the maximum exponent for desired precision\n        if precision is None:\n            if isinstance(scalar, int):\n                prec_exponent = 0\n            elif isinstance(scalar, float):\n                # Encode with *at least* as much precision as the python float\n                # What's the base-2 exponent on the float?\n                bin_flt_exponent = math.frexp(scalar)[1]\n\n                # What's the base-2 exponent of the least significant bit?\n                # The least significant bit has value 2 ** bin_lsb_exponent\n                bin_lsb_exponent = bin_flt_exponent - cls.FLOAT_MANTISSA_BITS\n\n                # What's the corresponding base BASE exponent? Round that down.\n                prec_exponent = math.floor(bin_lsb_exponent / cls.LOG2_BASE)\n            else:\n                raise TypeError(\"Don't know the precision of type %s.\"\n                                % type(scalar))\n        else:\n            prec_exponent = math.floor(math.log(precision, cls.BASE))\n\n        # Remember exponents are negative for numbers < 1.\n        # If we're going to store numbers with a more negative\n        # exponent than demanded by the precision, then we may\n        # as well bump up the actual precision.\n        if max_exponent is None:\n            exponent = prec_exponent\n        else:\n            exponent = min(max_exponent, prec_exponent)\n\n        # Use rationals instead of floats to avoid overflow.\n        int_rep = round(fractions.Fraction(scalar)\n                        * fractions.Fraction(cls.BASE) ** -exponent)\n\n        if abs(int_rep) > public_key.max_int:\n            raise ValueError('Integer needs to be within +/- %d but got %d'\n                             % (public_key.max_int, int_rep))\n\n        # Wrap negative numbers by adding n\n        return cls(public_key, int_rep % public_key.n, exponent)", "response": "Return an encoding of an integer or float."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode(self):\n        if self.encoding >= self.public_key.n:\n            # Should be mod n\n            raise ValueError('Attempted to decode corrupted number')\n        elif self.encoding <= self.public_key.max_int:\n            # Positive\n            mantissa = self.encoding\n        elif self.encoding >= self.public_key.n - self.public_key.max_int:\n            # Negative\n            mantissa = self.encoding - self.public_key.n\n        else:\n            raise OverflowError('Overflow detected in decrypted number')\n\n        if self.exponent >= 0:\n            # Integer multiplication. This is exact.\n            return mantissa * self.BASE ** self.exponent\n        else:\n            # BASE ** -e is an integer, so below is a division of ints.\n            # Not coercing mantissa to float prevents some overflows.\n            try:\n                return mantissa / self.BASE ** -self.exponent\n            except OverflowError as e:\n                raise OverflowError(\n                    'decoded result too large for a float') from e", "response": "Decode plaintext and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an instance with same value but lower exponent.", "response": "def decrease_exponent_to(self, new_exp):\n        \"\"\"Return an `EncodedNumber` with same value but lower exponent.\n\n        If we multiply the encoded value by :attr:`BASE` and decrement\n        :attr:`exponent`, then the decoded value does not change. Thus\n        we can almost arbitrarily ratchet down the exponent of an\n        :class:`EncodedNumber` - we only run into trouble when the encoded\n        integer overflows. There may not be a warning if this happens.\n\n        This is necessary when adding :class:`EncodedNumber` instances,\n        and can also be useful to hide information about the precision\n        of numbers - e.g. a protocol can fix the exponent of all\n        transmitted :class:`EncodedNumber` to some lower bound(s).\n\n        Args:\n          new_exp (int): the desired exponent.\n\n        Returns:\n          EncodedNumber: Instance with the same value and desired\n            exponent.\n\n        Raises:\n          ValueError: You tried to increase the exponent, which can't be\n            done without decryption.\n        \"\"\"\n        if new_exp > self.exponent:\n            raise ValueError('New exponent %i should be more negative than'\n                             'old exponent %i' % (new_exp, self.exponent))\n        factor = pow(self.BASE, self.exponent - new_exp)\n        new_enc = self.encoding * factor % self.public_key.n\n        return self.__class__(self.public_key, new_enc, new_exp)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef powmod(a, b, c):\n    if a == 1:\n        return 1\n    if not HAVE_GMP or max(a, b, c) < _USE_MOD_FROM_GMP_SIZE:\n        return pow(a, b, c)\n    else:\n        return int(gmpy2.powmod(a, b, c))", "response": "A simple powmod implementation that uses GMP if available to do a^b mod c where a b c are integers."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextending Euclidean algorithm for the current version of the algorithm.", "response": "def extended_euclidean_algorithm(a, b):\n    \"\"\"Extended Euclidean algorithm\n\n    Returns r, s, t such that r = s*a + t*b and r is gcd(a, b)\n\n    See <https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm>\n    \"\"\"\n    r0, r1 = a, b\n    s0, s1 = 1, 0\n    t0, t1 = 0, 1\n    while r1 != 0:\n        q = r0 // r1\n        r0, r1 = r1, r0 - q*r1\n        s0, s1 = s1, s0 - q*s1\n        t0, t1 = t1, t0 - q*t1\n    return r0, s0, t0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninverts a multiplicitive inverse of b.", "response": "def invert(a, b):\n    \"\"\"\n    The multiplicitive inverse of a in the integers modulo b.\n\n    :return int: x, where a * x == 1 mod b\n    \"\"\"\n    if HAVE_GMP:\n        s = int(gmpy2.invert(a, b))\n        # according to documentation, gmpy2.invert might return 0 on\n        # non-invertible element, although it seems to actually raise an\n        # exception; for consistency, we always raise the exception\n        if s == 0:\n            raise ZeroDivisionError('invert() no inverse exists')\n        return s\n    else:\n        r, s, _ = extended_euclidean_algorithm(a, b)\n        if r != 1:\n            raise ZeroDivisionError('invert() no inverse exists')\n        return s % b"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getprimeover(N):\n    if HAVE_GMP:\n        randfunc = random.SystemRandom()\n        r = gmpy2.mpz(randfunc.getrandbits(N))\n        r = gmpy2.bit_set(r, N - 1)\n        return int(gmpy2.next_prime(r))\n    elif HAVE_CRYPTO:\n        return number.getPrime(N, os.urandom)\n    else:\n        randfunc = random.SystemRandom()\n        n = randfunc.randrange(2**(N-1), 2**N) | 1\n        while not is_prime(n):\n            n += 2\n        return n", "response": "Return a random N - bit prime number using the System s best\n    Cryptographic random source."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef improved_i_sqrt(n):\n    assert n >= 0\n    if n == 0:\n        return 0\n    i = n.bit_length() >> 1    # i = floor( (1 + floor(log_2(n))) / 2 )\n    m = 1 << i    # m = 2^i\n    #\n    # Fact: (2^(i + 1))^2 > n, so m has at least as many bits\n    # as the floor of the square root of n.\n    #\n    # Proof: (2^(i+1))^2 = 2^(2i + 2) >= 2^(floor(log_2(n)) + 2)\n    # >= 2^(ceil(log_2(n) + 1) >= 2^(log_2(n) + 1) > 2^(log_2(n)) = n. QED.\n    #\n    while (m << i) > n: # (m<<i) = m*(2^i) = m*m\n        m >>= 1\n        i -= 1\n    d = n - (m << i) # d = n-m^2\n    for k in range(i-1, -1, -1):\n        j = 1 << k\n        new_diff = d - (((m<<1) | j) << k) # n-(m+2^k)^2 = n-m^2-2*m*2^k-2^(2k)\n        if new_diff >= 0:\n            d = new_diff\n            m |= j\n    return m", "response": "A function that returns the integer square root of n."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef miller_rabin(n, k):\n    assert n > 3\n\n    # find r and d such that n-1 = 2^r \u00d7 d\n    d = n-1\n    r = 0\n    while d % 2 == 0:\n        d //= 2\n        r += 1\n    assert n-1 == d * 2**r\n    assert d % 2 == 1\n\n    for _ in range(k):  # each iteration divides risk of false prime by 4\n        a = random.randint(2, n-2)  # choose a random witness\n\n        x = pow(a, d, n)\n        if x == 1 or x == n-1:\n            continue  # go to next witness\n\n        for _ in range(1, r):\n            x = x*x % n\n            if x == n-1:\n                break   # go to next witness\n        else:\n            return False\n    return True", "response": "Run the Miller - Rabin test on n with at most k iterations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntesting whether n is probably prime with Miller - Rabin iterations.", "response": "def is_prime(n, mr_rounds=25):\n    \"\"\"Test whether n is probably prime\n\n    See <https://en.wikipedia.org/wiki/Primality_test#Probabilistic_tests>\n\n    Arguments:\n        n (int): the number to be tested\n        mr_rounds (int, optional): number of Miller-Rabin iterations to run;\n            defaults to 25 iterations, which is what the GMP library uses\n\n    Returns:\n        bool: when this function returns False, `n` is composite (not prime);\n        when it returns True, `n` is prime with overwhelming probability\n    \"\"\"\n    # as an optimization we quickly detect small primes using the list above\n    if n <= first_primes[-1]:\n        return n in first_primes\n    # for small dividors (relatively frequent), euclidean division is best\n    for p in first_primes:\n        if n % p == 0:\n            return False\n    # the actual generic test; give a false prime with probability 2\u207b\u2075\u2070\n    return miller_rabin(n, mr_rounds)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef findCommunities(G):\n\t\n\tinfomapWrapper = infomap.Infomap(\"--two-level\")\n\n\tprint(\"Building Infomap network from a NetworkX graph...\")\n\tfor e in G.edges():\n\t\tinfomapWrapper.addLink(*e)\n\n\tprint(\"Find communities with Infomap...\")\n\tinfomapWrapper.run();\n\n\ttree = infomapWrapper.tree\n\n\tprint(\"Found %d top modules with codelength: %f\" % (tree.numTopModules(), tree.codelength()))\n\n\tcommunities = {}\n\tfor node in tree.leafIter():\n\t\tcommunities[node.originalLeafIndex] = node.moduleIndex()\n\n\tnx.set_node_attributes(G, name='community', values=communities)\n\treturn tree.numTopModules()", "response": "Find communities in a network."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the bluetooth controller is available.", "response": "def setup(self):\n        \"\"\"Check if the bluetooth controller is available.\"\"\"\n        try:\n            subprocess.check_output([\"hcitool\", \"clock\"],\n                                    stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError:\n            raise BackendError(\"'hcitool clock' returned error. Make sure \"\n                               \"your bluetooth device is powered up with \"\n                               \"'hciconfig hciX up'.\")\n        except OSError:\n            raise BackendError(\"'hcitool' could not be found, make sure you \"\n                               \"have bluez-utils installed.\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nscan for bluetooth devices.", "response": "def scan(self):\n        \"\"\"Scan for bluetooth devices.\"\"\"\n        try:\n            res = subprocess.check_output([\"hcitool\", \"scan\", \"--flush\"],\n                                          stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError:\n             raise BackendError(\"'hcitool scan' returned error. Make sure \"\n                                \"your bluetooth device is powered up with \"\n                                \"'hciconfig hciX up'.\")\n\n        devices = []\n        res = res.splitlines()[1:]\n        for _, bdaddr, name in map(lambda l: l.split(b\"\\t\"), res):\n            devices.append((bdaddr.decode(\"utf8\"), name.decode(\"utf8\")))\n\n        return devices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nscanning for bluetooth devices and return a DS4 device.", "response": "def find_device(self):\n        \"\"\"Scan for bluetooth devices and return a DS4 device if found.\"\"\"\n        for bdaddr, name in self.scan():\n            if name == \"Wireless Controller\":\n                self.logger.info(\"Found device {0}\", bdaddr)\n                return BluetoothDS4Device.connect(bdaddr)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef devices(self):\n        log_msg = True\n        while True:\n            if log_msg:\n                self.logger.info(\"Scanning for devices\")\n\n            try:\n                device = self.find_device()\n                if device:\n                    yield device\n                    log_msg = True\n                else:\n                    log_msg = False\n            except BackendError as err:\n                self.logger.error(\"Error while scanning for devices: {0}\",\n                                  err)\n                return\n            except DeviceError as err:\n                self.logger.error(\"Unable to connect to detected device: {0}\",\n                                  err)", "response": "Yields the DS4 devices that are available on the device system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self, *args, **kwargs):\n\n        @wraps(self.callback)\n        def callback():\n            os.read(self.timer, 8)\n            repeat = self.callback(*args, **kwargs)\n            if not repeat:\n                self.stop()\n\n        spec = timerfd.itimerspec(self.interval, self.interval)\n        timerfd.settime(self.timer, 0, spec)\n\n        self.loop.remove_watcher(self.timer)\n        self.loop.add_watcher(self.timer, callback)", "response": "Starts the timer.\n\n        If the callback returns True the timer will be restarted."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts watching a non - blocking fd for data.", "response": "def add_watcher(self, fd, callback):\n        \"\"\"Starts watching a non-blocking fd for data.\"\"\"\n\n        if not isinstance(fd, int):\n            fd = fd.fileno()\n\n        self.callbacks[fd] = callback\n        self.epoll.register(fd, EPOLLIN)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstops watching a fd.", "response": "def remove_watcher(self, fd):\n        \"\"\"Stops watching a fd.\"\"\"\n        if not isinstance(fd, int):\n            fd = fd.fileno()\n\n        if fd not in self.callbacks:\n            return\n\n        self.callbacks.pop(fd, None)\n        self.epoll.unregister(fd)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprocessing any events in the queue.", "response": "def process_events(self):\n        \"\"\"Processes any events in the queue.\"\"\"\n        for event, args in iter_except(self.event_queue.popleft, IndexError):\n            for callback in self.event_callbacks[event]:\n                callback(*args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a generator yielding new devices.", "response": "def _get_future_devices(self, context):\n        \"\"\"Return a generator yielding new devices.\"\"\"\n        monitor = Monitor.from_netlink(context)\n        monitor.filter_by(\"hidraw\")\n        monitor.start()\n\n        self._scanning_log_message()\n        for device in iter(monitor.poll, None):\n            if device.action == \"add\":\n                # Sometimes udev rules has not been applied at this point,\n                # causing permission denied error if we are running in user\n                # mode. With this sleep this will hopefully not happen.\n                sleep(1)\n\n                yield device\n                self._scanning_log_message()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding all the HID devices that are available on the device system.", "response": "def devices(self):\n        \"\"\"Wait for new DS4 devices to appear.\"\"\"\n        context = Context()\n\n        existing_devices = context.list_devices(subsystem=\"hidraw\")\n        future_devices = self._get_future_devices(context)\n\n        for hidraw_device in itertools.chain(existing_devices, future_devices):\n            hid_device = hidraw_device.parent\n            if hid_device.subsystem != \"hid\":\n                continue\n\n            cls = HID_DEVICES.get(hid_device.get(\"HID_NAME\"))\n            if not cls:\n                continue\n\n            for child in hid_device.parent.children:\n                event_device = child.get(\"DEVNAME\", \"\")\n                if event_device.startswith(\"/dev/input/event\"):\n                    break\n            else:\n                continue\n\n\n            try:\n                device_addr = hid_device.get(\"HID_UNIQ\", \"\").upper()\n                if device_addr:\n                    device_name = \"{0} {1}\".format(device_addr,\n                                                   hidraw_device.sys_name)\n                else:\n                    device_name = hidraw_device.sys_name\n\n                yield cls(name=device_name,\n                          addr=device_addr,\n                          type=cls.__type__,\n                          hidraw_device=hidraw_device.device_node,\n                          event_device=event_device)\n\n            except DeviceError as err:\n                self.logger.error(\"Unable to open DS4 device: {0}\", err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rumble(self, small=0, big=0):\n        self._control(small_rumble=small, big_rumble=big)", "response": "Sets the intensity of the rumble motors. Valid range is 0 - 255."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the LED color. Values are RGB between 0 - 255.", "response": "def set_led(self, red=0, green=0, blue=0):\n        \"\"\"Sets the LED color. Values are RGB between 0-255.\"\"\"\n        self._led = (red, green, blue)\n        self._control()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts flashing the LED.", "response": "def start_led_flash(self, on, off):\n        \"\"\"Starts flashing the LED.\"\"\"\n        if not self._led_flashing:\n            self._led_flash = (on, off)\n            self._led_flashing = True\n            self._control()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop_led_flash(self):\n        if self._led_flashing:\n            self._led_flash = (0, 0)\n            self._led_flashing = False\n            # Call twice, once to stop flashing...\n            self._control()\n            # ...and once more to make sure the LED is on.\n            self._control()", "response": "Stops flashing the LED."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a buffer containing a HID report.", "response": "def parse_report(self, buf):\n        \"\"\"Parse a buffer containing a HID report.\"\"\"\n        dpad = buf[5] % 16\n\n        return DS4Report(\n            # Left analog stick\n            buf[1], buf[2],\n\n            # Right analog stick\n            buf[3], buf[4],\n\n            # L2 and R2 analog\n            buf[8], buf[9],\n\n            # DPad up, down, left, right\n            (dpad in (0, 1, 7)), (dpad in (3, 4, 5)),\n            (dpad in (5, 6, 7)), (dpad in (1, 2, 3)),\n\n            # Buttons cross, circle, square, triangle\n            (buf[5] & 32) != 0, (buf[5] & 64) != 0,\n            (buf[5] & 16) != 0, (buf[5] & 128) != 0,\n\n            # L1, L2 and L3 buttons\n            (buf[6] & 1) != 0, (buf[6] & 4) != 0, (buf[6] & 64) != 0,\n\n            # R1, R2,and R3 buttons\n            (buf[6] & 2) != 0, (buf[6] & 8) != 0, (buf[6] & 128) != 0,\n\n            # Share and option buttons\n            (buf[6] & 16) != 0, (buf[6] & 32) != 0,\n\n            # Trackpad and PS buttons\n            (buf[7] & 2) != 0, (buf[7] & 1) != 0,\n\n            # Acceleration\n            S16LE.unpack_from(buf, 13)[0],\n            S16LE.unpack_from(buf, 15)[0],\n            S16LE.unpack_from(buf, 17)[0],\n\n            # Orientation\n            -(S16LE.unpack_from(buf, 19)[0]),\n            S16LE.unpack_from(buf, 21)[0],\n            S16LE.unpack_from(buf, 23)[0],\n\n            # Trackpad touch 1: id, active, x, y\n            buf[35] & 0x7f, (buf[35] >> 7) == 0,\n            ((buf[37] & 0x0f) << 8) | buf[36],\n            buf[38] << 4 | ((buf[37] & 0xf0) >> 4),\n\n            # Trackpad touch 2: id, active, x, y\n            buf[39] & 0x7f, (buf[39] >> 7) == 0,\n            ((buf[41] & 0x0f) << 8) | buf[40],\n            buf[42] << 4 | ((buf[41] & 0xf0) >> 4),\n\n            # Timestamp and battery\n            buf[7] >> 2,\n            buf[30] % 16,\n\n            # External inputs (usb, audio, mic)\n            (buf[30] & 16) != 0, (buf[30] & 32) != 0,\n            (buf[30] & 64) != 0\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exec_(controller, cmd, *args):\n    controller.logger.info(\"Executing: {0} {1}\", cmd, \" \".join(args))\n\n    try:\n        subprocess.check_call([cmd] + list(args))\n    except (OSError, subprocess.CalledProcessError) as err:\n        controller.logger.error(\"Failed to execute process: {0}\", err)", "response": "Executes a subprocess in the foreground blocking until returned."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exec_background(controller, cmd, *args):\n    controller.logger.info(\"Executing in the background: {0} {1}\",\n                           cmd, \" \".join(args))\n\n    try:\n        subprocess.Popen([cmd] + list(args),\n                         stdout=open(os.devnull, \"wb\"),\n                         stderr=open(os.devnull, \"wb\"))\n    except OSError as err:\n        controller.logger.error(\"Failed to execute process: {0}\", err)", "response": "Executes a subprocess in the background."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_uinput_device(mapping):\n    if mapping not in _mappings:\n        raise DeviceError(\"Unknown device mapping: {0}\".format(mapping))\n\n    try:\n        mapping = _mappings[mapping]\n        device = UInputDevice(mapping)\n    except UInputError as err:\n        raise DeviceError(err)\n\n    return device", "response": "Creates a uinput device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a dict of mapping options.", "response": "def parse_uinput_mapping(name, mapping):\n    \"\"\"Parses a dict of mapping options.\"\"\"\n    axes, buttons, mouse, mouse_options = {}, {}, {}, {}\n    description = \"ds4drv custom mapping ({0})\".format(name)\n\n    for key, attr in mapping.items():\n        key = key.upper()\n        if key.startswith(\"BTN_\") or key.startswith(\"KEY_\"):\n            buttons[key] = attr\n        elif key.startswith(\"ABS_\"):\n            axes[key] = attr\n        elif key.startswith(\"REL_\"):\n            mouse[key] = attr\n        elif key.startswith(\"MOUSE_\"):\n            mouse_options[key] = attr\n\n    create_mapping(name, description, axes=axes, buttons=buttons,\n                   mouse=mouse, mouse_options=mouse_options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef next_joystick_device():\n    for i in range(100):\n        dev = \"/dev/input/js{0}\".format(i)\n        if not os.path.exists(dev):\n            return dev", "response": "Finds the next available js device name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a uinput device using the specified layout.", "response": "def create_device(self, layout):\n        \"\"\"Creates a uinput device using the specified layout.\"\"\"\n        events = {ecodes.EV_ABS: [], ecodes.EV_KEY: [],\n                  ecodes.EV_REL: []}\n\n        # Joystick device\n        if layout.axes or layout.buttons or layout.hats:\n            self.joystick_dev = next_joystick_device()\n\n        for name in layout.axes:\n            params = layout.axes_options.get(name, DEFAULT_AXIS_OPTIONS)\n            if not absInfoUsesValue:\n                params = params[1:]\n            events[ecodes.EV_ABS].append((name, params))\n\n        for name in layout.hats:\n            params = (0, -1, 1, 0, 0)\n            if not absInfoUsesValue:\n                params = params[1:]\n            events[ecodes.EV_ABS].append((name, params))\n\n        for name in layout.buttons:\n            events[ecodes.EV_KEY].append(name)\n\n        if layout.mouse:\n            self.mouse_pos = {}\n            self.mouse_rel = {}\n            self.mouse_analog_sensitivity = float(\n                layout.mouse_options.get(\"MOUSE_SENSITIVITY\",\n                                         DEFAULT_MOUSE_SENSITIVTY)\n            )\n            self.mouse_analog_deadzone = int(\n                layout.mouse_options.get(\"MOUSE_DEADZONE\",\n                                         DEFAULT_MOUSE_DEADZONE)\n            )\n            self.scroll_repeat_delay = float(\n                layout.mouse_options.get(\"MOUSE_SCROLL_REPEAT_DELAY\",\n                                         DEFAULT_SCROLL_REPEAT_DELAY)\n            )\n            self.scroll_delay = float(\n                layout.mouse_options.get(\"MOUSE_SCROLL_DELAY\",\n                                         DEFAULT_SCROLL_DELAY)\n            )\n\n            for name in layout.mouse:\n                if name in (ecodes.REL_WHEELUP, ecodes.REL_WHEELDOWN):\n                    if ecodes.REL_WHEEL not in events[ecodes.EV_REL]:\n                        # This ensures that scroll wheel events can work\n                        events[ecodes.EV_REL].append(ecodes.REL_WHEEL)\n                else:\n                    events[ecodes.EV_REL].append(name)\n                self.mouse_rel[name] = 0.0\n\n        self.device = UInput(name=layout.name, events=events,\n                             bustype=layout.bustype, vendor=layout.vendor,\n                             product=layout.product, version=layout.version)\n        self.layout = layout"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites an event to the device.", "response": "def write_event(self, etype, code, value):\n        \"\"\"Writes a event to the device, if it has changed.\"\"\"\n        last_value = self._write_cache.get(code)\n        if last_value != value:\n            self.device.write(etype, code, value)\n            self._write_cache[code] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite axes buttons and hats with values from the report to the device.", "response": "def emit(self, report):\n        \"\"\"Writes axes, buttons and hats with values from the report to\n        the device.\"\"\"\n        for name, attr in self.layout.axes.items():\n            value = getattr(report, attr)\n            self.write_event(ecodes.EV_ABS, name, value)\n\n        for name, attr in self.layout.buttons.items():\n            attr, modifier = attr\n\n            if attr in self.ignored_buttons:\n                value = False\n            else:\n                value = getattr(report, attr)\n\n            if modifier and \"analog\" in attr:\n                if modifier == \"+\":\n                    value = value > (128 + DEFAULT_A2D_DEADZONE)\n                elif modifier == \"-\":\n                    value = value < (128 - DEFAULT_A2D_DEADZONE)\n\n            self.write_event(ecodes.EV_KEY, name, value)\n\n        for name, attr in self.layout.hats.items():\n            if getattr(report, attr[0]):\n                value = -1\n            elif getattr(report, attr[1]):\n                value = 1\n            else:\n                value = 0\n\n            self.write_event(ecodes.EV_ABS, name, value)\n\n        self.device.syn()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresets the device to a blank state.", "response": "def emit_reset(self):\n        \"\"\"Resets the device to a blank state.\"\"\"\n        for name in self.layout.axes:\n            params = self.layout.axes_options.get(name, DEFAULT_AXIS_OPTIONS)\n            self.write_event(ecodes.EV_ABS, name, int(sum(params[1:3]) / 2))\n\n        for name in self.layout.buttons:\n            self.write_event(ecodes.EV_KEY, name, False)\n\n        for name in self.layout.hats:\n            self.write_event(ecodes.EV_ABS, name, 0)\n\n        self.device.syn()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef emit_mouse(self, report):\n        for name, attr in self.layout.mouse.items():\n            # If the attr is a tuple like (left_analog_y, \"-\")\n            # then set the attr to just be the first item\n            attr, modifier = attr\n\n            if attr.startswith(\"trackpad_touch\"):\n                active_attr = attr[:16] + \"active\"\n                if not getattr(report, active_attr):\n                    self.mouse_pos.pop(name, None)\n                    continue\n\n                pos = getattr(report, attr)\n                if name not in self.mouse_pos:\n                    self.mouse_pos[name] = pos\n\n                sensitivity = 0.5\n                self.mouse_rel[name] += (pos - self.mouse_pos[name]) * sensitivity\n                self.mouse_pos[name] = pos\n\n            elif \"analog\" in attr:\n                pos = getattr(report, attr)\n                if (pos > (128 + self.mouse_analog_deadzone)\n                    or pos < (128 - self.mouse_analog_deadzone)):\n                    accel = (pos - 128) / 10\n                else:\n                    continue\n\n                # If a minus modifier has been given then minus the acceleration\n                # to invert the direction.\n                if (modifier and modifier == \"-\"):\n                    accel = -accel\n\n                sensitivity = self.mouse_analog_sensitivity\n                self.mouse_rel[name] += accel * sensitivity\n\n            # Emulate mouse wheel (needs special handling)\n            if name in (ecodes.REL_WHEELUP, ecodes.REL_WHEELDOWN):\n                ecode = ecodes.REL_WHEEL # The real event we need to emit\n                write = False\n                if getattr(report, attr):\n                    self._scroll_details['direction'] = name\n                    now = time.time()\n                    last_write = self._scroll_details.get('last_write')\n                    if not last_write:\n                        # No delay for the first button press for fast feedback\n                        write = True\n                        self._scroll_details['count'] = 0\n                    if name == ecodes.REL_WHEELUP:\n                        value = 1\n                    elif name == ecodes.REL_WHEELDOWN:\n                        value = -1\n                    if last_write:\n                        # Delay at least one cycle before continual scrolling\n                        if self._scroll_details['count'] > 1:\n                            if now - last_write > self.scroll_delay:\n                                write = True\n                        elif now - last_write > self.scroll_repeat_delay:\n                            write = True\n                    if write:\n                        self.device.write(ecodes.EV_REL, ecode, value)\n                        self._scroll_details['last_write'] = now\n                        self._scroll_details['count'] += 1\n                        continue # No need to proceed further\n                else:\n                    # Reset so you can quickly tap the button to scroll\n                    if self._scroll_details.get('direction') == name:\n                        self._scroll_details['last_write'] = 0\n                        self._scroll_details['count'] = 0\n\n            rel = int(self.mouse_rel[name])\n            self.mouse_rel[name] = self.mouse_rel[name] - rel\n            self.device.write(ecodes.EV_REL, name, rel)\n\n        self.device.syn()", "response": "Emits the mouse events from a report and writes them."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start_output (self):\n        super(GMLLogger, self).start_output()\n        if self.has_part(\"intro\"):\n            self.write_intro()\n            self.writeln()\n        self.writeln(u\"graph [\")\n        self.writeln(u\"  directed 1\")\n        self.flush()", "response": "Write start of checking info as gml comment."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getaddresses (addr):\n    parsed = [mail for name, mail in AddressList(addr).addresslist if mail]\n    if parsed:\n        addresses = parsed\n    elif addr:\n        # we could not parse any mail addresses, so try with the raw string\n        addresses = [addr]\n    else:\n        addresses = []\n    return addresses", "response": "Return list of email addresses from given field value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_url (self):\n        super(MailtoUrl, self).build_url()\n        self.addresses = set()\n        self.subject = None\n        self.parse_addresses()\n        if self.addresses:\n            for addr in sorted(self.addresses):\n                self.check_email_syntax(addr)\n                if not self.valid:\n                    break\n        elif not self.subject:\n            self.add_warning(_(\"No mail addresses or email subject found in `%(url)s'.\") % \\\n                {\"url\": self.url})", "response": "Build the URL for the mailto."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking the email syntax.", "response": "def check_email_syntax (self, mail):\n        \"\"\"Check email syntax. The relevant RFCs:\n        - How to check names (memo):\n          http://tools.ietf.org/html/rfc3696\n        - Email address syntax\n          http://tools.ietf.org/html/rfc2822\n        - SMTP protocol\n          http://tools.ietf.org/html/rfc5321#section-4.1.3\n        - IPv6\n          http://tools.ietf.org/html/rfc4291#section-2.2\n        - Host syntax\n          http://tools.ietf.org/html/rfc1123#section-2\n        \"\"\"\n        # length checks\n\n        # restrict email length to 256 characters\n        # http://www.rfc-editor.org/errata_search.php?eid=1003\n        if len(mail) > 256:\n            self.set_result(_(\"Mail address `%(addr)s' too long. Allowed 256 chars, was %(length)d chars.\") % \\\n            {\"addr\": mail, \"length\": len(mail)}, valid=False, overwrite=False)\n            return\n        if \"@\" not in mail:\n            self.set_result(_(\"Missing `@' in mail address `%(addr)s'.\") % \\\n            {\"addr\": mail}, valid=False, overwrite=False)\n            return\n        # note: be sure to use rsplit since \"@\" can occur in local part\n        local, domain = mail.rsplit(\"@\", 1)\n        if not local:\n            self.set_result(_(\"Missing local part of mail address `%(addr)s'.\") % \\\n            {\"addr\": mail}, valid=False, overwrite=False)\n            return\n        if not domain:\n            self.set_result(_(\"Missing domain part of mail address `%(addr)s'.\") % \\\n            {\"addr\": mail}, valid=False, overwrite=False)\n            return\n        if len(local) > 64:\n            self.set_result(_(\"Local part of mail address `%(addr)s' too long. Allowed 64 chars, was %(length)d chars.\") % \\\n            {\"addr\": mail, \"length\": len(local)}, valid=False, overwrite=False)\n            return\n        if len(domain) > 255:\n            self.set_result(_(\"Domain part of mail address `%(addr)s' too long. Allowed 255 chars, was %(length)d chars.\") % \\\n            {\"addr\": mail, \"length\": len(local)}, valid=False, overwrite=False)\n            return\n\n        # local part syntax check\n\n        # Rules taken from http://tools.ietf.org/html/rfc3696#section-3\n        if is_quoted(local):\n            if is_missing_quote(local):\n                self.set_result(_(\"Unquoted double quote or backslash in mail address `%(addr)s'.\") % \\\n                {\"addr\": mail}, valid=False, overwrite=False)\n                return\n        else:\n            if local.startswith(u\".\"):\n                self.set_result(_(\"Local part of mail address `%(addr)s' may not start with a dot.\") % \\\n                {\"addr\": mail}, valid=False, overwrite=False)\n                return\n            if local.endswith(u\".\"):\n                self.set_result(_(\"Local part of mail address `%(addr)s' may not end with a dot.\") % \\\n                {\"addr\": mail}, valid=False, overwrite=False)\n                return\n            if u\"..\" in local:\n                self.set_result(_(\"Local part of mail address `%(addr)s' may not contain two dots.\") % \\\n                {\"addr\": mail}, valid=False, overwrite=False)\n                return\n            for char in u'@ \\\\\",[]':\n                if char in local.replace(u\"\\\\%s\"%char, u\"\"):\n                    self.set_result(_(\"Local part of mail address `%(addr)s' contains unquoted character `%(char)s.\") % \\\n                    {\"addr\": mail, \"char\": char}, valid=False, overwrite=False)\n                    return\n\n        # domain part syntax check\n\n        if is_literal(domain):\n            # it's an IP address\n            ip = domain[1:-1]\n            if ip.startswith(u\"IPv6:\"):\n                ip = ip[5:]\n            if not iputil.is_valid_ip(ip):\n                self.set_result(_(\"Domain part of mail address `%(addr)s' has invalid IP.\") % \\\n                {\"addr\": mail}, valid=False, overwrite=False)\n                return\n        else:\n            # it's a domain name\n            if not urlutil.is_safe_domain(domain):\n                self.set_result(_(\"Invalid domain part of mail address `%(addr)s'.\") % \\\n                {\"addr\": mail}, valid=False, overwrite=False)\n                return\n            if domain.endswith(\".\") or domain.split(\".\")[-1].isdigit():\n                self.set_result(_(\"Invalid top level domain part of mail address `%(addr)s'.\") % \\\n                {\"addr\": mail}, valid=False, overwrite=False)\n                return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nverify that the connection is valid.", "response": "def check_connection (self):\n        \"\"\"\n        Verify a list of email addresses. If one address fails,\n        the whole list will fail.\n\n        For each mail address the MX DNS records are found.\n        If no MX records are found, print a warning and try\n        to look for A DNS records. If no A records are found either\n        print an error.\n        \"\"\"\n        for mail in sorted(self.addresses):\n            self.check_smtp_domain(mail)\n            if not self.valid:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_smtp_domain (self, mail):\n        from dns.exception import DNSException\n        log.debug(LOG_CHECK, \"checking mail address %r\", mail)\n        mail = strformat.ascii_safe(mail)\n        username, domain = mail.rsplit('@', 1)\n        log.debug(LOG_CHECK, \"looking up MX mailhost %r\", domain)\n        try:\n            answers = resolver.query(domain, 'MX')\n        except DNSException:\n            answers = []\n        if len(answers) == 0:\n            self.add_warning(_(\"No MX mail host for %(domain)s found.\") %\n                            {'domain': domain},\n                             tag=WARN_MAIL_NO_MX_HOST)\n            try:\n                answers = resolver.query(domain, 'A')\n            except DNSException:\n                answers = []\n            if len(answers) == 0:\n                self.set_result(_(\"No host for %(domain)s found.\") %\n                                 {'domain': domain}, valid=False,\n                                 overwrite=True)\n                return\n            # set preference to zero\n            mxdata = [(0, rdata.to_text(omit_final_dot=True))\n                      for rdata in answers]\n        else:\n            from dns.rdtypes.mxbase import MXBase\n            mxdata = [(rdata.preference,\n                       rdata.exchange.to_text(omit_final_dot=True))\n                       for rdata in answers if isinstance(rdata, MXBase)]\n            if not mxdata:\n                self.set_result(\n                    _(\"Got invalid DNS answer %(answer)s for %(domain)s.\") %\n                    {'answer': answers, 'domain': domain}, valid=False,\n                     overwrite=True)\n                return\n            # sort according to preference (lower preference means this\n            # host should be preferred)\n            mxdata.sort()\n        # debug output\n        log.debug(LOG_CHECK, \"found %d MX mailhosts:\", len(answers))\n        for preference, host in mxdata:\n            log.debug(LOG_CHECK, \"MX host %r, preference %d\", host, preference)\n            pass\n        self.set_result(_(\"Valid mail address syntax\"))", "response": "Check a single SMTP domain."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_cache_url(self):\n        emails = u\",\".join(sorted(self.addresses))\n        self.cache_url = u\"%s:%s\" % (self.scheme, emails)", "response": "Sets the cache url."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnorm given system path with all available norm or expand functions in os. path.", "response": "def normpath (path):\n    \"\"\"Norm given system path with all available norm or expand functions\n    in os.path.\"\"\"\n    expanded = os.path.expanduser(os.path.expandvars(path))\n    return os.path.normcase(os.path.normpath(expanded))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_modules_info():\n    module_infos = []\n    for (mod, name, version_attr) in Modules:\n        if not fileutil.has_module(mod):\n            continue\n        if hasattr(mod, version_attr):\n            attr = getattr(mod, version_attr)\n            version = attr() if callable(attr) else attr\n            module_infos.append(\"%s %s\" % (name, version))\n        else:\n            # ignore attribute errors in case library developers\n            # change the version information attribute\n            module_infos.append(name)\n    return u\"Modules: %s\" % (u\", \".join(module_infos))", "response": "Return unicode string with detected module info."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a filename in the share directory.", "response": "def get_share_file (filename, devel_dir=None):\n    \"\"\"Return a filename in the share directory.\n    @param devel_dir: directory to search when developing\n    @ptype devel_dir: string\n    @param filename: filename to search for\n    @ptype filename: string\n    @return: the found filename or None\n    @rtype: string\n    @raises: ValueError if not found\n    \"\"\"\n    paths = [get_share_dir()]\n    if devel_dir is not None:\n        # when developing\n        paths.insert(0, devel_dir)\n    for path in paths:\n        fullpath = os.path.join(path, filename)\n        if os.path.isfile(fullpath):\n            return fullpath\n    # not found\n    msg = \"%s not found in %s; check your installation\" % (filename, paths)\n    raise ValueError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntry to find a system - wide SSL certificate file.", "response": "def get_system_cert_file():\n    \"\"\"Try to find a system-wide SSL certificate file.\n    @return: the filename to the cert file\n    @raises: ValueError when no system cert file could be found\n    \"\"\"\n    if os.name == 'posix':\n        filename = \"/etc/ssl/certs/ca-certificates.crt\"\n        if os.path.isfile(filename):\n            return filename\n    msg = \"no system certificate file found\"\n    raise ValueError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_certifi_file():\n    import certifi\n    filename = certifi.where()\n    if os.path.isfile(filename):\n        return filename\n    msg = \"%s not found; check your certifi installation\" % filename\n    raise ValueError(msg)", "response": "Get the SSL certifications installed by the certifi package."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_plugin_folders():\n    folders = []\n    defaultfolder = normpath(\"~/.linkchecker/plugins\")\n    if not os.path.exists(defaultfolder) and not Portable:\n        try:\n            make_userdir(defaultfolder)\n        except Exception as errmsg:\n            msg = _(\"could not create plugin directory %(dirname)r: %(errmsg)r\")\n            args = dict(dirname=defaultfolder, errmsg=errmsg)\n            log.warn(LOG_CHECK, msg % args)\n    if os.path.exists(defaultfolder):\n        folders.append(defaultfolder)\n    return folders", "response": "Get linkchecker plugin folders. Default is ~/.linkchecker / plugins."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_userdir(child):\n    userdir = os.path.dirname(child)\n    if not os.path.isdir(userdir):\n        if os.name == 'nt':\n            # Windows forbids filenames with leading dot unless\n            # a trailing dot is added.\n            userdir += \".\"\n        os.mkdir(userdir, 0700)", "response": "Create a child directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user_config():\n    # initial config (with all options explained)\n    initialconf = normpath(os.path.join(get_share_dir(), \"linkcheckerrc\"))\n    # per user config settings\n    userconf = normpath(\"~/.linkchecker/linkcheckerrc\")\n    if os.path.isfile(initialconf) and not os.path.exists(userconf) and \\\n       not Portable:\n        # copy the initial configuration to the user configuration\n        try:\n            make_userdir(userconf)\n            shutil.copy(initialconf, userconf)\n        except Exception as errmsg:\n            msg = _(\"could not copy initial configuration file %(src)r to %(dst)r: %(errmsg)r\")\n            args = dict(src=initialconf, dst=userconf, errmsg=errmsg)\n            log.warn(LOG_CHECK, msg % args)\n    return userconf", "response": "Get the user configuration filename."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_gconf_http_proxy ():\n    try:\n        import gconf\n    except ImportError:\n        return None\n    try:\n        client = gconf.client_get_default()\n        if client.get_bool(\"/system/http_proxy/use_http_proxy\"):\n            host = client.get_string(\"/system/http_proxy/host\")\n            port = client.get_int(\"/system/http_proxy/port\")\n            if host:\n                if not port:\n                    port = 8080\n                return \"%s:%d\" % (host, port)\n    except Exception as msg:\n        log.debug(LOG_CHECK, \"error getting HTTP proxy from gconf: %s\", msg)\n        pass\n    return None", "response": "Return host and port for GConf HTTP proxy if found else None."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn host : port for KDE HTTP proxy if found else None.", "response": "def get_kde_http_proxy ():\n    \"\"\"Return host:port for KDE HTTP proxy if found, else None.\"\"\"\n    config_dir = get_kde_config_dir()\n    if not config_dir:\n        # could not find any KDE configuration directory\n        return\n    try:\n        data = read_kioslaverc(config_dir)\n        return data.get(\"http_proxy\")\n    except Exception as msg:\n        log.debug(LOG_CHECK, \"error getting HTTP proxy from KDE: %s\", msg)\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the KDE home directory or None if not found.", "response": "def get_kde_home_dir ():\n    \"\"\"Return KDE home directory or None if not found.\"\"\"\n    if os.environ.get(\"KDEHOME\"):\n        kde_home = os.path.abspath(os.environ[\"KDEHOME\"])\n    else:\n        home = os.environ.get(\"HOME\")\n        if not home:\n            # $HOME is not set\n            return\n        kde3_home = os.path.join(home, \".kde\")\n        kde4_home = os.path.join(home, \".kde4\")\n        if fileutil.find_executable(\"kde4-config\"):\n            # kde4\n            kde3_file = kde_home_to_config(kde3_home)\n            kde4_file = kde_home_to_config(kde4_home)\n            if os.path.exists(kde4_file) and os.path.exists(kde3_file):\n                if fileutil.get_mtime(kde4_file) >= fileutil.get_mtime(kde3_file):\n                    kde_home = kde4_home\n                else:\n                    kde_home = kde3_home\n            else:\n                kde_home = kde4_home\n        else:\n            # kde3\n            kde_home = kde3_home\n    return kde_home if os.path.exists(kde_home) else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading kioslaverc into data dictionary.", "response": "def read_kioslaverc (kde_config_dir):\n    \"\"\"Read kioslaverc into data dictionary.\"\"\"\n    data = {}\n    filename = os.path.join(kde_config_dir, \"kioslaverc\")\n    with open(filename) as fd:\n        # First read all lines into dictionary since they can occur\n        # in any order.\n        for line in  fd:\n            line = line.rstrip()\n            if line.startswith('['):\n                in_proxy_settings = line.startswith(\"[Proxy Settings]\")\n            elif in_proxy_settings:\n                if '=' not in line:\n                    continue\n                key, value = line.split('=', 1)\n                key = key.strip()\n                value = value.strip()\n                if not key:\n                    continue\n                # trim optional localization\n                key = loc_ro.sub(\"\", key).strip()\n                if not key:\n                    continue\n                add_kde_setting(key, value, data)\n    resolve_kde_settings(data)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a KDE proxy setting value to data dictionary.", "response": "def add_kde_setting (key, value, data):\n    \"\"\"Add a KDE proxy setting value to data dictionary.\"\"\"\n    if key == \"ProxyType\":\n        mode = None\n        int_value = int(value)\n        if int_value == 1:\n            mode = \"manual\"\n        elif int_value == 2:\n            # PAC URL\n            mode = \"pac\"\n        elif int_value == 3:\n            # WPAD.\n            mode = \"wpad\"\n        elif int_value == 4:\n            # Indirect manual via environment variables.\n            mode = \"indirect\"\n        data[\"mode\"] = mode\n    elif key == \"Proxy Config Script\":\n        data[\"autoconfig_url\"] = value\n    elif key == \"httpProxy\":\n        add_kde_proxy(\"http_proxy\", value, data)\n    elif key == \"httpsProxy\":\n        add_kde_proxy(\"https_proxy\", value, data)\n    elif key == \"ftpProxy\":\n        add_kde_proxy(\"ftp_proxy\", value, data)\n    elif key == \"ReversedException\":\n        data[\"reversed_bypass\"] = bool(value == \"true\" or int(value))\n    elif key == \"NoProxyFor\":\n        data[\"ignore_hosts\"] = split_hosts(value)\n    elif key == \"AuthMode\":\n        mode = int(value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreplace name of environment variable with its value.", "response": "def resolve_indirect (data, key, splithosts=False):\n    \"\"\"Replace name of environment variable with its value.\"\"\"\n    value = data[key]\n    env_value = os.environ.get(value)\n    if env_value:\n        if splithosts:\n            data[key] = split_hosts(env_value)\n        else:\n            data[key] = env_value\n    else:\n        del data[key]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting final proxy configuration values in data dictionary.", "response": "def resolve_kde_settings (data):\n    \"\"\"Write final proxy configuration values in data dictionary.\"\"\"\n    if \"mode\" not in data:\n        return\n    if data[\"mode\"] == \"indirect\":\n        for key in (\"http_proxy\", \"https_proxy\", \"ftp_proxy\"):\n            if key in data:\n                resolve_indirect(data, key)\n        if \"ignore_hosts\" in data:\n            resolve_indirect(data, \"ignore_hosts\", splithosts=True)\n    elif data[\"mode\"] != \"manual\":\n        # unsupported config\n        for key in (\"http_proxy\", \"https_proxy\", \"ftp_proxy\"):\n            if key in data:\n                del data[key]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef logger_new (self, loggername, **kwargs):\n        args = self[loggername]\n        args.update(kwargs)\n        return self.loggers[loggername](**args)", "response": "Instantiate a new logger and return it."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logger_add (self, loggerclass):\n        self.loggers[loggerclass.LoggerName] = loggerclass\n        self[loggerclass.LoggerName] = {}", "response": "Add a new logger type to the known loggers."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads settings from given config files.", "response": "def read (self, files=None):\n        \"\"\"\n        Read settings from given config files.\n\n        @raises: LinkCheckerError on syntax errors in the config file(s)\n        \"\"\"\n        if files is None:\n            cfiles = []\n        else:\n            cfiles = files[:]\n        if not cfiles:\n            userconf = get_user_config()\n            if os.path.isfile(userconf):\n                cfiles.append(userconf)\n        # filter invalid files\n        filtered_cfiles = []\n        for cfile in cfiles:\n            if not os.path.isfile(cfile):\n                log.warn(LOG_CHECK, _(\"Configuration file %r does not exist.\"), cfile)\n            elif not fileutil.is_readable(cfile):\n                log.warn(LOG_CHECK, _(\"Configuration file %r is not readable.\"), cfile)\n            else:\n                filtered_cfiles.append(cfile)\n        log.debug(LOG_CHECK, \"reading configuration from %s\", filtered_cfiles)\n        confparse.LCConfigParser(self).read(filtered_cfiles)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_auth (self, user=None, password=None, pattern=None):\n        if not user or not pattern:\n            log.warn(LOG_CHECK,\n            _(\"missing user or URL pattern in authentication data.\"))\n            return\n        entry = dict(\n            user=user,\n            password=password,\n            pattern=re.compile(pattern),\n        )\n        self[\"authentication\"].append(entry)", "response": "Add given authentication data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting user and password from configured authentication that matches the given URL.", "response": "def get_user_password (self, url):\n        \"\"\"Get tuple (user, password) from configured authentication\n        that matches the given URL.\n        Both user and password can be None if not specified, or no\n        authentication matches the given URL.\n        \"\"\"\n        for auth in self[\"authentication\"]:\n            if auth['pattern'].match(url):\n                return (auth['user'], auth['password'])\n        return (None, None)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sanitize (self):\n        \"Make sure the configuration is consistent.\"\n        if self['logger'] is None:\n            self.sanitize_logger()\n        if self['loginurl']:\n            self.sanitize_loginurl()\n        self.sanitize_proxies()\n        self.sanitize_plugins()\n        self.sanitize_ssl()\n        # set default socket timeout\n        socket.setdefaulttimeout(self['timeout'])", "response": "Make sure the configuration is consistent."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes logger configuration consistent.", "response": "def sanitize_logger (self):\n        \"\"\"Make logger configuration consistent.\"\"\"\n        if not self['output']:\n            log.warn(LOG_CHECK, _(\"activating text logger output.\"))\n            self['output'] = 'text'\n        self['logger'] = self.logger_new(self['output'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking login configuration consistent.", "response": "def sanitize_loginurl (self):\n        \"\"\"Make login configuration consistent.\"\"\"\n        url = self[\"loginurl\"]\n        disable = False\n        if not self[\"loginpasswordfield\"]:\n            log.warn(LOG_CHECK,\n            _(\"no CGI password fieldname given for login URL.\"))\n            disable = True\n        if not self[\"loginuserfield\"]:\n            log.warn(LOG_CHECK,\n            _(\"no CGI user fieldname given for login URL.\"))\n            disable = True\n        if self.get_user_password(url) == (None, None):\n            log.warn(LOG_CHECK,\n            _(\"no user/password authentication data found for login URL.\"))\n            disable = True\n        if not url.lower().startswith((\"http:\", \"https:\")):\n            log.warn(LOG_CHECK, _(\"login URL is not a HTTP URL.\"))\n            disable = True\n        urlparts = urlparse.urlsplit(url)\n        if not urlparts[0] or not urlparts[1] or not urlparts[2]:\n            log.warn(LOG_CHECK, _(\"login URL is incomplete.\"))\n            disable = True\n        if disable:\n            log.warn(LOG_CHECK,\n              _(\"disabling login URL %(url)s.\") % {\"url\": url})\n            self[\"loginurl\"] = None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sanitize_proxies (self):\n        if os.name != 'posix':\n            return\n        if \"http\" not in self[\"proxy\"]:\n            http_proxy = get_gconf_http_proxy() or get_kde_http_proxy()\n            if http_proxy:\n                self[\"proxy\"][\"http\"] = http_proxy\n        if \"ftp\" not in self[\"proxy\"]:\n            ftp_proxy = get_gconf_ftp_proxy() or get_kde_ftp_proxy()\n            if ftp_proxy:\n                self[\"proxy\"][\"ftp\"] = ftp_proxy", "response": "Try to read additional proxy settings which urllib does not have not\n            support."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsanitizing SSL certificate file.", "response": "def sanitize_ssl(self):\n        \"\"\"Use local installed certificate file if available.\n        Tries to get system, then certifi, then the own\n        installed certificate file.\"\"\"\n        if self[\"sslverify\"] is True:\n            try:\n                self[\"sslverify\"] = get_system_cert_file()\n            except ValueError:\n                try:\n                    self[\"sslverify\"] = get_certifi_file()\n                except (ValueError, ImportError):\n                    try:\n                        self[\"sslverify\"] = get_share_file('cacert.pem')\n                    except ValueError:\n                        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_command(self):\n        cmd = None\n        count = len(self.command_list)\n        if count > 0:\n            cmd = self.command_list.pop(0)\n        ## If that was the last line, turn off lines_pending\n        if count == 1:\n            self.cmd_ready = False\n        return cmd", "response": "Get the command that was received from the DE."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends raw text to the distant end.", "response": "def send(self, text):\n        \"\"\"\n        Send raw text to the distant end.\n        \"\"\"\n        if text:\n            self.send_buffer += text.replace('\\n', '\\r\\n')\n            self.send_pending = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_wrapped(self, text):\n        lines = word_wrap(text, self.columns)\n        for line in lines:\n            self.send_cc(line + '\\n')", "response": "Send text padded and wrapped to the user s screen width."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef request_will_echo(self):\n        self._iac_will(ECHO)\n        self._note_reply_pending(ECHO, True)\n        self.telnet_echo = True", "response": "Tell the DE that we would like to echo their text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request_wont_echo(self):\n        self._iac_wont(ECHO)\n        self._note_reply_pending(ECHO, True)\n        self.telnet_echo = False", "response": "Tell the DE that we would like to stop echoing their text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef socket_send(self):\n        if len(self.send_buffer):\n            try:\n                sent = self.sock.send(self.send_buffer)\n            except socket.error, err:\n                print(\"!! SEND error '%d:%s' from %s\" % (err[0], err[1],\n                    self.addrport()))\n                self.active = False\n                return\n            self.bytes_sent += sent\n            self.send_buffer = self.send_buffer[sent:]\n        else:\n            self.send_pending = False", "response": "Called by TelnetServer when data is ready."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls by TelnetServer when data is ready.", "response": "def socket_recv(self):\n        \"\"\"\n        Called by TelnetServer when recv data is ready.\n        \"\"\"\n        try:\n            data = self.sock.recv(2048)\n        except socket.error, ex:\n            print (\"?? socket.recv() error '%d:%s' from %s\" %\n                (ex[0], ex[1], self.addrport()))\n            raise BogConnectionLost()\n\n        ## Did they close the connection?\n        size = len(data)\n        if size == 0:\n            raise BogConnectionLost()\n\n        ## Update some trackers\n        self.last_input_time = time.time()\n        self.bytes_received += size\n\n        ## Test for telnet commands\n        for byte in data:\n            self._iac_sniffer(byte)\n\n        ## Look for newline characters to get whole lines from the buffer\n        while True:\n            mark = self.recv_buffer.find('\\n')\n            if mark == -1:\n                break\n            cmd = self.recv_buffer[:mark].strip()\n            self.command_list.append(cmd)\n            self.cmd_ready = True\n            self.recv_buffer = self.recv_buffer[mark+1:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles a single byte from the socket.", "response": "def _recv_byte(self, byte):\n        \"\"\"\n        Non-printable filtering currently disabled because it did not play\n        well with extended character sets.\n        \"\"\"\n        ## Filter out non-printing characters\n        #if (byte >= ' ' and byte <= '~') or byte == '\\n':\n        if self.telnet_echo:\n            self._echo_byte(byte)\n        self.recv_buffer += byte"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nechoing a single byte to the client and convert LF into CR \\ LF.", "response": "def _echo_byte(self, byte):\n        \"\"\"\n        Echo a character back to the client and convert LF into CR\\LF.\n        \"\"\"\n        if byte == '\\n':\n            self.send_buffer += '\\r'\n        if self.telnet_echo_password:\n            self.send_buffer += '*'\n        else:\n            self.send_buffer += byte"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _iac_sniffer(self, byte):\n        ## Are we not currently in an IAC sequence coming from the DE?\n        if self.telnet_got_iac is False:\n\n            if byte == IAC:\n                ## Well, we are now\n                self.telnet_got_iac = True\n                return\n\n            ## Are we currenty in a sub-negotion?\n            elif self.telnet_got_sb is True:\n                ## Sanity check on length\n                if len(self.telnet_sb_buffer) < 64:\n                    self.telnet_sb_buffer += byte\n                else:\n                    self.telnet_got_sb = False\n                    self.telnet_sb_buffer = \"\"\n                return\n\n            else:\n                ## Just a normal NVT character\n                self._recv_byte(byte)\n                return\n\n        ## Byte handling when already in an IAC sequence sent from the DE\n\n        else:\n\n            ## Did we get sent a second IAC?\n            if byte == IAC and self.telnet_got_sb is True:\n                ## Must be an escaped 255 (IAC + IAC)\n                self.telnet_sb_buffer += byte\n                self.telnet_got_iac = False\n                return\n\n            ## Do we already have an IAC + CMD?\n            elif self.telnet_got_cmd:\n                ## Yes, so handle the option\n                self._three_byte_cmd(byte)\n                return\n\n            ## We have IAC but no CMD\n            else:\n\n                ## Is this the middle byte of a three-byte command?\n                if byte == DO:\n                    self.telnet_got_cmd = DO\n                    return\n\n                elif byte == DONT:\n                    self.telnet_got_cmd = DONT\n                    return\n\n                elif byte == WILL:\n                    self.telnet_got_cmd = WILL\n                    return\n\n                elif byte == WONT:\n                    self.telnet_got_cmd = WONT\n                    return\n\n                else:\n                    ## Nope, must be a two-byte command\n                    self._two_byte_cmd(byte)", "response": "This function handles the NVT IAC sequence and IAC commands and returns the NVT character."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling incoming Telnet commands that are two bytes long.", "response": "def _two_byte_cmd(self, cmd):\n        \"\"\"\n        Handle incoming Telnet commands that are two bytes long.\n        \"\"\"\n        #print \"got two byte cmd %d\" % ord(cmd)\n\n        if cmd == SB:\n            ## Begin capturing a sub-negotiation string\n            self.telnet_got_sb = True\n            self.telnet_sb_buffer = ''\n\n        elif cmd == SE:\n            ## Stop capturing a sub-negotiation string\n            self.telnet_got_sb = False\n            self._sb_decoder()\n\n        elif cmd == NOP:\n            pass\n\n        elif cmd == DATMK:\n            pass\n\n        elif cmd == IP:\n            pass\n\n        elif cmd == AO:\n            pass\n\n        elif cmd == AYT:\n            pass\n\n        elif cmd == EC:\n            pass\n\n        elif cmd == EL:\n            pass\n\n        elif cmd == GA:\n            pass\n\n        else:\n            print \"2BC: Should not be here.\"\n\n        self.telnet_got_iac = False\n        self.telnet_got_cmd = None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _three_byte_cmd(self, option):\n        cmd = self.telnet_got_cmd\n        #print \"got three byte cmd %d:%d\" % (ord(cmd), ord(option))\n\n        ## Incoming DO's and DONT's refer to the status of this end\n\n        #---[ DO ]-------------------------------------------------------------\n\n        if cmd == DO:\n\n            if option == BINARY:\n\n                if self._check_reply_pending(BINARY):\n                    self._note_reply_pending(BINARY, False)\n                    self._note_local_option(BINARY, True)\n\n                elif (self._check_local_option(BINARY) is False or\n                        self._check_local_option(BINARY) is UNKNOWN):\n                    self._note_local_option(BINARY, True)\n                    self._iac_will(BINARY)\n                    ## Just nod\n\n            elif option == ECHO:\n\n                if self._check_reply_pending(ECHO):\n                    self._note_reply_pending(ECHO, False)\n                    self._note_local_option(ECHO, True)\n\n                elif (self._check_local_option(ECHO) is False or\n                        self._check_local_option(ECHO) is UNKNOWN):\n                    self._note_local_option(ECHO, True)\n                    self._iac_will(ECHO)\n                    self.telnet_echo = True\n\n            elif option == SGA:\n\n                if self._check_reply_pending(SGA):\n                    self._note_reply_pending(SGA, False)\n                    self._note_local_option(SGA, True)\n\n                elif (self._check_local_option(SGA) is False or\n                        self._check_local_option(SGA) is UNKNOWN):\n                    self._note_local_option(SGA, True)\n                    self._iac_will(SGA)\n                    ## Just nod\n\n            else:\n\n                ## ALL OTHER OTHERS = Default to refusing once\n                if self._check_local_option(option) is UNKNOWN:\n                    self._note_local_option(option, False)\n                    self._iac_wont(option)\n\n\n        #---[ DONT ]-----------------------------------------------------------\n\n        elif cmd == DONT:\n\n            if option == BINARY:\n\n                if self._check_reply_pending(BINARY):\n                    self._note_reply_pending(BINARY, False)\n                    self._note_local_option(BINARY, False)\n\n                elif (self._check_local_option(BINARY) is True or\n                        self._check_local_option(BINARY) is UNKNOWN):\n                    self._note_local_option(BINARY, False)\n                    self._iac_wont(BINARY)\n                    ## Just nod\n\n            elif option == ECHO:\n\n                if self._check_reply_pending(ECHO):\n                    self._note_reply_pending(ECHO, False)\n                    self._note_local_option(ECHO, True)\n                    self.telnet_echo = False\n\n                elif (self._check_local_option(BINARY) is True or\n                        self._check_local_option(BINARY) is UNKNOWN):\n                    self._note_local_option(ECHO, False)\n                    self._iac_wont(ECHO)\n                    self.telnet_echo = False\n\n            elif option == SGA:\n\n                if self._check_reply_pending(SGA):\n                    self._note_reply_pending(SGA, False)\n                    self._note_local_option(SGA, False)\n\n                elif (self._check_remote_option(SGA) is True or\n                        self._check_remote_option(SGA) is UNKNOWN):\n                    self._note_local_option(SGA, False)\n                    self._iac_will(SGA)\n                    ## Just nod\n\n            else:\n\n                ## ALL OTHER OPTIONS = Default to ignoring\n                pass\n\n\n        ## Incoming WILL's and WONT's refer to the status of the DE\n\n        #---[ WILL ]-----------------------------------------------------------\n\n        elif cmd == WILL:\n\n            if option == ECHO:\n\n                ## Nutjob DE offering to echo the server...\n                if self._check_remote_option(ECHO) is UNKNOWN:\n                    self._note_remote_option(ECHO, False)\n                    # No no, bad DE!\n                    self._iac_dont(ECHO)\n\n            elif option == NAWS:\n\n                if self._check_reply_pending(NAWS):\n                    self._note_reply_pending(NAWS, False)\n                    self._note_remote_option(NAWS, True)\n                    ## Nothing else to do, client follow with SB\n\n                elif (self._check_remote_option(NAWS) is False or\n                        self._check_remote_option(NAWS) is UNKNOWN):\n                    self._note_remote_option(NAWS, True)\n                    self._iac_do(NAWS)\n                    ## Client should respond with SB\n\n            elif option == SGA:\n\n                if self._check_reply_pending(SGA):\n                    self._note_reply_pending(SGA, False)\n                    self._note_remote_option(SGA, True)\n\n                elif (self._check_remote_option(SGA) is False or\n                        self._check_remote_option(SGA) is UNKNOWN):\n                    self._note_remote_option(SGA, True)\n                    self._iac_do(SGA)\n                    ## Just nod\n\n            elif option == TTYPE:\n\n                if self._check_reply_pending(TTYPE):\n                    self._note_reply_pending(TTYPE, False)\n                    self._note_remote_option(TTYPE, True)\n                    ## Tell them to send their terminal type\n                    self.send('%c%c%c%c%c%c' % (IAC, SB, TTYPE, SEND, IAC, SE))\n\n                elif (self._check_remote_option(TTYPE) is False or\n                        self._check_remote_option(TTYPE) is UNKNOWN):\n                    self._note_remote_option(TTYPE, True)\n                    self._iac_do(TTYPE)\n\n\n        #---[ WONT ]-----------------------------------------------------------\n\n        elif cmd == WONT:\n\n            if option == ECHO:\n\n                ## DE states it wont echo us -- good, they're not suppose to.\n                if self._check_remote_option(ECHO) is UNKNOWN:\n                    self._note_remote_option(ECHO, False)\n                    self._iac_dont(ECHO)\n\n            elif option == SGA:\n\n                if self._check_reply_pending(SGA):\n                    self._note_reply_pending(SGA, False)\n                    self._note_remote_option(SGA, False)\n\n                elif (self._check_remote_option(SGA) is True or\n                        self._check_remote_option(SGA) is UNKNOWN):\n                    self._note_remote_option(SGA, False)\n                    self._iac_dont(SGA)\n\n                if self._check_reply_pending(TTYPE):\n                    self._note_reply_pending(TTYPE, False)\n                    self._note_remote_option(TTYPE, False)\n\n                elif (self._check_remote_option(TTYPE) is True or\n                        self._check_remote_option(TTYPE) is UNKNOWN):\n                    self._note_remote_option(TTYPE, False)\n                    self._iac_dont(TTYPE)\n\n        else:\n            print \"3BC: Should not be here.\"\n\n        self.telnet_got_iac = False\n        self.telnet_got_cmd = None", "response": "Handle incoming Telnet commmands that are three bytes long."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfigure out what to do with a received sub-negotiation block.", "response": "def _sb_decoder(self):\n        \"\"\"\n        Figures out what to do with a received sub-negotiation block.\n        \"\"\"\n        #print \"at decoder\"\n        bloc = self.telnet_sb_buffer\n        if len(bloc) > 2:\n\n            if bloc[0] == TTYPE and bloc[1] == IS:\n                self.terminal_type = bloc[2:]\n                #print \"Terminal type = '%s'\" % self.terminal_type\n\n            if bloc[0] == NAWS:\n                if len(bloc) != 5:\n                    print \"Bad length on NAWS SB:\", len(bloc)\n                else:\n                    self.columns = (256 * ord(bloc[1])) + ord(bloc[2])\n                    self.rows = (256 * ord(bloc[3])) + ord(bloc[4])\n\n                #print \"Screen is %d x %d\" % (self.columns, self.rows)\n\n        self.telnet_sb_buffer = ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntests the status of local negotiated Telnet options.", "response": "def _check_local_option(self, option):\n        \"\"\"Test the status of local negotiated Telnet options.\"\"\"\n        if not self.telnet_opt_dict.has_key(option):\n            self.telnet_opt_dict[option] = TelnetOption()\n        return self.telnet_opt_dict[option].local_option"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrecord the status of local negotiated Telnet options.", "response": "def _note_local_option(self, option, state):\n        \"\"\"Record the status of local negotiated Telnet options.\"\"\"\n        if not self.telnet_opt_dict.has_key(option):\n            self.telnet_opt_dict[option] = TelnetOption()\n        self.telnet_opt_dict[option].local_option = state"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntest the status of remote negotiated Telnet options.", "response": "def _check_remote_option(self, option):\n        \"\"\"Test the status of remote negotiated Telnet options.\"\"\"\n        if not self.telnet_opt_dict.has_key(option):\n            self.telnet_opt_dict[option] = TelnetOption()\n        return self.telnet_opt_dict[option].remote_option"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _note_remote_option(self, option, state):\n        if not self.telnet_opt_dict.has_key(option):\n            self.telnet_opt_dict[option] = TelnetOption()\n        self.telnet_opt_dict[option].remote_option = state", "response": "Record the status of remote negotiated Telnet options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _check_reply_pending(self, option):\n        if not self.telnet_opt_dict.has_key(option):\n            self.telnet_opt_dict[option] = TelnetOption()\n        return self.telnet_opt_dict[option].reply_pending", "response": "Test the status of requested Telnet options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _note_reply_pending(self, option, state):\n        if not self.telnet_opt_dict.has_key(option):\n            self.telnet_opt_dict[option] = TelnetOption()\n        self.telnet_opt_dict[option].reply_pending = state", "response": "Record the status of requested Telnet options."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns output of cmd1 | cmd2.", "response": "def pipecmd (cmd1, cmd2):\n    \"\"\"Return output of \"cmd1 | cmd2\".\"\"\"\n    p1 = subprocess.Popen(cmd1, stdout=subprocess.PIPE)\n    p2 = subprocess.Popen(cmd2, stdin=p1.stdout, stdout=subprocess.PIPE)\n    p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.\n    return p2.communicate()[0]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn parsed IPv4 info from ifconfig binary.", "response": "def ifconfig_inet (iface):\n    \"\"\"Return parsed IPv4 info from ifconfig(8) binary.\"\"\"\n    res = pipecmd([\"ifconfig\", iface], [\"grep\", \"inet \"])\n    info = {}\n    lastpart = None\n    for part in res.split():\n        # Linux systems have prefixes for each value\n        if part.startswith(\"addr:\"):\n            info[\"address\"] = part[5:]\n        elif part.startswith(\"Bcast:\"):\n            info[\"broadcast\"] = part[6:]\n        elif part.startswith(\"Mask:\"):\n            info[\"netmask\"] = part[5:]\n        elif lastpart == \"inet\":\n            info[\"address\"] = part\n        elif lastpart in (\"netmask\", \"broadcast\"):\n            info[lastpart] = part\n        lastpart = part\n    return info"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ioctl (self, func, args):\n        import fcntl\n        return fcntl.ioctl(self.sockfd.fileno(), func, args)", "response": "Call ioctl with given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all interface names in a list.", "response": "def getInterfaceList (self, flags=0):\n        \"\"\"Get all interface names in a list.\"\"\"\n        if sys.platform == 'darwin':\n            command = ['ifconfig', '-l']\n            if flags & self.IFF_UP:\n                command.append('-u')\n            # replace with subprocess.check_output() for Python 2.7\n            res = subprocess.Popen(command, stdout=subprocess.PIPE).communicate()[0]\n            return res.split()\n        # initial 8kB buffer to hold interface data\n        bufsize = 8192\n        # 80kB buffer should be enough for most boxen\n        max_bufsize = bufsize * 10\n        while True:\n            buf = array.array('c', '\\0' * bufsize)\n            ifreq = struct.pack(\"iP\", buf.buffer_info()[1], buf.buffer_info()[0])\n            try:\n                result = self._ioctl(self.SIOCGIFCONF, ifreq)\n                break\n            except IOError as msg:\n                # in case of EINVAL the buffer size was too small\n                if msg[0] != errno.EINVAL or bufsize == max_bufsize:\n                    raise\n            # increase buffer\n            bufsize += 8192\n        # loop over interface names\n        data = buf.tostring()\n        iflist = []\n        size, ptr = struct.unpack(\"iP\", result)\n        i = 0\n        while i < size:\n            ifconf = data[i:i+self.ifr_size]\n            name = struct.unpack(\"16s%ds\" % (self.ifr_size-16), ifconf)[0]\n            name = name.split('\\0', 1)[0]\n            if name:\n                if flags and not (self.getFlags(name) & flags):\n                    continue\n                iflist.append(name)\n            i += self.ifr_size\n        return iflist"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the flags for an interface", "response": "def getFlags (self, ifname):\n        \"\"\"Get the flags for an interface\"\"\"\n        try:\n            result = self._ioctl(self.SIOCGIFFLAGS, self._getifreq(ifname))\n        except IOError as msg:\n            log.warn(LOG_CHECK,\n                 \"error getting flags for interface %r: %s\", ifname, msg)\n            return 0\n        # extract the interface's flags from the return value\n        flags, = struct.unpack('H', result[16:18])\n        # return \"UP\" bit\n        return flags"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getAddr (self, ifname):\n        if sys.platform == 'darwin':\n            return ifconfig_inet(ifname).get('address')\n        return self._getaddr(ifname, self.SIOCGIFADDR)", "response": "Get the inet addr for an interface."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the netmask for an interface.", "response": "def getMask (self, ifname):\n        \"\"\"Get the netmask for an interface.\n        @param ifname: interface name\n        @type ifname: string\n        \"\"\"\n        if sys.platform == 'darwin':\n            return ifconfig_inet(ifname).get('netmask')\n        return self._getaddr(ifname, self.SIOCGIFNETMASK)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getBroadcast (self, ifname):\n        if sys.platform == 'darwin':\n            return ifconfig_inet(ifname).get('broadcast')\n        return self._getaddr(ifname, self.SIOCGIFBRDADDR)", "response": "Get the broadcast addr for an interface."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isLoopback (self, ifname):\n        # since not all systems have IFF_LOOPBACK as a flag defined,\n        # the ifname is tested first\n        if ifname.startswith('lo'):\n            return True\n        return (self.getFlags(ifname) & self.IFF_LOOPBACK) != 0", "response": "Check whether the given interface is a loopback device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_config(cls, configparser):\n        config = dict()\n        config[cls._filename_re_key] = configparser.get(cls.__name__, cls._filename_re_key) \\\n            if configparser.has_option(cls.__name__, cls._filename_re_key) else None\n        return config", "response": "Read configuration file options."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check(self, url_data):\n        content = url_data.get_content()\n        self._check_by_re(url_data, content)\n        self._check_inline_links(url_data, content)", "response": "Extracts urls from the file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _save_url(self, url_data, content, url_text, url_pos):\n        line = content.count('\\n', 0, url_pos) + 1\n        column = url_pos - content.rfind('\\n', 0, url_pos)\n        url_data.add_url(url_text.translate(None, '\\n '), line=line, column=column)", "response": "Saves url. Converts url to 1 - line text and url position as offset from the beginning to the end of the file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind urls by re.", "response": "def _check_by_re(self, url_data, content):\n        \"\"\" Finds urls by re.\n\n        :param url_data: object for url storing\n        :param content: file content\n        \"\"\"\n        for link_re in self._link_res:\n            for u in link_re.finditer(content):\n                self._save_url(url_data, content, u.group(1), u.start(1))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the index where the open_c and close_c characters balanced out.", "response": "def _find_balanced(self, text, start, open_c, close_c):\n        \"\"\"Returns the index where the open_c and close_c characters balance\n        out - the same number of open_c and close_c are encountered - or the\n        end of string if it's reached before the balance point is found.\n        \"\"\"\n        i = start\n        l = len(text)\n        count = 1\n        while count > 0 and i < l:\n            if text[i] == open_c:\n                count += 1\n            elif text[i] == close_c:\n                count -= 1\n            i += 1\n        return i"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts the url and title from the tail of a link.", "response": "def _extract_url_and_title(self, text, start):\n        \"\"\"Extracts the url from the tail of a link.\"\"\"\n        # text[start] equals the opening parenthesis\n        idx = self._whitespace.match(text, start + 1).end()\n        if idx == len(text):\n            return None, None\n        end_idx = idx\n        has_anglebrackets = text[idx] == \"<\"\n        if has_anglebrackets:\n            end_idx = self._find_balanced(text, end_idx+1, \"<\", \">\")\n        end_idx = self._find_balanced(text, end_idx, \"(\", \")\")\n        match = self._inline_link_title.search(text, idx, end_idx)\n        if not match:\n            return None, None\n        url = text[idx:match.start()]\n        if has_anglebrackets:\n            url = self._strip_anglebrackets.sub(r'\\1', url)\n        return url, end_idx"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _check_inline_links(self, url_data, content):\n        MAX_LINK_TEXT_SENTINEL = 3000\n        curr_pos = 0\n        content_length = len(content)\n        while True:  # Handle the next link.\n            # The next '[' is the start of:\n            # - an inline anchor:   [text](url \"title\")\n            # - an inline img:      ![text](url \"title\")\n            # - not markup:         [...anything else...\n            try:\n                start_idx = content.index('[', curr_pos)\n            except ValueError:\n                break\n\n            # Find the matching closing ']'.\n            bracket_depth = 0\n            for p in range(start_idx+1, min(start_idx+MAX_LINK_TEXT_SENTINEL, content_length)):\n                if content[p] == ']':\n                    bracket_depth -= 1\n                    if bracket_depth < 0:\n                        break\n                elif content[p] == '[':\n                    bracket_depth += 1\n            else:\n                # Closing bracket not found within sentinel length. This isn't markup.\n                curr_pos = start_idx + 1\n                continue\n\n            # Now determine what this is by the remainder.\n            p += 1\n            if p >= content_length:\n                return\n\n            if content[p] == '(':\n                url, url_end_idx = self._extract_url_and_title(content, p)\n                if url is not None:\n                    self._save_url(url_data, content, url, p)\n                    start_idx = url_end_idx\n\n            # Otherwise, it isn't markup.\n            curr_pos = start_idx + 1", "response": "Checks inline links.\n\n        :param url_data: url_data object\n        :param content: content for processing"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_meta_url (attr, attrs):\n    res = False\n    if attr == \"content\":\n        equiv = attrs.get_true('http-equiv', u'').lower()\n        scheme = attrs.get_true('scheme', u'').lower()\n        res = equiv in (u'refresh',) or scheme in (u'dcterms.uri',)\n    if attr == \"href\":\n        rel = attrs.get_true('rel', u'').lower()\n        res = rel in (u'shortcut icon', u'icon')\n    return res", "response": "Check if the meta attributes contain a URL."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if this is a GET form action URL.", "response": "def is_form_get(attr, attrs):\n    \"\"\"Check if this is a GET form action URL.\"\"\"\n    res = False\n    if attr == \"action\":\n        method = attrs.get_true('method', u'').lower()\n        res = method != 'post'\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start_element (self, tag, attrs):\n        if tag == 'title':\n            data = self.parser.peek(MAX_TITLELEN)\n            data = data.decode(self.parser.encoding, \"ignore\")\n            self.title = linkname.title_name(data)\n            raise StopParse(\"found <title> tag\")\n        elif tag == 'body':\n            raise StopParse(\"found <body> tag\")", "response": "Search for <title > tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start_element (self, tag, attrs):\n        if tag == 'meta' and attrs.get('name') == 'robots':\n            val = attrs.get_true('content', u'').lower().split(u',')\n            self.follow = u'nofollow' not in val\n            self.index = u'noindex' not in val\n            raise StopParse(\"found <meta name=robots> tag\")\n        elif tag == 'body':\n            raise StopParse(\"found <body> tag\")", "response": "Search for robots. txt nofollow and noindex flags."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start_element (self, tag, attrs):\n        log.debug(LOG_CHECK, \"LinkFinder tag %s attrs %s\", tag, attrs)\n        log.debug(LOG_CHECK, \"line %d col %d old line %d old col %d\", self.parser.lineno(), self.parser.column(), self.parser.last_lineno(), self.parser.last_column())\n        if tag == \"base\" and not self.base_ref:\n            self.base_ref = attrs.get_true(\"href\", u'')\n        tagattrs = self.tags.get(tag, self.universal_attrs)\n        # parse URLs in tag (possibly multiple URLs in CSS styles)\n        for attr in tagattrs.intersection(attrs):\n            if tag == \"meta\" and not is_meta_url(attr, attrs):\n                continue\n            if tag == \"form\" and not is_form_get(attr, attrs):\n                continue\n            # name of this link\n            name = self.get_link_name(tag, attrs, attr)\n            # possible codebase\n            base = u''\n            if tag  == 'applet':\n                base = attrs.get_true('codebase', u'')\n            if not base:\n                base = self.base_ref\n            # note: value can be None\n            value = attrs.get(attr)\n            if tag == 'link' and attrs.get('rel') == 'dns-prefetch':\n                if ':' in value:\n                    value = value.split(':', 1)[1]\n                value = 'dns:' + value.rstrip('/')\n            # parse tag for URLs\n            self.parse_tag(tag, attr, value, name, base)\n        log.debug(LOG_CHECK, \"LinkFinder finished tag %s\", tag)", "response": "Search for links and store found URLs in a list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_link_name (self, tag, attrs, attr):\n        if tag == 'a' and attr == 'href':\n            # Look for name only up to MAX_NAMELEN characters\n            data = self.parser.peek(MAX_NAMELEN)\n            data = data.decode(self.parser.encoding, \"ignore\")\n            name = linkname.href_name(data)\n            if not name:\n                name = attrs.get_true('title', u'')\n        elif tag == 'img':\n            name = attrs.get_true('alt', u'')\n            if not name:\n                name = attrs.get_true('title', u'')\n        else:\n            name = u\"\"\n        return name", "response": "Parse attrs for link name. Return name of link."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the given tag and attribute and value and add it to the url list.", "response": "def parse_tag (self, tag, attr, value, name, base):\n        \"\"\"Add given url data to url list.\"\"\"\n        assert isinstance(tag, unicode), repr(tag)\n        assert isinstance(attr, unicode), repr(attr)\n        assert isinstance(name, unicode), repr(name)\n        assert isinstance(base, unicode), repr(base)\n        assert isinstance(value, unicode) or value is None, repr(value)\n        # look for meta refresh\n        if tag == u'meta' and value:\n            mo = refresh_re.match(value)\n            if mo:\n                self.found_url(mo.group(\"url\"), name, base)\n            elif attr != 'content':\n                self.found_url(value, name, base)\n        elif attr == u'style' and value:\n            for mo in css_url_re.finditer(value):\n                url = unquote(mo.group(\"url\"), matching=True)\n                self.found_url(url, name, base)\n        elif attr == u'archive':\n            for url in value.split(u','):\n                self.found_url(url, name, base)\n        elif attr == u'srcset':\n            for img_candidate in value.split(u','):\n                url = img_candidate.split()[0]\n                self.found_url(url, name, base)\n        else:\n            self.found_url(value, name, base)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef found_url(self, url, name, base):\n        assert isinstance(url, unicode) or url is None, repr(url)\n        self.callback(url, line=self.parser.last_lineno(),\n                      column=self.parser.last_column(), name=name, base=base)", "response": "Add new URL to queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates an object containing the specified name TTL class and type and with the specified list of rdatas in text format.", "response": "def from_text_list(name, ttl, rdclass, rdtype, text_rdatas):\n    \"\"\"Create an RRset with the specified name, TTL, class, and type, and with\n    the specified list of rdatas in text format.\n\n    @rtype: dns.rrset.RRset object\n    \"\"\"\n\n    if isinstance(name, (str, unicode)):\n        name = dns.name.from_text(name, None)\n    if isinstance(rdclass, (str, unicode)):\n        rdclass = dns.rdataclass.from_text(rdclass)\n    if isinstance(rdtype, (str, unicode)):\n        rdtype = dns.rdatatype.from_text(rdtype)\n    r = RRset(name, rdclass, rdtype)\n    r.update_ttl(ttl)\n    for t in text_rdatas:\n        rd = dns.rdata.from_text(r.rdclass, r.rdtype, t)\n        r.add(rd)\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_text(name, ttl, rdclass, rdtype, *text_rdatas):\n\n    return from_text_list(name, ttl, rdclass, rdtype, text_rdatas)", "response": "Create an RRset from a list of text records."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_rdata_list(name, ttl, rdatas):\n\n    if isinstance(name, (str, unicode)):\n        name = dns.name.from_text(name, None)\n\n    if len(rdatas) == 0:\n        raise ValueError(\"rdata list must not be empty\")\n    r = None\n    for rd in rdatas:\n        if r is None:\n            r = RRset(name, rd.rdclass, rd.rdtype)\n            r.update_ttl(ttl)\n            first_time = False\n        r.add(rd)\n    return r", "response": "Create an RRset with the specified name and TTL and with the specified list of rdata objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if this rrset matches the specified class type covers and deletion state.", "response": "def match(self, name, rdclass, rdtype, covers, deleting=None):\n        \"\"\"Returns True if this rrset matches the specified class, type,\n        covers, and deletion state.\"\"\"\n\n        if not super(RRset, self).match(rdclass, rdtype, covers):\n            return False\n        if self.name != name or self.deleting != deleting:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_text(self, origin=None, relativize=True, **kw):\n\n        return super(RRset, self).to_text(self.name, origin, relativize,\n                                          self.deleting, **kw)", "response": "Convert the object to text format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the RRset to wire format.", "response": "def to_wire(self, file, compress=None, origin=None, **kw):\n        \"\"\"Convert the RRset to wire format.\"\"\"\n\n        return super(RRset, self).to_wire(self.name, file, compress, origin,\n                                          self.deleting, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging the url data into the blacklist.", "response": "def log_url (self, url_data):\n        \"\"\"\n        Put invalid url in blacklist, delete valid url from blacklist.\n        \"\"\"\n        key = (url_data.parent_url, url_data.cache_url)\n        key = repr(key)\n        if key in self.blacklist:\n            if url_data.valid:\n                del self.blacklist[key]\n            else:\n                self.blacklist[key] += 1\n        else:\n            if not url_data.valid:\n                self.blacklist[key] = 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a previously stored blacklist from file.", "response": "def read_blacklist (self):\n        \"\"\"\n        Read a previously stored blacklist from file fd.\n        \"\"\"\n        with codecs.open(self.filename, 'r', self.output_encoding,\n                         self.codec_errors) as fd:\n            for line in fd:\n                line = line.rstrip()\n                if line.startswith('#') or not line:\n                    continue\n                value, key = line.split(None, 1)\n                self.blacklist[key] = int(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a zone object from a master file format string.", "response": "def from_text(text, origin = None, rdclass = dns.rdataclass.IN,\n              relativize = True, zone_factory=Zone, filename=None,\n              allow_include=False, check_origin=True):\n    \"\"\"Build a zone object from a master file format string.\n\n    @param text: the master file format input\n    @type text: string.\n    @param origin: The origin of the zone; if not specified, the first\n    $ORIGIN statement in the master file will determine the origin of the\n    zone.\n    @type origin: dns.name.Name object or string\n    @param rdclass: The zone's rdata class; the default is class IN.\n    @type rdclass: int\n    @param relativize: should names be relativized?  The default is True\n    @type relativize: bool\n    @param zone_factory: The zone factory to use\n    @type zone_factory: function returning a Zone\n    @param filename: The filename to emit when describing where an error\n    occurred; the default is '<string>'.\n    @type filename: string\n    @param allow_include: is $INCLUDE allowed?\n    @type allow_include: bool\n    @param check_origin: should sanity checks of the origin node be done?\n    The default is True.\n    @type check_origin: bool\n    @raises dns.zone.NoSOA: No SOA RR was found at the zone origin\n    @raises dns.zone.NoNS: No NS RRset was found at the zone origin\n    @rtype: dns.zone.Zone object\n    \"\"\"\n\n    # 'text' can also be a file, but we don't publish that fact\n    # since it's an implementation detail.  The official file\n    # interface is from_file().\n\n    if filename is None:\n        filename = '<string>'\n    tok = dns.tokenizer.Tokenizer(text, filename)\n    reader = _MasterReader(tok, origin, rdclass, relativize, zone_factory,\n                           allow_include=allow_include,\n                           check_origin=check_origin)\n    reader.read()\n    return reader.zone"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_file(f, origin = None, rdclass = dns.rdataclass.IN,\n              relativize = True, zone_factory=Zone, filename=None,\n              allow_include=True, check_origin=True):\n    \"\"\"Read a master file and build a zone object.\n\n    @param f: file or string.  If I{f} is a string, it is treated\n    as the name of a file to open.\n    @param origin: The origin of the zone; if not specified, the first\n    $ORIGIN statement in the master file will determine the origin of the\n    zone.\n    @type origin: dns.name.Name object or string\n    @param rdclass: The zone's rdata class; the default is class IN.\n    @type rdclass: int\n    @param relativize: should names be relativized?  The default is True\n    @type relativize: bool\n    @param zone_factory: The zone factory to use\n    @type zone_factory: function returning a Zone\n    @param filename: The filename to emit when describing where an error\n    occurred; the default is '<file>', or the value of I{f} if I{f} is a\n    string.\n    @type filename: string\n    @param allow_include: is $INCLUDE allowed?\n    @type allow_include: bool\n    @param check_origin: should sanity checks of the origin node be done?\n    The default is True.\n    @type check_origin: bool\n    @raises dns.zone.NoSOA: No SOA RR was found at the zone origin\n    @raises dns.zone.NoNS: No NS RRset was found at the zone origin\n    @rtype: dns.zone.Zone object\n    \"\"\"\n\n    if sys.hexversion >= 0x02030000:\n        # allow Unicode filenames; turn on universal newline support\n        str_type = basestring\n        opts = 'rU'\n    else:\n        str_type = str\n        opts = 'r'\n    if isinstance(f, str_type):\n        if filename is None:\n            filename = f\n        f = file(f, opts)\n        want_close = True\n    else:\n        if filename is None:\n            filename = '<file>'\n        want_close = False\n\n    try:\n        z = from_text(f, origin, rdclass, relativize, zone_factory,\n                      filename, allow_include, check_origin)\n    finally:\n        if want_close:\n            f.close()\n    return z", "response": "Read a master file and build a Zone object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_xfr(xfr, zone_factory=Zone, relativize=True):\n\n    z = None\n    for r in xfr:\n        if z is None:\n            if relativize:\n                origin = r.origin\n            else:\n                origin = r.answer[0].name\n            rdclass = r.answer[0].rdclass\n            z = zone_factory(origin, rdclass, relativize=relativize)\n        for rrset in r.answer:\n            znode = z.nodes.get(rrset.name)\n            if not znode:\n                znode = z.node_factory()\n                z.nodes[rrset.name] = znode\n            zrds = znode.find_rdataset(rrset.rdclass, rrset.rdtype,\n                                       rrset.covers, True)\n            zrds.update_ttl(rrset.ttl)\n            for rd in rrset:\n                rd.choose_relativity(z.origin, relativize)\n                zrds.add(rd)\n    z.check_origin()\n    return z", "response": "Convert the output of a zone transfer generator into a zone object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds a node in the zone.", "response": "def find_node(self, name, create=False):\n        \"\"\"Find a node in the zone, possibly creating it.\n\n        @param name: the name of the node to find\n        @type name: dns.name.Name object or string\n        @param create: should the node be created if it doesn't exist?\n        @type create: bool\n        @raises KeyError: the name is not known and create was not specified.\n        @rtype: dns.node.Node object\n        \"\"\"\n\n        name = self._validate_name(name)\n        node = self.nodes.get(name)\n        if node is None:\n            if not create:\n                raise KeyError\n            node = self.node_factory()\n            self.nodes[name] = node\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a node in the zone or None if it doesn t exist.", "response": "def get_node(self, name, create=False):\n        \"\"\"Get a node in the zone, possibly creating it.\n\n        This method is like L{find_node}, except it returns None instead\n        of raising an exception if the node does not exist and creation\n        has not been requested.\n\n        @param name: the name of the node to find\n        @type name: dns.name.Name object or string\n        @param create: should the node be created if it doesn't exist?\n        @type create: bool\n        @rtype: dns.node.Node object or None\n        \"\"\"\n\n        try:\n            node = self.find_node(name, create)\n        except KeyError:\n            node = None\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_node(self, name):\n\n        name = self._validate_name(name)\n        if name in self.nodes:\n            del self.nodes[name]", "response": "Delete the specified node if it exists."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE,\n                      create=False):\n        \"\"\"Look for rdata with the specified name and type in the zone,\n        and return an rdataset encapsulating it.\n\n        The I{name}, I{rdtype}, and I{covers} parameters may be\n        strings, in which case they will be converted to their proper\n        type.\n\n        The rdataset returned is not a copy; changes to it will change\n        the zone.\n\n        KeyError is raised if the name or type are not found.\n        Use L{get_rdataset} if you want to have None returned instead.\n\n        @param name: the owner name to look for\n        @type name: DNS.name.Name object or string\n        @param rdtype: the rdata type desired\n        @type rdtype: int or string\n        @param covers: the covered type (defaults to None)\n        @type covers: int or string\n        @param create: should the node and rdataset be created if they do not\n        exist?\n        @type create: bool\n        @raises KeyError: the node or rdata could not be found\n        @rtype: dns.rrset.RRset object\n        \"\"\"\n\n        name = self._validate_name(name)\n        if isinstance(rdtype, (str, unicode)):\n            rdtype = dns.rdatatype.from_text(rdtype)\n        if isinstance(covers, (str, unicode)):\n            covers = dns.rdatatype.from_text(covers)\n        node = self.find_node(name, create)\n        return node.find_rdataset(self.rdclass, rdtype, covers, create)", "response": "Look for a rdata with the specified name and type in the zone and return an rdataset encapsulating it."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlooks for an rdataset with the specified name and type in the zone and return it.", "response": "def get_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE,\n                     create=False):\n        \"\"\"Look for rdata with the specified name and type in the zone,\n        and return an rdataset encapsulating it.\n\n        The I{name}, I{rdtype}, and I{covers} parameters may be\n        strings, in which case they will be converted to their proper\n        type.\n\n        The rdataset returned is not a copy; changes to it will change\n        the zone.\n\n        None is returned if the name or type are not found.\n        Use L{find_rdataset} if you want to have KeyError raised instead.\n\n        @param name: the owner name to look for\n        @type name: DNS.name.Name object or string\n        @param rdtype: the rdata type desired\n        @type rdtype: int or string\n        @param covers: the covered type (defaults to None)\n        @type covers: int or string\n        @param create: should the node and rdataset be created if they do not\n        exist?\n        @type create: bool\n        @rtype: dns.rrset.RRset object\n        \"\"\"\n\n        try:\n            rdataset = self.find_rdataset(name, rdtype, covers, create)\n        except KeyError:\n            rdataset = None\n        return rdataset"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE):\n\n        name = self._validate_name(name)\n        if isinstance(rdtype, (str, unicode)):\n            rdtype = dns.rdatatype.from_text(rdtype)\n        if isinstance(covers, (str, unicode)):\n            covers = dns.rdatatype.from_text(covers)\n        node = self.get_node(name)\n        if not node is None:\n            node.delete_rdataset(self.rdclass, rdtype, covers)\n            if len(node) == 0:\n                self.delete_node(name)", "response": "Delete the rdataset matching I{name rdtype and covers."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef replace_rdataset(self, name, replacement):\n\n        if replacement.rdclass != self.rdclass:\n            raise ValueError('replacement.rdclass != zone.rdclass')\n        node = self.find_node(name, True)\n        node.replace_rdataset(replacement)", "response": "Replace an rdataset at name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlook for a node or rdata with the specified name and type in the zone and return an object that encapsulates it.", "response": "def find_rrset(self, name, rdtype, covers=dns.rdatatype.NONE):\n        \"\"\"Look for rdata with the specified name and type in the zone,\n        and return an RRset encapsulating it.\n\n        The I{name}, I{rdtype}, and I{covers} parameters may be\n        strings, in which case they will be converted to their proper\n        type.\n\n        This method is less efficient than the similar\n        L{find_rdataset} because it creates an RRset instead of\n        returning the matching rdataset.  It may be more convenient\n        for some uses since it returns an object which binds the owner\n        name to the rdata.\n\n        This method may not be used to create new nodes or rdatasets;\n        use L{find_rdataset} instead.\n\n        KeyError is raised if the name or type are not found.\n        Use L{get_rrset} if you want to have None returned instead.\n\n        @param name: the owner name to look for\n        @type name: DNS.name.Name object or string\n        @param rdtype: the rdata type desired\n        @type rdtype: int or string\n        @param covers: the covered type (defaults to None)\n        @type covers: int or string\n        @raises KeyError: the node or rdata could not be found\n        @rtype: dns.rrset.RRset object\n        \"\"\"\n\n        name = self._validate_name(name)\n        if isinstance(rdtype, (str, unicode)):\n            rdtype = dns.rdatatype.from_text(rdtype)\n        if isinstance(covers, (str, unicode)):\n            covers = dns.rdatatype.from_text(covers)\n        rdataset = self.nodes[name].find_rdataset(self.rdclass, rdtype, covers)\n        rrset = dns.rrset.RRset(name, self.rdclass, rdtype, covers)\n        rrset.update(rdataset)\n        return rrset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_rrset(self, name, rdtype, covers=dns.rdatatype.NONE):\n\n        try:\n            rrset = self.find_rrset(name, rdtype, covers)\n        except KeyError:\n            rrset = None\n        return rrset", "response": "Look for a record with the specified name and type in the zone and return an object that encapsulates it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\niterating over all rdatasets in the zone which have the specified I{rdtype and I{covers }.", "response": "def iterate_rdatasets(self, rdtype=dns.rdatatype.ANY,\n                          covers=dns.rdatatype.NONE):\n        \"\"\"Return a generator which yields (name, rdataset) tuples for\n        all rdatasets in the zone which have the specified I{rdtype}\n        and I{covers}.  If I{rdtype} is dns.rdatatype.ANY, the default,\n        then all rdatasets will be matched.\n\n        @param rdtype: int or string\n        @type rdtype: int or string\n        @param covers: the covered type (defaults to None)\n        @type covers: int or string\n        \"\"\"\n\n        if isinstance(rdtype, (str, unicode)):\n            rdtype = dns.rdatatype.from_text(rdtype)\n        if isinstance(covers, (str, unicode)):\n            covers = dns.rdatatype.from_text(covers)\n        for (name, node) in self.iteritems():\n            for rds in node:\n                if rdtype == dns.rdatatype.ANY or \\\n                   (rds.rdtype == rdtype and rds.covers == covers):\n                    yield (name, rds)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iterate_rdatas(self, rdtype=dns.rdatatype.ANY,\n                       covers=dns.rdatatype.NONE):\n        \"\"\"Return a generator which yields (name, ttl, rdata) tuples for\n        all rdatas in the zone which have the specified I{rdtype}\n        and I{covers}.  If I{rdtype} is dns.rdatatype.ANY, the default,\n        then all rdatas will be matched.\n\n        @param rdtype: int or string\n        @type rdtype: int or string\n        @param covers: the covered type (defaults to None)\n        @type covers: int or string\n        \"\"\"\n\n        if isinstance(rdtype, (str, unicode)):\n            rdtype = dns.rdatatype.from_text(rdtype)\n        if isinstance(covers, (str, unicode)):\n            covers = dns.rdatatype.from_text(covers)\n        for (name, node) in self.iteritems():\n            for rds in node:\n                if rdtype == dns.rdatatype.ANY or \\\n                   (rds.rdtype == rdtype and rds.covers == covers):\n                    for rdata in rds:\n                        yield (name, rds.ttl, rdata)", "response": "Iterate over all rdatas in the zone which have the specified I{rdtype and covers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting a zone to a file.", "response": "def to_file(self, f, sorted=True, relativize=True, nl=None):\n        \"\"\"Write a zone to a file.\n\n        @param f: file or string.  If I{f} is a string, it is treated\n        as the name of a file to open.\n        @param sorted: if True, the file will be written with the\n        names sorted in DNSSEC order from least to greatest.  Otherwise\n        the names will be written in whatever order they happen to have\n        in the zone's dictionary.\n        @param relativize: if True, domain names in the output will be\n        relativized to the zone's origin (if possible).\n        @type relativize: bool\n        @param nl: The end of line string.  If not specified, the\n        output will use the platform's native end-of-line marker (i.e.\n        LF on POSIX, CRLF on Windows, CR on Macintosh).\n        @type nl: string or None\n        \"\"\"\n\n        if sys.hexversion >= 0x02030000:\n            # allow Unicode filenames\n            str_type = basestring\n        else:\n            str_type = str\n        if nl is None:\n            opts = 'w'\n        else:\n            opts = 'wb'\n        if isinstance(f, str_type):\n            f = file(f, opts)\n            want_close = True\n        else:\n            want_close = False\n        try:\n            if sorted:\n                names = self.keys()\n                names.sort()\n            else:\n                names = self.iterkeys()\n            for n in names:\n                l = self[n].to_text(n, origin=self.origin,\n                                    relativize=relativize)\n                if nl is None:\n                    print >> f, l\n                else:\n                    f.write(l)\n                    f.write(nl)\n        finally:\n            if want_close:\n                f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_origin(self):\n        if self.relativize:\n            name = dns.name.empty\n        else:\n            name = self.origin\n        if self.get_rdataset(name, dns.rdatatype.SOA) is None:\n            raise NoSOA\n        if self.get_rdataset(name, dns.rdatatype.NS) is None:\n            raise NoNS", "response": "Do some simple checking of the zone s origin."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess one line from a DNS master file.", "response": "def _rr_line(self):\n        \"\"\"Process one line from a DNS master file.\"\"\"\n        # Name\n        if self.current_origin is None:\n            raise UnknownOrigin\n        token = self.tok.get(want_leading = True)\n        if not token.is_whitespace():\n            self.last_name = dns.name.from_text(token.value, self.current_origin)\n        else:\n            token = self.tok.get()\n            if token.is_eol_or_eof():\n                # treat leading WS followed by EOL/EOF as if they were EOL/EOF.\n                return\n            self.tok.unget(token)\n        name = self.last_name\n        if not name.is_subdomain(self.zone.origin):\n            self._eat_line()\n            return\n        if self.relativize:\n            name = name.relativize(self.zone.origin)\n        token = self.tok.get()\n        if not token.is_identifier():\n            raise dns.exception.SyntaxError\n        # TTL\n        try:\n            ttl = dns.ttl.from_text(token.value)\n            token = self.tok.get()\n            if not token.is_identifier():\n                raise dns.exception.SyntaxError\n        except dns.ttl.BadTTL:\n            ttl = self.ttl\n        # Class\n        try:\n            rdclass = dns.rdataclass.from_text(token.value)\n            token = self.tok.get()\n            if not token.is_identifier():\n                raise dns.exception.SyntaxError\n        except dns.exception.SyntaxError:\n            raise\n        except Exception:\n            rdclass = self.zone.rdclass\n        if rdclass != self.zone.rdclass:\n            raise dns.exception.SyntaxError(\"RR class is not zone's class\")\n        # Type\n        try:\n            rdtype = dns.rdatatype.from_text(token.value)\n        except Exception:\n            raise dns.exception.SyntaxError(\"unknown rdatatype '%s'\" % token.value)\n        n = self.zone.nodes.get(name)\n        if n is None:\n            n = self.zone.node_factory()\n            self.zone.nodes[name] = n\n        try:\n            rd = dns.rdata.from_text(rdclass, rdtype, self.tok,\n                                     self.current_origin, False)\n        except dns.exception.SyntaxError:\n            # Catch and reraise.\n            (ty, va) = sys.exc_info()[:2]\n            raise va\n        except Exception:\n            # All exceptions that occur in the processing of rdata\n            # are treated as syntax errors.  This is not strictly\n            # correct, but it is correct almost all of the time.\n            # We convert them to syntax errors so that we can emit\n            # helpful filename:line info.\n            (ty, va) = sys.exc_info()[:2]\n            raise dns.exception.SyntaxError(\"caught exception %s: %s\" % (str(ty), str(va)))\n\n        rd.choose_relativity(self.zone.origin, self.relativize)\n        covers = rd.covers()\n        rds = n.find_rdataset(rdclass, rdtype, covers, True)\n        rds.add(rd, ttl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(self):\n\n        try:\n            while 1:\n                token = self.tok.get(True, True).unescape()\n                if token.is_eof():\n                    if not self.current_file is None:\n                        self.current_file.close()\n                    if len(self.saved_state) > 0:\n                        (self.tok,\n                         self.current_origin,\n                         self.last_name,\n                         self.current_file,\n                         self.ttl) = self.saved_state.pop(-1)\n                        continue\n                    break\n                elif token.is_eol():\n                    continue\n                elif token.is_comment():\n                    self.tok.get_eol()\n                    continue\n                elif token.value[0] == '$':\n                    u = token.value.upper()\n                    if u == '$TTL':\n                        token = self.tok.get()\n                        if not token.is_identifier():\n                            raise dns.exception.SyntaxError(\"bad $TTL\")\n                        self.ttl = dns.ttl.from_text(token.value)\n                        self.tok.get_eol()\n                    elif u == '$ORIGIN':\n                        self.current_origin = self.tok.get_name()\n                        self.tok.get_eol()\n                        if self.zone.origin is None:\n                            self.zone.origin = self.current_origin\n                    elif u == '$INCLUDE' and self.allow_include:\n                        token = self.tok.get()\n                        if not token.is_quoted_string():\n                            raise dns.exception.SyntaxError(\"bad filename in $INCLUDE\")\n                        filename = token.value\n                        token = self.tok.get()\n                        if token.is_identifier():\n                            new_origin = dns.name.from_text(token.value, \\\n                                                            self.current_origin)\n                            self.tok.get_eol()\n                        elif not token.is_eol_or_eof():\n                            raise dns.exception.SyntaxError(\"bad origin in $INCLUDE\")\n                        else:\n                            new_origin = self.current_origin\n                        self.saved_state.append((self.tok,\n                                                 self.current_origin,\n                                                 self.last_name,\n                                                 self.current_file,\n                                                 self.ttl))\n                        self.current_file = file(filename, 'r')\n                        self.tok = dns.tokenizer.Tokenizer(self.current_file,\n                                                           filename)\n                        self.current_origin = new_origin\n                    else:\n                        raise dns.exception.SyntaxError(\"Unknown master file directive '\" + u + \"'\")\n                    continue\n                self.tok.unget(token)\n                self._rr_line()\n        except dns.exception.SyntaxError, detail:\n            (filename, line_number) = self.tok.where()\n            if detail is None:\n                detail = \"syntax error\"\n            raise dns.exception.SyntaxError(\"%s:%d: %s\" % (filename, line_number, detail))\n\n        # Now that we're done reading, do some basic checking of the zone.\n        if self.check_origin:\n            self.zone.check_origin()", "response": "Read a DNS master file and build a zone object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cnormpath (path):\n    path = normpath(path)\n    if os.name == 'nt':\n        # replace slashes with backslashes\n        path = path.replace(\"/\", \"\\\\\")\n    if not os.path.isabs(path):\n        path = normpath(os.path.join(sys.prefix, path))\n    return path", "response": "Norm a path name to platform specific notation and make it absolute."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_release_date ():\n    fname = os.path.join(\"doc\", \"changelog.txt\")\n    release_date = \"unknown\"\n    with open(fname) as fd:\n        # the release date is on the first line\n        line = fd.readline()\n        mo = release_ro.search(line)\n        if mo:\n            release_date = mo.groups(1)\n    return release_date", "response": "Parse and return relase date as string from doc / changelog. txt."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning the C compiler with a simple main program.", "response": "def cc_run (args):\n    \"\"\"Run the C compiler with a simple main program.\n\n    @return: successful exit flag\n    @rtype: bool\n    \"\"\"\n    prog = b\"int main(){}\\n\"\n    pipe = subprocess.Popen(args,\n        stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)\n    pipe.communicate(input=prog)\n    if os.WIFEXITED(pipe.returncode):\n        return os.WEXITSTATUS(pipe.returncode) == 0\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_message_files (package, suffix=\".mo\"):\n    for fname in glob.glob(\"po/*\" + suffix):\n        # basename (without extension) is a locale name\n        localename = os.path.splitext(os.path.basename(fname))[0]\n        domainname = \"%s.mo\" % package.lower()\n        yield (fname, os.path.join(\n            \"share\", \"locale\", localename, \"LC_MESSAGES\", domainname))", "response": "Return list of all found message files and their installation paths."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_manifest ():\n    try:\n        f = open('MANIFEST')\n    except Exception:\n        print('\\n*** SOURCE WARNING: The MANIFEST file is missing!')\n        return\n    try:\n        manifest = [l.strip() for l in f.readlines() if not l.startswith('#')]\n    finally:\n        f.close()\n    err = [line for line in manifest if not os.path.exists(line)]\n    if err:\n        n = len(manifest)\n        print('\\n*** SOURCE WARNING: There are files missing (%d/%d found)!' %\n            (n - len(err), n))\n        print('\\nMissing: '.join(err))", "response": "Snatched from roundup. sf. net.\n    Check that the files listed in the MANIFEST are present when the archive is unpacked."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef install (self):\n        outs = super(MyInstallLib, self).install()\n        infile = self.create_conf_file()\n        outfile = os.path.join(self.install_dir, os.path.basename(infile))\n        self.copy_file(infile, outfile)\n        outs.append(outfile)\n        return outs", "response": "Install the generated config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a configuration file for the current version of the user.", "response": "def create_conf_file (self):\n        \"\"\"Create configuration file.\"\"\"\n        cmd_obj = self.distribution.get_command_obj(\"install\")\n        cmd_obj.ensure_finalized()\n        # we have to write a configuration file because we need the\n        # <install_data> directory (and other stuff like author, url, ...)\n        # all paths are made absolute by cnormpath()\n        data = []\n        for d in ['purelib', 'platlib', 'lib', 'headers', 'scripts', 'data']:\n            attr = 'install_%s' % d\n            if cmd_obj.root:\n                # cut off root path prefix\n                cutoff = len(cmd_obj.root)\n                # don't strip the path separator\n                if cmd_obj.root.endswith(os.sep):\n                    cutoff -= 1\n                val = getattr(cmd_obj, attr)[cutoff:]\n            else:\n                val = getattr(cmd_obj, attr)\n            if attr == 'install_data':\n                cdir = os.path.join(val, \"share\", \"linkchecker\")\n                data.append('config_dir = %r' % cnormpath(cdir))\n            elif attr == 'install_lib':\n                if cmd_obj.root:\n                    _drive, tail = os.path.splitdrive(val)\n                    if tail.startswith(os.sep):\n                        tail = tail[1:]\n                    self.install_lib = os.path.join(cmd_obj.root, tail)\n                else:\n                    self.install_lib = val\n            data.append(\"%s = %r\" % (attr, cnormpath(val)))\n        self.distribution.create_conf_file(data, directory=self.install_lib)\n        return self.get_conf_output()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the generated config file to the list of outputs.", "response": "def get_outputs (self):\n        \"\"\"Add the generated config file to the list of outputs.\"\"\"\n        outs = super(MyInstallLib, self).get_outputs()\n        conf_output = self.get_conf_output()\n        outs.append(conf_output)\n        if self.compile:\n            outs.extend(self._bytecode_filenames([conf_output]))\n        return outs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fix_permissions (self):\n        if os.name == 'posix' and not self.dry_run:\n            # Make the data files we just installed world-readable,\n            # and the directories world-executable as well.\n            for path in self.get_outputs():\n                mode = os.stat(path)[stat.ST_MODE]\n                if stat.S_ISDIR(mode):\n                    mode |= 0o11\n                mode |= 0o44\n                os.chmod(path, mode)", "response": "Set correct read permissions on POSIX systems."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate config file and run commands.", "response": "def run_commands (self):\n        \"\"\"Generate config file and run commands.\"\"\"\n        cwd = os.getcwd()\n        data = []\n        data.append('config_dir = %r' % os.path.join(cwd, \"config\"))\n        data.append(\"install_data = %r\" % cwd)\n        data.append(\"install_scripts = %r\" % cwd)\n        self.create_conf_file(data)\n        super(MyDistribution, self).run_commands()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_conf_file (self, data, directory=None):\n        data.insert(0, \"# this file is automatically created by setup.py\")\n        data.insert(0, \"# -*- coding: iso-8859-1 -*-\")\n        if directory is None:\n            directory = os.getcwd()\n        filename = self.get_conf_filename(directory)\n        # add metadata\n        metanames = (\"name\", \"version\", \"author\", \"author_email\",\n                     \"maintainer\", \"maintainer_email\", \"url\",\n                     \"license\", \"description\", \"long_description\",\n                     \"keywords\", \"platforms\", \"fullname\", \"contact\",\n                     \"contact_email\")\n        for name in metanames:\n            method = \"get_\" + name\n            val = getattr(self.metadata, method)()\n            if isinstance(val, str):\n                val = unicode(val)\n            cmd = \"%s = %r\" % (name, val)\n            data.append(cmd)\n        data.append('release_date = \"%s\"' % get_release_date())\n        data.append('portable = %s' % get_portable())\n        # write the config file\n        util.execute(write_file, (filename, data),\n                     \"creating %s\" % filename, self.verbose >= 1, self.dry_run)", "response": "Create local config file from given data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild the extensions list.", "response": "def build_extensions (self):\n        \"\"\"Add -std=gnu99 to build options if supported.\"\"\"\n        # For gcc >= 3 we can add -std=gnu99 to get rid of warnings.\n        extra = []\n        if self.compiler.compiler_type == 'unix':\n            option = \"-std=gnu99\"\n            if cc_supports_option(self.compiler.compiler, option):\n                extra.append(option)\n        # First, sanity-check the 'extensions' list\n        self.check_extensions_list(self.extensions)\n        for ext in self.extensions:\n            for opt in extra:\n                if opt not in ext.extra_compile_args:\n                    ext.extra_compile_args.append(opt)\n            self.build_extension(ext)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run (self):\n        if self.all:\n            # remove share directory\n            directory = os.path.join(\"build\", \"share\")\n            if os.path.exists(directory):\n                remove_tree(directory, dry_run=self.dry_run)\n            else:\n                log.warn(\"'%s' does not exist -- can't clean it\", directory)\n        clean.run(self)", "response": "Remove share directory on clean."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_address(text):\n    try:\n        parts = list(dns.ipv6.inet_aton(text).encode('hex_codec'))\n        origin = ipv6_reverse_domain\n    except Exception:\n        parts = ['%d' % ord(byte) for byte in dns.ipv4.inet_aton(text)]\n        origin = ipv4_reverse_domain\n    parts.reverse()\n    return dns.name.from_text('.'.join(parts), origin=origin)", "response": "Convert an IPv4 or IPv6 address in textual form into a Name object whose\n    value is the reverse - map domain name of the address."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_address(name):\n    if name.is_subdomain(ipv4_reverse_domain):\n        name = name.relativize(ipv4_reverse_domain)\n        labels = list(name.labels)\n        labels.reverse()\n        text = '.'.join(labels)\n        # run through inet_aton() to check syntax and make pretty.\n        return dns.ipv4.inet_ntoa(dns.ipv4.inet_aton(text))\n    elif name.is_subdomain(ipv6_reverse_domain):\n        name = name.relativize(ipv6_reverse_domain)\n        labels = list(name.labels)\n        labels.reverse()\n        parts = []\n        i = 0\n        l = len(labels)\n        while i < l:\n            parts.append(''.join(labels[i:i+4]))\n            i += 4\n        text = ':'.join(parts)\n        # run through inet_aton() to check syntax and make pretty.\n        return dns.ipv6.inet_ntoa(dns.ipv6.inet_aton(text))\n    else:\n        raise dns.exception.SyntaxError('unknown reverse-map address family')", "response": "Convert a reverse map domain name into textual address form."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_text(text):\n\n    if text.isdigit():\n        v = int(text)\n        if v >= 0 and v <= 4095:\n            return v\n    v = _by_text.get(text.upper())\n    if v is None:\n        raise UnknownRcode\n    return v", "response": "Convert text into an rcode.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_flags(flags, ednsflags):\n\n    value = (flags & 0x000f) | ((ednsflags >> 20) & 0xff0)\n    if value < 0 or value > 4095:\n        raise ValueError('rcode must be >= 0 and <= 4095')\n    return value", "response": "Return the rcode value encoded by flags and ednsflags."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts an rcode to an ednsflags tuple which encodes the rcode.", "response": "def to_flags(value):\n    \"\"\"Return a (flags, ednsflags) tuple which encodes the rcode.\n\n    @param value: the rcode\n    @type value: int\n    @raises ValueError: rcode is < 0 or > 4095\n    @rtype: (int, int) tuple\n    \"\"\"\n\n    if value < 0 or value > 4095:\n        raise ValueError('rcode must be >= 0 and <= 4095')\n    v = value & 0xf\n    ev = long(value & 0xff0) << 20\n    return (v, ev)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting rcode into text.", "response": "def to_text(value):\n    \"\"\"Convert rcode into text.\n\n    @param value: the rcode\n    @type value: int\n    @rtype: string\n    \"\"\"\n\n    text = _by_value.get(value)\n    if text is None:\n        text = str(value)\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nresolve a HTML entity.", "response": "def _resolve_entity (mo):\n    \"\"\"\n    Resolve a HTML entity.\n\n    @param mo: matched _entity_re object with a \"entity\" match group\n    @type mo: MatchObject instance\n    @return: resolved entity char, or empty string on error\n    @rtype: unicode string\n    \"\"\"\n    ent = mo.group(\"entity\")\n    s = mo.group()\n    if s.startswith('&#'):\n        if s[2] in 'xX':\n            radix = 16\n        else:\n            radix = 10\n        try:\n            num = int(ent, radix)\n        except (ValueError, OverflowError):\n            return u''\n    else:\n        num = name2codepoint.get(ent)\n    if num is None or num < 0:\n        # unknown entity -> ignore\n        return u''\n    try:\n        return unichr(num)\n    except ValueError:\n        return u''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the document encoding for the HTML parser according to the HTML meta tag attributes.", "response": "def set_encoding (parsobj, attrs):\n    \"\"\"\n    Set document encoding for the HTML parser according to the <meta>\n    tag attribute information.\n\n    @param attrs: attributes of a <meta> HTML tag\n    @type attrs: dict\n    @return: None\n    \"\"\"\n    charset = attrs.get_true('charset', u'')\n    if charset:\n        # <meta charset=\"utf-8\">\n        # eg. in http://cn.dolphin-browser.com/activity/Dolphinjump\n        charset = charset.encode('ascii', 'ignore').lower()\n    elif attrs.get_true('http-equiv', u'').lower() == u\"content-type\":\n        # <meta http-equiv=\"content-type\" content=\"text/html;charset=\"utf-8\">\n        charset = attrs.get_true('content', u'')\n        charset = charset.encode('ascii', 'ignore').lower()\n        charset = get_ctype_charset(charset)\n    if charset and charset in SUPPORTED_CHARSETS:\n        parsobj.encoding = charset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_ctype_charset (text):\n    for param in text.lower().split(';'):\n        param = param.strip()\n        if param.startswith('charset='):\n            charset = param[8:].strip()\n            try:\n                codecs.lookup(charset)\n                return charset\n            except (LookupError, ValueError):\n                pass\n    return None", "response": "Extract charset information from mime content type string eg."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind a GeoIP database preferring city over country lookup.", "response": "def get_geoip_dat ():\n    \"\"\"Find a GeoIP database, preferring city over country lookup.\"\"\"\n    datafiles = (\"GeoIPCity.dat\", \"GeoIP.dat\")\n    if os.name == 'nt':\n        paths = (sys.exec_prefix, r\"c:\\geoip\")\n    else:\n        paths = (\"/usr/local/share/GeoIP\", \"/usr/share/GeoIP\")\n    for path in paths:\n        for datafile in datafiles:\n            filename = os.path.join(path, datafile)\n            if os.path.isfile(filename):\n                return filename"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets translated country and optional city name.", "response": "def get_location (host):\n    \"\"\"Get translated country and optional city name.\n\n    @return: country with optional city or an boolean False if not found\n    \"\"\"\n    if geoip is None:\n        # no geoip available\n        return None\n    try:\n        record = get_geoip_record(host)\n    except (geoip_error, socket.error):\n        log.debug(LOG_PLUGIN, \"Geoip error for %r\", host, exception=True)\n        # ignore lookup errors\n        return None\n    value = u\"\"\n    if record and record.get(\"city\"):\n        value += unicode_safe(record[\"city\"])\n    if record and record.get(\"country_name\"):\n        if value:\n            value += u\", \"\n        value += unicode_safe(record[\"country_name\"])\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntry to ask GeoIP database for country info.", "response": "def check(self, url_data):\n        \"\"\"Try to ask GeoIP database for country info.\"\"\"\n        location = get_location(url_data.host)\n        if location:\n            url_data.add_info(_(\"URL is located in %(location)s.\") %\n            {\"location\": _(location)})"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the status file for given key.", "response": "def _VmB (VmKey):\n    \"\"\"Parse /proc/<pid>/status file for given key.\n\n    @return: requested number value of status entry\n    @rtype: float\n    \"\"\"\n    if os.name != 'posix':\n        # not supported\n        return 0.0\n    global _proc_status, _scale\n    # get pseudo file /proc/<pid>/status\n    try:\n        t = open(_proc_status)\n        v = t.read()\n        t.close()\n    except IOError:\n        # unsupported platform (non-Linux?)\n        return 0.0\n    # get VmKey line e.g. 'VmRSS:  9999  kB\\n ...'\n    i = v.index(VmKey)\n    v = v[i:].split(None, 3)  # whitespace\n    if len(v) < 3:\n        return 0.0  # invalid format?\n    # convert Vm value to bytes\n    return float(v[1]) * _scale[v[2]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_intern_pattern (url):\n    parts = strformat.url_unicode_split(url)\n    scheme = parts[0].lower()\n    domain = parts[1].lower()\n    domain, is_idn = urlutil.idna_encode(domain)\n    # allow redirection www.example.com -> example.com and vice versa\n    if domain.startswith('www.'):\n        domain = domain[4:]\n    if not (domain and scheme):\n        return None\n    path = urlutil.splitparams(parts[2])[0]\n    segments = path.split('/')[:-1]\n    path = \"/\".join(segments)\n    if url.endswith('/'):\n        path += '/'\n    args = list(re.escape(x) for x in (scheme, domain, path))\n    if args[0] in ('http', 'https'):\n        args[0] = 'https?'\n    args[1] = r\"(www\\.|)%s\" % args[1]\n    return \"^%s://%s%s\" % tuple(args)", "response": "Return intern pattern for given URL."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_intern_pattern (self, url=None):\n        if url is None:\n            url = absolute_url(self.base_url, self.base_ref, self.parent_url)\n        if not url:\n            return None\n        return get_intern_pattern(url)", "response": "Get pattern for intern URL matching."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setdefault (self, key, *args):\n        if key not in self:\n            self._keys.append(key)\n        return super(ListDict, self).setdefault(key, *args)", "response": "Remember key order if key not found."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pop (self, key):\n        if key in self._keys:\n            self._keys.remove(key)\n        super(ListDict, self).pop(key)", "response": "Remove key from dict and return value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves oldest key from dict and return item.", "response": "def popitem (self):\n        \"\"\"Remove oldest key from dict and return item.\"\"\"\n        if self._keys:\n            k = self._keys[0]\n            v = self[k]\n            del self[k]\n            return (k, v)\n        raise KeyError(\"popitem() on empty dictionary\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_true (self, key, default):\n        if key not in self or not self[key]:\n            return default\n        return self[key]", "response": "Get the value of the key if it evaluates to True."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get (self, key, def_val=None):\n        assert isinstance(key, basestring)\n        return dict.get(self, key.lower(), def_val)", "response": "Return lowercase key value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset lowercase key value and return.", "response": "def setdefault (self, key, *args):\n        \"\"\"Set lowercase key value and return.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.setdefault(self, key.lower(), *args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a caseless dict from given data.", "response": "def fromkeys (cls, iterable, value=None):\n        \"\"\"Construct new caseless dict from given data.\"\"\"\n        d = cls()\n        for k in iterable:\n            dict.__setitem__(d, k.lower(), value)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove lowercase key from dict and return value.", "response": "def pop (self, key, *args):\n        \"\"\"Remove lowercase key from dict and return value.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.pop(self, key.lower(), *args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshrinking ca. 5% of entries.", "response": "def shrink (self):\n        \"\"\"Shrink ca. 5% of entries.\"\"\"\n        trim = int(0.05*len(self))\n        if trim:\n            items = super(LFUCache, self).items()\n            # sorting function for items\n            keyfunc = lambda x: x[1][0]\n            values = sorted(items, key=keyfunc)\n            for item in values[0:trim]:\n                del self[item[0]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates key usage if found and return value else set and return_val.", "response": "def setdefault (self, key, def_val=None):\n        \"\"\"Update key usage if found and return value, else set and return\n        default.\"\"\"\n        if key in self:\n            return self[key]\n        self[key] = def_val\n        return def_val"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn list of items not updating usage count.", "response": "def items (self):\n        \"\"\"Return list of items, not updating usage count.\"\"\"\n        return [(key, value[1]) for key, value in super(LFUCache, self).items()]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving and return an item.", "response": "def popitem (self):\n        \"\"\"Remove and return an item.\"\"\"\n        key, value = super(LFUCache, self).popitem()\n        return (key, value[1])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unicode_safe (s, encoding=i18n.default_encoding, errors='replace'):\n    assert s is not None, \"argument to unicode_safe was None\"\n    if isinstance(s, unicode):\n        # s is already unicode, nothing to do\n        return s\n    return unicode(str(s), encoding, errors)", "response": "Return a unicode string without raising encoding errors."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove leading and ending single and double quotes. The quotes need to match if matching is True. Only one quote from each end will be stripped. @return: if s evaluates to False, return s as is, else return string with stripped quotes @rtype: unquoted string, or s unchanged if it is evaluting to False", "response": "def unquote (s, matching=False):\n    \"\"\"Remove leading and ending single and double quotes.\n    The quotes need to match if matching is True. Only one quote from each\n    end will be stripped.\n\n    @return: if s evaluates to False, return s as is, else return\n        string with stripped quotes\n    @rtype: unquoted string, or s unchanged if it is evaluting to False\n    \"\"\"\n    if not s:\n        return s\n    if len(s) < 2:\n        return s\n    if matching:\n        if s[0] in (\"\\\"'\") and s[0] == s[-1]:\n            s = s[1:-1]\n    else:\n        if s[0] in (\"\\\"'\"):\n            s = s[1:]\n        if s[-1] in (\"\\\"'\"):\n            s = s[:-1]\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wrap (text, width, **kwargs):\n    if width <= 0 or not text:\n        return text\n    ret = []\n    for para in get_paragraphs(text):\n        text = \" \".join(para.strip().split())\n        ret.extend(textwrap.wrap(text, width, **kwargs))\n    return os.linesep.join(ret)", "response": "Adjust lines of text to be not longer than width."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nindent each line of text with the given indent string.", "response": "def indent (text, indent_string=\"  \"):\n    \"\"\"Indent each line of text with the given indent string.\"\"\"\n    lines = str(text).splitlines()\n    return os.linesep.join(\"%s%s\" % (indent_string, x) for x in lines)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_line_number (s, index):\n    i = 0\n    if index < 0:\n        return 0\n    line = 1\n    while i < index:\n        if s[i] == '\\n':\n            line += 1\n        i += 1\n    return line", "response": "r Return the line number of s at index."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_markup (s):\n    mo = _markup_re.search(s)\n    while mo:\n        s = s[0:mo.start()] + s[mo.end():]\n        mo = _markup_re.search(s)\n    return s", "response": "Remove all html markup tags from s."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef strsize (b, grouping=True):\n    if b < 0:\n        raise ValueError(\"Invalid negative byte number\")\n    if b < 1024:\n        return u\"%sB\" % locale.format(\"%d\", b, grouping)\n    if b < 1024 * 10:\n        return u\"%sKB\" % locale.format(\"%d\", (b // 1024), grouping)\n    if b < 1024 * 1024:\n        return u\"%sKB\" % locale.format(\"%.2f\", (float(b) / 1024), grouping)\n    if b < 1024 * 1024 * 10:\n        return u\"%sMB\" % locale.format(\"%.2f\", (float(b) / (1024*1024)), grouping)\n    if b < 1024 * 1024 * 1024:\n        return u\"%sMB\" % locale.format(\"%.1f\", (float(b) / (1024*1024)), grouping)\n    if b < 1024 * 1024 * 1024 * 10:\n        return u\"%sGB\" % locale.format(\"%.2f\", (float(b) / (1024*1024*1024)), grouping)\n    return u\"%sGB\" % locale.format(\"%.1f\", (float(b) / (1024*1024*1024)), grouping)", "response": "Return human representation of bytes b. A negative number of bytes\n    raises a value error. A negative number of bytes\n    raises a value error."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn ISO 8601 formatted time.", "response": "def strtime (t, func=time.localtime):\n    \"\"\"Return ISO 8601 formatted time.\"\"\"\n    return time.strftime(\"%Y-%m-%d %H:%M:%S\", func(t)) + strtimezone()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nturning a time value in seconds into hh : mm : ss or mm : ss.", "response": "def strduration (duration):\n    \"\"\"Turn a time value in seconds into hh:mm:ss or mm:ss.\"\"\"\n    if duration < 0:\n        duration = abs(duration)\n        prefix = \"-\"\n    else:\n        prefix = \"\"\n    duration = math.ceil(duration)\n    if duration >= SECONDS_PER_HOUR: # 1 hour\n        # time, in hours:minutes:seconds\n        return \"%s%02d:%02d:%02d\" % (prefix, duration // SECONDS_PER_HOUR,\n                                   (duration % SECONDS_PER_HOUR) // SECONDS_PER_MINUTE,\n                                    duration % SECONDS_PER_MINUTE)\n    else:\n        # time, in minutes:seconds\n        return \"%s%02d:%02d\" % (prefix, duration // SECONDS_PER_MINUTE,\n                                 duration % SECONDS_PER_MINUTE)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strduration_long (duration, do_translate=True):\n    if do_translate:\n        # use global translator functions\n        global _, _n\n    else:\n        # do not translate\n        _ = lambda x: x\n        _n = lambda a, b, n: a if n==1 else b\n    if duration < 0:\n        duration = abs(duration)\n        prefix = \"-\"\n    else:\n        prefix = \"\"\n    if duration < 1:\n        return _(\"%(prefix)s%(duration).02f seconds\") % \\\n               {\"prefix\": prefix, \"duration\": duration}\n    # translation dummies\n    _n(\"%d second\", \"%d seconds\", 1)\n    _n(\"%d minute\", \"%d minutes\", 1)\n    _n(\"%d hour\", \"%d hours\", 1)\n    _n(\"%d day\", \"%d days\", 1)\n    _n(\"%d year\", \"%d years\", 1)\n    cutoffs = [\n        (60, \"%d second\", \"%d seconds\"),\n        (60, \"%d minute\", \"%d minutes\"),\n        (24, \"%d hour\", \"%d hours\"),\n        (365, \"%d day\", \"%d days\"),\n        (None, \"%d year\", \"%d years\"),\n    ]\n    time_str = []\n    for divisor, single, plural in cutoffs:\n        if duration < 1:\n            break\n        if divisor is None:\n            duration, unit = 0, duration\n        else:\n            duration, unit = divmod(duration, divisor)\n        if unit:\n            time_str.append(_n(single, plural, unit) % unit)\n    time_str.reverse()\n    if len(time_str) > 2:\n        time_str.pop()\n    return \"%s%s\" % (prefix, \", \".join(time_str))", "response": "Turn a time value in seconds into x hours x minutes etc."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns timezone info on some platforms but not supported on all platforms.", "response": "def strtimezone ():\n    \"\"\"Return timezone info, %z on some platforms, but not supported on all.\n    \"\"\"\n    if time.daylight:\n        zone = time.altzone\n    else:\n        zone = time.timezone\n    return \"%+04d\" % (-zone//SECONDS_PER_HOUR)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef limit (s, length=72):\n    assert length >= 0, \"length limit must be a non-negative integer\"\n    if not s or len(s) <= length:\n        return s\n    if length == 0:\n        return \"\"\n    return \"%s...\" % s[:length]", "response": "Returns a limited string that is at most length + 3 characters long."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a socket with given family and type.", "response": "def create_socket (family, socktype, proto=0, timeout=60):\n    \"\"\"\n    Create a socket with given family and type. If SSL context\n    is given an SSL socket is created.\n    \"\"\"\n    sock = socket.socket(family, socktype, proto=proto)\n    sock.settimeout(timeout)\n    socktypes_inet = [socket.AF_INET]\n    if has_ipv6:\n        socktypes_inet.append(socket.AF_INET6)\n    if family in socktypes_inet and socktype == socket.SOCK_STREAM:\n        # disable NAGLE algorithm, which means sending pending data\n        # immediately, possibly wasting bandwidth but improving\n        # responsiveness for fast networks\n        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    return sock"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef applies_to(self, url_data):\n        return url_data.valid and url_data.scheme == 'https' and \\\n          not url_data.extern[0] and url_data.url_connection is not None", "response": "Check validity scheme extern and url_connection."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check(self, url_data):\n        host = url_data.urlparts[1]\n        if host in self.checked_hosts:\n            return\n        self.checked_hosts.add(host)\n        cert = url_data.ssl_cert\n        config = url_data.aggregate.config\n        if cert and 'notAfter' in cert:\n            self.check_ssl_valid_date(url_data, cert)\n        elif config['sslverify']:\n            msg = _('certificate did not include \"notAfter\" information')\n            url_data.add_warning(msg)\n        else:\n            msg = _('SSL verification is disabled; enable the sslverify option')\n            url_data.add_warning(msg)", "response": "Run all SSL certificate checks that have not yet been done."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if the certificate is still valid or if configured check if it s at least a number of days valid.", "response": "def check_ssl_valid_date(self, url_data, cert):\n        \"\"\"Check if the certificate is still valid, or if configured check\n        if it's at least a number of days valid.\n        \"\"\"\n        import ssl\n        try:\n            notAfter = ssl.cert_time_to_seconds(cert['notAfter'])\n        except ValueError as msg:\n            msg = _('Invalid SSL certficate \"notAfter\" value %r') % cert['notAfter']\n            url_data.add_warning(msg)\n            return\n        curTime = time.time()\n        # Calculate seconds until certifcate expires. Can be negative if\n        # the certificate is already expired.\n        secondsValid = notAfter - curTime\n        args = dict(expire=cert['notAfter'])\n        if secondsValid < 0:\n            msg = _('SSL certficate is expired on %(expire)s.')\n            url_data.add_warning(msg % args)\n        else:\n            args['valid'] = strformat.strduration_long(secondsValid)\n            if secondsValid < self.warn_ssl_cert_secs_valid:\n                msg = _('SSL certificate expires on %(expire)s and is only %(valid)s valid.')\n                url_data.add_warning(msg % args)\n            else:\n                msg = _('SSL certificate expires on %(expire)s and is %(valid)s valid.')\n                url_data.add_info(msg % args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_config(cls, configparser):\n        config = dict()\n        section = cls.__name__\n        option = sslcertwarndays\n        if configparser.has_option(section, option):\n            num = configparser.getint(section, option)\n            if num > 0:\n                config[option] = num\n            else:\n                msg = _(\"invalid value for %s: %d must not be less than %d\") % (option, num, 0)\n                raise LinkCheckerError(msg)\n        else:\n            # set the default\n            config[option] = 30\n        return config", "response": "Read configuration file options."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check(self, url_data):\n        log.debug(LOG_PLUGIN, \"checking content for invalid anchors\")\n        # list of parsed anchors\n        self.anchors = []\n        find_links(url_data, self.add_anchor, linkparse.AnchorTags)\n        self.check_anchor(url_data)", "response": "Check content for invalid anchors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if URL is parseable and has an anchor.", "response": "def check_anchor(self, url_data):\n        \"\"\"If URL is valid, parseable and has an anchor, check it.\n        A warning is logged and True is returned if the anchor is not found.\n        \"\"\"\n        log.debug(LOG_PLUGIN, \"checking anchor %r in %s\", url_data.anchor, self.anchors)\n        enc = lambda anchor: urlutil.url_quote_part(anchor, encoding=url_data.encoding)\n        if any(x for x in self.anchors if enc(x[0]) == url_data.anchor):\n            return\n        if self.anchors:\n            anchornames = sorted(set(u\"`%s'\" % x[0] for x in self.anchors))\n            anchors = u\", \".join(anchornames)\n        else:\n            anchors = u\"-\"\n        args = {\"name\": url_data.anchor, \"anchors\": anchors}\n        msg = u\"%s %s\" % (_(\"Anchor `%(name)s' not found.\") % args,\n                          _(\"Available anchors: %(anchors)s.\") % args)\n        url_data.add_warning(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,\n          tcp=False, source=None, raise_on_no_answer=True, resolver=None):\n    \"\"\"Query nameservers to find the answer to the question.\n\n    This is a convenience function that uses the default resolver\n    object to make the query.\n    @see: L{dns.resolver.Resolver.query} for more information on the\n    parameters.\"\"\"\n    if resolver is None:\n        resolver = get_default_resolver()\n    return resolver.query(qname, rdtype, rdclass, tcp, source, raise_on_no_answer)", "response": "Query nameservers to find the answer to the question."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef zone_for_name(name, rdclass=dns.rdataclass.IN, tcp=False, resolver=None):\n\n    if isinstance(name, basestring):\n        name = dns.name.from_text(name, dns.name.root)\n    if resolver is None:\n        resolver = get_default_resolver()\n    if not name.is_absolute():\n        raise NotAbsolute(name)\n    while 1:\n        try:\n            answer = resolver.query(name, dns.rdatatype.SOA, rdclass, tcp)\n            if answer.rrset.name == name:\n                return name\n            # otherwise we were CNAMEd or DNAMEd and need to look higher\n        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):\n            pass\n        try:\n            name = name.parent()\n        except dns.name.NoParent:\n            raise NoRootSOA", "response": "Find the name of the zone which contains the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef maybe_clean(self):\n\n        now = time.time()\n        if self.next_cleaning <= now:\n            keys_to_delete = []\n            for (k, v) in self.data.iteritems():\n                if v.expiration <= now:\n                    keys_to_delete.append(k)\n            for k in keys_to_delete:\n                del self.data[k]\n            now = time.time()\n            self.next_cleaning = now + self.cleaning_interval", "response": "Clean the cache if it s time to do so."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, key):\n\n        self.maybe_clean()\n        v = self.data.get(key)\n        if v is None or v.expiration <= time.time():\n            return None\n        return v", "response": "Get the answer associated with I { key. Returns None if no answer is associated with I { key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put(self, key, value):\n\n        self.maybe_clean()\n        self.data[key] = value", "response": "Associate key and value in the cache.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef flush(self, key=None):\n\n        if not key is None:\n            if key in self.data:\n                del self.data[key]\n        else:\n            self.data = {}\n            self.next_cleaning = time.time() + self.cleaning_interval", "response": "Flush the cache.\n\n        If I{key} is specified, only that item is flushed.  Otherwise\n        the entire cache is flushed.\n\n        @param key: the key to flush\n        @type key: (dns.name.Name, int, int) tuple or None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset(self):\n        self.domain = \\\n            dns.name.Name(dns.name.from_text(socket.gethostname())[1:])\n        if len(self.domain) == 0:\n            self.domain = dns.name.root\n        self.nameservers = []\n        self.localhosts = set([\n          'localhost',\n          'loopback',\n          '127.0.0.1',\n          '0.0.0.0',\n          '::1',\n          'ip6-localhost',\n          'ip6-loopback',\n        ])\n        # connected and active network interfaces\n        self.interfaces = set()\n        self.search = set()\n        self.search_patterns = ['www.%s.com', 'www.%s.org', 'www.%s.net', ]\n        self.port = 53\n        self.timeout = 2.0\n        self.lifetime = 30.0\n        self.keyring = None\n        self.keyname = None\n        self.keyalgorithm = dns.tsig.default_algorithm\n        self.edns = -1\n        self.ednsflags = 0\n        self.payload = 0\n        self.cache = None", "response": "Reset all resolver configuration to the defaults."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the resolv. conf file and populate the instance variables.", "response": "def read_resolv_conf(self, f):\n        \"\"\"Process f as a file in the /etc/resolv.conf format.  If f is\n        a string, it is used as the name of the file to open; otherwise it\n        is treated as the file itself.\"\"\"\n        if isinstance(f, basestring):\n            try:\n                f = open(f, 'r')\n            except IOError:\n                # /etc/resolv.conf doesn't exist, can't be read, etc.\n                # We'll just use the default resolver configuration.\n                self.nameservers = ['127.0.0.1']\n                return\n            want_close = True\n        else:\n            want_close = False\n        try:\n            for l in f:\n                l = l.strip()\n                if len(l) == 0 or l[0] == '#' or l[0] == ';':\n                    continue\n                tokens = l.split()\n                if len(tokens) < 2:\n                    continue\n                if tokens[0] == 'nameserver':\n                    self.nameservers.append(tokens[1])\n                elif tokens[0] == 'domain':\n                    self.domain = dns.name.from_text(tokens[1])\n                elif tokens[0] == 'search':\n                    for suffix in tokens[1:]:\n                        self.search.add(dns.name.from_text(suffix))\n        finally:\n            if want_close:\n                f.close()\n        if len(self.nameservers) == 0:\n            self.nameservers.append('127.0.0.1')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_local_ifaddrs (self):\n        if os.name != 'posix':\n            # only POSIX is supported right now\n            return []\n        try:\n            from linkcheck.network import IfConfig\n        except ImportError:\n            return []\n        ifaddrs = []\n        ifc = IfConfig()\n        for iface in ifc.getInterfaceList(flags=IfConfig.IFF_UP):\n            addr = ifc.getAddr(iface)\n            if addr:\n                ifaddrs.append(addr)\n        return ifaddrs", "response": "Reads the local IP addresses for all active interfaces."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconfigure a NameServer registry entry.", "response": "def _config_win32_nameservers(self, nameservers):\n        \"\"\"Configure a NameServer registry entry.\"\"\"\n        # we call str() on nameservers to convert it from unicode to ascii\n        nameservers = str(nameservers)\n        split_char = self._determine_split_char(nameservers)\n        ns_list = nameservers.split(split_char)\n        for ns in ns_list:\n            if not ns in self.nameservers:\n                self.nameservers.append(ns)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconfiguring a Domain registry entry.", "response": "def _config_win32_domain(self, domain):\n        \"\"\"Configure a Domain registry entry.\"\"\"\n        # we call str() on domain to convert it from unicode to ascii\n        self.domain = dns.name.from_text(str(domain))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconfigures a Search registry entry.", "response": "def _config_win32_search(self, search):\n        \"\"\"Configure a Search registry entry.\"\"\"\n        # we call str() on search to convert it from unicode to ascii\n        search = str(search)\n        split_char = self._determine_split_char(search)\n        search_list = search.split(split_char)\n        for s in search_list:\n            if not s in self.search:\n                self.search.add(dns.name.from_text(s))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _config_win32_add_ifaddr (self, key, name):\n        try:\n            ip, rtype = _winreg.QueryValueEx(key, name)\n            if isinstance(ip, basestring) and ip:\n                ip = str(ip).lower()\n                self.localhosts.add(ip)\n                self.interfaces.add(ip)\n        except WindowsError:\n            pass", "response": "Add interface ip address to self. localhosts."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _config_win32_fromkey(self, key):\n        try:\n            enable_dhcp, rtype = _winreg.QueryValueEx(key, 'EnableDHCP')\n        except WindowsError:\n            enable_dhcp = False\n        if enable_dhcp:\n            try:\n                servers, rtype = _winreg.QueryValueEx(key, 'DhcpNameServer')\n            except WindowsError:\n                servers = None\n            if servers:\n                self._config_win32_nameservers(servers)\n                try:\n                    dom, rtype = _winreg.QueryValueEx(key, 'DhcpDomain')\n                    if dom:\n                        self._config_win32_domain(servers)\n                except WindowsError:\n                    pass\n            self._config_win32_add_ifaddr(key, 'DhcpIPAddress')\n        else:\n            try:\n                servers, rtype = _winreg.QueryValueEx(key, 'NameServer')\n            except WindowsError:\n                servers = None\n            if servers:\n                self._config_win32_nameservers(servers)\n                try:\n                    dom, rtype = _winreg.QueryValueEx(key, 'Domain')\n                    if dom:\n                        self._config_win32_domain(servers)\n                except WindowsError:\n                    pass\n            self._config_win32_add_ifaddr(key, 'IPAddress')\n        try:\n            search, rtype = _winreg.QueryValueEx(key, 'SearchList')\n        except WindowsError:\n            search = None\n        if search:\n            self._config_win32_search(search)", "response": "Extract DNS info from a registry key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the resolver configuration from the Windows registry.", "response": "def read_registry(self):\n        \"\"\"Extract resolver configuration from the Windows registry.\"\"\"\n        lm = _winreg.ConnectRegistry(None, _winreg.HKEY_LOCAL_MACHINE)\n        want_scan = False\n        try:\n            try:\n                # XP, 2000\n                tcp_params = _winreg.OpenKey(lm,\n                                             r'SYSTEM\\CurrentControlSet'\n                                             r'\\Services\\Tcpip\\Parameters')\n                want_scan = True\n            except EnvironmentError:\n                # ME\n                tcp_params = _winreg.OpenKey(lm,\n                                             r'SYSTEM\\CurrentControlSet'\n                                             r'\\Services\\VxD\\MSTCP')\n            try:\n                self._config_win32_fromkey(tcp_params)\n            finally:\n                tcp_params.Close()\n            if want_scan:\n                interfaces = _winreg.OpenKey(lm,\n                                             r'SYSTEM\\CurrentControlSet'\n                                             r'\\Services\\Tcpip\\Parameters'\n                                             r'\\Interfaces')\n                try:\n                    i = 0\n                    while True:\n                        try:\n                            guid = _winreg.EnumKey(interfaces, i)\n                            i += 1\n                            key = _winreg.OpenKey(interfaces, guid)\n                            if not self._win32_is_nic_enabled(lm, guid, key):\n                                continue\n                            try:\n                                self._config_win32_fromkey(key)\n                            finally:\n                                key.Close()\n                        except EnvironmentError:\n                            break\n                finally:\n                    interfaces.Close()\n        finally:\n            lm.Close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries the nameservers to find the answer to the question.", "response": "def query(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,\n              tcp=False, source=None, raise_on_no_answer=True):\n        \"\"\"Query nameservers to find the answer to the question.\n\n        The I{qname}, I{rdtype}, and I{rdclass} parameters may be objects\n        of the appropriate type, or strings that can be converted into objects\n        of the appropriate type.  E.g. For I{rdtype} the integer 2 and the\n        the string 'NS' both mean to query for records with DNS rdata type NS.\n\n        @param qname: the query name\n        @type qname: dns.name.Name object or string\n        @param rdtype: the query type\n        @type rdtype: int or string\n        @param rdclass: the query class\n        @type rdclass: int or string\n        @param tcp: use TCP to make the query (default is False).\n        @type tcp: bool\n        @param source: bind to this IP address (defaults to machine default IP).\n        @type source: IP address in dotted quad notation\n        @param raise_on_no_answer: raise NoAnswer if there's no answer\n        (defaults is True).\n        @type raise_on_no_answer: bool\n        @rtype: dns.resolver.Answer instance\n        @raises Timeout: no answers could be found in the specified lifetime\n        @raises NXDOMAIN: the query name does not exist\n        @raises NoAnswer: the response did not contain an answer and\n        raise_on_no_answer is True.\n        @raises NoNameservers: no non-broken nameservers are available to\n        answer the question.\"\"\"\n\n        if isinstance(qname, basestring):\n            qname = dns.name.from_text(qname, None)\n        if isinstance(rdtype, basestring):\n            rdtype = dns.rdatatype.from_text(rdtype)\n        if dns.rdatatype.is_metatype(rdtype):\n            raise NoMetaqueries\n        if isinstance(rdclass, basestring):\n            rdclass = dns.rdataclass.from_text(rdclass)\n        if dns.rdataclass.is_metaclass(rdclass):\n            raise NoMetaqueries\n        qnames_to_try = []\n        if qname.is_absolute():\n            qnames_to_try.append(qname)\n        else:\n            if len(qname) > 1:\n                qnames_to_try.append(qname.concatenate(dns.name.root))\n            if self.search:\n                for suffix in self.search:\n                    qnames_to_try.append(qname.concatenate(suffix))\n            else:\n                qnames_to_try.append(qname.concatenate(self.domain))\n        all_nxdomain = True\n        start = time.time()\n        for qname in qnames_to_try:\n            if self.cache:\n                answer = self.cache.get((qname, rdtype, rdclass))\n                if answer:\n                    return answer\n            request = dns.message.make_query(qname, rdtype, rdclass)\n            if not self.keyname is None:\n                request.use_tsig(self.keyring, self.keyname,\n                                 algorithm=self.keyalgorithm)\n            request.use_edns(self.edns, self.ednsflags, self.payload)\n            response = None\n\n            # make a copy of the servers list so we can alter it later.\n\n            nameservers = self.nameservers[:]\n            backoff = 0.10\n            while response is None:\n                if len(nameservers) == 0:\n                    raise NoNameservers(\"No DNS servers %s could answer the query %s\" % \\\n                      (str(self.nameservers), str(qname)))\n                for nameserver in nameservers[:]:\n                    timeout = self._compute_timeout(start)\n                    try:\n                        if tcp:\n                            response = dns.query.tcp(request, nameserver,\n                                                     timeout, self.port,\n                                                     source=source)\n                        else:\n                            response = dns.query.udp(request, nameserver,\n                                                     timeout, self.port,\n                                                     source=source)\n                    except (socket.error, dns.exception.Timeout):\n\n                        # Communication failure or timeout.  Go to the\n                        # next server\n\n                        response = None\n                        continue\n                    except dns.query.UnexpectedSource:\n\n                        # Who knows?  Keep going.\n\n                        response = None\n                        continue\n                    except dns.exception.FormError:\n\n                        # We don't understand what this server is\n                        # saying.  Take it out of the mix and\n                        # continue.\n\n                        nameservers.remove(nameserver)\n                        response = None\n                        continue\n                    rcode = response.rcode()\n                    if rcode == dns.rcode.NOERROR or \\\n                           rcode == dns.rcode.NXDOMAIN:\n                        break\n\n                    # We got a response, but we're not happy with the\n                    # rcode in it.  Remove the server from the mix if\n                    # the rcode isn't SERVFAIL.\n\n                    if rcode != dns.rcode.SERVFAIL:\n                        nameservers.remove(nameserver)\n                    response = None\n\n                if response is not None:\n                    break\n                # All nameservers failed!\n\n                if len(nameservers) > 0:\n\n                    # But we still have servers to try.  Sleep a bit\n                    # so we don't pound them!\n\n                    timeout = self._compute_timeout(start)\n                    sleep_time = min(timeout, backoff)\n                    backoff *= 2\n                    time.sleep(sleep_time)\n            if response.rcode() == dns.rcode.NXDOMAIN:\n                continue\n            all_nxdomain = False\n            break\n        if all_nxdomain:\n            raise NXDOMAIN(\"Domain does not exist\")\n        answer = Answer(qname, rdtype, rdclass, response,\n                        raise_on_no_answer)\n        if self.cache:\n            self.cache.put((qname, rdtype, rdclass), answer)\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a TSIG signature to the query.", "response": "def use_tsig(self, keyring, keyname=None,\n                 algorithm=dns.tsig.default_algorithm):\n        \"\"\"Add a TSIG signature to the query.\n\n        @param keyring: The TSIG keyring to use; defaults to None.\n        @type keyring: dict\n        @param keyname: The name of the TSIG key to use; defaults to None.\n        The key must be defined in the keyring.  If a keyring is specified\n        but a keyname is not, then the key used will be the first key in the\n        keyring.  Note that the order of keys in a dictionary is not defined,\n        so applications should supply a keyname when a keyring is used, unless\n        they know the keyring contains only one key.\n        @param algorithm: The TSIG key algorithm to use.  The default\n        is dns.tsig.default_algorithm.\n        @type algorithm: string\"\"\"\n        self.keyring = keyring\n        if keyname is None:\n            self.keyname = self.keyring.keys()[0]\n        else:\n            self.keyname = keyname\n        self.keyalgorithm = algorithm"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconfigure the EDNS level and flags of the current object.", "response": "def use_edns(self, edns, ednsflags, payload):\n        \"\"\"Configure Edns.\n\n        @param edns: The EDNS level to use.  The default is -1, no Edns.\n        @type edns: int\n        @param ednsflags: The EDNS flags\n        @type ednsflags: int\n        @param payload: The EDNS payload size.  The default is 0.\n        @type payload: int\"\"\"\n\n        if edns is None:\n            edns = -1\n        self.edns = edns\n        self.ednsflags = ednsflags\n        self.payload = payload"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstall _ and _n gettext methods into default namespace.", "response": "def install_builtin (translator, do_unicode):\n    \"\"\"Install _() and _n() gettext methods into default namespace.\"\"\"\n    try:\n        import __builtin__ as builtins\n    except ImportError:\n        # Python 3\n        import builtins\n    # Python 3 has no ugettext\n    has_unicode = hasattr(translator, 'ugettext')\n    if do_unicode and has_unicode:\n        builtins.__dict__['_'] = translator.ugettext\n        # also install ngettext\n        builtins.__dict__['_n'] = translator.ungettext\n    else:\n        builtins.__dict__['_'] = translator.gettext\n        # also install ngettext\n        builtins.__dict__['_n'] = translator.ngettext"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init (domain, directory, loc=None):\n    global default_language, default_encoding, default_domain, default_directory\n    default_directory = directory\n    default_domain = domain\n    if os.path.isdir(directory):\n        # get supported languages\n        for lang in os.listdir(directory):\n            path = os.path.join(directory, lang, 'LC_MESSAGES')\n            mo_file = os.path.join(path, '%s.mo' % domain)\n            if os.path.exists(mo_file):\n                supported_languages.add(lang)\n    if loc is None:\n        loc, encoding = get_locale()\n    else:\n        encoding = get_locale()[1]\n    if loc in supported_languages:\n        default_language = loc\n    else:\n        default_language = \"en\"\n    # Even if the default language is not supported, the encoding should\n    # be installed. Otherwise the Python installation is borked.\n    default_encoding = encoding\n    install_language(default_language)", "response": "Initialize this gettext i18n module. Searches for supported languages\n    and installs the gettext translator class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninstall translation service routines into default namespace.", "response": "def install_language(language):\n    \"\"\"Install translation service routines into default namespace.\"\"\"\n    translator = get_translator(default_domain, default_directory,\n        languages=[get_lang(language)], fallback=True)\n    do_unicode = True\n    translator.install(do_unicode)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_translator (domain, directory, languages=None,\n                    translatorklass=Translator, fallback=False,\n                    fallbackklass=NullTranslator):\n    \"\"\"Search the appropriate GNUTranslations class.\"\"\"\n    translator = gettext.translation(domain, localedir=directory,\n            languages=languages, class_=translatorklass, fallback=fallback)\n    if not isinstance(translator, gettext.GNUTranslations) and fallbackklass:\n        translator = fallbackklass()\n    return translator", "response": "Search the appropriate GNUTranslations class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning preferred supported language in given HTTP headers.", "response": "def get_headers_lang (headers):\n    \"\"\"Return preferred supported language in given HTTP headers.\"\"\"\n    if 'Accept-Language' not in headers:\n        return default_language\n    languages = headers['Accept-Language'].split(\",\")\n    # sort with preference values\n    pref_languages = []\n    for lang in languages:\n        pref = 1.0\n        if \";\" in lang:\n            lang, _pref = lang.split(';', 1)\n            try:\n                pref = float(_pref)\n            except ValueError:\n                pass\n        pref_languages.append((pref, lang))\n    pref_languages.sort()\n    # search for lang\n    for lang in (x[1] for x in pref_languages):\n        if lang in supported_languages:\n            return lang\n    return default_language"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_locale ():\n    try:\n        loc, encoding = locale.getdefaultlocale()\n    except ValueError:\n        # locale configuration is broken - ignore that\n        loc, encoding = None, None\n    if loc is None:\n        loc = \"C\"\n    else:\n        loc = norm_locale(loc)\n    if encoding is None:\n        encoding = \"ascii\"\n    return (loc, encoding)", "response": "Search the default platform locale and norm it."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_encoded_writer (out=sys.stdout, encoding=None, errors='replace'):\n    if encoding is None:\n        encoding = default_encoding\n    Writer = codecs.getwriter(encoding)\n    return Writer(out, errors)", "response": "Get wrapped output writer with given encoding and error handling."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_rr(self, name, ttl, rd, deleting=None, section=None):\n\n        if section is None:\n            section = self.authority\n        covers = rd.covers()\n        rrset = self.find_rrset(section, name, self.zone_rdclass, rd.rdtype,\n                                covers, deleting, True, True)\n        rrset.add(rd, ttl)", "response": "Add a single RR to the update section."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding records to the record set.", "response": "def _add(self, replace, section, name, *args):\n        \"\"\"Add records.  The first argument is the replace mode.  If\n        false, RRs are added to an existing RRset; if true, the RRset\n        is replaced with the specified contents.  The second\n        argument is the section to add to.  The third argument\n        is always a name.  The other arguments can be:\n\n                - rdataset...\n\n                - ttl, rdata...\n\n                - ttl, rdtype, string...\"\"\"\n\n        if isinstance(name, (str, unicode)):\n            name = dns.name.from_text(name, None)\n        if isinstance(args[0], dns.rdataset.Rdataset):\n            for rds in args:\n                if replace:\n                    self.delete(name, rds.rdtype)\n                for rd in rds:\n                    self._add_rr(name, rds.ttl, rd, section=section)\n        else:\n            args = list(args)\n            ttl = int(args.pop(0))\n            if isinstance(args[0], dns.rdata.Rdata):\n                if replace:\n                    self.delete(name, args[0].rdtype)\n                for rd in args:\n                    self._add_rr(name, ttl, rd, section=section)\n            else:\n                rdtype = args.pop(0)\n                if isinstance(rdtype, str):\n                    rdtype = dns.rdatatype.from_text(rdtype)\n                if replace:\n                    self.delete(name, rdtype)\n                for s in args:\n                    rd = dns.rdata.from_text(self.zone_rdclass, rdtype, s,\n                                             self.origin)\n                    self._add_rr(name, ttl, rd, section=section)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding records. The first argument is always a name. The other arguments can be: - rdataset... - ttl, rdata... - ttl, rdtype, string...", "response": "def add(self, name, *args):\n        \"\"\"Add records.  The first argument is always a name.  The other\n        arguments can be:\n\n                - rdataset...\n\n                - ttl, rdata...\n\n                - ttl, rdtype, string...\"\"\"\n        self._add(False, self.authority, name, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self, name, *args):\n\n        if isinstance(name, (str, unicode)):\n            name = dns.name.from_text(name, None)\n        if len(args) == 0:\n            rrset = self.find_rrset(self.authority, name, dns.rdataclass.ANY,\n                                    dns.rdatatype.ANY, dns.rdatatype.NONE,\n                                    dns.rdatatype.ANY, True, True)\n        elif isinstance(args[0], dns.rdataset.Rdataset):\n            for rds in args:\n                for rd in rds:\n                    self._add_rr(name, 0, rd, dns.rdataclass.NONE)\n        else:\n            args = list(args)\n            if isinstance(args[0], dns.rdata.Rdata):\n                for rd in args:\n                    self._add_rr(name, 0, rd, dns.rdataclass.NONE)\n            else:\n                rdtype = args.pop(0)\n                if isinstance(rdtype, (str, unicode)):\n                    rdtype = dns.rdatatype.from_text(rdtype)\n                if len(args) == 0:\n                    rrset = self.find_rrset(self.authority, name,\n                                            self.zone_rdclass, rdtype,\n                                            dns.rdatatype.NONE,\n                                            dns.rdataclass.ANY,\n                                            True, True)\n                else:\n                    for s in args:\n                        rd = dns.rdata.from_text(self.zone_rdclass, rdtype, s,\n                                                 self.origin)\n                        self._add_rr(name, 0, rd, dns.rdataclass.NONE)", "response": "Delete records.  The first argument is always a name.  The other\n        arguments can be:\n\n                - I{nothing}\n\n                - rdataset...\n\n                - rdata...\n\n                - rdtype, [string...]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef replace(self, name, *args):\n\n        self._add(True, self.authority, name, *args)", "response": "Replace records.  The first argument is always a name.  The other\n        arguments can be:\n\n                - rdataset...\n\n                - ttl, rdata...\n\n                - ttl, rdtype, string...\n\n        Note that if you want to replace the entire node, you should do\n        a delete of the name followed by one or more calls to add."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrequires that an owner name and optionally an rdata type or specific rdataset exists as a prerequisite to the update of the update.", "response": "def present(self, name, *args):\n        \"\"\"Require that an owner name (and optionally an rdata type,\n        or specific rdataset) exists as a prerequisite to the\n        execution of the update.  The first argument is always a name.\n        The other arguments can be:\n\n                - rdataset...\n\n                - rdata...\n\n                - rdtype, string...\"\"\"\n\n        if isinstance(name, (str, unicode)):\n            name = dns.name.from_text(name, None)\n        if len(args) == 0:\n            rrset = self.find_rrset(self.answer, name,\n                                    dns.rdataclass.ANY, dns.rdatatype.ANY,\n                                    dns.rdatatype.NONE, None,\n                                    True, True)\n        elif isinstance(args[0], dns.rdataset.Rdataset) or \\\n             isinstance(args[0], dns.rdata.Rdata) or \\\n             len(args) > 1:\n            if not isinstance(args[0], dns.rdataset.Rdataset):\n                # Add a 0 TTL\n                args = list(args)\n                args.insert(0, 0)\n            self._add(False, self.answer, name, *args)\n        else:\n            rdtype = args[0]\n            if isinstance(rdtype, (str, unicode)):\n                rdtype = dns.rdatatype.from_text(rdtype)\n            rrset = self.find_rrset(self.answer, name,\n                                    dns.rdataclass.ANY, rdtype,\n                                    dns.rdatatype.NONE, None,\n                                    True, True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrequire that an owner name and optionally an rdata type does not exist as a prerequisite to the execution of the update.", "response": "def absent(self, name, rdtype=None):\n        \"\"\"Require that an owner name (and optionally an rdata type) does\n        not exist as a prerequisite to the execution of the update.\"\"\"\n\n        if isinstance(name, (str, unicode)):\n            name = dns.name.from_text(name, None)\n        if rdtype is None:\n            rrset = self.find_rrset(self.answer, name,\n                                    dns.rdataclass.NONE, dns.rdatatype.ANY,\n                                    dns.rdatatype.NONE, None,\n                                    True, True)\n        else:\n            if isinstance(rdtype, (str, unicode)):\n                rdtype = dns.rdatatype.from_text(rdtype)\n            rrset = self.find_rrset(self.answer, name,\n                                    dns.rdataclass.NONE, rdtype,\n                                    dns.rdatatype.NONE, None,\n                                    True, True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the update in DNS compressed wire format.", "response": "def to_wire(self, origin=None, max_size=65535):\n        \"\"\"Return a string containing the update in DNS compressed wire\n        format.\n        @rtype: string\"\"\"\n        if origin is None:\n            origin = self.origin\n        return super(Update, self).to_wire(origin, max_size)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite start of checking info as sql comment.", "response": "def start_output (self):\n        \"\"\"\n        Write start of checking info as sql comment.\n        \"\"\"\n        super(SQLLogger, self).start_output()\n        if self.has_part(\"intro\"):\n            self.write_intro()\n            self.writeln()\n            self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_url (self, url_data):\n        self.writeln(u\"insert into %(table)s(urlname,\"\n              \"parentname,baseref,valid,result,warning,info,url,line,col,\"\n              \"name,checktime,dltime,size,cached,level,modified) values (\"\n              \"%(base_url)s,\"\n              \"%(url_parent)s,\"\n              \"%(base_ref)s,\"\n              \"%(valid)d,\"\n              \"%(result)s,\"\n              \"%(warning)s,\"\n              \"%(info)s,\"\n              \"%(url)s,\"\n              \"%(line)d,\"\n              \"%(column)d,\"\n              \"%(name)s,\"\n              \"%(checktime)d,\"\n              \"%(dltime)d,\"\n              \"%(size)d,\"\n              \"%(cached)d,\"\n              \"%(level)d,\"\n              \"%(modified)s\"\n              \")%(separator)s\" %\n              {'table': self.dbname,\n               'base_url': sqlify(url_data.base_url),\n               'url_parent': sqlify((url_data.parent_url)),\n               'base_ref': sqlify((url_data.base_ref)),\n               'valid': intify(url_data.valid),\n               'result': sqlify(url_data.result),\n               'warning': sqlify(os.linesep.join(x[1] for x in url_data.warnings)),\n               'info': sqlify(os.linesep.join(url_data.info)),\n               'url': sqlify(urlutil.url_quote(url_data.url)),\n               'line': url_data.line,\n               'column': url_data.column,\n               'name': sqlify(url_data.name),\n               'checktime': url_data.checktime,\n               'dltime': url_data.dltime,\n               'size': url_data.size,\n               'cached': 0,\n               'separator': self.separator,\n               \"level\": url_data.level,\n               \"modified\": sqlify(self.format_modified(url_data.modified)),\n              })\n        self.flush()", "response": "Log a URL check info into the database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the alt part of the first img alt = tag in txt.", "response": "def image_name (txt):\n    \"\"\"Return the alt part of the first <img alt=\"\"> tag in txt.\"\"\"\n    mo = imgtag_re.search(txt)\n    if mo:\n        name = strformat.unquote(mo.group('name').strip())\n        return  _unquote(name)\n    return u''"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef href_name (txt):\n    name = u\"\"\n    endtag = a_end_search(txt)\n    if not endtag:\n        return name\n    name = txt[:endtag.start()]\n    if img_re.search(name):\n        return image_name(name)\n    return _unquote(name)", "response": "Return the name part of the first href = name link in txt."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the part of the first title name in txt.", "response": "def title_name (txt):\n    \"\"\"Return the part of the first <title>name</title> in txt.\"\"\"\n    name = u\"\"\n    endtag = title_end_search(txt)\n    if not endtag:\n        return name\n    name = txt[:endtag.start()]\n    return _unquote(name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_memory_dump():\n    # first do a full garbage collection run\n    gc.collect()\n    if gc.garbage:\n        log.warn(LOG_CHECK, \"Unreachabe objects: %s\", pprint.pformat(gc.garbage))\n    from meliae import scanner\n    fo, filename = get_temp_file(mode='wb', suffix='.json', prefix='lcdump_')\n    try:\n        scanner.dump_all_objects(fo)\n    finally:\n        fo.close()\n    return filename", "response": "Dump memory to a temporary file with the meliae package."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_e164(text, origin=public_enum_domain):\n    parts = [d for d in text if d.isdigit()]\n    parts.reverse()\n    return dns.name.from_text('.'.join(parts), origin=origin)", "response": "Convert an E. 164 number in textual form into a Name object whose value is the ENUM domain name for that number."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_e164(name, origin=public_enum_domain, want_plus_prefix=True):\n    if not origin is None:\n        name = name.relativize(origin)\n    dlabels = [d for d in name.labels if (d.isdigit() and len(d) == 1)]\n    if len(dlabels) != len(name.labels):\n        raise dns.exception.SyntaxError('non-digit labels in ENUM domain name')\n    dlabels.reverse()\n    text = ''.join(dlabels)\n    if want_plus_prefix:\n        text = '+' + text\n    return text", "response": "Convert an ENUM domain name into an E. 164 number."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nqueries NAPTR RRs for the specified number in the specified domains.", "response": "def query(number, domains, resolver=None):\n    \"\"\"Look for NAPTR RRs for the specified number in the specified domains.\n\n    e.g. lookup('16505551212', ['e164.dnspython.org.', 'e164.arpa.'])\n    \"\"\"\n    if resolver is None:\n        resolver = dns.resolver.get_default_resolver()\n    for domain in domains:\n        if isinstance(domain, (str, unicode)):\n            domain = dns.name.from_text(domain)\n        qname = dns.e164.from_e164(number, domain)\n        try:\n            return resolver.query(qname, 'NAPTR')\n        except dns.resolver.NXDOMAIN:\n            pass\n    raise dns.resolver.NXDOMAIN"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning new node data or None if node already exists.", "response": "def get_node (self, url_data):\n        \"\"\"Return new node data or None if node already exists.\"\"\"\n        if not url_data.url:\n            return None\n        elif url_data.url in self.nodes:\n            return None\n        node = {\n            \"url\": url_data.url,\n            \"parent_url\": url_data.parent_url,\n            \"id\": self.nodeid,\n            \"label\": quote(url_data.title if url_data.title else url_data.name),\n            \"extern\": 1 if url_data.extern else 0,\n            \"checktime\": url_data.checktime,\n            \"size\": url_data.size,\n            \"dltime\": url_data.dltime,\n            \"edge\": quote(url_data.name),\n            \"valid\": 1 if url_data.valid else 0,\n        }\n        self.nodes[node[\"url\"]] = node\n        self.nodeid += 1\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite all edges in the brute - force manner.", "response": "def write_edges (self):\n        \"\"\"\n        Write all edges we can find in the graph in a brute-force manner.\n        \"\"\"\n        for node in self.nodes.values():\n            if node[\"parent_url\"] in self.nodes:\n                self.write_edge(node)\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites edges and end of checking info as gml comment.", "response": "def end_output (self, **kwargs):\n        \"\"\"Write edges and end of checking info as gml comment.\"\"\"\n        self.write_edges()\n        self.end_graph()\n        if self.has_part(\"outro\"):\n            self.write_outro()\n        self.close_fileoutput()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse cookie data from a text file in HTTP header format.", "response": "def from_file (filename):\n    \"\"\"Parse cookie data from a text file in HTTP header format.\n\n    @return: list of tuples (headers, scheme, host, path)\n    \"\"\"\n    entries = []\n    with open(filename) as fd:\n        lines = []\n        for line in fd.readlines():\n            line = line.rstrip()\n            if not line:\n                if lines:\n                    entries.append(from_headers(\"\\r\\n\".join(lines)))\n                lines = []\n            else:\n                lines.append(line)\n        if lines:\n            entries.append(from_headers(\"\\r\\n\".join(lines)))\n        return entries"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a string in RFC 2616 format.", "response": "def from_headers (strheader):\n    \"\"\"Parse cookie data from a string in HTTP header (RFC 2616) format.\n\n    @return: list of cookies\n    @raises: ValueError for incomplete or invalid data\n    \"\"\"\n    res = []\n    fp = StringIO(strheader)\n    headers = httplib.HTTPMessage(fp, seekable=True)\n    if \"Host\" not in headers:\n        raise ValueError(\"Required header 'Host:' missing\")\n    host = headers[\"Host\"]\n    path= headers.get(\"Path\", \"/\")\n    for header in headers.getallmatchingheaders(\"Set-Cookie\"):\n        headervalue = header.split(':', 1)[1]\n        for pairs in cookielib.split_header_words([headervalue]):\n            for name, value in pairs:\n                cookie = requests.cookies.create_cookie(name, value,\n                    domain=host, path=path)\n                res.append(cookie)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GetConsoleScreenBufferInfo(stream_id=STDOUT):\n    handle = handles[stream_id]\n    csbi = CONSOLE_SCREEN_BUFFER_INFO()\n    success = windll.kernel32.GetConsoleScreenBufferInfo(\n        handle, byref(csbi))\n    if not success:\n        raise WinError()\n    return csbi", "response": "Get console screen buffer info object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef SetConsoleTextAttribute(stream_id, attrs):\n    handle = handles[stream_id]\n    return windll.kernel32.SetConsoleTextAttribute(handle, attrs)", "response": "Set a console text attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init():\n    global _default_foreground, _default_background, _default_style\n    try:\n        attrs = GetConsoleScreenBufferInfo().wAttributes\n    except (ArgumentError, WindowsError):\n        _default_foreground = GREY\n        _default_background = BLACK\n        _default_style = NORMAL\n    else:\n        _default_foreground = attrs & 7\n        _default_background = (attrs >> 4) & 7\n        _default_style = attrs & BRIGHT", "response": "Initialize foreground and background attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_console(stream=STDOUT, foreground=None, background=None, style=None):\n    if foreground is None:\n        foreground = _default_foreground\n    if background is None:\n        background = _default_background\n    if style is None:\n        style = _default_style\n    attrs = get_attrs(foreground, background, style)\n    SetConsoleTextAttribute(stream, attrs)", "response": "Set console foreground and background attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reset (self):\n        super(FtpUrl, self).reset()\n        # list of files for recursion\n        self.files = []\n        # last part of URL filename\n        self.filename = None\n        self.filename_encoding = 'iso-8859-1'", "response": "Reset the FTP url data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_connection (self):\n        # proxy support (we support only http)\n        self.set_proxy(self.aggregate.config[\"proxy\"].get(self.scheme))\n        if self.proxy:\n            # using a (HTTP) proxy\n            http = httpurl.HttpUrl(self.base_url,\n                  self.recursion_level,\n                  self.aggregate,\n                  parent_url=self.parent_url,\n                  base_ref=self.base_ref,\n                  line=self.line,\n                  column=self.column,\n                  name=self.name)\n            http.build_url()\n            return http.check()\n        self.login()\n        self.negotiate_encoding()\n        self.filename = self.cwd()\n        self.listfile()\n        self.files = []\n        return None", "response": "Checks the connection to the aggregate."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef login (self):\n        self.url_connection = ftplib.FTP(timeout=self.aggregate.config[\"timeout\"])\n        if log.is_debug(LOG_CHECK):\n            self.url_connection.set_debuglevel(1)\n        try:\n            self.url_connection.connect(self.host, self.port)\n            _user, _password = self.get_user_password()\n            if _user is None:\n                self.url_connection.login()\n            elif _password is None:\n                self.url_connection.login(_user)\n            else:\n                self.url_connection.login(_user, _password)\n            info = self.url_connection.getwelcome()\n            if info:\n                # note that the info may change every time a user logs in,\n                # so don't add it to the url_data info.\n                log.debug(LOG_CHECK, \"FTP info %s\", info)\n                pass\n            else:\n                raise LinkCheckerError(_(\"Got no answer from FTP server\"))\n        except EOFError as msg:\n            raise LinkCheckerError(\n                      _(\"Remote host has closed connection: %(msg)s\") % str(msg))", "response": "Log into ftp server and check the welcome message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if server can handle UTF - 8 encoded filenames.", "response": "def negotiate_encoding (self):\n        \"\"\"Check if server can handle UTF-8 encoded filenames.\n        See also RFC 2640.\"\"\"\n        try:\n            features = self.url_connection.sendcmd(\"FEAT\")\n        except ftplib.error_perm as msg:\n            log.debug(LOG_CHECK, \"Ignoring error when getting FTP features: %s\" % msg)\n            pass\n        else:\n            log.debug(LOG_CHECK, \"FTP features %s\", features)\n            if \" UTF-8\" in features.splitlines():\n                self.filename_encoding = \"utf-8\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging to URL parent directory. Return filename of last path component.", "response": "def cwd (self):\n        \"\"\"\n        Change to URL parent directory. Return filename of last path\n        component.\n        \"\"\"\n        path = self.urlparts[2].encode(self.filename_encoding, 'replace')\n        dirname = path.strip('/')\n        dirs = dirname.split('/')\n        filename = dirs.pop()\n        self.url_connection.cwd('/')\n        for d in dirs:\n            self.url_connection.cwd(d)\n        return filename"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listfile (self):\n        if not self.filename:\n            return\n        files = self.get_files()\n        log.debug(LOG_CHECK, \"FTP files %s\", str(files))\n        if self.filename in files:\n            # file found\n            return\n        # it could be a directory if the trailing slash was forgotten\n        if \"%s/\" % self.filename in files:\n            if not self.url.endswith('/'):\n                self.add_warning(\n                         _(\"Missing trailing directory slash in ftp url.\"),\n                         tag=WARN_FTP_MISSING_SLASH)\n                self.url += '/'\n            return\n        raise ftplib.error_perm(\"550 File not found\")", "response": "Return the FTP file name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting list of filenames in directory. Subdirectories have an ending slash.", "response": "def get_files (self):\n        \"\"\"Get list of filenames in directory. Subdirectories have an\n        ending slash.\"\"\"\n        files = []\n        def add_entry (line):\n            \"\"\"Parse list line and add the entry it points to to the file\n            list.\"\"\"\n            log.debug(LOG_CHECK, \"Directory entry %r\", line)\n            from ..ftpparse import ftpparse\n            fpo = ftpparse(line)\n            if fpo is not None and fpo[\"name\"]:\n                name = fpo[\"name\"]\n                if fpo[\"trycwd\"]:\n                    name += \"/\"\n                if fpo[\"trycwd\"] or fpo[\"tryretr\"]:\n                    files.append(name)\n        self.url_connection.dir(add_entry)\n        return files"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_parseable (self):\n        if self.is_directory():\n            return True\n        if self.content_type in self.ContentMimetypes:\n            return True\n        log.debug(LOG_CHECK, \"URL with content type %r is not parseable.\", self.content_type)\n        return False", "response": "See if URL target is parseable for recursion."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns URL target content or in case of directories a dummy HTML file with links to the files.", "response": "def read_content (self):\n        \"\"\"Return URL target content, or in case of directories a dummy HTML\n        file with links to the files.\"\"\"\n        if self.is_directory():\n            self.url_connection.cwd(self.filename)\n            self.files = self.get_files()\n            # XXX limit number of files?\n            data = get_index_html(self.files)\n        else:\n            # download file in BINARY mode\n            ftpcmd = \"RETR %s\" % self.filename\n            buf = StringIO()\n            def stor_data (s):\n                \"\"\"Helper method storing given data\"\"\"\n                # limit the download size\n                if (buf.tell() + len(s)) > self.max_size:\n                    raise LinkCheckerError(_(\"FTP file size too large\"))\n                buf.write(s)\n            self.url_connection.retrbinary(ftpcmd, stor_data)\n            data = buf.getvalue()\n            buf.close()\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreleasing the open connection from the connection pool.", "response": "def close_connection (self):\n        \"\"\"Release the open connection from the connection pool.\"\"\"\n        if self.url_connection is not None:\n            try:\n                self.url_connection.quit()\n            except Exception:\n                pass\n            self.url_connection = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns path where all profiles of current user are stored.", "response": "def get_profile_dir ():\n    \"\"\"Return path where all profiles of current user are stored.\"\"\"\n    if os.name == 'nt':\n        basedir = unicode(os.environ[\"APPDATA\"], nt_filename_encoding)\n        dirpath = os.path.join(basedir, u\"Opera\", u\"Opera\")\n    elif os.name == 'posix':\n        basedir = unicode(os.environ[\"HOME\"])\n        dirpath = os.path.join(basedir, u\".opera\")\n    return dirpath"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_bookmark_file ():\n    try:\n        dirname = get_profile_dir()\n        if os.path.isdir(dirname):\n            for name in OperaBookmarkFiles:\n                fname = os.path.join(dirname, name)\n                if os.path.isfile(fname):\n                    return fname\n    except Exception:\n        pass\n    return u\"\"", "response": "Return the absolute filename of the Opera profile."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_bookmark_data (data):\n    name = None\n    lineno = 0\n    for line in data.splitlines():\n        lineno += 1\n        line = line.strip()\n        if line.startswith(\"NAME=\"):\n            name = line[5:]\n        elif line.startswith(\"URL=\"):\n            url = line[4:]\n            if url and name is not None:\n                yield (url, name, lineno)\n        else:\n            name = None", "response": "Parse bookmarks from a string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(args):\n    filename = args[0]\n    marker = args[1]\n    for line in fileinput.input(filename, inplace=1):\n        print(line.rstrip())\n        if line.startswith(marker):\n            break", "response": "Remove lines after marker."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_bookmark_file (profile=\"Default\"):\n    try:\n        dirname = os.path.join(get_profile_dir(), profile)\n        if os.path.isdir(dirname):\n            fname = os.path.join(dirname, \"Bookmarks\")\n            if os.path.isfile(fname):\n                return fname\n    except Exception:\n        pass\n    return u\"\"", "response": "Return the absolute filename of the bookmark file of the Default profile."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_bookmark_data (data):\n    for url, name in parse_bookmark_json(json.loads(data)):\n        yield url, name", "response": "Parse data string.\n    Return iterator for bookmarks of the form url name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_bookmark_file (file):\n    for url, name in parse_bookmark_json(json.load(file)):\n        yield url, name", "response": "Parse a JSON file object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_bookmark_json (data):\n    for entry in data[\"roots\"].values():\n        for url, name in parse_bookmark_node(entry):\n            yield url, name", "response": "Parse complete JSON data for Chromium Bookmarks."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing one JSON node of Chromium Bookmarks.", "response": "def parse_bookmark_node (node):\n    \"\"\"Parse one JSON node of Chromium Bookmarks.\"\"\"\n    if node[\"type\"] == \"url\":\n        yield node[\"url\"], node[\"name\"]\n    elif node[\"type\"] == \"folder\":\n        for child in node[\"children\"]:\n            for entry in parse_bookmark_node(child):\n                yield entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_text(self, name, **kw):\n\n        s = StringIO.StringIO()\n        for rds in self.rdatasets:\n            print >> s, rds.to_text(name, **kw)\n        return s.getvalue()[:-1]", "response": "Convert a node to text format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_rdataset(self, rdclass, rdtype, covers=dns.rdatatype.NONE,\n                      create=False):\n        \"\"\"Find an rdataset matching the specified properties in the\n        current node.\n\n        @param rdclass: The class of the rdataset\n        @type rdclass: int\n        @param rdtype: The type of the rdataset\n        @type rdtype: int\n        @param covers: The covered type.  Usually this value is\n        dns.rdatatype.NONE, but if the rdtype is dns.rdatatype.SIG or\n        dns.rdatatype.RRSIG, then the covers value will be the rdata\n        type the SIG/RRSIG covers.  The library treats the SIG and RRSIG\n        types as if they were a family of\n        types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).  This makes RRSIGs much\n        easier to work with than if RRSIGs covering different rdata\n        types were aggregated into a single RRSIG rdataset.\n        @type covers: int\n        @param create: If True, create the rdataset if it is not found.\n        @type create: bool\n        @raises KeyError: An rdataset of the desired type and class does\n        not exist and I{create} is not True.\n        @rtype: dns.rdataset.Rdataset object\n        \"\"\"\n\n        for rds in self.rdatasets:\n            if rds.match(rdclass, rdtype, covers):\n                return rds\n        if not create:\n            raise KeyError\n        rds = dns.rdataset.Rdataset(rdclass, rdtype)\n        self.rdatasets.append(rds)\n        return rds", "response": "Find an rdataset matching the specified properties in the current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an rdataset matching the specified properties in the current node.", "response": "def get_rdataset(self, rdclass, rdtype, covers=dns.rdatatype.NONE,\n                     create=False):\n        \"\"\"Get an rdataset matching the specified properties in the\n        current node.\n\n        None is returned if an rdataset of the specified type and\n        class does not exist and I{create} is not True.\n\n        @param rdclass: The class of the rdataset\n        @type rdclass: int\n        @param rdtype: The type of the rdataset\n        @type rdtype: int\n        @param covers: The covered type.\n        @type covers: int\n        @param create: If True, create the rdataset if it is not found.\n        @type create: bool\n        @rtype: dns.rdataset.Rdataset object or None\n        \"\"\"\n\n        try:\n            rds = self.find_rdataset(rdclass, rdtype, covers, create)\n        except KeyError:\n            rds = None\n        return rds"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_rdataset(self, rdclass, rdtype, covers=dns.rdatatype.NONE):\n\n        rds = self.get_rdataset(rdclass, rdtype, covers)\n        if not rds is None:\n            self.rdatasets.remove(rds)", "response": "Delete the rdataset matching the specified properties in the current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace_rdataset(self, replacement):\n\n        self.delete_rdataset(replacement.rdclass, replacement.rdtype,\n                             replacement.covers)\n        self.rdatasets.append(replacement)", "response": "Replace an rdataset with another."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef poll(self):\n        #print len(self.connections)\n        ## Build a list of connections to test for receive data pending\n        recv_list = [self.server_fileno]    # always add the server\n\n        for client in self.clients.values():\n            if client.active:\n                recv_list.append(client.fileno)\n            ## Delete inactive connections from the dictionary\n            else:\n                #print \"-- Lost connection to %s\" % client.addrport()\n                #client.sock.close()\n                self.on_disconnect(client)\n                del self.clients[client.fileno]\n\n\n        ## Build a list of connections that need to send data\n        send_list = []\n        for client in self.clients.values():\n            if client.send_pending:\n                send_list.append(client.fileno)\n\n        ## Get active socket file descriptors from select.select()\n        try:\n            rlist, slist, elist = select.select(recv_list, send_list, [],\n                self.timeout)\n\n        except select.error, err:\n            ## If we can't even use select(), game over man, game over\n            print >> sys.stderr, (\"!! FATAL SELECT error '%d:%s'!\"\n                % (err[0], err[1]))\n            sys.exit(1)\n\n        ## Process socket file descriptors with data to recieve\n        for sock_fileno in rlist:\n\n            ## If it's coming from the server's socket then this is a new\n            ## connection request.\n            if sock_fileno == self.server_fileno:\n\n                try:\n                    sock, addr_tup = self.server_socket.accept()\n\n                except socket.error, err:\n                    print >> sys.stderr, (\"!! ACCEPT error '%d:%s'.\" %\n                        (err[0], err[1]))\n                    continue\n\n                ## Check for maximum connections\n                if self.client_count() >= MAX_CONNECTIONS:\n                    print '?? Refusing new connection; maximum in use.'\n                    sock.close()\n                    continue\n\n                new_client = TelnetClient(sock, addr_tup)\n                #print \"++ Opened connection to %s\" % new_client.addrport()\n                ## Add the connection to our dictionary and call handler\n                self.clients[new_client.fileno] = new_client\n                self.on_connect(new_client)\n\n            else:\n                ## Call the connection's recieve method\n                try:\n                    self.clients[sock_fileno].socket_recv()\n                except BogConnectionLost:\n                    self.clients[sock_fileno].deactivate()\n\n        ## Process sockets with data to send\n        for sock_fileno in slist:\n            ## Call the connection's send method\n            self.clients[sock_fileno].socket_send()", "response": "Perform a non - blocking scan of the server and client connection sockets and process new connection requests and send outgoing data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a dictionary containing ( textual DNS name base64 secret ) pairs into a dictionary containing ( dns. name. Name binary secret ) pairs .", "response": "def from_text(textring):\n    \"\"\"Convert a dictionary containing (textual DNS name, base64 secret) pairs\n    into a binary keyring which has (dns.name.Name, binary secret) pairs.\n    @rtype: dict\"\"\"\n\n    keyring = {}\n    for keytext in textring:\n        keyname = dns.name.from_text(keytext)\n        secret = base64.decodestring(textring[keytext])\n        keyring[keyname] = secret\n    return keyring"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a dictionary containing DNS name and base64 secret pairs into a text keyring which has ( textual DNS name base64 secret pairs.", "response": "def to_text(keyring):\n    \"\"\"Convert a dictionary containing (dns.name.Name, binary secret) pairs\n    into a text keyring which has (textual DNS name, base64 secret) pairs.\n    @rtype: dict\"\"\"\n\n    textring = {}\n    for keyname in keyring:\n        keytext = dns.name.to_text(keyname)\n        secret = base64.encodestring(keyring[keyname])\n        textring[keytext] = secret\n    return textring"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the application logging.", "response": "def init_log_config(handler=None):\n    \"\"\"Set up the application logging (not to be confused with check loggers).\n    \"\"\"\n    for applog in lognames.values():\n        # propagate except for root app logger 'linkcheck'\n        propagate = (applog != LOG_ROOT)\n        configdict['loggers'][applog] = dict(level='INFO', propagate=propagate)\n\n    logging.config.dictConfig(configdict)\n    if handler is None:\n        handler = ansicolor.ColoredStreamHandler(strm=sys.stderr)\n    add_loghandler(handler)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds log handler to root logger and LOG_ROOT and set formatting.", "response": "def add_loghandler (handler):\n    \"\"\"Add log handler to root logger and LOG_ROOT and set formatting.\"\"\"\n    format = \"%(levelname)s %(name)s %(asctime)s %(threadName)s %(message)s\"\n    handler.setFormatter(logging.Formatter(format))\n    logging.getLogger(LOG_ROOT).addHandler(handler)\n    logging.getLogger().addHandler(handler)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving log handler from root logger and LOG_ROOT.", "response": "def remove_loghandler (handler):\n    \"\"\"Remove log handler from root logger and LOG_ROOT.\"\"\"\n    logging.getLogger(LOG_ROOT).removeHandler(handler)\n    logging.getLogger().removeHandler(handler)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset logging levels for given loggers.", "response": "def set_loglevel(loggers, level):\n    \"\"\"Set logging levels for given loggers.\"\"\"\n    if not loggers:\n        return\n    if 'all' in loggers:\n        loggers = lognames.keys()\n    for key in loggers:\n        logging.getLogger(lognames[key]).setLevel(level)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start_output (self):\n        super(GraphXMLLogger, self).start_output()\n        self.xml_start_output()\n        self.xml_starttag(u'GraphXML')\n        self.xml_starttag(u'graph', attrs={u\"isDirected\": u\"true\"})\n        self.flush()", "response": "Write start of checking info as xml comment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef log_url (self, url_data):\n        node = self.get_node(url_data)\n        if node:\n            self.xml_starttag(u'node', attrs={u\"name\": u\"%d\" % node[\"id\"]})\n            self.xml_tag(u\"label\", node[\"label\"])\n            if self.has_part(\"realurl\"):\n                self.xml_tag(u\"url\", node[\"url\"])\n            self.xml_starttag(u\"data\")\n            if node[\"dltime\"] >= 0 and self.has_part(\"dltime\"):\n                self.xml_tag(u\"dltime\", u\"%f\" % node[\"dltime\"])\n            if node[\"size\"] >= 0 and self.has_part(\"dlsize\"):\n                self.xml_tag(u\"size\", u\"%d\" % node[\"size\"])\n            if node[\"checktime\"] and self.has_part(\"checktime\"):\n                self.xml_tag(u\"checktime\", u\"%f\" % node[\"checktime\"])\n            if self.has_part(\"extern\"):\n                self.xml_tag(u\"extern\", u\"%d\" % node[\"extern\"])\n            self.xml_endtag(u\"data\")\n            self.xml_endtag(u\"node\")", "response": "Write one node and all possible edges."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinishes graph output and print end of checking info as xml comment.", "response": "def end_output (self, **kwargs):\n        \"\"\"Finish graph output, and print end of checking info as xml\n        comment.\"\"\"\n        self.xml_endtag(u\"graph\")\n        self.xml_endtag(u\"GraphXML\")\n        self.xml_end_output()\n        self.close_fileoutput()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert text into a DNS rdata class value.", "response": "def from_text(text):\n    \"\"\"Convert text into a DNS rdata class value.\n    @param text: the text\n    @type text: string\n    @rtype: int\n    @raises dns.rdataclass.UnknownRdataClass: the class is unknown\n    @raises ValueError: the rdata class value is not >= 0 and <= 65535\n    \"\"\"\n\n    value = _by_text.get(text.upper())\n    if value is None:\n        match = _unknown_class_pattern.match(text)\n        if match == None:\n            raise UnknownRdataclass\n        value = int(match.group(1))\n        if value < 0 or value > 65535:\n            raise ValueError(\"class must be between >= 0 and <= 65535\")\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a DNS rdata class value to text.", "response": "def to_text(value):\n    \"\"\"Convert a DNS rdata class to text.\n    @param value: the rdata class value\n    @type value: int\n    @rtype: string\n    @raises ValueError: the rdata class value is not >= 0 and <= 65535\n    \"\"\"\n\n    if value < 0 or value > 65535:\n        raise ValueError(\"class must be between >= 0 and <= 65535\")\n    text = _by_value.get(value)\n    if text is None:\n        text = 'CLASS' + repr(value)\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _reset (self):\n        self.entries = []\n        self.default_entry = None\n        self.disallow_all = False\n        self.allow_all = False\n        self.last_checked = 0\n        # list of tuples (sitemap url, line number)\n        self.sitemap_urls = []", "response": "Reset internal flags and entry lists."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the URL referring to a robots. txt file.", "response": "def set_url (self, url):\n        \"\"\"Set the URL referring to a robots.txt file.\"\"\"\n        self.url = url\n        self.host, self.path = urlparse.urlparse(url)[1:3]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the robots. txt URL and feeds it to the parser.", "response": "def read (self):\n        \"\"\"Read the robots.txt URL and feeds it to the parser.\"\"\"\n        self._reset()\n        kwargs = dict(\n            headers = {\n                'User-Agent': configuration.UserAgent,\n                'Accept-Encoding': ACCEPT_ENCODING,\n            }\n        )\n        if self.auth:\n            kwargs[\"auth\"] = self.auth\n        if self.proxies:\n            kwargs[\"proxies\"] = self.proxies\n        try:\n            response = self.session.get(self.url, **kwargs)\n            response.raise_for_status()\n            content_type = response.headers.get('content-type')\n            if content_type and content_type.lower().startswith('text/plain'):\n                self.parse(response.iter_lines())\n            else:\n                log.debug(LOG_CHECK, \"%r allow all (no text content)\", self.url)\n                self.allow_all = True\n        except requests.HTTPError as x:\n            if x.response.status_code in (401, 403):\n                self.disallow_all = True\n                log.debug(LOG_CHECK, \"%r disallow all (code %d)\", self.url, x.response.status_code)\n            else:\n                self.allow_all = True\n                log.debug(LOG_CHECK, \"%r allow all (HTTP error)\", self.url)\n        except requests.exceptions.Timeout:\n            raise\n        except requests.exceptions.RequestException:\n            # no network or other failure\n            self.allow_all = True\n            log.debug(LOG_CHECK, \"%r allow all (request error)\", self.url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_entry (self, entry):\n        if \"*\" in entry.useragents:\n            # the default entry is considered last\n            self.default_entry = entry\n        else:\n            self.entries.append(entry)", "response": "Add a parsed entry to the list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the input lines from a robot. txt file.", "response": "def parse (self, lines):\n        \"\"\"Parse the input lines from a robot.txt file.\n        We allow that a user-agent: line is not preceded by\n        one or more blank lines.\n\n        @return: None\n        \"\"\"\n        log.debug(LOG_CHECK, \"%r parse lines\", self.url)\n        state = 0\n        linenumber = 0\n        entry = Entry()\n\n        for line in lines:\n            line = line.strip()\n            linenumber += 1\n            if not line:\n                if state == 1:\n                    log.debug(LOG_CHECK, \"%r line %d: allow or disallow directives without any user-agent line\", self.url, linenumber)\n                    entry = Entry()\n                    state = 0\n                elif state == 2:\n                    self._add_entry(entry)\n                    entry = Entry()\n                    state = 0\n            # remove optional comment and strip line\n            i = line.find('#')\n            if i >= 0:\n                line = line[:i]\n            line = line.strip()\n            if not line:\n                continue\n            line = line.split(':', 1)\n            if len(line) == 2:\n                line[0] = line[0].strip().lower()\n                line[1] = urllib.unquote(line[1].strip())\n                if line[0] == \"user-agent\":\n                    if state == 2:\n                        log.debug(LOG_CHECK, \"%r line %d: missing blank line before user-agent directive\", self.url, linenumber)\n                        self._add_entry(entry)\n                        entry = Entry()\n                    entry.useragents.append(line[1])\n                    state = 1\n                elif line[0] == \"disallow\":\n                    if state == 0:\n                        log.debug(LOG_CHECK, \"%r line %d: missing user-agent directive before this line\", self.url, linenumber)\n                        pass\n                    else:\n                        entry.rulelines.append(RuleLine(line[1], False))\n                        state = 2\n                elif line[0] == \"allow\":\n                    if state == 0:\n                        log.debug(LOG_CHECK, \"%r line %d: missing user-agent directive before this line\", self.url, linenumber)\n                        pass\n                    else:\n                        entry.rulelines.append(RuleLine(line[1], True))\n                        state = 2\n                elif line[0] == \"crawl-delay\":\n                    if state == 0:\n                        log.debug(LOG_CHECK, \"%r line %d: missing user-agent directive before this line\", self.url, linenumber)\n                        pass\n                    else:\n                        try:\n                            entry.crawldelay = max(0, int(line[1]))\n                            state = 2\n                        except (ValueError, OverflowError):\n                            log.debug(LOG_CHECK, \"%r line %d: invalid delay number %r\", self.url, linenumber, line[1])\n                            pass\n                elif line[0] == \"sitemap\":\n                    # Note that sitemap URLs must be absolute according to\n                    # http://www.sitemaps.org/protocol.html#submit_robots\n                    # But this should be checked by the calling layer.\n                    self.sitemap_urls.append((line[1], linenumber))\n                else:\n                    log.debug(LOG_CHECK, \"%r line %d: unknown key %r\", self.url, linenumber, line[0])\n                    pass\n            else:\n                log.debug(LOG_CHECK, \"%r line %d: malformed line %r\", self.url, linenumber, line)\n                pass\n        if state in (1, 2):\n            self.entries.append(entry)\n        self.modified()\n        log.debug(LOG_CHECK, \"Parsed rules:\\n%s\", str(self))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if useragent can fetch url False otherwise.", "response": "def can_fetch (self, useragent, url):\n        \"\"\"Using the parsed robots.txt decide if useragent can fetch url.\n\n        @return: True if agent can fetch url, else False\n        @rtype: bool\n        \"\"\"\n        log.debug(LOG_CHECK, \"%r check allowance for:\\n  user agent: %r\\n  url: %r ...\", self.url, useragent, url)\n        if not isinstance(useragent, str):\n            useragent = useragent.encode(\"ascii\", \"ignore\")\n        if not isinstance(url, str):\n            url = url.encode(\"ascii\", \"ignore\")\n        if self.disallow_all:\n            log.debug(LOG_CHECK, \" ... disallow all.\")\n            return False\n        if self.allow_all:\n            log.debug(LOG_CHECK, \" ... allow all.\")\n            return True\n        # search for given user agent matches\n        # the first match counts\n        url = urllib.quote(urlparse.urlparse(urllib.unquote(url))[2]) or \"/\"\n        for entry in self.entries:\n            if entry.applies_to(useragent):\n                return entry.allowance(url)\n        # try the default entry last\n        if self.default_entry is not None:\n            return self.default_entry.allowance(url)\n        # agent not found ==> access granted\n        log.debug(LOG_CHECK, \" ... agent not found, allow.\")\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the number of seconds until the user has requested a crawl delay.", "response": "def get_crawldelay (self, useragent):\n        \"\"\"Look for a configured crawl delay.\n\n        @return: crawl delay in seconds or zero\n        @rtype: integer >= 0\n        \"\"\"\n        for entry in self.entries:\n            if entry.applies_to(useragent):\n                return entry.crawldelay\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if this entry applies to the specified agent.", "response": "def applies_to (self, useragent):\n        \"\"\"Check if this entry applies to the specified agent.\n\n        @return: True if this entry applies to the agent, else False.\n        @rtype: bool\n        \"\"\"\n        if not useragent:\n            return True\n        useragent = useragent.lower()\n        for agent in self.useragents:\n            if agent == '*':\n                # we have the catch-all agent\n                return True\n            if agent.lower() in useragent:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if given filename is allowed to acces this entry.", "response": "def allowance (self, filename):\n        \"\"\"Preconditions:\n        - our agent applies to this entry\n        - filename is URL decoded\n\n        Check if given filename is allowed to acces this entry.\n\n        @return: True if allowed, else False\n        @rtype: bool\n        \"\"\"\n        for line in self.rulelines:\n            log.debug(LOG_CHECK, \"%s %s %s\", filename, str(line), line.allowance)\n            if line.applies_to(filename):\n                log.debug(LOG_CHECK, \" ... rule line %s\", line)\n                return line.allowance\n        log.debug(LOG_CHECK, \" ... no rule lines of %s applied to %s; allowed.\", self.useragents, filename)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_result(self, key, result):\n        if len(self.cache) > self.max_size:\n            return\n        if key is not None:\n            self.cache[key] = result", "response": "Add result object to cache with given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter_tree(tree):\n    to_remove = []\n    for elem in tree.findall('urldata'):\n        valid = elem.find('valid')\n        if valid is not None and valid.text == '0' and \\\n           valid.attrib.get('result', '').startswith('401'):\n            to_remove.append(elem)\n    root = tree.getroot()\n    for elem in to_remove:\n        root.remove(elem)", "response": "Filter all 401 errors."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_connection (self):\n        nntpserver = self.host or self.aggregate.config[\"nntpserver\"]\n        if not nntpserver:\n            self.add_warning(\n                    _(\"No NNTP server was specified, skipping this URL.\"),\n                    tag=WARN_NNTP_NO_SERVER)\n            return\n        nntp = self._connect_nntp(nntpserver)\n        group = self.urlparts[2]\n        while group[:1] == '/':\n            group = group[1:]\n        if '@' in group:\n            # request article info (resp, number mid)\n            number = nntp.stat(\"<\"+group+\">\")[1]\n            self.add_info(_('Article number %(num)s found.') % {\"num\": number})\n        else:\n            # split off trailing articel span\n            group = group.split('/', 1)[0]\n            if group:\n                # request group info (resp, count, first, last, name)\n                name = nntp.group(group)[4]\n                self.add_info(_(\"News group %(name)s found.\") % {\"name\": name})\n            else:\n                # group name is the empty string\n                self.add_warning(_(\"No newsgroup specified in NNTP URL.\"),\n                            tag=WARN_NNTP_NO_NEWSGROUP)", "response": "Connect to NNTP server and request the URL article\n            resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconnects to NNTP server and return nntp object.", "response": "def _connect_nntp (self, nntpserver):\n        \"\"\"\n        This is done only once per checking task. Also, the newly\n        introduced error codes 504 and 505 (both inclining \"Too busy, retry\n        later\", are caught.\n        \"\"\"\n        tries = 0\n        nntp = None\n        while tries < 2:\n            tries += 1\n            try:\n                nntp = nntplib.NNTP(nntpserver, usenetrc=False)\n            except nntplib.NNTPTemporaryError:\n                self.wait()\n            except nntplib.NNTPPermanentError as msg:\n                if re.compile(\"^50[45]\").search(str(msg)):\n                    self.wait()\n                else:\n                    raise\n        if nntp is None:\n            raise LinkCheckerError(\n               _(\"NNTP server too busy; tried more than %d times.\") % tries)\n        if log.is_debug(LOG_CHECK):\n            nntp.set_debuglevel(1)\n        self.add_info(nntp.getwelcome())\n        return nntp"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_fileoutput (self, args):\n        super(TextLogger, self).init_fileoutput(args)\n        if self.fd is not None:\n            self.fd = ansicolor.Colorizer(self.fd)", "response": "Colorize file output if possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start_fileoutput (self):\n        init_color = self.fd is None\n        super(TextLogger, self).start_fileoutput()\n        if init_color:\n            self.fd = ansicolor.Colorizer(self.fd)", "response": "Needed to make file descriptor color aware."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start_output (self):\n        super(TextLogger, self).start_output()\n        if self.has_part('intro'):\n            self.write_intro()\n        self.flush()", "response": "Write generic start checking info."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite url checking info.", "response": "def log_url (self, url_data):\n        \"\"\"Write url checking info.\"\"\"\n        self.writeln()\n        if self.has_part('url'):\n            self.write_url(url_data)\n        if url_data.name and self.has_part('name'):\n            self.write_name(url_data)\n        if url_data.parent_url and self.has_part('parenturl'):\n            self.write_parent(url_data)\n        if url_data.base_ref and self.has_part('base'):\n            self.write_base(url_data)\n        if url_data.url and self.has_part('realurl'):\n            self.write_real(url_data)\n        if url_data.checktime and self.has_part('checktime'):\n            self.write_checktime(url_data)\n        if url_data.dltime >= 0 and self.has_part('dltime'):\n            self.write_dltime(url_data)\n        if url_data.size >= 0 and self.has_part('dlsize'):\n            self.write_size(url_data)\n        if url_data.info and self.has_part('info'):\n            self.write_info(url_data)\n        if url_data.modified and self.has_part('modified'):\n            self.write_modified(url_data)\n        if url_data.warnings and self.has_part('warning'):\n            self.write_warning(url_data)\n        if self.has_part('result'):\n            self.write_result(url_data)\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_id (self):\n        self.writeln()\n        self.write(self.part('id') + self.spaces('id'))\n        self.writeln(u\"%d\" % self.stats.number, color=self.colorinfo)", "response": "Write unique ID of url_data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_outro (self, interrupt=False):\n        self.writeln()\n        if interrupt:\n            self.writeln(_(\"The check has been interrupted; results are not complete.\"))\n        self.write(_(\"That's it.\") + \" \")\n        self.write(_n(\"%d link\", \"%d links\",\n                      self.stats.number) % self.stats.number)\n        self.write(u\" \")\n        if self.stats.num_urls is not None:\n            self.write(_n(\"in %d URL\", \"in %d URLs\",\n                          self.stats.num_urls) % self.stats.num_urls)\n        self.write(u\" checked. \")\n        warning_text = _n(\"%d warning found\", \"%d warnings found\",\n             self.stats.warnings_printed) % self.stats.warnings_printed\n        if self.stats.warnings_printed:\n            warning_color = self.colorwarning\n        else:\n            warning_color = self.colorinfo\n        self.write(warning_text, color=warning_color)\n        if self.stats.warnings != self.stats.warnings_printed:\n            self.write(_(\" (%d ignored or duplicates not printed)\") %\n                (self.stats.warnings - self.stats.warnings_printed))\n        self.write(u\". \")\n        error_text = _n(\"%d error found\", \"%d errors found\",\n             self.stats.errors_printed) % self.stats.errors_printed\n        if self.stats.errors_printed:\n            error_color = self.colorinvalid\n        else:\n            error_color = self.colorvalid\n        self.write(error_text, color=error_color)\n        if self.stats.errors != self.stats.errors_printed:\n            self.write(_(\" (%d duplicates not printed)\") %\n                (self.stats.errors - self.stats.errors_printed))\n        self.writeln(u\".\")\n        num = self.stats.internal_errors\n        if num:\n            self.writeln(_n(\"There was %(num)d internal error.\",\n                \"There were %(num)d internal errors.\", num) % {\"num\": num})\n        self.stoptime = time.time()\n        duration = self.stoptime - self.starttime\n        self.writeln(_(\"Stopped checking at %(time)s (%(duration)s)\") %\n             {\"time\": strformat.strtime(self.stoptime),\n              \"duration\": strformat.strduration_long(duration)})", "response": "Write end of checking message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite check statistic info.", "response": "def write_stats (self):\n        \"\"\"Write check statistic info.\"\"\"\n        self.writeln()\n        self.writeln(_(\"Statistics:\"))\n        if self.stats.downloaded_bytes is not None:\n            self.writeln(_(\"Downloaded: %s.\") % strformat.strsize(self.stats.downloaded_bytes))\n        if self.stats.number > 0:\n            self.writeln(_(\n              \"Content types: %(image)d image, %(text)d text, %(video)d video, \"\n              \"%(audio)d audio, %(application)d application, %(mail)d mail\"\n              \" and %(other)d other.\") % self.stats.link_types)\n            self.writeln(_(\"URL lengths: min=%(min)d, max=%(max)d, avg=%(avg)d.\") %\n                         dict(min=self.stats.min_url_length,\n                         max=self.stats.max_url_length,\n                         avg=self.stats.avg_url_length))\n        else:\n            self.writeln(_(\"No statistics available since no URLs were checked.\"))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite end of output info and flush all output buffers.", "response": "def end_output (self, **kwargs):\n        \"\"\"Write end of output info, and flush all output buffers.\"\"\"\n        self.stats.downloaded_bytes = kwargs.get(\"downloaded_bytes\")\n        self.stats.num_urls = kwargs.get(\"num_urls\")\n        if self.has_part('stats'):\n            self.write_stats()\n        if self.has_part('outro'):\n            self.write_outro(interrupt=kwargs.get(\"interrupt\"))\n        self.close_fileoutput()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef splitparams (path):\n    if '/' in path:\n        i = path.find(';', path.rfind('/'))\n    else:\n        i = path.find(';')\n    if i < 0:\n        return path, ''\n    return path[:i], path[i+1:]", "response": "Split off parameter part from path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_numeric_port (portstr):\n    if portstr.isdigit():\n        port = int(portstr)\n        # 65536 == 2**16\n        if 0 < port < 65536:\n            return port\n    return False", "response": "return integer port iff portstr is a valid port number False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_qsl (qs, keep_blank_values=0, strict_parsing=0):\n    pairs = []\n    name_value_amp = qs.split('&')\n    for name_value in name_value_amp:\n        if ';' in name_value:\n            pairs.extend([x, ';'] for x in name_value.split(';'))\n            pairs[-1][1] = '&'\n        else:\n            pairs.append([name_value, '&'])\n    pairs[-1][1] = ''\n    r = []\n    for name_value, sep in pairs:\n        nv = name_value.split('=', 1)\n        if len(nv) != 2:\n            if strict_parsing:\n                raise ValueError(\"bad query field: %r\" % name_value)\n            elif len(nv) == 1:\n                # None value indicates missing equal sign\n                nv = (nv[0], None)\n            else:\n                continue\n        if nv[1] or keep_blank_values:\n            name = urllib.unquote(nv[0].replace('+', ' '))\n            if nv[1]:\n                value = urllib.unquote(nv[1].replace('+', ' '))\n            else:\n                value = nv[1]\n            r.append((name, value, sep))\n    return r", "response": "Parse a query string into a list of triples."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef idna_encode (host):\n    if host and isinstance(host, unicode):\n        try:\n            host.encode('ascii')\n            return host, False\n        except UnicodeError:\n            uhost = host.encode('idna').decode('ascii')\n            return uhost, uhost != host\n    return host, False", "response": "Encode hostname as internationalized domain name according\n    to RFC 3490."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfix common typos in given URL like forgotten colon.", "response": "def url_fix_common_typos (url):\n    \"\"\"Fix common typos in given URL like forgotten colon.\"\"\"\n    if url.startswith(\"http//\"):\n        url = \"http://\" + url[6:]\n    elif url.startswith(\"https//\"):\n        url = \"https://\" + url[7:]\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing and re - join the given CGI query.", "response": "def url_parse_query (query, encoding=None):\n    \"\"\"Parse and re-join the given CGI query.\"\"\"\n    if isinstance(query, unicode):\n        if encoding is None:\n            encoding = url_encoding\n        query = query.encode(encoding, 'ignore')\n    # if ? is in the query, split it off, seen at msdn.microsoft.com\n    append = \"\"\n    while '?' in query:\n        query, rest = query.rsplit('?', 1)\n        append = '?'+url_parse_query(rest)+append\n    l = []\n    for k, v, sep in parse_qsl(query, keep_blank_values=True):\n        k = url_quote_part(k, '/-:,;')\n        if v:\n            v = url_quote_part(v, '/-:,;')\n            l.append(\"%s=%s%s\" % (k, v, sep))\n        elif v is None:\n            l.append(\"%s%s\" % (k, sep))\n        else:\n            # some sites do not work when the equal sign is missing\n            l.append(\"%s=%s\" % (k, sep))\n    return ''.join(l) + append"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef collapse_segments (path):\n    # replace backslashes\n    # note: this is _against_ the specification (which would require\n    # backslashes to be left alone, and finally quoted with '%5C')\n    # But replacing has several positive effects:\n    # - Prevents path attacks on Windows systems (using \\.. parent refs)\n    # - Fixes bad URLs where users used backslashes instead of slashes.\n    #   This is a far more probable case than users having an intentional\n    #   backslash in the path name.\n    path = path.replace('\\\\', '/')\n    # shrink multiple slashes to one slash\n    path = _slashes_ro.sub(\"/\", path)\n    # collapse redundant path segments\n    path = _thisdir_ro.sub(\"\", path)\n    path = _samedir_ro.sub(\"/\", path)\n    # collapse parent path segments\n    # note: here we exploit the fact that the replacements happen\n    # to be from left to right (see also _parentdir_ro above)\n    newpath = _parentdir_ro.sub(\"/\", path)\n    while newpath != path:\n        path = newpath\n        newpath = _parentdir_ro.sub(\"/\", path)\n    # collapse parent path segments of relative paths\n    # (ie. without leading slash)\n    newpath = _relparentdir_ro.sub(\"\", path)\n    while newpath != path:\n        path = newpath\n        newpath = _relparentdir_ro.sub(\"\", path)\n    return path", "response": "Remove all redundant segments from the given URL path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping urllib. quote to support unicode strings.", "response": "def url_quote_part (s, safechars='/', encoding=None):\n    \"\"\"Wrap urllib.quote() to support unicode strings. A unicode string\n    is first converted to UTF-8. After that urllib.quote() is called.\"\"\"\n    if isinstance(s, unicode):\n        if encoding is None:\n            encoding = url_encoding\n        s = s.encode(encoding, 'ignore')\n    return urllib.quote(s, safechars)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if host matches an entry in given domain list.", "response": "def match_host (host, domainlist):\n    \"\"\"Return True if host matches an entry in given domain list.\"\"\"\n    if not host:\n        return False\n    for domain in domainlist:\n        if domain.startswith('.'):\n            if host.endswith(domain):\n                return True\n        elif host == domain:\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsplitting url into scheme host port document", "response": "def url_split (url):\n    \"\"\"Split url in a tuple (scheme, hostname, port, document) where\n    hostname is always lowercased.\n    Precondition: url is syntactically correct URI (eg has no whitespace)\n    \"\"\"\n    scheme, netloc = urllib.splittype(url)\n    host, document = urllib.splithost(netloc)\n    port = default_ports.get(scheme, 0)\n    if host:\n        host = host.lower()\n        host, port = splitport(host, port=port)\n    return scheme, host, port, document"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrejoins URL parts to a string.", "response": "def url_unsplit (parts):\n    \"\"\"Rejoin URL parts to a string.\"\"\"\n    if parts[2] == default_ports.get(parts[0]):\n        return \"%s://%s%s\" % (parts[0], parts[1], parts[3])\n    return \"%s://%s:%d%s\" % parts"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef splitport (host, port=0):\n    if \":\" in host:\n        shost, sport = host.split(\":\", 1)\n        iport = is_numeric_port(sport)\n        if iport:\n            host, port = shost, iport\n        elif not sport:\n            # empty port, ie. the host was \"hostname:\"\n            host = shost\n        else:\n            # For an invalid non-empty port leave the host name as is\n            pass\n    return host, port", "response": "Split optional port number from host."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_content(url, user=None, password=None, proxy=None, data=None,\n                addheaders=None):\n    \"\"\"Get URL content and info.\n\n    @return: (decoded text content of URL, headers) or\n             (None, errmsg) on error.\n    @rtype: tuple (String, dict) or (None, String)\n    \"\"\"\n    from . import configuration\n    headers = {\n        'User-Agent': configuration.UserAgent,\n    }\n    if addheaders:\n        headers.update(addheaders)\n    method = 'GET'\n    kwargs = dict(headers=headers)\n    if user and password:\n        kwargs['auth'] = (user, password)\n    if data:\n        kwargs['data'] = data\n        method = 'POST'\n    if proxy:\n        kwargs['proxy'] = dict(http=proxy)\n    from .configuration import get_share_file\n    try:\n        kwargs[\"verify\"] = get_share_file('cacert.pem')\n    except ValueError:\n        pass\n    try:\n        response = requests.request(method, url, **kwargs)\n        return response.text, response.headers\n    except (requests.exceptions.RequestException,\n            requests.exceptions.BaseHTTPError) as msg:\n        log.warn(LOG_CHECK, (\"Could not get content of URL %(url)s: %(msg)s.\") \\\n          % {\"url\": url, \"msg\": str(msg)})\n        return None, str(msg)", "response": "Get URL content and info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef shorten_duplicate_content_url(url):\n    if '#' in url:\n        url = url.split('#', 1)[0]\n    if url.endswith('index.html'):\n        return url[:-10]\n    if url.endswith('index.htm'):\n        return url[:-9]\n    return url", "response": "Shorten duplicate content URLs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if two URLs are allowed to point to the same content.", "response": "def is_duplicate_content_url(url1, url2):\n    \"\"\"Check if both URLs are allowed to point to the same content.\"\"\"\n    if url1 == url2:\n        return True\n    if url2 in url1:\n        url1 = shorten_duplicate_content_url(url1)\n        if not url2.endswith('/') and url1.endswith('/'):\n            url2 += '/'\n        return url1 == url2\n    if url1 in url2:\n        url2 = shorten_duplicate_content_url(url2)\n        if not url1.endswith('/') and url2.endswith('/'):\n            url1 += '/'\n        return url1 == url2\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites a file with content to filename.", "response": "def write_file (filename, content, backup=False, callback=None):\n    \"\"\"Overwrite a possibly existing file with new content. Do this\n    in a manner that does not leave truncated or broken files behind.\n    @param filename: name of file to write\n    @type filename: string\n    @param content: file content to write\n    @type content: string\n    @param backup: if backup file should be left\n    @type backup: bool\n    @param callback: non-default storage function\n    @type callback: None or function taking two parameters (fileobj, content)\n    \"\"\"\n    # first write in a temp file\n    f = file(filename+\".tmp\", 'wb')\n    if callback is None:\n        f.write(content)\n    else:\n        callback(f, content)\n    f.close()\n    # move orig file to backup\n    if os.path.exists(filename):\n        os.rename(filename, filename+\".bak\")\n    # move temp file to orig\n    os.rename(filename+\".tmp\", filename)\n    # remove backup\n    if not backup and os.path.exists(filename+\".bak\"):\n        os.remove(filename+\".bak\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntest if given module can be imported.", "response": "def has_module (name, without_error=True):\n    \"\"\"Test if given module can be imported.\n    @param without_error: True if module must not throw any errors when importing\n    @return: flag if import is successful\n    @rtype: bool\n    \"\"\"\n    try:\n        importlib.import_module(name)\n        return True\n    except ImportError:\n        return False\n    except Exception:\n        # some modules raise errors when intitializing\n        return not without_error"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nencodes a path string with the platform file system encoding.", "response": "def pathencode (path):\n    \"\"\"Encode a path string with the platform file system encoding.\"\"\"\n    if isinstance(path, unicode) and not os.path.supports_unicode_filenames:\n        path = path.encode(FSCODING, \"replace\")\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if filename has changed since the last check.", "response": "def has_changed (filename):\n    \"\"\"Check if filename has changed since the last check. If this\n    is the first check, assume the file is changed.\"\"\"\n    key = os.path.abspath(filename)\n    mtime = get_mtime(key)\n    if key not in _mtime_cache:\n        _mtime_cache[key] = mtime\n        return True\n    return mtime > _mtime_cache[key]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_temp_file (mode='r', **kwargs):\n    fd, filename = tempfile.mkstemp(**kwargs)\n    return os.fdopen(fd, mode), filename", "response": "Return tuple ( open file object filename pointing to a temporary\n    file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_readable(filename):\n    return os.path.isfile(filename) and os.access(filename, os.R_OK)", "response": "Check if file is a regular file and is readable."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_accessable_by_others(filename):\n    mode = os.stat(filename)[stat.ST_MODE]\n    return mode & (stat.S_IRWXG | stat.S_IRWXO)", "response": "Check if file is group or world accessable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if file or directory is world writable.", "response": "def is_writable_by_others(filename):\n    \"\"\"Check if file or directory is world writable.\"\"\"\n    mode = os.stat(filename)[stat.ST_MODE]\n    return mode & stat.S_IWOTH"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the file is writable", "response": "def is_writable(filename):\n    \"\"\"Check if\n    - the file is a regular file and is writable, or\n    - the file does not exist and its parent directory exists and is\n      writable\n    \"\"\"\n    if not os.path.exists(filename):\n        parentdir = os.path.dirname(filename)\n        return os.path.isdir(parentdir) and os.access(parentdir, os.W_OK)\n    return os.path.isfile(filename) and os.access(filename, os.W_OK)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite data to buffer.", "response": "def write (self, data):\n        \"\"\"Write data to buffer.\"\"\"\n        self.tmpbuf.append(data)\n        self.pos += len(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nflush buffered data and return it.", "response": "def flush (self, overlap=0):\n        \"\"\"Flush buffered data and return it.\"\"\"\n        self.buf += self.empty.join(self.tmpbuf)\n        self.tmpbuf = []\n        if overlap and overlap < self.pos:\n            data = self.buf[:-overlap]\n            self.buf = self.buf[-overlap:]\n        else:\n            data = self.buf\n            self.buf = self.empty\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef guess_url(url):\n    if url.lower().startswith(\"www.\"):\n        # syntactic sugar\n        return \"http://%s\" % url\n    elif url.lower().startswith(\"ftp.\"):\n        # syntactic sugar\n        return \"ftp://%s\" % url\n    return url", "response": "Guess if URL is a http or ftp URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef absolute_url (base_url, base_ref, parent_url):\n    if base_url and urlutil.url_is_absolute(base_url):\n        return base_url\n    elif base_ref and urlutil.url_is_absolute(base_ref):\n        return base_ref\n    elif parent_url and urlutil.url_is_absolute(parent_url):\n        return parent_url\n    return u\"\"", "response": "Returns the absolute url of the link."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_url_from (base_url, recursion_level, aggregate,\n                  parent_url=None, base_ref=None, line=0, column=0, page=0,\n                  name=u\"\", parent_content_type=None, extern=None):\n    \"\"\"\n    Get url data from given base data.\n\n    @param base_url: base url from a link tag\n    @type base_url: string or None\n    @param recursion_level: current recursion level\n    @type recursion_level: number\n    @param aggregate: aggregate object\n    @type aggregate: aggregate.Consumer\n    @param parent_url: parent url\n    @type parent_url: string or None\n    @param base_ref: base url from <base> tag\n    @type base_ref string or None\n    @param line: line number\n    @type line: number\n    @param column: column number\n    @type column: number\n    @param page: page number\n    @type page: number\n    @param name: link name\n    @type name: string\n    @param extern: (is_extern, is_strict) or None\n    @type extern: tuple(int, int) or None\n    \"\"\"\n    if base_url is not None:\n        base_url = strformat.unicode_safe(base_url)\n        # left strip for detection of URL scheme\n        base_url_stripped = base_url.lstrip()\n    else:\n        base_url_stripped = base_url\n    if parent_url is not None:\n        parent_url = strformat.unicode_safe(parent_url)\n    if base_ref is not None:\n        base_ref = strformat.unicode_safe(base_ref)\n    name = strformat.unicode_safe(name)\n    url = absolute_url(base_url_stripped, base_ref, parent_url).lower()\n    if \":\" in url:\n        scheme = url.split(\":\", 1)[0].lower()\n    else:\n        scheme = None\n        if not (url or name):\n            # use filename as base url, with slash as path seperator\n            name = base_url.replace(\"\\\\\", \"/\")\n    allowed_schemes = aggregate.config[\"allowedschemes\"]\n    # ignore local PHP files with execution directives\n    local_php = (parent_content_type == 'application/x-httpd-php' and\n       '<?' in base_url and '?>' in base_url and scheme == 'file')\n    if local_php or (allowed_schemes and scheme not in allowed_schemes):\n        klass = ignoreurl.IgnoreUrl\n    else:\n        assume_local_file = (recursion_level == 0)\n        klass = get_urlclass_from(scheme, assume_local_file=assume_local_file)\n    log.debug(LOG_CHECK, \"%s handles url %s\", klass.__name__, base_url)\n    return klass(base_url, recursion_level, aggregate,\n                 parent_url=parent_url, base_ref=base_ref,\n                 line=line, column=column, page=page, name=name, extern=extern)", "response": "Get url data from given base data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_urlclass_from (scheme, assume_local_file=False):\n    if scheme in (\"http\", \"https\"):\n        klass = httpurl.HttpUrl\n    elif scheme == \"ftp\":\n        klass = ftpurl.FtpUrl\n    elif scheme == \"file\":\n        klass = fileurl.FileUrl\n    elif scheme == \"telnet\":\n        klass = telneturl.TelnetUrl\n    elif scheme == \"mailto\":\n        klass = mailtourl.MailtoUrl\n    elif scheme in (\"nntp\", \"news\", \"snews\"):\n        klass = nntpurl.NntpUrl\n    elif scheme == \"dns\":\n        klass = dnsurl.DnsUrl\n    elif scheme == \"itms-services\":\n        klass = itmsservicesurl.ItmsServicesUrl\n    elif scheme and unknownurl.is_unknown_scheme(scheme):\n        klass = unknownurl.UnknownUrl\n    elif assume_local_file:\n        klass = fileurl.FileUrl\n    else:\n        klass = unknownurl.UnknownUrl\n    return klass", "response": "Return checker class for given URL scheme."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct artificial index. html from given URLs.", "response": "def get_index_html (urls):\n    \"\"\"\n    Construct artificial index.html from given URLs.\n\n    @param urls: URL strings\n    @type urls: iterator of string\n    \"\"\"\n    lines = [\"<html>\", \"<body>\"]\n    for entry in urls:\n        name = cgi.escape(entry)\n        try:\n            url = cgi.escape(urllib.quote(entry))\n        except KeyError:\n            # Some unicode entries raise KeyError.\n            url = name\n        lines.append('<a href=\"%s\">%s</a>' % (url, name))\n    lines.extend([\"</body>\", \"</html>\"])\n    return os.linesep.join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_checked (self):\n        self.start_time = time.time()\n        self.setName(\"Interrupt\")\n        while not self.stopped(self.WaitSeconds):\n            duration = time.time() - self.start_time\n            if duration > self.duration:\n                log.warn(LOG_CHECK, \"Interrupt after %s\" % strformat.strduration_long(duration))\n                raise KeyboardInterrupt()", "response": "Wait and raise KeyboardInterrupt after."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns path where all profiles of current user are stored.", "response": "def get_profile_dir ():\n    \"\"\"Return path where all profiles of current user are stored.\"\"\"\n    if os.name == 'nt':\n        basedir = unicode(os.environ[\"APPDATA\"], nt_filename_encoding)\n        dirpath = os.path.join(basedir, u\"Mozilla\", u\"Firefox\", u\"Profiles\")\n    elif os.name == 'posix':\n        basedir = unicode(os.environ[\"HOME\"])\n        dirpath = os.path.join(basedir, u\".mozilla\", u\"firefox\")\n    return dirpath"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_bookmark_file (filename):\n    if not has_sqlite:\n        return\n    conn = sqlite3.connect(filename, timeout=0.5)\n    try:\n        c = conn.cursor()\n        try:\n            sql = \"\"\"SELECT mp.url, mb.title\n            FROM moz_places mp, moz_bookmarks mb\n            WHERE mp.hidden=0 AND mp.url NOT LIKE 'place:%' AND\n            mp.id=mb.fk\"\"\"\n            c.execute(sql)\n            for url, name in c:\n                if not name:\n                    name = url\n                yield (url, name)\n        finally:\n            c.close()\n    finally:\n        conn.close()", "response": "Parse a file containing bookmarks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef esc_ansicolor (color):\n    control = ''\n    if \";\" in color:\n        control, color = color.split(\";\", 1)\n        control = AnsiControl.get(control, '')+\";\"\n    cnum = AnsiColor.get(color, '0')\n    return AnsiEsc % (control+cnum)", "response": "convert a named color definition to an escaped ANSI color"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a named color definition to Windows console color foreground background and style numbers.", "response": "def get_win_color(color):\n    \"\"\"Convert a named color definition to Windows console color foreground,\n    background and style numbers.\"\"\"\n    foreground = background = style = None\n    control = ''\n    if \";\" in color:\n        control, color = color.split(\";\", 1)\n        if control == bold:\n            style = colorama.BRIGHT\n    if color in InverseColors:\n        background = WinColor[color]\n    else:\n        foreground = WinColor.get(color)\n    return foreground, background, style"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_colors (fp):\n    # The is_tty() function ensures that we do not colorize\n    # redirected streams, as this is almost never what we want\n    if not is_tty(fp):\n        return False\n    if os.name == 'nt':\n        return True\n    elif has_curses:\n        import curses\n        try:\n            curses.setupterm(os.environ.get(\"TERM\"), fp.fileno())\n            # More than 8 colors are good enough.\n            return curses.tigetnum(\"colors\") >= 8\n        except curses.error:\n            return False\n    return False", "response": "Test if given file is an ANSI color enabled tty."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_columns (fp):\n    if not is_tty(fp):\n        return 80\n    if os.name == 'nt':\n        return colorama.get_console_size().X\n    if has_curses:\n        import curses\n        try:\n            curses.setupterm(os.environ.get(\"TERM\"), fp.fileno())\n            return curses.tigetnum(\"cols\")\n        except curses.error:\n           pass\n    return 80", "response": "Return number of columns for given file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _write_color_ansi (fp, text, color):\n    fp.write(esc_ansicolor(color))\n    fp.write(text)\n    fp.write(AnsiReset)", "response": "Colorize text with given color."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _write_color (self, text, color=None):\n        if color is None:\n            self.fp.write(text)\n        else:\n            write_color(self.fp, text, color)", "response": "Print text with given color."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nemits a record. If a formatter is specified, it is used to format the record. The record is then written to the stream with a trailing newline [N.B. this may be removed depending on feedback].", "response": "def emit (self, record):\n        \"\"\"Emit a record.\n\n        If a formatter is specified, it is used to format the record.\n        The record is then written to the stream with a trailing newline\n        [N.B. this may be removed depending on feedback].\n        \"\"\"\n        color = self.get_color(record)\n        msg = self.format(record)\n        if not hasattr(types, \"UnicodeType\"):\n            # no unicode support\n            self.stream.write(\"%s\" % msg, color=color)\n        else:\n            try:\n                self.stream.write(\"%s\" % msg, color=color)\n            except UnicodeError:\n                self.stream.write(\"%s\" % msg.encode(\"UTF-8\"),\n                                  color=color)\n        self.stream.write(os.linesep)\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the deepest match to the longest name in the dictionary which is a superdomain of I { name.", "response": "def get_deepest_match(self, name):\n        \"\"\"Find the deepest match to I{name} in the dictionary.\n\n        The deepest match is the longest name in the dictionary which is\n        a superdomain of I{name}.\n\n        @param name: the name\n        @type name: dns.name.Name object\n        @rtype: (key, value) tuple\n        \"\"\"\n\n        depth = len(name)\n        if depth > self.max_depth:\n            depth = self.max_depth\n        for i in xrange(-depth, 0):\n            n = dns.name.Name(name[i:])\n            if n in self:\n                return (n, self[n])\n        v = self[dns.name.empty]\n        return (dns.name.empty, v)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _escapify(label):\n    text = ''\n    for c in label:\n        if c in _escaped:\n            text += '\\\\' + c\n        elif ord(c) > 0x20 and ord(c) < 0x7F:\n            text += c\n        else:\n            text += '\\\\%03d' % ord(c)\n    return text", "response": "Escape the characters in the label which need it."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate_labels(labels):\n\n    l = len(labels)\n    total = 0\n    i = -1\n    j = 0\n    for label in labels:\n        ll = len(label)\n        total += ll + 1\n        if ll > 63:\n            raise LabelTooLong\n        if i < 0 and label == '':\n            i = j\n        j += 1\n    if total > 255:\n        raise NameTooLong\n    if i >= 0 and i != l - 1:\n        raise EmptyLabel", "response": "Validate the labels in the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts unicode text into a Name object.", "response": "def from_unicode(text, origin = root):\n    \"\"\"Convert unicode text into a Name object.\n\n    Lables are encoded in IDN ACE form.\n\n    @rtype: dns.name.Name object\n    \"\"\"\n\n    if not isinstance(text, unicode):\n        raise ValueError(\"input to from_unicode() must be a unicode string\")\n    if not (origin is None or isinstance(origin, Name)):\n        raise ValueError(\"origin must be a Name or None\")\n    labels = []\n    label = u''\n    escaping = False\n    edigits = 0\n    total = 0\n    if text == u'@':\n        text = u''\n    if text:\n        if text == u'.':\n            return Name([''])        # no Unicode \"u\" on this constant!\n        for c in text:\n            if escaping:\n                if edigits == 0:\n                    if c.isdigit():\n                        total = int(c)\n                        edigits += 1\n                    else:\n                        label += c\n                        escaping = False\n                else:\n                    if not c.isdigit():\n                        raise BadEscape\n                    total *= 10\n                    total += int(c)\n                    edigits += 1\n                    if edigits == 3:\n                        escaping = False\n                        label += chr(total)\n            elif c == u'.' or c == u'\\u3002' or \\\n                 c == u'\\uff0e' or c == u'\\uff61':\n                if len(label) == 0:\n                    raise EmptyLabel\n                labels.append(encodings.idna.ToASCII(label))\n                label = u''\n            elif c == u'\\\\':\n                escaping = True\n                edigits = 0\n                total = 0\n            else:\n                label += c\n        if escaping:\n            raise BadEscape\n        if len(label) > 0:\n            labels.append(encodings.idna.ToASCII(label))\n        else:\n            labels.append('')\n    if (len(labels) == 0 or labels[-1] != '') and not origin is None:\n        labels.extend(list(origin.labels))\n    return Name(labels)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a string into a Name object.", "response": "def from_text(text, origin = root):\n    \"\"\"Convert text into a Name object.\n    @rtype: dns.name.Name object\n    \"\"\"\n\n    if not isinstance(text, str):\n        if isinstance(text, unicode) and sys.hexversion >= 0x02030000:\n            return from_unicode(text, origin)\n        else:\n            raise ValueError(\"input to from_text() must be a string\")\n    if not (origin is None or isinstance(origin, Name)):\n        raise ValueError(\"origin must be a Name or None\")\n    labels = []\n    label = ''\n    escaping = False\n    edigits = 0\n    total = 0\n    if text == '@':\n        text = ''\n    if text:\n        if text == '.':\n            return Name([''])\n        for c in text:\n            if escaping:\n                if edigits == 0:\n                    if c.isdigit():\n                        total = int(c)\n                        edigits += 1\n                    else:\n                        label += c\n                        escaping = False\n                else:\n                    if not c.isdigit():\n                        raise BadEscape\n                    total *= 10\n                    total += int(c)\n                    edigits += 1\n                    if edigits == 3:\n                        escaping = False\n                        label += chr(total)\n            elif c == '.':\n                if len(label) == 0:\n                    raise EmptyLabel\n                labels.append(label)\n                label = ''\n            elif c == '\\\\':\n                escaping = True\n                edigits = 0\n                total = 0\n            else:\n                label += c\n        if escaping:\n            raise BadEscape\n        if len(label) > 0:\n            labels.append(label)\n        else:\n            labels.append('')\n    if (len(labels) == 0 or labels[-1] != '') and not origin is None:\n        labels.extend(list(origin.labels))\n    return Name(labels)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts possibly compressed wire format into a Name object.", "response": "def from_wire(message, current):\n    \"\"\"Convert possibly compressed wire format into a Name.\n    @param message: the entire DNS message\n    @type message: string\n    @param current: the offset of the beginning of the name from the start\n    of the message\n    @type current: int\n    @raises dns.name.BadPointer: a compression pointer did not point backwards\n    in the message\n    @raises dns.name.BadLabelType: an invalid label type was encountered.\n    @returns: a tuple consisting of the name that was read and the number\n    of bytes of the wire format message which were consumed reading it\n    @rtype: (dns.name.Name object, int) tuple\n    \"\"\"\n\n    if not isinstance(message, str):\n        raise ValueError(\"input to from_wire() must be a byte string\")\n    message = dns.wiredata.maybe_wrap(message)\n    labels = []\n    biggest_pointer = current\n    hops = 0\n    count = ord(message[current])\n    current += 1\n    cused = 1\n    while count != 0:\n        if count < 64:\n            labels.append(message[current : current + count].unwrap())\n            current += count\n            if hops == 0:\n                cused += count\n        elif count >= 192:\n            current = (count & 0x3f) * 256 + ord(message[current])\n            if hops == 0:\n                cused += 1\n            if current >= biggest_pointer:\n                raise BadPointer\n            biggest_pointer = current\n            hops += 1\n        else:\n            raise BadLabelType\n        count = ord(message[current])\n        current += 1\n        if hops == 0:\n            cused += 1\n    labels.append('')\n    return (Name(labels), cused)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomparing two names returning a 3 - tuple of the relation order and nlabels.", "response": "def fullcompare(self, other):\n        \"\"\"Compare two names, returning a 3-tuple (relation, order, nlabels).\n\n        I{relation} describes the relation ship beween the names,\n        and is one of: dns.name.NAMERELN_NONE,\n        dns.name.NAMERELN_SUPERDOMAIN, dns.name.NAMERELN_SUBDOMAIN,\n        dns.name.NAMERELN_EQUAL, or dns.name.NAMERELN_COMMONANCESTOR\n\n        I{order} is < 0 if self < other, > 0 if self > other, and ==\n        0 if self == other.  A relative name is always less than an\n        absolute name.  If both names have the same relativity, then\n        the DNSSEC order relation is used to order them.\n\n        I{nlabels} is the number of significant labels that the two names\n        have in common.\n        \"\"\"\n\n        sabs = self.is_absolute()\n        oabs = other.is_absolute()\n        if sabs != oabs:\n            if sabs:\n                return (NAMERELN_NONE, 1, 0)\n            else:\n                return (NAMERELN_NONE, -1, 0)\n        l1 = len(self.labels)\n        l2 = len(other.labels)\n        ldiff = l1 - l2\n        if ldiff < 0:\n            l = l1\n        else:\n            l = l2\n\n        order = 0\n        nlabels = 0\n        namereln = NAMERELN_NONE\n        while l > 0:\n            l -= 1\n            l1 -= 1\n            l2 -= 1\n            label1 = self.labels[l1].lower()\n            label2 = other.labels[l2].lower()\n            if label1 < label2:\n                order = -1\n                if nlabels > 0:\n                    namereln = NAMERELN_COMMONANCESTOR\n                return (namereln, order, nlabels)\n            elif label1 > label2:\n                order = 1\n                if nlabels > 0:\n                    namereln = NAMERELN_COMMONANCESTOR\n                return (namereln, order, nlabels)\n            nlabels += 1\n        order = ldiff\n        if ldiff < 0:\n            namereln = NAMERELN_SUPERDOMAIN\n        elif ldiff > 0:\n            namereln = NAMERELN_SUBDOMAIN\n        else:\n            namereln = NAMERELN_EQUAL\n        return (namereln, order, nlabels)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_subdomain(self, other):\n\n        (nr, o, nl) = self.fullcompare(other)\n        if nr == NAMERELN_SUBDOMAIN or nr == NAMERELN_EQUAL:\n            return True\n        return False", "response": "Is self a subdomain of other?"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_superdomain(self, other):\n\n        (nr, o, nl) = self.fullcompare(other)\n        if nr == NAMERELN_SUPERDOMAIN or nr == NAMERELN_EQUAL:\n            return True\n        return False", "response": "Is self a superdomain of other?"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_text(self, omit_final_dot = False):\n\n        if len(self.labels) == 0:\n            return '@'\n        if len(self.labels) == 1 and self.labels[0] == '':\n            return '.'\n        if omit_final_dot and self.is_absolute():\n            l = self.labels[:-1]\n        else:\n            l = self.labels\n        s = '.'.join(map(_escapify, l))\n        return s", "response": "Convert the name to text format."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the IDN ACE class name to Unicode text format.", "response": "def to_unicode(self, omit_final_dot = False):\n        \"\"\"Convert name to Unicode text format.\n\n        IDN ACE lables are converted to Unicode.\n\n        @param omit_final_dot: If True, don't emit the final dot (denoting the\n        root label) for absolute names.  The default is False.\n        @rtype: string\n        \"\"\"\n\n        if len(self.labels) == 0:\n            return u'@'\n        if len(self.labels) == 1 and self.labels[0] == '':\n            return u'.'\n        if omit_final_dot and self.is_absolute():\n            l = self.labels[:-1]\n        else:\n            l = self.labels\n        s = u'.'.join([encodings.idna.ToUnicode(_escapify(x)) for x in l])\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_digestable(self, origin=None):\n\n        if not self.is_absolute():\n            if origin is None or not origin.is_absolute():\n                raise NeedAbsoluteNameOrOrigin\n            labels = list(self.labels)\n            labels.extend(list(origin.labels))\n        else:\n            labels = self.labels\n        dlabels = [\"%s%s\" % (chr(len(x)), x.lower()) for x in labels]\n        return ''.join(dlabels)", "response": "Convert name to a format suitable for digesting in hashes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the name to wire format.", "response": "def to_wire(self, file = None, compress = None, origin = None):\n        \"\"\"Convert name to wire format, possibly compressing it.\n\n        @param file: the file where the name is emitted (typically\n        a cStringIO file).  If None, a string containing the wire name\n        will be returned.\n        @type file: file or None\n        @param compress: The compression table.  If None (the default) names\n        will not be compressed.\n        @type compress: dict\n        @param origin: If the name is relative and origin is not None, then\n        origin will be appended to it.\n        @type origin: dns.name.Name object\n        @raises NeedAbsoluteNameOrOrigin: All names in wire format are\n        absolute.  If self is a relative name, then an origin must be supplied;\n        if it is missing, then this exception is raised\n        \"\"\"\n\n        if file is None:\n            file = cStringIO.StringIO()\n            want_return = True\n        else:\n            want_return = False\n\n        if not self.is_absolute():\n            if origin is None or not origin.is_absolute():\n                raise NeedAbsoluteNameOrOrigin\n            labels = list(self.labels)\n            labels.extend(list(origin.labels))\n        else:\n            labels = self.labels\n        i = 0\n        for label in labels:\n            n = Name(labels[i:])\n            i += 1\n            if not compress is None:\n                pos = compress.get(n)\n            else:\n                pos = None\n            if not pos is None:\n                value = 0xc000 + pos\n                s = struct.pack('!H', value)\n                file.write(s)\n                break\n            else:\n                if not compress is None and len(n) > 1:\n                    pos = file.tell()\n                    if pos < 0xc000:\n                        compress[n] = pos\n                l = len(label)\n                file.write(chr(l))\n                if l > 0:\n                    file.write(label)\n        if want_return:\n            return file.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split(self, depth):\n\n        l = len(self.labels)\n        if depth == 0:\n            return (self, dns.name.empty)\n        elif depth == l:\n            return (dns.name.empty, self)\n        elif depth < 0 or depth > l:\n            raise ValueError('depth must be >= 0 and <= the length of the name')\n        return (Name(self[: -depth]), Name(self[-depth :]))", "response": "Split a name into a prefix and suffix at the specified depth."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new name which is the concatenation of self and other.", "response": "def concatenate(self, other):\n        \"\"\"Return a new name which is the concatenation of self and other.\n        @rtype: dns.name.Name object\n        @raises AbsoluteConcatenation: self is absolute and other is\n        not the empty name\n        \"\"\"\n\n        if self.is_absolute() and len(other) > 0:\n            raise AbsoluteConcatenation\n        labels = list(self.labels)\n        labels.extend(list(other.labels))\n        return Name(labels)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new name which is selfRelativeToOrigin.", "response": "def relativize(self, origin):\n        \"\"\"If self is a subdomain of origin, return a new name which is self\n        relative to origin.  Otherwise return self.\n        @rtype: dns.name.Name object\n        \"\"\"\n\n        if not origin is None and self.is_subdomain(origin):\n            return Name(self[: -len(origin)])\n        else:\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a name with the relativity desired by the caller.", "response": "def choose_relativity(self, origin=None, relativize=True):\n        \"\"\"Return a name with the relativity desired by the caller.  If\n        origin is None, then self is returned.  Otherwise, if\n        relativize is true the name is relativized, and if relativize is\n        false the name is derelativized.\n        @rtype: dns.name.Name object\n        \"\"\"\n\n        if origin:\n            if relativize:\n                return self.relativize(origin)\n            else:\n                return self.derelativize(origin)\n        else:\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the parent of the name.", "response": "def parent(self):\n        \"\"\"Return the parent of the name.\n        @rtype: dns.name.Name object\n        @raises NoParent: the name is either the root name or the empty name,\n        and thus has no parent.\n        \"\"\"\n        if self == root or self == empty:\n            raise NoParent\n        return Name(self.labels[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init_win32com ():\n    global _initialized\n    if _initialized:\n        return\n    import win32com.client\n    if win32com.client.gencache.is_readonly:\n        #allow gencache to create the cached wrapper objects\n        win32com.client.gencache.is_readonly = False\n        # under py2exe the call in gencache to __init__() does not happen\n        # so we use Rebuild() to force the creation of the gen_py folder\n        # Note that the python...\\win32com.client.gen_py dir must not exist\n        # to allow creation of the cache in %temp% for py2exe.\n        # This is ensured by excluding win32com.gen_py in setup.py\n        win32com.client.gencache.Rebuild()\n    _initialized = True", "response": "Initialize the win32com. client cache."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_word ():\n    if not has_win32com:\n        return False\n    try:\n        import _winreg as winreg\n    except ImportError:\n        import winreg\n    try:\n        key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, \"Word.Application\")\n        winreg.CloseKey(key)\n        return True\n    except (EnvironmentError, ImportError):\n        pass\n    return False", "response": "Determine if Word is available on the current system."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns open Word. Application handle or None.", "response": "def get_word_app ():\n    \"\"\"Return open Word.Application handle, or None if Word is not available\n    on this system.\"\"\"\n    if not has_word():\n        return None\n    # Since this function is called from different threads, initialize\n    # the COM layer.\n    pythoncom.CoInitialize()\n    import win32com.client\n    app = win32com.client.gencache.EnsureDispatch(\"Word.Application\")\n    app.Visible = False\n    return app"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_wordfile (app, filename):\n    return app.Documents.Open(filename, ReadOnly=True,\n      AddToRecentFiles=False, Visible=False, NoEncodingDialog=True)", "response": "Open given Word file with application object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting line number for given range object.", "response": "def get_line_number(doc, wrange):\n    \"\"\"Get line number for given range object.\"\"\"\n    lineno = 1\n    wrange.Select()\n    wdFirstCharacterLineNumber = constants(\"wdFirstCharacterLineNumber\")\n    wdGoToLine = constants(\"wdGoToLine\")\n    wdGoToPrevious = constants(\"wdGoToPrevious\")\n    while True:\n        curline = doc.Selection.Information(wdFirstCharacterLineNumber)\n        doc.Selection.GoTo(wdGoToLine, wdGoToPrevious, Count=1, Name=\"\")\n        lineno += 1\n        prevline = doc.Selection.Information(wdFirstCharacterLineNumber)\n        if prevline == curline:\n            break\n    return lineno"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget temporary filename for content to parse.", "response": "def get_temp_filename (content):\n    \"\"\"Get temporary filename for content to parse.\"\"\"\n    # store content in temporary file\n    fd, filename = fileutil.get_temp_file(mode='wb', suffix='.doc',\n        prefix='lc_')\n    try:\n        fd.write(content)\n    finally:\n        fd.close()\n    return filename"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstrip out any caret codes from a string.", "response": "def strip_caret_codes(text):\n    \"\"\"\n    Strip out any caret codes from a string.\n    \"\"\"\n    ## temporarily escape out ^^\n    text = text.replace('^^', '\\x00')\n    for token, foo in _ANSI_CODES:\n        text = text.replace(token, '')\n    return text.replace('\\x00', '^')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef colorize(text, ansi=True):\n    if ansi:\n        text = text.replace('^^', '\\x00')\n        for token, code in _ANSI_CODES:\n            text = text.replace(token, code)\n        text = text.replace('\\x00', '^')\n    else:\n        text = strip_caret_codes(text)\n    return text", "response": "If the client wants ansi, replace the tokens with ansi sequences --\n    otherwise, simply strip them out."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef word_wrap(text, columns=80, indent=4, padding=2):\n    paragraphs = _PARA_BREAK.split(text)\n    lines = []\n    columns -= padding\n    for para in paragraphs:\n        if para.isspace():\n            continue\n        line = ' ' * indent\n        for word in para.split():\n            if (len(line) + 1 + len(word)) > columns:\n                lines.append(line)\n                line = ' ' * padding\n                line += word\n            else:\n                line += ' ' + word\n        if not line.isspace():\n            lines.append(line)\n    return lines", "response": "Given a block of text breaks into a list of lines wrapped to the specified number of columns."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread a character from input.", "response": "def _get_char(self):\n        \"\"\"Read a character from input.\n        @rtype: string\n        \"\"\"\n\n        if self.ungotten_char is None:\n            if self.eof:\n                c = ''\n            else:\n                c = self.file.read(1)\n                if c == '':\n                    self.eof = True\n                elif c == '\\n':\n                    self.line_number += 1\n        else:\n            c = self.ungotten_char\n            self.ungotten_char = None\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconsume input until a non - whitespace character is encountered.", "response": "def skip_whitespace(self):\n        \"\"\"Consume input until a non-whitespace character is encountered.\n\n        The non-whitespace character is then ungotten, and the number of\n        whitespace characters consumed is returned.\n\n        If the tokenizer is in multiline mode, then newlines are whitespace.\n\n        @rtype: int\n        \"\"\"\n\n        skipped = 0\n        while True:\n            c = self._get_char()\n            if c != ' ' and c != '\\t':\n                if (c != '\\n') or not self.multiline:\n                    self._unget_char(c)\n                    return skipped\n            skipped += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, want_leading = False, want_comment = False):\n\n        if not self.ungotten_token is None:\n            token = self.ungotten_token\n            self.ungotten_token = None\n            if token.is_whitespace():\n                if want_leading:\n                    return token\n            elif token.is_comment():\n                if want_comment:\n                    return token\n            else:\n                return token\n        skipped = self.skip_whitespace()\n        if want_leading and skipped > 0:\n            return Token(WHITESPACE, ' ')\n        token = ''\n        ttype = IDENTIFIER\n        has_escape = False\n        while True:\n            c = self._get_char()\n            if c == '' or c in self.delimiters:\n                if c == '' and self.quoting:\n                    raise dns.exception.UnexpectedEnd\n                if token == '' and ttype != QUOTED_STRING:\n                    if c == '(':\n                        self.multiline += 1\n                        self.skip_whitespace()\n                        continue\n                    elif c == ')':\n                        if not self.multiline > 0:\n                            raise dns.exception.SyntaxError\n                        self.multiline -= 1\n                        self.skip_whitespace()\n                        continue\n                    elif c == '\"':\n                        if not self.quoting:\n                            self.quoting = True\n                            self.delimiters = _QUOTING_DELIMITERS\n                            ttype = QUOTED_STRING\n                            continue\n                        else:\n                            self.quoting = False\n                            self.delimiters = _DELIMITERS\n                            self.skip_whitespace()\n                            continue\n                    elif c == '\\n':\n                        return Token(EOL, '\\n')\n                    elif c == ';':\n                        while 1:\n                            c = self._get_char()\n                            if c == '\\n' or c == '':\n                                break\n                            token += c\n                        if want_comment:\n                            self._unget_char(c)\n                            return Token(COMMENT, token)\n                        elif c == '':\n                            if self.multiline:\n                                raise dns.exception.SyntaxError('unbalanced parentheses')\n                            return Token(EOF)\n                        elif self.multiline:\n                            self.skip_whitespace()\n                            token = ''\n                            continue\n                        else:\n                            return Token(EOL, '\\n')\n                    else:\n                        # This code exists in case we ever want a\n                        # delimiter to be returned.  It never produces\n                        # a token currently.\n                        token = c\n                        ttype = DELIMITER\n                else:\n                    self._unget_char(c)\n                break\n            elif self.quoting:\n                if c == '\\\\':\n                    c = self._get_char()\n                    if c == '':\n                        raise dns.exception.UnexpectedEnd\n                    if c.isdigit():\n                        c2 = self._get_char()\n                        if c2 == '':\n                            raise dns.exception.UnexpectedEnd\n                        c3 = self._get_char()\n                        if c == '':\n                            raise dns.exception.UnexpectedEnd\n                        if not (c2.isdigit() and c3.isdigit()):\n                            raise dns.exception.SyntaxError\n                        c = chr(int(c) * 100 + int(c2) * 10 + int(c3))\n                elif c == '\\n':\n                    raise dns.exception.SyntaxError('newline in quoted string')\n            elif c == '\\\\':\n                #\n                # It's an escape.  Put it and the next character into\n                # the token; it will be checked later for goodness.\n                #\n                token += c\n                has_escape = True\n                c = self._get_char()\n                if c == '' or c == '\\n':\n                    raise dns.exception.UnexpectedEnd\n            token += c\n        if token == '' and ttype != QUOTED_STRING:\n            if self.multiline:\n                raise dns.exception.SyntaxError('unbalanced parentheses')\n            ttype = EOF\n        return Token(ttype, token, has_escape)", "response": "Get the next token from the input stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_int(self):\n\n        token = self.get().unescape()\n        if not token.is_identifier():\n            raise dns.exception.SyntaxError('expecting an identifier')\n        if not token.value.isdigit():\n            raise dns.exception.SyntaxError('expecting an integer')\n        return int(token.value)", "response": "Read the next token and interpret it as an integer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_uint8(self):\n\n        value = self.get_int()\n        if value < 0 or value > 255:\n            raise dns.exception.SyntaxError('%d is not an unsigned 8-bit integer' % value)\n        return value", "response": "Read the next token and interpret it as an 8 - bit unsigned integer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the next token and interpret it as a 16 - bit unsigned integer.", "response": "def get_uint16(self):\n        \"\"\"Read the next token and interpret it as a 16-bit unsigned\n        integer.\n\n        @raises dns.exception.SyntaxError:\n        @rtype: int\n        \"\"\"\n\n        value = self.get_int()\n        if value < 0 or value > 65535:\n            raise dns.exception.SyntaxError('%d is not an unsigned 16-bit integer' % value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the next token and interpret it as a 32 - bit unsigned integer.", "response": "def get_uint32(self):\n        \"\"\"Read the next token and interpret it as a 32-bit unsigned\n        integer.\n\n        @raises dns.exception.SyntaxError:\n        @rtype: int\n        \"\"\"\n\n        token = self.get().unescape()\n        if not token.is_identifier():\n            raise dns.exception.SyntaxError('expecting an identifier')\n        if not token.value.isdigit():\n            raise dns.exception.SyntaxError('expecting an integer')\n        value = long(token.value)\n        if value < 0 or value > 4294967296L:\n            raise dns.exception.SyntaxError('%d is not an unsigned 32-bit integer' % value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the next token and interpret it as a string.", "response": "def get_string(self, origin=None):\n        \"\"\"Read the next token and interpret it as a string.\n\n        @raises dns.exception.SyntaxError:\n        @rtype: string\n        \"\"\"\n\n        token = self.get().unescape()\n        if not (token.is_identifier() or token.is_quoted_string()):\n            raise dns.exception.SyntaxError('expecting a string')\n        return token.value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the next token and raise an exception if it is not an identifier.", "response": "def get_identifier(self, origin=None):\n        \"\"\"Read the next token and raise an exception if it is not an identifier.\n\n        @raises dns.exception.SyntaxError:\n        @rtype: string\n        \"\"\"\n\n        token = self.get().unescape()\n        if not token.is_identifier():\n            raise dns.exception.SyntaxError('expecting an identifier')\n        return token.value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_name(self, origin=None):\n\n        token = self.get()\n        if not token.is_identifier():\n            raise dns.exception.SyntaxError('expecting an identifier')\n        return dns.name.from_text(token.value, origin)", "response": "Reads the next token and interpret it as a DNS name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the next token and raise an exception if it isn t EOL or EOF.", "response": "def get_eol(self):\n        \"\"\"Read the next token and raise an exception if it isn't EOL or\n        EOF.\n\n        @raises dns.exception.SyntaxError:\n        @rtype: string\n        \"\"\"\n\n        token = self.get()\n        if not token.is_eol_or_eof():\n            raise dns.exception.SyntaxError('expected EOL or EOF, got %d \"%s\"' % (token.ttype, token.value))\n        return token.value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_rdata_list(ttl, rdatas):\n\n    if len(rdatas) == 0:\n        raise ValueError(\"rdata list must not be empty\")\n    r = None\n    for rd in rdatas:\n        if r is None:\n            r = Rdataset(rd.rdclass, rd.rdtype)\n            r.update_ttl(ttl)\n            first_time = False\n        r.add(rd)\n    return r", "response": "Create an rdataset with the specified TTL and with\n    the specified list of rdata objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the TTL of the rdataset to be the lesser of the set s current TTL or the specified TTL.", "response": "def update_ttl(self, ttl):\n        \"\"\"Set the TTL of the rdataset to be the lesser of the set's current\n        TTL or the specified TTL.  If the set contains no rdatas, set the TTL\n        to the specified TTL.\n        @param ttl: The TTL\n        @type ttl: int\"\"\"\n\n        if len(self) == 0:\n            self.ttl = ttl\n        elif ttl < self.ttl:\n            self.ttl = ttl"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, rd, ttl=None):\n\n        #\n        # If we're adding a signature, do some special handling to\n        # check that the signature covers the same type as the\n        # other rdatas in this rdataset.  If this is the first rdata\n        # in the set, initialize the covers field.\n        #\n        if self.rdclass != rd.rdclass or self.rdtype != rd.rdtype:\n            raise IncompatibleTypes\n        if not ttl is None:\n            self.update_ttl(ttl)\n        if self.rdtype == dns.rdatatype.RRSIG or \\\n           self.rdtype == dns.rdatatype.SIG:\n            covers = rd.covers()\n            if len(self) == 0 and self.covers == dns.rdatatype.NONE:\n                self.covers = covers\n            elif self.covers != covers:\n                raise DifferingCovers\n        if dns.rdatatype.is_singleton(rd.rdtype) and len(self) > 0:\n            self.clear()\n        super(Rdataset, self).add(rd)", "response": "Add the specified rdata to the rdataset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding all rdatas in other to self.", "response": "def update(self, other):\n        \"\"\"Add all rdatas in other to self.\n\n        @param other: The rdataset from which to update\n        @type other: dns.rdataset.Rdataset object\"\"\"\n\n        self.update_ttl(other.ttl)\n        super(Rdataset, self).update(other)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the rdataset into text format.", "response": "def to_text(self, name=None, origin=None, relativize=True,\n                override_rdclass=None, **kw):\n        \"\"\"Convert the rdataset into DNS master file format.\n\n        @see: L{dns.name.Name.choose_relativity} for more information\n        on how I{origin} and I{relativize} determine the way names\n        are emitted.\n\n        Any additional keyword arguments are passed on to the rdata\n        to_text() method.\n\n        @param name: If name is not None, emit a RRs with I{name} as\n        the owner name.\n        @type name: dns.name.Name object\n        @param origin: The origin for relative names, or None.\n        @type origin: dns.name.Name object\n        @param relativize: True if names should names be relativized\n        @type relativize: bool\"\"\"\n        if not name is None:\n            name = name.choose_relativity(origin, relativize)\n            ntext = str(name)\n            pad = ' '\n        else:\n            ntext = ''\n            pad = ''\n        s = StringIO.StringIO()\n        if not override_rdclass is None:\n            rdclass = override_rdclass\n        else:\n            rdclass = self.rdclass\n        if len(self) == 0:\n            #\n            # Empty rdatasets are used for the question section, and in\n            # some dynamic updates, so we don't need to print out the TTL\n            # (which is meaningless anyway).\n            #\n            print >> s, '%s%s%s %s' % (ntext, pad,\n                                       dns.rdataclass.to_text(rdclass),\n                                       dns.rdatatype.to_text(self.rdtype))\n        else:\n            for rd in self:\n                print >> s, '%s%s%d %s %s %s' % \\\n                      (ntext, pad, self.ttl, dns.rdataclass.to_text(rdclass),\n                       dns.rdatatype.to_text(self.rdtype),\n                       rd.to_text(origin=origin, relativize=relativize, **kw))\n        #\n        # We strip off the final \\n for the caller's convenience in printing\n        #\n        return s.getvalue()[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_wire(self, name, file, compress=None, origin=None,\n                override_rdclass=None, want_shuffle=True):\n        \"\"\"Convert the rdataset to wire format.\n\n        @param name: The owner name of the RRset that will be emitted\n        @type name: dns.name.Name object\n        @param file: The file to which the wire format data will be appended\n        @type file: file\n        @param compress: The compression table to use; the default is None.\n        @type compress: dict\n        @param origin: The origin to be appended to any relative names when\n        they are emitted.  The default is None.\n        @returns: the number of records emitted\n        @rtype: int\n        \"\"\"\n\n        if not override_rdclass is None:\n            rdclass =  override_rdclass\n            want_shuffle = False\n        else:\n            rdclass = self.rdclass\n        file.seek(0, 2)\n        if len(self) == 0:\n            name.to_wire(file, compress, origin)\n            stuff = struct.pack(\"!HHIH\", self.rdtype, rdclass, 0, 0)\n            file.write(stuff)\n            return 1\n        else:\n            if want_shuffle:\n                l = list(self)\n                random.shuffle(l)\n            else:\n                l = self\n            for rd in l:\n                name.to_wire(file, compress, origin)\n                stuff = struct.pack(\"!HHIH\", self.rdtype, rdclass,\n                                    self.ttl, 0)\n                file.write(stuff)\n                start = file.tell()\n                rd.to_wire(file, compress, origin)\n                end = file.tell()\n                assert end - start < 65536\n                file.seek(start - 2)\n                stuff = struct.pack(\"!H\", end - start)\n                file.write(stuff)\n                file.seek(0, 2)\n            return len(self)", "response": "Convert the rdataset to wire format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match(self, rdclass, rdtype, covers):\n        if self.rdclass == rdclass and \\\n           self.rdtype == rdtype and \\\n           self.covers == covers:\n            return True\n        return False", "response": "Returns True if this rdataset matches the specified class type and covers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting plugin modules for given folders.", "response": "def get_plugin_modules(folders, package='plugins',\n                       parentpackage='linkcheck.dummy'):\n    \"\"\"Get plugin modules for given folders.\"\"\"\n    for folder in folders:\n        for module in loader.get_folder_modules(folder, parentpackage):\n            yield module\n    for module in loader.get_package_modules(package):\n        yield module"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget plugin classes for given modules.", "response": "def get_plugin_classes(modules):\n    \"\"\"Get plugin classes for given modules.\"\"\"\n    classes = (_ConnectionPlugin, _ContentPlugin, _ParserPlugin)\n    return loader.get_plugins(modules, classes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the check method of given plugins.", "response": "def run_plugins(plugins, url_data, stop_after_match=False, **kwargs):\n    \"\"\"Run the check(url_data) method of given plugins.\"\"\"\n    for plugin in plugins:\n        log.debug(LOG_PLUGIN, \"Run plugin %s\", plugin.__class__.__name__)\n        if plugin.applies_to(url_data, **kwargs):\n            plugin.check(url_data)\n            if stop_after_match:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun parser plugins for given pagetype.", "response": "def run_parser_plugins(self, url_data, pagetype):\n        \"\"\"Run parser plugins for given pagetype.\"\"\"\n        run_plugins(self.parser_plugins, url_data, stop_after_match=True, pagetype=pagetype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_update ():\n    version, value = get_online_version()\n    if version is None:\n        # value is an error message\n        return False, value\n    if version == CurrentVersion:\n        # user has newest version\n        return True, None\n    if is_newer_version(version):\n        # value is an URL linking to the update package\n        return True, (version, value)\n    # user is running a local or development version\n    return True, (version, None)", "response": "Check if the online version of the current version is newer than the online version of the current version"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndownloads update info and parse it.", "response": "def get_online_version ():\n    \"\"\"Download update info and parse it.\"\"\"\n    # prevent getting a cached answer\n    headers = {'Pragma': 'no-cache', 'Cache-Control': 'no-cache'}\n    content, info = get_content(UPDATE_URL, addheaders=headers)\n    if content is None:\n        return content, info\n    version, url = None, None\n    for line in content.splitlines():\n        if line.startswith(VERSION_TAG):\n            version = line.split(':', 1)[1].strip()\n        elif line.startswith(URL_TAG):\n            url = line.split(':', 1)[1].strip()\n            url = url.replace('${version}', version)\n    return version, url"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_urls (aggregate):\n    try:\n        aggregate.visit_loginurl()\n    except Exception as msg:\n        log.warn(LOG_CHECK, _(\"Error using login URL: %(msg)s.\") % \\\n                 dict(msg=msg))\n        raise\n    try:\n        aggregate.logger.start_log_output()\n    except Exception as msg:\n        log.error(LOG_CHECK, _(\"Error starting log output: %(msg)s.\") % \\\n            dict(msg=msg))\n        raise\n    try:\n        if not aggregate.urlqueue.empty():\n            aggregate.start_threads()\n        check_url(aggregate)\n        aggregate.finish()\n        aggregate.end_log_output()\n    except LinkCheckerInterrupt:\n        raise\n    except KeyboardInterrupt:\n        interrupt(aggregate)\n    except thread.error:\n        log.warn(LOG_CHECK,\n             _(\"Could not start a new thread. Check that the current user\" \\\n               \" is allowed to start new threads.\"))\n        abort(aggregate)\n    except Exception:\n        # Catching \"Exception\" is intentionally done. This saves the program\n        # from libraries that raise all kinds of strange exceptions.\n        console.internal_error()\n        aggregate.logger.log_internal_error()\n        abort(aggregate)", "response": "Main check function ; checks all configured URLs until interrupted\n    with Ctrl - C."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef interrupt (aggregate):\n    while True:\n        try:\n            log.warn(LOG_CHECK,\n               _(\"interrupt; waiting for active threads to finish\"))\n            log.warn(LOG_CHECK,\n               _(\"another interrupt will exit immediately\"))\n            abort(aggregate)\n            break\n        except KeyboardInterrupt:\n            pass", "response": "Interrupt execution and shutdown ignoring any subsequent\n    interrupts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef abort (aggregate):\n    while True:\n        try:\n            aggregate.abort()\n            aggregate.finish()\n            aggregate.end_log_output(interrupt=True)\n            break\n        except KeyboardInterrupt:\n            log.warn(LOG_CHECK, _(\"user abort; force shutdown\"))\n            aggregate.end_log_output(interrupt=True)\n            abort_now()", "response": "Helper function to ensure a clean shutdown."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nforces exit of current process without cleanup.", "response": "def abort_now ():\n    \"\"\"Force exit of current process without cleanup.\"\"\"\n    if os.name == 'posix':\n        # Unix systems can use signals\n        import signal\n        os.kill(os.getpid(), signal.SIGTERM)\n        time.sleep(1)\n        os.kill(os.getpid(), signal.SIGKILL)\n    elif os.name == 'nt':\n        # NT has os.abort()\n        os.abort()\n    else:\n        # All other systems have os._exit() as best shot.\n        os._exit(3)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_aggregate (config):\n    _urlqueue = urlqueue.UrlQueue(max_allowed_urls=config[\"maxnumurls\"])\n    _robots_txt = robots_txt.RobotsTxt(config[\"useragent\"])\n    plugin_manager = plugins.PluginManager(config)\n    result_cache = results.ResultCache()\n    return aggregator.Aggregate(config, _urlqueue, _robots_txt, plugin_manager,\n        result_cache)", "response": "Get an aggregator instance with given configuration."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a network format IPv6 address into text.", "response": "def inet_ntoa(address):\n    \"\"\"Convert a network format IPv6 address into text.\n\n    @param address: the binary address\n    @type address: string\n    @rtype: string\n    @raises ValueError: the address isn't 16 bytes long\n    \"\"\"\n\n    if len(address) != 16:\n        raise ValueError(\"IPv6 addresses are 16 bytes long\")\n    hex = address.encode('hex_codec')\n    chunks = []\n    i = 0\n    l = len(hex)\n    while i < l:\n        chunk = hex[i : i + 4]\n        # strip leading zeros.  we do this with an re instead of\n        # with lstrip() because lstrip() didn't support chars until\n        # python 2.2.2\n        m = _leading_zero.match(chunk)\n        if not m is None:\n            chunk = m.group(1)\n        chunks.append(chunk)\n        i += 4\n    #\n    # Compress the longest subsequence of 0-value chunks to ::\n    #\n    best_start = 0\n    best_len = 0\n    start = -1\n    last_was_zero = False\n    for i in xrange(8):\n        if chunks[i] != '0':\n            if last_was_zero:\n                end = i\n                current_len = end - start\n                if current_len > best_len:\n                    best_start = start\n                    best_len = current_len\n                last_was_zero = False\n        elif not last_was_zero:\n            start = i\n            last_was_zero = True\n    if last_was_zero:\n        end = 8\n        current_len = end - start\n        if current_len > best_len:\n            best_start = start\n            best_len = current_len\n    if best_len > 0:\n        if best_start == 0 and \\\n           (best_len == 6 or\n            best_len == 5 and chunks[5] == 'ffff'):\n            # We have an embedded IPv4 address\n            if best_len == 6:\n                prefix = '::'\n            else:\n                prefix = '::ffff:'\n            hex = prefix + dns.ipv4.inet_ntoa(address[12:])\n        else:\n            hex = ':'.join(chunks[:best_start]) + '::' + \\\n                  ':'.join(chunks[best_start + best_len:])\n    else:\n        hex = ':'.join(chunks)\n    return hex"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inet_aton(text):\n\n    #\n    # Our aim here is not something fast; we just want something that works.\n    #\n\n    if text == '::':\n        text = '0::'\n    #\n    # Get rid of the icky dot-quad syntax if we have it.\n    #\n    m = _v4_ending.match(text)\n    if not m is None:\n        text = \"%s:%04x:%04x\" % (m.group(1),\n                                 int(m.group(2)) * 256 + int(m.group(3)),\n                                 int(m.group(4)) * 256 + int(m.group(5)))\n    #\n    # Try to turn '::<whatever>' into ':<whatever>'; if no match try to\n    # turn '<whatever>::' into '<whatever>:'\n    #\n    m = _colon_colon_start.match(text)\n    if not m is None:\n        text = text[1:]\n    else:\n        m = _colon_colon_end.match(text)\n        if not m is None:\n            text = text[:-1]\n    #\n    # Now canonicalize into 8 chunks of 4 hex digits each\n    #\n    chunks = text.split(':')\n    l = len(chunks)\n    if l > 8:\n        raise dns.exception.SyntaxError\n    seen_empty = False\n    canonical = []\n    for c in chunks:\n        if c == '':\n            if seen_empty:\n                raise dns.exception.SyntaxError\n            seen_empty = True\n            for i in xrange(0, 8 - l + 1):\n                canonical.append('0000')\n        else:\n            lc = len(c)\n            if lc > 4:\n                raise dns.exception.SyntaxError\n            if lc != 4:\n                c = ('0' * (4 - lc)) + c\n            canonical.append(c)\n    if l < 8 and not seen_empty:\n        raise dns.exception.SyntaxError\n    text = ''.join(canonical)\n\n    #\n    # Finally we can go to binary.\n    #\n    try:\n        return text.decode('hex_codec')\n    except TypeError:\n        raise dns.exception.SyntaxError", "response": "Convert a text format IPv6 address into network format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode (text):\n    if isinstance(text, unicode):\n        return text.encode(i18n.default_encoding, 'ignore')\n    return text", "response": "Encode text with default encoding if its Unicode."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint internal error message.", "response": "def internal_error (out=stderr, etype=None, evalue=None, tb=None):\n    \"\"\"Print internal error message (output defaults to stderr).\"\"\"\n    print(os.linesep, file=out)\n    print(_(\"\"\"********** Oops, I did it again. *************\n\nYou have found an internal error in LinkChecker. Please write a bug report\nat %s\nand include the following information:\n- the URL or file you are testing\n- the system information below\n\nWhen using the commandline client:\n- your commandline arguments and any custom configuration files.\n- the output of a debug run with option \"-Dall\"\n\nNot disclosing some of the information above due to privacy reasons is ok.\nI will try to help you nonetheless, but you have to give me something\nI can work with ;) .\n\"\"\") % configuration.SupportUrl, file=out)\n    if etype is None:\n        etype = sys.exc_info()[0]\n    if evalue is None:\n        evalue = sys.exc_info()[1]\n    if tb is None:\n        tb = sys.exc_info()[2]\n    better_exchook2.better_exchook(etype, evalue, tb, out=out)\n    print_app_info(out=out)\n    print_proxy_info(out=out)\n    print_locale_info(out=out)\n    print(os.linesep,\n      _(\"******** LinkChecker internal error, over and out ********\"), file=out)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints system and application info.", "response": "def print_app_info (out=stderr):\n    \"\"\"Print system and application info (output defaults to stderr).\"\"\"\n    print(_(\"System info:\"), file=out)\n    print(configuration.App, file=out)\n    print(_(\"Released on:\"), configuration.ReleaseDate, file=out)\n    print(_(\"Python %(version)s on %(platform)s\") %\n                    {\"version\": sys.version, \"platform\": sys.platform}, file=out)\n    for key in PYTHON_ENV_VARS:\n        print_env_info(key, out=out)\n    print(configuration.get_modules_info(), file=out)\n    stime = strformat.strtime(time.time())\n    print(_(\"Local time:\"), stime, file=out)\n    print(_(\"sys.argv:\"), sys.argv, file=out)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints the program version.", "response": "def print_version (out=stdout):\n    \"\"\"Print the program version (output defaults to stdout).\"\"\"\n    print(configuration.App, _(\"released\"),\n          configuration.ReleaseDate, file=out)\n    print(configuration.Copyright, file=out)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting status message to file descriptor.", "response": "def log_status (self, checked, in_progress, queue, duration, num_urls):\n        \"\"\"Write status message to file descriptor.\"\"\"\n        msg = _n(\"%2d thread active\", \"%2d threads active\", in_progress) % \\\n          in_progress\n        self.write(u\"%s, \" % msg)\n        msg = _n(\"%5d link queued\", \"%5d links queued\", queue) % queue\n        self.write(u\"%s, \" % msg)\n        msg = _n(\"%4d link\", \"%4d links\", checked) % checked\n        self.write(u\"%s\" % msg)\n        msg = _n(\"%3d URL\", \"%3d URLs\", num_urls) % num_urls\n        self.write(u\" in %s checked, \" % msg)\n        msg = _(\"runtime %s\") % strformat.strduration_long(duration)\n        self.writeln(msg)\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting status message and line break to file descriptor.", "response": "def writeln (self, msg):\n        \"\"\"Write status message and line break to file descriptor.\"\"\"\n        self.fd.write(u\"%s%s\" % (msg, unicode(os.linesep)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_func_meta (fake_func, real_func):\n    fake_func.__module__ = real_func.__module__\n    fake_func.__name__ = real_func.__name__\n    fake_func.__doc__ = real_func.__doc__\n    fake_func.__dict__.update(real_func.__dict__)\n    return fake_func", "response": "Update the meta information of fake function to that of the real function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deprecated (func):\n    def newfunc (*args, **kwargs):\n        \"\"\"Print deprecated warning and execute original function.\"\"\"\n        warnings.warn(\"Call to deprecated function %s.\" % func.__name__,\n                      category=DeprecationWarning)\n        return func(*args, **kwargs)\n    return update_func_meta(newfunc, func)", "response": "A decorator which marks functions as deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsynchronize a function with a given lock.", "response": "def synchronize (lock, func, log_duration_secs=0):\n    \"\"\"Return synchronized function acquiring the given lock.\"\"\"\n    def newfunc (*args, **kwargs):\n        \"\"\"Execute function synchronized.\"\"\"\n        t = time.time()\n        with lock:\n            duration = time.time() - t\n            if duration > log_duration_secs > 0:\n                print(\"WARN:\", func.__name__, \"locking took %0.2f seconds\" % duration, file=sys.stderr)\n            return func(*args, **kwargs)\n    return update_func_meta(newfunc, func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef notimplemented (func):\n    def newfunc (*args, **kwargs):\n        \"\"\"Raise NotImplementedError\"\"\"\n        co = func.func_code\n        attrs = (co.co_name, co.co_filename, co.co_firstlineno)\n        raise NotImplementedError(\"function %s at %s:%d is not implemented\" % attrs)\n    return update_func_meta(newfunc, func)", "response": "Raises a NotImplementedError if the function is called."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntimes a function and print execution time. For quick n'dirty profiling.", "response": "def timeit (func, log, limit):\n    \"\"\"Print execution time of the function. For quick'n'dirty profiling.\"\"\"\n\n    def newfunc (*args, **kwargs):\n        \"\"\"Execute function and print execution time.\"\"\"\n        t = time.time()\n        res = func(*args, **kwargs)\n        duration = time.time() - t\n        if duration > limit:\n            print(func.__name__, \"took %0.2f seconds\" % duration, file=log)\n            print(args, file=log)\n            print(kwargs, file=log)\n        return res\n    return update_func_meta(newfunc, func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_text(text):\n\n    if text.isdigit():\n        total = long(text)\n    else:\n        if not text[0].isdigit():\n            raise BadTTL\n        total = 0L\n        current = 0L\n        for c in text:\n            if c.isdigit():\n                current *= 10\n                current += long(c)\n            else:\n                c = c.lower()\n                if c == 'w':\n                    total += current * 604800L\n                elif c == 'd':\n                    total += current * 86400L\n                elif c == 'h':\n                    total += current * 3600L\n                elif c == 'm':\n                    total += current * 60L\n                elif c == 's':\n                    total += current\n                else:\n                    raise BadTTL(\"unknown unit '%s'\" % c)\n                current = 0\n        if not current == 0:\n            raise BadTTL(\"trailing integer\")\n    if total < 0L or total > 2147483647L:\n        raise BadTTL(\"TTL should be between 0 and 2^31 - 1 (inclusive)\")\n    return total", "response": "Convert the text form of a TTL to an integer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle keyboard interrupt and other errors.", "response": "def run (self):\n        \"\"\"Handle keyboard interrupt and other errors.\"\"\"\n        try:\n            self.run_checked()\n        except KeyboardInterrupt:\n            thread.interrupt_main()\n        except Exception:\n            self.internal_error()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse(self, url_data):\n        self.url_data = url_data\n        self.loc = False\n        self.url = u\"\"\n        data = url_data.get_content()\n        isfinal = True\n        try:\n            self.parser.Parse(data, isfinal)\n        except ExpatError as expaterr:\n            self.url_data.add_warning(expaterr.message,tag=WARN_XML_PARSE_ERROR)", "response": "Parse XML URL data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start_element(self, name, attrs):\n        self.in_tag = (name == self.tag)\n        self.url = u\"\"", "response": "Set tag status for start element."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef end_element(self, name):\n        self.in_tag = False\n        if name == self.tag:\n            self.add_url()", "response": "End element of the tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds non - empty URLs to the queue.", "response": "def add_url(self):\n        \"\"\"Add non-empty URLs to the queue.\"\"\"\n        if self.url:\n            self.url_data.add_url(self.url, line=self.parser.CurrentLineNumber,\n                column=self.parser.CurrentColumnNumber)\n            self.url = u\"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Windows Shell Folder locations from the registry.", "response": "def get_shell_folder (name):\n    \"\"\"Get Windows Shell Folder locations from the registry.\"\"\"\n    try:\n        import _winreg as winreg\n    except ImportError:\n        import winreg\n    lm = winreg.ConnectRegistry(None, winreg.HKEY_CURRENT_USER)\n    try:\n        key = winreg.OpenKey(lm, r\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\")\n        try:\n            return winreg.QueryValueEx(key, name)[0]\n        finally:\n            key.Close()\n    finally:\n        lm.Close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_csv_file(url, res):\n    response = requests.get(url, stream=True)\n    reader = csv.reader(response.iter_lines())\n    first_row = True\n    for row in reader:\n        if first_row:\n            # skip first row\n            first_row = False\n        else:\n            scheme, template, description, reference = row\n            res[scheme] = description", "response": "Parse given URL and write res with scheme -> description"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_connect(client):\n    print \"++ Opened connection to %s\" % client.addrport()\n    broadcast('%s joins the conversation.\\n' % client.addrport() )\n    CLIENT_LIST.append(client)\n    client.send(\"Welcome to the Chat Server, %s.\\n\" % client.addrport() )", "response": "Sample on_connect function.\n    Handles new connections."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_disconnect(client):\n    print \"-- Lost connection to %s\" % client.addrport()\n    CLIENT_LIST.remove(client)\n    broadcast('%s leaves the conversation.\\n' % client.addrport() )", "response": "Sample on_disconnect function.\n    Handles lost connections."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef kick_idle():\n    ## Who hasn't been typing?\n    for client in CLIENT_LIST:\n        if client.idle() > IDLE_TIMEOUT:\n            print('-- Kicking idle lobby client from %s' % client.addrport())\n            client.active = False", "response": "Kick idle lobby clients."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nechoing whatever client types to everyone.", "response": "def chat(client):\n    \"\"\"\n    Echo whatever client types to everyone.\n    \"\"\"\n    global SERVER_RUN\n    msg = client.get_command()\n    print '%s says, \"%s\"' % (client.addrport(), msg)\n\n    for guest in CLIENT_LIST:\n        if guest != client:\n            guest.send('%s says, %s\\n' % (client.addrport(), msg))\n        else:\n            guest.send('You say, %s\\n' % msg)\n\n    cmd = msg.lower()\n    ## bye = disconnect\n    if cmd == 'bye':\n        client.active = False\n    ## shutdown == stop the server\n    elif cmd == 'shutdown':\n        SERVER_RUN = False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a host : port string into separate components.", "response": "def parse_host_port (host_port):\n    \"\"\"Parse a host:port string into separate components.\"\"\"\n    host, port = urllib.splitport(host_port.strip())\n    if port is not None:\n        if urlutil.is_numeric_port(port):\n            port = int(port)\n    return host, port"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing given proxy information and store parsed values.", "response": "def set_proxy (self, proxy):\n        \"\"\"Parse given proxy information and store parsed values.\n        Note that only http:// proxies are supported, both for ftp://\n        and http:// URLs.\n        \"\"\"\n        self.proxy = proxy\n        self.proxytype = \"http\"\n        self.proxyauth = None\n        if not self.proxy:\n            return\n        proxyurl = urlparse.urlparse(self.proxy)\n        self.proxytype = proxyurl.scheme\n        if self.proxytype not in ('http', 'https'):\n            # Note that invalid proxies might raise TypeError in urllib2,\n            # so make sure to stop checking at this point, not later.\n            msg = _(\"Proxy value `%(proxy)s' must start with 'http:' or 'https:'.\") \\\n                 % dict(proxy=proxy)\n            raise LinkCheckerError(msg)\n        if self.ignore_proxy_host():\n            # log proxy without auth info\n            log.debug(LOG_CHECK, \"ignoring proxy %r\", self.proxy)\n            self.add_info(_(\"Ignoring proxy setting `%(proxy)s'.\") %\n                dict(proxy=proxy))\n            self.proxy = None\n            return\n        log.debug(LOG_CHECK, \"using proxy %r\", self.proxy)\n        self.add_info(_(\"Using proxy `%(proxy)s'.\") % dict(proxy=self.proxy))\n        self.proxyhost = proxyurl.hostname\n        self.proxyport = proxyurl.port\n        if proxyurl.username is not None:\n            username = proxyurl.username\n            password = proxyurl.password if proxy.password is not None else \"\"\n            auth = \"%s:%s\" % (username, password)\n            self.proxyauth = \"Basic \"+httputil.encode_base64(auth)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ignore_proxy_host (self):\n        if urllib.proxy_bypass(self.host):\n            return True\n        no_proxy = os.environ.get(\"no_proxy\")\n        if no_proxy:\n            entries = [parse_host_port(x) for x in no_proxy.split(\",\")]\n            for host, port in entries:\n                if host.lower() == self.host and port == self.port:\n                    return True\n        return False", "response": "Check if self. host is in the no_proxy ignore list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_netloc(self):\n        if self.proxy:\n            scheme = self.proxytype\n            host = self.proxyhost\n            port = self.proxyport\n        else:\n            scheme = self.scheme\n            host = self.host\n            port = self.port\n        return (scheme, host, port)", "response": "Determine scheme host and port for this connection taking\n            proxy data into account."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a (tsig_rdata, mac, ctx) tuple containing the HMAC TSIG rdata for the input parameters, the HMAC MAC calculated by applying the TSIG signature algorithm, and the TSIG digest context. @rtype: (string, string, hmac.HMAC object) @raises ValueError: I{other_data} is too long @raises NotImplementedError: I{algorithm} is not supported", "response": "def sign(wire, keyname, secret, time, fudge, original_id, error,\n         other_data, request_mac, ctx=None, multi=False, first=True,\n         algorithm=default_algorithm):\n    \"\"\"Return a (tsig_rdata, mac, ctx) tuple containing the HMAC TSIG rdata\n    for the input parameters, the HMAC MAC calculated by applying the\n    TSIG signature algorithm, and the TSIG digest context.\n    @rtype: (string, string, hmac.HMAC object)\n    @raises ValueError: I{other_data} is too long\n    @raises NotImplementedError: I{algorithm} is not supported\n    \"\"\"\n\n    (algorithm_name, digestmod) = get_algorithm(algorithm)\n    if first:\n        ctx = hmac.new(secret, digestmod=digestmod)\n        ml = len(request_mac)\n        if ml > 0:\n            ctx.update(struct.pack('!H', ml))\n            ctx.update(request_mac)\n    id = struct.pack('!H', original_id)\n    ctx.update(id)\n    ctx.update(wire[2:])\n    if first:\n        ctx.update(keyname.to_digestable())\n        ctx.update(struct.pack('!H', dns.rdataclass.ANY))\n        ctx.update(struct.pack('!I', 0))\n    long_time = time + 0L\n    upper_time = (long_time >> 32) & 0xffffL\n    lower_time = long_time & 0xffffffffL\n    time_mac = struct.pack('!HIH', upper_time, lower_time, fudge)\n    pre_mac = algorithm_name + time_mac\n    ol = len(other_data)\n    if ol > 65535:\n        raise ValueError('TSIG Other Data is > 65535 bytes')\n    post_mac = struct.pack('!HH', error, ol) + other_data\n    if first:\n        ctx.update(pre_mac)\n        ctx.update(post_mac)\n    else:\n        ctx.update(time_mac)\n    mac = ctx.digest()\n    mpack = struct.pack('!H', len(mac))\n    tsig_rdata = pre_mac + mpack + mac + id + post_mac\n    if multi:\n        ctx = hmac.new(secret)\n        ml = len(mac)\n        ctx.update(struct.pack('!H', ml))\n        ctx.update(mac)\n    else:\n        ctx = None\n    return (tsig_rdata, mac, ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(wire, keyname, secret, now, request_mac, tsig_start, tsig_rdata,\n             tsig_rdlen, ctx=None, multi=False, first=True):\n    \"\"\"Validate the specified TSIG rdata against the other input parameters.\n\n    @raises FormError: The TSIG is badly formed.\n    @raises BadTime: There is too much time skew between the client and the\n    server.\n    @raises BadSignature: The TSIG signature did not validate\n    @rtype: hmac.HMAC object\"\"\"\n\n    (adcount,) = struct.unpack(\"!H\", wire[10:12])\n    if adcount == 0:\n        raise dns.exception.FormError\n    adcount -= 1\n    new_wire = wire[0:10] + struct.pack(\"!H\", adcount) + wire[12:tsig_start]\n    current = tsig_rdata\n    (aname, used) = dns.name.from_wire(wire, current)\n    current = current + used\n    (upper_time, lower_time, fudge, mac_size) = \\\n                 struct.unpack(\"!HIHH\", wire[current:current + 10])\n    time = ((upper_time + 0L) << 32) + (lower_time + 0L)\n    current += 10\n    mac = wire[current:current + mac_size]\n    current += mac_size\n    (original_id, error, other_size) = \\\n                  struct.unpack(\"!HHH\", wire[current:current + 6])\n    current += 6\n    other_data = wire[current:current + other_size]\n    current += other_size\n    if current != tsig_rdata + tsig_rdlen:\n        raise dns.exception.FormError\n    if error != 0:\n        if error == BADSIG:\n            raise PeerBadSignature\n        elif error == BADKEY:\n            raise PeerBadKey\n        elif error == BADTIME:\n            raise PeerBadTime\n        elif error == BADTRUNC:\n            raise PeerBadTruncation\n        else:\n            raise PeerError('unknown TSIG error code %d' % error)\n    time_low = time - fudge\n    time_high = time + fudge\n    if now < time_low or now > time_high:\n        raise BadTime\n    (junk, our_mac, ctx) = sign(new_wire, keyname, secret, time, fudge,\n                                original_id, error, other_data,\n                                request_mac, ctx, multi, first, aname)\n    if (our_mac != mac):\n        raise BadSignature\n    return ctx", "response": "Validate the TSIG rdata against the other input parameters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the wire format string and the hash module to use for the specified TSIG algorithm", "response": "def get_algorithm(algorithm):\n    \"\"\"Returns the wire format string and the hash module to use for the\n    specified TSIG algorithm\n\n    @rtype: (string, hash constructor)\n    @raises NotImplementedError: I{algorithm} is not supported\n    \"\"\"\n\n    global _hashes\n    if _hashes is None:\n        _setup_hashes()\n\n    if isinstance(algorithm, (str, unicode)):\n        algorithm = dns.name.from_text(algorithm)\n\n    if sys.hexversion < 0x02050200 and \\\n       (algorithm == HMAC_SHA384 or algorithm == HMAC_SHA512):\n        raise NotImplementedError(\"TSIG algorithm \" + str(algorithm) +\n                                  \" requires Python 2.5.2 or later\")\n\n    try:\n        return (algorithm.to_digestable(), _hashes[algorithm])\n    except KeyError:\n        raise NotImplementedError(\"TSIG algorithm \" + str(algorithm) +\n                                  \" is not supported\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert the textual form of a network address into its binary form.", "response": "def inet_pton(family, text):\n    \"\"\"Convert the textual form of a network address into its binary form.\n\n    @param family: the address family\n    @type family: int\n    @param text: the textual address\n    @type text: string\n    @raises NotImplementedError: the address family specified is not\n    implemented.\n    @rtype: string\n    \"\"\"\n\n    if family == AF_INET:\n        return dns.ipv4.inet_aton(text)\n    elif family == AF_INET6:\n        return dns.ipv6.inet_aton(text)\n    else:\n        raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the binary form of a network address into its textual form.", "response": "def inet_ntop(family, address):\n    \"\"\"Convert the binary form of a network address into its textual form.\n\n    @param family: the address family\n    @type family: int\n    @param address: the binary address\n    @type address: string\n    @raises NotImplementedError: the address family specified is not\n    implemented.\n    @rtype: string\n    \"\"\"\n    if family == AF_INET:\n        return dns.ipv4.inet_ntoa(address)\n    elif family == AF_INET6:\n        return dns.ipv6.inet_ntoa(address)\n    else:\n        raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine the address family of a textual - form network address.", "response": "def af_for_address(text):\n    \"\"\"Determine the address family of a textual-form network address.\n\n    @param text: the textual address\n    @type text: string\n    @raises ValueError: the address family cannot be determined from the input.\n    @rtype: int\n    \"\"\"\n    try:\n        junk = dns.ipv4.inet_aton(text)\n        return AF_INET\n    except Exception:\n        try:\n            junk = dns.ipv6.inet_aton(text)\n            return AF_INET6\n        except Exception:\n            raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nis the textual - form network address a multicast address?", "response": "def is_multicast(text):\n    \"\"\"Is the textual-form network address a multicast address?\n\n    @param text: the textual address\n    @raises ValueError: the address family cannot be determined from the input.\n    @rtype: bool\n    \"\"\"\n    try:\n        first = ord(dns.ipv4.inet_aton(text)[0])\n        return (first >= 224 and first <= 239)\n    except Exception:\n        try:\n            first = ord(dns.ipv6.inet_aton(text)[0])\n            return (first == 255)\n        except Exception:\n            raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat a stack trace to a message.", "response": "def _stack_format (stack):\n    \"\"\"Format a stack trace to a message.\n\n    @return: formatted stack message\n    @rtype: string\n    \"\"\"\n    s = StringIO()\n    s.write('Traceback:')\n    s.write(os.linesep)\n    for frame, fname, lineno, method, lines, dummy in reversed(stack):\n        s.write('  File %r, line %d, in %s' % (fname, lineno, method))\n        s.write(os.linesep)\n        s.write('    %s' % lines[0].lstrip())\n        if PRINT_LOCALVARS:\n            for key, value in frame.f_locals.items():\n                s.write(\"      %s = \" % key)\n                # be careful not to cause a new error in the error output\n                try:\n                    s.write(repr(value))\n                    s.write(os.linesep)\n                except Exception:\n                    s.write(\"error in repr() call%s\" % os.linesep)\n    return s.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _log (fun, msg, args, **kwargs):\n    fun(msg, *args)\n    if kwargs.get(\"traceback\"):\n        # note: get rid of last parts of the stack\n        fun(_stack_format(inspect.stack()[2:]))\n    if kwargs.get(\"exception\"):\n        fun(traceback.format_exc())", "response": "Log a message with given function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef debug (logname, msg, *args, **kwargs):\n    log = logging.getLogger(logname)\n    if log.isEnabledFor(logging.DEBUG):\n        _log(log.debug, msg, args, **kwargs)", "response": "Log a debug message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef info (logname, msg, *args, **kwargs):\n    log = logging.getLogger(logname)\n    if log.isEnabledFor(logging.INFO):\n        _log(log.info, msg, args, **kwargs)", "response": "Log an informational message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef warn (logname, msg, *args, **kwargs):\n    log = logging.getLogger(logname)\n    if log.isEnabledFor(logging.WARN):\n        _log(log.warn, msg, args, **kwargs)", "response": "Log a warning.\n\n    return: None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef error (logname, msg, *args, **kwargs):\n    log = logging.getLogger(logname)\n    if log.isEnabledFor(logging.ERROR):\n        _log(log.error, msg, args, **kwargs)", "response": "Log an error message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef critical (logname, msg, *args, **kwargs):\n    log = logging.getLogger(logname)\n    if log.isEnabledFor(logging.CRITICAL):\n        _log(log.critical, msg, args, **kwargs)", "response": "Log a critical error."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_files (dirname):\n    for entry in os.listdir(dirname):\n        fullentry = os.path.join(dirname, entry)\n        if os.path.islink(fullentry):\n            continue\n        if os.path.isfile(fullentry):\n            yield entry\n        elif os.path.isdir(fullentry):\n            yield entry+\"/\"", "response": "Get iterator of files in directory. Only allows regular files\n    and directories no symlinks."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_nt_filename (path):\n    unc, rest = os.path.splitunc(path)\n    head, tail = os.path.split(rest)\n    if not tail:\n        return path\n    for fname in os.listdir(unc+head):\n        if fname.lower() == tail.lower():\n            return os.path.join(get_nt_filename(unc+head), fname)\n    log.error(LOG_CHECK, \"could not find %r in %r\", tail, head)\n    return path", "response": "Return case sensitive filename for NT path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_os_filename (path):\n    if os.name == 'nt':\n        path = prepare_urlpath_for_nt(path)\n    res = urllib.url2pathname(fileutil.pathencode(path))\n    if os.name == 'nt' and res.endswith(':') and len(res) == 2:\n        # Work around http://bugs.python.org/issue11474\n        res += os.sep\n    return res", "response": "Return filesystem path for given URL path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if given path is absolute.", "response": "def is_absolute_path (path):\n    \"\"\"Check if given path is absolute. On Windows absolute paths start\n    with a drive letter. On all other systems absolute paths start with\n    a slash.\"\"\"\n    if os.name == 'nt':\n        if re.search(r\"^[a-zA-Z]:\", path):\n            return True\n        path = path.replace(\"\\\\\", \"/\")\n    return path.startswith(\"/\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds the base URL for the current object.", "response": "def build_base_url(self):\n        \"\"\"The URL is normed according to the platform:\n         - the base URL is made an absolute file:// URL\n         - under Windows platform the drive specifier is normed\n        \"\"\"\n        if self.base_url is None:\n            return\n        base_url = self.base_url\n        if not (self.parent_url or self.base_ref or base_url.startswith(\"file:\")):\n            base_url = os.path.expanduser(base_url)\n            if not is_absolute_path(base_url):\n                try:\n                    base_url = os.getcwd()+\"/\"+base_url\n                except OSError as msg:\n                    # occurs on stale remote filesystems (eg. NFS)\n                    errmsg = _(\"Could not get current working directory: %(msg)s\") % dict(msg=msg)\n                    raise LinkCheckerError(errmsg)\n                if os.path.isdir(base_url):\n                    base_url += \"/\"\n            base_url = \"file://\"+base_url\n        if os.name == \"nt\":\n            base_url = base_url.replace(\"\\\\\", \"/\")\n            # transform c:/windows into /c|/windows\n            base_url = re.sub(\"^file://(/?)([a-zA-Z]):\", r\"file:///\\2|\", base_url)\n            # transform file://path into file:///path\n            base_url = re.sub(\"^file://([^/])\", r\"file:///\\1\", base_url)\n        self.base_url = unicode(base_url)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding the base URL and the URL of the file.", "response": "def build_url (self):\n        \"\"\"\n        Calls super.build_url() and adds a trailing slash to directories.\n        \"\"\"\n        self.build_base_url()\n        if self.parent_url is not None:\n            # URL joining with the parent URL only works if the query\n            # of the base URL are removed first.\n            # Otherwise the join function thinks the query is part of\n            # the file name.\n            from .urlbase import url_norm\n            # norm base url - can raise UnicodeError from url.idna_encode()\n            base_url, is_idn = url_norm(self.base_url, self.encoding)\n            urlparts = list(urlparse.urlsplit(base_url))\n            # ignore query part for filesystem urls\n            urlparts[3] = ''\n            self.base_url = urlutil.urlunsplit(urlparts)\n        super(FileUrl, self).build_url()\n        # ignore query and fragment url parts for filesystem urls\n        self.urlparts[3] = self.urlparts[4] = ''\n        if self.is_directory() and not self.urlparts[2].endswith('/'):\n            self.add_warning(_(\"Added trailing slash to directory.\"),\n                           tag=WARN_FILE_MISSING_SLASH)\n            self.urlparts[2] += '/'\n        self.url = urlutil.urlunsplit(self.urlparts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets size of file content and modification time from filename path.", "response": "def add_size_info (self):\n        \"\"\"Get size of file content and modification time from filename path.\"\"\"\n        if self.is_directory():\n            # Directory size always differs from the customer index.html\n            # that is generated. So return without calculating any size.\n            return\n        filename = self.get_os_filename()\n        self.size = fileutil.get_size(filename)\n        self.modified = datetime.utcfromtimestamp(fileutil.get_mtime(filename))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to open the local file. Under NT systems the case sensitivity is checked.", "response": "def check_connection (self):\n        \"\"\"\n        Try to open the local file. Under NT systems the case sensitivity\n        is checked.\n        \"\"\"\n        if (self.parent_url is not None and\n           not self.parent_url.startswith(u\"file:\")):\n            msg = _(\"local files are only checked without parent URL or when the parent URL is also a file\")\n            raise LinkCheckerError(msg)\n        if self.is_directory():\n            self.set_result(_(\"directory\"))\n        else:\n            url = fileutil.pathencode(self.url)\n            self.url_connection = urlopen(url)\n            self.check_case_sensitivity()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the path name and windows path name match cases", "response": "def check_case_sensitivity (self):\n        \"\"\"\n        Check if url and windows path name match cases\n        else there might be problems when copying such\n        files on web servers that are case sensitive.\n        \"\"\"\n        if os.name != 'nt':\n            return\n        path = self.get_os_filename()\n        realpath = get_nt_filename(path)\n        if path != realpath:\n            self.add_warning(_(\"The URL path %(path)r is not the same as the \"\n                            \"system path %(realpath)r. You should always use \"\n                            \"the system path in URLs.\") % \\\n                            {\"path\": path, \"realpath\": realpath},\n                               tag=WARN_FILE_SYSTEM_PATH)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_content (self):\n        if self.is_directory():\n            data = get_index_html(get_files(self.get_os_filename()))\n            if isinstance(data, unicode):\n                data = data.encode(\"iso8859-1\", \"ignore\")\n        else:\n            data = super(FileUrl, self).read_content()\n        return data", "response": "Return file content or in case of directories a dummy HTML file\n        with links to the files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if file is a directory.", "response": "def is_directory (self):\n        \"\"\"\n        Check if file is a directory.\n\n        @return: True iff file is a directory\n        @rtype: bool\n        \"\"\"\n        filename = self.get_os_filename()\n        return os.path.isdir(filename) and not os.path.islink(filename)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_parseable (self):\n        if self.is_directory():\n            return True\n        if firefox.has_sqlite and firefox.extension.search(self.url):\n            return True\n        if self.content_type in self.ContentMimetypes:\n            return True\n        log.debug(LOG_CHECK, \"File with content type %r is not parseable.\", self.content_type)\n        return False", "response": "Check if content is parseable for recursion."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns URL content type or an empty string.", "response": "def set_content_type (self):\n        \"\"\"Return URL content type, or an empty string if content\n        type could not be found.\"\"\"\n        if self.url:\n            self.content_type = mimeutil.guess_mimetype(self.url, read=self.get_content)\n        else:\n            self.content_type = u\"\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_intern_pattern (self, url=None):\n        if url is None:\n            url = self.url\n        if not url:\n            return None\n        if url.startswith('file://'):\n            i = url.rindex('/')\n            if i > 6:\n                # remove last filename to make directory internal\n                url = url[:i+1]\n        return re.escape(url)", "response": "Get pattern for intern URL matching."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a URL to the file.", "response": "def add_url (self, url, line=0, column=0, page=0, name=u\"\", base=None):\n        \"\"\"If a local webroot directory is configured, replace absolute URLs\n        with it. After that queue the URL data for checking.\"\"\"\n        webroot = self.aggregate.config[\"localwebroot\"]\n        if webroot and url and url.startswith(u\"/\"):\n            url = webroot + url[1:]\n            log.debug(LOG_CHECK, \"Applied local webroot `%s' to `%s'.\", webroot, url)\n        super(FileUrl, self).add_url(url, line=line, column=column, page=page, name=name, base=base)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new request session.", "response": "def new_request_session(config, cookies):\n    \"\"\"Create a new request session.\"\"\"\n    session = requests.Session()\n    if cookies:\n        session.cookies = cookies\n    session.max_redirects = config[\"maxhttpredirects\"]\n    session.headers.update({\n        \"User-Agent\": config[\"useragent\"],\n    })\n    if config[\"cookiefile\"]:\n        for cookie in cookies.from_file(config[\"cookiefile\"]):\n            session.cookies = requests.cookies.merge_cookies(session.cookies, cookie)\n    return session"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef visit_loginurl(self):\n        url = self.config[\"loginurl\"]\n        if not url:\n            return\n        user, password = self.config.get_user_password(url)\n        session = requests.Session()\n        # XXX user-agent header\n        # XXX timeout\n        response = session.get(url)\n        cgiuser = self.config[\"loginuserfield\"]\n        cgipassword = self.config[\"loginpasswordfield\"]\n        form = formsearch.search_form(response.content, cgiuser, cgipassword,\n              encoding=response.encoding)\n        form.data[cgiuser] = user\n        form.data[cgipassword] = password\n        for key, value in self.config[\"loginextrafields\"].items():\n            form.data[key] = value\n        formurl = urlparse.urljoin(url, form.url)\n        response = session.post(formurl, data=form.data)\n        self.cookies = session.cookies\n        if len(self.cookies) == 0:\n            raise LinkCheckerError(\"No cookies set by login URL %s\" % url)", "response": "Check for a login URL and visit it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nspawn threads for URL checking and status printing.", "response": "def start_threads (self):\n        \"\"\"Spawn threads for URL checking and status printing.\"\"\"\n        if self.config[\"status\"]:\n            t = status.Status(self, self.config[\"status_wait_seconds\"])\n            t.start()\n            self.threads.append(t)\n        if self.config[\"maxrunseconds\"]:\n            t = interrupt.Interrupt(self.config[\"maxrunseconds\"])\n            t.start()\n            self.threads.append(t)\n        num = self.config[\"threads\"]\n        if num > 0:\n            for dummy in range(num):\n                t = checker.Checker(self.urlqueue, self.logger, self.add_request_session)\n                self.threads.append(t)\n                t.start()\n        else:\n            self.request_sessions[thread.get_ident()] = new_request_session(self.config, self.cookies)\n            checker.check_urls(self.urlqueue, self.logger)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_request_session(self):\n        session = new_request_session(self.config, self.cookies)\n        self.request_sessions[thread.get_ident()] = session", "response": "Add a request session for current thread."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nthrottling requests to one host.", "response": "def wait_for_host(self, host):\n        \"\"\"Throttle requests to one host.\"\"\"\n        t = time.time()\n        if host in self.times:\n            due_time = self.times[host]\n            if due_time > t:\n                wait = due_time - t\n                time.sleep(wait)\n                t = time.time()\n        wait_time = random.uniform(self.wait_time_min, self.wait_time_max)\n        self.times[host] = t + wait_time"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlogging all currently active threads.", "response": "def print_active_threads (self):\n        \"\"\"Log all currently active threads.\"\"\"\n        debug = log.is_debug(LOG_CHECK)\n        if debug:\n            first = True\n            for name in self.get_check_threads():\n                if first:\n                    log.info(LOG_CHECK, _(\"These URLs are still active:\"))\n                    first = False\n                log.info(LOG_CHECK, name[12:])\n        args = dict(\n            num=len([x for x in self.threads if x.getName().startswith(\"CheckThread-\")]),\n            timeout=strformat.strduration_long(self.config[\"aborttimeout\"]),\n        )\n        log.info(LOG_CHECK, _(\"%(num)d URLs are still active. After a timeout of %(timeout)s the active URLs will stop.\") % args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns iterator of checker threads.", "response": "def get_check_threads(self):\n        \"\"\"Return iterator of checker threads.\"\"\"\n        for t in self.threads:\n            name = t.getName()\n            if name.startswith(\"CheckThread-\"):\n                yield name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef abort (self):\n        self.print_active_threads()\n        self.cancel()\n        timeout = self.config[\"aborttimeout\"]\n        try:\n            self.urlqueue.join(timeout=timeout)\n        except urlqueue.Timeout:\n            log.warn(LOG_CHECK, \"Abort timed out after %d seconds, stopping application.\" % timeout)\n            raise KeyboardInterrupt()", "response": "Print still-active URLs and empty the URL queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the stopped threads from the internal thread list.", "response": "def remove_stopped_threads (self):\n        \"\"\"Remove the stopped threads from the internal thread list.\"\"\"\n        self.threads = [t for t in self.threads if t.is_alive()]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait for checker threads to finish.", "response": "def finish (self):\n        \"\"\"Wait for checker threads to finish.\"\"\"\n        if not self.urlqueue.empty():\n            # This happens when all checker threads died.\n            self.cancel()\n        for t in self.threads:\n            t.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint ending output to log.", "response": "def end_log_output(self, **kwargs):\n        \"\"\"Print ending output to log.\"\"\"\n        kwargs.update(dict(\n            downloaded_bytes=self.downloaded_bytes,\n            num_urls = len(self.result_cache),\n        ))\n        self.logger.end_log_output(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_url (self):\n        super(TelnetUrl, self).build_url()\n        # default port\n        if self.port is None:\n            self.port = 23\n        # set user/pass\n        self.user, self.password = self.get_user_password()", "response": "Build the URL for the Telnet URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if the host is empty.", "response": "def local_check (self):\n        \"\"\"\n        Warn about empty host names. Else call super.local_check().\n        \"\"\"\n        if not self.host:\n            self.set_result(_(\"Host is empty\"), valid=False)\n            return\n        super(TelnetUrl, self).local_check()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_connection (self):\n        self.url_connection = telnetlib.Telnet(timeout=self.aggregate.config[\"timeout\"])\n        if log.is_debug(LOG_CHECK):\n            self.url_connection.set_debuglevel(1)\n        self.url_connection.open(self.host, self.port)\n        if self.user:\n            self.url_connection.read_until(\"login: \", 10)\n            self.url_connection.write(encode(self.user)+\"\\n\")\n            if self.password:\n                self.url_connection.read_until(\"Password: \", 10)\n                self.url_connection.write(encode(self.password)+\"\\n\")\n                # XXX how to tell if we are logged in??\n        self.url_connection.write(\"exit\\n\")", "response": "Open a telnet connection and try to login."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a x509 pyopenssl object to a dictionary with keys subject subjectAltName and optional notAfter.", "response": "def x509_to_dict(x509):\n    \"\"\"Parse a x509 pyopenssl object to a dictionary with keys\n    subject, subjectAltName and optional notAfter.\n    \"\"\"\n    from requests.packages.urllib3.contrib.pyopenssl import get_subj_alt_name\n    res = {\n            'subject': (\n                (('commonName', x509.get_subject().CN),),\n            ),\n            'subjectAltName': [\n                ('DNS', value)\n                for value in get_subj_alt_name(x509)\n            ]\n    }\n    notAfter = x509.get_notAfter()\n    if notAfter is not None:\n        parsedtime = asn1_generaltime_to_seconds(notAfter)\n        if parsedtime is not None:\n            res['notAfter'] = parsedtime.strftime('%b %d %H:%M:%S %Y')\n            if parsedtime.tzinfo is None:\n                res['notAfter'] += ' GMT'\n        else:\n            # give up parsing, just set the string\n            res['notAfter'] = notAfter\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef asn1_generaltime_to_seconds(timestr):\n    res = None\n    timeformat = \"%Y%m%d%H%M%S\"\n    try:\n        res = datetime.strptime(timestr, timeformat + 'Z')\n    except ValueError:\n        try:\n            res = datetime.strptime(timestr, timeformat + '%z')\n        except ValueError:\n            pass\n    return res", "response": "Convert a string in the format YYYYMMDDhhmmssZ\n    YYYYMMDDhhmmss + hhmm\n    YYYYMMDDhhmmss - hhmm\n    YYYYMMDDhhmmss - hhmm\n    YYYYMMDDhhmmss - hhmm\n    YYYYMMDDhhmmssZ\n    YYYYMMDDhhmmss - hhmm\n    YYYYMMDDhhmmss - hhmm\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_header_value (headers, name, value):\n    name = name.lower()\n    value = value.lower()\n    for hname, hvalue in headers:\n        if hname.lower()==name and hvalue.lower()==value:\n            return True\n    return False", "response": "Check if a specific header name and value is found in a specific header."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef http_persistent (response):\n    headers = response.getheaders()\n    if response.version == 11:\n        return not has_header_value(headers, 'Connection', 'Close')\n    return has_header_value(headers, \"Connection\", \"Keep-Alive\")", "response": "Returns True if the HTTP connection can be kept open according the the\n header values found in the response object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting HTTP keepalive value from the Keep - Alive header.", "response": "def http_keepalive (headers):\n    \"\"\"\n    Get HTTP keepalive value, either from the Keep-Alive header or a\n    default value.\n\n    @param headers: HTTP headers\n    @type headers: dict\n    @return: keepalive in seconds\n    @rtype: int\n    \"\"\"\n    keepalive = headers.get(\"Keep-Alive\")\n    if keepalive is not None:\n        try:\n            keepalive = int(keepalive[8:].strip())\n        except (ValueError, OverflowError):\n            keepalive = DEFAULT_KEEPALIVE\n    else:\n        keepalive = DEFAULT_KEEPALIVE\n    return keepalive"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the MIME type from the Content - Type header value or the application / octet - stream header value.", "response": "def get_content_type (headers):\n    \"\"\"\n    Get the MIME type from the Content-Type header value, or\n    'application/octet-stream' if not found.\n\n    @return: MIME type\n    @rtype: string\n    \"\"\"\n    ptype = headers.get('Content-Type', 'application/octet-stream')\n    if \";\" in ptype:\n        # split off not needed extension info\n        ptype = ptype.split(';')[0]\n    return ptype.strip().lower()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint available plugins and exit.", "response": "def print_plugins(folders, exit_code=0):\n    \"\"\"Print available plugins and exit.\"\"\"\n    modules = plugins.get_plugin_modules(folders)\n    pluginclasses = sorted(plugins.get_plugin_classes(modules), key=lambda x: x.__name__)\n\n    for pluginclass in pluginclasses:\n        print(pluginclass.__name__)\n        doc = strformat.wrap(pluginclass.__doc__, 80)\n        print(strformat.indent(doc))\n        print()\n    sys.exit(exit_code)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_usage (msg, exit_code=2):\n    program = sys.argv[0]\n    print(_(\"Error: %(msg)s\") % {\"msg\": msg}, file=console.stderr)\n    print(_(\"Execute '%(program)s -h' for help\") % {\"program\": program}, file=console.stderr)\n    sys.exit(exit_code)", "response": "Print a program msg text to stderr and exit."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef aggregate_url (aggregate, url, err_exit_code=2):\n    get_url_from = checker.get_url_from\n    url = checker.guess_url(url)\n    url_data = get_url_from(url, 0, aggregate, extern=(0, 0))\n    aggregate.urlqueue.put(url_data)", "response": "Append given commandline URL to input queue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_help(self, file=sys.stdout):\n        msg = console.encode(self.format_help())\n        if fileutil.is_tty(file):\n            strformat.paginate(msg)\n        else:\n            print(msg, file=file)", "response": "Print a help message to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_wire(wire, keyring=None, request_mac='', xfr=False, origin=None,\n              tsig_ctx = None, multi = False, first = True,\n              question_only = False, one_rr_per_rrset = False):\n    \"\"\"Convert a DNS wire format message into a message\n    object.\n\n    @param keyring: The keyring to use if the message is signed.\n    @type keyring: dict\n    @param request_mac: If the message is a response to a TSIG-signed request,\n    I{request_mac} should be set to the MAC of that request.\n    @type request_mac: string\n    @param xfr: Is this message part of a zone transfer?\n    @type xfr: bool\n    @param origin: If the message is part of a zone transfer, I{origin}\n    should be the origin name of the zone.\n    @type origin: dns.name.Name object\n    @param tsig_ctx: The ongoing TSIG context, used when validating zone\n    transfers.\n    @type tsig_ctx: hmac.HMAC object\n    @param multi: Is this message part of a multiple message sequence?\n    @type multi: bool\n    @param first: Is this message standalone, or the first of a multi\n    message sequence?\n    @type first: bool\n    @param question_only: Read only up to the end of the question section?\n    @type question_only: bool\n    @param one_rr_per_rrset: Put each RR into its own RRset\n    @type one_rr_per_rrset: bool\n    @raises ShortHeader: The message is less than 12 octets long.\n    @raises TrailingJunk: There were octets in the message past the end\n    of the proper DNS message.\n    @raises BadEDNS: An OPT record was in the wrong section, or occurred more\n    than once.\n    @raises BadTSIG: A TSIG record was not the last record of the additional\n    data section.\n    @rtype: dns.message.Message object\"\"\"\n\n    m = Message(id=0)\n    m.keyring = keyring\n    m.request_mac = request_mac\n    m.xfr = xfr\n    m.origin = origin\n    m.tsig_ctx = tsig_ctx\n    m.multi = multi\n    m.first = first\n\n    reader = _WireReader(wire, m, question_only, one_rr_per_rrset)\n    reader.read()\n\n    return m", "response": "Convert a DNS wire format message into a message object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the text format message into a message object.", "response": "def from_text(text):\n    \"\"\"Convert the text format message into a message object.\n\n    @param text: The text format message.\n    @type text: string\n    @raises UnknownHeaderField:\n    @raises dns.exception.SyntaxError:\n    @rtype: dns.message.Message object\"\"\"\n\n    # 'text' can also be a file, but we don't publish that fact\n    # since it's an implementation detail.  The official file\n    # interface is from_file().\n\n    m = Message()\n\n    reader = _TextReader(text, m)\n    reader.read()\n\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_file(f):\n\n    if sys.hexversion >= 0x02030000:\n        # allow Unicode filenames; turn on universal newline support\n        str_type = basestring\n        opts = 'rU'\n    else:\n        str_type = str\n        opts = 'r'\n    if isinstance(f, str_type):\n        f = file(f, opts)\n        want_close = True\n    else:\n        want_close = False\n\n    try:\n        m = from_text(f)\n    finally:\n        if want_close:\n            f.close()\n    return m", "response": "Read the next text format message from the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a query message.", "response": "def make_query(qname, rdtype, rdclass = dns.rdataclass.IN, use_edns=None,\n               want_dnssec=False):\n    \"\"\"Make a query message.\n\n    The query name, type, and class may all be specified either\n    as objects of the appropriate type, or as strings.\n\n    The query will have a randomly choosen query id, and its DNS flags\n    will be set to dns.flags.RD.\n\n    @param qname: The query name.\n    @type qname: dns.name.Name object or string\n    @param rdtype: The desired rdata type.\n    @type rdtype: int\n    @param rdclass: The desired rdata class; the default is class IN.\n    @type rdclass: int\n    @param use_edns: The EDNS level to use; the default is None (no EDNS).\n    See the description of dns.message.Message.use_edns() for the possible\n    values for use_edns and their meanings.\n    @type use_edns: int or bool or None\n    @param want_dnssec: Should the query indicate that DNSSEC is desired?\n    @type want_dnssec: bool\n    @rtype: dns.message.Message object\"\"\"\n\n    if isinstance(qname, (str, unicode)):\n        qname = dns.name.from_text(qname)\n    if isinstance(rdtype, (str, unicode)):\n        rdtype = dns.rdatatype.from_text(rdtype)\n    if isinstance(rdclass, (str, unicode)):\n        rdclass = dns.rdataclass.from_text(rdclass)\n    m = Message()\n    m.flags |= dns.flags.RD\n    m.find_rrset(m.question, qname, rdclass, rdtype, create=True,\n                 force_unique=True)\n    m.use_edns(use_edns)\n    m.want_dnssec(want_dnssec)\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a message which is a response for the specified query.", "response": "def make_response(query, recursion_available=False, our_payload=8192):\n    \"\"\"Make a message which is a response for the specified query.\n    The message returned is really a response skeleton; it has all\n    of the infrastructure required of a response, but none of the\n    content.\n\n    The response's question section is a shallow copy of the query's\n    question section, so the query's question RRsets should not be\n    changed.\n\n    @param query: the query to respond to\n    @type query: dns.message.Message object\n    @param recursion_available: should RA be set in the response?\n    @type recursion_available: bool\n    @param our_payload: payload size to advertise in EDNS responses; default\n    is 8192.\n    @type our_payload: int\n    @rtype: dns.message.Message object\"\"\"\n\n    if query.flags & dns.flags.QR:\n        raise dns.exception.FormError('specified query message is not a query')\n    response = dns.message.Message(query.id)\n    response.flags = dns.flags.QR | (query.flags & dns.flags.RD)\n    if recursion_available:\n        response.flags |= dns.flags.RA\n    response.set_opcode(query.opcode())\n    response.question = list(query.question)\n    if query.edns >= 0:\n        response.use_edns(0, 0, our_payload, query.payload)\n    if not query.keyname is None:\n        response.keyname = query.keyname\n        response.keyring = query.keyring\n        response.request_mac = query.mac\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the message to text.", "response": "def to_text(self,  origin=None, relativize=True, **kw):\n        \"\"\"Convert the message to text.\n\n        The I{origin}, I{relativize}, and any other keyword\n        arguments are passed to the rrset to_wire() method.\n\n        @rtype: string\n        \"\"\"\n\n        s = cStringIO.StringIO()\n        print >> s, 'id %d' % self.id\n        print >> s, 'opcode %s' % \\\n              dns.opcode.to_text(dns.opcode.from_flags(self.flags))\n        rc = dns.rcode.from_flags(self.flags, self.ednsflags)\n        print >> s, 'rcode %s' % dns.rcode.to_text(rc)\n        print >> s, 'flags %s' % dns.flags.to_text(self.flags)\n        if self.edns >= 0:\n            print >> s, 'edns %s' % self.edns\n            if self.ednsflags != 0:\n                print >> s, 'eflags %s' % \\\n                      dns.flags.edns_to_text(self.ednsflags)\n            print >> s, 'payload', self.payload\n        is_update = dns.opcode.is_update(self.flags)\n        if is_update:\n            print >> s, ';ZONE'\n        else:\n            print >> s, ';QUESTION'\n        for rrset in self.question:\n            print >> s, rrset.to_text(origin, relativize, **kw)\n        if is_update:\n            print >> s, ';PREREQ'\n        else:\n            print >> s, ';ANSWER'\n        for rrset in self.answer:\n            print >> s, rrset.to_text(origin, relativize, **kw)\n        if is_update:\n            print >> s, ';UPDATE'\n        else:\n            print >> s, ';AUTHORITY'\n        for rrset in self.authority:\n            print >> s, rrset.to_text(origin, relativize, **kw)\n        print >> s, ';ADDITIONAL'\n        for rrset in self.additional:\n            print >> s, rrset.to_text(origin, relativize, **kw)\n        #\n        # We strip off the final \\n so the caller can print the result without\n        # doing weird things to get around eccentricities in Python print\n        # formatting\n        #\n        return s.getvalue()[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nis this message a response to other?", "response": "def is_response(self, other):\n        \"\"\"Is other a response to self?\n        @rtype: bool\"\"\"\n        if other.flags & dns.flags.QR == 0 or \\\n           self.id != other.id or \\\n           dns.opcode.from_flags(self.flags) != \\\n           dns.opcode.from_flags(other.flags):\n            return False\n        if dns.rcode.from_flags(other.flags, other.ednsflags) != \\\n               dns.rcode.NOERROR:\n            return True\n        if dns.opcode.is_update(self.flags):\n            return True\n        for n in self.question:\n            if n not in other.question:\n                return False\n        for n in other.question:\n            if n not in self.question:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_rrset(self, section, name, rdclass, rdtype,\n                   covers=dns.rdatatype.NONE, deleting=None, create=False,\n                   force_unique=False):\n        \"\"\"Find the RRset with the given attributes in the specified section.\n\n        @param section: the section of the message to look in, e.g.\n        self.answer.\n        @type section: list of dns.rrset.RRset objects\n        @param name: the name of the RRset\n        @type name: dns.name.Name object\n        @param rdclass: the class of the RRset\n        @type rdclass: int\n        @param rdtype: the type of the RRset\n        @type rdtype: int\n        @param covers: the covers value of the RRset\n        @type covers: int\n        @param deleting: the deleting value of the RRset\n        @type deleting: int\n        @param create: If True, create the RRset if it is not found.\n        The created RRset is appended to I{section}.\n        @type create: bool\n        @param force_unique: If True and create is also True, create a\n        new RRset regardless of whether a matching RRset exists already.\n        @type force_unique: bool\n        @raises KeyError: the RRset was not found and create was False\n        @rtype: dns.rrset.RRset object\"\"\"\n\n        key = (self.section_number(section),\n               name, rdclass, rdtype, covers, deleting)\n        if not force_unique:\n            if not self.index is None:\n                rrset = self.index.get(key)\n                if not rrset is None:\n                    return rrset\n            else:\n                for rrset in section:\n                    if rrset.match(name, rdclass, rdtype, covers, deleting):\n                        return rrset\n        if not create:\n            raise KeyError\n        rrset = dns.rrset.RRset(name, rdclass, rdtype, covers, deleting)\n        section.append(rrset)\n        if not self.index is None:\n            self.index[key] = rrset\n        return rrset", "response": "Finds the RRset with the given attributes in the specified section."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the RRset with the given attributes in the specified section. If the RRset is not found None is returned.", "response": "def get_rrset(self, section, name, rdclass, rdtype,\n                  covers=dns.rdatatype.NONE, deleting=None, create=False,\n                  force_unique=False):\n        \"\"\"Get the RRset with the given attributes in the specified section.\n\n        If the RRset is not found, None is returned.\n\n        @param section: the section of the message to look in, e.g.\n        self.answer.\n        @type section: list of dns.rrset.RRset objects\n        @param name: the name of the RRset\n        @type name: dns.name.Name object\n        @param rdclass: the class of the RRset\n        @type rdclass: int\n        @param rdtype: the type of the RRset\n        @type rdtype: int\n        @param covers: the covers value of the RRset\n        @type covers: int\n        @param deleting: the deleting value of the RRset\n        @type deleting: int\n        @param create: If True, create the RRset if it is not found.\n        The created RRset is appended to I{section}.\n        @type create: bool\n        @param force_unique: If True and create is also True, create a\n        new RRset regardless of whether a matching RRset exists already.\n        @type force_unique: bool\n        @rtype: dns.rrset.RRset object or None\"\"\"\n\n        try:\n            rrset = self.find_rrset(section, name, rdclass, rdtype, covers,\n                                    deleting, create, force_unique)\n        except KeyError:\n            rrset = None\n        return rrset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_wire(self, origin=None, max_size=0, **kw):\n\n        if max_size == 0:\n            if self.request_payload != 0:\n                max_size = self.request_payload\n            else:\n                max_size = 65535\n        if max_size < 512:\n            max_size = 512\n        elif max_size > 65535:\n            max_size = 65535\n        r = dns.renderer.Renderer(self.id, self.flags, max_size, origin)\n        for rrset in self.question:\n            r.add_question(rrset.name, rrset.rdtype, rrset.rdclass)\n        for rrset in self.answer:\n            r.add_rrset(dns.renderer.ANSWER, rrset, **kw)\n        for rrset in self.authority:\n            r.add_rrset(dns.renderer.AUTHORITY, rrset, **kw)\n        if self.edns >= 0:\n            r.add_edns(self.edns, self.ednsflags, self.payload, self.options)\n        for rrset in self.additional:\n            r.add_rrset(dns.renderer.ADDITIONAL, rrset, **kw)\n        r.write_header()\n        if not self.keyname is None:\n            r.add_tsig(self.keyname, self.keyring[self.keyname],\n                       self.fudge, self.original_id, self.tsig_error,\n                       self.other_data, self.request_mac,\n                       self.keyalgorithm)\n            self.mac = r.mac\n        return r.get_wire()", "response": "Return the string representation of the message in DNS compressed wire format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef use_edns(self, edns=0, ednsflags=0, payload=1280, request_payload=None, options=None):\n        if edns is None or edns is False:\n            edns = -1\n        if edns is True:\n            edns = 0\n        if request_payload is None:\n            request_payload = payload\n        if edns < 0:\n            ednsflags = 0\n            payload = 0\n            request_payload = 0\n            options = []\n        else:\n            # make sure the EDNS version in ednsflags agrees with edns\n            ednsflags &= 0xFF00FFFFL\n            ednsflags |= (edns << 16)\n            if options is None:\n                options = []\n        self.edns = edns\n        self.ednsflags = ednsflags\n        self.payload = payload\n        self.options = options\n        self.request_payload = request_payload", "response": "Configure EDNS behavior.\n        @param edns: The EDNS level to use.  Specifying None, False, or -1\n        means 'do not use EDNS', and in this case the other parameters are\n        ignored.  Specifying True is equivalent to specifying 0, i.e. 'use\n        EDNS0'.\n        @type edns: int or bool or None\n        @param ednsflags: EDNS flag values.\n        @type ednsflags: int\n        @param payload: The EDNS sender's payload field, which is the maximum\n        size of UDP datagram the sender can handle.\n        @type payload: int\n        @param request_payload: The EDNS payload size to use when sending\n        this message.  If not specified, defaults to the value of payload.\n        @type request_payload: int or None\n        @param options: The EDNS options\n        @type options: None or list of dns.edns.Option objects\n        @see: RFC 2671"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef want_dnssec(self, wanted=True):\n        if wanted:\n            if self.edns < 0:\n                self.use_edns()\n            self.ednsflags |= dns.flags.DO\n        elif self.edns >= 0:\n            self.ednsflags &= ~dns.flags.DO", "response": "Enable or disable DNSSEC desired flag in requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_rcode(self, rcode):\n        (value, evalue) = dns.rcode.to_flags(rcode)\n        self.flags &= 0xFFF0\n        self.flags |= value\n        self.ednsflags &= 0x00FFFFFFL\n        self.ednsflags |= evalue\n        if self.ednsflags != 0 and self.edns < 0:\n            self.edns = 0", "response": "Set the rcode.\n        @param rcode: the rcode\n        @type rcode: int"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the opcode. @param opcode: the opcode @type opcode: int", "response": "def set_opcode(self, opcode):\n        \"\"\"Set the opcode.\n        @param opcode: the opcode\n        @type opcode: int\n        \"\"\"\n        self.flags &= 0x87FF\n        self.flags |= dns.opcode.to_flags(opcode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the next I { qcount records from the wire and add them to the question section.", "response": "def _get_question(self, qcount):\n        \"\"\"Read the next I{qcount} records from the wire data and add them to\n        the question section.\n        @param qcount: the number of questions in the message\n        @type qcount: int\"\"\"\n\n        if self.updating and qcount > 1:\n            raise dns.exception.FormError\n\n        for i in xrange(0, qcount):\n            (qname, used) = dns.name.from_wire(self.wire, self.current)\n            if not self.message.origin is None:\n                qname = qname.relativize(self.message.origin)\n            self.current = self.current + used\n            (rdtype, rdclass) = \\\n                     struct.unpack('!HH',\n                                   self.wire[self.current:self.current + 4])\n            self.current = self.current + 4\n            self.message.find_rrset(self.message.question, qname,\n                                    rdclass, rdtype, create=True,\n                                    force_unique=True)\n            if self.updating:\n                self.zone_rdclass = rdclass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_section(self, section, count):\n\n        if self.updating or self.one_rr_per_rrset:\n            force_unique = True\n        else:\n            force_unique = False\n        seen_opt = False\n        for i in xrange(0, count):\n            rr_start = self.current\n            (name, used) = dns.name.from_wire(self.wire, self.current)\n            absolute_name = name\n            if not self.message.origin is None:\n                name = name.relativize(self.message.origin)\n            self.current = self.current + used\n            (rdtype, rdclass, ttl, rdlen) = \\\n                     struct.unpack('!HHIH',\n                                   self.wire[self.current:self.current + 10])\n            self.current = self.current + 10\n            if rdtype == dns.rdatatype.OPT:\n                if not section is self.message.additional or seen_opt:\n                    raise BadEDNS\n                self.message.payload = rdclass\n                self.message.ednsflags = ttl\n                self.message.edns = (ttl & 0xff0000) >> 16\n                self.message.options = []\n                current = self.current\n                optslen = rdlen\n                while optslen > 0:\n                    (otype, olen) = \\\n                            struct.unpack('!HH',\n                                          self.wire[current:current + 4])\n                    current = current + 4\n                    opt = dns.edns.option_from_wire(otype, self.wire, current, olen)\n                    self.message.options.append(opt)\n                    current = current + olen\n                    optslen = optslen - 4 - olen\n                seen_opt = True\n            elif rdtype == dns.rdatatype.TSIG:\n                if not (section is self.message.additional and\n                        i == (count - 1)):\n                    raise BadTSIG\n                if self.message.keyring is None:\n                    raise UnknownTSIGKey('got signed message without keyring')\n                secret = self.message.keyring.get(absolute_name)\n                if secret is None:\n                    raise UnknownTSIGKey(\"key '%s' unknown\" % name)\n                self.message.tsig_ctx = \\\n                                      dns.tsig.validate(self.wire,\n                                          absolute_name,\n                                          secret,\n                                          int(time.time()),\n                                          self.message.request_mac,\n                                          rr_start,\n                                          self.current,\n                                          rdlen,\n                                          self.message.tsig_ctx,\n                                          self.message.multi,\n                                          self.message.first)\n                self.message.had_tsig = True\n            else:\n                if ttl < 0:\n                    ttl = 0\n                if self.updating and \\\n                   (rdclass == dns.rdataclass.ANY or\n                    rdclass == dns.rdataclass.NONE):\n                    deleting = rdclass\n                    rdclass = self.zone_rdclass\n                else:\n                    deleting = None\n                if deleting == dns.rdataclass.ANY or \\\n                   (deleting == dns.rdataclass.NONE and \\\n                    section is self.message.answer):\n                    covers = dns.rdatatype.NONE\n                    rd = None\n                else:\n                    rd = dns.rdata.from_wire(rdclass, rdtype, self.wire,\n                                             self.current, rdlen,\n                                             self.message.origin)\n                    covers = rd.covers()\n                if self.message.xfr and rdtype == dns.rdatatype.SOA:\n                    force_unique = True\n                rrset = self.message.find_rrset(section, name,\n                                                rdclass, rdtype, covers,\n                                                deleting, True, force_unique)\n                if not rd is None:\n                    rrset.add(rd, ttl)\n            self.current = self.current + rdlen", "response": "Read the next count records from the wire and add them to the specified section."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a wire format DNS message and build a dns. message. Message object.", "response": "def read(self):\n        \"\"\"Read a wire format DNS message and build a dns.message.Message\n        object.\"\"\"\n\n        l = len(self.wire)\n        if l < 12:\n            raise ShortHeader\n        (self.message.id, self.message.flags, qcount, ancount,\n         aucount, adcount) = struct.unpack('!HHHHHH', self.wire[:12])\n        self.current = 12\n        if dns.opcode.is_update(self.message.flags):\n            self.updating = True\n        self._get_question(qcount)\n        if self.question_only:\n            return\n        self._get_section(self.message.answer, ancount)\n        self._get_section(self.message.authority, aucount)\n        self._get_section(self.message.additional, adcount)\n        if self.current != l:\n            raise TrailingJunk\n        if self.message.multi and self.message.tsig_ctx and \\\n               not self.message.had_tsig:\n            self.message.tsig_ctx.update(self.wire)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess one line from the text format header section.", "response": "def _header_line(self, section):\n        \"\"\"Process one line from the text format header section.\"\"\"\n\n        token = self.tok.get()\n        what = token.value\n        if what == 'id':\n            self.message.id = self.tok.get_int()\n        elif what == 'flags':\n            while True:\n                token = self.tok.get()\n                if not token.is_identifier():\n                    self.tok.unget(token)\n                    break\n                self.message.flags = self.message.flags | \\\n                                     dns.flags.from_text(token.value)\n            if dns.opcode.is_update(self.message.flags):\n                self.updating = True\n        elif what == 'edns':\n            self.message.edns = self.tok.get_int()\n            self.message.ednsflags = self.message.ednsflags | \\\n                                     (self.message.edns << 16)\n        elif what == 'eflags':\n            if self.message.edns < 0:\n                self.message.edns = 0\n            while True:\n                token = self.tok.get()\n                if not token.is_identifier():\n                    self.tok.unget(token)\n                    break\n                self.message.ednsflags = self.message.ednsflags | \\\n                              dns.flags.edns_from_text(token.value)\n        elif what == 'payload':\n            self.message.payload = self.tok.get_int()\n            if self.message.edns < 0:\n                self.message.edns = 0\n        elif what == 'opcode':\n            text = self.tok.get_string()\n            self.message.flags = self.message.flags | \\\n                      dns.opcode.to_flags(dns.opcode.from_text(text))\n        elif what == 'rcode':\n            text = self.tok.get_string()\n            self.message.set_rcode(dns.rcode.from_text(text))\n        else:\n            raise UnknownHeaderField\n        self.tok.get_eol()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _question_line(self, section):\n\n        token = self.tok.get(want_leading = True)\n        if not token.is_whitespace():\n            self.last_name = dns.name.from_text(token.value, None)\n        name = self.last_name\n        token = self.tok.get()\n        if not token.is_identifier():\n            raise dns.exception.SyntaxError\n        # Class\n        try:\n            rdclass = dns.rdataclass.from_text(token.value)\n            token = self.tok.get()\n            if not token.is_identifier():\n                raise dns.exception.SyntaxError\n        except dns.exception.SyntaxError:\n            raise dns.exception.SyntaxError\n        except Exception:\n            rdclass = dns.rdataclass.IN\n        # Type\n        rdtype = dns.rdatatype.from_text(token.value)\n        self.message.find_rrset(self.message.question, name,\n                                rdclass, rdtype, create=True,\n                                force_unique=True)\n        if self.updating:\n            self.zone_rdclass = rdclass\n        self.tok.get_eol()", "response": "Process one line from the text format question section."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _rr_line(self, section):\n\n        deleting = None\n        # Name\n        token = self.tok.get(want_leading = True)\n        if not token.is_whitespace():\n            self.last_name = dns.name.from_text(token.value, None)\n        name = self.last_name\n        token = self.tok.get()\n        if not token.is_identifier():\n            raise dns.exception.SyntaxError\n        # TTL\n        try:\n            ttl = int(token.value, 0)\n            token = self.tok.get()\n            if not token.is_identifier():\n                raise dns.exception.SyntaxError\n        except dns.exception.SyntaxError:\n            raise dns.exception.SyntaxError\n        except Exception:\n            ttl = 0\n        # Class\n        try:\n            rdclass = dns.rdataclass.from_text(token.value)\n            token = self.tok.get()\n            if not token.is_identifier():\n                raise dns.exception.SyntaxError\n            if rdclass == dns.rdataclass.ANY or rdclass == dns.rdataclass.NONE:\n                deleting = rdclass\n                rdclass = self.zone_rdclass\n        except dns.exception.SyntaxError:\n            raise dns.exception.SyntaxError\n        except Exception:\n            rdclass = dns.rdataclass.IN\n        # Type\n        rdtype = dns.rdatatype.from_text(token.value)\n        token = self.tok.get()\n        if not token.is_eol_or_eof():\n            self.tok.unget(token)\n            rd = dns.rdata.from_text(rdclass, rdtype, self.tok, None)\n            covers = rd.covers()\n        else:\n            rd = None\n            covers = dns.rdatatype.NONE\n        rrset = self.message.find_rrset(section, name,\n                                        rdclass, rdtype, covers,\n                                        deleting, True, self.updating)\n        if not rd is None:\n            rrset.add(rd, ttl)", "response": "Process one line from the text format answer authority or or\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a text format DNS message and build a dns. message. Message object.", "response": "def read(self):\n        \"\"\"Read a text format DNS message and build a dns.message.Message\n        object.\"\"\"\n\n        line_method = self._header_line\n        section = None\n        while 1:\n            token = self.tok.get(True, True)\n            if token.is_eol_or_eof():\n                break\n            if token.is_comment():\n                u = token.value.upper()\n                if u == 'HEADER':\n                    line_method = self._header_line\n                elif u == 'QUESTION' or u == 'ZONE':\n                    line_method = self._question_line\n                    section = self.message.question\n                elif u == 'ANSWER' or u == 'PREREQ':\n                    line_method = self._rr_line\n                    section = self.message.answer\n                elif u == 'AUTHORITY' or u == 'UPDATE':\n                    line_method = self._rr_line\n                    section = self.message.authority\n                elif u == 'ADDITIONAL':\n                    line_method = self._rr_line\n                    section = self.message.additional\n                self.tok.get_eol()\n                continue\n            self.tok.unget(token)\n            line_method(section)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_text(text):\n\n    if text.isdigit():\n        value = int(text)\n        if value >= 0 and value <= 15:\n            return value\n    value = _by_text.get(text.upper())\n    if value is None:\n        raise UnknownOpcode\n    return value", "response": "Convert a textual opcode into an int\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting correct file permissions.", "response": "def chmod(config):\n    \"\"\"Set correct file permissions.\"\"\"\n    output_dir = config[\"output_dir\"]\n    for dirpath, dirnames, filenames in os.walk(output_dir):\n        for dirname in dirnames:\n            os.chmod(os.path.join(dirpath, dirname), 0755)\n        for filename in filenames:\n            os.chmod(os.path.join(dirpath, filename), 0644)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd given patterns to trace filter set or clear set.", "response": "def trace_filter (patterns):\n    \"\"\"Add given patterns to trace filter set or clear set if patterns is\n    None.\"\"\"\n    if patterns is None:\n        _trace_filter.clear()\n    else:\n        _trace_filter.update(re.compile(pat) for pat in patterns)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _trace (frame, event, arg):\n    if event in ('call', 'c_call'):\n        _trace_line(frame, event, arg)\n    elif event in ('return', 'c_return'):\n        _trace_line(frame, event, arg)\n        print(\"  return:\", arg)\n    #elif event in ('exception', 'c_exception'):\n    #    _trace_line(frame, event, arg)\n    return _trace", "response": "Trace function calls and return functions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _trace_full (frame, event, arg):\n    if event == \"line\":\n        _trace_line(frame, event, arg)\n    else:\n        _trace(frame, event, arg)\n    return _trace_full", "response": "Trace every executed line."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _trace_line (frame, event, arg):\n    name = frame.f_globals[\"__name__\"]\n    if name in _trace_ignore:\n        return _trace_line\n    for pat in _trace_filter:\n        if not pat.match(name):\n            return _trace_line\n    lineno = frame.f_lineno\n    filename = frame.f_globals[\"__file__\"]\n    if filename.endswith((\".pyc\", \".pyo\")):\n        filename = filename[:-1]\n    line = linecache.getline(filename, lineno)\n    currentThread = threading.currentThread()\n    tid = currentThread.ident\n    tname = currentThread.getName()\n    args = (tid, tname, time.time(), line.rstrip(), name, lineno)\n    print(\"THREAD(%d) %r %.2f %s # %s:%d\" % args)", "response": "Print current executed line."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef trace_on (full=False):\n    if full:\n        sys.settrace(_trace_full)\n    else:\n        sys.settrace(_trace)", "response": "Start tracing of the current thread and the current thread only."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite start of checking info as DOT comment.", "response": "def start_output (self):\n        \"\"\"Write start of checking info as DOT comment.\"\"\"\n        super(DOTLogger, self).start_output()\n        if self.has_part(\"intro\"):\n            self.write_intro()\n            self.writeln()\n        self.writeln(u\"digraph G {\")\n        self.writeln(u\"  graph [\")\n        self.writeln(u\"    charset=\\\"%s\\\",\" % self.get_charset_encoding())\n        self.writeln(u\"  ];\")\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites edge from parent to node.", "response": "def write_edge (self, node):\n        \"\"\"Write edge from parent to node.\"\"\"\n        source = dotquote(self.nodes[node[\"parent_url\"]][\"label\"])\n        target = dotquote(node[\"label\"])\n        self.writeln(u'  \"%s\" -> \"%s\" [' % (source, target))\n        self.writeln(u'    label=\"%s\",' % dotquote(node[\"edge\"]))\n        if self.has_part(\"result\"):\n            self.writeln(u\"    valid=%d,\" % node[\"valid\"])\n        self.writeln(u\"  ];\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites start of checking info as xml comment.", "response": "def start_output (self):\n        \"\"\"\n        Write start of checking info as xml comment.\n        \"\"\"\n        super(CustomXMLLogger, self).start_output()\n        self.xml_start_output()\n        attrs = {\"created\": strformat.strtime(self.starttime)}\n        self.xml_starttag(u'linkchecker', attrs)\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs URL data in custom XML format.", "response": "def log_url (self, url_data):\n        \"\"\"\n        Log URL data in custom XML format.\n        \"\"\"\n        self.xml_starttag(u'urldata')\n        if self.has_part('url'):\n            self.xml_tag(u\"url\", unicode(url_data.base_url))\n        if url_data.name and self.has_part('name'):\n            self.xml_tag(u\"name\", unicode(url_data.name))\n        if url_data.parent_url and self.has_part('parenturl'):\n            attrs = {\n                u'line': u\"%d\" % url_data.line,\n                u'column': u\"%d\" % url_data.column,\n            }\n            self.xml_tag(u\"parent\", unicode(url_data.parent_url),\n                         attrs=attrs)\n        if url_data.base_ref and self.has_part('base'):\n            self.xml_tag(u\"baseref\", unicode(url_data.base_ref))\n        if self.has_part(\"realurl\"):\n            self.xml_tag(u\"realurl\", unicode(url_data.url))\n        if self.has_part(\"extern\"):\n            self.xml_tag(u\"extern\", u\"%d\" % (1 if url_data.extern else 0))\n        if url_data.dltime >= 0 and self.has_part(\"dltime\"):\n            self.xml_tag(u\"dltime\", u\"%f\" % url_data.dltime)\n        if url_data.size >= 0 and self.has_part(\"dlsize\"):\n            self.xml_tag(u\"dlsize\", u\"%d\" % url_data.size)\n        if url_data.checktime and self.has_part(\"checktime\"):\n            self.xml_tag(u\"checktime\", u\"%f\" % url_data.checktime)\n        if self.has_part(\"level\"):\n            self.xml_tag(u\"level\", u\"%d\" % url_data.level)\n        if url_data.info and self.has_part('info'):\n            self.xml_starttag(u\"infos\")\n            for info in url_data.info:\n                self.xml_tag(u\"info\", info)\n            self.xml_endtag(u\"infos\")\n        if url_data.modified and self.has_part('modified'):\n            self.xml_tag(u\"modified\", self.format_modified(url_data.modified))\n        if url_data.warnings and self.has_part('warning'):\n            self.xml_starttag(u\"warnings\")\n            for tag, data in url_data.warnings:\n                attrs = {}\n                if tag:\n                    attrs[\"tag\"] = tag\n                self.xml_tag(u\"warning\", data, attrs)\n            self.xml_endtag(u\"warnings\")\n        if self.has_part(\"result\"):\n            attrs = {}\n            if url_data.result:\n                attrs[\"result\"] = url_data.result\n            self.xml_tag(u\"valid\", u\"%d\" % (1 if url_data.valid else 0), attrs)\n        self.xml_endtag(u'urldata')\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef end_output (self, **kwargs):\n        self.xml_endtag(u\"linkchecker\")\n        self.xml_end_output()\n        self.close_fileoutput()", "response": "Write XML end tag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding warnings for W3C HTML or CSS errors in xml format.", "response": "def check_w3_errors (url_data, xml, w3type):\n    \"\"\"Add warnings for W3C HTML or CSS errors in xml format.\n    w3type is either \"W3C HTML\" or \"W3C CSS\".\"\"\"\n    dom = parseString(xml)\n    for error in dom.getElementsByTagName('m:error'):\n        warnmsg = _(\"%(w3type)s validation error at line %(line)s col %(column)s: %(msg)s\")\n        attrs = {\n            \"w3type\": w3type,\n            \"line\": getXmlText(error, \"m:line\"),\n            \"column\": getXmlText(error, \"m:col\"),\n            \"msg\": getXmlText(error, \"m:message\"),\n        }\n        url_data.add_warning(warnmsg % attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getXmlText (parent, tag):\n    elem = parent.getElementsByTagName(tag)[0]\n    # Yes, the DOM standard is awful.\n    rc = []\n    for node in elem.childNodes:\n        if node.nodeType == node.TEXT_NODE:\n            rc.append(node.data)\n    return ''.join(rc)", "response": "Return XML content of given tag in parent element."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_w3_time (self):\n        if time.time() - self.last_w3_call < W3Timer.SleepSeconds:\n            time.sleep(W3Timer.SleepSeconds)\n        self.last_w3_call = time.time()", "response": "Make sure the W3C validators are at most called once a second."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check(self, url_data):\n        self.timer.check_w3_time()\n        session = url_data.session\n        try:\n            body = {'uri': url_data.url, 'output': 'soap12'}\n            response = session.post('http://validator.w3.org/check', data=body)\n            response.raise_for_status()\n            if response.headers.get('x-w3c-validator-status', 'Invalid') == 'Valid':\n                url_data.add_info(u\"W3C Validator: %s\" % _(\"valid HTML syntax\"))\n                return\n            check_w3_errors(url_data, response.text, \"W3C HTML\")\n        except requests.exceptions.RequestException:\n            pass # ignore service failures\n        except Exception as msg:\n            log.warn(LOG_PLUGIN, _(\"HTML syntax check plugin error: %(msg)s \") % {\"msg\": msg})", "response": "Check HTML syntax of given URL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting start of checking info as xml comment.", "response": "def start_output (self):\n        \"\"\"Write start of checking info as xml comment.\"\"\"\n        super(SitemapXmlLogger, self).start_output()\n        self.xml_start_output()\n        attrs = {u\"xmlns\": u\"http://www.sitemaps.org/schemas/sitemap/0.9\"}\n        self.xml_starttag(u'urlset', attrs)\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_filter_url(self, url_data, do_print):\n        self.stats.log_url(url_data, do_print)\n        if self.disabled:\n            return\n        # initialize prefix and priority\n        if self.prefix is None:\n            if not url_data.url.startswith(HTTP_SCHEMES):\n                log.warn(LOG_CHECK, \"Sitemap URL %r does not start with http: or https:.\", url_data.url)\n                self.disabled = True\n                return\n            self.prefix = url_data.url\n            # first URL (ie. the homepage) gets priority 1.0 per default\n            priority = 1.0\n        elif url_data.url == self.prefix:\n            return\n        else:\n            # all other pages get priority 0.5 per default\n            priority = 0.5\n        if self.priority is not None:\n            priority = self.priority\n         # ignore the do_print flag and determine ourselves if we filter the url\n        if (url_data.valid\n            and url_data.url.startswith(HTTP_SCHEMES)\n            and url_data.url.startswith(self.prefix)\n            and url_data.content_type in HTML_TYPES):\n            self.log_url(url_data, priority=priority)", "response": "Update accounting data and determine if URL should be included in the sitemap."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlogs URL data in sitemap format.", "response": "def log_url (self, url_data, priority=None):\n        \"\"\"Log URL data in sitemap format.\"\"\"\n        self.xml_starttag(u'url')\n        self.xml_tag(u'loc', url_data.url)\n        if url_data.modified:\n            self.xml_tag(u'lastmod', self.format_modified(url_data.modified, sep=\"T\"))\n        self.xml_tag(u'changefreq', self.frequency)\n        self.xml_tag(u'priority', \"%.2f\" % priority)\n        self.xml_endtag(u'url')\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef end_output (self, **kwargs):\n        self.xml_endtag(u\"urlset\")\n        self.xml_end_output()\n        self.close_fileoutput()", "response": "Write XML end tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset the HTTP specific variables.", "response": "def reset (self):\n        \"\"\"\n        Initialize HTTP specific variables.\n        \"\"\"\n        super(HttpUrl, self).reset()\n        # initialize check data\n        # server headers\n        self.headers = {}\n        self.auth = None\n        self.ssl_cipher = None\n        self.ssl_cert = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef content_allows_robots (self):\n        if not self.is_html():\n            return True\n        # construct parser object\n        handler = linkparse.MetaRobotsFinder()\n        parser = htmlsax.parser(handler)\n        handler.parser = parser\n        if self.charset:\n            parser.encoding = self.charset\n        # parse\n        try:\n            parser.feed(self.get_content())\n            parser.flush()\n        except linkparse.StopParse as msg:\n            log.debug(LOG_CHECK, \"Stopped parsing: %s\", msg)\n            pass\n        # break cyclic dependencies\n        handler.parser = None\n        parser.handler = None\n        return handler.follow", "response": "Return True if the content of this URL allows robots to be parsed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_size_info (self):\n        if self.headers and \"Content-Length\" in self.headers and \\\n           \"Transfer-Encoding\" not in self.headers:\n            # Note that content-encoding causes size differences since\n            # the content data is always decoded.\n            try:\n                self.size = int(self.getheader(\"Content-Length\"))\n            except (ValueError, OverflowError):\n                pass\n        else:\n            self.size = -1", "response": "Get size of URL content from HTTP header."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks the connection with HTTP protocol.", "response": "def check_connection (self):\n        \"\"\"\n        Check a URL with HTTP protocol.\n        Here is an excerpt from RFC 1945 with common response codes:\n        The first digit of the Status-Code defines the class of response. The\n        last two digits do not have any categorization role. There are 5\n        values for the first digit:\n          - 1xx: Informational - Not used, but reserved for future use\n          - 2xx: Success - The action was successfully received,\n            understood, and accepted.\n          - 3xx: Redirection - Further action must be taken in order to\n            complete the request\n          - 4xx: Client Error - The request contains bad syntax or cannot\n            be fulfilled\n          - 5xx: Server Error - The server failed to fulfill an apparently\n            valid request\n        \"\"\"\n        self.session = self.aggregate.get_request_session()\n        # set the proxy, so a 407 status after this is an error\n        self.set_proxy(self.aggregate.config[\"proxy\"].get(self.scheme))\n        self.construct_auth()\n        # check robots.txt\n        if not self.allows_robots(self.url):\n            self.add_info(_(\"Access denied by robots.txt, checked only syntax.\"))\n            self.set_result(_(\"syntax OK\"))\n            self.do_check_content = False\n            return\n        # check the http connection\n        request = self.build_request()\n        self.send_request(request)\n        self._add_response_info()\n        self.follow_redirections(request)\n        self.check_response()\n        if self.allows_simple_recursion():\n            self.parse_header_links()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a prepared request object.", "response": "def build_request(self):\n        \"\"\"Build a prepared request object.\"\"\"\n        clientheaders = {}\n        if (self.parent_url and\n            self.parent_url.lower().startswith(HTTP_SCHEMAS)):\n            clientheaders[\"Referer\"] = self.parent_url\n        kwargs = dict(\n            method='GET',\n            url=self.url,\n            headers=clientheaders,\n        )\n        if self.auth:\n            kwargs['auth'] = self.auth\n        log.debug(LOG_CHECK, \"Prepare request with %s\", kwargs)\n        request = requests.Request(**kwargs)\n        return self.session.prepare_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_request(self, request):\n        # throttle the number of requests to each host\n        self.aggregate.wait_for_host(self.urlparts[1])\n        kwargs = self.get_request_kwargs()\n        kwargs[\"allow_redirects\"] = False\n        self._send_request(request, **kwargs)", "response": "Send request and store response in self. url_connection."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a request to the server.", "response": "def _send_request(self, request, **kwargs):\n        \"\"\"Send GET request.\"\"\"\n        log.debug(LOG_CHECK, \"Send request %s with %s\", request, kwargs)\n        log.debug(LOG_CHECK, \"Request headers %s\", request.headers)\n        self.url_connection = self.session.send(request, **kwargs)\n        self.headers = self.url_connection.headers\n        self._add_ssl_info()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _add_response_info(self):\n        self.charset = httputil.get_charset(self.headers)\n        self.set_content_type()\n        self.add_size_info()", "response": "Set info from established HTTP connection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_ssl_sock(self):\n        assert self.scheme == u\"https\", self\n        raw_connection = self.url_connection.raw._connection\n        if raw_connection.sock is None:\n            # sometimes the socket is not yet connected\n            # see https://github.com/kennethreitz/requests/issues/1966\n            raw_connection.connect()\n        return raw_connection.sock", "response": "Get raw SSL socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_ssl_info(self):\n        if self.scheme == u'https':\n            sock = self._get_ssl_sock()\n            if hasattr(sock, 'cipher'):\n                self.ssl_cert = sock.getpeercert()\n            else:\n                # using pyopenssl\n                cert = sock.connection.get_peer_certificate()\n                self.ssl_cert = httputil.x509_to_dict(cert)\n            log.debug(LOG_CHECK, \"Got SSL certificate %s\", self.ssl_cert)\n        else:\n            self.ssl_cert = None", "response": "Add SSL cipher info."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconstructing HTTP Basic authentication credentials if there is user and password information available. Does not overwrite if there is already been constructed.", "response": "def construct_auth (self):\n        \"\"\"Construct HTTP Basic authentication credentials if there\n        is user/password information available. Does not overwrite if\n        credentials have already been constructed.\"\"\"\n        if self.auth:\n            return\n        _user, _password = self.get_user_password()\n        if _user is not None and _password is not None:\n            self.auth = (_user, _password)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs keyword parameters for Session. request and Session. resolve_redirects.", "response": "def get_request_kwargs(self):\n        \"\"\"Construct keyword parameters for Session.request() and\n        Session.resolve_redirects().\"\"\"\n        kwargs = dict(stream=True, timeout=self.aggregate.config[\"timeout\"])\n        if self.proxy:\n            kwargs[\"proxies\"] = {self.proxytype: self.proxy}\n        if self.scheme == u\"https\" and self.aggregate.config[\"sslverify\"]:\n            kwargs['verify'] = self.aggregate.config[\"sslverify\"]\n        else:\n            kwargs['verify'] = False\n        return kwargs"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns iterator of redirects for given request.", "response": "def get_redirects(self, request):\n        \"\"\"Return iterator of redirects for given request.\"\"\"\n        kwargs = self.get_request_kwargs()\n        return self.session.resolve_redirects(self.url_connection,\n            request, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef follow_redirections(self, request):\n        log.debug(LOG_CHECK, \"follow all redirections\")\n        if self.is_redirect():\n            # run connection plugins for old connection\n            self.aggregate.plugin_manager.run_connection_plugins(self)\n        response = None\n        for response in self.get_redirects(request):\n            newurl = response.url\n            log.debug(LOG_CHECK, \"Redirected to %r\", newurl)\n            self.aliases.append(newurl)\n            # XXX on redirect errors this is not printed\n            self.add_info(_(\"Redirected to `%(url)s'.\") % {'url': newurl})\n            # Reset extern and recalculate\n            self.extern = None\n            self.set_extern(newurl)\n            self.urlparts = strformat.url_unicode_split(newurl)\n            self.build_url_parts()\n            self.url_connection = response\n            self.headers = response.headers\n            self.url = urlutil.urlunsplit(self.urlparts)\n            self.scheme = self.urlparts[0].lower()\n            self._add_ssl_info()\n            self._add_response_info()\n            if self.is_redirect():\n                # run connection plugins for old connection\n                self.aggregate.plugin_manager.run_connection_plugins(self)", "response": "Follow all redirections of http response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getheader (self, name, default=None):\n        value = self.headers.get(name)\n        if value is None:\n            return default\n        return unicode_safe(value, encoding=HEADER_ENCODING)", "response": "Get decoded header value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_response (self):\n        if self.url_connection.status_code >= 400:\n            self.set_result(u\"%d %s\" % (self.url_connection.status_code, self.url_connection.reason),\n                            valid=False)\n        else:\n            if self.url_connection.status_code == 204:\n                # no content\n                self.add_warning(self.url_connection.reason,\n                                 tag=WARN_HTTP_EMPTY_CONTENT)\n            if self.url_connection.status_code >= 200:\n                self.set_result(u\"%r %s\" % (self.url_connection.status_code, self.url_connection.reason))\n            else:\n                self.set_result(_(\"OK\"))", "response": "Check final result and log it."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_content(self):\n        maxbytes = self.aggregate.config[\"maxfilesizedownload\"]\n        buf = StringIO()\n        for data in self.url_connection.iter_content(chunk_size=self.ReadChunkBytes):\n            if buf.tell() + len(data) > maxbytes:\n                raise LinkCheckerError(_(\"File size too large\"))\n            buf.write(data)\n        return buf.getvalue()", "response": "Return data and data size for this URL. Can be overridden in subclasses."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_header_links(self):\n        for linktype, linkinfo in self.url_connection.links.items():\n            url = linkinfo[\"url\"]\n            name = u\"Link: header %s\" % linktype\n            self.add_url(url, name=name)\n        if 'Refresh' in self.headers:\n            from ..htmlutil.linkparse import refresh_re\n            value = self.headers['Refresh'].strip()\n            mo = refresh_re.match(value)\n            if mo:\n                url = unicode_safe(mo.group(\"url\"))\n                name = u\"Refresh: header\"\n                self.add_url(url, name=name)\n        if 'Content-Location' in self.headers:\n            url = self.headers['Content-Location'].strip()\n            name = u\"Content-Location: header\"\n            self.add_url(url, name=name)", "response": "Parse URLs in HTTP headers Link."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_parseable (self):\n        if not self.valid:\n            return False\n        # some content types must be validated with the page content\n        if self.content_type in (\"application/xml\", \"text/xml\"):\n            rtype = mimeutil.guess_mimetype_read(self.get_content)\n            if rtype is not None:\n                # XXX side effect\n                self.content_type = rtype\n        if self.content_type not in self.ContentMimetypes:\n            log.debug(LOG_CHECK, \"URL with content type %r is not parseable\", self.content_type)\n            return False\n        return True", "response": "Check if content is parseable for recursion."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file(type_str, open_files, basedir):\n    if type_str not in open_files:\n        filename = type_str+\".html\"\n        encoding = 'utf-8'\n        fd = codecs.open(os.path.join(basedir, filename), 'w', encoding)\n        open_files[type_str] = fd\n        write_html_header(fd, type_str, encoding)\n    return open_files[type_str]", "response": "Get already opened file or open and initialize a new one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_loggers():\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "response": "Return list of Logger classes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting all log statistics to default values.", "response": "def reset (self):\n        \"\"\"Reset all log statistics to default values.\"\"\"\n        # number of logged URLs\n        self.number = 0\n        # number of encountered URL errors\n        self.errors = 0\n        # number of URL errors that were printed\n        self.errors_printed = 0\n        # number of URL warnings\n        self.warnings = 0\n        # number of URL warnings that were printed\n        self.warnings_printed = 0\n        # number of internal errors\n        self.internal_errors = 0\n        # link types\n        self.link_types = ContentTypes.copy()\n        # URL length statistics\n        self.max_url_length = 0\n        self.min_url_length = 0\n        self.avg_url_length = 0.0\n        self.avg_number = 0\n        # overall downloaded bytes\n        self.downloaded_bytes = None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_args(self, kwargs):\n        args = dict(self.LoggerArgs)\n        args.update(kwargs)\n        return args", "response": "Construct log configuration from default and user args."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nencode string with output encoding.", "response": "def encode (self, s):\n        \"\"\"Encode string with output encoding.\"\"\"\n        assert isinstance(s, unicode)\n        return s.encode(self.output_encoding, self.codec_errors)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init_fileoutput (self, args):\n        self.filename = None\n        self.close_fd = False\n        self.fd = None\n        if args.get('fileoutput'):\n            self.filename = os.path.expanduser(args['filename'])\n        elif 'fd' in args:\n            self.fd = args['fd']\n        else:\n            self.fd = self.create_fd()", "response": "Initialize self. filename self. close_fd self. fd self. filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts output to configured file.", "response": "def start_fileoutput (self):\n        \"\"\"Start output to configured file.\"\"\"\n        path = os.path.dirname(self.filename)\n        try:\n            if path and not os.path.isdir(path):\n                os.makedirs(path)\n            self.fd = self.create_fd()\n            self.close_fd = True\n        except IOError:\n            msg = sys.exc_info()[1]\n            log.warn(LOG_CHECK,\n                \"Could not open file %r for writing: %s\\n\"\n                \"Disabling log output of %s\", self.filename, msg, self)\n            self.fd = dummy.Dummy()\n            self.is_active = False\n        self.filename = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_fd (self):\n        if self.filename is None:\n            return i18n.get_encoded_writer(encoding=self.output_encoding,\n                                           errors=self.codec_errors)\n        return codecs.open(self.filename, \"wb\", self.output_encoding,\n                           self.codec_errors)", "response": "Create open file descriptor."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nflush and close the file output denoted by self. fd.", "response": "def close_fileoutput (self):\n        \"\"\"\n        Flush and close the file output denoted by self.fd.\n        \"\"\"\n        if self.fd is not None:\n            try:\n                self.flush()\n            except IOError:\n                # ignore flush errors\n                pass\n            if self.close_fd:\n                try:\n                    self.fd.close()\n                except IOError:\n                    # ignore close errors\n                    pass\n            self.fd = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_date (self):\n        now = datetime.date.today()\n        if now.day == 7 and now.month == 1:\n            msg = _(\"Happy birthday for LinkChecker, I'm %d years old today!\")\n            self.comment(msg % (now.year - 2000))", "response": "Check for special dates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap the given lines of text into a single line.", "response": "def wrap (self, lines, width):\n        \"\"\"\n        Return wrapped version of given lines.\n        \"\"\"\n        sep = os.linesep+os.linesep\n        text = sep.join(lines)\n        kwargs = dict(subsequent_indent=\" \"*self.max_indent,\n                      initial_indent=\" \"*self.max_indent,\n                      break_long_words=False,\n                      break_on_hyphens=False)\n        return strformat.wrap(text, width, **kwargs).lstrip()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite string to output descriptor. Strips control characters from string before writing.", "response": "def write (self, s, **args):\n        \"\"\"Write string to output descriptor. Strips control characters\n        from string before writing.\n        \"\"\"\n        if self.filename is not None:\n            self.start_fileoutput()\n        if self.fd is None:\n            # Happens when aborting threads times out\n            log.warn(LOG_CHECK, \"writing to unitialized or closed file\")\n        else:\n            try:\n                self.fd.write(s, **args)\n            except IOError:\n                msg = sys.exc_info()[1]\n                log.warn(LOG_CHECK,\n                    \"Could not write to output file: %s\\n\"\n                    \"Disabling log output of %s\", msg, self)\n                self.close_fileoutput()\n                self.fd = dummy.Dummy()\n                self.is_active = False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef writeln (self, s=u\"\", **args):\n        self.write(u\"%s%s\" % (s, unicode(os.linesep)), **args)", "response": "Writes a string to the output descriptor plus a newline."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_filter_url (self, url_data, do_print):\n        self.stats.log_url(url_data, do_print)\n        if do_print:\n            self.log_url(url_data)", "response": "Log a new url with this logger."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats modification date in UTC if it s not None.", "response": "def format_modified(self, modified, sep=\" \"):\n        \"\"\"Format modification date in UTC if it's not None.\n        @param modified: modification date in UTC\n        @ptype modified: datetime or None\n        @return: formatted date or empty string\n        @rtype: unicode\n        \"\"\"\n        if modified is not None:\n            return modified.strftime(\"%Y-%m-%d{0}%H:%M:%S.%fZ\".format(sep))\n        return u\"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting value with given key from WSGI form.", "response": "def formvalue (form, key):\n    \"\"\"Get value with given key from WSGI form.\"\"\"\n    field = form.get(key)\n    if isinstance(field, list):\n        field = field[0]\n    return field"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates the CGI form and checks the given links.", "response": "def checklink (form=None, env=os.environ):\n    \"\"\"Validates the CGI form and checks the given links.\"\"\"\n    if form is None:\n        form = {}\n    try:\n        checkform(form, env)\n    except LCFormError as errmsg:\n        log(env, errmsg)\n        yield encode(format_error(errmsg))\n        return\n    out = ThreadsafeIO()\n    config = get_configuration(form, out)\n    url = strformat.stripurl(formvalue(form, \"url\"))\n    aggregate = director.get_aggregate(config)\n    url_data = checker.get_url_from(url, 0, aggregate, extern=(0, 0))\n    aggregate.urlqueue.put(url_data)\n    for html_str in start_check(aggregate, out):\n        yield encode(html_str)\n    out.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts checking in background and write encoded output to out.", "response": "def start_check (aggregate, out):\n    \"\"\"Start checking in background and write encoded output to out.\"\"\"\n    # check in background\n    t = threading.Thread(target=director.check_urls, args=(aggregate,))\n    t.start()\n    # time to wait for new data\n    sleep_seconds = 2\n    # current running time\n    run_seconds = 0\n    while not aggregate.is_finished():\n        yield out.get_data()\n        time.sleep(sleep_seconds)\n        run_seconds += sleep_seconds\n        if run_seconds > MAX_REQUEST_SECONDS:\n            director.abort(aggregate)\n            break\n    yield out.get_data()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_configuration(form, out):\n    config = configuration.Configuration()\n    config[\"recursionlevel\"] = int(formvalue(form, \"level\"))\n    config[\"logger\"] = config.logger_new('html', fd=out, encoding=HTML_ENCODING)\n    config[\"threads\"] = 2\n    if \"anchors\" in form:\n        config[\"enabledplugins\"].append(\"AnchorCheck\")\n    if \"errors\" not in form:\n        config[\"verbose\"] = True\n    # avoid checking of local files or other nasty stuff\n    pat = \"!^%s$\" % urlutil.safe_url_pattern\n    config[\"externlinks\"].append(get_link_pat(pat, strict=True))\n    config.sanitize()\n    return config", "response": "Initialize a CGI configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef checkform (form, env):\n    # check lang support\n    if \"language\" in form:\n        lang = formvalue(form, 'language')\n        if lang in _supported_langs:\n            localestr = lang_locale[lang]\n            try:\n                # XXX this is not thread-safe, so think of something else\n                locale.setlocale(locale.LC_ALL, localestr)\n                init_i18n()\n            except locale.Error as errmsg:\n                log(env, \"could not set locale %r: %s\" % (localestr, errmsg))\n        else:\n            raise LCFormError(_(\"unsupported language %r\") % lang)\n    # check url syntax\n    if \"url\" in form:\n        url = formvalue(form, \"url\")\n        if not url or url == \"http://\":\n            raise LCFormError(_(\"empty url was given\"))\n        if not urlutil.is_safe_url(url):\n            raise LCFormError(_(\"disallowed url %r was given\") % url)\n    else:\n        raise LCFormError(_(\"no url was given\"))\n    # check recursion level\n    if \"level\" in form:\n        level = formvalue(form, \"level\")\n        if not _is_level(level):\n            raise LCFormError(_(\"invalid recursion level %r\") % level)\n    # check options\n    for option in (\"anchors\", \"errors\", \"intern\"):\n        if option in form:\n            value = formvalue(form, option)\n            if value != \"on\":\n                raise LCFormError(_(\"invalid %s option %r\") % (option, value))", "response": "Check the form data. throw exception on error\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlog environment and form.", "response": "def dump (env, form):\n    \"\"\"Log environment and form.\"\"\"\n    for var, value in env.items():\n        log(env, var+\"=\"+value)\n    for key in form:\n        log(env, str(formvalue(form, key)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write (self, data):\n        assert isinstance(data, unicode)\n        if self.closed:\n            raise IOError(\"Write on closed I/O object\")\n        if data:\n            self.buf.append(data)", "response": "Write given unicode data to buffer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting bufferd unicode data.", "response": "def get_data (self):\n        \"\"\"Get bufferd unicode data.\"\"\"\n        data = u\"\".join(self.buf)\n        self.buf = []\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_opera (url_data):\n    from ..bookmarks.opera import parse_bookmark_data\n    for url, name, lineno in parse_bookmark_data(url_data.get_content()):\n        url_data.add_url(url, line=lineno, name=name)", "response": "Parse an opera bookmark file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a Chromium or Google Chrome bookmark file.", "response": "def parse_chromium (url_data):\n    \"\"\"Parse a Chromium or Google Chrome bookmark file.\"\"\"\n    from ..bookmarks.chromium import parse_bookmark_data\n    for url, name in parse_bookmark_data(url_data.get_content()):\n        url_data.add_url(url, name=name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_safari (url_data):\n    from ..bookmarks.safari import parse_bookmark_data\n    for url, name in parse_bookmark_data(url_data.get_content()):\n        url_data.add_url(url, name=name)", "response": "Parse a Safari bookmark file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_text (url_data):\n    lineno = 0\n    for line in url_data.get_content().splitlines():\n        lineno += 1\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        url_data.add_url(line, line=lineno)", "response": "Parse a text file with one url per line ; comment and blank\nCTYPE lines are ignored."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_css (url_data):\n    lineno = 0\n    linkfinder = linkparse.css_url_re.finditer\n    strip_comments = linkparse.strip_c_comments\n    for line in strip_comments(url_data.get_content()).splitlines():\n        lineno += 1\n        for mo in linkfinder(line):\n            column = mo.start(\"url\")\n            url = strformat.unquote(mo.group(\"url\").strip())\n            url_data.add_url(url, line=lineno, column=column)", "response": "Parse a CSS file for url patterns."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a SWF file for URLs.", "response": "def parse_swf (url_data):\n    \"\"\"Parse a SWF file for URLs.\"\"\"\n    linkfinder = linkparse.swf_url_re.finditer\n    for mo in linkfinder(url_data.get_content()):\n        url = mo.group()\n        url_data.add_url(url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_links (url_data, callback, tags):\n    # construct parser object\n    handler = linkparse.LinkFinder(callback, tags)\n    parser = htmlsax.parser(handler)\n    if url_data.charset:\n        parser.encoding = url_data.charset\n    handler.parser = parser\n    # parse\n    try:\n        parser.feed(url_data.get_content())\n        parser.flush()\n    except linkparse.StopParse as msg:\n        log.debug(LOG_CHECK, \"Stopped parsing: %s\", msg)\n        pass\n    # break cyclic dependencies\n    handler.parser = None\n    parser.handler = None", "response": "Parse into content and search for URLs to check.\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_firefox (url_data):\n    filename = url_data.get_os_filename()\n    for url, name in firefox.parse_bookmark_file(filename):\n        url_data.add_url(url, name=name)", "response": "Parse a Firefox3 bookmark file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting url CGI parameter value as child URL.", "response": "def parse_itms_services(url_data):\n    \"\"\"Get \"url\" CGI parameter value as child URL.\"\"\"\n    query = url_data.urlparts[3]\n    for k, v, sep in urlutil.parse_qsl(query, keep_blank_values=True):\n        if k == \"url\":\n            url_data.add_url(v)\n            break"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind all valid modules in the given package which must be a folder in the same directory as this loader. py module. A valid module has a. py extension and is importable.", "response": "def get_package_modules(packagename):\n    \"\"\"Find all valid modules in the given package which must be a folder\n    in the same directory as this loader.py module. A valid module has\n    a .py extension, and is importable.\n    @return: all loaded valid modules\n    @rtype: iterator of module\n    \"\"\"\n    if is_frozen():\n        # find modules in library.zip filename\n        zipname = os.path.dirname(os.path.dirname(__file__))\n        parentmodule = os.path.basename(os.path.dirname(__file__))\n        with zipfile.ZipFile(zipname, 'r') as f:\n            prefix = \"%s/%s/\" % (parentmodule, packagename)\n            modnames = [os.path.splitext(n[len(prefix):])[0]\n              for n in f.namelist()\n              if n.startswith(prefix) and \"__init__\" not in n]\n    else:\n        dirname = os.path.join(os.path.dirname(__file__), packagename)\n        modnames = [x[:-3] for x in get_importable_files(dirname)]\n    for modname in modnames:\n        try:\n            name =\"..%s.%s\" % (packagename, modname)\n            yield importlib.import_module(name, __name__)\n        except ImportError as msg:\n            print(\"WARN: could not load module %s: %s\" % (modname, msg))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nyields all modules in a folder.", "response": "def get_folder_modules(folder, parentpackage):\n    \"\"\".\"\"\"\n    if check_writable_by_others(folder):\n        print(\"ERROR: refuse to load modules from world writable folder %r\" % folder)\n        return\n    for filename in get_importable_files(folder):\n        fullname = os.path.join(folder, filename)\n        modname = parentpackage+\".\"+filename[:-3]\n        try:\n            yield imp.load_source(modname, fullname)\n        except ImportError as msg:\n            print(\"WARN: could not load file %s: %s\" % (fullname, msg))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all module files in the given folder that end with. py and don t start with an underscore.", "response": "def get_importable_files(folder):\n    \"\"\"Find all module files in the given folder that end with '.py' and\n    don't start with an underscore.\n    @return module names\n    @rtype: iterator of string\n    \"\"\"\n    for fname in os.listdir(folder):\n        if fname.endswith('.py') and not fname.startswith('_'):\n            fullname = os.path.join(folder, fname)\n            if check_writable_by_others(fullname):\n                print(\"ERROR: refuse to load module from world writable file %r\" % fullname)\n            else:\n                yield fname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_plugins(modules, classes):\n    for module in modules:\n        for plugin in get_module_plugins(module, classes):\n            yield plugin", "response": "Find all given classes in all modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ftpparse (line):\n    if len(line) < 2:\n        # an empty name in EPLF, with no info, could be 2 chars\n        return None\n    info = dict(name=None, trycwd=False, tryretr=False)\n\n    # EPLF format\n    # http://pobox.com/~djb/proto/eplf.html\n    # \"+i8388621.29609,m824255902,/,\\tdev\"\n    # \"+i8388621.44468,m839956783,r,s10376,\\tRFCEPLF\"\n    if line[0] == '+':\n        if '\\t' in line:\n            flags, name = line.split('\\t', 1)\n            info['name'] = name\n            flags = flags.split(',')\n            info['trycwd'] = '/' in flags\n            info['tryretr'] = 'r' in flags\n        return info\n\n    # UNIX-style listing, without inum and without blocks\n    # \"-rw-r--r--   1 root     other        531 Jan 29 03:26 README\"\n    # \"dr-xr-xr-x   2 root     other        512 Apr  8  1994 etc\"\n    # \"dr-xr-xr-x   2 root     512 Apr  8  1994 etc\"\n    # \"lrwxrwxrwx   1 root     other          7 Jan 25 00:17 bin -> usr/bin\"\n    # Also produced by Microsoft's FTP servers for Windows:\n    # \"----------   1 owner    group         1803128 Jul 10 10:18 ls-lR.Z\"\n    # \"d---------   1 owner    group               0 May  9 19:45 Softlib\"\n    # Also WFTPD for MSDOS:\n    # \"-rwxrwxrwx   1 noone    nogroup      322 Aug 19  1996 message.ftp\"\n    # Also NetWare:\n    # \"d [R----F--] supervisor            512       Jan 16 18:53    login\"\n    # \"- [R----F--] rhesus             214059       Oct 20 15:27    cx.exe\"\n    # Also NetPresenz for the Mac:\n    # \"-------r--         326  1391972  1392298 Nov 22  1995 MegaPhone.sit\"\n    # \"drwxrwxr-x               folder        2 May 10  1996 network\"\n    if line[0] in 'bcdlps-':\n        if line[0] == 'd':\n            info['trycwd'] = True\n        if line[0] == '-':\n            info['tryretr'] = True\n        if line[0] == 'l':\n            info['trycwd'] = info['tryretr'] = True\n        parts = line.split()\n        if len(parts) < 7:\n            return None\n        del parts[0] # skip permissions\n        if parts[0] != 'folder':\n            del parts[0] # skip nlink\n        del parts[0] # skip uid\n        del parts[0] # skip gid or size\n        if not ismonth(parts[0]):\n            del parts[0] # skip size\n        if not ismonth(parts[0]):\n            return None\n        del parts[0] # skip month\n        del parts[0] # skip day\n        if not parts:\n            return None\n        del parts[0] # skip year or time\n        name = \" \".join(parts)\n        # resolve links\n        if line[0] == 'l' and ' -> ' in name:\n            name = name.split(' -> ', 1)[1]\n        # eliminate extra NetWare spaces\n        if line[1] in ' [' and name.startswith('   '):\n            name = name[3:]\n        info[\"name\"] = name\n        return info\n\n    # MultiNet (some spaces removed from examples)\n    # \"00README.TXT;1      2 30-DEC-1996 17:44 [SYSTEM] (RWED,RWED,RE,RE)\"\n    # \"CORE.DIR;1          1  8-SEP-1996 16:09 [SYSTEM] (RWE,RWE,RE,RE)\"\n    # and non-MutliNet VMS:\n    # \"CII-MANUAL.TEX;1  213/216  29-JAN-1996 03:33:12  [ANONYMOU,ANONYMOUS]   (RWED,RWED,,)\"\n    i = line.find(';')\n    if i != -1:\n        name = line[:i]\n        if name.endswith(\".DIR\"):\n            name = name[:-4]\n            info[\"trycwd\"] = True\n        else:\n            info[\"tryretr\"] = True\n        info[\"name\"] = name\n        return info\n\n    # MSDOS format\n    # 04-27-00  09:09PM       <DIR>          licensed\n    # 07-18-00  10:16AM       <DIR>          pub\n    # 04-14-00  03:47PM                  589 readme.htm\n    if line[0].isdigit():\n        parts = line.split()\n        if len(parts) != 4:\n            return None\n        info['name'] = parts[3]\n        if parts[2][0] == '<':\n            info['trycwd'] = True\n        else:\n            info['tryretr'] = True\n        return info\n\n    # Some useless lines, safely ignored:\n    # \"Total of 11 Files, 10966 Blocks.\" (VMS)\n    # \"total 14786\" (UNIX)\n    # \"DISK$ANONFTP:[ANONYMOUS]\" (VMS)\n    # \"Directory DISK$PCSA:[ANONYM]\" (VMS)\n    return None", "response": "Parse a single line of FTP list into a dictionary with attributes name flags and contents of the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_lock (name, debug=False):\n    lock = threading.Lock()\n    # for thread debugging, use the DebugLock wrapper\n    if debug:\n        lock = DebugLock(lock, name)\n    return lock", "response": "Get a new lock."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_semaphore(name, value=None, debug=False):\n    if value is None:\n        lock = threading.Semaphore()\n    else:\n        lock = threading.BoundedSemaphore(value)\n    if debug:\n        lock = DebugLock(lock, name)\n    return lock", "response": "Get a new semaphore."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_multiline (value):\n    for line in value.splitlines():\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        yield line", "response": "Helper function reading multiline values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read (self, files):\n        assert isinstance(files, list), \"Invalid file list %r\" % files\n        try:\n            self.read_ok = super(LCConfigParser, self).read(files)\n            if len(self.read_ok) < len(files):\n                failed_files = set(files) - set(self.read_ok)\n                log.warn(LOG_CHECK, \"Could not read configuration files %s.\", failed_files)\n            # Read all the configuration parameters from the given files.\n            self.read_checking_config()\n            self.read_authentication_config()\n            self.read_filtering_config()\n            self.read_output_config()\n            self.read_plugin_config()\n        except Exception as msg:\n            raise LinkCheckerError(\n              _(\"Error parsing configuration: %s\") % unicode(msg))", "response": "Read settings from given config files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a string option.", "response": "def read_string_option (self, section, option, allowempty=False):\n        \"\"\"Read a string option.\"\"\"\n        if self.has_option(section, option):\n            value = self.get(section, option)\n            if not allowempty and not value:\n                raise LinkCheckerError(_(\"invalid empty value for %s: %s\\n\") % (option, value))\n            self.config[option] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread a boolean option.", "response": "def read_boolean_option(self, section, option):\n        \"\"\"Read a boolean option.\"\"\"\n        if self.has_option(section, option):\n            self.config[option] = self.getboolean(section, option)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_int_option (self, section, option, key=None, min=None, max=None):\n        if self.has_option(section, option):\n            num = self.getint(section, option)\n            if min is not None and num < min:\n                raise LinkCheckerError(\n                    _(\"invalid value for %s: %d must not be less than %d\") % (option, num, min))\n            if max is not None and num < max:\n                raise LinkCheckerError(\n                    _(\"invalid value for %s: %d must not be greater than %d\") % (option, num, max))\n            if key is None:\n                key = option\n            self.config[key] = num", "response": "Read an integer option."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_output_config (self):\n        section = \"output\"\n        from ..logger import LoggerClasses\n        for c in LoggerClasses:\n            key = c.LoggerName\n            if self.has_section(key):\n                for opt in self.options(key):\n                    self.config[key][opt] = self.get(key, opt)\n                if self.has_option(key, 'parts'):\n                    val = self.get(key, 'parts')\n                    parts = [f.strip().lower() for f in val.split(',')]\n                    self.config[key]['parts'] = parts\n        self.read_boolean_option(section, \"warnings\")\n        if self.has_option(section, \"verbose\"):\n            if self.getboolean(section, \"verbose\"):\n                self.config[\"verbose\"] = True\n                self.config[\"warnings\"] = True\n        if self.has_option(section, \"quiet\"):\n            if self.getboolean(section, \"quiet\"):\n                self.config['output'] = 'none'\n                self.config['quiet'] = True\n        if self.has_option(section, \"debug\"):\n            val = self.get(section, \"debug\")\n            parts = [f.strip().lower() for f in val.split(',')]\n            logconf.set_debug(parts)\n        self.read_boolean_option(section, \"status\")\n        if self.has_option(section, \"log\"):\n            val = self.get(section, \"log\").strip().lower()\n            self.config['output'] = val\n        if self.has_option(section, \"fileoutput\"):\n            loggers = self.get(section, \"fileoutput\").split(\",\")\n            # strip names from whitespace\n            loggers = (x.strip().lower() for x in loggers)\n            # no file output for the blacklist and none Logger\n            from ..logger import LoggerNames\n            loggers = (x for x in loggers if x in LoggerNames and\n                       x not in (\"blacklist\", \"none\"))\n            for val in loggers:\n                output = self.config.logger_new(val, fileoutput=1)\n                self.config['fileoutput'].append(output)", "response": "Read configuration options in section output."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_checking_config (self):\n        section = \"checking\"\n        self.read_int_option(section, \"threads\", min=-1)\n        self.config['threads'] = max(0, self.config['threads'])\n        self.read_int_option(section, \"timeout\", min=1)\n        self.read_int_option(section, \"aborttimeout\", min=1)\n        self.read_int_option(section, \"recursionlevel\", min=-1)\n        self.read_string_option(section, \"nntpserver\")\n        self.read_string_option(section, \"useragent\")\n        self.read_int_option(section, \"maxrequestspersecond\", min=1)\n        self.read_int_option(section, \"maxnumurls\", min=0)\n        self.read_int_option(section, \"maxfilesizeparse\", min=1)\n        self.read_int_option(section, \"maxfilesizedownload\", min=1)\n        if self.has_option(section, \"allowedschemes\"):\n            self.config['allowedschemes'] = [x.strip().lower() for x in \\\n                 self.get(section, 'allowedschemes').split(',')]\n        self.read_boolean_option(section, \"debugmemory\")\n        self.read_string_option(section, \"cookiefile\")\n        self.read_string_option(section, \"localwebroot\")\n        try:\n            self.read_boolean_option(section, \"sslverify\")\n        except ValueError:\n            self.read_string_option(section, \"sslverify\")\n        self.read_int_option(section, \"maxrunseconds\", min=0)", "response": "Read configuration options in section checking."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_authentication_config (self):\n        section = \"authentication\"\n        password_fields = []\n        if self.has_option(section, \"entry\"):\n            for val in read_multiline(self.get(section, \"entry\")):\n                auth = val.split()\n                if len(auth) == 3:\n                    self.config.add_auth(pattern=auth[0], user=auth[1],\n                                         password=auth[2])\n                    password_fields.append(\"entry/%s/%s\" % (auth[0], auth[1]))\n                elif len(auth) == 2:\n                    self.config.add_auth(pattern=auth[0], user=auth[1])\n                else:\n                    raise LinkCheckerError(\n                       _(\"missing auth part in entry %(val)r\") % {\"val\": val})\n        # read login URL and field names\n        if self.has_option(section, \"loginurl\"):\n            val = self.get(section, \"loginurl\").strip()\n            if not (val.lower().startswith(\"http:\") or\n                    val.lower().startswith(\"https:\")):\n                raise LinkCheckerError(_(\"invalid login URL `%s'. Only \" \\\n                  \"HTTP and HTTPS URLs are supported.\") % val)\n            self.config[\"loginurl\"] = val\n        self.read_string_option(section, \"loginuserfield\")\n        self.read_string_option(section, \"loginpasswordfield\")\n        # read login extra fields\n        if self.has_option(section, \"loginextrafields\"):\n            for val in read_multiline(self.get(section, \"loginextrafields\")):\n                name, value = val.split(\":\", 1)\n                self.config[\"loginextrafields\"][name] = value\n        self.check_password_readable(section, password_fields)", "response": "Read configuration options in section authentication."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_password_readable(self, section, fields):\n        if not fields:\n            return\n        # The information which of the  configuration files\n        # included which option is not available. To avoid false positives,\n        # a warning is only printed if exactly one file has been read.\n        if len(self.read_ok) != 1:\n            return\n        fn = self.read_ok[0]\n        if fileutil.is_accessable_by_others(fn):\n            log.warn(LOG_CHECK, \"The configuration file %s contains password information (in section [%s] and options %s) and the file is readable by others. Please make the file only readable by you.\", fn, section, fields)\n            if os.name == 'posix':\n                log.warn(LOG_CHECK, _(\"For example execute 'chmod go-rw %s'.\") % fn)\n            elif os.name == 'nt':\n                log.warn(LOG_CHECK, _(\"See http://support.microsoft.com/kb/308419 for more info on setting file permissions.\"))", "response": "Check if there is a readable configuration file and print a warning."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading configuration options in section filtering.", "response": "def read_filtering_config (self):\n        \"\"\"\n        Read configuration options in section \"filtering\".\n        \"\"\"\n        section = \"filtering\"\n        if self.has_option(section, \"ignorewarnings\"):\n            self.config['ignorewarnings'] = [f.strip().lower() for f in \\\n                 self.get(section, 'ignorewarnings').split(',')]\n        if self.has_option(section, \"ignore\"):\n            for line in read_multiline(self.get(section, \"ignore\")):\n                pat = get_link_pat(line, strict=1)\n                self.config[\"externlinks\"].append(pat)\n        if self.has_option(section, \"nofollow\"):\n            for line in read_multiline(self.get(section, \"nofollow\")):\n                pat = get_link_pat(line, strict=0)\n                self.config[\"externlinks\"].append(pat)\n        if self.has_option(section, \"internlinks\"):\n            pat = get_link_pat(self.get(section, \"internlinks\"))\n            self.config[\"internlinks\"].append(pat)\n        self.read_boolean_option(section, \"checkextern\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread plugin - specific configuration values.", "response": "def read_plugin_config(self):\n        \"\"\"Read plugin-specific configuration values.\"\"\"\n        folders = self.config[\"pluginfolders\"]\n        modules = plugins.get_plugin_modules(folders)\n        for pluginclass in plugins.get_plugin_classes(modules):\n            section = pluginclass.__name__\n            if self.has_section(section):\n                self.config[\"enabledplugins\"].append(section)\n                self.config[section] = pluginclass.read_config(self)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check(self, url_data):\n        log.debug(LOG_PLUGIN, \"checking content for warning regex\")\n        content = url_data.get_content()\n        # add warnings for found matches, up to the maximum allowed number\n        match = self.warningregex.search(content)\n        if match:\n            # calculate line number for match\n            line = content.count('\\n', 0, match.start())\n            # add a warning message\n            msg = _(\"Found %(match)r at line %(line)d in link contents.\")\n            url_data.add_warning(msg % {\"match\": match.group(), \"line\": line})", "response": "Check content for warning regex."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread configuration file options.", "response": "def read_config(cls, configparser):\n        \"\"\"Read configuration file options.\"\"\"\n        config = dict()\n        section = cls.__name__\n        option = \"warningregex\"\n        if configparser.has_option(section, option):\n            value = configparser.get(section, option)\n        else:\n            value = None\n        config[option] = value\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntruncate the output buffer at offset I{where and remove any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS any ArcGIS entries that pointed beyond the truncation ArcGIS.", "response": "def _rollback(self, where):\n        \"\"\"Truncate the output buffer at offset I{where}, and remove any\n        compression table entries that pointed beyond the truncation\n        point.\n\n        @param where: the offset\n        @type where: int\n        \"\"\"\n\n        self.output.seek(where)\n        self.output.truncate()\n        keys_to_delete = []\n        for k, v in self.compress.iteritems():\n            if v >= where:\n                keys_to_delete.append(k)\n        for k in keys_to_delete:\n            del self.compress[k]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _set_section(self, section):\n\n        if self.section != section:\n            if self.section > section:\n                raise dns.exception.FormError\n            self.section = section", "response": "Set the renderer s current section."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_question(self, qname, rdtype, rdclass=dns.rdataclass.IN):\n\n        self._set_section(QUESTION)\n        before = self.output.tell()\n        qname.to_wire(self.output, self.compress, self.origin)\n        self.output.write(struct.pack(\"!HH\", rdtype, rdclass))\n        after = self.output.tell()\n        if after >= self.max_size:\n            self._rollback(before)\n            raise dns.exception.TooBig\n        self.counts[QUESTION] += 1", "response": "Add a question to the message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_rrset(self, section, rrset, **kw):\n\n        self._set_section(section)\n        before = self.output.tell()\n        n = rrset.to_wire(self.output, self.compress, self.origin, **kw)\n        after = self.output.tell()\n        if after >= self.max_size:\n            self._rollback(before)\n            raise dns.exception.TooBig\n        self.counts[section] += n", "response": "Add the rrset to the specified section."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the specified rdataset to the specified section.", "response": "def add_rdataset(self, section, name, rdataset, **kw):\n        \"\"\"Add the rdataset to the specified section, using the specified\n        name as the owner name.\n\n        Any keyword arguments are passed on to the rdataset's to_wire()\n        routine.\n\n        @param section: the section\n        @type section: int\n        @param name: the owner name\n        @type name: dns.name.Name object\n        @param rdataset: the rdataset\n        @type rdataset: dns.rdataset.Rdataset object\n        \"\"\"\n\n        self._set_section(section)\n        before = self.output.tell()\n        n = rdataset.to_wire(name, self.output, self.compress, self.origin,\n                             **kw)\n        after = self.output.tell()\n        if after >= self.max_size:\n            self._rollback(before)\n            raise dns.exception.TooBig\n        self.counts[section] += n"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_edns(self, edns, ednsflags, payload, options=None):\n\n        # make sure the EDNS version in ednsflags agrees with edns\n        ednsflags &= 0xFF00FFFFL\n        ednsflags |= (edns << 16)\n        self._set_section(ADDITIONAL)\n        before = self.output.tell()\n        self.output.write(struct.pack('!BHHIH', 0, dns.rdatatype.OPT, payload,\n                                      ednsflags, 0))\n        if not options is None:\n            lstart = self.output.tell()\n            for opt in options:\n                stuff = struct.pack(\"!HH\", opt.otype, 0)\n                self.output.write(stuff)\n                start = self.output.tell()\n                opt.to_wire(self.output)\n                end = self.output.tell()\n                assert end - start < 65536\n                self.output.seek(start - 2)\n                stuff = struct.pack(\"!H\", end - start)\n                self.output.write(stuff)\n                self.output.seek(0, 2)\n            lend = self.output.tell()\n            assert lend - lstart < 65536\n            self.output.seek(lstart - 2)\n            stuff = struct.pack(\"!H\", lend - lstart)\n            self.output.write(stuff)\n            self.output.seek(0, 2)\n        after = self.output.tell()\n        if after >= self.max_size:\n            self._rollback(before)\n            raise dns.exception.TooBig\n        self.counts[ADDITIONAL] += 1", "response": "Add an EDNS OPT record to the message."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a TSIG signature to the message.", "response": "def add_tsig(self, keyname, secret, fudge, id, tsig_error, other_data,\n                 request_mac, algorithm=dns.tsig.default_algorithm):\n        \"\"\"Add a TSIG signature to the message.\n\n        @param keyname: the TSIG key name\n        @type keyname: dns.name.Name object\n        @param secret: the secret to use\n        @type secret: string\n        @param fudge: TSIG time fudge\n        @type fudge: int\n        @param id: the message id to encode in the tsig signature\n        @type id: int\n        @param tsig_error: TSIG error code; default is 0.\n        @type tsig_error: int\n        @param other_data: TSIG other data.\n        @type other_data: string\n        @param request_mac: This message is a response to the request which\n        had the specified MAC.\n        @type request_mac: string\n        @param algorithm: the TSIG algorithm to use\n        @type algorithm: dns.name.Name object\n        \"\"\"\n\n        self._set_section(ADDITIONAL)\n        before = self.output.tell()\n        s = self.output.getvalue()\n        (tsig_rdata, self.mac, ctx) = dns.tsig.sign(s,\n                                                    keyname,\n                                                    secret,\n                                                    int(time.time()),\n                                                    fudge,\n                                                    id,\n                                                    tsig_error,\n                                                    other_data,\n                                                    request_mac,\n                                                    algorithm=algorithm)\n        keyname.to_wire(self.output, self.compress, self.origin)\n        self.output.write(struct.pack('!HHIH', dns.rdatatype.TSIG,\n                                      dns.rdataclass.ANY, 0, 0))\n        rdata_start = self.output.tell()\n        self.output.write(tsig_rdata)\n        after = self.output.tell()\n        assert after - rdata_start < 65536\n        if after >= self.max_size:\n            self._rollback(before)\n            raise dns.exception.TooBig\n        self.output.seek(rdata_start - 2)\n        self.output.write(struct.pack('!H', after - rdata_start))\n        self.counts[ADDITIONAL] += 1\n        self.output.seek(10)\n        self.output.write(struct.pack('!H', self.counts[ADDITIONAL]))\n        self.output.seek(0, 2)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the header of the record set.", "response": "def write_header(self):\n        \"\"\"Write the DNS message header.\n\n        Writing the DNS message header is done asfter all sections\n        have been rendered, but before the optional TSIG signature\n        is added.\n        \"\"\"\n\n        self.output.seek(0)\n        self.output.write(struct.pack('!HHHHHH', self.id, self.flags,\n                                      self.counts[0], self.counts[1],\n                                      self.counts[2], self.counts[3]))\n        self.output.seek(0, 2)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef option_from_wire(otype, wire, current, olen):\n\n    cls = get_option_class(otype)\n    return cls.from_wire(otype, wire, current, olen)", "response": "Build an EDNS option object from wire format\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite checking start info as csv comment.", "response": "def start_output (self):\n        \"\"\"Write checking start info as csv comment.\"\"\"\n        super(CSVLogger, self).start_output()\n        row = []\n        if self.has_part(\"intro\"):\n            self.write_intro()\n            self.flush()\n        else:\n            # write empty string to initialize file output\n            self.write(u\"\")\n        self.queue = StringIO()\n        self.writer = csv.writer(self.queue, dialect=self.dialect,\n               delimiter=self.separator, lineterminator=self.linesep,\n               quotechar=self.quotechar)\n        for s in Columns:\n            if self.has_part(s):\n                row.append(s)\n        if row:\n            self.writerow(row)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites url check info.", "response": "def log_url (self, url_data):\n        \"\"\"Write csv formatted url check info.\"\"\"\n        row = []\n        if self.has_part(\"urlname\"):\n            row.append(url_data.base_url)\n        if self.has_part(\"parentname\"):\n            row.append(url_data.parent_url)\n        if self.has_part(\"baseref\"):\n            row.append(url_data.base_ref)\n        if self.has_part(\"result\"):\n            row.append(url_data.result)\n        if self.has_part(\"warningstring\"):\n            row.append(self.linesep.join(x[1] for x in url_data.warnings))\n        if self.has_part(\"infostring\"):\n            row.append(self.linesep.join(url_data.info))\n        if self.has_part(\"valid\"):\n            row.append(url_data.valid)\n        if self.has_part(\"url\"):\n            row.append(url_data.url)\n        if self.has_part(\"line\"):\n            row.append(url_data.line)\n        if self.has_part(\"column\"):\n            row.append(url_data.column)\n        if self.has_part(\"name\"):\n            row.append(url_data.name)\n        if self.has_part(\"dltime\"):\n            row.append(url_data.dltime)\n        if self.has_part(\"dlsize\"):\n            row.append(url_data.size)\n        if self.has_part(\"checktime\"):\n            row.append(url_data.checktime)\n        if self.has_part(\"cached\"):\n            row.append(0)\n        if self.has_part(\"level\"):\n            row.append(url_data.level)\n        if self.has_part(\"modified\"):\n            row.append(self.format_modified(url_data.modified))\n        self.writerow(map(strformat.unicode_safe, row))\n        self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck URLs without threading.", "response": "def check_urls (urlqueue, logger):\n    \"\"\"Check URLs without threading.\"\"\"\n    while not urlqueue.empty():\n        url_data = urlqueue.get()\n        try:\n            check_url(url_data, logger)\n        finally:\n            urlqueue.task_done(url_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks a single URL with logging.", "response": "def check_url(url_data, logger):\n    \"\"\"Check a single URL with logging.\"\"\"\n    if url_data.has_result:\n        logger.log_url(url_data.to_wire())\n    else:\n        cache = url_data.aggregate.result_cache\n        key = url_data.cache_url\n        result = cache.get_result(key)\n        if result is None:\n            # check\n            check_start = time.time()\n            try:\n                url_data.check()\n                do_parse = url_data.check_content()\n                url_data.checktime = time.time() - check_start\n                # Add result to cache\n                result = url_data.to_wire()\n                cache.add_result(key, result)\n                for alias in url_data.aliases:\n                    # redirect aliases\n                    cache.add_result(alias, result)\n                # parse content recursively\n                # XXX this could add new warnings which should be cached.\n                if do_parse:\n                    parser.parse_url(url_data)\n            finally:\n                # close/release possible open connection\n                url_data.close_connection()\n        else:\n            # copy data from cache and adjust it\n            result = copy.copy(result)\n            result.parent_url = url_data.parent_url\n            result.base_ref = url_data.base_ref or u\"\"\n            result.base_url = url_data.base_url or u\"\"\n            result.line = url_data.line\n            result.column = url_data.column\n            result.level = url_data.recursion_level\n            result.name = url_data.name\n        logger.log_url(result)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to get URL data from queue and check it.", "response": "def check_url (self):\n        \"\"\"Try to get URL data from queue and check it.\"\"\"\n        try:\n            url_data = self.urlqueue.get(timeout=QUEUE_POLL_INTERVALL_SECS)\n            if url_data is not None:\n                try:\n                    self.check_url_data(url_data)\n                finally:\n                    self.urlqueue.task_done(url_data)\n                self.setName(self.origname)\n        except urlqueue.Empty:\n            pass\n        except Exception:\n            self.internal_error()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_url_data (self, url_data):\n        if url_data.url is None:\n            url = \"\"\n        else:\n            url = url_data.url.encode(\"ascii\", \"replace\")\n        self.setName(\"CheckThread-%s\" % url)\n        check_url(url_data, self.logger)", "response": "Check one URL data instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nselect a single entry in the cache.", "response": "def _select_for(fd, readable, writable, error, timeout):\n    \"\"\"\n    @param fd: File descriptor (int).\n    @param readable: Whether to wait for readability (bool).\n    @param writable: Whether to wait for writability (bool).\n    @param expiration: Deadline timeout (expiration time, in seconds (float)).\n\n    @return True on success, False on timeout\n    \"\"\"\n    rset, wset, xset = [], [], []\n\n    if readable:\n        rset = [fd]\n    if writable:\n        wset = [fd]\n    if error:\n        xset = [fd]\n\n    if timeout is None:\n        (rcount, wcount, xcount) = select.select(rset, wset, xset)\n    else:\n        (rcount, wcount, xcount) = select.select(rset, wset, xset, timeout)\n\n    return bool((rcount or wcount or xcount))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the response obtained after sending a query via UDP.", "response": "def udp(q, where, timeout=None, port=53, af=None, source=None, source_port=0,\n        ignore_unexpected=False, one_rr_per_rrset=False):\n    \"\"\"Return the response obtained after sending a query via UDP.\n\n    @param q: the query\n    @type q: dns.message.Message\n    @param where: where to send the message\n    @type where: string containing an IPv4 or IPv6 address\n    @param timeout: The number of seconds to wait before the query times out.\n    If None, the default, wait forever.\n    @type timeout: float\n    @param port: The port to which to send the message.  The default is 53.\n    @type port: int\n    @param af: the address family to use.  The default is None, which\n    causes the address family to use to be inferred from the form of of where.\n    If the inference attempt fails, AF_INET is used.\n    @type af: int\n    @rtype: dns.message.Message object\n    @param source: source address.  The default is the IPv4 wildcard address.\n    @type source: string\n    @param source_port: The port from which to send the message.\n    The default is 0.\n    @type source_port: int\n    @param ignore_unexpected: If True, ignore responses from unexpected\n    sources.  The default is False.\n    @type ignore_unexpected: bool\n    @param one_rr_per_rrset: Put each RR into its own RRset\n    @type one_rr_per_rrset: bool\n    \"\"\"\n\n    wire = q.to_wire()\n    if af is None:\n        try:\n            af = dns.inet.af_for_address(where)\n        except Exception:\n            af = dns.inet.AF_INET\n    if af == dns.inet.AF_INET:\n        destination = (where, port)\n        if source is not None:\n            source = (source, source_port)\n    elif af == dns.inet.AF_INET6:\n        destination = (where, port, 0, 0)\n        if source is not None:\n            source = (source, source_port, 0, 0)\n    s = socket.socket(af, socket.SOCK_DGRAM, 0)\n    try:\n        expiration = _compute_expiration(timeout)\n        s.setblocking(0)\n        if source is not None:\n            s.bind(source)\n        _wait_for_writable(s, expiration)\n        s.sendto(wire, destination)\n        while 1:\n            _wait_for_readable(s, expiration)\n            (wire, from_address) = s.recvfrom(65535)\n            if _addresses_equal(af, from_address, destination) or \\\n                    (dns.inet.is_multicast(where) and \\\n                         from_address[1:] == destination[1:]):\n                break\n            if not ignore_unexpected:\n                raise UnexpectedSource('got a response from '\n                                       '%s instead of %s' % (from_address,\n                                                             destination))\n    finally:\n        s.close()\n    r = dns.message.from_wire(wire, keyring=q.keyring, request_mac=q.mac,\n                              one_rr_per_rrset=one_rr_per_rrset)\n    if not q.is_response(r):\n        raise BadResponse\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the specified number of bytes from sock.", "response": "def _net_read(sock, count, expiration):\n    \"\"\"Read the specified number of bytes from sock.  Keep trying until we\n    either get the desired amount, or we hit EOF.\n    A Timeout exception will be raised if the operation is not completed\n    by the expiration time.\n    \"\"\"\n    s = ''\n    while count > 0:\n        _wait_for_readable(sock, expiration)\n        n = sock.recv(count)\n        if n == '':\n            raise EOFError\n        count = count - len(n)\n        s = s + n\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the specified data to the socket.", "response": "def _net_write(sock, data, expiration):\n    \"\"\"Write the specified data to the socket.\n    A Timeout exception will be raised if the operation is not completed\n    by the expiration time.\n    \"\"\"\n    current = 0\n    l = len(data)\n    while current < l:\n        _wait_for_writable(sock, expiration)\n        current += sock.send(data[current:])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the response obtained after sending a TCP query.", "response": "def tcp(q, where, timeout=None, port=53, af=None, source=None, source_port=0,\n        one_rr_per_rrset=False):\n    \"\"\"Return the response obtained after sending a query via TCP.\n\n    @param q: the query\n    @type q: dns.message.Message object\n    @param where: where to send the message\n    @type where: string containing an IPv4 or IPv6 address\n    @param timeout: The number of seconds to wait before the query times out.\n    If None, the default, wait forever.\n    @type timeout: float\n    @param port: The port to which to send the message.  The default is 53.\n    @type port: int\n    @param af: the address family to use.  The default is None, which\n    causes the address family to use to be inferred from the form of of where.\n    If the inference attempt fails, AF_INET is used.\n    @type af: int\n    @rtype: dns.message.Message object\n    @param source: source address.  The default is the IPv4 wildcard address.\n    @type source: string\n    @param source_port: The port from which to send the message.\n    The default is 0.\n    @type source_port: int\n    @param one_rr_per_rrset: Put each RR into its own RRset\n    @type one_rr_per_rrset: bool\n    \"\"\"\n\n    wire = q.to_wire()\n    if af is None:\n        try:\n            af = dns.inet.af_for_address(where)\n        except Exception:\n            af = dns.inet.AF_INET\n    if af == dns.inet.AF_INET:\n        destination = (where, port)\n        if source is not None:\n            source = (source, source_port)\n    elif af == dns.inet.AF_INET6:\n        destination = (where, port, 0, 0)\n        if source is not None:\n            source = (source, source_port, 0, 0)\n    s = socket.socket(af, socket.SOCK_STREAM, 0)\n    try:\n        expiration = _compute_expiration(timeout)\n        s.setblocking(0)\n        if source is not None:\n            s.bind(source)\n        _connect(s, destination)\n\n        l = len(wire)\n\n        # copying the wire into tcpmsg is inefficient, but lets us\n        # avoid writev() or doing a short write that would get pushed\n        # onto the net\n        tcpmsg = struct.pack(\"!H\", l) + wire\n        _net_write(s, tcpmsg, expiration)\n        ldata = _net_read(s, 2, expiration)\n        (l,) = struct.unpack(\"!H\", ldata)\n        wire = _net_read(s, l, expiration)\n    finally:\n        s.close()\n    r = dns.message.from_wire(wire, keyring=q.keyring, request_mac=q.mac,\n                              one_rr_per_rrset=one_rr_per_rrset)\n    if not q.is_response(r):\n        raise BadResponse\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a generator for the responses to a zone transfer.", "response": "def xfr(where, zone, rdtype=dns.rdatatype.AXFR, rdclass=dns.rdataclass.IN,\n        timeout=None, port=53, keyring=None, keyname=None, relativize=True,\n        af=None, lifetime=None, source=None, source_port=0, serial=0,\n        use_udp=False, keyalgorithm=dns.tsig.default_algorithm):\n    \"\"\"Return a generator for the responses to a zone transfer.\n\n    @param where: where to send the message\n    @type where: string containing an IPv4 or IPv6 address\n    @param zone: The name of the zone to transfer\n    @type zone: dns.name.Name object or string\n    @param rdtype: The type of zone transfer.  The default is\n    dns.rdatatype.AXFR.\n    @type rdtype: int or string\n    @param rdclass: The class of the zone transfer.  The default is\n    dns.rdatatype.IN.\n    @type rdclass: int or string\n    @param timeout: The number of seconds to wait for each response message.\n    If None, the default, wait forever.\n    @type timeout: float\n    @param port: The port to which to send the message.  The default is 53.\n    @type port: int\n    @param keyring: The TSIG keyring to use\n    @type keyring: dict\n    @param keyname: The name of the TSIG key to use\n    @type keyname: dns.name.Name object or string\n    @param relativize: If True, all names in the zone will be relativized to\n    the zone origin.  It is essential that the relativize setting matches\n    the one specified to dns.zone.from_xfr().\n    @type relativize: bool\n    @param af: the address family to use.  The default is None, which\n    causes the address family to use to be inferred from the form of of where.\n    If the inference attempt fails, AF_INET is used.\n    @type af: int\n    @param lifetime: The total number of seconds to spend doing the transfer.\n    If None, the default, then there is no limit on the time the transfer may\n    take.\n    @type lifetime: float\n    @rtype: generator of dns.message.Message objects.\n    @param source: source address.  The default is the IPv4 wildcard address.\n    @type source: string\n    @param source_port: The port from which to send the message.\n    The default is 0.\n    @type source_port: int\n    @param serial: The SOA serial number to use as the base for an IXFR diff\n    sequence (only meaningful if rdtype == dns.rdatatype.IXFR).\n    @type serial: int\n    @param use_udp: Use UDP (only meaningful for IXFR)\n    @type use_udp: bool\n    @param keyalgorithm: The TSIG algorithm to use; defaults to\n    dns.tsig.default_algorithm\n    @type keyalgorithm: string\n    \"\"\"\n\n    if isinstance(zone, (str, unicode)):\n        zone = dns.name.from_text(zone)\n    if isinstance(rdtype, (str, unicode)):\n        rdtype = dns.rdatatype.from_text(rdtype)\n    q = dns.message.make_query(zone, rdtype, rdclass)\n    if rdtype == dns.rdatatype.IXFR:\n        rrset = dns.rrset.from_text(zone, 0, 'IN', 'SOA',\n                                    '. . %u 0 0 0 0' % serial)\n        q.authority.append(rrset)\n    if not keyring is None:\n        q.use_tsig(keyring, keyname, algorithm=keyalgorithm)\n    wire = q.to_wire()\n    if af is None:\n        try:\n            af = dns.inet.af_for_address(where)\n        except Exception:\n            af = dns.inet.AF_INET\n    if af == dns.inet.AF_INET:\n        destination = (where, port)\n        if source is not None:\n            source = (source, source_port)\n    elif af == dns.inet.AF_INET6:\n        destination = (where, port, 0, 0)\n        if source is not None:\n            source = (source, source_port, 0, 0)\n    if use_udp:\n        if rdtype != dns.rdatatype.IXFR:\n            raise ValueError('cannot do a UDP AXFR')\n        s = socket.socket(af, socket.SOCK_DGRAM, 0)\n    else:\n        s = socket.socket(af, socket.SOCK_STREAM, 0)\n    s.setblocking(0)\n    if source is not None:\n        s.bind(source)\n    expiration = _compute_expiration(lifetime)\n    _connect(s, destination)\n    l = len(wire)\n    if use_udp:\n        _wait_for_writable(s, expiration)\n        s.send(wire)\n    else:\n        tcpmsg = struct.pack(\"!H\", l) + wire\n        _net_write(s, tcpmsg, expiration)\n    done = False\n    soa_rrset = None\n    soa_count = 0\n    if relativize:\n        origin = zone\n        oname = dns.name.empty\n    else:\n        origin = None\n        oname = zone\n    tsig_ctx = None\n    first = True\n    while not done:\n        mexpiration = _compute_expiration(timeout)\n        if mexpiration is None or mexpiration > expiration:\n            mexpiration = expiration\n        if use_udp:\n            _wait_for_readable(s, expiration)\n            (wire, from_address) = s.recvfrom(65535)\n        else:\n            ldata = _net_read(s, 2, mexpiration)\n            (l,) = struct.unpack(\"!H\", ldata)\n            wire = _net_read(s, l, mexpiration)\n        r = dns.message.from_wire(wire, keyring=q.keyring, request_mac=q.mac,\n                                  xfr=True, origin=origin, tsig_ctx=tsig_ctx,\n                                  multi=True, first=first,\n                                  one_rr_per_rrset=(rdtype==dns.rdatatype.IXFR))\n        tsig_ctx = r.tsig_ctx\n        first = False\n        answer_index = 0\n        delete_mode = False\n        expecting_SOA = False\n        if soa_rrset is None:\n            if not r.answer or r.answer[0].name != oname:\n                raise dns.exception.FormError\n            rrset = r.answer[0]\n            if rrset.rdtype != dns.rdatatype.SOA:\n                raise dns.exception.FormError(\"first RRset is not an SOA\")\n            answer_index = 1\n            soa_rrset = rrset.copy()\n            if rdtype == dns.rdatatype.IXFR:\n                if soa_rrset[0].serial == serial:\n                    #\n                    # We're already up-to-date.\n                    #\n                    done = True\n                else:\n                    expecting_SOA = True\n        #\n        # Process SOAs in the answer section (other than the initial\n        # SOA in the first message).\n        #\n        for rrset in r.answer[answer_index:]:\n            if done:\n                raise dns.exception.FormError(\"answers after final SOA\")\n            if rrset.rdtype == dns.rdatatype.SOA and rrset.name == oname:\n                if expecting_SOA:\n                    if rrset[0].serial != serial:\n                        raise dns.exception.FormError(\"IXFR base serial mismatch\")\n                    expecting_SOA = False\n                elif rdtype == dns.rdatatype.IXFR:\n                    delete_mode = not delete_mode\n                if rrset == soa_rrset and not delete_mode:\n                    done = True\n            elif expecting_SOA:\n                #\n                # We made an IXFR request and are expecting another\n                # SOA RR, but saw something else, so this must be an\n                # AXFR response.\n                #\n                rdtype = dns.rdatatype.AXFR\n                expecting_SOA = False\n        if done and q.keyring and not r.had_tsig:\n            raise dns.exception.FormError(\"missing TSIG\")\n        yield r\n    s.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns path where all profiles of current user are stored.", "response": "def get_profile_dir ():\n    \"\"\"Return path where all profiles of current user are stored.\"\"\"\n    if os.name == 'nt':\n        if \"LOCALAPPDATA\" in os.environ:\n            basedir = unicode(os.environ[\"LOCALAPPDATA\"], nt_filename_encoding)\n        else:\n            # read local appdata directory from registry\n            from ..winutil import get_shell_folder\n            try:\n                basedir = get_shell_folder(\"Local AppData\")\n            except EnvironmentError:\n                basedir = os.path.join(os.environ[\"USERPROFILE\"], \"Local Settings\", \"Application Data\")\n        dirpath = os.path.join(basedir, u\"Google\", u\"Chrome\", u\"User Data\")\n    elif os.name == 'posix':\n        basedir = unicode(os.environ[\"HOME\"])\n        if sys.platform == 'darwin':\n            dirpath = os.path.join(basedir, u\"Library\", u\"Application Support\")\n        else:\n            dirpath = os.path.join(basedir, u\".config\")\n        dirpath = os.path.join(dirpath, u\"Google\", u\"Chrome\")\n    return dirpath"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_text(text):\n\n    value = _by_text.get(text.upper())\n    if value is None:\n        match = _unknown_type_pattern.match(text)\n        if match == None:\n            raise UnknownRdatatype\n        value = int(match.group(1))\n        if value < 0 or value > 65535:\n            raise ValueError(\"type must be between >= 0 and <= 65535\")\n    return value", "response": "Convert text into a DNS rdata type value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntrue if the type is a metatype.", "response": "def is_metatype(rdtype):\n    \"\"\"True if the type is a metatype.\n    @param rdtype: the type\n    @type rdtype: int\n    @rtype: bool\"\"\"\n\n    if rdtype >= TKEY and rdtype <= ANY or rdtype in _metatypes:\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_checked (self):\n        self.start_time = time.time()\n        self.setName(\"Status\")\n        # the first status should be after a second\n        wait_seconds = 1\n        first_wait = True\n        while not self.stopped(wait_seconds):\n            self.log_status()\n            if first_wait:\n                wait_seconds = self.wait_seconds\n                first_wait = False", "response": "Print periodic status messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_status (self):\n        duration = time.time() - self.start_time\n        checked, in_progress, queue = self.aggregator.urlqueue.status()\n        num_urls = len(self.aggregator.result_cache)\n        self.logger.log_status(checked, in_progress, queue, duration, num_urls)", "response": "Log a status message."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_mimedb():\n    global mimedb\n    try:\n        mimedb = mimetypes.MimeTypes(strict=False)\n    except Exception as msg:\n        log.error(LOG_CHECK, \"could not initialize MIME database: %s\" % msg)\n        return\n    # For Opera bookmark files (opera6.adr)\n    add_mimetype(mimedb, 'text/plain', '.adr')\n    # To recognize PHP files as HTML with content check.\n    add_mimetype(mimedb, 'application/x-httpd-php', '.php')\n    # To recognize WML files\n    add_mimetype(mimedb, 'text/vnd.wap.wml', '.wml')", "response": "Initialize the local MIME database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_mimetype(mimedb, mimetype, extension):\n    # If extension is already a common type, strict=True must be used.\n    strict = extension in mimedb.types_map[True]\n    mimedb.add_type(mimetype, extension, strict=strict)", "response": "Add or replace a mimetype to be used with the given extension."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef guess_mimetype (filename, read=None):\n    mime, encoding = None, None\n    if mimedb:\n        mime, encoding = mimedb.guess_type(filename, strict=False)\n    basename = os.path.basename(filename)\n    # Special case for Safari Bookmark files\n    if not mime and basename == 'Bookmarks.plist':\n        return 'application/x-plist+safari'\n    # Special case for Google Chrome Bookmark files.\n    if not mime and basename == 'Bookmarks':\n        mime = 'text/plain'\n    # Some mime types can be differentiated further with content reading.\n    if mime in (\"text/plain\", \"application/xml\", \"text/xml\") and read is not None:\n        read_mime = guess_mimetype_read(read)\n        if read_mime is not None:\n            mime = read_mime\n    if not mime:\n        mime = \"application/octet-stream\"\n    elif \";\" in mime:\n        # split off not needed extension info\n        mime = mime.split(';')[0]\n    return mime.strip().lower()", "response": "Guess MIME type of file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntry to read some content and do a poor man s file ( 1 ).", "response": "def guess_mimetype_read(read):\n    \"\"\"Try to read some content and do a poor man's file(1).\"\"\"\n    mime = None\n    try:\n        data = read()[:70]\n    except Exception:\n        pass\n    else:\n        for cmime, ro in PARSE_CONTENTS.items():\n            if ro.search(data):\n                mime = cmime\n                break\n    return mime"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for a HTML form in the given HTML content that has the given CGI fields.", "response": "def search_form(content, cgiuser, cgipassword, encoding='utf-8'):\n    \"\"\"Search for a HTML form in the given HTML content that has the given\n    CGI fields. If no form is found return None.\n    \"\"\"\n    handler = FormFinder()\n    parser = htmlsax.parser(handler)\n    handler.parser = parser\n    parser.encoding = encoding\n    # parse\n    parser.feed(content)\n    parser.flush()\n    # break cyclic dependencies\n    handler.parser = None\n    parser.handler = None\n    log.debug(LOG_CHECK, \"Found forms %s\", handler.forms)\n    cginames = (cgiuser.lower(), cgipassword.lower())\n    for form in handler.forms:\n        for key, value in form.data.items():\n            if key.lower() in cginames:\n                return form\n    # not found\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndoes nothing override in a subclass.", "response": "def start_element(self, tag, attrs):\n        \"\"\"Does nothing, override in a subclass.\"\"\"\n        if tag == u'form':\n            if u'action' in attrs:\n                url = attrs['action']\n                self.form = Form(url)\n        elif tag == u'input':\n            if self.form:\n                if 'name' in attrs:\n                    key = attrs['name']\n                    value = attrs.get('value')\n                    self.form.add_value(key, value)\n                else:\n                    log.warning(LOG_CHECK, \"nameless form input %s\" % attrs)\n                    pass\n            else:\n                log.warning(LOG_CHECK, \"formless input\u00b4%s\" % attrs)\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for ending form values.", "response": "def end_element(self, tag):\n        \"\"\"search for ending form values.\"\"\"\n        if tag == u'form':\n            self.forms.append(self.form)\n            self.form = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_link_pat (arg, strict=False):\n    log.debug(LOG_CHECK, \"Link pattern %r strict=%s\", arg, strict)\n    if arg.startswith('!'):\n        pattern = arg[1:]\n        negate = True\n    else:\n        pattern = arg\n        negate = False\n    try:\n        regex = re.compile(pattern)\n    except re.error as msg:\n        log.warn(LOG_CHECK, \"invalid regular expression %r: %s\" % (pattern, msg))\n        raise\n    return {\n        \"pattern\": regex,\n        \"negate\": negate,\n        \"strict\": strict,\n    }", "response": "Get a compiled pattern and a negate and strict option."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init_i18n (loc=None):\n    if 'LOCPATH' in os.environ:\n        locdir = os.environ['LOCPATH']\n    else:\n        locdir = os.path.join(get_install_data(), 'share', 'locale')\n    i18n.init(configdata.name.lower(), locdir, loc=loc)\n    # install translated log level names\n    import logging\n    logging.addLevelName(logging.CRITICAL, _('CRITICAL'))\n    logging.addLevelName(logging.ERROR, _('ERROR'))\n    logging.addLevelName(logging.WARN, _('WARN'))\n    logging.addLevelName(logging.WARNING, _('WARNING'))\n    logging.addLevelName(logging.INFO, _('INFO'))\n    logging.addLevelName(logging.DEBUG, _('DEBUG'))\n    logging.addLevelName(logging.NOTSET, _('NOTSET'))", "response": "Initialize i18n with the configured locale dir."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking sure to drop root privileges on POSIX systems.", "response": "def drop_privileges ():\n    \"\"\"Make sure to drop root privileges on POSIX systems.\"\"\"\n    if os.name != 'posix':\n        return\n    if os.geteuid() == 0:\n        log.warn(LOG_CHECK, _(\"Running as root user; \"\n                       \"dropping privileges by changing user to nobody.\"))\n        import pwd\n        os.seteuid(pwd.getpwnam('nobody')[3])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_third_party_modules ():\n    parent = os.path.dirname(os.path.dirname(__file__))\n    third_party = os.path.join(parent, \"third_party\")\n    if os.path.isdir(third_party):\n        sys.path.append(os.path.join(third_party, \"dnspython\"))", "response": "Find third party modules and add them to the python path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_profile_dir ():\n    basedir = unicode(os.environ[\"HOME\"])\n    return os.path.join(basedir, u\"Library\", u\"Safari\")", "response": "Return path where all profiles of current user are stored."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_bookmark_file ():\n    if sys.platform != 'darwin':\n        return u\"\"\n    try:\n        dirname = get_profile_dir()\n        if os.path.isdir(dirname):\n            fname = os.path.join(dirname, u\"Bookmarks.plist\")\n            if os.path.isfile(fname):\n                return fname\n    except Exception:\n        pass\n    return u\"\"", "response": "Return the absolute filename of the bookmark file of the Default profile."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_plist_data_from_file (filename):\n    if has_biplist:\n        return biplist.readPlist(filename)\n    # fall back to normal plistlist\n    try:\n        return plistlib.readPlist(filename)\n    except Exception:\n        # not parseable (eg. not well-formed, or binary)\n        return {}", "response": "Parse plist data for a file. Tries biplist falling back to plistlist\n    plistlib."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses plist data for a string. Tries biplist falling back to plistlist plistlib.", "response": "def get_plist_data_from_string (data):\n    \"\"\"Parse plist data for a string. Tries biplist, falling back to\n    plistlib.\"\"\"\n    if has_biplist:\n        return biplist.readPlistFromString(data)\n    # fall back to normal plistlist\n    try:\n        return plistlib.readPlistFromString(data)\n    except Exception:\n        # not parseable (eg. not well-formed, or binary)\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a XML dictionary entry.", "response": "def parse_plist(entry):\n    \"\"\"Parse a XML dictionary entry.\"\"\"\n    if is_leaf(entry):\n        url = entry[KEY_URLSTRING]\n        title = entry[KEY_URIDICTIONARY].get('title', url)\n        yield (url, title)\n    elif has_children(entry):\n        for child in entry[KEY_CHILDREN]:\n            for item in parse_plist(child):\n                yield item"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef algorithm_from_text(text):\n\n    value = _algorithm_by_text.get(text.upper())\n    if value is None:\n        value = int(text)\n    return value", "response": "Convert text into a DNSSEC algorithm value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a DNSSEC algorithm value to text.", "response": "def algorithm_to_text(value):\n    \"\"\"Convert a DNSSEC algorithm value to text\n    @rtype: string\"\"\"\n\n    text = _algorithm_by_value.get(value)\n    if text is None:\n        text = str(value)\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _validate_rrsig(rrset, rrsig, keys, origin=None, now=None):\n\n    if isinstance(origin, (str, unicode)):\n        origin = dns.name.from_text(origin, dns.name.root)\n\n    key = _find_key(keys, rrsig)\n    if not key:\n        raise ValidationFailure, 'unknown key'\n\n    # For convenience, allow the rrset to be specified as a (name, rdataset)\n    # tuple as well as a proper rrset\n    if isinstance(rrset, tuple):\n        rrname = rrset[0]\n        rdataset = rrset[1]\n    else:\n        rrname = rrset.name\n        rdataset = rrset\n\n    if now is None:\n        now = time.time()\n    if rrsig.expiration < now:\n        raise ValidationFailure, 'expired'\n    if rrsig.inception > now:\n        raise ValidationFailure, 'not yet valid'\n\n    hash = _make_hash(rrsig.algorithm)\n\n    if _is_rsa(rrsig.algorithm):\n        keyptr = key.key\n        (bytes,) = struct.unpack('!B', keyptr[0:1])\n        keyptr = keyptr[1:]\n        if bytes == 0:\n            (bytes,) = struct.unpack('!H', keyptr[0:2])\n            keyptr = keyptr[2:]\n        rsa_e = keyptr[0:bytes]\n        rsa_n = keyptr[bytes:]\n        keylen = len(rsa_n) * 8\n        pubkey = Crypto.PublicKey.RSA.construct(\n            (Crypto.Util.number.bytes_to_long(rsa_n),\n             Crypto.Util.number.bytes_to_long(rsa_e)))\n        sig = (Crypto.Util.number.bytes_to_long(rrsig.signature),)\n    elif _is_dsa(rrsig.algorithm):\n        keyptr = key.key\n        (t,) = struct.unpack('!B', keyptr[0:1])\n        keyptr = keyptr[1:]\n        octets = 64 + t * 8\n        dsa_q = keyptr[0:20]\n        keyptr = keyptr[20:]\n        dsa_p = keyptr[0:octets]\n        keyptr = keyptr[octets:]\n        dsa_g = keyptr[0:octets]\n        keyptr = keyptr[octets:]\n        dsa_y = keyptr[0:octets]\n        pubkey = Crypto.PublicKey.DSA.construct(\n            (Crypto.Util.number.bytes_to_long(dsa_y),\n             Crypto.Util.number.bytes_to_long(dsa_g),\n             Crypto.Util.number.bytes_to_long(dsa_p),\n             Crypto.Util.number.bytes_to_long(dsa_q)))\n        (dsa_r, dsa_s) = struct.unpack('!20s20s', rrsig.signature[1:])\n        sig = (Crypto.Util.number.bytes_to_long(dsa_r),\n               Crypto.Util.number.bytes_to_long(dsa_s))\n    else:\n        raise ValidationFailure, 'unknown algorithm %u' % rrsig.algorithm\n\n    hash.update(_to_rdata(rrsig, origin)[:18])\n    hash.update(rrsig.signer.to_digestable(origin))\n\n    if rrsig.labels < len(rrname) - 1:\n        suffix = rrname.split(rrsig.labels + 1)[1]\n        rrname = dns.name.from_text('*', suffix)\n    rrnamebuf = rrname.to_digestable(origin)\n    rrfixed = struct.pack('!HHI', rdataset.rdtype, rdataset.rdclass,\n                          rrsig.original_ttl)\n    rrlist = sorted(rdataset);\n    for rr in rrlist:\n        hash.update(rrnamebuf)\n        hash.update(rrfixed)\n        rrdata = rr.to_digestable(origin)\n        rrlen = struct.pack('!H', len(rrdata))\n        hash.update(rrlen)\n        hash.update(rrdata)\n\n    digest = hash.digest()\n\n    if _is_rsa(rrsig.algorithm):\n        # PKCS1 algorithm identifier goop\n        digest = _make_algorithm_id(rrsig.algorithm) + digest\n        padlen = keylen // 8 - len(digest) - 3\n        digest = chr(0) + chr(1) + chr(0xFF) * padlen + chr(0) + digest\n    elif _is_dsa(rrsig.algorithm):\n        pass\n    else:\n        # Raise here for code clarity; this won't actually ever happen\n        # since if the algorithm is really unknown we'd already have\n        # raised an exception above\n        raise ValidationFailure, 'unknown algorithm %u' % rrsig.algorithm\n\n    if not pubkey.verify(digest, sig):\n        raise ValidationFailure, 'verify failure'", "response": "Validate an RRset against a single signature."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _validate(rrset, rrsigset, keys, origin=None, now=None):\n\n    if isinstance(origin, (str, unicode)):\n        origin = dns.name.from_text(origin, dns.name.root)\n\n    if isinstance(rrset, tuple):\n        rrname = rrset[0]\n    else:\n        rrname = rrset.name\n\n    if isinstance(rrsigset, tuple):\n        rrsigname = rrsigset[0]\n        rrsigrdataset = rrsigset[1]\n    else:\n        rrsigname = rrsigset.name\n        rrsigrdataset = rrsigset\n\n    rrname = rrname.choose_relativity(origin)\n    rrsigname = rrname.choose_relativity(origin)\n    if rrname != rrsigname:\n        raise ValidationFailure, \"owner names do not match\"\n\n    for rrsig in rrsigrdataset:\n        try:\n            _validate_rrsig(rrset, rrsig, keys, origin, now)\n            return\n        except ValidationFailure, e:\n            pass\n    raise ValidationFailure, \"no RRSIGs validated\"", "response": "Validate an RRset and signature."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nasking robots. txt allowance.", "response": "def allows_url (self, url_data):\n        \"\"\"Ask robots.txt allowance.\"\"\"\n        roboturl = url_data.get_robots_txt_url()\n        with self.get_lock(roboturl):\n            return self._allows_url(url_data, roboturl)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nask robots. txt allowance. Assumes only single thread per robots. txt URL calls this function.", "response": "def _allows_url (self, url_data, roboturl):\n        \"\"\"Ask robots.txt allowance. Assumes only single thread per robots.txt\n        URL calls this function.\"\"\"\n        with cache_lock:\n            if roboturl in self.cache:\n                self.hits += 1\n                rp = self.cache[roboturl]\n                return rp.can_fetch(self.useragent, url_data.url)\n            self.misses += 1\n        kwargs = dict(auth=url_data.auth, session=url_data.session)\n        if hasattr(url_data, \"proxy\") and hasattr(url_data, \"proxy_type\"):\n            kwargs[\"proxies\"] = {url_data.proxytype: url_data.proxy}\n        rp = robotparser2.RobotFileParser(**kwargs)\n        rp.set_url(roboturl)\n        rp.read()\n        with cache_lock:\n            self.cache[roboturl] = rp\n        self.add_sitemap_urls(rp, url_data, roboturl)\n        return rp.can_fetch(self.useragent, url_data.url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_sitemap_urls(self, rp, url_data, roboturl):\n        if not rp.sitemap_urls or not url_data.allows_simple_recursion():\n            return\n        for sitemap_url, line in rp.sitemap_urls:\n            url_data.add_url(sitemap_url, line=line)", "response": "Add sitemap URLs to the url_data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start_output (self):\n        super(HtmlLogger, self).start_output()\n        header = {\n            \"encoding\": self.get_charset_encoding(),\n            \"title\": configuration.App,\n            \"body\": self.colorbackground,\n            \"link\": self.colorlink,\n            \"vlink\": self.colorlink,\n            \"alink\": self.colorlink,\n            \"url\": self.colorurl,\n            \"error\": self.colorerror,\n            \"valid\": self.colorok,\n            \"warning\": self.colorwarning,\n        }\n        self.write(HTML_HEADER % header)\n        self.comment(\"Generated by %s\" % configuration.App)\n        if self.has_part('intro'):\n            self.write(u\"<h2>\"+configuration.App+\n                       \"</h2><br/><blockquote>\"+\n                       configuration.Freeware+\"<br/><br/>\"+\n                       (_(\"Start checking at %s\") %\n                       strformat.strtime(self.starttime))+\n                       os.linesep+\"<br/>\")\n            self.check_date()\n        self.flush()", "response": "Write start of checking info."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_id (self):\n        self.writeln(u\"<tr>\")\n        self.writeln(u'<td>%s</td>' % self.part(\"id\"))\n        self.write(u\"<td>%d</td></tr>\" % self.stats.number)", "response": "Write ID for current URL."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite check statistic infos.", "response": "def write_stats (self):\n        \"\"\"Write check statistic infos.\"\"\"\n        self.writeln(u'<br/><i>%s</i><br/>' % _(\"Statistics\"))\n        if self.stats.number > 0:\n            self.writeln(_(\n              \"Content types: %(image)d image, %(text)d text, %(video)d video, \"\n              \"%(audio)d audio, %(application)d application, %(mail)d mail\"\n              \" and %(other)d other.\") % self.stats.link_types)\n            self.writeln(u\"<br/>\")\n            self.writeln(_(\"URL lengths: min=%(min)d, max=%(max)d, avg=%(avg)d.\") %\n                         dict(min=self.stats.min_url_length,\n                         max=self.stats.max_url_length,\n                         avg=self.stats.avg_url_length))\n        else:\n            self.writeln(_(\"No statistics available since no URLs were checked.\"))\n        self.writeln(u\"<br/>\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites end of check message.", "response": "def write_outro (self):\n        \"\"\"Write end of check message.\"\"\"\n        self.writeln(u\"<br/>\")\n        self.write(_(\"That's it.\")+\" \")\n        if self.stats.number >= 0:\n            self.write(_n(\"%d link checked.\", \"%d links checked.\",\n                       self.stats.number) % self.stats.number)\n            self.write(u\" \")\n        self.write(_n(\"%d warning found\", \"%d warnings found\",\n             self.stats.warnings_printed) % self.stats.warnings_printed)\n        if self.stats.warnings != self.stats.warnings_printed:\n            self.write(_(\" (%d ignored or duplicates not printed)\") %\n                (self.stats.warnings - self.stats.warnings_printed))\n        self.write(u\". \")\n        self.write(_n(\"%d error found\", \"%d errors found\",\n             self.stats.errors_printed) % self.stats.errors_printed)\n        if self.stats.errors != self.stats.errors_printed:\n            self.write(_(\" (%d duplicates not printed)\") %\n                (self.stats.errors - self.stats.errors_printed))\n        self.writeln(u\".\")\n        self.writeln(u\"<br/>\")\n        num = self.stats.internal_errors\n        if num:\n            self.write(_n(\"There was %(num)d internal error.\",\n                \"There were %(num)d internal errors.\", num) % {\"num\": num})\n            self.writeln(u\"<br/>\")\n        self.stoptime = time.time()\n        duration = self.stoptime - self.starttime\n        self.writeln(_(\"Stopped checking at %(time)s (%(duration)s)\") %\n             {\"time\": strformat.strtime(self.stoptime),\n              \"duration\": strformat.strduration_long(duration)})\n        self.writeln(u'</blockquote><br/><hr><small>'+\n                     configuration.HtmlAppInfo+u\"<br/>\")\n        self.writeln(_(\"Get the newest version at %s\") %\n           (u'<a href=\"'+configuration.Url+u'\" target=\"_top\">'+\n            configuration.Url+u\"</a>.<br/>\"))\n        self.writeln(_(\"Write comments and bugs to %s\") %\n           (u'<a href=\"'+configuration.SupportUrl+u'\">'+\n            configuration.SupportUrl+u\"</a>.<br/>\"))\n        self.writeln(_(\"Support this project at %s\") %\n           (u'<a href=\"'+configuration.DonateUrl+u'\">'+\n            configuration.DonateUrl+u\"</a>.\"))\n        self.writeln(u\"</small></body></html>\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef end_output (self, **kwargs):\n        if self.has_part(\"stats\"):\n            self.write_stats()\n        if self.has_part(\"outro\"):\n            self.write_outro()\n        self.close_fileoutput()", "response": "Write end of checking info as HTML."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexpanding an IPv6 address with included :: to num octets.", "response": "def expand_ipv6 (ip, num):\n    \"\"\"\n    Expand an IPv6 address with included :: to num octets.\n\n    @raise: ValueError on invalid IP addresses\n    \"\"\"\n    i = ip.find(\"::\")\n    prefix = ip[:i]\n    suffix = ip[i + 2:]\n    count = prefix.count(\":\") + suffix.count(\":\")\n    if prefix:\n        count += 1\n        prefix = prefix + \":\"\n    if suffix:\n        count += 1\n        suffix = \":\" + suffix\n    if count >= num:\n        raise ValueError(\"invalid ipv6 number: %s\" % ip)\n    fill = (num - count - 1) * \"0:\" + \"0\"\n    return prefix + fill + suffix"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexpand IPv6 addresses to full 6 octets.", "response": "def expand_ip (ip):\n    \"\"\"\n    ipv6 addresses are expanded to full 8 octets, all other\n    addresses are left untouched\n    return a tuple (ip, num) where num==1 if ip is a numeric ip, 0\n    otherwise.\n    \"\"\"\n    if _ipv4_re.match(ip) or \\\n       _ipv6_re.match(ip) or \\\n       _ipv6_ipv4_re.match(ip):\n        return (ip, 1)\n    if _ipv6_abbr_re.match(ip):\n        return (expand_ipv6(ip, 8), 1)\n    if _ipv6_ipv4_abbr_re.match(ip):\n        i = ip.rfind(\":\") + 1\n        return (expand_ipv6(ip[:i], 6) + ip[i:], 1)\n    return (ip, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if given ip is a valid IPv4 address.", "response": "def is_valid_ipv4 (ip):\n    \"\"\"\n    Return True if given ip is a valid IPv4 address.\n    \"\"\"\n    if not _ipv4_re.match(ip):\n        return False\n    a, b, c, d = [int(i) for i in ip.split(\".\")]\n    return a <= 255 and b <= 255 and c <= 255 and d <= 255"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_valid_ipv6 (ip):\n    # XXX this is not complete: check ipv6 and ipv4 semantics too here\n    if not (_ipv6_re.match(ip) or _ipv6_ipv4_re.match(ip) or\n            _ipv6_abbr_re.match(ip) or _ipv6_ipv4_abbr_re.match(ip)):\n        return False\n    return True", "response": "Return True if given ip is a valid IPv6 address."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if given ip is in host or network list.", "response": "def host_in_set (ip, hosts, nets):\n    \"\"\"\n    Return True if given ip is in host or network list.\n    \"\"\"\n    if ip in hosts:\n        return True\n    if is_valid_ipv4(ip):\n        n = dq2num(ip)\n        for net in nets:\n            if dq_in_net(n, net):\n                return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hosts2map (hosts):\n    hostset = set()\n    nets = []\n    for host in hosts:\n        if _host_cidrmask_re.match(host):\n            host, mask = host.split(\"/\")\n            mask = int(mask)\n            if not is_valid_cidrmask(mask):\n                log.error(LOG_CHECK,\n                          \"CIDR mask %d is not a valid network mask\", mask)\n                continue\n            if not is_valid_ipv4(host):\n                log.error(LOG_CHECK, \"host %r is not a valid ip address\", host)\n                continue\n            nets.append(dq2net(host, cidr2mask(mask)))\n        elif _host_netmask_re.match(host):\n            host, mask = host.split(\"/\")\n            if not is_valid_ipv4(host):\n                log.error(LOG_CHECK, \"host %r is not a valid ip address\", host)\n                continue\n            if not is_valid_ipv4(mask):\n                log.error(LOG_CHECK,\n                          \"mask %r is not a valid ip network mask\", mask)\n                continue\n            nets.append(dq2net(host, netmask2mask(mask)))\n        elif is_valid_ip(host):\n            hostset.add(expand_ip(host)[0])\n        else:\n            hostset |= set(resolve_host(host))\n    return (hostset, nets)", "response": "Return a set of named hosts and a list of subnets."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef map2hosts (hostmap):\n    ret = hostmap[0].copy()\n    for net, mask in hostmap[1]:\n        ret.add(\"%s/%d\" % (num2dq(net), mask2netmask(mask)))\n    return ret", "response": "Convert a tuple of hosts networks into a list of hosts."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn set of host names that resolve to given ips.", "response": "def lookup_ips (ips):\n    \"\"\"\n    Return set of host names that resolve to given ips.\n    \"\"\"\n    hosts = set()\n    for ip in ips:\n        try:\n            hosts.add(socket.gethostbyaddr(ip)[0])\n        except socket.error:\n            hosts.add(ip)\n    return hosts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef obfuscate_ip(ip):\n    if is_valid_ipv4(ip):\n        res = \"0x%s\" % \"\".join(hex(int(x))[2:] for x in ip.split(\".\"))\n    else:\n        raise ValueError('Invalid IP value %r' % ip)\n    assert is_obfuscated_ip(res),  '%r obfuscation error' % res\n    return res", "response": "Obfuscate given host in IP form."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check(self, url_data):\n        headers = []\n        for name, value in url_data.headers.items():\n            if name.startswith(self.prefixes):\n                headers.append(name)\n        if headers:\n            items = [u\"%s=%s\" % (name.capitalize(), url_data.headers[name]) for name in headers]\n            info = u\"HTTP headers %s\" % u\", \".join(items)\n            url_data.add_info(info)", "response": "Check content for invalid anchors."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_config(cls, configparser):\n        config = dict()\n        section = cls.__name__\n        option = \"prefixes\"\n        if configparser.has_option(section, option):\n            value = configparser.get(section, option)\n            names = [x.strip().lower() for x in value.split(\",\")]\n        else:\n            names = []\n        config[option] = names\n        return config", "response": "Read configuration file options."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get (self, timeout):\n        if timeout is None:\n            while self._empty():\n                self.not_empty.wait()\n        else:\n            if timeout < 0:\n                raise ValueError(\"'timeout' must be a positive number\")\n            endtime = _time() + timeout\n            while self._empty():\n                remaining = endtime - _time()\n                if remaining <= 0.0:\n                    raise Empty()\n                self.not_empty.wait(remaining)\n        self.in_progress += 1\n        return self.queue.popleft()", "response": "Non thread - safe utility function of the real\n        get method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef put (self, item):\n        with self.mutex:\n            self._put(item)\n            self.not_empty.notify()", "response": "Put an item into the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nput URL in queue increase number of unfished tasks.", "response": "def _put (self, url_data):\n        \"\"\"Put URL in queue, increase number of unfished tasks.\"\"\"\n        if self.shutdown or self.max_allowed_urls == 0:\n            return\n        log.debug(LOG_CACHE, \"queueing %s\", url_data.url)\n        key = url_data.cache_url\n        cache = url_data.aggregate.result_cache\n        if url_data.has_result or cache.has_result(key):\n            self.queue.appendleft(url_data)\n        else:\n            assert key is not None, \"no result for None key: %s\" % url_data\n            if self.max_allowed_urls is not None:\n                self.max_allowed_urls -= 1\n            self.num_puts += 1\n            if self.num_puts >= NUM_PUTS_CLEANUP:\n                self.cleanup()\n            self.queue.append(url_data)\n        self.unfinished_tasks += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cleanup(self):\n        self.num_puts = 0\n        cached = []\n        for i, url_data in enumerate(self.queue):\n            key = url_data.cache_url\n            cache = url_data.aggregate.result_cache\n            if cache.has_result(key):\n                cached.append(i)\n        for pos in cached:\n            self._move_to_top(pos)", "response": "Move cached elements to top."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _move_to_top(self, pos):\n        if pos > 0:\n            self.queue.rotate(-pos)\n            item = self.queue.popleft()\n            self.queue.rotate(pos)\n            self.queue.appendleft(item)", "response": "Move element at given position to top of queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls by Queue consumer threads to indicate that a task is complete.", "response": "def task_done (self, url_data):\n        \"\"\"\n        Indicate that a formerly enqueued task is complete.\n\n        Used by Queue consumer threads.  For each get() used to fetch a task,\n        a subsequent call to task_done() tells the queue that the processing\n        on the task is complete.\n\n        If a join() is currently blocking, it will resume when all items\n        have been processed (meaning that a task_done() call was received\n        for every item that had been put() into the queue).\n\n        Raises a ValueError if called more times than there were items\n        placed in the queue.\n        \"\"\"\n        with self.all_tasks_done:\n            log.debug(LOG_CACHE, \"task_done %s\", url_data.url)\n            self.finished_tasks += 1\n            self.unfinished_tasks -= 1\n            self.in_progress -= 1\n            if self.unfinished_tasks <= 0:\n                if self.unfinished_tasks < 0:\n                    raise ValueError('task_done() called too many times')\n                self.all_tasks_done.notifyAll()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nblocking until all items in the Queue have been retrieved and processed.", "response": "def join (self, timeout=None):\n        \"\"\"Blocks until all items in the Queue have been gotten and processed.\n\n        The count of unfinished tasks goes up whenever an item is added to the\n        queue. The count goes down whenever a consumer thread calls task_done()\n        to indicate the item was retrieved and all work on it is complete.\n\n        When the count of unfinished tasks drops to zero, join() unblocks.\n        \"\"\"\n        with self.all_tasks_done:\n            if timeout is None:\n                while self.unfinished_tasks:\n                    self.all_tasks_done.wait()\n            else:\n                if timeout < 0:\n                    raise ValueError(\"'timeout' must be a positive number\")\n                endtime = _time() + timeout\n                while self.unfinished_tasks:\n                    remaining = endtime - _time()\n                    if remaining <= 0.0:\n                        raise Timeout()\n                    self.all_tasks_done.wait(remaining)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, item):\n        if not item in self.items:\n            self.items.append(item)", "response": "Add an item to the set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake a shallow copy of the set. This method is used to make a shallow copy of the set.", "response": "def _clone(self):\n        \"\"\"Make a (shallow) copy of the set.\n\n        There is a 'clone protocol' that subclasses of this class\n        should use.  To make a copy, first call your super's _clone()\n        method, and use the object returned as the new instance.  Then\n        make shallow copies of the attributes defined in the subclass.\n\n        This protocol allows us to write the set algorithms that\n        return new instances (e.g. union) once, and keep using them in\n        subclasses.\n        \"\"\"\n\n        cls = self.__class__\n        obj = cls.__new__(cls)\n        obj.items = list(self.items)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the set with any elements from other which are not already in the set.", "response": "def union_update(self, other):\n        \"\"\"Update the set, adding any elements from other which are not\n        already in the set.\n        @param other: the collection of items with which to update the set\n        @type other: Set object\n        \"\"\"\n        if not isinstance(other, Set):\n            raise ValueError('other must be a Set instance')\n        if self is other:\n            return\n        for item in other.items:\n            self.add(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef intersection_update(self, other):\n        if not isinstance(other, Set):\n            raise ValueError('other must be a Set instance')\n        if self is other:\n            return\n        # we make a copy of the list so that we can remove items from\n        # the list without breaking the iterator.\n        for item in list(self.items):\n            if item not in other.items:\n                self.items.remove(item)", "response": "Update the set removing any elements from other which are not\n        in both sets."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the set removing any elements from other which are in the set.", "response": "def difference_update(self, other):\n        \"\"\"Update the set, removing any elements from other which are in\n        the set.\n        @param other: the collection of items with which to update the set\n        @type other: Set object\n        \"\"\"\n        if not isinstance(other, Set):\n            raise ValueError('other must be a Set instance')\n        if self is other:\n            self.items = []\n        else:\n            for item in other.items:\n                self.discard(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef union(self, other):\n\n        obj = self._clone()\n        obj.union_update(other)\n        return obj", "response": "Return a new set which is the union of self and other."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new set which is the intersection of self and other.", "response": "def intersection(self, other):\n        \"\"\"Return a new set which is the intersection of I{self} and I{other}.\n\n        @param other: the other set\n        @type other: Set object\n        @rtype: the same type as I{self}\n        \"\"\"\n\n        obj = self._clone()\n        obj.intersection_update(other)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef difference(self, other):\n\n        obj = self._clone()\n        obj.difference_update(other)\n        return obj", "response": "Return a new set which contains the items in self which are not also in other."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef issuperset(self, other):\n\n        if not isinstance(other, Set):\n            raise ValueError('other must be a Set instance')\n        for item in other.items:\n            if not item in self.items:\n                return False\n        return True", "response": "Is I { self}? I { other}? I { other } a superset of I { self }?"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef urljoin (parent, url):\n    if urlutil.url_is_absolute(url):\n        return url\n    return urlparse.urljoin(parent, url)", "response": "Join parent and url."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap for url. url_norm to convert UnicodeError in LinkCheckerError.", "response": "def url_norm (url, encoding=None):\n    \"\"\"Wrapper for url.url_norm() to convert UnicodeError in\n    LinkCheckerError.\"\"\"\n    try:\n        return urlutil.url_norm(url, encoding=encoding)\n    except UnicodeError:\n        msg = _(\"URL has unparsable domain name: %(name)s\") % \\\n            {\"name\": sys.exc_info()[1]}\n        raise LinkCheckerError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reset (self):\n        # self.url is constructed by self.build_url() out of base_url\n        # and (base_ref or parent) as absolute and normed url.\n        # This the real url we use when checking so it also referred to\n        # as 'real url'\n        self.url = None\n        # a splitted version of url for convenience\n        self.urlparts = None\n        # the scheme, host, port and anchor part of url\n        self.scheme = self.host = self.port = self.anchor = None\n        # the result message string and flag\n        self.result = u\"\"\n        self.has_result = False\n        # valid or not\n        self.valid = True\n        # list of warnings (without duplicates)\n        self.warnings = []\n        # list of infos\n        self.info = []\n        # content size\n        self.size = -1\n        # last modification time of content in HTTP-date format as specified in RFC2616 chapter 3.3.1\n        self.modified = None\n        # download time\n        self.dltime = -1\n        # check time\n        self.checktime = 0\n        # connection object\n        self.url_connection = None\n        # data of url content,  (data == None) means no data is available\n        self.data = None\n        # cache url is set by build_url() calling set_cache_url()\n        self.cache_url = None\n        # extern flags (is_extern, is_strict)\n        self.extern = None\n        # flag if the result should be cached\n        self.caching = True\n        # title is either the URL or parsed from content\n        self.title = None\n        # flag if content should be checked or not\n        self.do_check_content = True\n        # MIME content type\n        self.content_type = u\"\"\n        # URLs seen through redirections\n        self.aliases = []", "response": "Reset all variables to default values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset result string and validity.", "response": "def set_result (self, msg, valid=True, overwrite=False):\n        \"\"\"\n        Set result string and validity.\n        \"\"\"\n        if self.has_result and not overwrite:\n            log.warn(LOG_CHECK,\n              \"Double result %r (previous %r) for %s\", msg, self.result, self)\n        else:\n            self.has_result = True\n        if not isinstance(msg, unicode):\n            log.warn(LOG_CHECK, \"Non-unicode result for %s: %r\", self, msg)\n        elif not msg:\n            log.warn(LOG_CHECK, \"Empty result for %s\", self)\n        self.result = msg\n        self.valid = valid\n        # free content data\n        self.data = None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_title (self):\n        if self.title is None:\n            url = u\"\"\n            if self.base_url:\n                url = self.base_url\n            elif self.url:\n                url = self.url\n            self.title = url\n            if \"/\" in url:\n                title = url.rsplit(\"/\", 1)[1]\n                if title:\n                    self.title = title\n        return self.title", "response": "Return title of page the URL refers to. This is per default the filename or the URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _is_ctype(self, ctype):\n        if not self.valid:\n            return False\n        mime = self.content_type\n        return self.ContentMimetypes.get(mime) == ctype", "response": "Return True iff content is valid and of the given type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a warning string.", "response": "def add_warning (self, s, tag=None):\n        \"\"\"\n        Add a warning string.\n        \"\"\"\n        item = (tag, s)\n        if item not in self.warnings and \\\n           tag not in self.aggregate.config[\"ignorewarnings\"]:\n            self.warnings.append(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_info (self, s):\n        if s not in self.info:\n            self.info.append(s)", "response": "Add an info string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_cache_url (self):\n        # remove anchor from cached target url since we assume\n        # URLs with different anchors to have the same content\n        self.cache_url = urlutil.urlunsplit(self.urlparts[:4]+[u''])\n        if self.cache_url is not None:\n            assert isinstance(self.cache_url, unicode), repr(self.cache_url)", "response": "Set the URL to be used for caching."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_syntax (self):\n        log.debug(LOG_CHECK, \"checking syntax\")\n        if self.base_url is None:\n            self.base_url = u\"\"\n        if not (self.base_url or self.parent_url):\n            self.set_result(_(\"URL is empty\"), valid=False)\n            return\n        try:\n            self.build_url()\n            self.check_url_warnings()\n        except tuple(ExcSyntaxList) as msg:\n            self.set_result(unicode_safe(msg), valid=False)\n        else:\n            self.set_cache_url()", "response": "Checks the syntax of the url and sets the result to True if the url is valid."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking URL name and length.", "response": "def check_url_warnings(self):\n        \"\"\"Check URL name and length.\"\"\"\n        effectiveurl = urlutil.urlunsplit(self.urlparts)\n        if self.url != effectiveurl:\n            self.add_warning(_(\"Effective URL %(url)r.\") %\n                             {\"url\": effectiveurl},\n                             tag=WARN_URL_EFFECTIVE_URL)\n            self.url = effectiveurl\n        if len(self.url) > URL_MAX_LENGTH and self.scheme != u\"data\":\n            args = dict(len=len(self.url), max=URL_MAX_LENGTH)\n            self.add_warning(_(\"URL length %(len)d is longer than %(max)d.\") % args, tag=WARN_URL_TOO_LONG)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_url (self):\n        # norm base url - can raise UnicodeError from url.idna_encode()\n        base_url, is_idn = url_norm(self.base_url, self.encoding)\n        # make url absolute\n        if self.base_ref:\n            # use base reference as parent url\n            if \":\" not in self.base_ref:\n                # some websites have a relative base reference\n                self.base_ref = urljoin(self.parent_url, self.base_ref)\n            self.url = urljoin(self.base_ref, base_url)\n        elif self.parent_url:\n            # strip the parent url query and anchor\n            urlparts = list(urlparse.urlsplit(self.parent_url))\n            urlparts[4] = \"\"\n            parent_url = urlutil.urlunsplit(urlparts)\n            self.url = urljoin(parent_url, base_url)\n        else:\n            self.url = base_url\n        # urljoin can unnorm the url path, so norm it again\n        urlparts = list(urlparse.urlsplit(self.url))\n        if urlparts[2]:\n            urlparts[2] = urlutil.collapse_segments(urlparts[2])\n        self.url = urlutil.urlunsplit(urlparts)\n        # split into (modifiable) list\n        self.urlparts = strformat.url_unicode_split(self.url)\n        self.build_url_parts()\n        # and unsplit again\n        self.url = urlutil.urlunsplit(self.urlparts)", "response": "Construct self. url and self. urlparts out of the given base_url parent_url and base_ref."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_url_parts (self):\n        # check userinfo@host:port syntax\n        self.userinfo, host = urllib.splituser(self.urlparts[1])\n        port = urlutil.default_ports.get(self.scheme, 0)\n        host, port = urlutil.splitport(host, port=port)\n        if port is None:\n            raise LinkCheckerError(_(\"URL host %(host)r has invalid port\") %\n                    {\"host\": host})\n        self.port = port\n        # set host lowercase\n        self.host = host.lower()\n        if self.scheme in scheme_requires_host:\n            if not self.host:\n                raise LinkCheckerError(_(\"URL has empty hostname\"))\n            self.check_obfuscated_ip()\n        if not self.port or self.port == urlutil.default_ports.get(self.scheme):\n            host = self.host\n        else:\n            host = \"%s:%d\" % (self.host, self.port)\n        if self.userinfo:\n            self.urlparts[1] = \"%s@%s\" % (self.userinfo, host)\n        else:\n            self.urlparts[1] = host\n        # safe anchor for later checking\n        self.anchor = self.urlparts[4]\n        if self.anchor is not None:\n            assert isinstance(self.anchor, unicode), repr(self.anchor)", "response": "Build the URL parts."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwarns if host of this URL is obfuscated IP address.", "response": "def check_obfuscated_ip (self):\n        \"\"\"Warn if host of this URL is obfuscated IP address.\"\"\"\n        # check if self.host can be an IP address\n        # check for obfuscated IP address\n        if iputil.is_obfuscated_ip(self.host):\n            ips = iputil.resolve_host(self.host)\n            if ips:\n                self.host = ips[0]\n                self.add_warning(\n                   _(\"URL %(url)s has obfuscated IP address %(ip)s\") % \\\n                   {\"url\": self.base_url, \"ip\": ips[0]},\n                          tag=WARN_URL_OBFUSCATED_IP)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef local_check (self):\n        log.debug(LOG_CHECK, \"Checking %s\", unicode(self))\n        # strict extern URLs should not be checked\n        assert not self.extern[1], 'checking strict extern URL'\n        # check connection\n        log.debug(LOG_CHECK, \"checking connection\")\n        try:\n            self.check_connection()\n            self.set_content_type()\n            self.add_size_info()\n            self.aggregate.plugin_manager.run_connection_plugins(self)\n        except tuple(ExcList) as exc:\n            value = self.handle_exception()\n            # make nicer error msg for unknown hosts\n            if isinstance(exc, socket.error) and exc.args[0] == -2:\n                value = _('Hostname not found')\n            elif isinstance(exc, UnicodeError):\n                # idna.encode(host) failed\n                value = _('Bad hostname %(host)r: %(msg)s') % {'host': self.host, 'msg': str(value)}\n            self.set_result(unicode_safe(value), valid=False)", "response": "Local check function can be overridden in subclasses."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks content of URL.", "response": "def check_content(self):\n        \"\"\"Check content of URL.\n        @return: True if content can be parsed, else False\n        \"\"\"\n        if self.do_check_content and self.valid:\n            # check content and recursion\n            try:\n                if self.can_get_content():\n                    self.aggregate.plugin_manager.run_content_plugins(self)\n                if self.allows_recursion():\n                    return True\n            except tuple(ExcList):\n                value = self.handle_exception()\n                self.add_warning(_(\"could not get content: %(msg)s\") %\n                     {\"msg\": str(value)}, tag=WARN_URL_ERROR_GETTING_CONTENT)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef close_connection (self):\n        if self.url_connection is None:\n            # no connection is open\n            return\n        try:\n            self.url_connection.close()\n        except Exception:\n            # ignore close errors\n            pass\n        self.url_connection = None", "response": "Close an opened url connection."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles an exception. Log it and set the cache flag.", "response": "def handle_exception (self):\n        \"\"\"\n        An exception occurred. Log it and set the cache flag.\n        \"\"\"\n        etype, evalue = sys.exc_info()[:2]\n        log.debug(LOG_CHECK, \"Error in %s: %s %s\", self.url, etype, evalue, exception=True)\n        # note: etype must be the exact class, not a subclass\n        if (etype in ExcNoCacheList) or \\\n           (etype == socket.error and evalue.args[0]==errno.EBADF) or \\\n            not evalue:\n            # EBADF occurs when operating on an already socket\n            self.caching = False\n        # format unicode message \"<exception name>: <error message>\"\n        errmsg = unicode(etype.__name__)\n        uvalue = strformat.unicode_safe(evalue)\n        if uvalue:\n            errmsg += u\": %s\" % uvalue\n        # limit length to 240\n        return strformat.limit(errmsg, length=240)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_size_info (self):\n        maxbytes = self.aggregate.config[\"maxfilesizedownload\"]\n        if self.size > maxbytes:\n            self.add_warning(\n              _(\"Content size %(size)s is larger than %(maxbytes)s.\") %\n                  dict(size=strformat.strsize(self.size),\n                       maxbytes=strformat.strsize(maxbytes)),\n                tag=WARN_URL_CONTENT_SIZE_TOO_LARGE)", "response": "Add a warning if the size of the URL content is larger than the maxbytes of the archive."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck recursion level and extern status.", "response": "def allows_simple_recursion(self):\n        \"\"\"Check recursion level and extern status.\"\"\"\n        rec_level = self.aggregate.config[\"recursionlevel\"]\n        if rec_level >= 0 and self.recursion_level >= rec_level:\n            log.debug(LOG_CHECK, \"... no, maximum recursion level reached.\")\n            return False\n        if self.extern[0]:\n            log.debug(LOG_CHECK, \"... no, extern.\")\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True iff we can recurse into the url s content.", "response": "def allows_recursion (self):\n        \"\"\"\n        Return True iff we can recurse into the url's content.\n        \"\"\"\n        log.debug(LOG_CHECK, \"checking recursion of %r ...\", self.url)\n        if not self.valid:\n            log.debug(LOG_CHECK, \"... no, invalid.\")\n            return False\n        if not self.can_get_content():\n            log.debug(LOG_CHECK, \"... no, cannot get content.\")\n            return False\n        if not self.allows_simple_recursion():\n            return False\n        if self.size > self.aggregate.config[\"maxfilesizeparse\"]:\n            log.debug(LOG_CHECK, \"... no, maximum parse size.\")\n            return False\n        if not self.is_parseable():\n            log.debug(LOG_CHECK, \"... no, not parseable.\")\n            return False\n        if not self.content_allows_robots():\n            log.debug(LOG_CHECK, \"... no, robots.\")\n            return False\n        log.debug(LOG_CHECK, \"... yes, recursion.\")\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets self. extern to a tuple with content is_extern and is_strict.", "response": "def set_extern (self, url):\n        \"\"\"\n        Match URL against extern and intern link patterns. If no pattern\n        matches the URL is extern. Sets self.extern to a tuple (bool,\n        bool) with content (is_extern, is_strict).\n\n        @return: None\n        \"\"\"\n        if self.extern:\n            return\n        if not url:\n            self.extern = (1, 1)\n            return\n        for entry in self.aggregate.config[\"externlinks\"]:\n            match = entry['pattern'].search(url)\n            if (entry['negate'] and not match) or \\\n               (match and not entry['negate']):\n                log.debug(LOG_CHECK, \"Extern URL %r\", url)\n                self.extern = (1, entry['strict'])\n                return\n        for entry in self.aggregate.config[\"internlinks\"]:\n            match = entry['pattern'].search(url)\n            if (entry['negate'] and not match) or \\\n               (match and not entry['negate']):\n                log.debug(LOG_CHECK, \"Intern URL %r\", url)\n                self.extern = (0, 0)\n                return\n        if self.aggregate.config['checkextern']:\n            self.extern = (1, 0)\n        else:\n            self.extern = (1, 1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting content of the URL.", "response": "def get_content (self):\n        \"\"\"Precondition: url_connection is an opened URL.\"\"\"\n        if self.data is None:\n            log.debug(LOG_CHECK, \"Get content of %r\", self.url)\n            t = time.time()\n            self.data = self.read_content()\n            self.size = len(self.data)\n            self.dltime = time.time() - t\n            if self.size == 0:\n                self.add_warning(_(\"Content size is zero.\"),\n                             tag=WARN_URL_CONTENT_SIZE_ZERO)\n            else:\n                self.aggregate.add_downloaded_bytes(self.size)\n        return self.data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_content(self):\n        buf = StringIO()\n        data = self.read_content_chunk()\n        while data:\n            if buf.tell() + len(data) > self.aggregate.config[\"maxfilesizedownload\"]:\n                raise LinkCheckerError(_(\"File size too large\"))\n            buf.write(data)\n            data = self.read_content_chunk()\n        return buf.getvalue()", "response": "Return data for this URL. Can be overridden in subclasses."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets user and password from configured authentication.", "response": "def get_user_password (self):\n        \"\"\"Get tuple (user, password) from configured authentication.\n        Both user and password can be None.\n        \"\"\"\n        if self.userinfo:\n            # URL itself has authentication info\n            return urllib.splitpasswd(self.userinfo)\n        return self.aggregate.config.get_user_password(self.url)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding new URL to queue.", "response": "def add_url (self, url, line=0, column=0, page=0, name=u\"\", base=None):\n        \"\"\"Add new URL to queue.\"\"\"\n        if base:\n            base_ref = urlutil.url_norm(base)[0]\n        else:\n            base_ref = None\n        url_data = get_url_from(url, self.recursion_level+1, self.aggregate,\n            parent_url=self.url, base_ref=base_ref, line=line, column=column,\n            page=page, name=name, parent_content_type=self.content_type)\n        self.aggregate.urlqueue.put(url_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns serialized url check data as unicode string.", "response": "def serialized (self, sep=os.linesep):\n        \"\"\"\n        Return serialized url check data as unicode string.\n        \"\"\"\n        return unicode_safe(sep).join([\n            u\"%s link\" % self.scheme,\n            u\"base_url=%r\" % self.base_url,\n            u\"parent_url=%r\" % self.parent_url,\n            u\"base_ref=%r\" % self.base_ref,\n            u\"recursion_level=%d\" % self.recursion_level,\n            u\"url_connection=%s\" % self.url_connection,\n            u\"line=%d\" % self.line,\n            u\"column=%d\" % self.column,\n            u\"page=%d\" % self.page,\n            u\"name=%r\" % self.name,\n            u\"anchor=%r\" % self.anchor,\n            u\"cache_url=%s\" % self.cache_url,\n           ])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_intern_pattern(self, url=None):\n        try:\n            pat = self.get_intern_pattern(url=url)\n            if pat:\n                log.debug(LOG_CHECK, \"Add intern pattern %r\", pat)\n                self.aggregate.config['internlinks'].append(get_link_pat(pat))\n        except UnicodeError as msg:\n            res = _(\"URL has unparsable domain name: %(domain)s\") % \\\n                {\"domain\": msg}\n            self.set_result(res, valid=False)", "response": "Add intern URL regex to config."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a simplified transport object for logging and caching.", "response": "def to_wire_dict (self):\n        \"\"\"Return a simplified transport object for logging and caching.\n\n        The transport object must contain these attributes:\n        - url_data.valid: bool\n          Indicates if URL is valid\n        - url_data.result: unicode\n          Result string\n        - url_data.warnings: list of tuples (tag, warning message)\n          List of tagged warnings for this URL.\n        - url_data.name: unicode string or None\n          name of URL (eg. filename or link name)\n        - url_data.parent_url: unicode or None\n          Parent URL\n        - url_data.base_ref: unicode\n          HTML base reference URL of parent\n        - url_data.url: unicode\n          Fully qualified URL.\n        - url_data.domain: unicode\n          URL domain part.\n        - url_data.checktime: int\n          Number of seconds needed to check this link, default: zero.\n        - url_data.dltime: int\n          Number of seconds needed to download URL content, default: -1\n        - url_data.size: int\n          Size of downloaded URL content, default: -1\n        - url_data.info: list of unicode\n          Additional information about this URL.\n        - url_data.line: int\n          Line number of this URL at parent document, or -1\n        - url_data.column: int\n          Column number of this URL at parent document, or -1\n        - url_data.page: int\n          Page number of this URL at parent document, or -1\n        - url_data.cache_url: unicode\n          Cache url for this URL.\n        - url_data.content_type: unicode\n          MIME content type for URL content.\n        - url_data.level: int\n          Recursion level until reaching this URL from start URL\n        - url_data.last_modified: datetime\n          Last modification date of retrieved page (or None).\n        \"\"\"\n        return dict(valid=self.valid,\n          extern=self.extern[0],\n          result=self.result,\n          warnings=self.warnings[:],\n          name=self.name or u\"\",\n          title=self.get_title(),\n          parent_url=self.parent_url or u\"\",\n          base_ref=self.base_ref or u\"\",\n          base_url=self.base_url or u\"\",\n          url=self.url or u\"\",\n          domain=(self.urlparts[1] if self.urlparts else u\"\"),\n          checktime=self.checktime,\n          dltime=self.dltime,\n          size=self.size,\n          info=self.info,\n          line=self.line,\n          column=self.column,\n          page=self.page,\n          cache_url=self.cache_url,\n          content_type=self.content_type,\n          level=self.recursion_level,\n          modified=self.modified,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite start of checking info as xml comment.", "response": "def xml_start_output (self):\n        \"\"\"\n        Write start of checking info as xml comment.\n        \"\"\"\n        self.writeln(u'<?xml version=\"1.0\" encoding=\"%s\"?>' %\n             xmlquoteattr(self.get_charset_encoding()))\n        if self.has_part(\"intro\"):\n            self.write_intro()\n            self.writeln()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite XML start tag.", "response": "def xml_starttag (self, name, attrs=None):\n        \"\"\"\n        Write XML start tag.\n        \"\"\"\n        self.write(self.indent*self.level)\n        self.write(u\"<%s\" % xmlquote(name))\n        if attrs:\n            for name, value in attrs.items():\n                args = (xmlquote(name), xmlquoteattr(value))\n                self.write(u' %s=\"%s\"' % args)\n        self.writeln(u\">\")\n        self.level += 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xml_endtag (self, name):\n        self.level -= 1\n        assert self.level >= 0\n        self.write(self.indent*self.level)\n        self.writeln(u\"</%s>\" % xmlquote(name))", "response": "Write XML end tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef xml_tag (self, name, content, attrs=None):\n        self.write(self.indent*self.level)\n        self.write(u\"<%s\" % xmlquote(name))\n        if attrs:\n            for aname, avalue in attrs.items():\n                args = (xmlquote(aname), xmlquoteattr(avalue))\n                self.write(u' %s=\"%s\"' % args)\n        self.writeln(u\">%s</%s>\" % (xmlquote(content), xmlquote(name)))", "response": "Write XML tag with content."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a binary string into its hex encoding broken up into chunks of I{chunksize characters separated by a space.", "response": "def _hexify(data, chunksize=None):\n    \"\"\"Convert a binary string into its hex encoding, broken up into chunks\n    of I{chunksize} characters separated by a space.\n\n    @param data: the binary string\n    @type data: string\n    @param chunksize: the chunk size.  Default is L{dns.rdata._hex_chunksize}\n    @rtype: string\n    \"\"\"\n\n    if chunksize is None:\n        chunksize = _hex_chunksize\n    hex = data.encode('hex_codec')\n    l = len(hex)\n    if l > chunksize:\n        chunks = []\n        i = 0\n        while i < l:\n            chunks.append(hex[i : i + chunksize])\n            i += chunksize\n        hex = ' '.join(chunks)\n    return hex"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _base64ify(data, chunksize=None):\n\n    if chunksize is None:\n        chunksize = _base64_chunksize\n    b64 = data.encode('base64_codec')\n    b64 = b64.replace('\\n', '')\n    l = len(b64)\n    if l > chunksize:\n        chunks = []\n        i = 0\n        while i < l:\n            chunks.append(b64[i : i + chunksize])\n            i += chunksize\n        b64 = ' '.join(chunks)\n    return b64", "response": "Convert a binary string into its base64 encoding broken up into chunks\n    of I{chunksize characters separated by a space."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _escapify(qstring):\n\n    text = ''\n    for c in qstring:\n        if c in __escaped:\n            text += '\\\\' + c\n        elif ord(c) >= 0x20 and ord(c) < 0x7F:\n            text += c\n        else:\n            text += '\\\\%03d' % ord(c)\n    return text", "response": "Escape the characters in a quoted string which need it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the index of the greatest byte that isn t all zeros and and return the bitmap that contains all the bytes less than that index.", "response": "def _truncate_bitmap(what):\n    \"\"\"Determine the index of greatest byte that isn't all zeros, and\n    return the bitmap that contains all the bytes less than that index.\n\n    @param what: a string of octets representing a bitmap.\n    @type what: string\n    @rtype: string\n    \"\"\"\n\n    for i in xrange(len(what) - 1, -1, -1):\n        if what[i] != '\\x00':\n            break\n    return ''.join(what[0 : i + 1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an rdata object from text format.", "response": "def from_text(rdclass, rdtype, tok, origin = None, relativize = True):\n    \"\"\"Build an rdata object from text format.\n\n    This function attempts to dynamically load a class which\n    implements the specified rdata class and type.  If there is no\n    class-and-type-specific implementation, the GenericRdata class\n    is used.\n\n    Once a class is chosen, its from_text() class method is called\n    with the parameters to this function.\n\n    @param rdclass: The rdata class\n    @type rdclass: int\n    @param rdtype: The rdata type\n    @type rdtype: int\n    @param tok: The tokenizer\n    @type tok: dns.tokenizer.Tokenizer\n    @param origin: The origin to use for relative names\n    @type origin: dns.name.Name\n    @param relativize: Should names be relativized?\n    @type relativize: bool\n    @rtype: dns.rdata.Rdata instance\"\"\"\n\n    if isinstance(tok, str):\n        tok = dns.tokenizer.Tokenizer(tok)\n    cls = get_rdata_class(rdclass, rdtype)\n    if cls != GenericRdata:\n        # peek at first token\n        token = tok.get()\n        tok.unget(token)\n        if token.is_identifier() and \\\n           token.value == r'\\#':\n            #\n            # Known type using the generic syntax.  Extract the\n            # wire form from the generic syntax, and then run\n            # from_wire on it.\n            #\n            rdata = GenericRdata.from_text(rdclass, rdtype, tok, origin,\n                                           relativize)\n            return from_wire(rdclass, rdtype, rdata.data, 0, len(rdata.data),\n                             origin)\n    return cls.from_text(rdclass, rdtype, tok, origin, relativize)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_wire(rdclass, rdtype, wire, current, rdlen, origin = None):\n\n    wire = dns.wiredata.maybe_wrap(wire)\n    cls = get_rdata_class(rdclass, rdtype)\n    return cls.from_wire(rdclass, rdtype, wire, current, rdlen, origin)", "response": "Build an rdata object from wire format using the specified rdata class and type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking that the current contents of the rdata s fields are valid.", "response": "def validate(self):\n        \"\"\"Check that the current contents of the rdata's fields are\n        valid.  If you change an rdata by assigning to its fields,\n        it is a good idea to call validate() when you are done making\n        changes.\n        \"\"\"\n        dns.rdata.from_text(self.rdclass, self.rdtype, self.to_text())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine if URL entry should be logged or not.", "response": "def do_print (self, url_data):\n        \"\"\"Determine if URL entry should be logged or not.\"\"\"\n        if self.verbose:\n            return True\n        if self.warnings and url_data.warnings:\n            return True\n        return not url_data.valid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend new url to all configured loggers.", "response": "def log_url (self, url_data):\n        \"\"\"Send new url to all configured loggers.\"\"\"\n        self.check_active_loggers()\n        do_print = self.do_print(url_data)\n        # Only send a transport object to the loggers, not the complete\n        # object instance.\n        for log in self.loggers:\n            log.log_filter_url(url_data, do_print)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nquote a HTML attribute to be able to wrap it in double quotes.", "response": "def quote_attrval (s):\n    \"\"\"\n    Quote a HTML attribute to be able to wrap it in double quotes.\n\n    @param s: the attribute string to quote\n    @type s: string\n    @return: the quoted HTML attribute\n    @rtype: string\n    \"\"\"\n    res = []\n    for c in s:\n        if ord(c) <= 127:\n            # ASCII\n            if c == u'&':\n                res.append(u\"&amp;\")\n            elif c == u'\"':\n                res.append(u\"&quot;\")\n            else:\n                res.append(c)\n        else:\n            res.append(u\"&#%d;\" % ord(c))\n    return u\"\".join(res)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint HTML comment. @param data: the comment @type data: string @return: None", "response": "def comment (self, data):\n        \"\"\"\n        Print HTML comment.\n\n        @param data: the comment\n        @type data: string\n        @return: None\n        \"\"\"\n        data = data.encode(self.encoding, \"ignore\")\n        self.fd.write(\"<!--%s-->\" % data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _start_element (self, tag, attrs, end):\n        tag = tag.encode(self.encoding, \"ignore\")\n        self.fd.write(\"<%s\" % tag.replace(\"/\", \"\"))\n        for key, val in attrs.items():\n            key = key.encode(self.encoding, \"ignore\")\n            if val is None:\n                self.fd.write(\" %s\" % key)\n            else:\n                val = val.encode(self.encoding, \"ignore\")\n                self.fd.write(' %s=\"%s\"' % (key, quote_attrval(val)))\n        self.fd.write(end)", "response": "Print HTML element with end string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint HTML end element.", "response": "def end_element (self, tag):\n        \"\"\"\n        Print HTML end element.\n\n        @param tag: tag name\n        @type tag: string\n        @return: None\n        \"\"\"\n        tag = tag.encode(self.encoding, \"ignore\")\n        self.fd.write(\"</%s>\" % tag)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef doctype (self, data):\n        data = data.encode(self.encoding, \"ignore\")\n        self.fd.write(\"<!DOCTYPE%s>\" % data)", "response": "Print HTML document type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pi (self, data):\n        data = data.encode(self.encoding, \"ignore\")\n        self.fd.write(\"<?%s?>\" % data)", "response": "Print HTML pi.\n\n        @param data: the tag data\n        @type data: string\n        @return: None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting HTML cdata. @param data: the character data @type data: string @return: None", "response": "def cdata (self, data):\n        \"\"\"\n        Print HTML cdata.\n\n        @param data: the character data\n        @type data: string\n        @return: None\n        \"\"\"\n        data = data.encode(self.encoding, \"ignore\")\n        self.fd.write(\"<![CDATA[%s]]>\" % data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting the character data to the file descriptor.", "response": "def characters (self, data):\n        \"\"\"\n        Print characters.\n\n        @param data: the character data\n        @type data: string\n        @return: None\n        \"\"\"\n        data = data.encode(self.encoding, \"ignore\")\n        self.fd.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef canonical_clamav_conf ():\n    if os.name == 'posix':\n        clamavconf = \"/etc/clamav/clamd.conf\"\n    elif os.name == 'nt':\n        clamavconf = r\"c:\\clamav-devel\\etc\\clamd.conf\"\n    else:\n        clamavconf = \"clamd.conf\"\n    return clamavconf", "response": "Default clamav configs for various platforms."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns socket. getaddrinfo for given host and port.", "response": "def get_sockinfo (host, port=None):\n    \"\"\"Return socket.getaddrinfo for given host and port.\"\"\"\n    family, socktype = socket.AF_INET, socket.SOCK_STREAM\n    return socket.getaddrinfo(host, port, family, socktype)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nscan data for viruses.", "response": "def scan (data, clamconf):\n    \"\"\"Scan data for viruses.\n    @return (infection msgs, errors)\n    @rtype ([], [])\n    \"\"\"\n    try:\n        scanner = ClamdScanner(clamconf)\n    except socket.error:\n        errmsg = _(\"Could not connect to ClamAV daemon.\")\n        return ([], [errmsg])\n    try:\n        scanner.scan(data)\n    finally:\n        scanner.close()\n    return scanner.infected, scanner.errors"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to ask GeoIP database for country info.", "response": "def check(self, url_data):\n        \"\"\"Try to ask GeoIP database for country info.\"\"\"\n        data = url_data.get_content()\n        infected, errors = scan(data, self.clamav_conf)\n        if infected or errors:\n            for msg in infected:\n                url_data.add_warning(u\"Virus scan infection: %s\" % msg)\n            for msg in errors:\n                url_data.add_warning(u\"Virus scan error: %s\" % msg)\n        else:\n            url_data.add_info(\"No viruses in data found.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a connected socket for sending scan data to it.", "response": "def new_scansock (self):\n        \"\"\"Return a connected socket for sending scan data to it.\"\"\"\n        port = None\n        try:\n            self.sock.sendall(\"STREAM\")\n            port = None\n            for dummy in range(60):\n                data = self.sock.recv(self.sock_rcvbuf)\n                i = data.find(\"PORT\")\n                if i != -1:\n                    port = int(data[i+5:])\n                    break\n        except socket.error:\n            self.sock.close()\n            raise\n        if port is None:\n            raise ClamavError(_(\"clamd is not ready for stream scanning\"))\n        sockinfo = get_sockinfo(self.host, port=port)\n        wsock = create_socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            wsock.connect(sockinfo[0][4])\n        except socket.error:\n            wsock.close()\n            raise\n        return wsock"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close (self):\n        self.wsock.close()\n        data = self.sock.recv(self.sock_rcvbuf)\n        while data:\n            if \"FOUND\\n\" in data:\n                self.infected.append(data)\n            if \"ERROR\\n\" in data:\n                self.errors.append(data)\n            data = self.sock.recv(self.sock_rcvbuf)\n        self.sock.close()", "response": "Get results and close clamd daemon sockets."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses clamav configuration from given file.", "response": "def parseconf (self, filename):\n        \"\"\"Parse clamav configuration from given file.\"\"\"\n        with open(filename) as fd:\n            # yet another config format, sigh\n            for line in fd:\n                line = line.strip()\n                if not line or line.startswith(\"#\"):\n                    # ignore empty lines and comments\n                    continue\n                split = line.split(None, 1)\n                if len(split) == 1:\n                    self[split[0]] = True\n                else:\n                    self[split[0]] = split[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconnects to clamd for stream scanning.", "response": "def new_connection (self):\n        \"\"\"Connect to clamd for stream scanning.\n\n        @return: tuple (connected socket, host)\n        \"\"\"\n        if self.get('LocalSocket'):\n            host = 'localhost'\n            sock = self.create_local_socket()\n        elif self.get('TCPSocket'):\n            host = self.get('TCPAddr', 'localhost')\n            sock = self.create_tcp_socket(host)\n        else:\n            raise ClamavError(_(\"one of TCPSocket or LocalSocket must be enabled\"))\n        return sock, host"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_local_socket (self):\n        sock = create_socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        addr = self['LocalSocket']\n        try:\n            sock.connect(addr)\n        except socket.error:\n            sock.close()\n            raise\n        return sock", "response": "Create local socket connect to it and return socket object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_tcp_socket (self, host):\n        port = int(self['TCPSocket'])\n        sockinfo = get_sockinfo(host, port=port)\n        sock = create_socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.connect(sockinfo[0][4])\n        except socket.error:\n            sock.close()\n            raise\n        return sock", "response": "Create tcp socket connect to it and return socket object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef zonalstats(features, raster, all_touched, band, categorical,\n               indent, info, nodata, prefix, stats, sequence, use_rs):\n    '''zonalstats generates summary statistics of geospatial raster datasets\n    based on vector features.\n\n    The input arguments to zonalstats should be valid GeoJSON Features. (see cligj)\n\n    The output GeoJSON will be mostly unchanged but have additional properties per feature\n    describing the summary statistics (min, max, mean, etc.) of the underlying raster dataset.\n\n    The raster is specified by the required -r/--raster argument.\n\n    Example, calculate rainfall stats for each state and output to file:\n\n    \\b\n       rio zonalstats states.geojson -r rainfall.tif > mean_rainfall_by_state.geojson\n    '''\n\n    if info:\n        logging.basicConfig(level=logging.INFO)\n\n    if stats is not None:\n        stats = stats.split(\" \")\n        if 'all' in [x.lower() for x in stats]:\n            stats = \"ALL\"\n\n    zonal_results = gen_zonal_stats(\n        features,\n        raster,\n        all_touched=all_touched,\n        band=band,\n        categorical=categorical,\n        nodata=nodata,\n        stats=stats,\n        prefix=prefix,\n        geojson_out=True)\n\n    if sequence:\n        for feature in zonal_results:\n            if use_rs:\n                click.echo(b'\\x1e', nl=False)\n            click.echo(json.dumps(feature))\n    else:\n        click.echo(json.dumps(\n            {'type': 'FeatureCollection',\n             'features': list(zonal_results)}))", "response": "zonalstats generates summary statistics of geospatial raster datasets\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pointquery(features, raster, band, indent, nodata,\n               interpolate, property_name, sequence, use_rs):\n    \"\"\"\n    Queries the raster values at the points of the input GeoJSON Features.\n    The raster values are added to the features properties and output as GeoJSON\n    Feature Collection.\n\n    If the Features are Points, the point geometery is used.\n    For other Feauture types, all of the verticies of the geometry will be queried.\n    For example, you can provide a linestring and get the profile along the line\n    if the verticies are spaced properly.\n\n    You can use either bilinear (default) or nearest neighbor interpolation.\n    \"\"\"\n\n    results = gen_point_query(\n        features,\n        raster,\n        band=band,\n        nodata=nodata,\n        interpolate=interpolate,\n        property_name=property_name,\n        geojson_out=True)\n\n    if sequence:\n        for feature in results:\n            if use_rs:\n                click.echo(b'\\x1e', nl=False)\n            click.echo(json.dumps(feature))\n    else:\n        click.echo(json.dumps(\n            {'type': 'FeatureCollection',\n             'features': list(results)}))", "response": "Queries the raster values at the points of the input GeoJSON Features."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bilinear(arr, x, y):\n    # for now, only 2x2 arrays\n    assert arr.shape == (2, 2)\n    ulv, urv, llv, lrv = arr[0:2, 0:2].flatten().tolist()\n\n    # not valid if not on unit square\n    assert 0.0 <= x <= 1.0\n    assert 0.0 <= y <= 1.0\n\n    if hasattr(arr, 'count') and arr.count() != 4:\n        # a masked array with at least one nodata\n        # fall back to nearest neighbor\n        val = arr[int(round(1 - y)), int(round(x))]\n        if val is masked:\n            return None\n        else:\n            return asscalar(val)\n\n    # bilinear interp on unit square\n    return ((llv * (1 - x) * (1 - y)) +\n            (lrv * x * (1 - y)) +\n            (ulv * (1 - x) * y) +\n            (urv * x * y))", "response": "Given a 2x2 array an x and y treat center points as a unit square\n    return the value for the fractional row and colometric tree structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef geom_xys(geom):\n    if geom.has_z:\n        # hack to convert to 2D, https://gist.github.com/ThomasG77/cad711667942826edc70\n        geom = wkt.loads(geom.to_wkt())\n        assert not geom.has_z\n\n    if hasattr(geom, \"geoms\"):\n        geoms = geom.geoms\n    else:\n        geoms = [geom]\n\n    for g in geoms:\n        arr = g.array_interface_base['data']\n        for pair in zip(arr[::2], arr[1::2]):\n            yield pair", "response": "Given a shapely geometry generate a flattened series of 2D points as x y tuples\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gen_point_query(\n    vectors,\n    raster,\n    band=1,\n    layer=0,\n    nodata=None,\n    affine=None,\n    interpolate='bilinear',\n    property_name='value',\n    geojson_out=False):\n    \"\"\"\n    Given a set of vector features and a raster,\n    generate raster values at each vertex of the geometry\n\n    For features with point geometry,\n    the values will be a 1D with the index refering to the feature\n\n    For features with other geometry types,\n    it effectively creates a 2D list, such that\n    the first index is the feature, the second is the vertex within the geometry\n\n    Parameters\n    ----------\n    vectors: path to an vector source or geo-like python objects\n\n    raster: ndarray or path to a GDAL raster source\n        If ndarray is passed, the `transform` kwarg is required.\n\n    layer: int or string, optional\n        If `vectors` is a path to an fiona source,\n        specify the vector layer to use either by name or number.\n        defaults to 0\n\n    band: int, optional\n        If `raster` is a GDAL source, the band number to use (counting from 1).\n        defaults to 1.\n\n    nodata: float, optional\n        If `raster` is a GDAL source, this value overrides any NODATA value\n        specified in the file's metadata.\n        If `None`, the file's metadata's NODATA value (if any) will be used.\n        defaults to `None`.\n\n    affine: Affine instance\n        required only for ndarrays, otherwise it is read from src\n\n    interpolate: string\n        'bilinear' or 'nearest' interpolation\n\n    property_name: string\n        name of property key if geojson_out\n\n    geojson_out: boolean\n        generate GeoJSON-like features (default: False)\n        original feature geometry and properties will be retained\n        point query values appended as additional properties.\n\n    Returns\n    -------\n    generator of arrays (if ``geojson_out`` is False)\n    generator of geojson features (if ``geojson_out`` is True)\n    \"\"\"\n    if interpolate not in ['nearest', 'bilinear']:\n        raise ValueError(\"interpolate must be nearest or bilinear\")\n\n    features_iter = read_features(vectors, layer)\n\n    with Raster(raster, nodata=nodata, affine=affine, band=band) as rast:\n\n        for feat in features_iter:\n            geom = shape(feat['geometry'])\n            vals = []\n            for x, y in geom_xys(geom):\n                if interpolate == 'nearest':\n                    r, c = rast.index(x, y)\n                    window = ((int(r), int(r+1)), (int(c), int(c+1)))\n                    src_array = rast.read(window=window, masked=True).array\n                    val = src_array[0, 0]\n                    if val is masked:\n                        vals.append(None)\n                    else:\n                        vals.append(asscalar(val))\n\n                elif interpolate == 'bilinear':\n                    window, unitxy = point_window_unitxy(x, y, rast.affine)\n                    src_array = rast.read(window=window, masked=True).array\n                    vals.append(bilinear(src_array, *unitxy))\n\n            if len(vals) == 1:\n                vals = vals[0]  # flatten single-element lists\n\n            if geojson_out:\n                if 'properties' not in feat:\n                    feat['properties'] = {}\n                feat['properties'][property_name] = vals\n                yield feat\n            else:\n                yield vals", "response": "Generates a generator of point values at each vertex of the geometry."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rasterize_geom(geom, like, all_touched=False):\n    geoms = [(geom, 1)]\n    rv_array = features.rasterize(\n        geoms,\n        out_shape=like.shape,\n        transform=like.affine,\n        fill=0,\n        dtype='uint8',\n        all_touched=all_touched)\n\n    return rv_array.astype(bool)", "response": "Parameters\n    ----------\n    geom: GeoJSON geometry\n    like: raster object with desired shape and transform\n    all_touched: rasterization strategy\n\n    Returns\n    -------\n    ndarray: boolean"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the key associated with the value returned by func", "response": "def key_assoc_val(d, func, exclude=None):\n    \"\"\"return the key associated with the value returned by func\n    \"\"\"\n    vs = list(d.values())\n    ks = list(d.keys())\n    key = ks[vs.index(func(vs))]\n    return key"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef boxify_points(geom, rast):\n    if 'Point' not in geom.type:\n        raise ValueError(\"Points or multipoints only\")\n\n    buff = -0.01 * abs(min(rast.affine.a, rast.affine.e))\n\n    if geom.type == 'Point':\n        pts = [geom]\n    elif geom.type == \"MultiPoint\":\n        pts = geom.geoms\n    geoms = []\n    for pt in pts:\n        row, col = rast.index(pt.x, pt.y)\n        win = ((row, row + 1), (col, col + 1))\n        geoms.append(box(*window_bounds(win, rast.affine)).buffer(buff))\n\n    return MultiPolygon(geoms)", "response": "Convert points to box polygons 99% cellsize centered on the raster cell\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a python object containing a GeoJSON - like Feature object returns a GeoJSON - like Feature object", "response": "def parse_feature(obj):\n    \"\"\" Given a python object\n    attemp to a GeoJSON-like Feature from it\n    \"\"\"\n\n    # object implementing geo_interface\n    if hasattr(obj, '__geo_interface__'):\n        gi = obj.__geo_interface__\n        if gi['type'] in geom_types:\n            return wrap_geom(gi)\n        elif gi['type'] == 'Feature':\n            return gi\n\n    # wkt\n    try:\n        shape = wkt.loads(obj)\n        return wrap_geom(shape.__geo_interface__)\n    except (ReadingError, TypeError, AttributeError):\n        pass\n\n    # wkb\n    try:\n        shape = wkb.loads(obj)\n        return wrap_geom(shape.__geo_interface__)\n    except (ReadingError, TypeError):\n        pass\n\n    # geojson-like python mapping\n    try:\n        if obj['type'] in geom_types:\n            return wrap_geom(obj)\n        elif obj['type'] == 'Feature':\n            return obj\n    except (AssertionError, TypeError):\n        pass\n\n    raise ValueError(\"Can't parse %s as a geojson Feature object\" % obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting row and col for a x y", "response": "def rowcol(x, y, affine, op=math.floor):\n    \"\"\" Get row/col for a x/y\n    \"\"\"\n    r = int(op((y - affine.f) / affine.e))\n    c = int(op((x - affine.c) / affine.a))\n    return r, c"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a full cover rasterio - style window containing bounds.", "response": "def bounds_window(bounds, affine):\n    \"\"\"Create a full cover rasterio-style window\n    \"\"\"\n    w, s, e, n = bounds\n    row_start, col_start = rowcol(w, n, affine)\n    row_stop, col_stop = rowcol(e, s, affine, op=math.ceil)\n    return (row_start, row_stop), (col_start, col_stop)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef index(self, x, y):\n        col, row = [math.floor(a) for a in (~self.affine * (x, y))]\n        return row, col", "response": "Given ( x y ) in crs return the row and column of the raster"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self, bounds=None, window=None, masked=False):\n        # Calculate the window\n        if bounds and window:\n            raise ValueError(\"Specify either bounds or window\")\n\n        if bounds:\n            win = bounds_window(bounds, self.affine)\n        elif window:\n            win = window\n        else:\n            raise ValueError(\"Specify either bounds or window\")\n\n        c, _, _, f = window_bounds(win, self.affine)  # c ~ west, f ~ north\n        a, b, _, d, e, _, _, _, _ = tuple(self.affine)\n        new_affine = Affine(a, b, c, d, e, f)\n\n        nodata = self.nodata\n        if nodata is None:\n            nodata = -999\n            warnings.warn(\"Setting nodata to -999; specify nodata explicitly\")\n\n        if self.array is not None:\n            # It's an ndarray already\n            new_array = boundless_array(\n                self.array, window=win, nodata=nodata, masked=masked)\n        elif self.src:\n            # It's an open rasterio dataset\n            new_array = self.src.read(\n                self.band, window=win, boundless=True, masked=masked)\n\n        return Raster(new_array, new_affine, nodata)", "response": "Reads the array from the source rasterio array and returns a Raster object with updated array info."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a zonal statistics for a set of raster values.", "response": "def gen_zonal_stats(\n        vectors, raster,\n        layer=0,\n        band=1,\n        nodata=None,\n        affine=None,\n        stats=None,\n        all_touched=False,\n        categorical=False,\n        category_map=None,\n        add_stats=None,\n        zone_func=None,\n        raster_out=False,\n        prefix=None,\n        geojson_out=False, **kwargs):\n    \"\"\"Zonal statistics of raster values aggregated to vector geometries.\n\n    Parameters\n    ----------\n    vectors: path to an vector source or geo-like python objects\n\n    raster: ndarray or path to a GDAL raster source\n        If ndarray is passed, the ``affine`` kwarg is required.\n\n    layer: int or string, optional\n        If `vectors` is a path to an fiona source,\n        specify the vector layer to use either by name or number.\n        defaults to 0\n\n    band: int, optional\n        If `raster` is a GDAL source, the band number to use (counting from 1).\n        defaults to 1.\n\n    nodata: float, optional\n        If `raster` is a GDAL source, this value overrides any NODATA value\n        specified in the file's metadata.\n        If `None`, the file's metadata's NODATA value (if any) will be used.\n        defaults to `None`.\n\n    affine: Affine instance\n        required only for ndarrays, otherwise it is read from src\n\n    stats:  list of str, or space-delimited str, optional\n        Which statistics to calculate for each zone.\n        All possible choices are listed in ``utils.VALID_STATS``.\n        defaults to ``DEFAULT_STATS``, a subset of these.\n\n    all_touched: bool, optional\n        Whether to include every raster cell touched by a geometry, or only\n        those having a center point within the polygon.\n        defaults to `False`\n\n    categorical: bool, optional\n\n    category_map: dict\n        A dictionary mapping raster values to human-readable categorical names.\n        Only applies when categorical is True\n\n    add_stats: dict\n        with names and functions of additional stats to compute, optional\n\n    zone_func: callable\n        function to apply to zone ndarray prior to computing stats\n\n    raster_out: boolean\n        Include the masked numpy array for each feature?, optional\n\n        Each feature dictionary will have the following additional keys:\n        mini_raster_array: The clipped and masked numpy array\n        mini_raster_affine: Affine transformation\n        mini_raster_nodata: NoData Value\n\n    prefix: string\n        add a prefix to the keys (default: None)\n\n    geojson_out: boolean\n        Return list of GeoJSON-like features (default: False)\n        Original feature geometry and properties will be retained\n        with zonal stats appended as additional properties.\n        Use with `prefix` to ensure unique and meaningful property names.\n\n    Returns\n    -------\n    generator of dicts (if geojson_out is False)\n        Each item corresponds to a single vector feature and\n        contains keys for each of the specified stats.\n\n    generator of geojson features (if geojson_out is True)\n        GeoJSON-like Feature as python dict\n    \"\"\"\n    stats, run_count = check_stats(stats, categorical)\n\n    # Handle 1.0 deprecations\n    transform = kwargs.get('transform')\n    if transform:\n        warnings.warn(\"GDAL-style transforms will disappear in 1.0. \"\n                      \"Use affine=Affine.from_gdal(*transform) instead\",\n                      DeprecationWarning)\n        if not affine:\n            affine = Affine.from_gdal(*transform)\n\n    cp = kwargs.get('copy_properties')\n    if cp:\n        warnings.warn(\"Use `geojson_out` to preserve feature properties\",\n                      DeprecationWarning)\n\n    band_num = kwargs.get('band_num')\n    if band_num:\n        warnings.warn(\"Use `band` to specify band number\", DeprecationWarning)\n        band = band_num\n\n    with Raster(raster, affine, nodata, band) as rast:\n        features_iter = read_features(vectors, layer)\n        for _, feat in enumerate(features_iter):\n            geom = shape(feat['geometry'])\n\n            if 'Point' in geom.type:\n                geom = boxify_points(geom, rast)\n\n            geom_bounds = tuple(geom.bounds)\n\n            fsrc = rast.read(bounds=geom_bounds)\n\n            # rasterized geometry\n            rv_array = rasterize_geom(geom, like=fsrc, all_touched=all_touched)\n\n            # nodata mask\n            isnodata = (fsrc.array == fsrc.nodata)\n\n            # add nan mask (if necessary)\n            has_nan = (\n                np.issubdtype(fsrc.array.dtype, np.floating)\n                and np.isnan(fsrc.array.min()))\n            if has_nan:\n                isnodata = (isnodata | np.isnan(fsrc.array))\n\n            # Mask the source data array\n            # mask everything that is not a valid value or not within our geom\n            masked = np.ma.MaskedArray(\n                fsrc.array,\n                mask=(isnodata | ~rv_array))\n\n            # If we're on 64 bit platform and the array is an integer type\n            # make sure we cast to 64 bit to avoid overflow.\n            # workaround for https://github.com/numpy/numpy/issues/8433\n            if sysinfo.platform_bits == 64 and \\\n                    masked.dtype != np.int64 and \\\n                    issubclass(masked.dtype.type, np.integer):\n                masked = masked.astype(np.int64)\n\n            # execute zone_func on masked zone ndarray\n            if zone_func is not None:\n                if not callable(zone_func):\n                    raise TypeError(('zone_func must be a callable '\n                                     'which accepts function a '\n                                     'single `zone_array` arg.'))\n                zone_func(masked)\n\n            if masked.compressed().size == 0:\n                # nothing here, fill with None and move on\n                feature_stats = dict([(stat, None) for stat in stats])\n                if 'count' in stats:  # special case, zero makes sense here\n                    feature_stats['count'] = 0\n            else:\n                if run_count:\n                    keys, counts = np.unique(masked.compressed(), return_counts=True)\n                    pixel_count = dict(zip([np.asscalar(k) for k in keys],\n                                           [np.asscalar(c) for c in counts]))\n\n                if categorical:\n                    feature_stats = dict(pixel_count)\n                    if category_map:\n                        feature_stats = remap_categories(category_map, feature_stats)\n                else:\n                    feature_stats = {}\n\n                if 'min' in stats:\n                    feature_stats['min'] = float(masked.min())\n                if 'max' in stats:\n                    feature_stats['max'] = float(masked.max())\n                if 'mean' in stats:\n                    feature_stats['mean'] = float(masked.mean())\n                if 'count' in stats:\n                    feature_stats['count'] = int(masked.count())\n                # optional\n                if 'sum' in stats:\n                    feature_stats['sum'] = float(masked.sum())\n                if 'std' in stats:\n                    feature_stats['std'] = float(masked.std())\n                if 'median' in stats:\n                    feature_stats['median'] = float(np.median(masked.compressed()))\n                if 'majority' in stats:\n                    feature_stats['majority'] = float(key_assoc_val(pixel_count, max))\n                if 'minority' in stats:\n                    feature_stats['minority'] = float(key_assoc_val(pixel_count, min))\n                if 'unique' in stats:\n                    feature_stats['unique'] = len(list(pixel_count.keys()))\n                if 'range' in stats:\n                    try:\n                        rmin = feature_stats['min']\n                    except KeyError:\n                        rmin = float(masked.min())\n                    try:\n                        rmax = feature_stats['max']\n                    except KeyError:\n                        rmax = float(masked.max())\n                    feature_stats['range'] = rmax - rmin\n\n                for pctile in [s for s in stats if s.startswith('percentile_')]:\n                    q = get_percentile(pctile)\n                    pctarr = masked.compressed()\n                    feature_stats[pctile] = np.percentile(pctarr, q)\n\n            if 'nodata' in stats or 'nan' in stats:\n                featmasked = np.ma.MaskedArray(fsrc.array, mask=(~rv_array))\n\n                if 'nodata' in stats:\n                    feature_stats['nodata'] = float((featmasked == fsrc.nodata).sum())\n                if 'nan' in stats:\n                    feature_stats['nan'] = float(np.isnan(featmasked).sum()) if has_nan else 0\n\n            if add_stats is not None:\n                for stat_name, stat_func in add_stats.items():\n                    feature_stats[stat_name] = stat_func(masked)\n\n            if raster_out:\n                feature_stats['mini_raster_array'] = masked\n                feature_stats['mini_raster_affine'] = fsrc.affine\n                feature_stats['mini_raster_nodata'] = fsrc.nodata\n\n            if prefix is not None:\n                prefixed_feature_stats = {}\n                for key, val in feature_stats.items():\n                    newkey = \"{}{}\".format(prefix, key)\n                    prefixed_feature_stats[newkey] = val\n                feature_stats = prefixed_feature_stats\n\n            if geojson_out:\n                for key, val in feature_stats.items():\n                    if 'properties' not in feat:\n                        feat['properties'] = {}\n                    feat['properties'][key] = val\n                yield feat\n            else:\n                yield feature_stats"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nyield successive n - sized chunks from a slice - able iterable.", "response": "def chunks(data, n):\n    \"\"\"Yield successive n-sized chunks from a slice-able iterable.\"\"\"\n    for i in range(0, len(data), n):\n        yield data[i:i+n]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef request(self, req_mode=0x26):\n        error = True\n        back_bits = 0\n\n        self.dev_write(0x0D, 0x07)\n        (error, back_data, back_bits) = self.card_write(self.mode_transrec, [req_mode, ])\n\n        if error or (back_bits != 0x10):\n            return (True, None)\n\n        return (False, back_bits)", "response": "Request for a tag."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef anticoll(self):\n        back_data = []\n        serial_number = []\n\n        serial_number_check = 0\n\n        self.dev_write(0x0D, 0x00)\n        serial_number.append(self.act_anticl)\n        serial_number.append(0x20)\n\n        (error, back_data, back_bits) = self.card_write(self.mode_transrec, serial_number)\n        if not error:\n            if len(back_data) == 5:\n                for i in range(4):\n                    serial_number_check = serial_number_check ^ back_data[i]\n\n                if serial_number_check != back_data[4]:\n                    error = True\n            else:\n                error = True\n\n        return (error, back_data)", "response": "Anti - collision detection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef select_tag(self, uid):\n        back_data = []\n        buf = []\n\n        buf.append(self.act_select)\n        buf.append(0x70)\n\n        for i in range(5):\n            buf.append(uid[i])\n\n        crc = self.calculate_crc(buf)\n        buf.append(crc[0])\n        buf.append(crc[1])\n\n        (error, back_data, back_length) = self.card_write(self.mode_transrec, buf)\n\n        if (not error) and (back_length == 0x18):\n            return False\n        else:\n            return True", "response": "Select a tag for further usage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nauthenticate to use specified block address.", "response": "def card_auth(self, auth_mode, block_address, key, uid):\n        \"\"\"\n        Authenticates to use specified block address. Tag must be selected using select_tag(uid) before auth.\n        auth_mode -- RFID.auth_a or RFID.auth_b\n        key -- list or tuple with six bytes key\n        uid -- list or tuple with four bytes tag ID\n        Returns error state.\n        \"\"\"\n        buf = []\n        buf.append(auth_mode)\n        buf.append(block_address)\n\n        for i in range(len(key)):\n            buf.append(key[i])\n\n        for i in range(4):\n            buf.append(uid[i])\n\n        (error, back_data, back_length) = self.card_write(self.mode_auth, buf)\n        if not (self.dev_read(0x08) & 0x08) != 0:\n            error = True\n\n        if not error:\n            self.authed = True\n\n        return error"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef halt(self):\n\n        buf = []\n        buf.append(self.act_end)\n        buf.append(0)\n\n        crc = self.calculate_crc(buf)\n        self.clear_bitmask(0x08, 0x80)\n        self.card_write(self.mode_transrec, buf)\n        self.clear_bitmask(0x08, 0x08)\n        self.authed = False", "response": "Switch state to HALT"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads data from the specified block.", "response": "def read(self, block_address):\n        \"\"\"\n        Reads data from block. You should be authenticated before calling read.\n        Returns tuple of (error state, read data).\n        \"\"\"\n        buf = []\n        buf.append(self.act_read)\n        buf.append(block_address)\n        crc = self.calculate_crc(buf)\n        buf.append(crc[0])\n        buf.append(crc[1])\n        (error, back_data, back_length) = self.card_write(self.mode_transrec, buf)\n\n        if len(back_data) != 16:\n            error = True\n\n        return (error, back_data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting data to the block. Returns error state.", "response": "def write(self, block_address, data):\n        \"\"\"\n        Writes data to block. You should be authenticated before calling write.\n        Returns error state.\n        \"\"\"\n        buf = []\n        buf.append(self.act_write)\n        buf.append(block_address)\n        crc = self.calculate_crc(buf)\n        buf.append(crc[0])\n        buf.append(crc[1])\n        (error, back_data, back_length) = self.card_write(self.mode_transrec, buf)\n        if not(back_length == 4) or not((back_data[0] & 0x0F) == 0x0A):\n            error = True\n\n        if not error:\n            buf_w = []\n            for i in range(16):\n                buf_w.append(data[i])\n\n            crc = self.calculate_crc(buf_w)\n            buf_w.append(crc[0])\n            buf_w.append(crc[1])\n            (error, back_data, back_length) = self.card_write(self.mode_transrec, buf_w)\n            if not(back_length == 4) or not((back_data[0] & 0x0F) == 0x0A):\n                error = True\n\n        return error"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the tag for further operations.", "response": "def set_tag(self, uid):\n        \"\"\"\n        Sets tag for further operations.\n        Calls deauth() if card is already set.\n        Calls RFID select_tag().\n        Returns called select_tag() error state.\n        \"\"\"\n        if self.debug:\n            print(\"Selecting UID \" + str(uid))\n\n        if self.uid != None:\n            self.deauth()\n\n        self.uid = uid\n        return self.rfid.select_tag(uid)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef auth(self, auth_method, key):\n        self.method = auth_method\n        self.key = key\n\n        if self.debug:\n            print(\"Changing used auth key to \" + str(key) + \" using method \" + (\"A\" if auth_method == self.rfid.auth_a else \"B\"))", "response": "Sets the authentication info for current tag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting authentication info. Calls stop_crypto()", "response": "def deauth(self):\n        \"\"\"\n        Resets authentication info. Calls stop_crypto() if RFID is in auth state\n        \"\"\"\n        self.method = None\n        self.key = None\n        self.last_auth = None\n\n        if self.debug:\n            print(\"Changing auth key and method to None\")\n\n        if self.rfid.authed:\n            self.rfid.stop_crypto()\n            if self.debug:\n                print(\"Stopping crypto1\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_auth(self, block_address, force=False):\n        auth_data = (block_address, self.method, self.key, self.uid)\n        if (self.last_auth != auth_data) or force:\n            if self.debug:\n                print(\"Calling card_auth on UID \" + str(self.uid))\n\n            self.last_auth = auth_data\n            return self.rfid.card_auth(self.method, block_address, self.key, self.uid)\n        else:\n            if self.debug:\n                print(\"Not calling card_auth - already authed\")\n            return False", "response": "Calls RFID card_auth method with saved auth information if needed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the trailer of the specified sector.", "response": "def write_trailer(self, sector, key_a=(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF), auth_bits=(0xFF, 0x07, 0x80), \n                      user_data=0x69, key_b=(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF)):\n        \"\"\"\n        Writes sector trailer of specified sector. Tag and auth must be set - does auth.\n        If value is None, value of byte is kept.\n        Returns error state.\n        \"\"\"\n        addr = self.block_addr(sector, 3)\n        return self.rewrite(addr, key_a[:6] + auth_bits[:3] + (user_data, ) + key_b[:6])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrewriting the block with new bytes.", "response": "def rewrite(self, block_address, new_bytes):\n        \"\"\"\n        Rewrites block with new bytes, keeping the old ones if None is passed. Tag and auth must be set - does auth.\n        Returns error state.\n        \"\"\"\n        if not self.is_tag_set_auth():\n            return True\n\n        error = self.do_auth(block_address)\n        if not error:\n            (error, data) = self.rfid.read(block_address)\n            if not error:\n                for i in range(len(new_bytes)):\n                    if new_bytes[i] != None:\n                        if self.debug:\n                            print(\"Changing pos \" + str(i) + \" with current value \" + str(data[i]) + \" to \" + str(new_bytes[i]))\n\n                        data[i] = new_bytes[i]\n\n                error = self.rfid.write(block_address, data)\n                if self.debug:\n                    print(\"Writing \" + str(data) + \" to \" + self.sector_string(block_address))\n\n        return error"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading out the contents of a single entry in the RFID.", "response": "def read_out(self, block_address):\n        \"\"\"\n        Prints sector/block number and contents of block. Tag and auth must be set - does auth.\n        \"\"\"\n        if not self.is_tag_set_auth():\n            return True\n\n        error = self.do_auth(block_address)\n        if not error:\n            (error, data) = self.rfid.read(block_address)\n            print(self.sector_string(block_address) + \": \" + str(data))\n        else:\n            print(\"Error on \" + self.sector_string(block_address))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data(n_samples=100):\n    X, y = make_classification(\n        n_samples=n_samples,\n        n_features=N_FEATURES,\n        n_classes=N_CLASSES,\n        random_state=0,\n    )\n    X = X.astype(np.float32)\n    return X, y", "response": "Get synthetic classification data with n_samples samples."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a multi - layer perceptron model.", "response": "def get_model(with_pipeline=False):\n    \"\"\"Get a multi-layer perceptron model.\n\n    Optionally, put it in a pipeline that scales the data.\n\n    \"\"\"\n    model = NeuralNetClassifier(MLPClassifier)\n    if with_pipeline:\n        model = Pipeline([\n            ('scale', FeatureUnion([\n                ('minmax', MinMaxScaler()),\n                ('normalize', Normalizer()),\n            ])),\n            ('select', SelectKBest(k=N_FEATURES)),  # keep input size constant\n            ('net', model),\n        ])\n    return model"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves model to output_file if given", "response": "def save_model(model, output_file):\n    \"\"\"Save model to output_file, if given\"\"\"\n    if not output_file:\n        return\n\n    with open(output_file, 'wb') as f:\n        pickle.dump(model, f)\n    print(\"Saved model to file '{}'.\".format(output_file))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef net(n_samples=100, output_file=None, **kwargs):\n\n    model = get_model(with_pipeline=False)\n    # important: wrap the model with the parsed arguments\n    parsed = parse_args(kwargs, defaults=DEFAULTS_NET)\n    model = parsed(model)\n\n    X, y = get_data(n_samples=n_samples)\n    print(\"Training MLP classifier\")\n    model.fit(X, y)\n\n    save_model(model, output_file)", "response": "Train an MLP classifier on synthetic data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pipeline(n_samples=100, output_file=None, **kwargs):\n\n    model = get_model(with_pipeline=True)\n    # important: wrap the model with the parsed arguments\n    parsed = parse_args(kwargs, defaults=DEFAULTS_PIPE)\n    model = parsed(model)\n\n    X, y = get_data(n_samples=n_samples)\n    print(\"Training MLP classifier in a pipeline\")\n    model.fit(X, y)\n\n    save_model(model, output_file)", "response": "Train an MLP classifier on synthetic data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset_params(self):\n        units = [N_FEATURES]\n        units += [self.hidden_units] * self.num_hidden\n        units += [N_CLASSES]\n\n        sequence = []\n        for u0, u1 in zip(units, units[1:]):\n            sequence.append(nn.Linear(u0, u1))\n            sequence.append(self.nonlin)\n            sequence.append(nn.Dropout(self.dropout))\n\n        sequence = sequence[:-2]\n        self.sequential = nn.Sequential(*sequence)", "response": "Re - set all parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef predict(self, X):\n        y_preds = []\n        for yp in self.forward_iter(X, training=False):\n            yp = yp[0] if isinstance(yp, tuple) else yp\n            y_preds.append(to_numpy(yp.max(-1)[-1]))\n        y_pred = np.concatenate(y_preds, 0)\n        return y_pred", "response": "Where applicable return class labels for samples in X."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fit(self, X, y, **fit_params):\n        # pylint: disable=useless-super-delegation\n        # this is actually a pylint bug:\n        # https://github.com/PyCQA/pylint/issues/1085\n        return super().fit(X, y, **fit_params)", "response": "See ``NeuralNet.fit``.\n\n        In contrast to ``NeuralNet.fit``, ``y`` is non-optional to\n        avoid mistakenly forgetting about ``y``. However, ``y`` can be\n        set to ``None`` in case it is derived dynamically from\n        ``X``."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef predict_proba(self, X):\n        y_probas = []\n        bce_logits_loss = isinstance(\n            self.criterion_, torch.nn.BCEWithLogitsLoss)\n\n        for yp in self.forward_iter(X, training=False):\n            yp = yp[0] if isinstance(yp, tuple) else yp\n            if bce_logits_loss:\n                yp = torch.sigmoid(yp)\n            y_probas.append(to_numpy(yp))\n        y_proba = np.concatenate(y_probas, 0)\n        return y_proba", "response": "Where applicable return probability estimates for all the items in the specified samples."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\napply a function to data trying to unpack different data types.", "response": "def _apply_to_data(data, func, unpack_dict=False):\n    \"\"\"Apply a function to data, trying to unpack different data\n    types.\n\n    \"\"\"\n    apply_ = partial(_apply_to_data, func=func, unpack_dict=unpack_dict)\n\n    if isinstance(data, dict):\n        if unpack_dict:\n            return [apply_(v) for v in data.values()]\n        return {k: apply_(v) for k, v in data.items()}\n\n    if isinstance(data, (list, tuple)):\n        try:\n            # e.g.list/tuple of arrays\n            return [apply_(x) for x in data]\n        except TypeError:\n            return func(data)\n\n    return func(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef uses_placeholder_y(ds):\n\n    if isinstance(ds, torch.utils.data.Subset):\n        return uses_placeholder_y(ds.dataset)\n    return isinstance(ds, Dataset) and hasattr(ds, \"y\") and ds.y is None", "response": "Returns True if the dataset y is a placeholder."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unpack_data(data):\n    # Note: This function cannot detect it when a user only returns 1\n    # item that is exactly of length 2 (e.g. because the batch size is\n    # 2). In that case, the item will be erroneously split into X and\n    # y.\n    try:\n        X, y = data\n        return X, y\n    except ValueError:\n        # if a 1-tuple/list or something else like a torch tensor\n        if not isinstance(data, (tuple, list)) or len(data) < 2:\n            raise ValueError(ERROR_MSG_1_ITEM)\n        raise ValueError(ERROR_MSG_MORE_THAN_2_ITEMS.format(len(data)))", "response": "Unpack data returned by the net s iterator into a 2 - tuple."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef transform(self, X, y):\n        # pylint: disable=anomalous-backslash-in-string\n        \"\"\"Additional transformations on ``X`` and ``y``.\n\n        By default, they are cast to PyTorch :class:`~torch.Tensor`\\s.\n        Override this if you want a different behavior.\n\n        Note: If you use this in conjuction with PyTorch\n        :class:`~torch.utils.data.DataLoader`, the latter will call\n        the dataset for each row separately, which means that the\n        incoming ``X`` and ``y`` each are single rows.\n\n        \"\"\"\n        # pytorch DataLoader cannot deal with None so we use 0 as a\n        # placeholder value. We only return a Tensor with one value\n        # (as opposed to ``batchsz`` values) since the pytorch\n        # DataLoader calls __getitem__ for each row in the batch\n        # anyway, which results in a dummy ``y`` value for each row in\n        # the batch.\n        y = torch.Tensor([0]) if y is None else y\n\n        # pytorch cannot convert sparse matrices, for now just make it\n        # dense; squeeze because X[i].shape is (1, n) for csr matrices\n        if sparse.issparse(X):\n            X = X.toarray().squeeze(0)\n        return X, y", "response": "Transform X and y into a new version of the key - value store."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nresolve which cross validation strategy is used.", "response": "def check_cv(self, y):\n        \"\"\"Resolve which cross validation strategy is used.\"\"\"\n        y_arr = None\n        if self.stratified:\n            # Try to convert y to numpy for sklearn's check_cv; if conversion\n            # doesn't work, still try.\n            try:\n                y_arr = to_numpy(y)\n            except (AttributeError, TypeError):\n                y_arr = y\n\n        if self._is_float(self.cv):\n            return self._check_cv_float()\n        return self._check_cv_non_float(y_arr)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_span(s, pattern):\n    i, j = -1, -1\n\n    match = pattern.match(s)\n    if not match:\n        return i, j\n\n    for group_name in pattern.groupindex:\n        i, j = match.span(group_name)\n        if (i, j) != (-1, -1):\n            return i, j\n\n    return i, j", "response": "Return the span of the first group that matches the pattern."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreplace the default value in a parameter docstring by a new value.", "response": "def _substitute_default(s, new_value):\n    \"\"\"Replaces the default value in a parameter docstring by a new value.\n\n    The docstring must conform to the numpydoc style and have the form\n    \"something (keyname=<value-to-replace>)\"\n\n    If no matching pattern is found or ``new_value`` is None, return\n    the input untouched.\n\n    Examples\n    --------\n    >>> _replace_default('int (default=128)', 256)\n    'int (default=256)'\n    >>> _replace_default('nonlin (default = ReLU())', nn.Hardtanh(1, 2))\n    'nonlin (default = Hardtanh(min_val=1, max_val=2))'\n\n    \"\"\"\n    if new_value is None:\n        return s\n\n    # BB: ideally, I would like to replace the 'default*' group\n    # directly but I haven't found a way to do this\n    i, j = _get_span(s, pattern=P_DEFAULTS)\n    if (i, j) == (-1, -1):\n        return s\n    return '{}{}{}'.format(s[:i], new_value, s[j:])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve a dotted name into a base object.", "response": "def _resolve_dotted_name(dotted_name):\n    \"\"\"Returns objects from strings\n\n    Deals e.g. with 'torch.nn.Softmax(dim=-1)'.\n\n    Modified from palladium:\n\n    https://github.com/ottogroup/palladium/blob/8a066a9a7690557d9b1b6ed54b7d1a1502ba59e3/palladium/util.py\n\n    with added support for instantiated objects.\n\n    \"\"\"\n    if not isinstance(dotted_name, str):\n        return dotted_name\n\n    if '.' not in dotted_name:\n        return dotted_name\n\n    args = None\n    params = None\n    match = P_PARAMS.match(dotted_name)\n    if match:\n        dotted_name = match.group('name')\n        params = match.group('params')\n\n    module, name = dotted_name.rsplit('.', 1)\n    attr = import_module(module)\n    attr = getattr(attr, name)\n\n    if params:\n        args, kwargs = _parse_args_kwargs(params[1:-1])\n        attr = attr(*args, **kwargs)\n\n    return attr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_net_kwargs(kwargs):\n    if not kwargs:\n        return kwargs\n\n    resolved = {}\n    for k, v in kwargs.items():\n        resolved[k] = _resolve_dotted_name(v)\n\n    return resolved", "response": "Parse keyword arguments for the estimator."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nyield the estimator and its prefix from the model.", "response": "def _yield_estimators(model):\n    \"\"\"Yield estimator and its prefix from the model.\n\n    First, pipeline preprocessing steps are yielded (if there are\n    any). Next the neural net is yielded. Finally, the module is\n    yielded.\n\n    \"\"\"\n    yield from _yield_preproc_steps(model)\n\n    net_prefixes = []\n    module_prefixes = []\n\n    if isinstance(model, Pipeline):\n        name = model.steps[-1][0]\n        net_prefixes.append(name)\n        module_prefixes.append(name)\n        net = model.steps[-1][1]\n    else:\n        net = model\n\n    yield '__'.join(net_prefixes), net\n\n    module = net.module\n    module_prefixes.append('module')\n    yield '__'.join(module_prefixes), module"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_help_for_estimator(prefix, estimator, defaults=None):\n    from numpydoc.docscrape import ClassDoc\n\n    defaults = defaults or {}\n    estimator = _extract_estimator_cls(estimator)\n    yield \"<{}> options:\".format(estimator.__name__)\n\n    doc = ClassDoc(estimator)\n    yield from _get_help_for_params(\n        doc['Parameters'],\n        prefix=prefix,\n        defaults=defaults,\n    )\n    yield ''", "response": "Yields help lines for the given estimator and prefix."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_help(model, defaults=None):\n    defaults = defaults or {}\n\n    print(\"This is the help for the model-specific parameters.\")\n    print(\"To invoke help for the remaining options, run:\")\n    print(\"python {} -- --help\".format(sys.argv[0]))\n    print()\n\n    lines = (_get_help_for_estimator(prefix, estimator, defaults=defaults) for\n             prefix, estimator in _yield_estimators(model))\n    print('\\n'.join(chain(*lines)))", "response": "Print help for the command line arguments of the given model."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_args(kwargs, defaults=None):\n    try:\n        import fire\n    except ImportError:\n        raise ImportError(\"Using skorch cli helpers requires the fire library,\"\n                          \" you can install it with pip: pip install fire.\")\n    try:\n        import numpydoc.docscrape\n    except ImportError:\n        raise ImportError(\"Using skorch cli helpers requires the numpydoc library,\"\n                          \" you can install it with pip: pip install numpydoc.\")\n\n    defaults = defaults or {}\n\n    def print_help_and_exit(estimator):\n        print_help(estimator, defaults=defaults)\n        sys.exit()\n\n    def set_params(estimator):\n        estimator.set_params(**defaults)\n        return estimator.set_params(**parse_net_kwargs(kwargs))\n\n    if kwargs.get('help'):\n        return print_help_and_exit\n    return set_params", "response": "Parse command line arguments and return a new object that can be used to build a new skorch estimator."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filter_requires_grad(pgroups):\n    warnings.warn(\n        \"For filtering gradients, please use skorch.callbacks.Freezer.\",\n        DeprecationWarning)\n\n    for pgroup in pgroups:\n        output = {k: v for k, v in pgroup.items() if k != 'params'}\n        output['params'] = (p for p in pgroup['params'] if p.requires_grad)\n        yield output", "response": "Returns parameter groups where parameters that require a gradient are filtered out."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrap an optimizer that filters out parameters where filter_fn over pgroups returns False", "response": "def filtered_optimizer(optimizer, filter_fn):\n    \"\"\"Wraps an optimizer that filters out parameters where\n    ``filter_fn`` over ``pgroups`` returns ``False``.\n    This function can be used, for example, to filter parameters\n    that do not require a gradient:\n\n    >>> from skorch.helper import filtered_optimizer, filter_requires_grad\n    >>> optimizer = filtered_optimizer(torch.optim.SGD, filter_requires_grad)\n    >>> net = NeuralNetClassifier(module, optimizer=optimizer)\n\n    Parameters\n    ----------\n    optimizer : torch optim (class)\n      The uninitialized optimizer that is wrapped\n\n    filter_fn : function\n      Use this function to filter parameter groups before passing\n      it to ``optimizer``.\n\n    \"\"\"\n    warnings.warn(\n        \"For filtering gradients, please use skorch.callbacks.Freezer.\",\n        DeprecationWarning)\n\n    return partial(_make_optimizer, optimizer=optimizer, filter_fn=filter_fn)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a pytorch tensor into a Pillow Image.", "response": "def convert_cell_to_img(t, padding=16):\n    \"\"\"Converts pytorch tensor into a Pillow Image. The padding will be removed\n    from the resulting image\"\"\"\n    std = torch.Tensor([0.229, 0.224, 0.225]).reshape(-1, 1, 1)\n    mu = torch.Tensor([0.485, 0.456, 0.406]).reshape(-1, 1, 1)\n    output = t.mul(std)\n    output.add_(mu)\n    img = to_pil_image(output)\n    w, h = img.size\n    return img.crop((padding, padding, w - padding, h - padding))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot cells with their true mask predicted mask.", "response": "def plot_mask_cells(mask_cells, padding=16):\n    \"\"\"Plots cells with their true mask, predicted mask.\n\n    Parameters\n    ----------\n    mask_cells: list of tuples (`true_mask`, `predicted_mask`, `cell`)\n    padding: int (default=16)\n        Padding around mask to remove.\n    \"\"\"\n    fig, axes = plt.subplots(len(mask_cells), 3, figsize=(12, 10))\n    for idx, (axes, mask_cell) in enumerate(zip(axes, mask_cells), 1):\n        ax1, ax2, ax3 = axes\n        true_mask, predicted_mask, cell = mask_cell\n        plot_mask_cell(\n                true_mask, predicted_mask, cell,\n                'Type {}'.format(idx),\n                ax1, ax2, ax3,\n                padding=padding)\n    fig.tight_layout()\n    return fig, axes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_mask_cell(true_mask,\n                   predicted_mask,\n                   cell,\n                   suffix,\n                   ax1,\n                   ax2,\n                   ax3,\n                   padding=16):\n    \"\"\"Plots a single cell with a its true mask and predicuted mask\"\"\"\n    for ax in [ax1, ax2, ax3]:\n        ax.grid(False)\n        ax.set_xticks([])\n        ax.set_yticks([])\n    ax1.imshow(true_mask[padding:-padding, padding:-padding], cmap='viridis')\n    ax1.set_title('True Mask - {}'.format(suffix))\n    ax2.imshow(\n        predicted_mask[padding:-padding, padding:-padding], cmap='viridis')\n    ax2.set_title('Predicted Mask - {}'.format(suffix))\n    ax3.imshow(convert_cell_to_img(cell, padding=padding))\n    ax3.set_title('Image - {}'.format(suffix))\n    return ax1, ax2, ax3", "response": "Plots a single cell with a true mask and predicted mask"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat a given row into a string.", "response": "def format_row(self, row, key, color):\n        \"\"\"For a given row from the table, format it (i.e. floating\n        points and color if applicable).\n\n        \"\"\"\n        value = row[key]\n\n        if isinstance(value, bool) or value is None:\n            return '+' if value else ''\n\n        if not isinstance(value, Number):\n            return value\n\n        # determine if integer value\n        is_integer = float(value).is_integer()\n        template = '{}' if is_integer else '{:' + self.floatfmt + '}'\n\n        # if numeric, there could be a 'best' key\n        key_best = key + '_best'\n        if (key_best in row) and row[key_best]:\n            template = color + template + Ansi.ENDC.value\n        return template.format(value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _sorted_keys(self, keys):\n        sorted_keys = []\n        if ('epoch' in keys) and ('epoch' not in self.keys_ignored_):\n            sorted_keys.append('epoch')\n\n        for key in sorted(keys):\n            if not (\n                    (key in ('epoch', 'dur')) or\n                    (key in self.keys_ignored_) or\n                    key.endswith('_best') or\n                    key.startswith('event_')\n            ):\n                sorted_keys.append(key)\n\n        for key in sorted(keys):\n            if key.startswith('event_') and (key not in self.keys_ignored_):\n                sorted_keys.append(key)\n        if ('dur' in keys) and ('dur' not in self.keys_ignored_):\n            sorted_keys.append('dur')\n        return sorted_keys", "response": "Sort keys in order of priority."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_tensor(X, device, accept_sparse=False):\n    to_tensor_ = partial(to_tensor, device=device)\n\n    if is_torch_data_type(X):\n        return X.to(device)\n    if isinstance(X, dict):\n        return {key: to_tensor_(val) for key, val in X.items()}\n    if isinstance(X, (list, tuple)):\n        return [to_tensor_(x) for x in X]\n    if np.isscalar(X):\n        return torch.as_tensor(X, device=device)\n    if isinstance(X, Sequence):\n        return torch.as_tensor(np.array(X), device=device)\n    if isinstance(X, np.ndarray):\n        return torch.as_tensor(X, device=device)\n    if sparse.issparse(X):\n        if accept_sparse:\n            return torch.sparse_coo_tensor(\n                X.nonzero(), X.data, size=X.shape).to(device)\n        raise TypeError(\"Sparse matrices are not supported. Set \"\n                        \"accept_sparse=True to allow sparse matrices.\")\n\n    raise TypeError(\"Cannot convert this data type to a torch tensor.\")", "response": "Turn input data to torch tensor."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of indexing functions for each element of data.", "response": "def _indexing_list_tuple_of_data(data, i, indexings=None):\n    \"\"\"Data is a list/tuple of data structures (e.g. list of numpy arrays).\n\n    ``indexings`` are the indexing functions for each element of\n    ``data``. If ``indexings`` are not given, the indexing functions\n    for the individual structures have to be determined ad hoc, which\n    is slower.\n\n    \"\"\"\n    if not indexings:\n        return [multi_indexing(x, i) for x in data]\n    return [multi_indexing(x, i, indexing)\n            for x, indexing in zip(data, indexings)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_indexing(data):\n    if data is None:\n        return _indexing_none\n\n    if isinstance(data, dict):\n        # dictionary of containers\n        return _indexing_dict\n\n    if isinstance(data, (list, tuple)):\n        try:\n            # list or tuple of containers\n            # TODO: Is there a better way than just to try to index? This\n            # is error prone (e.g. if one day list of strings are\n            # possible).\n            multi_indexing(data[0], 0)\n            indexings = [check_indexing(x) for x in data]\n            return partial(_indexing_list_tuple_of_data, indexings=indexings)\n        except TypeError:\n            # list or tuple of values\n            return _indexing_other\n\n    if is_pandas_ndframe(data):\n        # pandas NDFrame, will be transformed to dict\n        return _indexing_ndframe\n\n    # torch tensor, numpy ndarray, list\n    return _indexing_other", "response": "Perform a check how incoming data should be indexed and return an an\n    appropriate indexing function with signature f ( data index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _normalize_numpy_indices(i):\n    if isinstance(i, np.ndarray):\n        if i.dtype == bool:\n            i = tuple(j.tolist() for j in i.nonzero())\n        elif i.dtype == int:\n            i = i.tolist()\n    return i", "response": "Normalize the index in case it is a numpy integer or boolean\n    array."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms indexing on multiple data structures.", "response": "def multi_indexing(data, i, indexing=None):\n    \"\"\"Perform indexing on multiple data structures.\n\n    Currently supported data types:\n\n    * numpy arrays\n    * torch tensors\n    * pandas NDFrame\n    * a dictionary of the former three\n    * a list/tuple of the former three\n\n    ``i`` can be an integer or a slice.\n\n    Examples\n    --------\n    >>> multi_indexing(np.asarray([1, 2, 3]), 0)\n    1\n\n    >>> multi_indexing(np.asarray([1, 2, 3]), np.s_[:2])\n    array([1, 2])\n\n    >>> multi_indexing(torch.arange(0, 4), np.s_[1:3])\n    tensor([ 1.,  2.])\n\n    >>> multi_indexing([[1, 2, 3], [4, 5, 6]], np.s_[:2])\n    [[1, 2], [4, 5]]\n\n    >>> multi_indexing({'a': [1, 2, 3], 'b': [4, 5, 6]}, np.s_[-2:])\n    {'a': [2, 3], 'b': [5, 6]}\n\n    >>> multi_indexing(pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]}), [1, 2])\n       a  b\n    1  2  5\n    2  3  6\n\n    Parameters\n    ----------\n    data\n      Data of a type mentioned above.\n\n    i : int or slice\n      Slicing index.\n\n    indexing : function/callable or None (default=None)\n      If not None, use this function for indexing into the data. If\n      None, try to automatically determine how to index data.\n\n    \"\"\"\n    # in case of i being a numpy array\n    i = _normalize_numpy_indices(i)\n\n    # If we already know how to index, use that knowledge\n    if indexing is not None:\n        return indexing(data, i)\n\n    # If we don't know how to index, find out and apply\n    return check_indexing(data)(data, i)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for duplicate items in all collections.", "response": "def duplicate_items(*collections):\n    \"\"\"Search for duplicate items in all collections.\n\n    Examples\n    --------\n    >>> duplicate_items([1, 2], [3])\n    set()\n    >>> duplicate_items({1: 'a', 2: 'a'})\n    set()\n    >>> duplicate_items(['a', 'b', 'a'])\n    {'a'}\n    >>> duplicate_items([1, 2], {3: 'hi', 4: 'ha'}, (2, 3))\n    {2, 3}\n\n    \"\"\"\n    duplicates = set()\n    seen = set()\n    for item in flatten(collections):\n        if item in seen:\n            duplicates.add(item)\n        else:\n            seen.add(item)\n    return duplicates"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting parameters that belong to a given sklearn module prefix from kwargs.", "response": "def params_for(prefix, kwargs):\n    \"\"\"Extract parameters that belong to a given sklearn module prefix from\n    ``kwargs``. This is useful to obtain parameters that belong to a\n    submodule.\n\n    Examples\n    --------\n    >>> kwargs = {'encoder__a': 3, 'encoder__b': 4, 'decoder__a': 5}\n    >>> params_for('encoder', kwargs)\n    {'a': 3, 'b': 4}\n\n    \"\"\"\n    if not prefix.endswith('__'):\n        prefix += '__'\n    return {key[len(prefix):]: val for key, val in kwargs.items()\n            if key.startswith(prefix)}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to access X and y attribute from dataset.", "response": "def data_from_dataset(dataset, X_indexing=None, y_indexing=None):\n    \"\"\"Try to access X and y attribute from dataset.\n\n    Also works when dataset is a subset.\n\n    Parameters\n    ----------\n    dataset : skorch.dataset.Dataset or torch.utils.data.Subset\n      The incoming dataset should be a ``skorch.dataset.Dataset`` or a\n      ``torch.utils.data.Subset`` of a\n      ``skorch.dataset.Dataset``.\n\n    X_indexing : function/callable or None (default=None)\n      If not None, use this function for indexing into the X data. If\n      None, try to automatically determine how to index data.\n\n    y_indexing : function/callable or None (default=None)\n      If not None, use this function for indexing into the y data. If\n      None, try to automatically determine how to index data.\n\n    \"\"\"\n    X, y = _none, _none\n\n    if isinstance(dataset, Subset):\n        X, y = data_from_dataset(\n            dataset.dataset, X_indexing=X_indexing, y_indexing=y_indexing)\n        X = multi_indexing(X, dataset.indices, indexing=X_indexing)\n        y = multi_indexing(y, dataset.indices, indexing=y_indexing)\n    elif hasattr(dataset, 'X') and hasattr(dataset, 'y'):\n        X, y = dataset.X, dataset.y\n\n    if (X is _none) or (y is _none):\n        raise AttributeError(\"Could not access X and y from dataset.\")\n    return X, y"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_skorch_dataset(ds):\n    from skorch.dataset import Dataset\n    if isinstance(ds, Subset):\n        return is_skorch_dataset(ds.dataset)\n    return isinstance(ds, Dataset)", "response": "Checks if the supplied dataset is an instance of\n    skorch. util. data. Dataset even when it is nested inside\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_file_like(f, mode):\n    new_fd = isinstance(f, (str, pathlib.Path))\n    if new_fd:\n        f = open(f, mode)\n    try:\n        yield f\n    finally:\n        if new_fd:\n            f.close()", "response": "Wrapper for opening a file - like object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines the location to map loaded data for a given target device.", "response": "def get_map_location(target_device, fallback_device='cpu'):\n    \"\"\"Determine the location to map loaded data (e.g., weights)\n    for a given target device (e.g. 'cuda').\n    \"\"\"\n    map_location = torch.device(target_device)\n\n    # The user wants to use CUDA but there is no CUDA device\n    # available, thus fall back to CPU.\n    if map_location.type == 'cuda' and not torch.cuda.is_available():\n        warnings.warn(\n            'Requested to load data to CUDA but no CUDA devices '\n            'are available. Loading on device \"{}\" instead.'.format(\n                fallback_device,\n            ), DeviceWarning)\n        map_location = torch.device(fallback_device)\n    return map_location"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncaches context for ``skorch.NeuralNet`` instance. Returns a modified version of the net whose ``infer`` method will subsequently return cached predictions. Leaving the context will undo the overwrite of the ``infer`` method.", "response": "def cache_net_infer(net, use_caching, y_preds):\n    \"\"\"Caching context for ``skorch.NeuralNet`` instance. Returns\n    a modified version of the net whose ``infer`` method will\n    subsequently return cached predictions. Leaving the context\n    will undo the overwrite of the ``infer`` method.\"\"\"\n    if not use_caching:\n        yield net\n        return\n    y_preds = iter(y_preds)\n    net.infer = lambda *a, **kw: next(y_preds)\n\n    try:\n        yield net\n    finally:\n        # By setting net.infer we define an attribute `infer`\n        # that precedes the bound method `infer`. By deleting\n        # the entry from the attribute dict we undo this.\n        del net.__dict__['infer']"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert_sklearn_metric_function(scoring):\n    if callable(scoring):\n        module = getattr(scoring, '__module__', None)\n        if (\n                hasattr(module, 'startswith') and\n                module.startswith('sklearn.metrics.') and\n                not module.startswith('sklearn.metrics.scorer') and\n                not module.startswith('sklearn.metrics.tests.')\n        ):\n            return make_scorer(scoring)\n    return scoring", "response": "Convert a sklearn metric function to a\n    sklearn scorer and return it unchanged."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind name of scoring function.", "response": "def _get_name(self):\n        \"\"\"Find name of scoring function.\"\"\"\n        if self.name is not None:\n            return self.name\n        if self.scoring_ is None:\n            return 'score'\n        if isinstance(self.scoring_, str):\n            return self.scoring_\n        if isinstance(self.scoring_, partial):\n            return self.scoring_.func.__name__\n        if isinstance(self.scoring_, _BaseScorer):\n            return self.scoring_._score_func.__name__\n        return self.scoring_.__name__"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresolves scoring and apply it to data. Use cached prediction instead of running inference again.", "response": "def _scoring(self, net, X_test, y_test):\n        \"\"\"Resolve scoring and apply it to data. Use cached prediction\n        instead of running inference again, if available.\"\"\"\n        scorer = check_scoring(net, self.scoring_)\n        scores = _score(\n            estimator=net,\n            X_test=X_test,\n            y_test=y_test,\n            scorer=scorer,\n            is_multimetric=False,\n        )\n        return scores"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _record_score(self, history, current_score):\n        history.record(self.name_, current_score)\n\n        is_best = self._is_best_score(current_score)\n        if is_best is None:\n            return\n\n        history.record(self.name_ + '_best', bool(is_best))\n        if is_best:\n            self.best_score_ = current_score", "response": "Record the current score in the given history."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the bounding boxes based on image shape and size of the bounding box given by patch_size.", "response": "def calcuate_bboxes(im_shape, patch_size):\n    \"\"\"Calculate bound boxes based on image shape and size of the bounding box\n    given by `patch_size`\"\"\"\n    h, w = im_shape\n    ph, pw = patch_size\n\n    steps_h = chain(range(0, h - ph, ph), [h - ph])\n    steps_w = chain(range(0, w - pw, pw), [w - pw])\n\n    return product(steps_h, steps_w)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_classifier(output_nonlin=nn.Softmax(dim=-1), **kwargs):\n    return partial(MLPModule, output_nonlin=output_nonlin, **kwargs)", "response": "Returns a multi - layer perceptron to be used with\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reset_params(self):\n        units = [self.input_units]\n        units += [self.hidden_units] * self.num_hidden\n        units += [self.output_units]\n\n        sequence = []\n        for u0, u1 in zip(units, units[1:]):\n            sequence.append(nn.Linear(u0, u1))\n            sequence.append(self.nonlin)\n            sequence.append(nn.Dropout(self.dropout))\n\n        sequence = sequence[:-2]\n        if self.output_nonlin:\n            sequence.append(self.output_nonlin)\n\n        self.sequential = nn.Sequential(*sequence)", "response": "Re - set all parameters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef notify(self, method_name, **cb_kwargs):\n        getattr(self, method_name)(self, **cb_kwargs)\n        for _, cb in self.callbacks_:\n            getattr(cb, method_name)(self, **cb_kwargs)", "response": "Call the callback method specified in method_name with the given kwargs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _yield_callbacks(self):\n        print_logs = []\n        for item in self.get_default_callbacks() + (self.callbacks or []):\n            if isinstance(item, (tuple, list)):\n                named_by_user = True\n                name, cb = item\n            else:\n                named_by_user = False\n                cb = item\n                if isinstance(cb, type):  # uninitialized:\n                    name = cb.__name__\n                else:\n                    name = cb.__class__.__name__\n            if isinstance(cb, PrintLog) or (cb == PrintLog):\n                print_logs.append((name, cb, named_by_user))\n            else:\n                yield name, cb, named_by_user\n        yield from print_logs", "response": "Yield all callbacks set on this instance including the last set of callbacks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _callbacks_grouped_by_name(self):\n        callbacks, names_set_by_user = OrderedDict(), set()\n        for name, cb, named_by_user in self._yield_callbacks():\n            if named_by_user:\n                names_set_by_user.add(name)\n            callbacks[name] = callbacks.get(name, []) + [cb]\n        return callbacks, names_set_by_user", "response": "Group callbacks by name and collect names set by the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nyield a list of named callbacks that are unique.", "response": "def _uniquely_named_callbacks(self):\n        \"\"\"Make sure that the returned dict of named callbacks is unique\n        w.r.t. to the callback name. User-defined names will not be\n        renamed on conflict, instead an exception will be raised. The\n        same goes for the event where renaming leads to a conflict.\n        \"\"\"\n        grouped_cbs, names_set_by_user = self._callbacks_grouped_by_name()\n        for name, cbs in grouped_cbs.items():\n            if len(cbs) > 1 and name in names_set_by_user:\n                raise ValueError(\"Found duplicate user-set callback name \"\n                                 \"'{}'. Use unique names to correct this.\"\n                                 .format(name))\n\n            for i, cb in enumerate(cbs):\n                if len(cbs) > 1:\n                    unique_name = '{}_{}'.format(name, i+1)\n                    if unique_name in grouped_cbs:\n                        raise ValueError(\"Assigning new callback name failed \"\n                                         \"since new name '{}' exists already.\"\n                                         .format(unique_name))\n                else:\n                    unique_name = name\n                yield unique_name, cb"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing all callbacks and saves the result in the class attribute callbacks_.", "response": "def initialize_callbacks(self):\n        \"\"\"Initializes all callbacks and save the result in the\n        ``callbacks_`` attribute.\n\n        Both ``default_callbacks`` and ``callbacks`` are used (in that\n        order). Callbacks may either be initialized or not, and if\n        they don't have a name, the name is inferred from the class\n        name. The ``initialize`` method is called on all callbacks.\n\n        The final result will be a list of tuples, where each tuple\n        consists of a name and an initialized callback. If names are\n        not unique, a ValueError is raised.\n\n        \"\"\"\n        callbacks_ = []\n\n        class Dummy:\n            # We cannot use None as dummy value since None is a\n            # legitimate value to be set.\n            pass\n\n        for name, cb in self._uniquely_named_callbacks():\n            # check if callback itself is changed\n            param_callback = getattr(self, 'callbacks__' + name, Dummy)\n            if param_callback is not Dummy:  # callback itself was set\n                cb = param_callback\n\n            # below: check for callback params\n            # don't set a parameter for non-existing callback\n            params = self._get_params_for('callbacks__{}'.format(name))\n            if (cb is None) and params:\n                raise ValueError(\"Trying to set a parameter for callback {} \"\n                                 \"which does not exist.\".format(name))\n            if cb is None:\n                continue\n\n            if isinstance(cb, type):  # uninitialized:\n                cb = cb(**params)\n            else:\n                cb.set_params(**params)\n            cb.initialize()\n            callbacks_.append((name, cb))\n\n        self.callbacks_ = callbacks_\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _format_reinit_msg(self, name, kwargs=None, triggered_directly=True):\n        msg = \"Re-initializing {}\".format(name)\n        if triggered_directly and kwargs:\n            msg += (\" because the following parameters were re-set: {}.\"\n                    .format(', '.join(sorted(kwargs))))\n        else:\n            msg += \".\"\n        return msg", "response": "Returns a message that informs about re - initialization a compoment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initialize_module(self):\n        kwargs = self._get_params_for('module')\n        module = self.module\n        is_initialized = isinstance(module, torch.nn.Module)\n\n        if kwargs or not is_initialized:\n            if is_initialized:\n                module = type(module)\n\n            if (is_initialized or self.initialized_) and self.verbose:\n                msg = self._format_reinit_msg(\"module\", kwargs)\n                print(msg)\n\n            module = module(**kwargs)\n\n        self.module_ = module.to(self.device)\n        return self", "response": "Initializes the module.\n\n        Note that if the module has learned parameters, those will be\n        reset."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initialize_optimizer(self, triggered_directly=True):\n        args, kwargs = self._get_params_for_optimizer(\n            'optimizer', self.module_.named_parameters())\n\n        if self.initialized_ and self.verbose:\n            msg = self._format_reinit_msg(\n                \"optimizer\", kwargs, triggered_directly=triggered_directly)\n            print(msg)\n\n        if 'lr' not in kwargs:\n            kwargs['lr'] = self.lr\n\n        self.optimizer_ = self.optimizer(*args, **kwargs)\n\n        self._register_virtual_param(\n            ['optimizer__param_groups__*__*', 'optimizer__*', 'lr'],\n            optimizer_setter,\n        )", "response": "Initialize the model optimizer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initialize(self):\n        self.initialize_virtual_params()\n        self.initialize_callbacks()\n        self.initialize_criterion()\n        self.initialize_module()\n        self.initialize_optimizer()\n        self.initialize_history()\n\n        self.initialized_ = True\n        return self", "response": "Initializes all components of the : class :. NeuralNet class and returns self."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform a forward step using batched data and return the resulting loss.", "response": "def validation_step(self, Xi, yi, **fit_params):\n        \"\"\"Perform a forward step using batched data and return the\n        resulting loss.\n\n        The module is set to be in evaluation mode (e.g. dropout is\n        not applied).\n\n        Parameters\n        ----------\n        Xi : input data\n          A batch of the input data.\n\n        yi : target data\n          A batch of the target data.\n\n        **fit_params : dict\n          Additional parameters passed to the ``forward`` method of\n          the module and to the ``self.train_split`` call.\n\n        \"\"\"\n        self.module_.eval()\n        with torch.no_grad():\n            y_pred = self.infer(Xi, **fit_params)\n            loss = self.get_loss(y_pred, yi, X=Xi, training=False)\n        return {\n            'loss': loss,\n            'y_pred': y_pred,\n            }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntrain the module for single training.", "response": "def train_step_single(self, Xi, yi, **fit_params):\n        \"\"\"Compute y_pred, loss value, and update net's gradients.\n\n        The module is set to be in train mode (e.g. dropout is\n        applied).\n\n        Parameters\n        ----------\n        Xi : input data\n          A batch of the input data.\n\n        yi : target data\n          A batch of the target data.\n\n        **fit_params : dict\n          Additional parameters passed to the ``forward`` method of\n          the module and to the ``self.train_split`` call.\n\n        \"\"\"\n        self.module_.train()\n        self.optimizer_.zero_grad()\n        y_pred = self.infer(Xi, **fit_params)\n        loss = self.get_loss(y_pred, yi, X=Xi, training=True)\n        loss.backward()\n\n        self.notify(\n            'on_grad_computed',\n            named_parameters=TeeGenerator(self.module_.named_parameters()),\n            X=Xi,\n            y=yi\n        )\n\n        return {\n            'loss': loss,\n            'y_pred': y_pred,\n            }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef train_step(self, Xi, yi, **fit_params):\n        step_accumulator = self.get_train_step_accumulator()\n        def step_fn():\n            step = self.train_step_single(Xi, yi, **fit_params)\n            step_accumulator.store_step(step)\n            return step['loss']\n        self.optimizer_.step(step_fn)\n        return step_accumulator.get_step()", "response": "Prepares a loss function callable and pass it to the optimizer and performs one optimization step."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nperforming a forward step to produce the output used for prediction and scoring.", "response": "def evaluation_step(self, Xi, training=False):\n        \"\"\"Perform a forward step to produce the output used for\n        prediction and scoring.\n\n        Therefore the module is set to evaluation mode by default\n        beforehand which can be overridden to re-enable features\n        like dropout by setting ``training=True``.\n\n        \"\"\"\n        with torch.set_grad_enabled(training):\n            self.module_.train(training)\n            return self.infer(Xi)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef partial_fit(self, X, y=None, classes=None, **fit_params):\n        if not self.initialized_:\n            self.initialize()\n\n        self.notify('on_train_begin', X=X, y=y)\n        try:\n            self.fit_loop(X, y, **fit_params)\n        except KeyboardInterrupt:\n            pass\n        self.notify('on_train_end', X=X, y=y)\n        return self", "response": "Fit the module with the given data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fit(self, X, y=None, **fit_params):\n        if not self.warm_start or not self.initialized_:\n            self.initialize()\n\n        self.partial_fit(X, y, **fit_params)\n        return self", "response": "Initialize and fit the module."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef forward_iter(self, X, training=False, device='cpu'):\n        dataset = self.get_dataset(X)\n        iterator = self.get_iterator(dataset, training=training)\n        for data in iterator:\n            Xi = unpack_data(data)[0]\n            yp = self.evaluation_step(Xi, training=training)\n            if isinstance(yp, tuple):\n                yield tuple(n.to(device) for n in yp)\n            else:\n                yield yp.to(device)", "response": "Yield outputs of module forward calls on each batch of data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef forward(self, X, training=False, device='cpu'):\n        y_infer = list(self.forward_iter(X, training=training, device=device))\n\n        is_multioutput = len(y_infer) > 0 and isinstance(y_infer[0], tuple)\n        if is_multioutput:\n            return tuple(map(torch.cat, zip(*y_infer)))\n        return torch.cat(y_infer)", "response": "Gather and concatenate the output from the forward call with the given data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef infer(self, x, **fit_params):\n        x = to_tensor(x, device=self.device)\n        if isinstance(x, dict):\n            x_dict = self._merge_x_and_fit_params(x, fit_params)\n            return self.module_(**x_dict)\n        return self.module_(x, **fit_params)", "response": "Perform a single inference step on a batch of data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npredicting the probability of a set of all entries in the module.", "response": "def predict_proba(self, X):\n        \"\"\"Return the output of the module's forward method as a numpy\n        array.\n\n        If the module's forward method returns multiple outputs as a\n        tuple, it is assumed that the first output contains the\n        relevant information and the other values are ignored. If all\n        values are relevant, consider using\n        :func:`~skorch.NeuralNet.forward` instead.\n\n        Parameters\n        ----------\n        X : input data, compatible with skorch.dataset.Dataset\n          By default, you should be able to pass:\n\n            * numpy arrays\n            * torch tensors\n            * pandas DataFrame or Series\n            * scipy sparse CSR matrices\n            * a dictionary of the former three\n            * a list/tuple of the former three\n            * a Dataset\n\n          If this doesn't work with your data, you have to pass a\n          ``Dataset`` that can deal with the data.\n\n        Returns\n        -------\n        y_proba : numpy ndarray\n\n        \"\"\"\n        y_probas = []\n        for yp in self.forward_iter(X, training=False):\n            yp = yp[0] if isinstance(yp, tuple) else yp\n            y_probas.append(to_numpy(yp))\n        y_proba = np.concatenate(y_probas, 0)\n        return y_proba"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_loss(self, y_pred, y_true, X=None, training=False):\n        y_true = to_tensor(y_true, device=self.device)\n        return self.criterion_(y_pred, y_true)", "response": "Returns the loss for this batch."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_dataset(self, X, y=None):\n        if is_dataset(X):\n            return X\n\n        dataset = self.dataset\n        is_initialized = not callable(dataset)\n\n        kwargs = self._get_params_for('dataset')\n        if kwargs and is_initialized:\n            raise TypeError(\"Trying to pass an initialized Dataset while \"\n                            \"passing Dataset arguments ({}) is not \"\n                            \"allowed.\".format(kwargs))\n\n        if is_initialized:\n            return dataset\n\n        return dataset(X, y, **kwargs)", "response": "Get a new dataset that contains the input data and is passed to\n            the iterator."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the train and validation datasets for the given data.", "response": "def get_split_datasets(self, X, y=None, **fit_params):\n        \"\"\"Get internal train and validation datasets.\n\n        The validation dataset can be None if ``self.train_split`` is\n        set to None; then internal validation will be skipped.\n\n        Override this if you want to change how the net splits\n        incoming data into train and validation part.\n\n        Parameters\n        ----------\n        X : input data, compatible with skorch.dataset.Dataset\n          By default, you should be able to pass:\n\n            * numpy arrays\n            * torch tensors\n            * pandas DataFrame or Series\n            * scipy sparse CSR matrices\n            * a dictionary of the former three\n            * a list/tuple of the former three\n            * a Dataset\n\n          If this doesn't work with your data, you have to pass a\n          ``Dataset`` that can deal with the data.\n\n        y : target data, compatible with skorch.dataset.Dataset\n          The same data types as for ``X`` are supported. If your X is\n          a Dataset that contains the target, ``y`` may be set to\n          None.\n\n        **fit_params : dict\n          Additional parameters passed to the ``self.train_split``\n          call.\n\n        Returns\n        -------\n        dataset_train\n          The initialized training dataset.\n\n        dataset_valid\n          The initialized validation dataset or None\n\n        \"\"\"\n        dataset = self.get_dataset(X, y)\n        if self.train_split:\n            dataset_train, dataset_valid = self.train_split(\n                dataset, y, **fit_params)\n        else:\n            dataset_train, dataset_valid = dataset, None\n        return dataset_train, dataset_valid"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_iterator(self, dataset, training=False):\n        if training:\n            kwargs = self._get_params_for('iterator_train')\n            iterator = self.iterator_train\n        else:\n            kwargs = self._get_params_for('iterator_valid')\n            iterator = self.iterator_valid\n\n        if 'batch_size' not in kwargs:\n            kwargs['batch_size'] = self.batch_size\n\n        if kwargs['batch_size'] == -1:\n            kwargs['batch_size'] = len(dataset)\n\n        return iterator(dataset, **kwargs)", "response": "Returns an iterator that allows to loop over the batches of the\n            given data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing kwargs configuration for the optimizer identified by the given prefix. Supports wildcards and param group assignment using wildcards.", "response": "def _get_params_for_optimizer(self, prefix, named_parameters):\n        \"\"\"Parse kwargs configuration for the optimizer identified by\n        the given prefix. Supports param group assignment using wildcards:\n\n            optimizer__lr=0.05,\n            optimizer__param_groups=[\n                ('rnn*.period', {'lr': 0.3, 'momentum': 0}),\n                ('rnn0', {'lr': 0.1}),\n            ]\n\n        The first positional argument are the param groups.\n        \"\"\"\n        kwargs = self._get_params_for(prefix)\n        params = list(named_parameters)\n        pgroups = []\n\n        for pattern, group in kwargs.pop('param_groups', []):\n            matches = [i for i, (name, _) in enumerate(params) if\n                       fnmatch.fnmatch(name, pattern)]\n            if matches:\n                p = [params.pop(i)[1] for i in reversed(matches)]\n                pgroups.append({'params': p, **group})\n\n        if params:\n            pgroups.append({'params': [p for _, p in params]})\n\n        return [pgroups], kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_params_callbacks(self, deep=True):\n        params = {}\n        if not deep:\n            return params\n\n        callbacks_ = getattr(self, 'callbacks_', [])\n        for key, val in chain(callbacks_, self._default_callbacks):\n            name = 'callbacks__' + key\n            params[name] = val\n            if val is None:  # callback deactivated\n                continue\n            for subkey, subval in val.get_params().items():\n                subname = name + '__' + subkey\n                params[subname] = subval\n        return params", "response": "Get the parameters of the callbacks_ attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_params(self, **kwargs):\n        self._check_deprecated_params(**kwargs)\n        normal_params, cb_params, special_params = {}, {}, {}\n        virtual_params = {}\n\n        for key, val in kwargs.items():\n            if self._is_virtual_param(key):\n                virtual_params[key] = val\n            elif key.startswith('callbacks'):\n                cb_params[key] = val\n            elif any(key.startswith(prefix) for prefix in self.prefixes_):\n                special_params[key] = val\n            else:\n                normal_params[key] = val\n\n        self._apply_virtual_params(virtual_params)\n        BaseEstimator.set_params(self, **normal_params)\n\n        for key, val in special_params.items():\n            if key.endswith('_'):\n                raise ValueError(\n                    \"Something went wrong here. Please open an issue on \"\n                    \"https://github.com/dnouri/skorch/issues detailing what \"\n                    \"caused this error.\")\n            else:\n                setattr(self, key, val)\n\n        # Below: Re-initialize parts of the net if necessary.\n\n        if cb_params:\n            # callbacks need special treatmeant since they are list of tuples\n            self.initialize_callbacks()\n            self._set_params_callback(**cb_params)\n\n        if any(key.startswith('criterion') for key in special_params):\n            self.initialize_criterion()\n\n        module_triggers_optimizer_reinit = False\n        if any(key.startswith('module') for key in special_params):\n            self.initialize_module()\n            module_triggers_optimizer_reinit = True\n\n        optimizer_changed = (\n            any(key.startswith('optimizer') for key in special_params) or\n            'lr' in normal_params\n        )\n        if module_triggers_optimizer_reinit or optimizer_changed:\n            # Model selectors such as GridSearchCV will set the\n            # parameters before .initialize() is called, therefore we\n            # need to make sure that we have an initialized model here\n            # as the optimizer depends on it.\n            if not hasattr(self, 'module_'):\n                self.initialize_module()\n\n            # If we reached this point but the optimizer was not\n            # changed, it means that optimizer initialization was\n            # triggered indirectly.\n            self.initialize_optimizer(triggered_directly=optimizer_changed)\n\n        vars(self).update(kwargs)\n\n        return self", "response": "Set the parameters of this class."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_params_callback(self, **params):\n        # model after sklearn.utils._BaseCompostion._set_params\n        # 1. All steps\n        if 'callbacks' in params:\n            setattr(self, 'callbacks', params.pop('callbacks'))\n\n        # 2. Step replacement\n        names, _ = zip(*getattr(self, 'callbacks_'))\n        for key in params.copy():\n            name = key[11:]  # drop 'callbacks__'\n            if '__' not in name and name in names:\n                self._replace_callback(name, params.pop(key))\n\n        # 3. Step parameters and other initilisation arguments\n        for key in params.copy():\n            name = key[11:]\n            part0, part1 = name.split('__')\n            kwarg = {part1: params.pop(key)}\n            callback = dict(self.callbacks_).get(part0)\n            if callback is not None:\n                callback.set_params(**kwarg)\n            else:\n                raise ValueError(\n                    \"Trying to set a parameter for callback {} \"\n                    \"which does not exist.\".format(part0))\n\n        return self", "response": "Special handling for setting params on callbacks."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_params(\n            self, f=None, f_params=None, f_optimizer=None, f_history=None):\n        \"\"\"Saves the module's parameters, history, and optimizer,\n        not the whole object.\n\n        To save the whole object, use pickle.\n\n        ``f_params`` and ``f_optimizer`` uses PyTorchs'\n        :func:`~torch.save`.\n\n        Parameters\n        ----------\n        f_params : file-like object, str, None (default=None)\n          Path of module parameters. Pass ``None`` to not save\n\n        f_optimizer : file-like object, str, None (default=None)\n          Path of optimizer. Pass ``None`` to not save\n\n        f_history : file-like object, str, None (default=None)\n          Path to history. Pass ``None`` to not save\n\n        f : deprecated\n\n        Examples\n        --------\n        >>> before = NeuralNetClassifier(mymodule)\n        >>> before.save_params(f_params='model.pkl',\n        >>>                    f_optimizer='optimizer.pkl',\n        >>>                    f_history='history.json')\n        >>> after = NeuralNetClassifier(mymodule).initialize()\n        >>> after.load_params(f_params='model.pkl',\n        >>>                   f_optimizer='optimizer.pkl',\n        >>>                   f_history='history.json')\n\n        \"\"\"\n\n        # TODO: Remove warning in a future release\n        if f is not None:\n            warnings.warn(\n                \"f argument was renamed to f_params and will be removed \"\n                \"in the next release. To make your code future-proof it is \"\n                \"recommended to explicitly specify keyword arguments' names \"\n                \"instead of relying on positional order.\",\n                DeprecationWarning)\n            f_params = f\n\n        if f_params is not None:\n            if not hasattr(self, 'module_'):\n                raise NotInitializedError(\n                    \"Cannot save parameters of an un-initialized model. \"\n                    \"Please initialize first by calling .initialize() \"\n                    \"or by fitting the model with .fit(...).\")\n            torch.save(self.module_.state_dict(), f_params)\n\n        if f_optimizer is not None:\n            if not hasattr(self, 'optimizer_'):\n                raise NotInitializedError(\n                    \"Cannot save state of an un-initialized optimizer. \"\n                    \"Please initialize first by calling .initialize() \"\n                    \"or by fitting the model with .fit(...).\")\n            torch.save(self.optimizer_.state_dict(), f_optimizer)\n\n        if f_history is not None:\n            self.history.to_file(f_history)", "response": "Saves the parameters of the current module to the given file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_device(self, requested_device, map_device):\n        type_1 = torch.device(requested_device)\n        type_2 = torch.device(map_device)\n        if type_1 != type_2:\n            warnings.warn(\n                'Setting self.device = {} since the requested device ({}) '\n                'is not available.'.format(map_device, requested_device),\n                DeviceWarning)\n            return map_device\n        # return requested_device instead of map_device even though we\n        # checked for *type* equality as we might have 'cuda:0' vs. 'cuda:1'.\n        return requested_device", "response": "Compare the requested device with the map device and return the requested device if it differs from the map device and a warning if it is not available."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_params(\n            self, f=None, f_params=None, f_optimizer=None, f_history=None,\n            checkpoint=None):\n        \"\"\"Loads the the module's parameters, history, and optimizer,\n        not the whole object.\n\n        To save and load the whole object, use pickle.\n\n        ``f_params`` and ``f_optimizer`` uses PyTorchs'\n        :func:`~torch.save`.\n\n        Parameters\n        ----------\n        f_params : file-like object, str, None (default=None)\n          Path of module parameters. Pass ``None`` to not load.\n\n        f_optimizer : file-like object, str, None (default=None)\n          Path of optimizer. Pass ``None`` to not load.\n\n        f_history : file-like object, str, None (default=None)\n          Path to history. Pass ``None`` to not load.\n\n        checkpoint : :class:`.Checkpoint`, None (default=None)\n          Checkpoint to load params from. If a checkpoint and a ``f_*``\n          path is passed in, the ``f_*`` will be loaded. Pass\n          ``None`` to not load.\n\n        f : deprecated\n\n        Examples\n        --------\n        >>> before = NeuralNetClassifier(mymodule)\n        >>> before.save_params(f_params='model.pkl',\n        >>>                    f_optimizer='optimizer.pkl',\n        >>>                    f_history='history.json')\n        >>> after = NeuralNetClassifier(mymodule).initialize()\n        >>> after.load_params(f_params='model.pkl',\n        >>>                   f_optimizer='optimizer.pkl',\n        >>>                   f_history='history.json')\n\n        \"\"\"\n        def _get_state_dict(f):\n            map_location = get_map_location(self.device)\n            self.device = self._check_device(self.device, map_location)\n            return torch.load(f, map_location=map_location)\n\n        # TODO: Remove warning in a future release\n        if f is not None:\n            warnings.warn(\n                \"f is deprecated in save_params and will be removed in the \"\n                \"next release, please use f_params instead\",\n                DeprecationWarning)\n            f_params = f\n\n        if f_history is not None:\n            self.history = History.from_file(f_history)\n\n        if checkpoint is not None:\n            if f_history is None and checkpoint.f_history is not None:\n                self.history = History.from_file(checkpoint.f_history_)\n            formatted_files = checkpoint.get_formatted_files(self)\n            f_params = f_params or formatted_files['f_params']\n            f_optimizer = f_optimizer or formatted_files['f_optimizer']\n\n        if f_params is not None:\n            if not hasattr(self, 'module_'):\n                raise NotInitializedError(\n                    \"Cannot load parameters of an un-initialized model. \"\n                    \"Please initialize first by calling .initialize() \"\n                    \"or by fitting the model with .fit(...).\")\n            state_dict = _get_state_dict(f_params)\n            self.module_.load_state_dict(state_dict)\n\n        if f_optimizer is not None:\n            if not hasattr(self, 'optimizer_'):\n                raise NotInitializedError(\n                    \"Cannot load state of an un-initialized optimizer. \"\n                    \"Please initialize first by calling .initialize() \"\n                    \"or by fitting the model with .fit(...).\")\n            state_dict = _get_state_dict(f_optimizer)\n            self.optimizer_.load_state_dict(state_dict)", "response": "Loads the module s parameters history and optimizer and model."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the history of the NeuralNet to a json file.", "response": "def save_history(self, f):\n        \"\"\"Saves the history of ``NeuralNet`` as a json file. In order\n        to use this feature, the history must only contain JSON encodable\n        Python data structures. Numpy and PyTorch types should not\n        be in the history.\n\n        Parameters\n        ----------\n        f : file-like object or str\n\n        Examples\n        --------\n\n        >>> before = NeuralNetClassifier(mymodule)\n        >>> before.fit(X, y, epoch=2) # Train for 2 epochs\n        >>> before.save_params('path/to/params')\n        >>> before.save_history('path/to/history.json')\n        >>> after = NeuralNetClassifier(mymodule).initialize()\n        >>> after.load_params('path/to/params')\n        >>> after.load_history('path/to/history.json')\n        >>> after.fit(X, y, epoch=2) # Train for another 2 epochs\n\n        \"\"\"\n        # TODO: Remove warning in a future release\n        warnings.warn(\n            \"save_history is deprecated and will be removed in the next \"\n            \"release, please use save_params with the f_history keyword\",\n            DeprecationWarning)\n\n        self.history.to_file(f)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_history(self, f):\n        # TODO: Remove warning in a future release\n        warnings.warn(\n            \"load_history is deprecated and will be removed in the next \"\n            \"release, please use load_params with the f_history keyword\",\n            DeprecationWarning)\n\n        self.history = History.from_file(f)", "response": "Load the history of a NeuralNet from a json file. See load_history for examples."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _filter_none(items):\n    type_ = list if isinstance(items, list) else tuple\n    return type_(filter(_not_none, items))", "response": "Filter special placeholder value preserves sequence type."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nunpacks index and return exactly four elements.", "response": "def _unpack_index(i):\n    \"\"\"Unpack index and return exactly four elements.\n\n    If index is more shallow than 4, return None for trailing\n    dimensions. If index is deeper than 4, raise a KeyError.\n\n    \"\"\"\n    if len(i) > 4:\n        raise KeyError(\n            \"Tried to index history with {} indices but only \"\n            \"4 indices are possible.\".format(len(i)))\n\n    # fill trailing indices with None\n    i_e, k_e, i_b, k_b = i + tuple([None] * (4 - len(i)))\n\n    # handle special case of\n    # history[j, 'batches', somekey]\n    # which should really be\n    # history[j, 'batches', :, somekey]\n    if i_b is not None and not isinstance(i_b, (int, slice)):\n        if k_b is not None:\n            raise KeyError(\"The last argument '{}' is invalid; it must be a \"\n                           \"string or tuple of strings.\".format(k_b))\n        warnings.warn(\n            \"Argument 3 to history slicing must be of type int or slice, e.g. \"\n            \"history[:, 'batches', 'train_loss'] should be \"\n            \"history[:, 'batches', :, 'train_loss'].\",\n            DeprecationWarning,\n        )\n        i_b, k_b = slice(None), i_b\n\n    return i_e, k_e, i_b, k_b"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef record(self, attr, value):\n        msg = \"Call new_epoch before recording for the first time.\"\n        if not self:\n            raise ValueError(msg)\n        self[-1][attr] = value", "response": "Add a new value to the given column for the current ISO epoch."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the history of a NeuralNet from a json file.", "response": "def from_file(cls, f):\n        \"\"\"Load the history of a ``NeuralNet`` from a json file.\n\n        Parameters\n        ----------\n        f : file-like object or str\n\n        \"\"\"\n\n        with open_file_like(f, 'r') as fp:\n            return cls(json.load(fp))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the history as a json file.", "response": "def to_file(self, f):\n        \"\"\"Saves the history as a json file. In order to use this feature,\n        the history must only contain JSON encodable Python data structures.\n        Numpy and PyTorch types should not be in the history.\n\n        Parameters\n        ----------\n        f : file-like object or str\n\n        \"\"\"\n        with open_file_like(f, 'w') as fp:\n            json.dump(self.to_list(), fp)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the model. This function saves some or all of the following: - model parameters; - optimizer state; - training history; - entire model object.", "response": "def save_model(self, net):\n        \"\"\"Save the model.\n\n        This function saves some or all of the following:\n\n          - model parameters;\n          - optimizer state;\n          - training history;\n          - entire model object.\n        \"\"\"\n        if self.f_params is not None:\n            f = self._format_target(net, self.f_params, -1)\n            self._save_params(f, net, \"f_params\", \"model parameters\")\n\n        if self.f_optimizer is not None:\n            f = self._format_target(net, self.f_optimizer, -1)\n            self._save_params(f, net, \"f_optimizer\", \"optimizer state\")\n\n        if self.f_history is not None:\n            f = self.f_history_\n            self._save_params(f, net, \"f_history\", \"history\")\n\n        if self.f_pickle:\n            f_pickle = self._format_target(net, self.f_pickle, -1)\n            with open_file_like(f_pickle, 'wb') as f:\n                pickle.dump(net, f)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dictionary of formatted filenames", "response": "def get_formatted_files(self, net):\n        \"\"\"Returns a dictionary of formatted filenames\"\"\"\n        idx = -1\n        if (\n                self.event_name is not None and\n                net.history\n        ):\n            for i, v in enumerate(net.history[:, self.event_name]):\n                if v:\n                    idx = i\n        return {\n            \"f_params\": self._format_target(net, self.f_params, idx),\n            \"f_optimizer\": self._format_target(net, self.f_optimizer, idx),\n            \"f_history\": self.f_history_,\n            \"f_pickle\": self._format_target(net, self.f_pickle, idx)\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying formatting to the target filename template.", "response": "def _format_target(self, net, f, idx):\n        \"\"\"Apply formatting to the target filename template.\"\"\"\n        if f is None:\n            return None\n        if isinstance(f, str):\n            f = self.fn_prefix + f.format(\n                net=net,\n                last_epoch=net.history[idx],\n                last_batch=net.history[idx, 'batches', -1],\n            )\n            return os.path.join(self.dirname, f)\n        return f"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_filenames(self):\n        if not self.dirname:\n            return\n\n        def _is_truthy_and_not_str(f):\n            return f and not isinstance(f, str)\n\n        if (\n                _is_truthy_and_not_str(self.f_optimizer) or\n                _is_truthy_and_not_str(self.f_params) or\n                _is_truthy_and_not_str(self.f_history) or\n                _is_truthy_and_not_str(self.f_pickle)\n        ):\n            raise SkorchException(\n                'dirname can only be used when f_* are strings')", "response": "Checks if passed filenames are valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetermines new threshold based on score.", "response": "def _calc_new_threshold(self, score):\n        \"\"\"Determine threshold based on score.\"\"\"\n        if self.threshold_mode == 'rel':\n            abs_threshold_change = self.threshold * score\n        else:\n            abs_threshold_change = self.threshold\n\n        if self.lower_is_better:\n            new_threshold = score - abs_threshold_change\n        else:\n            new_threshold = score + abs_threshold_change\n        return new_threshold"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef repackage_hidden(self, h):\n        if isinstance(h, Variable):\n            return torch.tensor(h.data, device=h.device)\n        else:\n            return tuple(self.repackage_hidden(v) for v in h)", "response": "Wraps hidden states in new Variables to detach them from their history."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting param group and param name from the given parameter name.", "response": "def _extract_optimizer_param_name_and_group(optimizer_name, param):\n    \"\"\"Extract param group and param name from the given parameter name.\n    Raises an error if the param name doesn't match one of\n    - ``optimizer__param_groups__<group>__<name>``\n    - ``optimizer__<name>``\n    In the second case group defaults to 'all'.\n    The second case explicitly forbids ``optimizer__foo__bar``\n    since we do not know how to deal with unknown sub-params.\n    \"\"\"\n    pat_1 = '__param_groups__(?P<group>[0-9])__(?P<name>.+)'\n    pat_2 = '__(?!.*__.*)(?P<name>.+)'\n    pat_1 = optimizer_name + pat_1\n    pat_2 = optimizer_name + pat_2\n\n    match_1 = re.compile(pat_1).fullmatch(param)\n    match_2 = re.compile(pat_2).fullmatch(param)\n    match = match_1 or match_2\n\n    if not match:\n        raise AttributeError('Invalid parameter \"{}\" for optimizer \"{}\"'.format(\n            param,\n            optimizer_name,\n        ))\n\n    groups = match.groupdict()\n    param_group = groups.get('group', 'all')\n    param_name = groups['name']\n    return param_group, param_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_optimizer_param(optimizer, param_group, param_name, value):\n    if param_group == 'all':\n        groups = optimizer.param_groups\n    else:\n        groups = [optimizer.param_groups[int(param_group)]]\n\n    for group in groups:\n        group[param_name] = value", "response": "Set a parameter on an optimizer instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the value of the optimizer parameter in the specified object.", "response": "def optimizer_setter(\n        net, param, value, optimizer_attr='optimizer_', optimizer_name='optimizer'\n    ):\n    \"\"\"Handle setting of optimizer parameters such as learning rate and\n    parameter group specific parameters such as momentum.\n\n    The parameters ``optimizer_attr`` and ``optimizer_name`` can be specified\n    if there exists more than one optimizer (e.g., in seq2seq models).\n    \"\"\"\n    if param == 'lr':\n        param_group = 'all'\n        param_name = 'lr'\n        net.lr = value\n    else:\n        param_group, param_name = _extract_optimizer_param_name_and_group(\n            optimizer_name, param)\n\n    _set_optimizer_param(\n        optimizer=getattr(net, optimizer_attr),\n        param_group=param_group,\n        param_name=param_name,\n        value=value\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_lr(name, optimizer, lr):\n    n = len(optimizer.param_groups)\n    if not isinstance(lr, (list, tuple)):\n        return lr * np.ones(n)\n\n    if len(lr) != n:\n        raise ValueError(\"{} lr values were passed for {} but there are \"\n                         \"{} param groups.\".format(n, name, len(lr)))\n    return np.array(lr)", "response": "Check learning rate for each param group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef simulate(self, steps, initial_lr):\n        test = torch.ones(1, requires_grad=True)\n        opt = torch.optim.SGD([{'params': test, 'lr': initial_lr}])\n        policy_cls = self._get_policy_cls()\n        sch = policy_cls(opt, **self.kwargs)\n\n        if hasattr(sch, 'batch_step') and callable(sch.batch_step):\n            step = sch.batch_step\n        else:\n            step = sch.step\n        lrs = []\n        for _ in range(steps):\n            step()\n            lrs.append(sch.get_lr()[0])\n\n        return np.array(lrs)", "response": "Simulates the learning rate scheduler."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns scheduler based on indicated policy with appropriate parameters.", "response": "def _get_scheduler(self, net, policy, **scheduler_kwargs):\n        \"\"\"Return scheduler, based on indicated policy, with appropriate\n        parameters.\n        \"\"\"\n        if policy not in [CyclicLR, ReduceLROnPlateau] and \\\n           'last_epoch' not in scheduler_kwargs:\n            last_epoch = len(net.history) - 1\n            scheduler_kwargs['last_epoch'] = last_epoch\n\n        if policy is CyclicLR and \\\n           'last_batch_idx' not in scheduler_kwargs:\n            scheduler_kwargs['last_batch_idx'] = self.batch_idx_ - 1\n        return policy(net.optimizer_, **scheduler_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the learning rate for the given batch index.", "response": "def batch_step(self, batch_idx=None):\n        \"\"\"Updates the learning rate for the batch index: ``batch_idx``.\n        If ``batch_idx`` is None, ``CyclicLR`` will use an internal\n        batch index to keep track of the index.\n        \"\"\"\n        if batch_idx is None:\n            batch_idx = self.last_batch_idx + 1\n        self.last_batch_idx = batch_idx\n        for param_group, lr in zip(self.optimizer.param_groups, self.get_lr()):\n            param_group['lr'] = lr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_lr(self):\n        cycle = np.floor(1 + self.last_batch_idx / self.total_size)\n        x = 1 + self.last_batch_idx / self.total_size - cycle\n        if x <= self.step_ratio:\n            scale_factor = x / self.step_ratio\n        else:\n            scale_factor = (x-1)/(self.step_ratio-1)\n\n        lrs = []\n        for base_lr, max_lr in zip(self.base_lrs, self.max_lrs):\n            base_height = (max_lr - base_lr) * scale_factor\n            if self.scale_mode == 'cycle':\n                lr = base_lr + base_height * self.scale_fn(cycle)\n            else:\n                lr = base_lr + base_height * self.scale_fn(self.last_batch_idx)\n            lrs.append(lr)\n        return lrs", "response": "Calculates the learning rate at the current batch index."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_verified(self):\n        if self._verified is None:\n            signature = self._data.get('Signature')\n            if not signature:\n                self._verified = False\n                return self._verified\n\n            # Decode the signature from base64\n            signature = bytes(base64.b64decode(signature))\n\n            # Get the message to sign\n            sign_bytes = self._get_bytes_to_sign()\n            if not sign_bytes:\n                self._verified = False\n                return self._verified\n\n            if not self.certificate:\n                self._verified = False\n                return self._verified\n\n            # Extract the public key\n            pkey = self.certificate.get_pubkey()\n\n            # Use the public key to verify the signature.\n            pkey.verify_init()\n            pkey.verify_update(sign_bytes)\n            verify_result = pkey.verify_final(signature)\n\n            self._verified = verify_result == 1\n\n        return self._verified", "response": "Verify an SES bounce message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef certificate(self):\n        if not hasattr(self, '_certificate'):\n            cert_url = self._get_cert_url()\n            # Only load certificates from a certain domain?\n            # Without some kind of trusted domain check, any old joe could\n            # craft a bounce message and sign it using his own certificate\n            # and we would happily load and verify it.\n\n            if not cert_url:\n                self._certificate = None\n                return self._certificate\n\n            try:\n                import requests\n            except ImportError:\n                raise ImproperlyConfigured(\"requests is required for bounce message verification.\")\n\n            try:\n                import M2Crypto\n            except ImportError:\n                raise ImproperlyConfigured(\"M2Crypto is required for bounce message verification.\")\n\n            # We use requests because it verifies the https certificate\n            # when retrieving the signing certificate. If https was somehow\n            # hijacked then all bets are off.\n            response = requests.get(cert_url)\n            if response.status_code != 200:\n                logger.warning(u'Could not download certificate from %s: \"%s\"', cert_url, response.status_code)\n                self._certificate = None\n                return self._certificate\n\n            # Handle errors loading the certificate.\n            # If the certificate is invalid then return\n            # false as we couldn't verify the message.\n            try:\n                self._certificate = M2Crypto.X509.load_cert_string(response.content)\n            except M2Crypto.X509.X509Error as e:\n                logger.warning(u'Could not load certificate from %s: \"%s\"', cert_url, e)\n                self._certificate = None\n\n        return self._certificate", "response": "Retrieves the certificate used to sign the bounce message."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_cert_url(self):\n        cert_url = self._data.get('SigningCertURL')\n        if cert_url:\n            if cert_url.startswith('https://'):\n                url_obj = urlparse(cert_url)\n                for trusted_domain in settings.BOUNCE_CERT_DOMAINS:\n                    parts = trusted_domain.split('.')\n                    if url_obj.netloc.split('.')[-len(parts):] == parts:\n                        return cert_url\n            logger.warning(u'Untrusted certificate URL: \"%s\"', cert_url)\n        else:\n            logger.warning(u'No signing certificate URL: \"%s\"', cert_url)\n        return None", "response": "Get the signing certificate URL."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the bytes to sign for the SNS message.", "response": "def _get_bytes_to_sign(self):\n        \"\"\"\n        Creates the message used for signing SNS notifications.\n        This is used to verify the bounce message when it is received.\n        \"\"\"\n\n        # Depending on the message type the fields to add to the message\n        # differ so we handle that here.\n        msg_type = self._data.get('Type')\n        if msg_type == 'Notification':\n            fields_to_sign = [\n                'Message',\n                'MessageId',\n                'Subject',\n                'Timestamp',\n                'TopicArn',\n                'Type',\n            ]\n        elif (msg_type == 'SubscriptionConfirmation' or\n              msg_type == 'UnsubscribeConfirmation'):\n            fields_to_sign = [\n                'Message',\n                'MessageId',\n                'SubscribeURL',\n                'Timestamp',\n                'Token',\n                'TopicArn',\n                'Type',\n            ]\n        else:\n            # Unrecognized type\n            logger.warning(u'Unrecognized SNS message Type: \"%s\"', msg_type)\n            return None\n\n        outbytes = StringIO()\n        for field_name in fields_to_sign:\n            field_value = smart_str(self._data.get(field_name, ''),\n                                    errors=\"replace\")\n            if field_value:\n                outbytes.write(text(field_name))\n                outbytes.write(text(\"\\n\"))\n                outbytes.write(text(field_value))\n                outbytes.write(text(\"\\n\"))\n\n        response = outbytes.getvalue()\n        return bytes(response, 'utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlimiting a view to superuser only.", "response": "def superuser_only(view_func):\n    \"\"\"\n    Limit a view to superuser only.\n    \"\"\"\n    def _inner(request, *args, **kwargs):\n        if not request.user.is_superuser:\n            raise PermissionDenied\n        return view_func(request, *args, **kwargs)\n    return _inner"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the output of SESConnection. get_send_statistics() in to an anonymized list of 15 - minute summaries.", "response": "def stats_to_list(stats_dict, localize=pytz):\n    \"\"\"\n    Parse the output of ``SESConnection.get_send_statistics()`` in to an\n    ordered list of 15-minute summaries.\n    \"\"\"\n    result = stats_dict['GetSendStatisticsResponse']['GetSendStatisticsResult']\n    # Make a copy, so we don't change the original stats_dict.\n    result = copy.deepcopy(result)\n    datapoints = []\n    if localize:\n        current_tz = localize.timezone(settings.TIME_ZONE)\n    else:\n        current_tz = None\n    for dp in result['SendDataPoints']:\n        if current_tz:\n            utc_dt = datetime.strptime(dp['Timestamp'], '%Y-%m-%dT%H:%M:%SZ')\n            utc_dt = localize.utc.localize(utc_dt)\n            dp['Timestamp'] = current_tz.normalize(\n                utc_dt.astimezone(current_tz))\n        datapoints.append(dp)\n\n    datapoints.sort(key=lambda x: x['Timestamp'])\n\n    return datapoints"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef emails_parse(emails_dict):\n    result = emails_dict['ListVerifiedEmailAddressesResponse'][\n        'ListVerifiedEmailAddressesResult']\n    emails = [email for email in result['VerifiedEmailAddresses']]\n\n    return sorted(emails)", "response": "Parses the output of SESConnection. list_verified_emails and get\n    a list of emails."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sum_stats(stats_data):\n    t_bounces = 0\n    t_complaints = 0\n    t_delivery_attempts = 0\n    t_rejects = 0\n    for dp in stats_data:\n        t_bounces += int(dp['Bounces'])\n        t_complaints += int(dp['Complaints'])\n        t_delivery_attempts += int(dp['DeliveryAttempts'])\n        t_rejects += int(dp['Rejects'])\n\n    return {\n        'Bounces': t_bounces,\n        'Complaints': t_complaints,\n        'DeliveryAttempts': t_delivery_attempts,\n        'Rejects': t_rejects,\n    }", "response": "Summarize the bounces complaints delivery attempts and rejects from a\n    list of datapoints."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngraphing SES send statistics over time.", "response": "def dashboard(request):\n    \"\"\"\n    Graph SES send statistics over time.\n    \"\"\"\n    cache_key = 'vhash:django_ses_stats'\n    cached_view = cache.get(cache_key)\n    if cached_view:\n        return cached_view\n\n    region = RegionInfo(\n        name=settings.AWS_SES_REGION_NAME,\n        endpoint=settings.AWS_SES_REGION_ENDPOINT)\n\n    ses_conn = SESConnection(\n        aws_access_key_id=settings.ACCESS_KEY,\n        aws_secret_access_key=settings.SECRET_KEY,\n        region=region,\n        proxy=settings.AWS_SES_PROXY,\n        proxy_port=settings.AWS_SES_PROXY_PORT,\n    )\n\n    quota_dict = ses_conn.get_send_quota()\n    verified_emails_dict = ses_conn.list_verified_email_addresses()\n    stats = ses_conn.get_send_statistics()\n\n    quota = quota_parse(quota_dict)\n    verified_emails = emails_parse(verified_emails_dict)\n    ordered_data = stats_to_list(stats)\n    summary = sum_stats(ordered_data)\n\n    extra_context = {\n        'title': 'SES Statistics',\n        'datapoints': ordered_data,\n        '24hour_quota': quota['Max24HourSend'],\n        '24hour_sent': quota['SentLast24Hours'],\n        '24hour_remaining': float(quota['Max24HourSend']) -\n                            float(quota['SentLast24Hours']),\n        'persecond_rate': quota['MaxSendRate'],\n        'verified_emails': verified_emails,\n        'summary': summary,\n        'access_key': ses_conn.gs_access_key_id,\n        'local_time': True,\n    }\n\n    response = render(request, 'django_ses/send_stats.html', extra_context)\n\n    cache.set(cache_key, response, 60 * 15)  # Cache for 15 minutes\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle_bounce(request):\n\n    raw_json = request.body\n\n    try:\n        notification = json.loads(raw_json.decode('utf-8'))\n    except ValueError as e:\n        # TODO: What kind of response should be returned here?\n        logger.warning(u'Received bounce with bad JSON: \"%s\"', e)\n        return HttpResponseBadRequest()\n\n    # Verify the authenticity of the bounce message.\n    if (settings.VERIFY_BOUNCE_SIGNATURES and\n            not utils.verify_bounce_message(notification)):\n        # Don't send any info back when the notification is not\n        # verified. Simply, don't process it.\n        logger.info(u'Received unverified notification: Type: %s',\n            notification.get('Type'),\n            extra={\n                'notification': notification,\n            },\n        )\n        return HttpResponse()\n\n    if notification.get('Type') in ('SubscriptionConfirmation',\n                                    'UnsubscribeConfirmation'):\n        # Process the (un)subscription confirmation.\n\n        logger.info(u'Received subscription confirmation: TopicArn: %s',\n            notification.get('TopicArn'),\n            extra={\n                'notification': notification,\n            },\n        )\n\n        # Get the subscribe url and hit the url to confirm the subscription.\n        subscribe_url = notification.get('SubscribeURL')\n        try:\n            urlopen(subscribe_url).read()\n        except URLError as e:\n            # Some kind of error occurred when confirming the request.\n            logger.error(u'Could not confirm subscription: \"%s\"', e,\n                extra={\n                    'notification': notification,\n                },\n                exc_info=True,\n            )\n    elif notification.get('Type') == 'Notification':\n        try:\n            message = json.loads(notification['Message'])\n        except ValueError as e:\n            # The message isn't JSON.\n            # Just ignore the notification.\n            logger.warning(u'Received bounce with bad JSON: \"%s\"', e, extra={\n                'notification': notification,\n            })\n        else:\n            mail_obj = message.get('mail')\n            notification_type = message.get('notificationType')\n\n            if notification_type == 'Bounce':\n                # Bounce\n                bounce_obj = message.get('bounce', {})\n\n                # Logging\n                feedback_id = bounce_obj.get('feedbackId')\n                bounce_type = bounce_obj.get('bounceType')\n                bounce_subtype = bounce_obj.get('bounceSubType')\n                logger.info(\n                    u'Received bounce notification: feedbackId: %s, bounceType: %s, bounceSubType: %s',\n                    feedback_id, bounce_type, bounce_subtype,\n                    extra={\n                        'notification': notification,\n                    },\n                )\n\n                signals.bounce_received.send(\n                    sender=handle_bounce,\n                    mail_obj=mail_obj,\n                    bounce_obj=bounce_obj,\n                    raw_message=raw_json,\n                )\n            elif notification_type == 'Complaint':\n                # Complaint\n                complaint_obj = message.get('complaint', {})\n\n                # Logging\n                feedback_id = complaint_obj.get('feedbackId')\n                feedback_type = complaint_obj.get('complaintFeedbackType')\n                logger.info(u'Received complaint notification: feedbackId: %s, feedbackType: %s',\n                    feedback_id, feedback_type,\n                    extra={\n                        'notification': notification,\n                    },\n                )\n\n                signals.complaint_received.send(\n                    sender=handle_bounce,\n                    mail_obj=mail_obj,\n                    complaint_obj=complaint_obj,\n                    raw_message=raw_json,\n                )\n            elif notification_type == 'Delivery':\n                # Delivery\n                delivery_obj = message.get('delivery', {})\n\n                # Logging\n                feedback_id = delivery_obj.get('feedbackId')\n                feedback_type = delivery_obj.get('deliveryFeedbackType')\n                logger.info(u'Received delivery notification: feedbackId: %s, feedbackType: %s',\n                    feedback_id, feedback_type,\n                    extra={\n                        'notification': notification,\n                    },\n                )\n\n                signals.delivery_received.send(\n                    sender=handle_bounce,\n                    mail_obj=mail_obj,\n                    delivery_obj=delivery_obj,\n                    raw_message=raw_json,\n                )\n            else:\n                # We received an unknown notification type. Just log and\n                # ignore it.\n                logger.warning(u\"Received unknown notification\", extra={\n                    'notification': notification,\n                })\n    else:\n        logger.info(u'Received unknown notification type: %s',\n            notification.get('Type'),\n            extra={\n                'notification': notification,\n            },\n        )\n\n    # AWS will consider anything other than 200 to be an error response and\n    # resend the SNS request. We don't need that so we return 200 here.\n    return HttpResponse()", "response": "Handle a bounced email via an SNS webhook."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning signed email message if dkim package and settings are available.", "response": "def dkim_sign(message, dkim_domain=None, dkim_key=None, dkim_selector=None, dkim_headers=None):\n    \"\"\"Return signed email message if dkim package and settings are available.\"\"\"\n    try:\n        import dkim\n    except ImportError:\n        pass\n    else:\n        if dkim_domain and dkim_key:\n            sig = dkim.sign(message,\n                            dkim_selector,\n                            dkim_domain,\n                            dkim_key,\n                            include_headers=dkim_headers)\n            message = sig + message\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open(self):\n        if self.connection:\n            return False\n\n        try:\n            self.connection = SESConnection(\n                aws_access_key_id=self._access_key_id,\n                aws_secret_access_key=self._access_key,\n                region=self._region,\n                proxy=self._proxy,\n                proxy_port=self._proxy_port,\n                proxy_user=self._proxy_user,\n                proxy_pass=self._proxy_pass,\n            )\n        except Exception:\n            if not self.fail_silently:\n                raise", "response": "Open a connection to the AWS API server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        try:\n            self.connection.close()\n            self.connection = None\n        except Exception:\n            if not self.fail_silently:\n                raise", "response": "Close any open HTTP connections to the API server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_messages(self, email_messages):\n        if not email_messages:\n            return\n\n        new_conn_created = self.open()\n        if not self.connection:\n            # Failed silently\n            return\n\n        num_sent = 0\n        source = settings.AWS_SES_RETURN_PATH\n        for message in email_messages:\n            # SES Configuration sets. If the AWS_SES_CONFIGURATION_SET setting\n            # is not None, append the appropriate header to the message so that\n            # SES knows which configuration set it belongs to.\n            #\n            # If settings.AWS_SES_CONFIGURATION_SET is a callable, pass it the\n            # message object and dkim settings and expect it to return a string\n            # containing the SES Configuration Set name.\n            if (settings.AWS_SES_CONFIGURATION_SET and\n                'X-SES-CONFIGURATION-SET' not in message.extra_headers):\n                if callable(settings.AWS_SES_CONFIGURATION_SET):\n                    message.extra_headers[\n                        'X-SES-CONFIGURATION-SET'] = settings.AWS_SES_CONFIGURATION_SET(\n                            message,\n                            dkim_domain=self.dkim_domain,\n                            dkim_key=self.dkim_key,\n                            dkim_selector=self.dkim_selector,\n                            dkim_headers=self.dkim_headers\n                        )\n                else:\n                    message.extra_headers[\n                        'X-SES-CONFIGURATION-SET'] = settings.AWS_SES_CONFIGURATION_SET\n\n            # Automatic throttling. Assumes that this is the only SES client\n            # currently operating. The AWS_SES_AUTO_THROTTLE setting is a\n            # factor to apply to the rate limit, with a default of 0.5 to stay\n            # well below the actual SES throttle.\n            # Set the setting to 0 or None to disable throttling.\n            if self._throttle:\n                global recent_send_times\n\n                now = datetime.now()\n\n                # Get and cache the current SES max-per-second rate limit\n                # returned by the SES API.\n                rate_limit = self.get_rate_limit()\n                logger.debug(u\"send_messages.throttle rate_limit='{}'\".format(rate_limit))\n\n                # Prune from recent_send_times anything more than a few seconds\n                # ago. Even though SES reports a maximum per-second, the way\n                # they enforce the limit may not be on a one-second window.\n                # To be safe, we use a two-second window (but allow 2 times the\n                # rate limit) and then also have a default rate limit factor of\n                # 0.5 so that we really limit the one-second amount in two\n                # seconds.\n                window = 2.0  # seconds\n                window_start = now - timedelta(seconds=window)\n                new_send_times = []\n                for time in recent_send_times:\n                    if time > window_start:\n                        new_send_times.append(time)\n                recent_send_times = new_send_times\n\n                # If the number of recent send times in the last 1/_throttle\n                # seconds exceeds the rate limit, add a delay.\n                # Since I'm not sure how Amazon determines at exactly what\n                # point to throttle, better be safe than sorry and let in, say,\n                # half of the allowed rate.\n                if len(new_send_times) > rate_limit * window * self._throttle:\n                    # Sleep the remainder of the window period.\n                    delta = now - new_send_times[0]\n                    total_seconds = (delta.microseconds + (delta.seconds +\n                                     delta.days * 24 * 3600) * 10**6) / 10**6\n                    delay = window - total_seconds\n                    if delay > 0:\n                        sleep(delay)\n\n                recent_send_times.append(now)\n                # end of throttling\n\n            try:\n                response = self.connection.send_raw_email(\n                    source=source or message.from_email,\n                    destinations=message.recipients(),\n                    raw_message=dkim_sign(message.message().as_string(),\n                                          dkim_key=self.dkim_key,\n                                          dkim_domain=self.dkim_domain,\n                                          dkim_selector=self.dkim_selector,\n                                          dkim_headers=self.dkim_headers)\n                )\n                message.extra_headers['status'] = 200\n                message.extra_headers['message_id'] = response[\n                    'SendRawEmailResponse']['SendRawEmailResult']['MessageId']\n                message.extra_headers['request_id'] = response[\n                    'SendRawEmailResponse']['ResponseMetadata']['RequestId']\n                num_sent += 1\n                if 'X-SES-CONFIGURATION-SET' in message.extra_headers:\n                    logger.debug(u\"send_messages.sent from='{}' recipients='{}' message_id='{}' request_id='{}' ses-configuration-set='{}'\".format(\n                        message.from_email,\n                        \", \".join(message.recipients()),\n                        message.extra_headers['message_id'],\n                        message.extra_headers['request_id'],\n                        message.extra_headers['X-SES-CONFIGURATION-SET']\n                    ))\n                else:\n                    logger.debug(u\"send_messages.sent from='{}' recipients='{}' message_id='{}' request_id='{}'\".format(\n                        message.from_email,\n                        \", \".join(message.recipients()),\n                        message.extra_headers['message_id'],\n                        message.extra_headers['request_id']\n                    ))\n\n            except SESConnection.ResponseError as err:\n                # Store failure information so to post process it if required\n                error_keys = ['status', 'reason', 'body', 'request_id',\n                              'error_code', 'error_message']\n                for key in error_keys:\n                    message.extra_headers[key] = getattr(err, key, None)\n                if not self.fail_silently:\n                    raise\n\n        if new_conn_created:\n            self.close()\n\n        return num_sent", "response": "Sends one or more EmailMessage objects and returns the number of EmailMessages sent."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts set literal tokens to tuples.", "response": "def set_to_tuple(tokens):\n    \"\"\"Converts set literal tokens to tuples.\"\"\"\n    internal_assert(len(tokens) == 1, \"invalid set maker tokens\", tokens)\n    if \"comp\" in tokens or \"list\" in tokens:\n        return \"(\" + tokens[0] + \")\"\n    elif \"test\" in tokens:\n        return \"(\" + tokens[0] + \",)\"\n    else:\n        raise CoconutInternalException(\"invalid set maker item\", tokens[0])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef single_import(path, imp_as):\n    out = []\n\n    parts = path.split(\"./\")  # denotes from ... import ...\n    if len(parts) == 1:\n        imp_from, imp = None, parts[0]\n    else:\n        imp_from, imp = parts\n\n    if imp == imp_as:\n        imp_as = None\n    elif imp.endswith(\".\" + imp_as):\n        if imp_from is None:\n            imp_from = \"\"\n        imp_from += imp.rsplit(\".\" + imp_as, 1)[0]\n        imp, imp_as = imp_as, None\n\n    if imp_from is None and imp == \"sys\":\n        out.append((imp_as if imp_as is not None else imp) + \" = _coconut_sys\")\n    elif imp_as is not None and \".\" in imp_as:\n        fake_mods = imp_as.split(\".\")\n        out.append(import_stmt(imp_from, imp, import_as_var))\n        for i in range(1, len(fake_mods)):\n            mod_name = \".\".join(fake_mods[:i])\n            out.extend((\n                \"try:\",\n                openindent + mod_name,\n                closeindent + \"except:\",\n                openindent + mod_name + ' = _coconut.types.ModuleType(\"' + mod_name + '\")',\n                closeindent + \"else:\",\n                openindent + \"if not _coconut.isinstance(\" + mod_name + \", _coconut.types.ModuleType):\",\n                openindent + mod_name + ' = _coconut.types.ModuleType(\"' + mod_name + '\")' + closeindent * 2,\n            ))\n        out.append(\".\".join(fake_mods) + \" = \" + import_as_var)\n    else:\n        out.append(import_stmt(imp_from, imp, imp_as))\n\n    return out", "response": "Generate a list of statements that will be imported from a fully qualified import and the name to bind it to."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating code for a universal import of imports from imp_from on target.", "response": "def universal_import(imports, imp_from=None, target=\"\"):\n    \"\"\"Generate code for a universal import of imports from imp_from on target.\n    imports = [[imp1], [imp2, as], ...]\"\"\"\n    importmap = []  # [((imp | old_imp, imp, version_check), imp_as), ...]\n    for imps in imports:\n        if len(imps) == 1:\n            imp, imp_as = imps[0], imps[0]\n        else:\n            imp, imp_as = imps\n        if imp_from is not None:\n            imp = imp_from + \"./\" + imp  # marker for from ... import ...\n        old_imp = None\n        path = imp.split(\".\")\n        for i in reversed(range(1, len(path) + 1)):\n            base, exts = \".\".join(path[:i]), path[i:]\n            clean_base = base.replace(\"/\", \"\")\n            if clean_base in py3_to_py2_stdlib:\n                old_imp, version_check = py3_to_py2_stdlib[clean_base]\n                if exts:\n                    old_imp += \".\"\n                    if \"/\" in base and \"/\" not in old_imp:\n                        old_imp += \"/\"  # marker for from ... import ...\n                    old_imp += \".\".join(exts)\n                break\n        if old_imp is None:\n            paths = (imp,)\n        elif not target:  # universal compatibility\n            paths = (old_imp, imp, version_check)\n        elif get_target_info_len2(target) >= version_check:  # if lowest is above, we can safely use new\n            paths = (imp,)\n        elif target.startswith(\"2\"):  # \"2\" and \"27\" can safely use old\n            paths = (old_imp,)\n        elif get_target_info(target) < version_check:  # \"3\" should be compatible with all 3+\n            paths = (old_imp, imp, version_check)\n        else:  # \"35\" and above can safely use new\n            paths = (imp,)\n        importmap.append((paths, imp_as))\n\n    stmts = []\n    for paths, imp_as in importmap:\n        if len(paths) == 1:\n            more_stmts = single_import(paths[0], imp_as)\n            stmts.extend(more_stmts)\n        else:\n            first, second, version_check = paths\n            stmts.append(\"if _coconut_sys.version_info < \" + str(version_check) + \":\")\n            first_stmts = single_import(first, imp_as)\n            first_stmts[0] = openindent + first_stmts[0]\n            first_stmts[-1] += closeindent\n            stmts.extend(first_stmts)\n            stmts.append(\"else:\")\n            second_stmts = single_import(second, imp_as)\n            second_stmts[0] = openindent + second_stmts[0]\n            second_stmts[-1] += closeindent\n            stmts.extend(second_stmts)\n    return \"\\n\".join(stmts)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsplitting function definition arguments.", "response": "def split_args_list(tokens, loc):\n    \"\"\"Splits function definition arguments.\"\"\"\n    req_args, def_args, star_arg, kwd_args, dubstar_arg = [], [], None, [], None\n    pos = 0\n    for arg in tokens:\n        if len(arg) == 1:\n            if arg[0] == \"*\":\n                # star sep (pos = 3)\n                if pos >= 3:\n                    raise CoconutDeferredSyntaxError(\"star separator at invalid position in function definition\", loc)\n                pos = 3\n            else:\n                # pos arg (pos = 0)\n                if pos > 0:\n                    raise CoconutDeferredSyntaxError(\"positional arguments must come first in function definition\", loc)\n                req_args.append(arg[0])\n        elif len(arg) == 2:\n            if arg[0] == \"*\":\n                # star arg (pos = 2)\n                if pos >= 2:\n                    raise CoconutDeferredSyntaxError(\"star argument at invalid position in function definition\", loc)\n                pos = 2\n                star_arg = arg[1]\n            elif arg[0] == \"**\":\n                # dub star arg (pos = 4)\n                if pos == 4:\n                    raise CoconutDeferredSyntaxError(\"double star argument at invalid position in function definition\", loc)\n                pos = 4\n                dubstar_arg = arg[1]\n            else:\n                # def arg (pos = 1)\n                if pos <= 1:\n                    pos = 1\n                    def_args.append((arg[0], arg[1]))\n                # kwd arg (pos = 3)\n                elif pos <= 3:\n                    pos = 3\n                    kwd_args.append((arg[0], arg[1]))\n                else:\n                    raise CoconutDeferredSyntaxError(\"invalid default argument in function definition\", loc)\n        else:\n            raise CoconutInternalException(\"invalid function definition argument\", arg)\n    return req_args, def_args, star_arg, kwd_args, dubstar_arg"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match_case_tokens(loc, tokens, check_var, top):\n    if len(tokens) == 2:\n        matches, stmts = tokens\n        cond = None\n    elif len(tokens) == 3:\n        matches, cond, stmts = tokens\n    else:\n        raise CoconutInternalException(\"invalid case match tokens\", tokens)\n    matching = Matcher(loc, check_var)\n    matching.match(matches, match_to_var)\n    if cond:\n        matching.add_guard(cond)\n    return matching.build(stmts, set_check_var=top)", "response": "Build code for matching the given case."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a hash from code.", "response": "def genhash(self, package, code):\n        \"\"\"Generate a hash from code.\"\"\"\n        return hex(checksum(\n            hash_sep.join(\n                str(item) for item in (VERSION_STR,)\n                + self.__reduce__()[1]\n                + (package, code)\n            ).encode(default_encoding),\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset(self):\n        self.indchar = None\n        self.comments = {}\n        self.refs = []\n        self.set_skips([])\n        self.docstring = \"\"\n        self.ichain_count = 0\n        self.tre_store_count = 0\n        self.case_check_count = 0\n        self.stmt_lambdas = []\n        if self.strict:\n            self.unused_imports = set()\n        self.bind()", "response": "Resets the internal state of the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbinding reference objects to the proper parse actions.", "response": "def bind(self):\n        \"\"\"Binds reference objects to the proper parse actions.\"\"\"\n        self.endline <<= attach(self.endline_ref, self.endline_handle)\n\n        self.moduledoc_item <<= trace(attach(self.moduledoc, self.set_docstring))\n        self.name <<= trace(attach(self.base_name, self.name_check))\n        # comments are evaluated greedily because we need to know about them even if we're going to suppress them\n        self.comment <<= trace(attach(self.comment_ref, self.comment_handle, greedy=True))\n        self.set_literal <<= trace(attach(self.set_literal_ref, self.set_literal_handle))\n        self.set_letter_literal <<= trace(attach(self.set_letter_literal_ref, self.set_letter_literal_handle))\n        self.classlist <<= trace(attach(self.classlist_ref, self.classlist_handle))\n        self.import_stmt <<= trace(attach(self.import_stmt_ref, self.import_handle))\n        self.complex_raise_stmt <<= trace(attach(self.complex_raise_stmt_ref, self.complex_raise_stmt_handle))\n        self.augassign_stmt <<= trace(attach(self.augassign_stmt_ref, self.augassign_handle))\n        self.dict_comp <<= trace(attach(self.dict_comp_ref, self.dict_comp_handle))\n        self.destructuring_stmt <<= trace(attach(self.destructuring_stmt_ref, self.destructuring_stmt_handle))\n        self.name_match_funcdef <<= trace(attach(self.name_match_funcdef_ref, self.name_match_funcdef_handle))\n        self.op_match_funcdef <<= trace(attach(self.op_match_funcdef_ref, self.op_match_funcdef_handle))\n        self.yield_from <<= trace(attach(self.yield_from_ref, self.yield_from_handle))\n        self.exec_stmt <<= trace(attach(self.exec_stmt_ref, self.exec_stmt_handle))\n        self.stmt_lambdef <<= trace(attach(self.stmt_lambdef_ref, self.stmt_lambdef_handle))\n        self.typedef <<= trace(attach(self.typedef_ref, self.typedef_handle))\n        self.typedef_default <<= trace(attach(self.typedef_default_ref, self.typedef_handle))\n        self.unsafe_typedef_default <<= trace(attach(self.unsafe_typedef_default_ref, self.unsafe_typedef_handle))\n        self.return_typedef <<= trace(attach(self.return_typedef_ref, self.typedef_handle))\n        self.typed_assign_stmt <<= trace(attach(self.typed_assign_stmt_ref, self.typed_assign_stmt_handle))\n        self.datadef <<= trace(attach(self.datadef_ref, self.data_handle))\n        self.with_stmt <<= trace(attach(self.with_stmt_ref, self.with_stmt_handle))\n        self.await_item <<= trace(attach(self.await_item_ref, self.await_item_handle))\n        self.ellipsis <<= trace(attach(self.ellipsis_ref, self.ellipsis_handle))\n        self.case_stmt <<= trace(attach(self.case_stmt_ref, self.case_stmt_handle))\n\n        self.decoratable_normal_funcdef_stmt <<= trace(attach(\n            self.decoratable_normal_funcdef_stmt_ref,\n            self.decoratable_funcdef_stmt_handle,\n        ))\n        self.decoratable_async_funcdef_stmt <<= trace(attach(\n            self.decoratable_async_funcdef_stmt_ref,\n            partial(self.decoratable_funcdef_stmt_handle, is_async=True),\n        ))\n\n        self.u_string <<= attach(self.u_string_ref, self.u_string_check)\n        self.matrix_at <<= attach(self.matrix_at_ref, self.matrix_at_check)\n        self.nonlocal_stmt <<= attach(self.nonlocal_stmt_ref, self.nonlocal_check)\n        self.star_assign_item <<= attach(self.star_assign_item_ref, self.star_assign_item_check)\n        self.classic_lambdef <<= attach(self.classic_lambdef_ref, self.lambdef_check)\n        self.star_expr <<= attach(self.star_expr_ref, self.star_expr_check)\n        self.dubstar_expr <<= attach(self.dubstar_expr_ref, self.star_expr_check)\n        self.star_sep_arg <<= attach(self.star_sep_arg_ref, self.star_sep_check)\n        self.star_sep_vararg <<= attach(self.star_sep_vararg_ref, self.star_sep_check)\n        self.endline_semicolon <<= attach(self.endline_semicolon_ref, self.endline_semicolon_check)\n        self.async_stmt <<= attach(self.async_stmt_ref, self.async_stmt_check)\n        self.async_comp_for <<= attach(self.async_comp_for_ref, self.async_comp_check)\n        self.f_string <<= attach(self.f_string_ref, self.f_string_check)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the line skips.", "response": "def set_skips(self, skips):\n        \"\"\"Set the line skips.\"\"\"\n        skips.sort()\n        internal_assert(lambda: len(set(skips)) == len(skips), \"duplicate line skip(s) in skips\", skips)\n        self.skips = skips"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef adjust(self, ln):\n        adj_ln = ln\n        need_unskipped = 0\n        for i in self.skips:\n            if i <= ln:\n                need_unskipped += 1\n            elif adj_ln + need_unskipped < i:\n                break\n            else:\n                need_unskipped -= i - adj_ln - 1\n                adj_ln = i\n        return adj_ln + need_unskipped", "response": "Converts a parsing line number into an original line number."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npost process a preprocessed snippet.", "response": "def reformat(self, snip, index=None):\n        \"\"\"Post process a preprocessed snippet.\"\"\"\n        if index is not None:\n            return self.reformat(snip), len(self.reformat(snip[:index]))\n        else:\n            return self.repl_proc(snip, reformatting=True, log=False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreformats and evaluate a code snippet and return code for the result.", "response": "def eval_now(self, code):\n        \"\"\"Reformat and evaluate a code snippet and return code for the result.\"\"\"\n        result = eval(self.reformat(code))\n        if result is None or isinstance(result, (bool, int, float, complex)):\n            return repr(result)\n        elif isinstance(result, bytes):\n            return \"b\" + self.wrap_str_of(result)\n        elif isinstance(result, str):\n            return self.wrap_str_of(result)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_err(self, errtype, message, original, loc, ln=None, reformat=True, *args, **kwargs):\n        if ln is None:\n            ln = self.adjust(lineno(loc, original))\n        errstr, index = getline(loc, original), col(loc, original) - 1\n        if reformat:\n            errstr, index = self.reformat(errstr, index)\n        return errtype(message, errstr, index, ln, *args, **kwargs)", "response": "Generate an error of the specified type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nraise an error if in strict mode otherwise raises a warning.", "response": "def strict_err_or_warn(self, *args, **kwargs):\n        \"\"\"Raises an error if in strict mode, otherwise raises a warning.\"\"\"\n        if self.strict:\n            raise self.make_err(CoconutStyleError, *args, **kwargs)\n        else:\n            logger.warn_err(self.make_err(CoconutSyntaxWarning, *args, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a reference and returns the identifier.", "response": "def add_ref(self, reftype, data):\n        \"\"\"Add a reference and returns the identifier.\"\"\"\n        ref = (reftype, data)\n        try:\n            index = self.refs.index(ref)\n        except ValueError:\n            self.refs.append(ref)\n            index = len(self.refs) - 1\n        return str(index)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wrap_str_of(self, text):\n        text_repr = ascii(text)\n        internal_assert(text_repr[0] == text_repr[-1] and text_repr[0] in (\"'\", '\"'), \"cannot wrap str of\", text)\n        return self.wrap_str(text_repr[1:-1], text_repr[-1])", "response": "Wrap a string of a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply_procs(self, procs, kwargs, inputstring, log=True):\n        for get_proc in procs:\n            proc = get_proc(self)\n            inputstring = proc(inputstring, **kwargs)\n            if log:\n                logger.log_tag(proc.__name__, inputstring, multiline=True)\n        return inputstring", "response": "Apply processors to inputstring."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pre(self, inputstring, **kwargs):\n        out = self.apply_procs(self.preprocs, kwargs, str(inputstring))\n        logger.log_tag(\"skips\", self.skips)\n        return out", "response": "Perform pre - processing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming post - processing.", "response": "def post(self, result, **kwargs):\n        \"\"\"Perform post-processing.\"\"\"\n        internal_assert(isinstance(result, str), \"got non-string parse result\", result)\n        return self.apply_procs(self.postprocs, kwargs, result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a formatted header.", "response": "def getheader(self, which, use_hash=None, polish=True):\n        \"\"\"Get a formatted header.\"\"\"\n        header = getheader(\n            which,\n            use_hash=use_hash,\n            target=self.target,\n            no_tco=self.no_tco,\n            strict=self.strict,\n        )\n        if polish:\n            header = self.polish(header)\n        return header"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_syntax_err(self, err, original):\n        msg, loc = err.args\n        return self.make_err(CoconutSyntaxError, msg, original, loc)", "response": "Make a CoconutSyntaxError from a CoconutDeferredSyntaxError."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_parse_err(self, err, reformat=True, include_ln=True):\n        err_line = err.line\n        err_index = err.col - 1\n        err_lineno = err.lineno if include_ln else None\n        if reformat:\n            err_line, err_index = self.reformat(err_line, err_index)\n            if err_lineno is not None:\n                err_lineno = self.adjust(err_lineno)\n        return CoconutParseError(None, err_line, err_index, err_lineno)", "response": "Make a CoconutParseError from a ParseBaseException."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing the parser to parse the inputstring with appropriate setup and teardown.", "response": "def parse(self, inputstring, parser, preargs, postargs):\n        \"\"\"Use the parser to parse the inputstring with appropriate setup and teardown.\"\"\"\n        self.reset()\n        pre_procd = None\n        with logger.gather_parsing_stats():\n            try:\n                pre_procd = self.pre(inputstring, **preargs)\n                parsed = parse(parser, pre_procd)\n                out = self.post(parsed, **postargs)\n            except ParseBaseException as err:\n                raise self.make_parse_err(err)\n            except CoconutDeferredSyntaxError as err:\n                internal_assert(pre_procd is not None, \"invalid deferred syntax error in pre-processing\", err)\n                raise self.make_syntax_err(err, pre_procd)\n            except RuntimeError as err:\n                raise CoconutException(\n                    str(err), extra=\"try again with --recursion-limit greater than the current \"\n                    + str(sys.getrecursionlimit()),\n                )\n        if self.strict:\n            for name in self.unused_imports:\n                if name != \"*\":\n                    logger.warn(\"found unused import\", name, extra=\"disable --strict to dismiss\")\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prepare(self, inputstring, strip=False, nl_at_eof_check=False, **kwargs):\n        if self.strict and nl_at_eof_check and inputstring and not inputstring.endswith(\"\\n\"):\n            end_index = len(inputstring) - 1 if inputstring else 0\n            raise self.make_err(CoconutStyleError, \"missing new line at end of file\", inputstring, end_index)\n        original_lines = inputstring.splitlines()\n        if self.keep_lines:\n            self.original_lines = original_lines\n        inputstring = \"\\n\".join(original_lines)\n        if strip:\n            inputstring = inputstring.strip()\n        return inputstring", "response": "Prepare a string for processing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess strings and comments.", "response": "def str_proc(self, inputstring, **kwargs):\n        \"\"\"Process strings and comments.\"\"\"\n        out = []\n        found = None  # store of characters that might be the start of a string\n        hold = None\n        # hold = [_comment]:\n        _comment = 0  # the contents of the comment so far\n        # hold = [_contents, _start, _stop]:\n        _contents = 0  # the contents of the string so far\n        _start = 1  # the string of characters that started the string\n        _stop = 2  # store of characters that might be the end of the string\n        skips = self.copy_skips()\n\n        x = 0\n        while x <= len(inputstring):\n            try:\n                c = inputstring[x]\n            except IndexError:\n                internal_assert(x == len(inputstring), \"invalid index in str_proc\", x)\n                c = \"\\n\"\n\n            if hold is not None:\n                if len(hold) == 1:  # hold == [_comment]\n                    if c == \"\\n\":\n                        if self.minify:\n                            if out:\n                                lines = \"\".join(out).splitlines()\n                                lines[-1] = lines[-1].rstrip()\n                                out = [\"\\n\".join(lines)]\n                            out.append(c)\n                        else:\n                            out.append(self.wrap_comment(hold[_comment], reformat=False) + c)\n                        hold = None\n                    else:\n                        hold[_comment] += c\n                elif hold[_stop] is not None:\n                    if c == \"\\\\\":\n                        hold[_contents] += hold[_stop] + c\n                        hold[_stop] = None\n                    elif c == hold[_start][0]:\n                        hold[_stop] += c\n                    elif len(hold[_stop]) > len(hold[_start]):\n                        raise self.make_err(CoconutSyntaxError, \"invalid number of string closes\", inputstring, x, reformat=False)\n                    elif hold[_stop] == hold[_start]:\n                        out.append(self.wrap_str(hold[_contents], hold[_start][0], True))\n                        hold = None\n                        x -= 1\n                    else:\n                        if c == \"\\n\":\n                            if len(hold[_start]) == 1:\n                                raise self.make_err(CoconutSyntaxError, \"linebreak in non-multiline string\", inputstring, x, reformat=False)\n                            else:\n                                skips = addskip(skips, self.adjust(lineno(x, inputstring)))\n                        hold[_contents] += hold[_stop] + c\n                        hold[_stop] = None\n                elif count_end(hold[_contents], \"\\\\\") % 2 == 1:\n                    if c == \"\\n\":\n                        skips = addskip(skips, self.adjust(lineno(x, inputstring)))\n                    hold[_contents] += c\n                elif c == hold[_start]:\n                    out.append(self.wrap_str(hold[_contents], hold[_start], False))\n                    hold = None\n                elif c == hold[_start][0]:\n                    hold[_stop] = c\n                else:\n                    if c == \"\\n\":\n                        if len(hold[_start]) == 1:\n                            raise self.make_err(CoconutSyntaxError, \"linebreak in non-multiline string\", inputstring, x, reformat=False)\n                        else:\n                            skips = addskip(skips, self.adjust(lineno(x, inputstring)))\n                    hold[_contents] += c\n            elif found is not None:\n                if c == found[0]:\n                    found += c\n                elif len(found) == 1:  # found == \"_\"\n                    if c == \"\\n\":\n                        raise self.make_err(CoconutSyntaxError, \"linebreak in non-multiline string\", inputstring, x, reformat=False)\n                    else:\n                        hold = [c, found, None]  # [_contents, _start, _stop]\n                        found = None\n                elif len(found) == 2:  # found == \"__\"\n                    out.append(self.wrap_str(\"\", found[0], False))\n                    found = None\n                    x -= 1\n                elif len(found) == 3:  # found == \"___\"\n                    if c == \"\\n\":\n                        skips = addskip(skips, self.adjust(lineno(x, inputstring)))\n                    hold = [c, found, None]  # [_contents, _start, _stop]\n                    found = None\n                else:\n                    raise self.make_err(CoconutSyntaxError, \"invalid number of string starts\", inputstring, x, reformat=False)\n            elif c == \"#\":\n                hold = [\"\"]  # [_comment]\n            elif c in holds:\n                found = c\n            else:\n                out.append(c)\n            x += 1\n\n        if hold is not None or found is not None:\n            raise self.make_err(CoconutSyntaxError, \"unclosed string\", inputstring, x, reformat=False)\n        else:\n            self.set_skips(skips)\n            return \"\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses the inputstring for statement lambda definitions.", "response": "def stmt_lambda_proc(self, inputstring, **kwargs):\n        \"\"\"Add statement lambda definitions.\"\"\"\n        regexes = []\n        for i in range(len(self.stmt_lambdas)):\n            name = self.stmt_lambda_name(i)\n            regex = compile_regex(r\"\\b%s\\b\" % (name,))\n            regexes.append(regex)\n        out = []\n        for line in inputstring.splitlines():\n            for i, regex in enumerate(regexes):\n                if regex.search(line):\n                    indent, line = split_leading_indent(line)\n                    out.append(indent + self.stmt_lambdas[i])\n            out.append(line)\n        return \"\\n\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget an end line comment.", "response": "def ln_comment(self, ln):\n        \"\"\"Get an end line comment. CoconutInternalExceptions should always be caught and complained.\"\"\"\n        if self.keep_lines:\n            if not 1 <= ln <= len(self.original_lines) + 1:\n                raise CoconutInternalException(\n                    \"out of bounds line number\", ln,\n                    \"not in range [1, \" + str(len(self.original_lines) + 1) + \"]\",\n                )\n            elif ln == len(self.original_lines) + 1:  # trim too large\n                lni = -1\n            else:\n                lni = ln - 1\n        if self.line_numbers and self.keep_lines:\n            if self.minify:\n                comment = str(ln) + \" \" + self.original_lines[lni]\n            else:\n                comment = \" line \" + str(ln) + \": \" + self.original_lines[lni]\n        elif self.keep_lines:\n            if self.minify:\n                comment = self.original_lines[lni]\n            else:\n                comment = \" \" + self.original_lines[lni]\n        elif self.line_numbers:\n            if self.minify:\n                comment = str(ln)\n            else:\n                comment = \" line \" + str(ln)\n        else:\n            return \"\"\n        return self.wrap_comment(comment, reformat=False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef endline_repl(self, inputstring, reformatting=False, **kwargs):\n        out = []\n        ln = 1  # line number\n        for line in inputstring.splitlines():\n            add_one_to_ln = False\n            try:\n                if line.endswith(lnwrapper):\n                    line, index = line[:-1].rsplit(\"#\", 1)\n                    new_ln = self.get_ref(\"ln\", index)\n                    if new_ln < ln:\n                        raise CoconutInternalException(\"line number decreased\", (ln, new_ln))\n                    ln = new_ln\n                    line = line.rstrip()\n                    add_one_to_ln = True\n                if not reformatting or add_one_to_ln:  # add_one_to_ln here is a proxy for whether there was a ln comment or not\n                    line += self.comments.get(ln, \"\")\n                if not reformatting and line.rstrip() and not line.lstrip().startswith(\"#\"):\n                    line += self.ln_comment(ln)\n            except CoconutInternalException as err:\n                complain(err)\n            out.append(line)\n            if add_one_to_ln:\n                ln += 1\n        return \"\\n\".join(out)", "response": "Add end of line comments."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses Python 3. 3 yield from.", "response": "def yield_from_handle(self, tokens):\n        \"\"\"Process Python 3.3 yield from.\"\"\"\n        internal_assert(len(tokens) == 1, \"invalid yield from tokens\", tokens)\n        if self.target_info < (3, 3):\n            return (\n                yield_from_var + \" = \" + tokens[0]\n                + \"\\nfor \" + yield_item_var + \" in \" + yield_from_var + \":\\n\"\n                + openindent + \"yield \" + yield_item_var + \"\\n\" + closeindent\n            )\n        else:\n            return \"yield from \" + tokens[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef endline_handle(self, original, loc, tokens):\n        internal_assert(len(tokens) == 1, \"invalid endline tokens\", tokens)\n        lines = tokens[0].splitlines(True)\n        if self.minify:\n            lines = lines[0]\n        out = []\n        ln = lineno(loc, original)\n        for endline in lines:\n            out.append(self.wrap_line_number(self.adjust(ln)) + endline)\n            ln += 1\n        return \"\".join(out)", "response": "Add line number information to end of line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstoring comment in comments.", "response": "def comment_handle(self, original, loc, tokens):\n        \"\"\"Store comment in comments.\"\"\"\n        internal_assert(len(tokens) == 1, \"invalid comment tokens\", tokens)\n        ln = self.adjust(lineno(loc, original))\n        internal_assert(lambda: ln not in self.comments, \"multiple comments on line\", ln)\n        self.comments[ln] = tokens[0]\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef classlist_handle(self, original, loc, tokens):\n        if len(tokens) == 0:\n            if self.target.startswith(\"3\"):\n                return \"\"\n            else:\n                return \"(_coconut.object)\"\n        elif len(tokens) == 1 and len(tokens[0]) == 1:\n            if \"tests\" in tokens[0]:\n                if self.strict and tokens[0][0] == \"(object)\":\n                    raise self.make_err(CoconutStyleError, \"unnecessary inheriting from object (Coconut does this automatically)\", original, loc)\n                return tokens[0][0]\n            elif \"args\" in tokens[0]:\n                if self.target.startswith(\"3\"):\n                    return tokens[0][0]\n                else:\n                    raise self.make_err(CoconutTargetError, \"found Python 3 keyword class definition\", original, loc, target=\"3\")\n            else:\n                raise CoconutInternalException(\"invalid inner classlist token\", tokens[0])\n        else:\n            raise CoconutInternalException(\"invalid classlist tokens\", tokens)", "response": "Process class inheritance lists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef complex_raise_stmt_handle(self, tokens):\n        internal_assert(len(tokens) == 2, \"invalid raise from tokens\", tokens)\n        if self.target.startswith(\"3\"):\n            return \"raise \" + tokens[0] + \" from \" + tokens[1]\n        else:\n            return (\n                raise_from_var + \" = \" + tokens[0] + \"\\n\"\n                + raise_from_var + \".__cause__ = \" + tokens[1] + \"\\n\"\n                + \"raise \" + raise_from_var\n            )", "response": "Process Python 3 raise from statement."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprocess Python 2. 7 dictionary comprehension.", "response": "def dict_comp_handle(self, loc, tokens):\n        \"\"\"Process Python 2.7 dictionary comprehension.\"\"\"\n        internal_assert(len(tokens) == 3, \"invalid dictionary comprehension tokens\", tokens)\n        if self.target.startswith(\"3\"):\n            key, val, comp = tokens\n            return \"{\" + key + \": \" + val + \" \" + comp + \"}\"\n        else:\n            key, val, comp = tokens\n            return \"dict(((\" + key + \"), (\" + val + \")) \" + comp + \")\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconstruct a pattern - matching error message.", "response": "def pattern_error(self, original, loc, value_var, check_var):\n        \"\"\"Construct a pattern-matching error message.\"\"\"\n        base_line = clean(self.reformat(getline(loc, original)))\n        line_wrap = self.wrap_str_of(base_line)\n        repr_wrap = self.wrap_str_of(ascii(base_line))\n        return (\n            \"if not \" + check_var + \":\\n\" + openindent\n            + match_err_var + ' = _coconut_MatchError(\"pattern-matching failed for \" '\n            + repr_wrap + ' \" in \" + _coconut.repr(_coconut.repr(' + value_var + \")))\\n\"\n            + match_err_var + \".pattern = \" + line_wrap + \"\\n\"\n            + match_err_var + \".value = \" + value_var\n            + \"\\nraise \" + match_err_var + \"\\n\" + closeindent\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef destructuring_stmt_handle(self, original, loc, tokens):\n        internal_assert(len(tokens) == 2, \"invalid destructuring assignment tokens\", tokens)\n        matches, item = tokens\n        out = match_handle(loc, [matches, \"in\", item, None])\n        out += self.pattern_error(original, loc, match_to_var, match_check_var)\n        return out", "response": "Process match assign blocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef name_match_funcdef_handle(self, original, loc, tokens):\n        if len(tokens) == 2:\n            func, matches = tokens\n            cond = None\n        elif len(tokens) == 3:\n            func, matches, cond = tokens\n        else:\n            raise CoconutInternalException(\"invalid match function definition tokens\", tokens)\n        matcher = Matcher(loc, match_check_var)\n\n        req_args, def_args, star_arg, kwd_args, dubstar_arg = split_args_list(matches, loc)\n        matcher.match_function(match_to_args_var, match_to_kwargs_var, req_args + def_args, star_arg, kwd_args, dubstar_arg)\n\n        if cond is not None:\n            matcher.add_guard(cond)\n\n        before_docstring = (\n            \"def \" + func\n            + \"(*\" + match_to_args_var + \", **\" + match_to_kwargs_var + \"):\\n\"\n            + openindent\n        )\n        after_docstring = (\n            match_check_var + \" = False\\n\"\n            + matcher.out()\n            # we only include match_to_args_var here because match_to_kwargs_var is modified during matching\n            + self.pattern_error(original, loc, match_to_args_var, match_check_var) + closeindent\n        )\n        return before_docstring, after_docstring", "response": "Process match defs. Result must be passed to insert_docstring_handle."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef op_match_funcdef_handle(self, original, loc, tokens):\n        if len(tokens) == 3:\n            func, args = get_infix_items(tokens)\n            cond = None\n        elif len(tokens) == 4:\n            func, args = get_infix_items(tokens[:-1])\n            cond = tokens[-1]\n        else:\n            raise CoconutInternalException(\"invalid infix match function definition tokens\", tokens)\n        name_tokens = [func, args]\n        if cond is not None:\n            name_tokens.append(cond)\n        return self.name_match_funcdef_handle(original, loc, name_tokens)", "response": "Process infix match defs. Result must be passed to insert_docstring_handle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_literal_handle(self, tokens):\n        internal_assert(len(tokens) == 1 and len(tokens[0]) == 1, \"invalid set literal tokens\", tokens)\n        if self.target_info < (2, 7):\n            return \"_coconut.set(\" + set_to_tuple(tokens[0]) + \")\"\n        else:\n            return \"{\" + tokens[0][0] + \"}\"", "response": "Converts set literals to the right form for the target Python."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing Python - 3 - style exec statements.", "response": "def exec_stmt_handle(self, tokens):\n        \"\"\"Process Python-3-style exec statements.\"\"\"\n        internal_assert(1 <= len(tokens) <= 3, \"invalid exec statement tokens\", tokens)\n        if self.target.startswith(\"2\"):\n            out = \"exec \" + tokens[0]\n            if len(tokens) > 1:\n                out += \" in \" + \", \".join(tokens[1:])\n            return out\n        else:\n            return \"exec(\" + \", \".join(tokens) + \")\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the next statement lambda name.", "response": "def stmt_lambda_name(self, index=None):\n        \"\"\"Return the next (or specified) statement lambda name.\"\"\"\n        if index is None:\n            index = len(self.stmt_lambdas)\n        return stmt_lambda_var + \"_\" + str(index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing multi - line lambdef statements.", "response": "def stmt_lambdef_handle(self, original, loc, tokens):\n        \"\"\"Process multi-line lambdef statements.\"\"\"\n        if len(tokens) == 2:\n            params, stmts = tokens\n        elif len(tokens) == 3:\n            params, stmts, last = tokens\n            if \"tests\" in tokens:\n                stmts = stmts.asList() + [\"return \" + last]\n            else:\n                stmts = stmts.asList() + [last]\n        else:\n            raise CoconutInternalException(\"invalid statement lambda tokens\", tokens)\n        name = self.stmt_lambda_name()\n        body = openindent + self.stmt_lambda_proc(\"\\n\".join(stmts)) + closeindent\n        if isinstance(params, str):\n            self.stmt_lambdas.append(\n                \"def \" + name + params + \":\\n\" + body,\n            )\n        else:\n            params.insert(0, name)  # construct match tokens\n            self.stmt_lambdas.append(\n                \"\".join(self.name_match_funcdef_handle(original, loc, params))\n                + body,\n            )\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef complain_on_err(self):\n        try:\n            yield\n        except ParseBaseException as err:\n            complain(self.make_parse_err(err, reformat=False, include_ln=False))\n        except CoconutException as err:\n            complain(err)", "response": "Complain about any parsing - related errors raised inside."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsplit a code block into a docstring and a body.", "response": "def split_docstring(self, block):\n        \"\"\"Split a code block into a docstring and a body.\"\"\"\n        try:\n            first_line, rest_of_lines = block.split(\"\\n\", 1)\n        except ValueError:\n            pass\n        else:\n            raw_first_line = split_leading_trailing_indent(rem_comment(first_line))[1]\n            if match_in(self.just_a_string, raw_first_line):\n                return first_line, rest_of_lines\n        return None, block"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates grammar element that matches a string which is just a TRE return statement.", "response": "def tre_return(self, func_name, func_args, func_store, use_mock=True):\n        \"\"\"Generate grammar element that matches a string which is just a TRE return statement.\"\"\"\n        def tre_return_handle(loc, tokens):\n            internal_assert(len(tokens) == 1, \"invalid tail recursion elimination tokens\", tokens)\n            args = tokens[0][1:-1]  # strip parens\n            # check if there is anything in the arguments that will store a reference\n            # to the current scope, and if so, abort TRE, since it can't handle that\n            if match_in(self.stores_scope, args):\n                return ignore_transform  # this is the only way to make the outer transform call return None\n            if self.no_tco:\n                tco_recurse = \"return \" + func_name + \"(\" + args + \")\"\n            else:\n                tco_recurse = \"return _coconut_tail_call(\" + func_name + (\", \" + args if args else \"\") + \")\"\n            if not func_args or func_args == args:\n                tre_recurse = \"continue\"\n            elif use_mock:\n                tre_recurse = func_args + \" = \" + tre_mock_var + \"(\" + args + \")\" + \"\\ncontinue\"\n            else:\n                tre_recurse = func_args + \" = \" + args + \"\\ncontinue\"\n            return (\n                \"try:\\n\" + openindent\n                + tre_check_var + \" = \" + func_name + \" is \" + func_store + \"\\n\" + closeindent\n                + \"except _coconut.NameError:\\n\" + openindent\n                + tre_check_var + \" = False\\n\" + closeindent\n                + \"if \" + tre_check_var + \":\\n\" + openindent\n                + tre_recurse + \"\\n\" + closeindent\n                + \"else:\\n\" + openindent\n                + tco_recurse + \"\\n\" + closeindent\n            )\n        return attach(\n            self.start_marker + (keyword(\"return\") + keyword(func_name)).suppress() + self.parens + self.end_marker,\n            tre_return_handle,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply TCO TRE or async universalization to the given function.", "response": "def transform_returns(self, raw_lines, tre_return_grammar=None, use_mock=None, is_async=False):\n        \"\"\"Apply TCO, TRE, or async universalization to the given function.\"\"\"\n        lines = []  # transformed lines\n        tco = False  # whether tco was done\n        tre = False  # whether tre was done\n        level = 0  # indentation level\n        disabled_until_level = None  # whether inside of a disabled block\n        attempt_tre = tre_return_grammar is not None  # whether to even attempt tre\n        attempt_tco = not is_async and not self.no_tco  # whether to even attempt tco\n\n        if is_async:\n            internal_assert(not attempt_tre and not attempt_tco, \"cannot tail call optimize async functions\")\n\n        for line in raw_lines:\n            indent, body, dedent = split_leading_trailing_indent(line)\n            base, comment = split_comment(body)\n\n            level += ind_change(indent)\n\n            if disabled_until_level is not None:\n                if level <= disabled_until_level:\n                    disabled_until_level = None\n\n            if disabled_until_level is None:\n\n                # tco and tre don't support generators\n                if not is_async and self.yield_regex.search(body):\n                    lines = raw_lines  # reset lines\n                    break\n\n                # don't touch inner functions\n                elif self.def_regex.match(body):\n                    disabled_until_level = level\n\n                # tco and tre shouldn't touch scopes that depend on actual return statements\n                #  or scopes where we can't insert a continue\n                elif not is_async and self.tre_disable_regex.match(body):\n                    disabled_until_level = level\n\n                else:\n\n                    if is_async:\n                        if self.return_regex.match(base):\n                            to_return = base[len(\"return\"):].strip()\n                            if to_return:  # leave empty return statements alone\n                                line = indent + \"raise _coconut.asyncio.Return(\" + to_return + \")\" + comment + dedent\n\n                    tre_base = None\n                    if attempt_tre:\n                        with self.complain_on_err():\n                            tre_base = transform(tre_return_grammar, base)\n                        if tre_base is not None:\n                            line = indent + tre_base + comment + dedent\n                            tre = True\n                            # when tco is available, tre falls back on it if the function is changed\n                            tco = not self.no_tco\n\n                    if attempt_tco and tre_base is None:  # don't attempt tco if tre succeeded\n                        tco_base = None\n                        with self.complain_on_err():\n                            tco_base = transform(self.tco_return, base)\n                        if tco_base is not None:\n                            line = indent + tco_base + comment + dedent\n                            tco = True\n\n            level += ind_change(dedent)\n            lines.append(line)\n\n        func_code = \"\".join(lines)\n        if is_async:\n            return func_code\n        else:\n            return func_code, tco, tre"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining if TCO or TRE can be done and if so does it and if so handles dotted function names and universalizes async functions.", "response": "def decoratable_funcdef_stmt_handle(self, original, loc, tokens, is_async=False):\n        \"\"\"Determines if TCO or TRE can be done and if so does it,\n        handles dotted function names, and universalizes async functions.\"\"\"\n        if len(tokens) == 1:\n            decorators, funcdef = \"\", tokens[0]\n        elif len(tokens) == 2:\n            decorators, funcdef = tokens\n        else:\n            raise CoconutInternalException(\"invalid function definition tokens\", tokens)\n\n        # extract information about the function\n        raw_lines = funcdef.splitlines(True)\n        def_stmt = raw_lines.pop(0)\n        func_name, func_args, func_params = None, None, None\n        with self.complain_on_err():\n            func_name, func_args, func_params = parse(self.split_func_name_args_params, def_stmt)\n\n        undotted_name = None  # the function __name__ if func_name is a dotted name\n        if func_name is not None:\n            if \".\" in func_name:\n                undotted_name = func_name.rsplit(\".\", 1)[-1]\n                def_stmt = def_stmt.replace(func_name, undotted_name)\n\n        # handle async functions\n        if is_async:\n            if not self.target:\n                raise self.make_err(\n                    CoconutTargetError,\n                    \"async function definition requires a specific target\",\n                    original, loc,\n                    target=\"sys\",\n                )\n            elif self.target_info >= (3, 5):\n                def_stmt = \"async \" + def_stmt\n            else:\n                decorators += \"@_coconut.asyncio.coroutine\\n\"\n\n            # only Python 3.3+ supports returning values inside generators\n            if self.target_info < (3, 3):\n                func_code = self.transform_returns(raw_lines, is_async=True)\n            else:\n                func_code = \"\".join(raw_lines)\n\n        # handle normal functions\n        else:\n            # tre does not work with decorators, though tco does\n            attempt_tre = func_name is not None and not decorators\n            if attempt_tre:\n                use_mock = func_args and func_args != func_params[1:-1]\n                func_store = tre_store_var + \"_\" + str(self.tre_store_count)\n                self.tre_store_count += 1\n                tre_return_grammar = self.tre_return(func_name, func_args, func_store, use_mock)\n            else:\n                use_mock = func_store = tre_return_grammar = None\n\n            func_code, tco, tre = self.transform_returns(\n                raw_lines,\n                tre_return_grammar,\n                use_mock,\n            )\n\n            if tre:\n                comment, rest = split_leading_comment(func_code)\n                indent, base, dedent = split_leading_trailing_indent(rest, 1)\n                base, base_dedent = split_trailing_indent(base)\n                docstring, base = self.split_docstring(base)\n                func_code = (\n                    comment + indent\n                    + (docstring + \"\\n\" if docstring is not None else \"\")\n                    + (\n                        \"def \" + tre_mock_var + func_params + \": return \" + func_args + \"\\n\"\n                        if use_mock else \"\"\n                    ) + \"while True:\\n\"\n                        + openindent + base + base_dedent\n                        + (\"\\n\" if \"\\n\" not in base_dedent else \"\") + \"return None\"\n                        + (\"\\n\" if \"\\n\" not in dedent else \"\") + closeindent + dedent\n                    + func_store + \" = \" + (func_name if undotted_name is None else undotted_name) + \"\\n\"\n                )\n            if tco:\n                decorators += \"@_coconut_tco\\n\"  # binds most tightly\n\n        out = decorators + def_stmt + func_code\n        if undotted_name is not None:\n            out += func_name + \" = \" + undotted_name + \"\\n\"\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef await_item_handle(self, original, loc, tokens):\n        internal_assert(len(tokens) == 1, \"invalid await statement tokens\", tokens)\n        if not self.target:\n            self.make_err(\n                CoconutTargetError,\n                \"await requires a specific target\",\n                original, loc,\n                target=\"sys\",\n            )\n        elif self.target_info >= (3, 5):\n            return \"await \" + tokens[0]\n        elif self.target_info >= (3, 3):\n            return \"(yield from \" + tokens[0] + \")\"\n        else:\n            return \"(yield _coconut.asyncio.From(\" + tokens[0] + \"))\"", "response": "Check for Python 3. 5 await expression."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing Python 3 type annotations.", "response": "def typedef_handle(self, tokens):\n        \"\"\"Process Python 3 type annotations.\"\"\"\n        if len(tokens) == 1:  # return typedef\n            if self.target.startswith(\"3\"):\n                return \" -> \" + self.wrap_typedef(tokens[0]) + \":\"\n            else:\n                return \":\\n\" + self.wrap_comment(\" type: (...) -> \" + tokens[0])\n        else:  # argument typedef\n            if len(tokens) == 3:\n                varname, typedef, comma = tokens\n                default = \"\"\n            elif len(tokens) == 4:\n                varname, typedef, default, comma = tokens\n            else:\n                raise CoconutInternalException(\"invalid type annotation tokens\", tokens)\n            if self.target.startswith(\"3\"):\n                return varname + \": \" + self.wrap_typedef(typedef) + default + comma\n            else:\n                return varname + default + comma + self.wrap_passthrough(self.wrap_comment(\" type: \" + typedef) + \"\\n\" + \" \" * self.tabideal)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing Python 3. 6 variable type annotations.", "response": "def typed_assign_stmt_handle(self, tokens):\n        \"\"\"Process Python 3.6 variable type annotations.\"\"\"\n        if len(tokens) == 2:\n            if self.target_info >= (3, 6):\n                return tokens[0] + \": \" + self.wrap_typedef(tokens[1])\n            else:\n                return tokens[0] + \" = None\" + self.wrap_comment(\" type: \" + tokens[1])\n        elif len(tokens) == 3:\n            if self.target_info >= (3, 6):\n                return tokens[0] + \": \" + self.wrap_typedef(tokens[1]) + \" = \" + tokens[2]\n            else:\n                return tokens[0] + \" = \" + tokens[2] + self.wrap_comment(\" type: \" + tokens[1])\n        else:\n            raise CoconutInternalException(\"invalid variable type annotation tokens\", tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_strict(self, name, original, loc, tokens):\n        internal_assert(len(tokens) == 1, \"invalid \" + name + \" tokens\", tokens)\n        if self.strict:\n            raise self.make_err(CoconutStyleError, \"found \" + name, original, loc)\n        else:\n            return tokens[0]", "response": "Check that syntax meets strict requirements."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lambdef_check(self, original, loc, tokens):\n        return self.check_strict(\"Python-style lambda\", original, loc, tokens)", "response": "Check for Python - style lambdas."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck for semicolons at the end of line.", "response": "def endline_semicolon_check(self, original, loc, tokens):\n        \"\"\"Check for semicolons at the end of lines.\"\"\"\n        return self.check_strict(\"semicolon at end of line\", original, loc, tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef u_string_check(self, original, loc, tokens):\n        return self.check_strict(\"Python-2-style unicode string\", original, loc, tokens)", "response": "Check for Python 2 - style unicode strings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck for Python - version - specific syntax.", "response": "def check_py(self, version, name, original, loc, tokens):\n        \"\"\"Check for Python-version-specific syntax.\"\"\"\n        internal_assert(len(tokens) == 1, \"invalid \" + name + \" tokens\", tokens)\n        if self.target_info < get_target_info(version):\n            raise self.make_err(CoconutTargetError, \"found Python \" + \".\".join(version) + \" \" + name, original, loc, target=version)\n        else:\n            return tokens[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef name_check(self, original, loc, tokens):\n        internal_assert(len(tokens) == 1, \"invalid name tokens\", tokens)\n        if self.strict:\n            self.unused_imports.discard(tokens[0])\n        if tokens[0] == \"exec\":\n            return self.check_py(\"3\", \"exec function\", original, loc, tokens)\n        elif tokens[0].startswith(reserved_prefix):\n            raise self.make_err(CoconutSyntaxError, \"variable names cannot start with reserved prefix \" + reserved_prefix, original, loc)\n        else:\n            return tokens[0]", "response": "Check the given base name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks for Python 3 nonlocal statement.", "response": "def nonlocal_check(self, original, loc, tokens):\n        \"\"\"Check for Python 3 nonlocal statement.\"\"\"\n        return self.check_py(\"3\", \"nonlocal statement\", original, loc, tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef star_assign_item_check(self, original, loc, tokens):\n        return self.check_py(\"3\", \"starred assignment (add 'match' to front to produce universal code)\", original, loc, tokens)", "response": "Check for Python 3 starred assignment."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks for Python 3. 5 star unpacking.", "response": "def star_expr_check(self, original, loc, tokens):\n        \"\"\"Check for Python 3.5 star unpacking.\"\"\"\n        return self.check_py(\"35\", \"star unpacking (add 'match' to front to produce universal code)\", original, loc, tokens)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks for Python 3 keyword - only arguments.", "response": "def star_sep_check(self, original, loc, tokens):\n        \"\"\"Check for Python 3 keyword-only arguments.\"\"\"\n        return self.check_py(\"3\", \"keyword-only argument separator (add 'match' to front to produce universal code)\", original, loc, tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef matrix_at_check(self, original, loc, tokens):\n        return self.check_py(\"35\", \"matrix multiplication\", original, loc, tokens)", "response": "Check for Python 3. 5 matrix multiplication."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef async_stmt_check(self, original, loc, tokens):\n        return self.check_py(\"35\", \"async for/with\", original, loc, tokens)", "response": "Check for Python 3. 5 async for."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks for Python 3. 6 async comprehension.", "response": "def async_comp_check(self, original, loc, tokens):\n        \"\"\"Check for Python 3.6 async comprehension.\"\"\"\n        return self.check_py(\"36\", \"async comprehension\", original, loc, tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef f_string_check(self, original, loc, tokens):\n        return self.check_py(\"36\", \"format string\", original, loc, tokens)", "response": "Handle Python 3. 6 format strings."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_match_names(match):\n    names = []\n    if \"paren\" in match:\n        (match,) = match\n        names += get_match_names(match)\n    elif \"var\" in match:\n        (setvar,) = match\n        if setvar != wildcard:\n            names.append(setvar)\n    elif \"trailer\" in match:\n        match, trailers = match[0], match[1:]\n        for i in range(0, len(trailers), 2):\n            op, arg = trailers[i], trailers[i + 1]\n            if op == \"as\":\n                names.append(arg)\n        names += get_match_names(match)\n    return names", "response": "Gets the keyword names for the given match."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nduplicates the matcher to others.", "response": "def duplicate(self):\n        \"\"\"Duplicates the matcher to others.\"\"\"\n        other = Matcher(self.loc, self.check_var, self.checkdefs, self.names, self.var_index)\n        other.insert_check(0, \"not \" + self.check_var)\n        self.others.append(other)\n        return other"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the checks at the position.", "response": "def get_checks(self, position=None):\n        \"\"\"Gets the checks at the position.\"\"\"\n        if position is None:\n            position = self.position\n        return self.checkdefs[position][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the checks at the position.", "response": "def set_checks(self, checks, position=None):\n        \"\"\"Sets the checks at the position.\"\"\"\n        if position is None:\n            position = self.position\n        self.checkdefs[position][0] = checks"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_defs(self, position=None):\n        if position is None:\n            position = self.position\n        return self.checkdefs[position][1]", "response": "Gets the defs at the position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_defs(self, defs, position=None):\n        if position is None:\n            position = self.position\n        self.checkdefs[position][1] = defs", "response": "Sets the defs at the position."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a check universally.", "response": "def add_check(self, check_item):\n        \"\"\"Adds a check universally.\"\"\"\n        self.checks.append(check_item)\n        for other in self.others:\n            other.add_check(check_item)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_def(self, def_item):\n        self.defs.append(def_item)\n        for other in self.others:\n            other.add_def(def_item)", "response": "Adds a def universally."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insert_check(self, index, check_item):\n        self.checks.insert(index, check_item)\n        for other in self.others:\n            other.insert_check(index, check_item)", "response": "Inserts a check universally."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insert_def(self, index, def_item):\n        self.defs.insert(index, def_item)\n        for other in self.others:\n            other.insert_def(index, def_item)", "response": "Inserts a def universally."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_position(self, position):\n        if position < 0:\n            position += len(self.checkdefs)\n        while position >= len(self.checkdefs):\n            self.checkdefs.append(([], []))\n        self.position = position", "response": "Sets the if - statement position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef only_self(self):\n        others, self.others = self.others, []\n        try:\n            yield\n        finally:\n            self.others = others + self.others", "response": "Only match in self not others."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_temp_var(self):\n        tempvar = match_temp_var + \"_\" + str(self.var_index)\n        self.var_index += 1\n        return tempvar", "response": "Gets the next match_temp_var."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmatching all matches to elements of item.", "response": "def match_all_in(self, matches, item):\n        \"\"\"Matches all matches to elements of item.\"\"\"\n        for i, match in enumerate(matches):\n            self.match(match, item + \"[\" + str(i) + \"]\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that the length of item is in range min_len and max_len + 1.", "response": "def check_len_in(self, min_len, max_len, item):\n        \"\"\"Checks that the length of item is in range(min_len, max_len+1).\"\"\"\n        if max_len is None:\n            if min_len:\n                self.add_check(\"_coconut.len(\" + item + \") >= \" + str(min_len))\n        elif min_len == max_len:\n            self.add_check(\"_coconut.len(\" + item + \") == \" + str(min_len))\n        elif not min_len:\n            self.add_check(\"_coconut.len(\" + item + \") <= \" + str(max_len))\n        else:\n            self.add_check(str(min_len) + \" <= _coconut.len(\" + item + \") <= \" + str(max_len))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmatching a pattern - matching function.", "response": "def match_function(self, args, kwargs, match_args=(), star_arg=None, kwd_args=(), dubstar_arg=None):\n        \"\"\"Matches a pattern-matching function.\"\"\"\n        self.match_in_args_kwargs(match_args, args, kwargs, allow_star_args=star_arg is not None)\n        if star_arg is not None:\n            self.match(star_arg, args + \"[\" + str(len(match_args)) + \":]\")\n        self.match_in_kwargs(kwd_args, kwargs)\n        with self.down_a_level():\n            if dubstar_arg is None:\n                self.add_check(\"not \" + kwargs)\n            else:\n                self.match(dubstar_arg, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match_in_args_kwargs(self, match_args, args, kwargs, allow_star_args=False):\n        req_len = 0\n        arg_checks = {}\n        to_match = []  # [(move_down, match, against)]\n        for i, arg in enumerate(match_args):\n            if isinstance(arg, tuple):\n                (match, default) = arg\n            else:\n                match, default = arg, None\n            names = get_match_names(match)\n            if default is None:\n                if not names:\n                    req_len = i + 1\n                    to_match.append((False, match, args + \"[\" + str(i) + \"]\"))\n                else:\n                    arg_checks[i] = (\n                        # if i < req_len\n                        \" and \".join('\"' + name + '\" not in ' + kwargs for name in names),\n                        # if i >= req_len\n                        \"_coconut.sum((_coconut.len(\" + args + \") > \" + str(i) + \", \"\n                        + \", \".join('\"' + name + '\" in ' + kwargs for name in names)\n                        + \")) == 1\",\n                    )\n                    tempvar = self.get_temp_var()\n                    self.add_def(\n                        tempvar + \" = \"\n                        + args + \"[\" + str(i) + \"] if _coconut.len(\" + args + \") > \" + str(i) + \" else \"\n                        + \"\".join(kwargs + '.pop(\"' + name + '\") if \"' + name + '\" in ' + kwargs + \" else \"\n                                  for name in names[:-1])\n                        + kwargs + '.pop(\"' + names[-1] + '\")',\n                    )\n                    to_match.append((True, match, tempvar))\n            else:\n                if not names:\n                    tempvar = self.get_temp_var()\n                    self.add_def(tempvar + \" = \" + args + \"[\" + str(i) + \"] if _coconut.len(\" + args + \") > \" + str(i) + \" else \" + default)\n                    to_match.append((True, match, tempvar))\n                else:\n                    arg_checks[i] = (\n                        # if i < req_len\n                        None,\n                        # if i >= req_len\n                        \"_coconut.sum((_coconut.len(\" + args + \") > \" + str(i) + \", \"\n                        + \", \".join('\"' + name + '\" in ' + kwargs for name in names)\n                        + \")) <= 1\",\n                    )\n                    tempvar = self.get_temp_var()\n                    self.add_def(\n                        tempvar + \" = \"\n                        + args + \"[\" + str(i) + \"] if _coconut.len(\" + args + \") > \" + str(i) + \" else \"\n                        + \"\".join(\n                            kwargs + '.pop(\"' + name + '\") if \"' + name + '\" in ' + kwargs + \" else \"\n                            for name in names\n                        )\n                        + default,\n                    )\n                    to_match.append((True, match, tempvar))\n\n        max_len = None if allow_star_args else len(match_args)\n        self.check_len_in(req_len, max_len, args)\n        for i in sorted(arg_checks):\n            lt_check, ge_check = arg_checks[i]\n            if i < req_len:\n                if lt_check is not None:\n                    self.add_check(lt_check)\n            else:\n                if ge_check is not None:\n                    self.add_check(ge_check)\n\n        for move_down, match, against in to_match:\n            if move_down:\n                with self.down_a_level():\n                    self.match(match, against)\n            else:\n                self.match(match, against)", "response": "Matches against args or kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassign name to item converted to the given series_type.", "response": "def assign_to_series(self, name, series_type, item):\n        \"\"\"Assign name to item converted to the given series_type.\"\"\"\n        if series_type == \"(\":\n            self.add_def(name + \" = _coconut.tuple(\" + item + \")\")\n        elif series_type == \"[\":\n            self.add_def(name + \" = _coconut.list(\" + item + \")\")\n        else:\n            raise CoconutInternalException(\"invalid series match type\", series_type)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmatching a lazy list or a chain.", "response": "def match_iterator(self, tokens, item):\n        \"\"\"Matches a lazy list or a chain.\"\"\"\n        tail = None\n        if len(tokens) == 2:\n            _, matches = tokens\n        else:\n            _, matches, tail = tokens\n        self.add_check(\"_coconut.isinstance(\" + item + \", _coconut.abc.Iterable)\")\n        if tail is None:\n            itervar = self.get_temp_var()\n            self.add_def(itervar + \" = _coconut.tuple(\" + item + \")\")\n        elif matches:\n            itervar = self.get_temp_var()\n            if tail == wildcard:\n                tail = item\n            else:\n                self.add_def(tail + \" = _coconut.iter(\" + item + \")\")\n            self.add_def(itervar + \" = _coconut.tuple(_coconut_igetitem(\" + tail + \", _coconut.slice(None, \" + str(len(matches)) + \")))\")\n        else:\n            itervar = None\n            if tail != wildcard:\n                self.add_def(tail + \" = \" + item)\n        if itervar is not None:\n            with self.down_a_level():\n                self.add_check(\"_coconut.len(\" + itervar + \") == \" + str(len(matches)))\n                self.match_all_in(matches, itervar)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_rsequence(self, tokens, item):\n        front, series_type, matches = tokens\n        self.add_check(\"_coconut.isinstance(\" + item + \", _coconut.abc.Sequence)\")\n        self.add_check(\"_coconut.len(\" + item + \") >= \" + str(len(matches)))\n        if front != wildcard:\n            if len(matches):\n                splice = \"[:\" + str(-len(matches)) + \"]\"\n            else:\n                splice = \"\"\n            self.assign_to_series(front, series_type, item + splice)\n        for i, match in enumerate(matches):\n            self.match(match, item + \"[\" + str(i - len(matches)) + \"]\")", "response": "Matches a reverse sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmatching a middle sequence.", "response": "def match_msequence(self, tokens, item):\n        \"\"\"Matches a middle sequence.\"\"\"\n        series_type, head_matches, middle, _, last_matches = tokens\n        self.add_check(\"_coconut.isinstance(\" + item + \", _coconut.abc.Sequence)\")\n        self.add_check(\"_coconut.len(\" + item + \") >= \" + str(len(head_matches) + len(last_matches)))\n        if middle != wildcard:\n            if len(head_matches) and len(last_matches):\n                splice = \"[\" + str(len(head_matches)) + \":\" + str(-len(last_matches)) + \"]\"\n            elif len(head_matches):\n                splice = \"[\" + str(len(head_matches)) + \":]\"\n            elif len(last_matches):\n                splice = \"[:\" + str(-len(last_matches)) + \"]\"\n            else:\n                splice = \"\"\n            self.assign_to_series(middle, series_type, item + splice)\n        self.match_all_in(head_matches, item)\n        for i, match in enumerate(last_matches):\n            self.match(match, item + \"[\" + str(i - len(last_matches)) + \"]\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match_mstring(self, tokens, item, use_bytes=None):\n        prefix, name, suffix = tokens\n        if use_bytes is None:\n            if prefix.startswith(\"b\") or suffix.startswith(\"b\"):\n                if prefix.startswith(\"b\") and suffix.startswith(\"b\"):\n                    use_bytes = True\n                else:\n                    raise CoconutDeferredSyntaxError(\"string literals and byte literals cannot be added in patterns\", self.loc)\n        if use_bytes:\n            self.add_check(\"_coconut.isinstance(\" + item + \", _coconut.bytes)\")\n        else:\n            self.add_check(\"_coconut.isinstance(\" + item + \", _coconut.str)\")\n        if prefix is not None:\n            self.add_check(item + \".startswith(\" + prefix + \")\")\n        if suffix is not None:\n            self.add_check(item + \".endswith(\" + suffix + \")\")\n        if name != wildcard:\n            self.add_def(\n                name + \" = \" + item + \"[\" +\n                (\"\" if prefix is None else \"_coconut.len(\" + prefix + \")\") + \":\"\n                + (\"\" if suffix is None else \"-_coconut.len(\" + suffix + \")\") + \"]\",\n            )", "response": "Match prefix and suffix string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_data(self, tokens, item):\n        if len(tokens) == 2:\n            data_type, matches = tokens\n            star_match = None\n        elif len(tokens) == 3:\n            data_type, matches, star_match = tokens\n        else:\n            raise CoconutInternalException(\"invalid data match tokens\", tokens)\n        self.add_check(\"_coconut.isinstance(\" + item + \", \" + data_type + \")\")\n        if star_match is None:\n            self.add_check(\"_coconut.len(\" + item + \") == \" + str(len(matches)))\n        elif len(matches):\n            self.add_check(\"_coconut.len(\" + item + \") >= \" + str(len(matches)))\n        self.match_all_in(matches, item)\n        if star_match is not None:\n            self.match(star_match, item + \"[\" + str(len(matches)) + \":]\")", "response": "Matches a data type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmatching typedefs and as patterns.", "response": "def match_trailer(self, tokens, item):\n        \"\"\"Matches typedefs and as patterns.\"\"\"\n        internal_assert(len(tokens) > 1 and len(tokens) % 2 == 1, \"invalid trailer match tokens\", tokens)\n        match, trailers = tokens[0], tokens[1:]\n        for i in range(0, len(trailers), 2):\n            op, arg = trailers[i], trailers[i + 1]\n            if op == \"is\":\n                self.add_check(\"_coconut.isinstance(\" + item + \", \" + arg + \")\")\n            elif op == \"as\":\n                if arg in self.names:\n                    self.add_check(self.names[arg] + \" == \" + item)\n                elif arg != wildcard:\n                    self.add_def(arg + \" = \" + item)\n                    self.names[arg] = item\n            else:\n                raise CoconutInternalException(\"invalid trailer match operation\", op)\n        self.match(match, item)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform pattern - matching processing.", "response": "def match(self, tokens, item):\n        \"\"\"Performs pattern-matching processing.\"\"\"\n        for flag, get_handler in self.matchers.items():\n            if flag in tokens:\n                return get_handler(self)(tokens, item)\n        raise CoconutInternalException(\"invalid pattern-matching tokens\", tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef out(self):\n        out = \"\"\n        if self.use_sentinel:\n            out += sentinel_var + \" = _coconut.object()\\n\"\n        closes = 0\n        for checks, defs in self.checkdefs:\n            if checks:\n                out += \"if \" + paren_join(checks, \"and\") + \":\\n\" + openindent\n                closes += 1\n            if defs:\n                out += \"\\n\".join(defs) + \"\\n\"\n        return out + (\n            self.check_var + \" = True\\n\"\n            + closeindent * closes\n            + \"\".join(other.out() for other in self.others)\n            + (\n                \"if \" + self.check_var + \" and not (\"\n                + paren_join(self.guards, \"and\")\n                + \"):\\n\" + openindent\n                + self.check_var + \" = False\\n\" + closeindent\n                if self.guards else \"\"\n            )\n        )", "response": "Return pattern - matching code."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build(self, stmts=None, set_check_var=True, invert=False):\n        out = \"\"\n        if set_check_var:\n            out += self.check_var + \" = False\\n\"\n        out += self.out()\n        if stmts is not None:\n            out += \"if \" + (\"not \" if invert else \"\") + self.check_var + \":\" + \"\\n\" + openindent + \"\".join(stmts) + closeindent\n        return out", "response": "Construct code for performing the match then executing stmts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nindent every nonempty line of the given code.", "response": "def _indent(code, by=1):\n    \"\"\"Indents every nonempty line of the given code.\"\"\"\n    return \"\".join(\n        (\"    \" * by if line else \"\") + line for line in code.splitlines(True)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclean and strip a line.", "response": "def clean(inputline, strip=True, rem_indents=True, encoding_errors=\"replace\"):\n    \"\"\"Clean and strip a line.\"\"\"\n    stdout_encoding = get_encoding(sys.stdout)\n    inputline = str(inputline)\n    if rem_indents:\n        inputline = inputline.replace(openindent, \"\").replace(closeindent, \"\")\n    if strip:\n        inputline = inputline.strip()\n    return inputline.encode(stdout_encoding, encoding_errors).decode(stdout_encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef displayable(inputstr, strip=True):\n    return clean(str(inputstr), strip, rem_indents=False, encoding_errors=\"backslashreplace\")", "response": "Make a string displayable with minimal loss of information."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nraise InternalException if condition is False.", "response": "def internal_assert(condition, message=None, item=None, extra=None):\n    \"\"\"Raise InternalException if condition is False.\n    If condition is a function, execute it on DEVELOP only.\"\"\"\n    if DEVELOP and callable(condition):\n        condition = condition()\n    if not condition:\n        if message is None:\n            message = \"assertion failed\"\n            if item is None:\n                item = condition\n        raise CoconutInternalException(message, item, extra)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef message(self, message, item, extra):\n        if item is not None:\n            message += \": \" + ascii(item)\n        if extra is not None:\n            message += \" (\" + str(extra) + \")\"\n        return message", "response": "Uses arguments to create the message."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a SyntaxError - like message.", "response": "def message(self, message, source, point, ln):\n        \"\"\"Creates a SyntaxError-like message.\"\"\"\n        if message is None:\n            message = \"parsing failed\"\n        if ln is not None:\n            message += \" (line \" + str(ln) + \")\"\n        if source:\n            if point is None:\n                message += \"\\n\" + \" \" * taberrfmt + clean(source)\n            else:\n                part = clean(source.splitlines()[lineno(point, source) - 1], False).lstrip()\n                point -= len(source) - len(part)  # adjust all points based on lstrip\n                part = part.rstrip()  # adjust only points that are too large based on rstrip\n                message += \"\\n\" + \" \" * taberrfmt + part\n                if point > 0:\n                    if point >= len(part):\n                        point = len(part) - 1\n                    message += \"\\n\" + \" \" * (taberrfmt + point) + \"^\"\n        return message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate the Coconut error message.", "response": "def message(self, message, source, point, ln):\n        \"\"\"Creates the --strict Coconut error message.\"\"\"\n        message += \" (disable --strict to dismiss)\"\n        return super(CoconutStyleError, self).message(message, source, point, ln)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef message(self, message, source, point, ln, target):\n        if target is not None:\n            message += \" (enable --target \" + target + \" to dismiss)\"\n        return super(CoconutTargetError, self).message(message, source, point, ln)", "response": "Creates the Coconut target error message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef message(self, message, item, extra):\n        return (\n            super(CoconutInternalException, self).message(message, item, extra)\n            + \" \" + report_this_text\n        )", "response": "Creates the Coconut internal exception message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef patched_nested_parse(self, *args, **kwargs):\n        kwargs[\"match_titles\"] = True\n        return self.stored_nested_parse(*args, **kwargs)", "response": "Sets match_titles then calls stored_nested_parse."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmodifying auto_code_block that patches nested_parse.", "response": "def auto_code_block(self, *args, **kwargs):\n        \"\"\"Modified auto_code_block that patches nested_parse.\"\"\"\n        self.stored_nested_parse = self.state_machine.state.nested_parse\n        self.state_machine.state.nested_parse = self.patched_nested_parse\n        try:\n            return super(PatchedAutoStructify, self).auto_code_block(*args, **kwargs)\n        finally:\n            self.state_machine.state.nested_parse = self.stored_nested_parse"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses command - line arguments.", "response": "def start(self, run=False):\n        \"\"\"Process command-line arguments.\"\"\"\n        if run:\n            args, argv = [], []\n            # for coconut-run, all args beyond the source file should be wrapped in an --argv\n            for i in range(1, len(sys.argv)):\n                arg = sys.argv[i]\n                args.append(arg)\n                # if arg is source file, put everything else in argv\n                if not arg.startswith(\"-\") and canparse(arguments, args[:-1]):\n                    argv = sys.argv[i + 1:]\n                    break\n            if \"--verbose\" in args:\n                args = list(coconut_run_verbose_args) + args\n            else:\n                args = list(coconut_run_args) + args\n            args += [\"--argv\"] + argv\n        else:\n            args = None\n        self.cmd(args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd(self, args=None, interact=True):\n        if args is None:\n            parsed_args = arguments.parse_args()\n        else:\n            parsed_args = arguments.parse_args(args)\n        self.exit_code = 0\n        with self.handling_exceptions():\n            self.use_args(parsed_args, interact, original_args=args)\n        self.exit_on_error()", "response": "Process command - line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets parameters for the compiler.", "response": "def setup(self, *args, **kwargs):\n        \"\"\"Set parameters for the compiler.\"\"\"\n        if self.comp is None:\n            self.comp = Compiler(*args, **kwargs)\n        else:\n            self.comp.setup(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exit_on_error(self):\n        if self.exit_code:\n            if self.errmsg is not None:\n                logger.show(\"Exiting due to \" + self.errmsg + \".\")\n                self.errmsg = None\n            if self.using_jobs:\n                kill_children()\n            sys.exit(self.exit_code)", "response": "Exit if exit_code is abnormal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle command - line arguments.", "response": "def use_args(self, args, interact=True, original_args=None):\n        \"\"\"Handle command-line arguments.\"\"\"\n        logger.quiet, logger.verbose = args.quiet, args.verbose\n        if DEVELOP:\n            logger.tracing = args.trace\n\n        logger.log(\"Using \" + PYPARSING + \".\")\n        if original_args is not None:\n            logger.log(\"Directly passed args:\", original_args)\n        logger.log(\"Parsed args:\", args)\n\n        if args.recursion_limit is not None:\n            set_recursion_limit(args.recursion_limit)\n        if args.jobs is not None:\n            self.set_jobs(args.jobs)\n        if args.display:\n            self.show = True\n        if args.style is not None:\n            self.prompt.set_style(args.style)\n        if args.history_file is not None:\n            self.prompt.set_history_file(args.history_file)\n        if args.documentation:\n            launch_documentation()\n        if args.tutorial:\n            launch_tutorial()\n\n        self.setup(\n            target=args.target,\n            strict=args.strict,\n            minify=args.minify,\n            line_numbers=args.line_numbers,\n            keep_lines=args.keep_lines,\n            no_tco=args.no_tco,\n        )\n\n        if args.mypy is not None:\n            self.set_mypy_args(args.mypy)\n\n        if args.argv is not None:\n            sys.argv = [args.source if args.source is not None else \"\"]\n            sys.argv.extend(args.argv)\n\n        if args.source is not None:\n            if args.interact and args.run:\n                logger.warn(\"extraneous --run argument passed; --interact implies --run\")\n            if args.package and self.mypy:\n                logger.warn(\"extraneous --package argument passed; --mypy implies --package\")\n\n            if args.standalone and args.package:\n                raise CoconutException(\"cannot compile as both --package and --standalone\")\n            if args.standalone and self.mypy:\n                raise CoconutException(\"cannot compile as both --package (implied by --mypy) and --standalone\")\n            if args.no_write and self.mypy:\n                raise CoconutException(\"cannot compile with --no-write when using --mypy\")\n            if (args.run or args.interact) and os.path.isdir(args.source):\n                if args.run:\n                    raise CoconutException(\"source path must point to file not directory when --run is enabled\")\n                if args.interact:\n                    raise CoconutException(\"source path must point to file not directory when --run (implied by --interact) is enabled\")\n            if args.watch and os.path.isfile(args.source):\n                raise CoconutException(\"source path must point to directory not file when --watch is enabled\")\n\n            if args.dest is None:\n                if args.no_write:\n                    dest = False  # no dest\n                else:\n                    dest = True  # auto-generate dest\n            elif args.no_write:\n                raise CoconutException(\"destination path cannot be given when --no-write is enabled\")\n            else:\n                dest = args.dest\n\n            if args.package or self.mypy:\n                package = True\n            elif args.standalone:\n                package = False\n            else:\n                package = None  # auto-decide package\n\n            with self.running_jobs(exit_on_error=not args.watch):\n                filepaths = self.compile_path(args.source, dest, package, args.run or args.interact, args.force)\n            self.run_mypy(filepaths)\n\n        elif (\n            args.run\n            or args.no_write\n            or args.force\n            or args.package\n            or args.standalone\n            or args.watch\n        ):\n            raise CoconutException(\"a source file/folder must be specified when options that depend on the source are enabled\")\n\n        if args.code is not None:\n            self.execute(self.comp.parse_block(args.code))\n        got_stdin = False\n        if args.jupyter is not None:\n            self.start_jupyter(args.jupyter)\n        elif stdin_readable():\n            logger.log(\"Reading piped input from stdin...\")\n            self.execute(self.comp.parse_block(sys.stdin.read()))\n            got_stdin = True\n        if args.interact or (interact and not (\n                got_stdin\n                or args.source\n                or args.code\n                or args.tutorial\n                or args.documentation\n                or args.watch\n                or args.jupyter is not None\n        )):\n            self.start_prompt()\n        if args.watch:\n            self.watch(args.source, dest, package, args.run, args.force)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_error(self, code=1, errmsg=None):\n        if errmsg is not None:\n            if self.errmsg is None:\n                self.errmsg = errmsg\n            elif errmsg not in self.errmsg:\n                self.errmsg += \", \" + errmsg\n        if code is not None:\n            self.exit_code = max(self.exit_code, code)", "response": "Update the exit code."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handling_exceptions(self):\n        try:\n            if self.using_jobs:\n                with handling_broken_process_pool():\n                    yield\n            else:\n                yield\n        except SystemExit as err:\n            self.register_error(err.code)\n        except BaseException as err:\n            if isinstance(err, CoconutException):\n                logger.display_exc()\n            elif not isinstance(err, KeyboardInterrupt):\n                traceback.print_exc()\n                printerr(report_this_text)\n            self.register_error(errmsg=err.__class__.__name__)", "response": "Perform proper exception handling."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compile_path(self, path, write=True, package=None, *args, **kwargs):\n        path = fixpath(path)\n        if not isinstance(write, bool):\n            write = fixpath(write)\n        if os.path.isfile(path):\n            if package is None:\n                package = False\n            destpath = self.compile_file(path, write, package, *args, **kwargs)\n            return [destpath] if destpath is not None else []\n        elif os.path.isdir(path):\n            if package is None:\n                package = True\n            return self.compile_folder(path, write, package, *args, **kwargs)\n        else:\n            raise CoconutException(\"could not find source path\", path)", "response": "Compile a path and returns paths to compiled files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncompiling a directory and returns paths to compiled files.", "response": "def compile_folder(self, directory, write=True, package=True, *args, **kwargs):\n        \"\"\"Compile a directory and returns paths to compiled files.\"\"\"\n        if not isinstance(write, bool) and os.path.isfile(write):\n            raise CoconutException(\"destination path cannot point to a file when compiling a directory\")\n        filepaths = []\n        for dirpath, dirnames, filenames in os.walk(directory):\n            if isinstance(write, bool):\n                writedir = write\n            else:\n                writedir = os.path.join(write, os.path.relpath(dirpath, directory))\n            for filename in filenames:\n                if os.path.splitext(filename)[1] in code_exts:\n                    with self.handling_exceptions():\n                        destpath = self.compile_file(os.path.join(dirpath, filename), writedir, package, *args, **kwargs)\n                        if destpath is not None:\n                            filepaths.append(destpath)\n            for name in dirnames[:]:\n                if not is_special_dir(name) and name.startswith(\".\"):\n                    if logger.verbose:\n                        logger.show_tabulated(\"Skipped directory\", name, \"(explicitly pass as source to override).\")\n                    dirnames.remove(name)  # directories removed from dirnames won't appear in further os.walk iterations\n        return filepaths"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compile_file(self, filepath, write=True, package=False, *args, **kwargs):\n        set_ext = False\n        if write is False:\n            destpath = None\n        elif write is True:\n            destpath = filepath\n            set_ext = True\n        elif os.path.splitext(write)[1]:\n            # write is a file; it is the destination filepath\n            destpath = write\n        else:\n            # write is a dir; make the destination filepath by adding the filename\n            destpath = os.path.join(write, os.path.basename(filepath))\n            set_ext = True\n        if set_ext:\n            base, ext = os.path.splitext(os.path.splitext(destpath)[0])\n            if not ext:\n                ext = comp_ext\n            destpath = fixpath(base + ext)\n        if filepath == destpath:\n            raise CoconutException(\"cannot compile \" + showpath(filepath) + \" to itself\", extra=\"incorrect file extension\")\n        self.compile(filepath, destpath, package, *args, **kwargs)\n        return destpath", "response": "Compile a file and returns the compiled file s path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompiling a source Coconut file to a destination Python file.", "response": "def compile(self, codepath, destpath=None, package=False, run=False, force=False, show_unchanged=True):\n        \"\"\"Compile a source Coconut file to a destination Python file.\"\"\"\n        with openfile(codepath, \"r\") as opened:\n            code = readfile(opened)\n\n        if destpath is not None:\n            destdir = os.path.dirname(destpath)\n            if not os.path.exists(destdir):\n                os.makedirs(destdir)\n            if package is True:\n                self.create_package(destdir)\n\n        foundhash = None if force else self.has_hash_of(destpath, code, package)\n        if foundhash:\n            if show_unchanged:\n                logger.show_tabulated(\"Left unchanged\", showpath(destpath), \"(pass --force to override).\")\n            if self.show:\n                print(foundhash)\n            if run:\n                self.execute_file(destpath)\n\n        else:\n            logger.show_tabulated(\"Compiling\", showpath(codepath), \"...\")\n\n            if package is True:\n                compile_method = \"parse_package\"\n            elif package is False:\n                compile_method = \"parse_file\"\n            else:\n                raise CoconutInternalException(\"invalid value for package\", package)\n\n            def callback(compiled):\n                if destpath is None:\n                    logger.show_tabulated(\"Compiled\", showpath(codepath), \"without writing to file.\")\n                else:\n                    with openfile(destpath, \"w\") as opened:\n                        writefile(opened, compiled)\n                    logger.show_tabulated(\"Compiled to\", showpath(destpath), \".\")\n                if self.show:\n                    print(compiled)\n                if run:\n                    if destpath is None:\n                        self.execute(compiled, path=codepath, allow_show=False)\n                    else:\n                        self.execute_file(destpath)\n\n            self.submit_comp_job(codepath, callback, compile_method, code)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsubmitting a job on self. comp to be run in parallel.", "response": "def submit_comp_job(self, path, callback, method, *args, **kwargs):\n        \"\"\"Submits a job on self.comp to be run in parallel.\"\"\"\n        if self.executor is None:\n            with self.handling_exceptions():\n                callback(getattr(self.comp, method)(*args, **kwargs))\n        else:\n            path = showpath(path)\n            with logger.in_path(path):  # pickle the compiler in the path context\n                future = self.executor.submit(multiprocess_wrapper(self.comp, method), *args, **kwargs)\n\n            def callback_wrapper(completed_future):\n                \"\"\"Ensures that all errors are always caught, since errors raised in a callback won't be propagated.\"\"\"\n                with logger.in_path(path):  # handle errors in the path context\n                    with self.handling_exceptions():\n                        result = completed_future.result()\n                        callback(result)\n            future.add_done_callback(callback_wrapper)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the number of jobs for this coconut.", "response": "def set_jobs(self, jobs):\n        \"\"\"Set --jobs.\"\"\"\n        if jobs == \"sys\":\n            self.jobs = None\n        else:\n            try:\n                jobs = int(jobs)\n            except ValueError:\n                jobs = -1  # will raise error below\n            if jobs < 0:\n                raise CoconutException(\"--jobs must be an integer >= 0 or 'sys'\")\n            self.jobs = jobs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a package directory.", "response": "def create_package(self, dirpath):\n        \"\"\"Set up a package directory.\"\"\"\n        dirpath = fixpath(dirpath)\n        filepath = os.path.join(dirpath, \"__coconut__.py\")\n        with openfile(filepath, \"w\") as opened:\n            writefile(opened, self.comp.getheader(\"__coconut__\"))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining if a file has the hash of the code.", "response": "def has_hash_of(self, destpath, code, package):\n        \"\"\"Determine if a file has the hash of the code.\"\"\"\n        if destpath is not None and os.path.isfile(destpath):\n            with openfile(destpath, \"r\") as opened:\n                compiled = readfile(opened)\n            hashash = gethash(compiled)\n            if hashash is not None and hashash == self.comp.genhash(package, code):\n                return compiled\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_input(self, more=False):\n        received = None\n        try:\n            received = self.prompt.input(more)\n        except KeyboardInterrupt:\n            print()\n            printerr(\"KeyboardInterrupt\")\n        except EOFError:\n            print()\n            self.exit_runner()\n        else:\n            if received.startswith(exit_chars):\n                self.exit_runner()\n                received = None\n        return received", "response": "Prompt for code input."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start_running(self):\n        self.comp.warm_up()\n        self.check_runner()\n        self.running = True", "response": "Start running the Runner."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncompiles Coconut interpreter input.", "response": "def handle_input(self, code):\n        \"\"\"Compile Coconut interpreter input.\"\"\"\n        if not self.prompt.multiline:\n            if not should_indent(code):\n                try:\n                    return self.comp.parse_block(code)\n                except CoconutException:\n                    pass\n            while True:\n                line = self.get_input(more=True)\n                if line is None:\n                    return None\n                elif line:\n                    code += \"\\n\" + line\n                else:\n                    break\n        try:\n            return self.comp.parse_block(code)\n        except CoconutException:\n            logger.display_exc()\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes sure there is a runner.", "response": "def check_runner(self):\n        \"\"\"Make sure there is a runner.\"\"\"\n        if os.getcwd() not in sys.path:\n            sys.path.append(os.getcwd())\n        if self.runner is None:\n            self.runner = Runner(self.comp, exit=self.exit_runner, store=self.mypy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun MyPy with arguments.", "response": "def run_mypy(self, paths=(), code=None):\n        \"\"\"Run MyPy with arguments.\"\"\"\n        if self.mypy:\n            set_mypy_path(stub_dir)\n            from coconut.command.mypy import mypy_run\n            args = list(paths) + self.mypy_args\n            if code is not None:\n                args += [\"-c\", code]\n            for line, is_err in mypy_run(args):\n                if code is None or line not in self.mypy_errs:\n                    printerr(line)\n                if line not in self.mypy_errs:\n                    self.mypy_errs.append(line)\n                self.register_error(errmsg=\"MyPy error\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_jupyter(self, args):\n        install_func = partial(run_cmd, show_output=logger.verbose)\n\n        try:\n            install_func([\"jupyter\", \"--version\"])\n        except CalledProcessError:\n            jupyter = \"ipython\"\n        else:\n            jupyter = \"jupyter\"\n\n        # always install kernels if given no args, otherwise only if there's a kernel missing\n        do_install = not args\n        if not do_install:\n            kernel_list = run_cmd([jupyter, \"kernelspec\", \"list\"], show_output=False, raise_errs=False)\n            do_install = any(ker not in kernel_list for ker in icoconut_kernel_names)\n\n        if do_install:\n            success = True\n            for icoconut_kernel_dir in icoconut_kernel_dirs:\n                install_args = [jupyter, \"kernelspec\", \"install\", icoconut_kernel_dir, \"--replace\"]\n                try:\n                    install_func(install_args)\n                except CalledProcessError:\n                    user_install_args = install_args + [\"--user\"]\n                    try:\n                        install_func(user_install_args)\n                    except CalledProcessError:\n                        logger.warn(\"kernel install failed on command'\", \" \".join(install_args))\n                        self.register_error(errmsg=\"Jupyter error\")\n                        success = False\n            if success:\n                logger.show_sig(\"Successfully installed Coconut Jupyter kernel.\")\n\n        if args:\n            if args[0] == \"console\":\n                ver = \"2\" if PY2 else \"3\"\n                try:\n                    install_func([\"python\" + ver, \"-m\", \"coconut.main\", \"--version\"])\n                except CalledProcessError:\n                    kernel_name = \"coconut\"\n                else:\n                    kernel_name = \"coconut\" + ver\n                run_args = [jupyter, \"console\", \"--kernel\", kernel_name] + args[1:]\n            else:\n                run_args = [jupyter] + args\n            self.register_error(run_cmd(run_args, raise_errs=False), errmsg=\"Jupyter error\")", "response": "Start Jupyter with the Coconut kernel."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef watch(self, source, write=True, package=None, run=False, force=False):\n        from coconut.command.watch import Observer, RecompilationWatcher\n\n        source = fixpath(source)\n\n        logger.show()\n        logger.show_tabulated(\"Watching\", showpath(source), \"(press Ctrl-C to end)...\")\n\n        def recompile(path):\n            path = fixpath(path)\n            if os.path.isfile(path) and os.path.splitext(path)[1] in code_exts:\n                with self.handling_exceptions():\n                    if write is True or write is None:\n                        writedir = write\n                    else:\n                        # correct the compilation path based on the relative position of path to source\n                        dirpath = os.path.dirname(path)\n                        writedir = os.path.join(write, os.path.relpath(dirpath, source))\n                    filepaths = self.compile_path(path, writedir, package, run, force, show_unchanged=False)\n                    self.run_mypy(filepaths)\n\n        watcher = RecompilationWatcher(recompile)\n        observer = Observer()\n        observer.schedule(watcher, source, recursive=True)\n\n        with self.running_jobs():\n            observer.start()\n            try:\n                while True:\n                    time.sleep(watch_interval)\n                    watcher.keep_watching()\n            except KeyboardInterrupt:\n                logger.show_sig(\"Got KeyboardInterrupt; stopping watcher.\")\n            finally:\n                observer.stop()\n                observer.join()", "response": "Watch a source and recompiles on change."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_ipython_extension(ipython):\n    # add Coconut built-ins\n    from coconut import __coconut__\n    newvars = {}\n    for var, val in vars(__coconut__).items():\n        if not var.startswith(\"__\"):\n            newvars[var] = val\n    ipython.push(newvars)\n\n    # import here to avoid circular dependencies\n    from coconut.convenience import cmd, parse, CoconutException\n    from coconut.terminal import logger\n\n    # add magic function\n    def magic(line, cell=None):\n        \"\"\"Provides %coconut and %%coconut magics.\"\"\"\n        try:\n            if cell is None:\n                code = line\n            else:\n                # first line in block is cmd, rest is code\n                line = line.strip()\n                if line:\n                    cmd(line, interact=False)\n                code = cell\n            compiled = parse(code)\n        except CoconutException:\n            logger.display_exc()\n        else:\n            ipython.run_cell(compiled, shell_futures=False)\n    ipython.register_magic_function(magic, \"line_cell\", \"coconut\")", "response": "Loads Coconut as an IPython extension."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef evaluate_tokens(tokens):\n    if isinstance(tokens, str):\n        return tokens\n    elif isinstance(tokens, ParseResults):\n        # evaluate the list portion of the ParseResults\n        toklist, name, asList, modal = tokens.__getnewargs__()\n        new_toklist = [evaluate_tokens(toks) for toks in toklist]\n        new_tokens = ParseResults(new_toklist, name, asList, modal)\n        # evaluate the dictionary portion of the ParseResults\n        new_tokdict = {}\n        for name, occurrences in tokens._ParseResults__tokdict.items():\n            new_occurences = []\n            for value, position in occurrences:\n                if isinstance(value, ParseResults) and value._ParseResults__toklist == toklist:\n                    new_value = new_tokens\n                else:\n                    try:\n                        new_value = new_toklist[toklist.index(value)]\n                    except ValueError:\n                        complain(lambda: CoconutInternalException(\"inefficient reevaluation of tokens: {} not in {}\".format(\n                            value,\n                            toklist,\n                        )))\n                        new_value = evaluate_tokens(value)\n                new_occurences.append(_ParseResultsWithOffset(new_value, position))\n            new_tokdict[name] = occurrences\n        new_tokens._ParseResults__accumNames.update(tokens._ParseResults__accumNames)\n        new_tokens._ParseResults__tokdict.update(new_tokdict)\n        return new_tokens\n    elif isinstance(tokens, ComputationNode):\n        return tokens.evaluate()\n    elif isinstance(tokens, (list, tuple)):\n        return [evaluate_tokens(inner_toks) for inner_toks in tokens]\n    else:\n        raise CoconutInternalException(\"invalid computation graph tokens\", tokens)", "response": "Evaluate the given tokens in the computation graph."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the parse action for the given item to create a node in the computation graph.", "response": "def attach(item, action, greedy=False, ignore_no_tokens=None, ignore_one_token=None):\n    \"\"\"Set the parse action for the given item to create a node in the computation graph.\"\"\"\n    if use_computation_graph:\n        # use the action's annotations to generate the defaults\n        if ignore_no_tokens is None:\n            ignore_no_tokens = getattr(action, \"ignore_no_tokens\", False)\n        if ignore_one_token is None:\n            ignore_one_token = getattr(action, \"ignore_one_token\", False)\n        # only include True keyword arguments in the partial, since False is the default\n        kwargs = {}\n        if greedy:\n            kwargs[\"greedy\"] = greedy\n        if ignore_no_tokens:\n            kwargs[\"ignore_no_tokens\"] = ignore_no_tokens\n        if ignore_one_token:\n            kwargs[\"ignore_one_token\"] = ignore_one_token\n        action = partial(ComputationNode, action, **kwargs)\n    return add_action(item, action)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unpack(tokens):\n    logger.log_tag(\"unpack\", tokens)\n    if use_computation_graph:\n        tokens = evaluate_tokens(tokens)\n    if isinstance(tokens, ParseResults) and len(tokens) == 1:\n        tokens = tokens[0]\n    return tokens", "response": "Evaluate and unpack the given computation graph."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all_matches(grammar, text):\n    for tokens, start, stop in grammar.parseWithTabs().scanString(text):\n        yield unpack(tokens), start, stop", "response": "Find all matches for grammar in text."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef match_in(grammar, text):\n    for result in grammar.parseWithTabs().scanString(text):\n        return True\n    return False", "response": "Determine if there is a match for grammar in text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a list of the versions supported by the given target.", "response": "def get_vers_for_target(target):\n    \"\"\"Gets a list of the versions supported by the given target.\"\"\"\n    target_info = get_target_info(target)\n    if not target_info:\n        return py2_vers + py3_vers\n    elif len(target_info) == 1:\n        if target_info == (2,):\n            return py2_vers\n        elif target_info == (3,):\n            return py3_vers\n        else:\n            raise CoconutInternalException(\"invalid target info\", target_info)\n    elif target_info == (3, 3):\n        return [(3, 3), (3, 4)]\n    else:\n        return [target_info[:2]]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_target_info_len2(target, mode=\"lowest\"):\n    supported_vers = get_vers_for_target(target)\n    if mode == \"lowest\":\n        return supported_vers[0]\n    elif mode == \"highest\":\n        return supported_vers[-1]\n    elif mode == \"nearest\":\n        if sys.version_info[:2] in supported_vers:\n            return sys.version_info[:2]\n        else:\n            return supported_vers[-1]\n    else:\n        raise CoconutInternalException(\"unknown get_target_info_len2 mode\", mode)", "response": "Converts target into a length 2 Python version tuple."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmatch the longest of the given grammar elements.", "response": "def longest(*args):\n    \"\"\"Match the longest of the given grammar elements.\"\"\"\n    internal_assert(len(args) >= 2, \"longest expects at least two args\")\n    matcher = args[0] + skip_whitespace\n    for elem in args[1:]:\n        matcher ^= elem + skip_whitespace\n    return matcher"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addskip(skips, skip):\n    if skip < 1:\n        complain(CoconutInternalException(\"invalid skip of line \" + str(skip)))\n    else:\n        skips.append(skip)\n    return skips", "response": "Add a line skip to the skips list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncount the number of instances of testchar at the end of teststr.", "response": "def count_end(teststr, testchar):\n    \"\"\"Count instances of testchar at end of teststr.\"\"\"\n    count = 0\n    x = len(teststr) - 1\n    while x >= 0 and teststr[x] == testchar:\n        count += 1\n        x -= 1\n    return count"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining the parenthetical change of level.", "response": "def paren_change(inputstring, opens=opens, closes=closes):\n    \"\"\"Determine the parenthetical change of level (num closes - num opens).\"\"\"\n    count = 0\n    for c in inputstring:\n        if c in opens:  # open parens/brackets/braces\n            count -= 1\n        elif c in closes:  # close parens/brackets/braces\n            count += 1\n    return count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap an item in optional parentheses only applying them if necessary.", "response": "def maybeparens(lparen, item, rparen):\n    \"\"\"Wrap an item in optional parentheses, only applying them if necessary.\"\"\"\n    return item | lparen.suppress() + item + rparen.suppress()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a list of tokens matching the item.", "response": "def tokenlist(item, sep, suppress=True):\n    \"\"\"Create a list of tokens matching the item.\"\"\"\n    if suppress:\n        sep = sep.suppress()\n    return item + ZeroOrMore(sep + item) + Optional(sep)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef itemlist(item, sep, suppress_trailing=True):\n    return condense(item + ZeroOrMore(addspace(sep + item)) + Optional(sep.suppress() if suppress_trailing else sep))", "response": "Create a list of items seperated by seps."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef should_indent(code):\n    last = rem_comment(code.splitlines()[-1])\n    return last.endswith(\":\") or last.endswith(\"\\\\\") or paren_change(last) < 0", "response": "Determines whether the next line should be indented."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit into leading comment and rest.", "response": "def split_leading_comment(inputstring):\n    \"\"\"Split into leading comment and rest.\"\"\"\n    if inputstring.startswith(\"#\"):\n        comment, rest = inputstring.split(\"\\n\", 1)\n        return comment + \"\\n\", rest\n    else:\n        return \"\", inputstring"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split_leading_indent(line, max_indents=None):\n    indent = \"\"\n    while (\n        (max_indents is None or max_indents > 0)\n        and line.startswith((openindent, closeindent))\n    ) or line.lstrip() != line:\n        if max_indents is not None and line.startswith((openindent, closeindent)):\n            max_indents -= 1\n        indent += line[0]\n        line = line[1:]\n    return indent, line", "response": "Split line into leading indent and main."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit line into leading indent and main.", "response": "def split_trailing_indent(line, max_indents=None):\n    \"\"\"Split line into leading indent and main.\"\"\"\n    indent = \"\"\n    while (\n        (max_indents is None or max_indents > 0)\n        and line.endswith((openindent, closeindent))\n    ) or line.rstrip() != line:\n        if max_indents is not None and (line.endswith(openindent) or line.endswith(closeindent)):\n            max_indents -= 1\n        indent = line[-1] + indent\n        line = line[:-1]\n    return line, indent"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef split_leading_trailing_indent(line, max_indents=None):\n    leading_indent, line = split_leading_indent(line, max_indents)\n    line, trailing_indent = split_trailing_indent(line, max_indents)\n    return leading_indent, line, trailing_indent", "response": "Split leading and trailing indent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncollapse all openindent - closeindent pairs.", "response": "def collapse_indents(indentation):\n    \"\"\"Removes all openindent-closeindent pairs.\"\"\"\n    change_in_level = ind_change(indentation)\n    if change_in_level == 0:\n        indents = \"\"\n    elif change_in_level < 0:\n        indents = closeindent * (-change_in_level)\n    else:\n        indents = openindent * change_in_level\n    return indentation.replace(openindent, \"\").replace(closeindent, \"\") + indents"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransform text by replacing matches to grammar.", "response": "def transform(grammar, text):\n    \"\"\"Transform text by replacing matches to grammar.\"\"\"\n    results = []\n    intervals = []\n    for result, start, stop in all_matches(grammar, text):\n        if result is not ignore_transform:\n            internal_assert(isinstance(result, str), \"got non-string transform result\", result)\n            if start == 0 and stop == len(text):\n                return result\n            results.append(result)\n            intervals.append((start, stop))\n\n    if not results:\n        return None\n\n    split_indices = [0]\n    split_indices.extend(start for start, _ in intervals)\n    split_indices.extend(stop for _, stop in intervals)\n    split_indices.sort()\n    split_indices.append(None)\n\n    out = []\n    for i in range(len(split_indices) - 1):\n        if i % 2 == 0:\n            start, stop = split_indices[i], split_indices[i + 1]\n            out.append(text[start:stop])\n        else:\n            out.append(results[i // 2])\n    if i // 2 < len(results) - 1:\n        raise CoconutInternalException(\"unused transform results\", results[i // 2 + 1:])\n    if stop is not None:\n        raise CoconutInternalException(\"failed to properly split text to be transformed\")\n    return \"\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprevent elems from matching inside of item.", "response": "def disable_inside(item, *elems, **kwargs):\n    \"\"\"Prevent elems from matching inside of item.\n\n    Returns (item with elem disabled, *new versions of elems).\n    \"\"\"\n    _invert = kwargs.get(\"_invert\", False)\n    internal_assert(set(kwargs.keys()) <= set((\"_invert\",)), \"excess keyword arguments passed to disable_inside\")\n\n    level = [0]  # number of wrapped items deep we are; in a list to allow modification\n\n    @contextmanager\n    def manage_item(self, instring, loc):\n        level[0] += 1\n        try:\n            yield\n        finally:\n            level[0] -= 1\n\n    yield Wrap(item, manage_item)\n\n    @contextmanager\n    def manage_elem(self, instring, loc):\n        if level[0] == 0 if not _invert else level[0] > 0:\n            yield\n        else:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n    for elem in elems:\n        yield Wrap(elem, manage_elem)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the name of the action.", "response": "def name(self):\n        \"\"\"Get the name of the action.\"\"\"\n        name = getattr(self.action, \"__name__\", None)\n        # ascii(action) not defined for all actions, so must only be evaluated if getattr fails\n        return name if name is not None else ascii(self.action)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nevaluates the computation graph at this node.", "response": "def evaluate(self):\n        \"\"\"Get the result of evaluating the computation graph at this node.\"\"\"\n        if DEVELOP:\n            internal_assert(not self.been_called, \"inefficient reevaluation of action \" + self.name + \" with tokens\", self.tokens)\n            self.been_called = True\n        evaluated_toks = evaluate_tokens(self.tokens)\n        if logger.tracing:  # avoid the overhead of the call if not tracing\n            logger.log_trace(self.name, self.original, self.loc, evaluated_toks, self.tokens)\n        try:\n            return _trim_arity(self.action)(\n                self.original,\n                self.loc,\n                evaluated_toks,\n            )\n        except CoconutException:\n            raise\n        except (Exception, AssertionError):\n            traceback.print_exc()\n            raise CoconutInternalException(\"error computing action \" + self.name + \" of evaluated tokens\", evaluated_toks)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimplement the parse action for Combine.", "response": "def _combine(self, original, loc, tokens):\n        \"\"\"Implement the parse action for Combine.\"\"\"\n        combined_tokens = super(CombineNode, self).postParse(original, loc, tokens)\n        internal_assert(len(combined_tokens) == 1, \"Combine produced multiple tokens\", combined_tokens)\n        return combined_tokens[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a ComputationNode for Combine.", "response": "def postParse(self, original, loc, tokens):\n        \"\"\"Create a ComputationNode for Combine.\"\"\"\n        return ComputationNode(self._combine, original, loc, tokens, ignore_no_tokens=True, ignore_one_token=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parseImpl(self, instring, loc, *args, **kwargs):\n        with self.wrapper(self, instring, loc):\n            return super(Wrap, self).parseImpl(instring, loc, *args, **kwargs)", "response": "Wrapper around ParseElementEnhance. parseImpl."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gethash(compiled):\n    lines = compiled.splitlines()\n    if len(lines) < 3 or not lines[2].startswith(hash_prefix):\n        return None\n    else:\n        return lines[2][len(hash_prefix):]", "response": "Retrieve a hash from a header."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming basic minifications. Fails on non - tabideal indentation or a string with a #.", "response": "def minify(compiled):\n    \"\"\"Perform basic minifications.\n\n    Fails on non-tabideal indentation or a string with a #.\n    \"\"\"\n    compiled = compiled.strip()\n    if compiled:\n        out = []\n        for line in compiled.splitlines():\n            line = line.split(\"#\", 1)[0].rstrip()\n            if line:\n                ind = 0\n                while line.startswith(\" \"):\n                    line = line[1:]\n                    ind += 1\n                internal_assert(ind % tabideal == 0, \"invalid indentation in\", line)\n                out.append(\" \" * (ind // tabideal) + line)\n        compiled = \"\\n\".join(out) + \"\\n\"\n    return compiled"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_template(template):\n    with open(os.path.join(template_dir, template) + template_ext, \"r\") as template_file:\n        return template_file.read()", "response": "Read the given template file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate the dictionary passed to str. format in the header target_startswith and target_info.", "response": "def process_header_args(which, target, use_hash, no_tco, strict):\n    \"\"\"Create the dictionary passed to str.format in the header, target_startswith, and target_info.\"\"\"\n    target_startswith = one_num_ver(target)\n    target_info = get_target_info(target)\n\n    try_backport_lru_cache = r'''try:\n    from backports.functools_lru_cache import lru_cache\n    functools.lru_cache = lru_cache\nexcept ImportError: pass\n'''\n    try_import_trollius = r'''try:\n    import trollius as asyncio\nexcept ImportError:\n    class you_need_to_install_trollius: pass\n    asyncio = you_need_to_install_trollius()\n'''\n\n    format_dict = dict(\n        comment=comment(),\n        empty_dict=\"{}\",\n        target_startswith=target_startswith,\n        default_encoding=default_encoding,\n        hash_line=hash_prefix + use_hash + \"\\n\" if use_hash is not None else \"\",\n        typing_line=\"# type: ignore\\n\" if which == \"__coconut__\" else \"\",\n        VERSION_STR=VERSION_STR,\n        module_docstring='\"\"\"Built-in Coconut utilities.\"\"\"\\n\\n' if which == \"__coconut__\" else \"\",\n        object=\"(object)\" if target_startswith != \"3\" else \"\",\n        import_asyncio=_indent(\n            \"\" if not target or target_info >= (3, 5)\n            else \"import asyncio\\n\" if target_info >= (3, 4)\n            else r'''if _coconut_sys.version_info >= (3, 4):\n    import asyncio\nelse:\n''' + _indent(try_import_trollius) if target_info >= (3,)\n            else try_import_trollius,\n        ),\n        import_pickle=_indent(\n            r'''if _coconut_sys.version_info < (3,):\n    import cPickle as pickle\nelse:\n    import pickle''' if not target\n            else \"import cPickle as pickle\" if target_info < (3,)\n            else \"import pickle\"\n        ),\n        import_OrderedDict=_indent(\n            r'''if _coconut_sys.version_info >= (2, 7):\n    OrderedDict = collections.OrderedDict\nelse:\n    OrderedDict = dict'''\n            if not target\n            else \"OrderedDict = collections.OrderedDict\" if target_info >= (2, 7)\n            else \"OrderedDict = dict\"\n        ),\n        import_collections_abc=_indent(\n            r'''if _coconut_sys.version_info < (3, 3):\n    abc = collections\nelse:\n    import collections.abc as abc'''\n            if target_startswith != \"2\"\n            else \"abc = collections\"\n        ),\n        bind_lru_cache=_indent(\n            r'''if _coconut_sys.version_info < (3, 2):\n''' + _indent(try_backport_lru_cache)\n            if not target\n            else try_backport_lru_cache if target_startswith == \"2\"\n            else \"\"\n        ),\n        comma_bytearray=\", bytearray\" if target_startswith != \"3\" else \"\",\n        static_repr=\"staticmethod(repr)\" if target_startswith != \"3\" else \"repr\",\n        with_ThreadPoolExecutor=(\n            r'''from multiprocessing import cpu_count  # cpu_count() * 5 is the default Python 3.5 thread count\n        with ThreadPoolExecutor(cpu_count() * 5)''' if target_info < (3, 5)\n            else '''with ThreadPoolExecutor()'''\n        ),\n        tco_decorator=\"@_coconut_tco\\n\" + \" \" * 8 if not no_tco else \"\",\n        tail_call_func_args_kwargs=\"func(*args, **kwargs)\" if no_tco else \"_coconut_tail_call(func, *args, **kwargs)\",\n        comma_tco=\", _coconut_tail_call, _coconut_tco\" if not no_tco else \"\",\n        def_coconut_NamedTuple=(\n            r'''def _coconut_NamedTuple(name, fields):\n    return _coconut.collections.namedtuple(name, [x for x, t in fields])'''\n            if target_info < (3, 6)\n            else \"from typing import NamedTuple as _coconut_NamedTuple\"\n        ),\n        def_prepattern=(\n            r'''def prepattern(base_func):\n    \"\"\"DEPRECATED: Use addpattern instead.\"\"\"\n    def pattern_prepender(func):\n        return addpattern(func)(base_func)\n    return pattern_prepender\n''' if not strict else \"\"\n        ),\n        def_datamaker=(\n            r'''def datamaker(data_type):\n    \"\"\"DEPRECATED: Use makedata instead.\"\"\"\n    return _coconut.functools.partial(makedata, data_type)\n''' if not strict else \"\"\n        ),\n        __coconut__=(\n            '\"__coconut__\"' if target_startswith == \"3\"\n            else 'b\"__coconut__\"' if target_startswith == \"2\"\n            else 'str(\"__coconut__\")'\n        ),\n    )\n\n    format_dict[\"underscore_imports\"] = \"_coconut, _coconut_NamedTuple, _coconut_MatchError{comma_tco}, _coconut_igetitem, _coconut_base_compose, _coconut_forward_compose, _coconut_back_compose, _coconut_forward_star_compose, _coconut_back_star_compose, _coconut_pipe, _coconut_star_pipe, _coconut_back_pipe, _coconut_back_star_pipe, _coconut_bool_and, _coconut_bool_or, _coconut_none_coalesce, _coconut_minus, _coconut_map, _coconut_partial\".format(**format_dict)\n\n    # ._coconut_tco_func is used in main.coco, so don't remove it\n    #  here without replacing its usage there\n    format_dict[\"def_tco\"] = \"\" if no_tco else '''class _coconut_tail_call{object}:\n    __slots__ = (\"func\", \"args\", \"kwargs\")\n    def __init__(self, func, *args, **kwargs):\n        self.func, self.args, self.kwargs = func, args, kwargs\n_coconut_tco_func_dict = {empty_dict}\ndef _coconut_tco(func):\n    @_coconut.functools.wraps(func)\n    def tail_call_optimized_func(*args, **kwargs):\n        call_func = func\n        while True:\n            wkref = _coconut_tco_func_dict.get(_coconut.id(call_func))\n            if wkref is not None and wkref() is call_func:\n                call_func = call_func._coconut_tco_func\n            result = call_func(*args, **kwargs)  # pass --no-tco to clean up your traceback\n            if not isinstance(result, _coconut_tail_call):\n                return result\n            call_func, args, kwargs = result.func, result.args, result.kwargs\n    tail_call_optimized_func._coconut_tco_func = func\n    _coconut_tco_func_dict[_coconut.id(tail_call_optimized_func)] = _coconut.weakref.ref(tail_call_optimized_func)\n    return tail_call_optimized_func\n'''.format(**format_dict)\n\n    return format_dict, target_startswith, target_info"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates the specified header.", "response": "def getheader(which, target=\"\", use_hash=None, no_tco=False, strict=False):\n    \"\"\"Generate the specified header.\"\"\"\n    internal_assert(which in allowed_headers, \"invalid header type\", which)\n\n    if which == \"none\":\n        return \"\"\n\n    # initial, __coconut__, package, sys, code, file\n\n    format_dict, target_startswith, target_info = process_header_args(which, target, use_hash, no_tco, strict)\n\n    if which == \"initial\" or which == \"__coconut__\":\n        header = '''#!/usr/bin/env python{target_startswith}\n# -*- coding: {default_encoding} -*-\n{hash_line}{typing_line}\n# Compiled with Coconut version {VERSION_STR}\n\n{module_docstring}'''.format(**format_dict)\n    elif use_hash is not None:\n        raise CoconutInternalException(\"can only add a hash to an initial or __coconut__ header, not\", which)\n    else:\n        header = \"\"\n\n    if which == \"initial\":\n        return header\n\n    # __coconut__, package, sys, code, file\n\n    header += section(\"Coconut Header\")\n\n    if target_startswith != \"3\":\n        header += \"from __future__ import print_function, absolute_import, unicode_literals, division\\n\"\n    elif target_info >= (3, 5):\n        header += \"from __future__ import generator_stop\\n\"\n\n    if which == \"package\":\n        return header + '''import sys as _coconut_sys, os.path as _coconut_os_path\n_coconut_file_path = _coconut_os_path.dirname(_coconut_os_path.abspath(__file__))\n_coconut_cached_module = _coconut_sys.modules.get({__coconut__})\nif _coconut_cached_module is not None and _coconut_os_path.dirname(_coconut_cached_module.__file__) != _coconut_file_path:\n    del _coconut_sys.modules[{__coconut__}]\n_coconut_sys.path.insert(0, _coconut_file_path)\nfrom __coconut__ import {underscore_imports}\nfrom __coconut__ import *\n_coconut_sys.path.remove(_coconut_file_path)\n\n'''.format(**format_dict) + section(\"Compiled Coconut\")\n\n    if which == \"sys\":\n        return header + '''import sys as _coconut_sys\nfrom coconut.__coconut__ import {underscore_imports}\nfrom coconut.__coconut__ import *\n'''.format(**format_dict)\n\n    # __coconut__, code, file\n\n    header += \"import sys as _coconut_sys\\n\"\n\n    if target_startswith == \"3\":\n        header += PY3_HEADER\n    elif target_info >= (2, 7):\n        header += PY27_HEADER\n    elif target_startswith == \"2\":\n        header += PY2_HEADER\n    else:\n        header += PYCHECK_HEADER\n\n    header += get_template(\"header\").format(**format_dict)\n\n    if which == \"file\":\n        header += \"\\n\" + section(\"Compiled Coconut\")\n\n    return header"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a version string into a version tuple.", "response": "def ver_str_to_tuple(ver_str):\n    \"\"\"Convert a version string into a version tuple.\"\"\"\n    out = []\n    for x in ver_str.split(\".\"):\n        try:\n            x = int(x)\n        except ValueError:\n            pass\n        out.append(x)\n    return tuple(out)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun mypy with given arguments and shows the result.", "response": "def mypy_run(args):\n    \"\"\"Runs mypy with given arguments and shows the result.\"\"\"\n    logger.log_cmd([\"mypy\"] + args)\n    try:\n        stdout, stderr, exit_code = run(args)\n    except BaseException:\n        traceback.print_exc()\n    else:\n        for line in stdout.splitlines():\n            yield line, False\n        for line in stderr.splitlines():\n            yield line, True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd coconut to sys. path if it isn t there already.", "response": "def add_coconut_to_path():\n    \"\"\"Adds coconut to sys.path if it isn't there already.\"\"\"\n    try:\n        import coconut  # NOQA\n    except ImportError:\n        sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef writefile(openedfile, newcontents):\n    openedfile.seek(0)\n    openedfile.truncate()\n    openedfile.write(newcontents)", "response": "Set the contents of a file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat a path for displaying.", "response": "def showpath(path):\n    \"\"\"Format a path for displaying.\"\"\"\n    if logger.verbose:\n        return os.path.abspath(path)\n    else:\n        path = os.path.relpath(path)\n        if path.startswith(os.curdir + os.sep):\n            path = path[len(os.curdir + os.sep):]\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving encoding declarations from compiled code so it can be passed to exec.", "response": "def rem_encoding(code):\n    \"\"\"Remove encoding declarations from compiled code so it can be passed to exec.\"\"\"\n    old_lines = code.splitlines()\n    new_lines = []\n    for i in range(min(2, len(old_lines))):\n        line = old_lines[i]\n        if not (line.lstrip().startswith(\"#\") and \"coding\" in line):\n            new_lines.append(line)\n    new_lines += old_lines[2:]\n    return \"\\n\".join(new_lines)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying to evaluate the given code otherwise execute it.", "response": "def interpret(code, in_vars):\n    \"\"\"Try to evaluate the given code, otherwise execute it.\"\"\"\n    try:\n        result = eval(code, in_vars)\n    except SyntaxError:\n        pass  # exec code outside of exception context\n    else:\n        if result is not None:\n            print(ascii(result))\n        return  # don't also exec code\n    exec_func(code, in_vars)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef kill_children():\n    try:\n        import psutil\n    except ImportError:\n        logger.warn(\n            \"missing psutil; --jobs may not properly terminate\",\n            extra=\"run 'pip install coconut[jobs]' to fix\",\n        )\n    else:\n        master = psutil.Process()\n        children = master.children(recursive=True)\n        while children:\n            for child in children:\n                try:\n                    child.terminate()\n                except psutil.NoSuchProcess:\n                    pass  # process is already dead, so do nothing\n            children = master.children(recursive=True)", "response": "Terminate all child processes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef splitname(path):\n    dirpath, filename = os.path.split(path)\n    # we don't use os.path.splitext here because we want all extensions,\n    #  not just the last, to be put in exts\n    name, exts = filename.split(os.extsep, 1)\n    return dirpath, name, exts", "response": "Split a path into a directory name and extensions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_file(path):\n    if PY26:\n        dirpath, name, _ = splitname(path)\n        found = imp.find_module(name, [dirpath])\n        module = imp.load_module(\"__main__\", *found)\n        return vars(module)\n    else:\n        return runpy.run_path(path, run_name=\"__main__\")", "response": "Run a module from a path and return its variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef call_output(cmd, stdin=None, encoding_errors=\"replace\", **kwargs):\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)\n    stdout, stderr, retcode = [], [], None\n    while retcode is None:\n        if stdin is not None:\n            logger.log_prefix(\"<0 \", stdin.rstrip())\n        raw_out, raw_err = p.communicate(stdin)\n        stdin = None\n\n        out = raw_out.decode(get_encoding(sys.stdout), encoding_errors) if raw_out else \"\"\n        if out:\n            logger.log_prefix(\"1> \", out.rstrip())\n        stdout.append(out)\n\n        err = raw_err.decode(get_encoding(sys.stderr), encoding_errors) if raw_err else \"\"\n        if err:\n            logger.log_prefix(\"2> \", err.rstrip())\n        stderr.append(err)\n\n        retcode = p.poll()\n    return stdout, stderr, retcode", "response": "Run command and read output."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_cmd(cmd, show_output=True, raise_errs=True, **kwargs):\n    internal_assert(cmd and isinstance(cmd, list), \"console commands must be passed as non-empty lists\")\n    try:\n        from shutil import which\n    except ImportError:\n        pass\n    else:\n        cmd[0] = which(cmd[0]) or cmd[0]\n    logger.log_cmd(cmd)\n    try:\n        if show_output and raise_errs:\n            return subprocess.check_call(cmd, **kwargs)\n        elif show_output:\n            return subprocess.call(cmd, **kwargs)\n        else:\n            stdout, stderr, retcode = call_output(cmd, **kwargs)\n            output = \"\".join(stdout + stderr)\n            if retcode and raise_errs:\n                raise subprocess.CalledProcessError(retcode, cmd, output=output)\n            return output\n    except OSError:\n        logger.log_exc()\n        if raise_errs:\n            raise subprocess.CalledProcessError(oserror_retcode, cmd)\n        elif show_output:\n            return oserror_retcode\n        else:\n            return \"\"", "response": "Run a console command."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines whether stdin has any data to read.", "response": "def stdin_readable():\n    \"\"\"Determine whether stdin has any data to read.\"\"\"\n    if not WINDOWS:\n        try:\n            return bool(select([sys.stdin], [], [], 0)[0])\n        except Exception:\n            logger.log_exc()\n    try:\n        return not sys.stdin.isatty()\n    except Exception:\n        logger.log_exc()\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_recursion_limit(limit):\n    if limit < minimum_recursion_limit:\n        raise CoconutException(\"--recursion-limit must be at least \" + str(minimum_recursion_limit))\n    sys.setrecursionlimit(limit)", "response": "Set the Python recursion limit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef canparse(argparser, args):\n    old_error_method = argparser.error\n    argparser.error = _raise_ValueError\n    try:\n        argparser.parse_args(args)\n    except ValueError:\n        return False\n    else:\n        return True\n    finally:\n        argparser.error = old_error_method", "response": "Determines if argparser can parse args."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting pygments syntax highlighting style.", "response": "def set_style(self, style):\n        \"\"\"Set pygments syntax highlighting style.\"\"\"\n        if style == \"none\":\n            self.style = None\n        elif prompt_toolkit is None:\n            raise CoconutException(\"syntax highlighting is not supported on this Python version\")\n        elif style == \"list\":\n            print(\"Coconut Styles: none, \" + \", \".join(pygments.styles.get_all_styles()))\n            sys.exit(0)\n        elif style in pygments.styles.get_all_styles():\n            self.style = style\n        else:\n            raise CoconutException(\"unrecognized pygments style\", style, extra=\"use '--style list' to show all valid styles\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_history_file(self, path):\n        if path:\n            self.history = prompt_toolkit.history.FileHistory(fixpath(path))\n        else:\n            self.history = prompt_toolkit.history.InMemoryHistory()", "response": "Set path to history file. \"\" produces no file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef input(self, more=False):\n        sys.stdout.flush()\n        if more:\n            msg = more_prompt\n        else:\n            msg = main_prompt\n        if self.style is not None:\n            internal_assert(prompt_toolkit is not None, \"without prompt_toolkit cannot highlight style\", self.style)\n            try:\n                return self.prompt(msg)\n            except EOFError:\n                raise  # issubclass(EOFError, Exception), so we have to do this\n            except (Exception, AssertionError):\n                logger.display_exc()\n                logger.show_sig(\"Syntax highlighting failed; switching to --style none.\")\n                self.style = None\n        return input(msg)", "response": "Prompt for code input."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting input using prompt_toolkit.", "response": "def prompt(self, msg):\n        \"\"\"Get input using prompt_toolkit.\"\"\"\n        try:\n            # prompt_toolkit v2\n            prompt = prompt_toolkit.PromptSession(history=self.history).prompt\n        except AttributeError:\n            # prompt_toolkit v1\n            prompt = partial(prompt_toolkit.prompt, history=self.history)\n        return prompt(\n            msg,\n            multiline=self.multiline,\n            vi_mode=self.vi_mode,\n            wrap_lines=self.wrap_lines,\n            enable_history_search=self.history_search,\n            lexer=PygmentsLexer(CoconutLexer),\n            style=style_from_pygments_cls(\n                pygments.styles.get_style_by_name(self.style),\n            ),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fix_pickle(self):\n        from coconut import __coconut__  # this is expensive, so only do it here\n        for var in self.vars:\n            if not var.startswith(\"__\") and var in dir(__coconut__):\n                self.vars[var] = getattr(__coconut__, var)", "response": "Fix pickling of Coconut header objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes a Python file.", "response": "def run_file(self, path, all_errors_exit=True):\n        \"\"\"Execute a Python file.\"\"\"\n        path = fixpath(path)\n        with self.handling_errors(all_errors_exit):\n            module_vars = run_file(path)\n            self.vars.update(module_vars)\n            self.store(\"from \" + splitname(path)[1] + \" import *\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef was_run_code(self, get_all=True):\n        if self.stored is None:\n            return \"\"\n        else:\n            if get_all:\n                self.stored = [\"\\n\".join(self.stored)]\n            return self.stored[-1]", "response": "Get all the code that was run."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_reqs(which=\"main\"):\n    reqs = []\n    for req in all_reqs[which]:\n        req_str = req + \">=\" + ver_tuple_to_str(min_versions[req])\n        if req in version_strictly:\n            req_str += \",<\" + ver_tuple_to_str(min_versions[req][:-1]) + \".\" + str(min_versions[req][-1] + 1)\n        reqs.append(req_str)\n    return reqs", "response": "Gets requirements from all_reqs with versions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding the union of all the given requirements.", "response": "def uniqueify_all(init_reqs, *other_reqs):\n    \"\"\"Find the union of all the given requirements.\"\"\"\n    union = set(init_reqs)\n    for reqs in other_reqs:\n        union.update(reqs)\n    return list(union)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all_versions(req):\n    import requests\n    url = \"https://pypi.python.org/pypi/\" + req + \"/json\"\n    return tuple(requests.get(url).json()[\"releases\"].keys())", "response": "Get all versions of req from PyPI."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndetermine if the first version tuple is newer than the second version tuple.", "response": "def newer(new_ver, old_ver, strict=False):\n    \"\"\"Determines if the first version tuple is newer than the second.\n    True if newer, False if older, None if difference is after specified version parts.\"\"\"\n    if old_ver == new_ver or old_ver + (0,) == new_ver:\n        return False\n    for n, o in zip(new_ver, old_ver):\n        if not isinstance(n, int):\n            o = str(o)\n        if o < n:\n            return True\n        elif o > n:\n            return False\n    return not strict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint new version of all the modules in the current tree.", "response": "def print_new_versions(strict=False):\n    \"\"\"Prints new requirement versions.\"\"\"\n    new_updates = []\n    same_updates = []\n    for req in everything_in(all_reqs):\n        new_versions = []\n        same_versions = []\n        for ver_str in all_versions(req):\n            if newer(ver_str_to_tuple(ver_str), min_versions[req], strict=True):\n                new_versions.append(ver_str)\n            elif not strict and newer(ver_str_to_tuple(ver_str), min_versions[req]):\n                same_versions.append(ver_str)\n        update_str = req + \": \" + ver_tuple_to_str(min_versions[req]) + \" -> \" + \", \".join(\n            new_versions + [\"(\" + v + \")\" for v in same_versions],\n        )\n        if new_versions:\n            new_updates.append(update_str)\n        elif same_versions:\n            same_updates.append(update_str)\n    print(\"\\n\".join(new_updates + same_updates))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_error(err_type, err_value, err_trace=None):\n    if err_trace is None:\n        err_parts = \"\".join(traceback.format_exception_only(err_type, err_value)).strip().split(\": \", 1)\n        if len(err_parts) == 1:\n            err_name, err_msg = err_parts[0], \"\"\n        else:\n            err_name, err_msg = err_parts\n        err_name = err_name.split(\".\")[-1]\n        return err_name + \": \" + err_msg\n    else:\n        return \"\".join(traceback.format_exception(err_type, err_value, err_trace)).strip()", "response": "Properly formats the specified error."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef complain(error):\n    if callable(error):\n        if DEVELOP:\n            raise error()\n    elif DEVELOP:\n        raise error\n    else:\n        logger.warn_err(error)", "response": "Raises in develop ; warns in release"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncopy the contents of another log record into this one.", "response": "def copy_from(self, other):\n        \"\"\"Copy other onto self.\"\"\"\n        self.verbose, self.quiet, self.path, self.name, self.tracing = other.verbose, other.quiet, other.path, other.name, other.tracing"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef display(self, messages, sig=\"\", debug=False):\n        full_message = \"\".join(\n            sig + line for line in \" \".join(\n                str(msg) for msg in messages\n            ).splitlines(True)\n        )\n        if not full_message:\n            full_message = sig.rstrip()\n        if debug:\n            printerr(full_message)\n        else:\n            print(full_message)", "response": "Prints an iterator of messages."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint error messages with main signature if not quiet.", "response": "def show_error(self, *messages):\n        \"\"\"Prints error messages with main signature if not --quiet.\"\"\"\n        if not self.quiet:\n            self.display(messages, main_sig, debug=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog debug messages with the given signature if verbose.", "response": "def log_prefix(self, prefix, *messages):\n        \"\"\"Logs debug messages with the given signature if --verbose.\"\"\"\n        if self.verbose:\n            self.display(messages, prefix, debug=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef log_vars(self, message, variables, rem_vars=(\"self\",)):\n        if self.verbose:\n            new_vars = dict(variables)\n            for v in rem_vars:\n                del new_vars[v]\n            printerr(message, new_vars)", "response": "Logs variables with given message if verbose."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_error(self):\n        exc_info = sys.exc_info()\n        if exc_info[0] is None:\n            return None\n        else:\n            err_type, err_value, err_trace = exc_info[0], exc_info[1], None\n            if self.verbose and len(exc_info) > 2:\n                err_trace = exc_info[2]\n            return format_error(err_type, err_value, err_trace)", "response": "Properly formats the current error."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_tabulated(self, begin, middle, end):\n        internal_assert(len(begin) < info_tabulation, \"info message too long\", begin)\n        self.show(begin + \" \" * (info_tabulation - len(begin)) + middle + \" \" + end)", "response": "Shows a tabulated message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_tag(self, tag, code, multiline=False):\n        if self.tracing:\n            if callable(code):\n                code = code()\n            tagstr = \"[\" + str(tag) + \"]\"\n            if multiline:\n                printerr(tagstr + \"\\n\" + displayable(code))\n            else:\n                printerr(tagstr, ascii(code))", "response": "Logs a tagged message if tracing."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats and displays a trace if tracing.", "response": "def log_trace(self, tag, original, loc, tokens=None, extra=None):\n        \"\"\"Formats and displays a trace if tracing.\"\"\"\n        if self.tracing:\n            tag, original, loc = displayable(tag), displayable(original), int(loc)\n            if \"{\" not in tag:\n                out = [\"[\" + tag + \"]\"]\n                add_line_col = True\n                if tokens is not None:\n                    if isinstance(tokens, Exception):\n                        msg = displayable(str(tokens))\n                        if \"{\" in msg:\n                            head, middle = msg.split(\"{\", 1)\n                            middle, tail = middle.rsplit(\"}\", 1)\n                            msg = head + \"{...}\" + tail\n                        out.append(msg)\n                        add_line_col = False\n                    elif len(tokens) == 1 and isinstance(tokens[0], str):\n                        out.append(ascii(tokens[0]))\n                    else:\n                        out.append(ascii(tokens))\n                if add_line_col:\n                    out.append(\"(line:\" + str(lineno(loc, original)) + \", col:\" + str(col(loc, original)) + \")\")\n                if extra is not None:\n                    out.append(\"from \" + ascii(extra))\n                printerr(*out)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trace(self, item):\n        if DEVELOP:\n            item.debugActions = (\n                None,  # no start action\n                self._trace_success_action,\n                self._trace_exc_action,\n            )\n            item.debug = True\n        return item", "response": "Traces a parse element."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding the parsing stats for the current instance of the class.", "response": "def gather_parsing_stats(self):\n        \"\"\"Times parsing if --verbose.\"\"\"\n        if self.verbose:\n            start_time = time.clock()\n            try:\n                yield\n            finally:\n                elapsed_time = time.clock() - start_time\n                printerr(\"Time while parsing:\", elapsed_time, \"seconds\")\n                if packrat_cache:\n                    hits, misses = ParserElement.packrat_cache_stats\n                    printerr(\"Packrat parsing stats:\", hits, \"hits;\", misses, \"misses\")\n        else:\n            yield"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npatch built - in Python logging if necessary.", "response": "def patch_logging(self):\n        \"\"\"Patches built-in Python logging if necessary.\"\"\"\n        if not hasattr(logging, \"getLogger\"):\n            def getLogger(name=None):\n                other = Logger(self)\n                if name is not None:\n                    other.name = name\n                return other\n            logging.getLogger = getLogger"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisplay all available logging information.", "response": "def pylog(self, *args, **kwargs):\n        \"\"\"Display all available logging information.\"\"\"\n        printerr(self.name, args, kwargs, traceback.format_exc())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lenient_add_filter(self, *args, **kwargs):\n    if args and args[0] != \"raiseonerror\":\n        self.original_add_filter(*args, **kwargs)", "response": "Disables the raiseonerror filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles a file modified event.", "response": "def on_modified(self, event):\n        \"\"\"Handle a file modified event.\"\"\"\n        path = event.src_path\n        if path not in self.saw:\n            self.saw.add(path)\n            self.recompile(path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit into positional arguments and keyword arguments.", "response": "def split_function_call(tokens, loc):\n    \"\"\"Split into positional arguments and keyword arguments.\"\"\"\n    pos_args = []\n    star_args = []\n    kwd_args = []\n    dubstar_args = []\n    for arg in tokens:\n        argstr = \"\".join(arg)\n        if len(arg) == 1:\n            if star_args or kwd_args or dubstar_args:\n                raise CoconutDeferredSyntaxError(\"positional arguments must come first\", loc)\n            pos_args.append(argstr)\n        elif len(arg) == 2:\n            if arg[0] == \"*\":\n                if kwd_args or dubstar_args:\n                    raise CoconutDeferredSyntaxError(\"star unpacking must come before keyword arguments\", loc)\n                star_args.append(argstr)\n            elif arg[0] == \"**\":\n                dubstar_args.append(argstr)\n            else:\n                kwd_args.append(argstr)\n        else:\n            raise CoconutInternalException(\"invalid function call argument\", arg)\n    return pos_args, star_args, kwd_args, dubstar_args"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef attrgetter_atom_split(tokens):\n    if len(tokens) == 1:  # .attr\n        return tokens[0], None\n    elif len(tokens) >= 2 and tokens[1] == \"(\":  # .method(...\n        if len(tokens) == 2:  # .method()\n            return tokens[0], \"\"\n        elif len(tokens) == 3:  # .method(args)\n            return tokens[0], tokens[2]\n        else:\n            raise CoconutInternalException(\"invalid methodcaller literal tokens\", tokens)\n    else:\n        raise CoconutInternalException(\"invalid attrgetter literal tokens\", tokens)", "response": "Split attrgetter_atom_tokens into attr_or_method_name method_args_or_none_if_attr."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing a pipe item which could be a partial attribute access method call or expression.", "response": "def pipe_item_split(tokens, loc):\n    \"\"\"Process a pipe item, which could be a partial, an attribute access, a method call, or an expression.\n    Return (type, split) where split is\n        - (expr,) for expression,\n        - (func, pos_args, kwd_args) for partial,\n        - (name, args) for attr/method, and\n        - (op, args) for itemgetter.\"\"\"\n    # list implies artificial tokens, which must be expr\n    if isinstance(tokens, list) or \"expr\" in tokens:\n        internal_assert(len(tokens) == 1, \"invalid expr pipe item tokens\", tokens)\n        return \"expr\", (tokens[0],)\n    elif \"partial\" in tokens:\n        func, args = tokens\n        pos_args, star_args, kwd_args, dubstar_args = split_function_call(args, loc)\n        return \"partial\", (func, join_args(pos_args, star_args), join_args(kwd_args, dubstar_args))\n    elif \"attrgetter\" in tokens:\n        name, args = attrgetter_atom_split(tokens)\n        return \"attrgetter\", (name, args)\n    elif \"itemgetter\" in tokens:\n        op, args = tokens\n        return \"itemgetter\", (op, args)\n    else:\n        raise CoconutInternalException(\"invalid pipe item tokens\", tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform infix token processing.", "response": "def get_infix_items(tokens, callback=infix_error):\n    \"\"\"Perform infix token processing.\n\n    Takes a callback that (takes infix tokens and returns a string) to handle inner infix calls.\n    \"\"\"\n    internal_assert(len(tokens) >= 3, \"invalid infix tokens\", tokens)\n    (arg1, func, arg2), tokens = tokens[:3], tokens[3:]\n    args = list(arg1) + list(arg2)\n    while tokens:\n        args = [callback([args, func, []])]\n        (func, newarg), tokens = tokens[:2], tokens[2:]\n        args += list(newarg)\n    return func, args"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef comp_pipe_info(op):\n    if op == \"..>\":\n        return \"forwards\", False\n    elif op == \"<..\":\n        return \"backwards\", False\n    elif op == \"..*>\":\n        return \"forwards\", True\n    elif op == \"<*..\":\n        return \"backwards\", True\n    else:\n        raise CoconutInternalException(\"invalid function composition pipe operator\", op)", "response": "Returns ( direction star ) where direction is forwards or backwards."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing the items in the list of items in the list.", "response": "def item_handle(loc, tokens):\n    \"\"\"Process trailers.\"\"\"\n    out = tokens.pop(0)\n    for i, trailer in enumerate(tokens):\n        if isinstance(trailer, str):\n            out += trailer\n        elif len(trailer) == 1:\n            if trailer[0] == \"$[]\":\n                out = \"_coconut.functools.partial(_coconut_igetitem, \" + out + \")\"\n            elif trailer[0] == \"$\":\n                out = \"_coconut.functools.partial(_coconut.functools.partial, \" + out + \")\"\n            elif trailer[0] == \"[]\":\n                out = \"_coconut.functools.partial(_coconut.operator.getitem, \" + out + \")\"\n            elif trailer[0] == \".\":\n                out = \"_coconut.functools.partial(_coconut.getattr, \" + out + \")\"\n            elif trailer[0] == \"type:[]\":\n                out = \"_coconut.typing.Sequence[\" + out + \"]\"\n            elif trailer[0] == \"type:$[]\":\n                out = \"_coconut.typing.Iterable[\" + out + \"]\"\n            elif trailer[0] == \"type:?\":\n                out = \"_coconut.typing.Optional[\" + out + \"]\"\n            elif trailer[0] == \"?\":\n                # short-circuit the rest of the evaluation\n                rest_of_trailers = tokens[i + 1:]\n                if len(rest_of_trailers) == 0:\n                    raise CoconutDeferredSyntaxError(\"None-coalescing ? must have something after it\", loc)\n                not_none_tokens = [\"x\"]\n                not_none_tokens.extend(rest_of_trailers)\n                return \"(lambda x: None if x is None else \" + item_handle(loc, not_none_tokens) + \")(\" + out + \")\"\n            else:\n                raise CoconutInternalException(\"invalid trailer symbol\", trailer[0])\n        elif len(trailer) == 2:\n            if trailer[0] == \"$[\":\n                out = \"_coconut_igetitem(\" + out + \", \" + trailer[1] + \")\"\n            elif trailer[0] == \"$(\":\n                args = trailer[1][1:-1]\n                if not args:\n                    raise CoconutDeferredSyntaxError(\"a partial application argument is required\", loc)\n                out = \"_coconut.functools.partial(\" + out + \", \" + args + \")\"\n            elif trailer[0] == \"$[\":\n                out = \"_coconut_igetitem(\" + out + \", \" + trailer[1] + \")\"\n            elif trailer[0] == \"$(?\":\n                pos_args, star_args, kwd_args, dubstar_args = split_function_call(trailer[1], loc)\n                extra_args_str = join_args(star_args, kwd_args, dubstar_args)\n                argdict_pairs = []\n                has_question_mark = False\n                for i, arg in enumerate(pos_args):\n                    if arg == \"?\":\n                        has_question_mark = True\n                    else:\n                        argdict_pairs.append(str(i) + \": \" + arg)\n                if not has_question_mark:\n                    raise CoconutInternalException(\"no question mark in question mark partial\", trailer[1])\n                elif argdict_pairs or extra_args_str:\n                    out = (\n                        \"_coconut_partial(\"\n                        + out\n                        + \", {\" + \", \".join(argdict_pairs) + \"}\"\n                        + \", \" + str(len(pos_args))\n                        + (\", \" if extra_args_str else \"\") + extra_args_str\n                        + \")\"\n                    )\n                else:\n                    raise CoconutDeferredSyntaxError(\"a non-? partial application argument is required\", loc)\n            else:\n                raise CoconutInternalException(\"invalid special trailer\", trailer[0])\n        else:\n            raise CoconutInternalException(\"invalid trailer tokens\", trailer)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing a pipe call.", "response": "def pipe_handle(loc, tokens, **kwargs):\n    \"\"\"Process pipe calls.\"\"\"\n    internal_assert(set(kwargs) <= set((\"top\",)), \"unknown pipe_handle keyword arguments\", kwargs)\n    top = kwargs.get(\"top\", True)\n    if len(tokens) == 1:\n        item = tokens.pop()\n        if not top:  # defer to other pipe_handle call\n            return item\n\n        # we've only been given one operand, so we can't do any optimization, so just produce the standard object\n        name, split_item = pipe_item_split(item, loc)\n        if name == \"expr\":\n            internal_assert(len(split_item) == 1)\n            return split_item[0]\n        elif name == \"partial\":\n            internal_assert(len(split_item) == 3)\n            return \"_coconut.functools.partial(\" + join_args(split_item) + \")\"\n        elif name == \"attrgetter\":\n            return attrgetter_atom_handle(loc, item)\n        elif name == \"itemgetter\":\n            return itemgetter_handle(item)\n        else:\n            raise CoconutInternalException(\"invalid split pipe item\", split_item)\n\n    else:\n        item, op = tokens.pop(), tokens.pop()\n\n        if op == \"|>\" or op == \"|*>\":\n            # if this is an implicit partial, we have something to apply it to, so optimize it\n            name, split_item = pipe_item_split(item, loc)\n            star = \"*\" if op == \"|*>\" else \"\"\n            if name == \"expr\":\n                internal_assert(len(split_item) == 1)\n                return \"(\" + split_item[0] + \")(\" + star + pipe_handle(loc, tokens) + \")\"\n            elif name == \"partial\":\n                internal_assert(len(split_item) == 3)\n                return split_item[0] + \"(\" + join_args((split_item[1], star + pipe_handle(loc, tokens), split_item[2])) + \")\"\n            elif name == \"attrgetter\":\n                internal_assert(len(split_item) == 2)\n                if star:\n                    raise CoconutDeferredSyntaxError(\"cannot star pipe into attribute access or method call\", loc)\n                return \"(\" + pipe_handle(loc, tokens) + \").\" + split_item[0] + (\"(\" + split_item[1] + \")\" if split_item[1] is not None else \"\")\n            elif name == \"itemgetter\":\n                internal_assert(len(split_item) == 2)\n                if star:\n                    raise CoconutDeferredSyntaxError(\"cannot star pipe into item getting\", loc)\n                op, args = split_item\n                if op == \"[\":\n                    return \"(\" + pipe_handle(loc, tokens) + \")[\" + args + \"]\"\n                elif op == \"$[\":\n                    return \"_coconut_igetitem(\" + pipe_handle(loc, tokens) + \", \" + args + \")\"\n                else:\n                    raise CoconutInternalException(\"pipe into invalid implicit itemgetter operation\", op)\n            else:\n                raise CoconutInternalException(\"invalid split pipe item\", split_item)\n\n        elif op == \"<|\" or op == \"<*|\":\n            # for backwards pipes, we just reuse the machinery for forwards pipes\n            star = \"*\" if op == \"<*|\" else \"\"\n            inner_item = pipe_handle(loc, tokens, top=False)\n            if isinstance(inner_item, str):\n                inner_item = [inner_item]  # artificial pipe item\n            return pipe_handle(loc, [item, \"|\" + star + \">\", inner_item])\n\n        else:\n            raise CoconutInternalException(\"invalid pipe operator\", op)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess a pipe function composition.", "response": "def comp_pipe_handle(loc, tokens):\n    \"\"\"Process pipe function composition.\"\"\"\n    internal_assert(len(tokens) >= 3 and len(tokens) % 2 == 1, \"invalid composition pipe tokens\", tokens)\n    funcs = [tokens[0]]\n    stars = []\n    direction = None\n    for i in range(1, len(tokens), 2):\n        op, fn = tokens[i], tokens[i + 1]\n        new_direction, star = comp_pipe_info(op)\n        if direction is None:\n            direction = new_direction\n        elif new_direction != direction:\n            raise CoconutDeferredSyntaxError(\"cannot mix function composition pipe operators with different directions\", loc)\n        funcs.append(fn)\n        stars.append(star)\n    if direction == \"backwards\":\n        funcs.reverse()\n        stars.reverse()\n    func = funcs.pop(0)\n    funcstars = zip(funcs, stars)\n    return \"_coconut_base_compose(\" + func + \", \" + \", \".join(\n        \"(%s, %s)\" % (f, star) for f, star in funcstars\n    ) + \")\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the None - coalescing operator.", "response": "def none_coalesce_handle(tokens):\n    \"\"\"Process the None-coalescing operator.\"\"\"\n    if len(tokens) == 1:\n        return tokens[0]\n    elif tokens[0].isalnum():\n        return \"({b} if {a} is None else {a})\".format(\n            a=tokens[0],\n            b=none_coalesce_handle(tokens[1:]),\n        )\n    else:\n        return \"(lambda {x}: {b} if {x} is None else {x})({a})\".format(\n            x=none_coalesce_var,\n            a=tokens[0],\n            b=none_coalesce_handle(tokens[1:]),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef typedef_callable_handle(tokens):\n    if len(tokens) == 1:\n        return '_coconut.typing.Callable[..., ' + tokens[0] + ']'\n    elif len(tokens) == 2:\n        return '_coconut.typing.Callable[[' + tokens[0] + '], ' + tokens[1] + ']'\n    else:\n        raise CoconutInternalException(\"invalid Callable typedef tokens\", tokens)", "response": "Process - > to Callable inside type annotations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing assignment function definition.", "response": "def math_funcdef_handle(tokens):\n    \"\"\"Process assignment function definition.\"\"\"\n    internal_assert(len(tokens) == 2, \"invalid assignment function definition tokens\", tokens)\n    return tokens[0] + (\"\" if tokens[1].startswith(\"\\n\") else \" \") + tokens[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef itemgetter_handle(tokens):\n    internal_assert(len(tokens) == 2, \"invalid implicit itemgetter args\", tokens)\n    op, args = tokens\n    if op == \"[\":\n        return \"_coconut.operator.itemgetter(\" + args + \")\"\n    elif op == \"$[\":\n        return \"_coconut.functools.partial(_coconut_igetitem, index=\" + args + \")\"\n    else:\n        raise CoconutInternalException(\"invalid implicit itemgetter type\", op)", "response": "Process implicit itemgetter partials."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses inline nonlocal and global statements.", "response": "def namelist_handle(tokens):\n    \"\"\"Process inline nonlocal and global statements.\"\"\"\n    if len(tokens) == 1:\n        return tokens[0]\n    elif len(tokens) == 2:\n        return tokens[0] + \"\\n\" + tokens[0] + \" = \" + tokens[1]\n    else:\n        raise CoconutInternalException(\"invalid in-line nonlocal / global tokens\", tokens)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess tail - call - optimizable return statements.", "response": "def tco_return_handle(tokens):\n    \"\"\"Process tail-call-optimizable return statements.\"\"\"\n    internal_assert(len(tokens) == 2, \"invalid tail-call-optimizable return statement tokens\", tokens)\n    if tokens[1].startswith(\"()\"):\n        return \"return _coconut_tail_call(\" + tokens[0] + \")\" + tokens[1][2:]  # tokens[1] contains \\n\n    else:\n        return \"return _coconut_tail_call(\" + tokens[0] + \", \" + tokens[1][1:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef split_func_name_args_params_handle(tokens):\n    internal_assert(len(tokens) == 2, \"invalid function definition splitting tokens\", tokens)\n    func_name = tokens[0]\n    func_args = []\n    func_params = []\n    for arg in tokens[1]:\n        if len(arg) > 1 and arg[0] in (\"*\", \"**\"):\n            func_args.append(arg[1])\n        elif arg[0] != \"*\":\n            func_args.append(arg[0])\n        func_params.append(\"\".join(arg))\n    return [\n        func_name,\n        \", \".join(func_args),\n        \"(\" + \", \".join(func_params) + \")\",\n    ]", "response": "Process splitting a function into name params and args."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef join_match_funcdef(tokens):\n    if len(tokens) == 2:\n        (func, insert_after_docstring), body = tokens\n        docstring = None\n    elif len(tokens) == 3:\n        (func, insert_after_docstring), docstring, body = tokens\n    else:\n        raise CoconutInternalException(\"invalid docstring insertion tokens\", tokens)\n    # insert_after_docstring and body are their own self-contained suites, but we\n    # expect them to both be one suite, so we have to join them together\n    insert_after_docstring, dedent = split_trailing_indent(insert_after_docstring)\n    indent, body = split_leading_indent(body)\n    indentation = collapse_indents(dedent + indent)\n    return (\n        func\n        + (docstring if docstring is not None else \"\")\n        + insert_after_docstring\n        + indentation\n        + body\n    )", "response": "Join the pieces of a pattern - matching function together."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprocessing a where statement.", "response": "def where_stmt_handle(tokens):\n    \"\"\"Process a where statement.\"\"\"\n    internal_assert(len(tokens) == 2, \"invalid where statement tokens\", tokens)\n    base_stmt, assignment_stmts = tokens\n    stmts = list(assignment_stmts) + [base_stmt]\n    return \"\\n\".join(stmts) + \"\\n\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_grammar_names():\n    for varname, val in vars(Grammar).items():\n        if isinstance(val, ParserElement):\n            setattr(Grammar, varname, val.setName(varname))", "response": "Set names of grammar elements to their variable names."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess command - line arguments.", "response": "def cmd(args, interact=False):\n    \"\"\"Process command-line arguments.\"\"\"\n    if isinstance(args, (str, bytes)):\n        args = args.split()\n    return CLI.cmd(args=args, interact=interact)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the Coconut version.", "response": "def version(which=\"num\"):\n    \"\"\"Get the Coconut version.\"\"\"\n    if which in VERSIONS:\n        return VERSIONS[which]\n    else:\n        raise CoconutException(\n            \"invalid version type \" + ascii(which),\n            extra=\"valid versions are \" + \", \".join(VERSIONS),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auto_compilation(on=True):\n    if on:\n        if coconut_importer not in sys.meta_path:\n            sys.meta_path.insert(0, coconut_importer)\n    else:\n        try:\n            sys.meta_path.remove(coconut_importer)\n        except ValueError:\n            pass", "response": "Turn automatic compilation of Coconut files on or off."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for a Coconut file of the given name and compiles it.", "response": "def find_module(self, fullname, path=None):\n        \"\"\"Searches for a Coconut file of the given name and compiles it.\"\"\"\n        basepaths = [\"\"] + list(sys.path)\n        if fullname.startswith(\".\"):\n            if path is None:\n                # we can't do a relative import if there's no package path\n                return None\n            fullname = fullname[1:]\n            basepaths.insert(0, path)\n        fullpath = os.path.join(*fullname.split(\".\"))\n        for head in basepaths:\n            path = os.path.join(head, fullpath)\n            filepath = path + self.ext\n            dirpath = os.path.join(path, \"__init__\" + self.ext)\n            if os.path.exists(filepath):\n                self.run_compiler(filepath)\n                # Coconut file was found and compiled, now let Python import it\n                return None\n            if os.path.exists(dirpath):\n                self.run_compiler(path)\n                # Coconut package was found and compiled, now let Python import it\n                return None\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a part of json report for coveralls.", "response": "def report(self, morfs=None):\n        \"\"\"\n        Generate a part of json report for coveralls\n\n        `morfs` is a list of modules or filenames.\n        `outfile` is a file object to write the json to.\n        \"\"\"\n        units = None\n        if hasattr(self, 'find_code_units'):\n            self.find_code_units(morfs)\n        else:\n            units = self.find_file_reporters(morfs)\n\n        if units is None:\n            if hasattr(self, 'code_units'):\n                units = self.code_units\n            else:\n                units = self.file_reporters\n\n        for cu in units:\n            try:\n                analyzed = self.coverage._analyze(cu)  # pylint: disable=W0212\n                self.parse_file(cu, analyzed)\n            except NoSource:\n                if not self.config.ignore_errors:\n                    log.warning('No source for %s', cu.filename)\n            except NotPython:\n                # Only report errors for .py files, and only if we didn't\n                # explicitly suppress those errors.\n                if cu.should_be_python() and not self.config.ignore_errors:\n                    log.warning('Source file is not python %s', cu.filename)\n            except KeyError:\n                cov3x = __version__[0] < 4\n                cov40 = __version__[0] == 4 and __version__[1] < 1\n                if cov3x or cov40:\n                    raise CoverallsException(\n                        'Old (<4.1) versions of coverage.py do not work '\n                        'consistently on new versions of Python. Please '\n                        'upgrade your coverage.py.'\n                    )\n\n                raise\n\n        return self.source_files"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a flat list of all branches that are executed and missing.", "response": "def get_arcs(analysis):\n        \"\"\"\n        Hit stats for each branch.\n\n        Returns a flat list where every four values represent a branch:\n        1. line-number\n        2. block-number (not used)\n        3. branch-number\n        4. hits (we only get 1/0 from coverage.py)\n        \"\"\"\n        if not analysis.has_arcs():\n            return None\n\n        branch_lines = analysis.branch_lines()\n        branches = []\n\n        for l1, l2 in analysis.arcs_executed():\n            if l1 in branch_lines:\n                branches.extend((l1, 0, abs(l2), 1))\n\n        for l1, l2 in analysis.arcs_missing():\n            if l1 in branch_lines:\n                branches.extend((l1, 0, abs(l2), 0))\n\n        return branches"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating data for single file", "response": "def parse_file(self, cu, analysis):\n        \"\"\"Generate data for single file\"\"\"\n        if hasattr(analysis, 'parser'):\n            filename = cu.file_locator.relative_filename(cu.filename)\n            source_lines = analysis.parser.lines\n            with cu.source_file() as source_file:\n                source = source_file.read()\n\n            try:\n                if sys.version_info < (3, 0):\n                    encoding = source_encoding(source)\n                    if encoding != 'utf-8':\n                        source = source.decode(encoding).encode('utf-8')\n            except UnicodeDecodeError:\n                log.warning(\n                    'Source file %s can not be properly decoded, skipping. '\n                    'Please check if encoding declaration is ok',\n                    os.path.basename(cu.filename))\n                return\n        else:\n            if hasattr(cu, 'relative_filename'):\n                filename = cu.relative_filename()\n            else:\n                filename = analysis.coverage.file_locator.relative_filename(\n                    cu.filename)\n\n            token_lines = analysis.file_reporter.source_token_lines()\n            source_lines = list(enumerate(token_lines))\n            source = analysis.file_reporter.source()\n\n        coverage_lines = [self.get_hits(i, analysis)\n                          for i in range(1, len(source_lines) + 1)]\n\n        # ensure results are properly merged between platforms\n        posix_filename = filename.replace(os.path.sep, '/')\n\n        results = {\n            'name': posix_filename,\n            'source': source,\n            'coverage': coverage_lines,\n        }\n\n        branches = self.get_arcs(analysis)\n        if branches:\n            results['branches'] = branches\n\n        self.source_files.append(results)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef git_info():\n    try:\n        branch = (os.environ.get('APPVEYOR_REPO_BRANCH')\n                  or os.environ.get('BUILDKITE_BRANCH')\n                  or os.environ.get('CI_BRANCH')\n                  or os.environ.get('CIRCLE_BRANCH')\n                  or os.environ.get('GIT_BRANCH')\n                  or os.environ.get('TRAVIS_BRANCH')\n                  or os.environ.get('BRANCH_NAME')\n                  or run_command('git', 'rev-parse', '--abbrev-ref', 'HEAD'))\n        head = {\n            'id': gitlog('%H'),\n            'author_name': gitlog('%aN'),\n            'author_email': gitlog('%ae'),\n            'committer_name': gitlog('%cN'),\n            'committer_email': gitlog('%ce'),\n            'message': gitlog('%s'),\n        }\n        remotes = [{'name': line.split()[0], 'url': line.split()[1]}\n                   for line in run_command('git', 'remote', '-v').splitlines()\n                   if '(fetch)' in line]\n    except (CoverallsException, EnvironmentError) as ex:\n        # When git is not available, try env vars as per Coveralls docs:\n        # https://docs.coveralls.io/mercurial-support\n        # Additionally, these variables have been extended by GIT_URL and\n        # GIT_REMOTE\n        branch = os.environ.get('GIT_BRANCH')\n        head = {\n            'id': os.environ.get('GIT_ID'),\n            'author_name': os.environ.get('GIT_AUTHOR_NAME'),\n            'author_email': os.environ.get('GIT_AUTHOR_EMAIL'),\n            'committer_name': os.environ.get('GIT_COMMITTER_NAME'),\n            'committer_email': os.environ.get('GIT_COMMITTER_EMAIL'),\n            'message': os.environ.get('GIT_MESSAGE'),\n        }\n        remotes = [{\n            'name': os.environ.get('GIT_REMOTE'),\n            'url': os.environ.get('GIT_URL'),\n        }]\n        if not all(head.values()):\n            log.warning('Failed collecting git data. Are you running '\n                        'coveralls inside a git repository? Is git installed?',\n                        exc_info=ex)\n            return {}\n\n    return {\n        'git': {\n            'branch': branch,\n            'head': head,\n            'remotes': remotes,\n        },\n    }", "response": "Returns a hash of git data that can be used to display more information to users."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating json dumped report for coveralls api.", "response": "def create_report(self):\n        \"\"\"Generate json dumped report for coveralls api.\"\"\"\n        data = self.create_data()\n        try:\n            json_string = json.dumps(data)\n        except UnicodeDecodeError as e:\n            log.error('ERROR: While preparing JSON:', exc_info=e)\n            self.debug_bad_encoding(data)\n            raise\n\n        log_string = re.sub(r'\"repo_token\": \"(.+?)\"',\n                            '\"repo_token\": \"[secure]\"', json_string)\n        log.debug(log_string)\n        log.debug('==\\nReporting %s files\\n==\\n', len(data['source_files']))\n        for source_file in data['source_files']:\n            log.debug('%s - %s/%s', source_file['name'],\n                      sum(filter(None, source_file['coverage'])),\n                      len(source_file['coverage']))\n        return json_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_report(self, file_path):\n        try:\n            report = self.create_report()\n        except coverage.CoverageException as e:\n            log.error('Failure to gather coverage:', exc_info=e)\n        else:\n            with open(file_path, 'w') as report_file:\n                report_file.write(report)", "response": "Write coveralls report to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_data(self, extra=None):\n        if self._data:\n            return self._data\n\n        self._data = {'source_files': self.get_coverage()}\n        self._data.update(git_info())\n        self._data.update(self.config)\n        if extra:\n            if 'source_files' in extra:\n                self._data['source_files'].extend(extra['source_files'])\n            else:\n                log.warning('No data to be merged; does the json file contain '\n                            '\"source_files\" data?')\n\n        return self._data", "response": "Generate object for api."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef debug_bad_encoding(data):\n        at_fault_files = set()\n        for source_file_data in data['source_files']:\n            for value in source_file_data.values():\n                try:\n                    json.dumps(value)\n                except UnicodeDecodeError:\n                    at_fault_files.add(source_file_data['name'])\n\n        if at_fault_files:\n            log.error('HINT: Following files cannot be decoded properly into '\n                      'unicode. Check their content: %s',\n                      ', '.join(at_fault_files))", "response": "Let s try to help user figure out what is at fault."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the primary account of this asset.", "response": "def set_primary(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#set-account-as-primary\"\"\"\n        data = self.api_client.set_primary_account(self.id, **params)\n        self.update(data)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmodifies the account s attributes.", "response": "def modify(self, **params):\n        \"\"\"https://developers.coinbase.com/api#modify-an-account\"\"\"\n        data = self.api_client.update_account(self.id, **params)\n        self.update(data)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a specific address by id", "response": "def get_address(self, address_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-addresss\"\"\"\n        return self.api_client.get_address(self.id, address_id, **params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_address_transactions(self, address_id, **params):\n        return self.api_client.get_address_transactions(self.id, address_id, **params)", "response": "Get all transactions for a given address."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_transaction(self, transaction_id, **params):\n        return self.api_client.get_transaction(self.id, transaction_id, **params)", "response": "Get a single transaction"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a single buy", "response": "def get_buy(self, buy_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-a-buy\"\"\"\n        return self.api_client.get_buy(self.id, buy_id, **params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef commit_buy(self, buy_id, **params):\n        return self.api_client.commit_buy(self.id, buy_id, **params)", "response": "Commits a buy to the base."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_sell(self, sell_id, **params):\n        return self.api_client.get_sell(self.id, sell_id, **params)", "response": "Get a single sell"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncommitting a new sell.", "response": "def commit_sell(self, sell_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#commit-a-sell\"\"\"\n        return self.api_client.commit_sell(self.id, sell_id, **params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a withdrawal by ID.", "response": "def get_withdrawal(self, withdrawal_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-a-withdrawal\"\"\"\n        return self.api_client.get_withdrawal(self.id, withdrawal_id, **params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncomplete the current asset.", "response": "def complete(self):\n        \"\"\"https://developers.coinbase.com/api/v2#complete-request-money\"\"\"\n        response = self.api_client._post(self.resource_path, 'complete')\n        return self.api_client._make_api_object(response, APIObject)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nresend the current invoice to the current currency.", "response": "def resend(self):\n        \"\"\"https://developers.coinbase.com/api/v2#re-send-request-money\"\"\"\n        response = self.api_client._post(self.resource_path, 'resend')\n        return self.api_client._make_api_object(response, APIObject)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cancel(self):\n        response = self.api_client._post(self.resource_path, 'cancel')\n        return self.api_client._make_api_object(response, APIObject)", "response": "Cancels the current money."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef modify(self, **params):\n        data = self.api_client.update_current_user(**params)\n        self.update(data)\n        return data", "response": "Update the current user s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clean_params(params, drop_nones=True, recursive=True):\n    cleaned = {}\n    for key, value in six.iteritems(params):\n        if drop_nones and value is None:\n            continue\n        if recursive and isinstance(value, dict):\n            value = clean_params(value, drop_nones, recursive)\n        cleaned[key] = value\n    return cleaned", "response": "Clean up a dict of API parameters to be sent to Coinbase API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncleaning and JSON - encode a dict of parameters.", "response": "def encode_params(params, **kwargs):\n    \"\"\"Clean and JSON-encode a dict of parameters.\"\"\"\n    cleaned = clean_params(params, **kwargs)\n    return json.dumps(cleaned)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwarn if the URL is insecure.", "response": "def check_uri_security(uri):\n    \"\"\"Warns if the URL is insecure.\"\"\"\n    if urlparse(uri).scheme != 'https':\n        warning_message = (\n            'WARNING: this client is sending a request to an insecure'\n            ' API endpoint. Any API request you make may expose your API key and'\n            ' secret to third parties. Consider using the default endpoint:\\n\\n'\n            '  %s\\n') % uri\n        warnings.warn(warning_message, UserWarning)\n    return uri"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_api_error(response, blob=None):\n    try:\n        blob = blob or response.json()\n    except json.JSONDecodeError:\n        blob = {}\n    error_list = blob.get('errors', None)\n    error = (error_list[0] if error_list else {})\n    if error:\n        error_id = error.get('id', '')\n        error_message = error.get('message', '')\n    else:\n        # In the case of an OAuth-specific error, the response data is the error\n        # blob, and the keys are slightly different. See\n        # https://developers.coinbase.com/api/v2#error-response\n        error_id = blob.get('error')\n        error_message = blob.get('error_description')\n    error_class = (\n        _error_id_to_class.get(error_id, None) or\n        _status_code_to_class.get(response.status_code, APIError))\n    return error_class(response, error_id, error_message, error_list)", "response": "Helper method for creating errors and attaching HTTP response and request\n    details to them."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _build_session(self, auth_class, *args, **kwargs):\n        session = requests.session()\n        session.auth = auth_class(*args, **kwargs)\n        session.headers.update({'CB-VERSION': self.API_VERSION,\n                                'Accept': 'application/json',\n                                'Content-Type': 'application/json',\n                                'User-Agent': 'coinbase/python/2.0'})\n        return session", "response": "Internal helper for creating a requests. Session object with the correct authentication handling."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _create_api_uri(self, *parts):\n        return urljoin(self.BASE_API_URI, '/'.join(imap(quote, parts)))", "response": "Internal helper for creating fully qualified endpoint URIs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets requests can be paginated ensure we iterate through all the pages.", "response": "def _get(self, *args, **kwargs):\n        \"\"\"Get requests can be paginated, ensure we iterate through all the pages.\"\"\"\n        prev_data = kwargs.pop('prev_data', [])\n        resp = self._request('get', *args, **kwargs)\n        resp_content = resp._content\n        if not resp_content:\n            # No content so its obviously not paginated\n            return resp\n\n        # if resp._content is a bytes object, decode it so we can loads it as json\n        if isinstance(resp_content, bytes):\n            resp_content = resp_content.decode('utf-8')\n\n        # Load the json so we can use the data as python objects\n        content = json.loads(resp_content)\n        if 'pagination' not in content:\n            # Result is not paginated\n            return resp\n\n        page_info = content['pagination']\n        if not page_info['next_uri']:\n            # next_uri is None when the cursor has been iterated to the last element\n            content['data'].extend(prev_data)\n            # If resp._content was is a bytes object, only set it as a bytes object\n            if isinstance(resp_content, bytes):\n                resp._content = json.dumps(content).decode('utf-8')\n            else:\n                resp._content = json.dumps(content)\n            return resp\n\n        prev_data.extend(content['data'])\n        next_page_id = page_info['next_uri'].split('=')[-1]\n        kwargs.update({\n            'prev_data': prev_data,\n            'params': {'starting_after': next_page_id}\n        })\n        return self._get(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets exchange rates for a given set of keys.", "response": "def get_exchange_rates(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#exchange-rates\"\"\"\n        response = self._get('v2', 'exchange-rates', params=params)\n        return self._make_api_object(response, APIObject)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the buy price for a given currency pair", "response": "def get_buy_price(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#get-buy-price\"\"\"\n        currency_pair = params.get('currency_pair', 'BTC-USD')\n        response = self._get('v2', 'prices', currency_pair, 'buy', params=params)\n        return self._make_api_object(response, APIObject)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the historic entries for a currency pair", "response": "def get_historic_prices(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#get-historic-prices\"\"\"\n        if 'currency_pair' in params:\n            currency_pair = params['currency_pair']\n        else:\n            currency_pair = 'BTC-USD'\n        response = self._get('v2', 'prices', currency_pair, 'historic', params=params)\n        return self._make_api_object(response, APIObject)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the current time of the user.", "response": "def get_time(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#time\"\"\"\n        response = self._get('v2', 'time', params=params)\n        return self._make_api_object(response, APIObject)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a user by ID", "response": "def get_user(self, user_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-a-user\"\"\"\n        response = self._get('v2', 'users', user_id, params=params)\n        return self._make_api_object(response, User)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_current_user(self, **params):\n        response = self._get('v2', 'user', params=params)\n        return self._make_api_object(response, CurrentUser)", "response": "Get the current user s information"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget user authorization information.", "response": "def get_auth_info(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-authorization-information\"\"\"\n        response = self._get('v2', 'user', 'auth', params=params)\n        return self._make_api_object(response, APIObject)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the current user s attributes.", "response": "def update_current_user(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#update-current-user\"\"\"\n        response = self._put('v2', 'user', data=params)\n        return self._make_api_object(response, CurrentUser)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all accounts in the current account set.", "response": "def get_accounts(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#list-accounts\"\"\"\n        response = self._get('v2', 'accounts', params=params)\n        return self._make_api_object(response, Account)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_account(self, account_id, **params):\n        response = self._get('v2', 'accounts', account_id, params=params)\n        return self._make_api_object(response, Account)", "response": "Get an account by ID"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_primary_account(self, account_id, **params):\n        response = self._post('v2', 'accounts', account_id, 'primary', data=params)\n        return self._make_api_object(response, Account)", "response": "Set the primary account of the given account_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_account(self, account_id, **params):\n        response = self._put('v2', 'accounts', account_id, data=params)\n        return self._make_api_object(response, Account)", "response": "Update an account s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget all the notifications for a given set of attributes.", "response": "def get_notifications(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#list-notifications\"\"\"\n        response = self._get('v2', 'notifications', params=params)\n        return self._make_api_object(response, Notification)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a specific notification", "response": "def get_notification(self, notification_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-a-notification\"\"\"\n        response = self._get('v2', 'notifications', notification_id, params=params)\n        return self._make_api_object(response, Notification)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_addresses(self, account_id, **params):\n        response = self._get('v2', 'accounts', account_id, 'addresses', params=params)\n        return self._make_api_object(response, Address)", "response": "Get all addresses for a given account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_address(self, account_id, address_id, **params):\n        response = self._get('v2', 'accounts', account_id, 'addresses', address_id, params=params)\n        return self._make_api_object(response, Address)", "response": "Get an address by ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all the transactions for a given address.", "response": "def get_address_transactions(self, account_id, address_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#list-address39s-transactions\"\"\"\n        response = self._get(\n            'v2',\n            'accounts',\n            account_id,\n            'addresses',\n            address_id,\n            'transactions',\n            params=params)\n        return self._make_api_object(response, Transaction)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new address for the given account.", "response": "def create_address(self, account_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#create-address\"\"\"\n        response = self._post('v2', 'accounts', account_id, 'addresses', data=params)\n        return self._make_api_object(response, Address)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_transactions(self, account_id, **params):\n        response = self._get('v2', 'accounts', account_id, 'transactions', params=params)\n        return self._make_api_object(response, Transaction)", "response": "Get all transactions for a given account."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_transaction(self, account_id, transaction_id, **params):\n        response = self._get(\n            'v2', 'accounts', account_id, 'transactions', transaction_id, params=params)\n        return self._make_api_object(response, Transaction)", "response": "Get a single transaction from the specified account."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_money(self, account_id, **params):\n        for required in ['to', 'amount', 'currency']:\n            if required not in params:\n                raise ValueError(\"Missing required parameter: %s\" % required)\n        params['type'] = 'send'\n        response = self._post('v2', 'accounts', account_id, 'transactions', data=params)\n        return self._make_api_object(response, Transaction)", "response": "Send money to an account"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget all reports for the current user.", "response": "def get_reports(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#list-all-reports\"\"\"\n        response = self._get('v2', 'reports', data=params)\n        return self._make_api_object(response, Report)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_report(self, report_id, **params):\n        response = self._get('v2', 'reports', report_id, data=params)\n        return self._make_api_object(response, Report)", "response": "Get a report by ID"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_report(self, **params):\n        if 'type' not in params and 'email' not in params:\n            raise ValueError(\"Missing required parameter: 'type' or 'email'\")\n        response = self._post('v2', 'reports', data=params)\n        return self._make_api_object(response, Report)", "response": "Creates a new report"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_buys(self, account_id, **params):\n        response = self._get('v2', 'accounts', account_id, 'buys', params=params)\n        return self._make_api_object(response, Buy)", "response": "Get a list of buys for a given account."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a buy from a given account", "response": "def get_buy(self, account_id, buy_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-a-buy\"\"\"\n        response = self._get('v2', 'accounts', account_id, 'buys', buy_id, params=params)\n        return self._make_api_object(response, Buy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef buy(self, account_id, **params):\n        if 'amount' not in params and 'total' not in params:\n            raise ValueError(\"Missing required parameter: 'amount' or 'total'\")\n        for required in ['currency', 'payment_method']:\n            if required not in params:\n                raise ValueError(\"Missing required parameter: %s\" % required)\n        response = self._post('v2', 'accounts', account_id, 'buys', data=params)\n        return self._make_api_object(response, Buy)", "response": "Buy a user from a coinbase account"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef commit_buy(self, account_id, buy_id, **params):\n        response = self._post(\n            'v2', 'accounts', account_id, 'buys', buy_id, 'commit', data=params)\n        return self._make_api_object(response, Buy)", "response": "Commits a buy to a specific account"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_sells(self, account_id, **params):\n        response = self._get('v2', 'accounts', account_id, 'sells', params=params)\n        return self._make_api_object(response, Sell)", "response": "Get all the sells for a given account."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a single sell from the database.", "response": "def get_sell(self, account_id, sell_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-a-sell\"\"\"\n        response = self._get(\n            'v2', 'accounts', account_id, 'sells', sell_id, params=params)\n        return self._make_api_object(response, Sell)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a single sell account", "response": "def sell(self, account_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#sell-bitcoin\"\"\"\n        if 'amount' not in params and 'total' not in params:\n            raise ValueError(\"Missing required parameter: 'amount' or 'total'\")\n        for required in ['currency']:\n            if required not in params:\n                raise ValueError(\"Missing required parameter: %s\" % required)\n        response = self._post('v2', 'accounts', account_id, 'sells', data=params)\n        return self._make_api_object(response, Sell)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncommits a new sell to an account", "response": "def commit_sell(self, account_id, sell_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#commit-a-sell\"\"\"\n        response = self._post(\n            'v2', 'accounts', account_id, 'sells', sell_id, 'commit', data=params)\n        return self._make_api_object(response, Sell)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_deposits(self, account_id, **params):\n        response = self._get('v2', 'accounts', account_id, 'deposits', params=params)\n        return self._make_api_object(response, Deposit)", "response": "Get all the deposits for a given account."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a specific Deposit from the API.", "response": "def get_deposit(self, account_id, deposit_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-a-deposit\"\"\"\n        response = self._get(\n            'v2', 'accounts', account_id, 'deposits', deposit_id, params=params)\n        return self._make_api_object(response, Deposit)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deposit(self, account_id, **params):\n        for required in ['payment_method', 'amount', 'currency']:\n            if required not in params:\n                raise ValueError(\"Missing required parameter: %s\" % required)\n        response = self._post('v2', 'accounts', account_id, 'deposits', data=params)\n        return self._make_api_object(response, Deposit)", "response": "Deposit funds for a given account."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all withdrawals for a given account.", "response": "def get_withdrawals(self, account_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#list-withdrawals\"\"\"\n        response = self._get('v2', 'accounts', account_id, 'withdrawals', params=params)\n        return self._make_api_object(response, Withdrawal)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a withdrawal from a given account.", "response": "def get_withdrawal(self, account_id, withdrawal_id, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#show-a-withdrawal\"\"\"\n        response = self._get(\n            'v2', 'accounts', account_id, 'withdrawals', withdrawal_id, params=params)\n        return self._make_api_object(response, Withdrawal)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all payment methods for a given set of parameters.", "response": "def get_payment_methods(self, **params):\n        \"\"\"https://developers.coinbase.com/api/v2#list-payment-methods\"\"\"\n        response = self._get('v2', 'payment-methods', params=params)\n        return self._make_api_object(response, PaymentMethod)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_payment_method(self, payment_method_id, **params):\n        response = self._get('v2', 'payment-methods', payment_method_id, params=params)\n        return self._make_api_object(response, PaymentMethod)", "response": "Get a PaymentMethod object by ID"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_orders(self, **params):\n        response = self._get('v2', 'orders', params=params)\n        return self._make_api_object(response, Order)", "response": "Get all orders for a given set of attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_order(self, order_id, **params):\n        response = self._get('v2', 'orders', order_id, params=params)\n        return self._make_api_object(response, Order)", "response": "Get an order by ID"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_checkouts(self, **params):\n        response = self._get('v2', 'checkouts', params=params)\n        return self._make_api_object(response, Checkout)", "response": "Get all checkouts for a given set of attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_checkout(self, checkout_id, **params):\n        response = self._get('v2', 'checkouts', checkout_id, params=params)\n        return self._make_api_object(response, Checkout)", "response": "Get a specific checkout"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_checkout(self, **params):\n        for required in ['amount', 'currency', 'name']:\n            if required not in params:\n                raise ValueError(\"Missing required parameter: %s\" % required)\n        response = self._post('v2', 'checkouts', data=params)\n        return self._make_api_object(response, Checkout)", "response": "Create a new Checkout"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_checkout_orders(self, checkout_id, **params):\n        response = self._get('v2', 'checkouts', checkout_id, 'orders', params=params)\n        return self._make_api_object(response, Order)", "response": "Get all orders for a given checkout."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_checkout_order(self, checkout_id, **params):\n        response = self._post('v2', 'checkouts', checkout_id, 'orders', data=params)\n        return self._make_api_object(response, Order)", "response": "Create a new order for a given checkout."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nattempting to refresh the current access token and refresh token pair.", "response": "def refresh(self):\n        \"\"\"Attempt to refresh the current access token / refresh token pair.\n\n        If successful, the relevant attributes of this client will be updated\n        automatically and the dict of token values and information given  by the\n        Coinbase OAuth server will be returned to the caller.\n        \"\"\"\n        params = {\n            'grant_type': 'refresh_token',\n            'refresh_token': self.refresh_token\n        }\n        response = self._post('oauth', 'token', params=params)\n        response = self._handle_response(response)\n        blob = response.json()\n        self.access_token = blob.get('access_token', None)\n        self.refresh_token = blob.get('refresh_token', None)\n        if not (self.access_token and self.refresh_token):\n            raise build_api_error(response, blob)\n        return blob"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _remove_non_methods():\n  cur_module = sys.modules[__name__]\n  my_globals = dict(globals())\n  # Import here so that it doesn't get added to the global namespace or deleted.\n  # pylint: disable=g-import-not-at-top\n  from prettytensor.pretty_tensor_class import PrettyTensor\n  for name, _ in six.iteritems(my_globals):\n    if not hasattr(PrettyTensor, name):\n      delattr(cur_module, name)\n  # Remove a couple of special ones....\n  if hasattr(cur_module, 'bookkeeper'):\n    delattr(cur_module, 'bookkeeper')", "response": "Removes any object in dict that is not a registered method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping a regularizer in a parameter - function.", "response": "def regularizer(name, regularization_fn, name_filter='weights'):\n  \"\"\"Wraps a regularizer in a parameter-function.\n\n  Args:\n    name: The name scope for this regularizer.\n    regularization_fn: A function with signature:\n      fn(variable) -> loss `Tensor` or `None`.\n    name_filter: A regex that will be used to filter variables by name.\n\n  Returns:\n    A parameter modification function that adds the loss to the\n    REGULARIZATION_LOSSES graph key.\n  \"\"\"\n  regex = re.compile(name_filter)\n  def fn(var_name, variable, phase):\n    if phase is pt.Phase.train and regex.search(var_name):\n      with tf.name_scope(None, name, [variable]):\n        loss = regularization_fn(variable)\n      if loss is not None:\n        tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES, loss)\n    return variable\n  return fn"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef l2_regularizer(decay, name_filter='weights'):\n  return regularizer(\n      'l2_regularizer',\n      lambda x: tf.nn.l2_loss(x) * decay,\n      name_filter=name_filter)", "response": "Create an l2 regularizer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating an l1 regularizer.", "response": "def l1_regularizer(decay, name_filter='weights'):\n  \"\"\"Create an l1 regularizer.\"\"\"\n  return regularizer(\n      'l1_regularizer',\n      lambda x: tf.reduce_sum(tf.abs(x)) *  decay,\n      name_filter=name_filter)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a function that combines multiple parameter modification functions in order.", "response": "def compose(*parameter_functions):\n  \"\"\"Composes multiple modification functions in order.\n\n  Args:\n    *parameter_functions: The functions to compose.\n\n  Returns:\n    A parameter modification function that consists of applying all the provided\n    functions.\n  \"\"\"\n  def composed_fn(var_name, variable, phase):\n    for fn in parameter_functions:\n      variable = fn(var_name, variable, phase)\n    return variable\n  return composed_fn"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the sum of absolute errors between y and target.", "response": "def l1_regression_loss(y, target, name=None):\n  \"\"\"Calculates the sum of absolute errors between y and target.\n\n  Args:\n    y: the calculated values.\n    target: the desired values.\n    name: the name for this op, defaults to l1_regression\n  Returns:\n    A tensorflow op.\n  \"\"\"\n  with tf.name_scope(name, 'l1_regression', [y, target]) as scope:\n    y = tf.convert_to_tensor(y, name='y')\n    target = tf.convert_to_tensor(target, name='target')\n    return reduce_batch_sum(tf.abs(y - target), name=scope)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the sum of squared errors between y and target.", "response": "def l2_regression_sq_loss(y, target, name=None):\n  \"\"\"Calculates the sum of squared errors between y and target.\n\n  Args:\n    y: the calculated values.\n    target: the desired values.\n    name: the name for this op, defaults to l2_regression\n  Returns:\n    A tensorflow op.\n  \"\"\"\n  with tf.name_scope(name, 'l2_regression_sq', [y, target]) as scope:\n    y = tf.convert_to_tensor(y, name='y')\n    target = tf.convert_to_tensor(target, name='target')\n    return reduce_batch_sum(tf.square(y - target), name=scope)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef l2_regression_loss(y, target, name=None):\n  with tf.name_scope(name, 'l2_regression', [y, target]) as scope:\n    y = tf.convert_to_tensor(y, name='y')\n    target = tf.convert_to_tensor(target, name='target')\n    return tf.sqrt(l2_regression_sq_loss(y, target, name=scope))", "response": "Calculates the square root of the SSE between y and target."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the binary cross entropy loss between sigmoid x and target.", "response": "def binary_cross_entropy_loss_with_logits(x, target, name=None):\n  \"\"\"Calculates the binary cross entropy between sigmoid(x) and target.\n\n  Expects unscaled logits. Do not pass in results of sigmoid operation.\n\n  Args:\n    x: the calculated pre-sigmoid values\n    target: the desired values.\n    name: the name for this op, defaults to binary_cross_entropy_with_logits\n  Returns:\n    -(target * -softplus(-x) + (1-target) * (-x - softplus(-x)))\n  Raises:\n    ValueError: If shapes are incompatible.\n  \"\"\"\n  with tf.name_scope(name, 'binary_cross_entropy_with_logits',\n                     [x, target]) as scope:\n    x.get_shape().assert_is_compatible_with(target.get_shape())\n    neg_softplus = -tf.nn.softplus(-x)\n    return -tf.add(tf.multiply(target, neg_softplus),\n                   tf.multiply(1 - target, -x + neg_softplus),\n                   name=scope)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dot_distance(t1, t2, name=None):\n  with tf.name_scope(name, 'dot_distance', [t1, t2]) as scope:\n    return -dot_product(t1, t2, name=scope)", "response": "dot distance between t1 and t2."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsquares of l2 distance between t1 and t2.", "response": "def l2_distance_sq(t1, t2, name=None):\n  \"\"\"Square of l2 distance between t1 and t2.\n\n  Args:\n    t1: A tensor.\n    t2: A tensor that is the same size as t1.\n    name: Optional name for this op.\n  Returns:\n    The l2 distance between t1 and t2.\n  \"\"\"\n  with tf.name_scope(name, 'l2_distance_sq', [t1, t2]) as scope:\n    t1 = tf.convert_to_tensor(t1, name='t1')\n    t2 = tf.convert_to_tensor(t2, name='t2')\n    return length_squared(tf.subtract(t1, t2), name=scope)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef l2_distance(t1, t2, epsilon=1e-12, name=None):\n  with tf.name_scope(name, 'l2_distance', [t1, t2]) as scope:\n    t1 = tf.convert_to_tensor(t1, name='t1')\n    t2 = tf.convert_to_tensor(t2, name='t2')\n    return tf.sqrt(tf.maximum(l2_distance_sq(t1, t2, scope), epsilon))", "response": "l2 distance between t1 and t2 and caps the gradient of the Square Root."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef l1_distance(t1, t2, name=None):\n  with tf.name_scope(name, 'l1_distance', [t1, t2]) as scope:\n    t1 = tf.convert_to_tensor(t1, name='t1')\n    t2 = tf.convert_to_tensor(t2, name='t2')\n    sub = tf.subtract(t1, t2)\n    reduction_dim = _last_index(sub, 1)\n    return tf.reduce_sum(tf.abs(sub), reduction_dim, name=scope)", "response": "l1 distance between t1 and t2."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a leaky_relu. This is an alternate non-linearity to relu. The leaky part of the relu may prevent dead Neurons in a model since the gradient doesn't go completely to 0. Args: x: The input tensor. name: Optional name for this op. Returns: x if x > 0 otherwise 0.01 * x.", "response": "def leaky_relu(x, name=None):\n  \"\"\"Creates a leaky_relu.\n\n  This is an alternate non-linearity to relu. The leaky part of the relu may\n  prevent dead Neurons in a model since the gradient doesn't go completely to\n  0.\n\n  Args:\n    x: The input tensor.\n    name: Optional name for this op.\n  Returns:\n    x if x > 0 otherwise 0.01 * x.\n  \"\"\"\n  with tf.name_scope(name, 'leaky_relu', [x]) as scope:\n    x = tf.convert_to_tensor(x, name='x')\n    return tf.where(tf.less(x, 0.0), 0.01 * x, x, name=scope)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the softplus of the hinge.", "response": "def softplus(x, scale=1.0, name=None):\n  \"\"\"Computes softplus with a scale factor to sharpen of the hinge.\n\n  This is an alternate non-linearity to relu. It has a similar shape, but\n  it has a smooth transition from the linear part to 0.\n\n  Args:\n    x: A tensor.\n    scale: A float that sharpens the curve.\n    name: Optional name.\n  Returns:\n    y = log(1 + exp(scale * x)) / scale\n\n  \"\"\"\n  if scale == 1:\n    return tf.nn.softplus(x)\n  else:\n    with tf.name_scope(name, 'softplus', [x]):\n      scale = tf.convert_to_tensor(scale, dtype=x.dtype.base_dtype)\n      return tf.nn.softplus(x * scale) / scale"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndropping every other value from the tensor and returns a 1D tensor.", "response": "def every_other(x, name=None):\n  \"\"\"Drops every other value from the tensor and returns a 1D tensor.\n\n  This is useful if you are running multiple inputs through a model tower\n  before splitting them and you want to line it up with some other data.\n\n  Args:\n    x: the target tensor.\n    name: the name for this op, defaults to every_other\n  Returns:\n    A tensorflow op.\n  \"\"\"\n  with tf.name_scope(name, 'every_other', [x]) as scope:\n    x = tf.convert_to_tensor(x, name='x')\n    return tf.reshape(\n        tf.slice(\n            tf.reshape(x, [-1, 2]), [0, 0], [-1, 1]),\n        [-1],\n        name=scope)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dot_product(t1, t2, keep_dims=False, name=None, reduction_dim=None):\n  with tf.name_scope(name, 'dot', [t1, t2]) as scope:\n    t1 = tf.convert_to_tensor(t1, name='t1')\n    t2 = tf.convert_to_tensor(t2, name='t2')\n    mul = tf.multiply(t1, t2)\n    if not reduction_dim:\n      reduction_dim = _last_index(mul, 1)\n    return tf.reduce_sum(mul, reduction_dim, name=scope, keep_dims=keep_dims)", "response": "Computes the dot product of t1 and t2."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef length_squared(x, keep_dims=False, name=None, reduction_dim=None):\n  with tf.name_scope(name, 'length_squared', [x]) as scope:\n    x = tf.convert_to_tensor(x, name='x')\n    if not reduction_dim:\n      reduction_dim = _last_index(x, 1)\n    return tf.reduce_sum(\n        tf.square(x),\n        reduction_dim,\n        keep_dims=keep_dims,\n        name=scope)", "response": "Computes the squared length of x."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsplits a tensor along the split_dim along the current_length.", "response": "def unzip(x, split_dim, current_length, num_splits=2, name=None):\n  \"\"\"Splits a tensor by unzipping along the split_dim.\n\n  For example the following array split into 2 would be:\n      [1, 2, 3, 4, 5, 6] -> [1, 3, 5], [2, 4, 6]\n  and by 3:\n      [1, 2, 3, 4] -> [1, 4], [2], [3]\n\n  Args:\n    x: The tensor to split.\n    split_dim: The dimension to split along.\n    current_length: Current length along the split_dim.\n    num_splits: The number of splits.\n    name: Optional name for this op.\n  Returns:\n    A length num_splits sequence.\n  \"\"\"\n  with tf.name_scope(name, 'unzip', [x]) as scope:\n    x = tf.convert_to_tensor(x, name='x')\n    # There is probably a more efficient way to do this.\n    all_splits = tf.split(\n        value=x, num_or_size_splits=current_length, axis=split_dim, name=scope)\n    splits = [[] for _ in xrange(num_splits)]\n    for i in xrange(current_length):\n      splits[i % num_splits].append(all_splits[i])\n    return [tf.concat(s, split_dim) for s in splits]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _last_index(x, default_dim):\n  if x.get_shape().ndims is not None:\n    return len(x.get_shape()) - 1\n  else:\n    return default_dim", "response": "Returns the last dimension s index or default_dim."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of dims in x or default_dims if the rank is unknown.", "response": "def _all_dims(x, default_dims=None):\n  \"\"\"Returns a list of dims in x or default_dims if the rank is unknown.\"\"\"\n  if x.get_shape().ndims is not None:\n    return list(xrange(x.get_shape().ndims))\n  else:\n    return default_dims"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply_activation(\n    books,\n    x,\n    activation,\n    activation_args=(),\n    activation_kwargs=None):\n  \"\"\"Returns activation(x, *activation_args, **activation_kwargs).\n\n  This applies the given activation and adds useful summaries specific to the\n  activation.\n\n  Args:\n    books: The bookkeeper.\n    x: The tensor to apply activation to.\n    activation: An activation function.\n    activation_args: Optional additional arguments for the activation.\n    activation_kwargs: Optional keyword args for activation.\n  Returns:\n    A tensor with activation applied to x.\n  \"\"\"\n  if activation is None:\n    return x\n  if activation_kwargs is None:\n    activation_kwargs = {}\n  y = activation(x, *activation_args, **activation_kwargs)\n  if activation in (tf.nn.relu, functions.leaky_relu, functions.softplus):\n    books.add_scalar_summary(\n        tf.reduce_mean(tf.cast(tf.less(x, 0.0), tf.float32)),\n        '%s/zeros' % y.op.name)\n  elif activation is tf.nn.relu6:\n    books.add_scalar_summary(\n        tf.reduce_mean(tf.cast(tf.less(x, 0.0), tf.float32)),\n        '%s/zeros' % y.op.name)\n    books.add_scalar_summary(\n        tf.reduce_mean(tf.cast(tf.greater(x, 6.0), tf.float32)),\n        '%s/sixes' % y.op.name)\n  elif activation in (functions.l2_normalize, tf.nn.l2_normalize,\n                      functions.l1_normalize):\n    books.add_scalar_summary(\n        tf.reduce_mean(tf.sqrt(tf.reduce_sum(\n            tf.square(x), 1))), '%s/length' % y.op.name)\n  return y", "response": "Applies the given activation function to the given bookkeeper."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the parameter initialization using the method described in He et al.", "response": "def he_init(n_inputs, n_outputs, activation_fn, uniform=True):\n  \"\"\"Sets the parameter initialization using the method described.\n\n  This method is designed to keep the scale of the gradients roughly the same\n  in all layers with ReLU activations.\n\n  He et al. (2015):\n           Delving deep into rectifiers: surpassing human-level performance on\n           imageNet classification. International Conference on Computer Vision.\n\n  For activations other than ReLU and ReLU6, this method uses Xavier\n  initialization as in xavier_init().\n\n  Args:\n    n_inputs: The number of input nodes into each output.\n    n_outputs: The number of output nodes for each input.\n    activation_fn: Activation function used in this layer.\n    uniform: If uniform distribution will be used for Xavier initialization.\n             Normal distribution will be used if False.\n  Returns:\n    An initializer.\n  \"\"\"\n  def in_relu_family(activation_fn):\n    if isinstance(activation_fn, collections.Sequence):\n      activation_fn = activation_fn[0]\n    return activation_fn in (tf.nn.relu, tf.nn.relu6)\n\n  if in_relu_family(activation_fn):\n    stddev = math.sqrt(2.0 / n_inputs)\n    # TODO(): Evaluates truncated_normal_initializer.\n    return tf.random_normal_initializer(stddev=stddev)\n  else:\n    return xavier_init(n_inputs, n_outputs, uniform)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the parameter initialization using the method described in Xavier Glorot and Yoshua Bengio 2000.", "response": "def xavier_init(n_inputs, n_outputs, uniform=True):\n  \"\"\"Set the parameter initialization using the method described.\n\n  This method is designed to keep the scale of the gradients roughly the same\n  in all layers.\n\n  Xavier Glorot and Yoshua Bengio (2010):\n           Understanding the difficulty of training deep feedforward neural\n           networks. International conference on artificial intelligence and\n           statistics.\n  Args:\n    n_inputs: The number of input nodes into each output.\n    n_outputs: The number of output nodes for each input.\n    uniform: If true use a uniform distribution, otherwise use a normal.\n  Returns:\n    An initializer.\n  \"\"\"\n  if uniform:\n    # 6 was used in the paper.\n    init_range = math.sqrt(6.0 / (n_inputs + n_outputs))\n    return tf.random_uniform_initializer(-init_range, init_range)\n  else:\n    # 3 gives us approximately the same limits as above since this repicks\n    # values greater than 2 standard deviations from the mean.\n    stddev = math.sqrt(3.0 / (n_inputs + n_outputs))\n    return tf.truncated_normal_initializer(stddev=stddev)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pool(input_layer, pool_fn, kernel, stride, edges, name):\n  input_layer.get_shape().assert_has_rank(4)\n  if input_layer.get_shape().ndims not in (None, 4):\n    raise ValueError('Pooling requires a rank 4 tensor: %s' %\n                     input_layer.get_shape())\n  kernel = _kernel(kernel)\n  stride = _stride(stride)\n  size = [1, kernel[0], kernel[1], 1]\n\n  new_head = pool_fn(input_layer.tensor, size, stride, edges, name=name)\n  return input_layer.with_tensor(new_head)", "response": "Applies a pooling function to the input_layer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform average pooling on the chainable object.", "response": "def average_pool(input_layer, kernel, stride, edges=PAD_SAME, name=PROVIDED):\n  \"\"\"Performs average pooling.\n\n  `kernel` is the patch that will be pooled and it describes the pooling along\n  each of the 4 dimensions.  `stride` is how big to take each step.\n\n  Because more often than not, pooling is only done\n  on the width and height of the image, the following shorthands are supported:\n\n  * scalar (e.g. 3): Square pooling on the image\n      (`[b, c, r, d] = [1, 3, 3, 1]`).\n  * singleton list (e.g. [3]): Square pooling on the image\n      (`[b, c, r, d] = [1, 3, 3, 1]`).\n  * list of length 2 (e.g. [3, 2]): Square pooling on the image\n      (`[b, c, r, d] = [1, 3, 2, 1]`).\n\n  Args:\n    input_layer: The chainable object, supplied.\n    kernel: The size of the patch for the pool, either an int or a length 1 or\n      2 sequence (if length 1 or int, it is expanded).\n    stride: The strides as a length 1, 2 or 4 sequence or an integer. If an\n      int, length 1 or 2, the stride in the first and last dimensions are 1.\n    edges: Either `pt.PAD_SAME`' or `pt.PAD_VALID` to control the padding.\n    name: The name for this operation is also used to create/find the\n      parameter variables.\n  Returns:\n    Handle to this layer.\n  \"\"\"\n  return _pool(input_layer, tf.nn.avg_pool, kernel, stride, edges, name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef max_pool(input_layer, kernel, stride, edges=PAD_SAME, name=PROVIDED):\n  return _pool(input_layer, tf.nn.max_pool, kernel, stride, edges, name)", "response": "Performs max pooling on the chainable object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bilinear_sampling(input_layer, x, y, name=PROVIDED):\n  input_layer.get_shape().assert_has_rank(4)\n  return _interpolate(im=input_layer, x=x, y=y, name=name)", "response": "Bilinear sampling of the chainable object at x y."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexpanding the kernel spec into a length 2 list.", "response": "def _kernel(kernel_spec):\n  \"\"\"Expands the kernel spec into a length 2 list.\n\n  Args:\n    kernel_spec: An integer or a length 1 or 2 sequence that is expanded to a\n      list.\n  Returns:\n    A length 2 list.\n  \"\"\"\n  if isinstance(kernel_spec, tf.compat.integral_types):\n    return [kernel_spec, kernel_spec]\n  elif len(kernel_spec) == 1:\n    return [kernel_spec[0], kernel_spec[0]]\n  else:\n    assert len(kernel_spec) == 2\n    return kernel_spec"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _stride(stride_spec):\n  if stride_spec is None:\n    return [1, 1, 1, 1]\n  elif isinstance(stride_spec, tf.compat.integral_types):\n    return [1, stride_spec, stride_spec, 1]\n  elif len(stride_spec) == 1:\n    return [1, stride_spec[0], stride_spec[0], 1]\n  elif len(stride_spec) == 2:\n    return [1, stride_spec[0], stride_spec[1], 1]\n  else:\n    assert len(stride_spec) == 4\n    return stride_spec", "response": "Expands the stride spec into a length 4 list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _interpolate(im, x, y, name):\n  with tf.variable_scope(name):\n    x = tf.reshape(x, [-1])\n    y = tf.reshape(y, [-1])\n\n    # constants\n    num_batch = tf.shape(im)[0]\n    _, height, width, channels = im.get_shape().as_list()\n\n    x = tf.to_float(x)\n    y = tf.to_float(y)\n    height_f = tf.cast(height, 'float32')\n    width_f = tf.cast(width, 'float32')\n    zero = tf.constant(0, dtype=tf.int32)\n    max_y = tf.cast(tf.shape(im)[1] - 1, 'int32')\n    max_x = tf.cast(tf.shape(im)[2] - 1, 'int32')\n\n    # scale indices from [-1, 1] to [0, width-1/height-1]\n    x = (x + 1.0) * (width_f - 1.0) / 2.0\n    y = (y + 1.0) * (height_f - 1.0) / 2.0\n\n    # do sampling\n    x0 = tf.cast(tf.floor(x), 'int32')\n    x1 = x0 + 1\n    y0 = tf.cast(tf.floor(y), 'int32')\n    y1 = y0 + 1\n\n    x0 = tf.clip_by_value(x0, zero, max_x)\n    x1 = tf.clip_by_value(x1, zero, max_x)\n    y0 = tf.clip_by_value(y0, zero, max_y)\n    y1 = tf.clip_by_value(y1, zero, max_y)\n    dim2 = width\n    dim1 = width * height\n\n    # Create base index\n    base = tf.range(num_batch) * dim1\n    base = tf.reshape(base, [-1, 1])\n    base = tf.tile(base, [1, height * width])\n    base = tf.reshape(base, [-1])\n\n    base_y0 = base + y0 * dim2\n    base_y1 = base + y1 * dim2\n    idx_a = base_y0 + x0\n    idx_b = base_y1 + x0\n    idx_c = base_y0 + x1\n    idx_d = base_y1 + x1\n\n    # use indices to lookup pixels in the flat image and restore channels dim\n    im_flat = tf.reshape(im, tf.stack([-1, channels]))\n    im_flat = tf.to_float(im_flat)\n    pixel_a = tf.gather(im_flat, idx_a)\n    pixel_b = tf.gather(im_flat, idx_b)\n    pixel_c = tf.gather(im_flat, idx_c)\n    pixel_d = tf.gather(im_flat, idx_d)\n\n    # and finally calculate interpolated values\n    x1_f = tf.to_float(x1)\n    y1_f = tf.to_float(y1)\n\n    wa = tf.expand_dims(((x1_f - x) * (y1_f - y)), 1)\n    wb = tf.expand_dims((x1_f - x) * (1.0 - (y1_f - y)), 1)\n    wc = tf.expand_dims(((1.0 - (x1_f - x)) * (y1_f - y)), 1)\n    wd = tf.expand_dims(((1.0 - (x1_f - x)) * (1.0 - (y1_f - y))), 1)\n\n    output = tf.add_n([wa * pixel_a, wb * pixel_b, wc * pixel_c, wd * pixel_d])\n    output = tf.reshape(\n        output, shape=tf.stack([num_batch, height, width, channels]))\n    return output", "response": "Perform bilinear sampling on the image given x y coordiantes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_shape_on_tensor(tensor, shape):\n  if shape is not None:\n    try:\n      tensor.set_shape(shape)\n    except ValueError:\n      raise ValueError(\"Requested shape does not match tensor's shape: %s vs %s\"\n                       % (shape, tensor.get_shape()))\n  elif tensor.get_shape().ndims is None:\n    raise ValueError('Unknown shape on tensor: %s' % tensor)", "response": "Convenience method to set a shape or check it."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unwrap(tensor):\n  while isinstance(tensor, (PrettyTensor, Loss)):\n    tensor = tensor.tensor\n  return tensor", "response": "Returns the underlying tensor if tensor is wrapped or tensor.\n is a pretty tensor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating an input layer representing the given tensor.", "response": "def wrap(tensor, books=None, tensor_shape=None):\n  \"\"\"Creates an input layer representing the given tensor.\n\n  Args:\n    tensor: The tensor.\n    books: The bookkeeper; this is usually not required unless you are building\n      multiple `tf.Graphs.`\n    tensor_shape: An optional shape that will be set on the Tensor or verified\n      to match the tensor.\n  Returns:\n    A layer.\n  \"\"\"\n  if books is None:\n    books = bookkeeper.for_default_graph()\n  if isinstance(tensor, PrettyTensor):\n    return tensor.as_layer()\n  elif isinstance(tensor, UnboundVariable):\n\n    def set_input_from_unbound_var(data):\n      \"\"\"Sets the input from the given unbound_var.\"\"\"\n      if data is not None:\n        return wrap(data, books)\n      else:\n        return None\n\n    return _DeferredLayer(books, set_input_from_unbound_var, [tensor], {})\n  else:\n    tensor = tf.convert_to_tensor(tensor, name='input')\n    if tensor_shape:\n      _set_shape_on_tensor(tensor, tensor_shape)\n    return Layer(books, tensor=tensor, name=tensor.name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef template(key, books=None, optional=False):\n  if books is None:\n    books = bookkeeper.for_default_graph()\n\n  def set_input_from_unbound_var(data):\n    \"\"\"Sets the input from the given unbound_var.\"\"\"\n    if data is not None:\n      return wrap(data, books)\n    else:\n      return None\n\n  if optional:\n    data = UnboundVariable(key=key, default=None)\n  else:\n    data = UnboundVariable(key=key)\n  return _DeferredLayer(books, set_input_from_unbound_var, [data], {})", "response": "Starts a Pretty Tensor graph template."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating an input layer representing the given sequence of tensors.", "response": "def wrap_sequence(sequence, books=None, tensor_shape=None):\n  \"\"\"Creates an input layer representing the given sequence of tensors.\n\n  Args:\n    sequence: A sequence of tensors.\n    books: The bookkeeper.\n    tensor_shape: An optional shape that will be set on the Tensor or verified\n      to match the tensor.\n  Returns:\n    A layer.\n  \"\"\"\n  if books is None:\n    books = bookkeeper.for_default_graph()\n  my_sequence = [\n      wrap(t, books=books, tensor_shape=tensor_shape) for t in sequence]\n  return Layer(books, sequence=my_sequence, name=my_sequence[0].name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a Context Manager that provides the scope for the defaults that are used in a block.", "response": "def defaults_scope(**kwargs):\n  \"\"\"Creates a scope for the defaults that are used in a `with` block.\n\n  Note: `defaults_scope` supports nesting where later defaults can be\n  overridden. Also, an explicitly given keyword argument on a method always\n  takes precedence.\n\n  In addition to setting defaults for some methods, this also can control:\n\n  * `summary_collections`: Choose which collection to place summaries in or\n      disable with `None`.\n  * `trainable_variables`: Boolean indicating if variables are trainable.\n  * `variable_collections`: Default collections in which to place variables;\n      `tf.GraphKeys.GLOBAL_VARIABLES` is always included.\n\n  Args:\n    **kwargs: The defaults.\n  Yields:\n    Doesn't really yield, instead this creates a Context Manager for use in a\n    `with` statement.\n  Raises:\n    ValueError: if a collection type is accidently supplied a string.\n  \"\"\"\n  _assert_value_not_string('summary_collections', kwargs)\n  _assert_value_not_string('variable_collections', kwargs)\n\n  _check_defaults(kwargs)\n  global _defaults\n  old_defaults = _defaults\n  _defaults = chain_dict.ChainDict(_defaults)\n  _defaults.update(kwargs)\n\n  # Special logic to support summary_collections.\n  # This is added here because introducing more scopes would add more confusion\n  # than overloading this one a bit.\n  books = bookkeeper.for_default_graph()\n  if 'summary_collections' in _defaults:\n    books.summary_collections = _defaults['summary_collections']\n  else:\n    books.reset_summary_collections()\n  try:\n    yield _defaults\n  finally:\n    _defaults = old_defaults"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a context that can be used to divide a context into a single context.", "response": "def _subdivide_context(sequential, branch_count, join_function, name):\n  \"\"\"Creates a context so that branches/joins can be done using 'with'.\"\"\"\n  with sequential.g.as_default(), scopes.var_and_name_scope((name, None)):\n    branches = []\n    for i in xrange(branch_count):\n      branches.append(SequentialLayerBuilder(copy=sequential)\n                      .with_name('l%d' % i))\n    yield tuple(branches)\n    layers = [b.as_layer() for b in branches]\n    sequential.join(layers, include_self=False, join_function=join_function)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\njoins the list of pretty_tensors and sets the head of output_pretty_tensor.", "response": "def join_pretty_tensors(tensors, output, join_function=None, name='join'):\n  \"\"\"Joins the list of pretty_tensors and sets head of output_pretty_tensor.\n\n  Args:\n    tensors: A sequence of Layers or SequentialLayerBuilders to join.\n    output: A pretty_tensor to set the head with the result.\n    join_function: A function to join the tensors, defaults to concat on the\n      last dimension.\n    name: A name that is used for the name_scope\n  Returns:\n    The result of calling with_tensor on output\n  Raises:\n    ValueError: if pretty_tensors is None or empty.\n  \"\"\"\n  if not tensors:\n    raise ValueError('pretty_tensors must be a non-empty sequence.')\n  with output.g.name_scope(name):\n    if join_function is None:\n      # Use depth concat\n      last_dim = len(tensors[0].shape) - 1\n      return output.with_tensor(tf.concat(tensors, last_dim))\n    else:\n      return output.with_tensor(join_function(tensors))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _merge_unbound_var_dicts(src, dst):\n  for k, v in six.iteritems(src):\n    if dst.get(k, v) != v:\n      trace1 = ''.join(scopes.skip_common_stack_elements(v.stacktrace, dst[\n          k].stacktrace))\n      trace2 = ''.join(\n          scopes.skip_common_stack_elements(dst[k].stacktrace, v.stacktrace))\n      raise ValueError('Key conflict: %s\\nDefined At:\\n%s\\nand\\n%s' %\n                       (k, trace1, trace2))\n    else:\n      dst[k] = v", "response": "Merges src into dst and throws an exception if a value is incompatible."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassign values to the vars and raises ValueError if one is missing.", "response": "def _assign_values_to_unbound_vars(unbound_vars, unbound_var_values):\n  \"\"\"Assigns values to the vars and raises ValueError if one is missing.\"\"\"\n  context = {}\n  for key, value in six.iteritems(unbound_var_values):\n    if key not in unbound_vars:\n      raise ValueError('unexpected key: %s. Legal values are: %s' %\n                       (key, list(six.iterkeys(unbound_vars))))\n    context[unbound_vars[key]] = value\n  unspecified = []\n  for unbound_var in six.itervalues(unbound_vars):\n    if unbound_var not in context:\n      if unbound_var.has_default():\n        context[unbound_var] = unbound_var.default\n      else:\n        unspecified.append(unbound_var.key)\n  if unspecified:\n    raise ValueError('Unspecified keys: %s' % unspecified)\n  return context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconstructing all the given templates in a single pass without redundancy.", "response": "def construct_all(templates, **unbound_var_values):\n  \"\"\"Constructs all the given templates in a single pass without redundancy.\n\n  This is useful when the templates have a common substructure and you want the\n  smallest possible graph.\n\n  Args:\n    templates: A sequence of templates.\n    **unbound_var_values: The unbound_var values to replace.\n  Returns:\n    A list of results corresponding to templates.\n  Raises:\n    TypeError: If any value in templates is unsupported.\n    ValueError: If the unbound_var values specified are not complete or contain\n      unknown values.\n  \"\"\"\n\n  def _merge_dicts(src, dst):\n    for k, v in six.iteritems(src):\n      if dst.get(k, v) != v:\n        raise ValueError('Conflicting values bound for %s: %s and %s' %\n                         (k, v, dst[k]))\n      else:\n        dst[k] = v\n  # pylint: disable=protected-access\n  all_unbound_vars = {}\n  context = {}\n  for x in templates:\n    if isinstance(x, _DeferredLayer):\n      _merge_unbound_var_dicts(x.unbound_vars, all_unbound_vars)\n      _merge_dicts(x._partial_context, context)\n    else:\n      raise TypeError('Unexpected type: %s' % type(x))\n\n  _merge_dicts(\n      _assign_values_to_unbound_vars(all_unbound_vars, unbound_var_values),\n      context)\n  # We need to create a result of known size to avoid client pylint errors.\n  result = list(templates)\n  for i, x in enumerate(result):\n    if isinstance(x, _DeferredLayer):\n      result[i] = x._construct(context)\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _strip_unnecessary_contents_from_stack(result, processed):\n  # pylint: disable=protected-access\n  if isinstance(result, (PrettyTensor, Loss)):\n    if result.is_sequence():\n      for tensor in result.sequence:\n        _strip_unnecessary_contents_from_stack(tensor, processed)\n        return\n    else:\n      result = result.tensor\n  if hasattr(result, 'op'):\n    result = result.op\n  if result in processed:\n    return\n  else:\n    processed.add(result)\n  trace = []\n  found = False\n  for f, line_no, method, _ in result._traceback:\n    if (method in ('_replace_deferred', '_construct') and\n        f.endswith('pretty_tensor_class.py')):\n      found = True\n      continue\n    trace.append((f, line_no, method, {}))\n  result._traceback = trace\n\n  # Assume that if we didn't find any PT deferred lines, then this node is\n  # not part of the deferred construction.\n  if not found:\n    return\n  for inp in result.inputs:\n    _strip_unnecessary_contents_from_stack(inp, processed)", "response": "Remove the distracting lines from the stored tracebacks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _gen_ipython_string(func, args, defaults, original_doc):\n  magic_string = '%s(' % func.__name__\n\n  if defaults:\n    default_offset = len(args) - len(defaults)\n  else:\n    default_offset = len(args)\n  for i, value in enumerate(args):\n    if i >= default_offset:\n      magic_string += '%s=%s, ' % (value, defaults[i - default_offset])\n    else:\n      magic_string += '%s, ' % value\n  if args:\n    magic_string = magic_string[:-2]\n  magic_string += ')\\n\\n'\n  if original_doc is not None:\n    magic_string += original_doc\n  return magic_string", "response": "Generates a string that can be used to generate the ipython docstring for the function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _should_defer(input_layer, args, kwargs):\n  for arg in itertools.chain([input_layer], args, six.itervalues(kwargs)):\n    if isinstance(arg, (_DeferredLayer, UnboundVariable)):\n      return True\n    elif (isinstance(arg, collections.Sequence) and\n          not isinstance(arg, six.string_types)):\n      if _should_defer(None, arg, {}):\n        return True\n    elif isinstance(arg, collections.Mapping):\n      if _should_defer(None, (), arg):\n        return True\n  return False", "response": "Checks to see if any of the args are templates."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a nested set of name and id scopes and avoids repeats.", "response": "def _method_scope(input_layer, name):\n  \"\"\"Creates a nested set of name and id scopes and avoids repeats.\"\"\"\n  global _in_method_scope\n  # pylint: disable=protected-access\n\n  with input_layer.g.as_default(), \\\n       scopes.var_and_name_scope(\n           None if _in_method_scope else input_layer._scope), \\\n       scopes.var_and_name_scope((name, None)) as (scope, var_scope):\n    was_in_method_scope = _in_method_scope\n    yield scope, var_scope\n    _in_method_scope = was_in_method_scope"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _conversion_function(pt_wrapper, dtype=None, name=None, as_ref=False):\n  # Ignore as_ref to not create backward compatibility issues.\n  _ = name, as_ref\n  t = pt_wrapper.tensor\n  if dtype and not dtype.is_compatible_with(t.dtype):\n    raise ValueError(\n        'Tensor conversion requested dtype %s for Tensor with dtype %s: %r' %\n        (dtype, t.dtype, t))\n  return t", "response": "Allows PrettyTensors and Loss to work as a tensor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bind(self, **bindings):\n    found_vars = set()\n    result = []\n    for layer in self.flatten():\n      if isinstance(layer, _DeferredLayer):\n        var_keys = {var.key for var in six.itervalues(layer.unbound_vars)}\n        layers_bindings = {\n            k: v\n            for k, v in six.iteritems(bindings) if k in var_keys\n        }\n        result.append(layer.bind(**layers_bindings))\n        found_vars.update(six.iterkeys(layers_bindings))\n      else:\n        result.append(layer)\n    missing_vars = set(six.iterkeys(bindings)) - found_vars\n    if missing_vars:\n      raise ValueError('Unused bindings: %s' % missing_vars)\n    return self.__class__(*result)", "response": "Makes the bindings to each item in this and returns a new tuple."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef as_fn(self, *binding_order):\n    if len(binding_order) != len(self.unbound_vars):\n      raise ValueError('All vars must be specified.')\n    for arg in binding_order:\n      if arg not in self.unbound_vars:\n        raise ValueError('Unknown binding: %s' % arg)\n\n    def func(*args, **kwargs):\n      \"\"\"Constructs a template.\"\"\"\n      if len(binding_order) != len(args):\n        raise ValueError('Missing values, expects: %s' % binding_order)\n      values = dict(zip(binding_order, args))\n      values.update(kwargs)\n      return self.construct(**values)\n\n    func.__doc__ = _gen_ipython_string(func, binding_order, [], func.__doc__)\n    return func", "response": "Returns a function that takes the arguments of the given order."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _method_complete(self, result):\n    if isinstance(result, (PrettyTensor, Loss, PrettyTensorTupleMixin)):\n      return result\n    elif (isinstance(result, collections.Sequence) and\n          not isinstance(result, six.string_types)):\n      return self.with_sequence(result)\n    else:\n      return self.with_tensor(result)", "response": "Called after a registered method with the result."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_loss(self, loss, name=None):\n    self.bookkeeper.add_loss(loss, name=name)\n    return Loss(self.bookkeeper, tensor=loss, name=name)", "response": "Adds a loss and returns a wrapper for that loss."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nattaches the template to this such that _key = this layer.", "response": "def attach_template(self, _template, _key, **unbound_var_values):\n    \"\"\"Attaches the template to this such that _key=this layer.\n\n    Note: names were chosen to avoid conflicts with any likely unbound_var keys.\n\n    Args:\n      _template: The template to construct.\n      _key: The key that this layer should replace.\n      **unbound_var_values: The values for the unbound_vars.\n    Returns:\n      A new layer with operation applied.\n    Raises:\n      ValueError: If _key is specified twice or there is a problem computing the\n        template.\n    \"\"\"\n    if _key in unbound_var_values:\n      raise ValueError('%s specified twice.' % _key)\n    unbound_var_values[_key] = self\n    return _template.as_layer().construct(**unbound_var_values)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _as_graph_element(self):\n    if self.is_sequence():\n      raise TypeError('A Pretty Tensor that holds a sequence cannot be '\n                      'represented as a graph element.')\n    else:\n      # Self might be holding something else that isn't a true tensor, so\n      # if the 'tensor' can behave like a graph element, look for its\n      # _AsGraphElement method and call it. Graph elements themselves may not\n      # have or need this method, so just return other items directly.\n      obj = self.tensor\n      conv_fn = getattr(obj, '_as_graph_element', None)\n      if conv_fn and isinstance(conv_fn, collections.Callable):\n        obj = conv_fn()\n      return obj", "response": "Returns the underlying graph element if possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the name scope for future operations.", "response": "def with_name(self, name):\n    \"\"\"Sets the name scope for future operations.\"\"\"\n    with self.g.as_default(), scopes.var_and_name_scope((name, None)) as (\n        name_scope, var_scope):\n      return Layer(copy=self, name=self._name, scope=(name_scope, var_scope))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mark_as_required(self):\n    if self not in tf.get_collection(bookkeeper.GraphKeys.MARKED_LOSSES):\n      tf.add_to_collection(bookkeeper.GraphKeys.MARKED_LOSSES, self)", "response": "Adds this loss to the MARKED_LOSSES collection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _replace_deferred(self, arg, context):\n    if isinstance(arg, UnboundVariable):\n      return context[arg]\n    elif isinstance(arg, _DeferredLayer):\n      # pylint: disable=protected-access\n      return arg._construct(context)\n    elif isinstance(arg, tuple):\n      return tuple((self._replace_deferred(x, context) for x in arg))\n    elif (isinstance(arg, collections.Sequence) and\n          not isinstance(arg, six.string_types)):\n      return [self._replace_deferred(x, context) for x in arg]\n    elif isinstance(arg, collections.Mapping):\n      return {k: self._replace_deferred(v, context)\n              for k, v in six.iteritems(arg)}\n    else:\n      return arg", "response": "This replaces all deferred nodes in the argument with the context."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _construct(self, context):\n    with self.g.as_default():\n      if self._pass_through:\n        # pylint: disable=protected-access\n        return self._pass_through._construct(context)\n      current_value = context.get(self, None)\n      assert current_value is not _unspecified, 'Circular dependency'\n      if current_value is not None:\n        return current_value\n      context[self] = _unspecified\n      method_args = self._replace_deferred(self._method_args, context)\n      method_kwargs = self._replace_deferred(self._method_kwargs, context)\n      result = self._method(*method_args, **method_kwargs)\n      _strip_unnecessary_contents_from_stack(result, set())\n\n      context[self] = result\n      return result", "response": "Constructs this by calling the deferred method on the given context."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new template with the given unbound variables bound.", "response": "def bind(self, **bindings):\n    \"\"\"Creates a new template with the given unbound variables bound.\n\n    Args:\n      **bindings: Arguments for every deferred parameter.\n    Returns:\n      A new template with the given bindings.\n    Raises:\n      ValueError: If any of the bindings do not correspond to unbound variables.\n    \"\"\"\n    new_context = dict(self._partial_context)\n    unknown_keys = []\n    for k, v in six.iteritems(bindings):\n      if k not in self._unbound_vars:\n        unknown_keys.append(k)\n      new_context[self._unbound_vars[k]] = v\n    if unknown_keys:\n      raise ValueError(\n          'The following keys are not associated with any unbound vars: %s, '\n          'legal values are %s' %\n          (unknown_keys, list(self._unbound_vars.keys())))\n    return _DeferredLayer(self.bookkeeper,\n                          None,\n                          (),\n                          {},\n                          scope=self._scope,\n                          defaults=self._defaults,\n                          pass_through=self,\n                          partial_context=new_context)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing the graph and returns either a tensor or a sequence.", "response": "def construct(self, **bindings):\n    \"\"\"Constructs the graph and returns either a tensor or a sequence.\n\n    Args:\n      **bindings: Arguments for every deferred parameter.\n    Returns:\n      The value that is placed into this.\n    \"\"\"\n    context = _assign_values_to_unbound_vars(self._unbound_vars, bindings)\n    context.update(self._partial_context)\n    return self._construct(context)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef with_name(self, name):\n    with self.g.as_default(), tf.variable_scope(name) as var_scope:\n      name_scope = scopes.get_current_name_scope()\n      return _DeferredLayer(self.bookkeeper,\n                            None,\n                            (),\n                            {},\n                            scope=(name_scope, var_scope),\n                            defaults=self._defaults,\n                            pass_through=self,\n                            partial_context=self._partial_context)", "response": "Sets the name scope for future operations."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef attach_template(self, _template, _key, **unbound_var_values):\n    if _key in unbound_var_values:\n      raise ValueError('%s specified twice.' % _key)\n    unbound_var_values[_key] = self\n    return _DeferredLayer(self.bookkeeper,\n                          _template.as_layer().construct,\n                          [],\n                          unbound_var_values,\n                          scope=self._scope,\n                          defaults=self._defaults,\n                          partial_context=self._partial_context)", "response": "Attaches the template to this with the _key is supplied with this layer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef construct(self, **bindings):\n    if hasattr(self._head, 'construct'):\n      return self._head.construct(**bindings)\n    else:\n      raise ValueError(\n          'Cannot call construct on a non-template: %s' % type(self._head))", "response": "Constructs the graph and returns either a tensor or sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall after an extention method with the result.", "response": "def _method_complete(self, result):\n    \"\"\"Called after an extention method with the result.\"\"\"\n    if isinstance(result, PrettyTensor):\n      self._head = result\n      return self\n    elif isinstance(result, Loss):\n      return result\n    elif isinstance(result, PrettyTensorTupleMixin):\n      self._head = result[0]\n      return result\n    else:\n      self._head = self._head.with_tensor(result)\n      return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbranching this pretty tensor and uses an explicit join function.", "response": "def subdivide_with(self, branches, join_function, name='mixed'):\n    \"\"\"Branches this pretty tensor and uses an explicit join function.\n\n    This should be used in a with statement, for example to fork and join with\n    a sum:\n\n        with pt.subdivide_with(2, tf.add_n) as [a, b]:\n          a...\n          b...\n\n    Args:\n      branches: The number of branches.\n      join_function: A function to use when rejoining.\n      name: A base name for this branch.\n    Returns:\n      A python context manager to use in a with statement that supplies a\n      sequence of tensors with one per branch.\n    Raises:\n      ValueError: if join_function is None.\n    \"\"\"\n    return _subdivide_context(self, branches, join_function, name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef with_name(self, name):\n    self._head = self._head.with_name(name)\n    return self", "response": "Sets the name scope for future operations."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef variable(self, var_name, shape, init, dt=tf.float32, train=None):\n    # Make sure it is a TF dtype and convert it into a base dtype.\n    dt = tf.as_dtype(dt).base_dtype\n    if var_name in self.vars:\n      v = self.vars[var_name]\n      if v.get_shape() != shape:\n        raise ValueError(\n            'Shape mismatch: %s vs %s. Perhaps a UnboundVariable had '\n            'incompatible values within a graph.' % (v.get_shape(), shape))\n      return v\n    elif callable(init):\n      if train is None:\n        train = _defaults.get('trainable_variables', True)\n      variable_collections = _defaults.get('variable_collections', ())\n      if tf.GraphKeys.GLOBAL_VARIABLES not in variable_collections:\n        variable_collections = list(variable_collections) + [\n            tf.GraphKeys.GLOBAL_VARIABLES]\n\n      v = tf.get_variable(var_name,\n                          shape=shape,\n                          dtype=dt,\n                          initializer=init,\n                          trainable=train,\n                          collections=variable_collections)\n      self.vars[var_name] = v\n      return v\n    else:\n      v = tf.convert_to_tensor(init, name=var_name, dtype=dt)\n      v.get_shape().assert_is_compatible_with(shape)\n      self.vars[var_name] = v\n      return v", "response": "Adds a named variable to the bookkeeper or returns an existing one."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies name_suffix and defaults to kwargs and returns the result.", "response": "def fill_kwargs(self, input_layer, kwargs):\n    \"\"\"Applies name_suffix and defaults to kwargs and returns the result.\"\"\"\n    return input_layer._replace_args_with_defaults(_args=self._assign_defaults,\n                                                   **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a deferred node with captured scope.", "response": "def create_deferred(self, func, input_layer, deferred_args, deferred_kwargs,\n                      name):\n    \"\"\"Creates a deferred node with captured scope.\n\n    Args:\n      func: The original function to call.\n      input_layer: The input_layer.\n      deferred_args: The arguments that will be used bythe deferred function.\n      deferred_kwargs: The keyword args for the deferred function.\n      name: The name of this layer.\n    Returns:\n      A _DeferredLayer that will execute func in the correct scopes.\n    \"\"\"\n    my_defaults = _defaults\n\n    def _with_method_complete(*args, **kwargs):\n      input_layer = args[0]\n      with input_layer.g.as_default(), defaults_scope(**my_defaults), \\\n          tf.name_scope(name):\n        return input_layer._method_complete(func(*args, **kwargs))\n    # The deferred layer passes on the scope of the source layer so that the\n    # construction scope matches that of the immediate version.\n    full_args = [input_layer]\n    full_args.extend(deferred_args)\n    partial_context = {}\n    if isinstance(input_layer, _DeferredLayer):\n      partial_context = input_layer._partial_context\n    return _DeferredLayer(input_layer.bookkeeper,\n                          scopes.Template(None, _with_method_complete),\n                          full_args,\n                          deferred_kwargs,\n                          scope=input_layer._scope,\n                          defaults=input_layer.defaults,\n                          partial_context=partial_context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake a tuple from a sequence or tuple.", "response": "def _make_tuple(x):\n  \"\"\"TF has an obnoxious habit of being lenient with single vs tuple.\"\"\"\n  if isinstance(x, prettytensor.PrettyTensor):\n    if x.is_sequence():\n      return tuple(x.sequence)\n    else:\n      return (x.tensor,)\n  elif isinstance(x, tuple):\n    return x\n  elif (isinstance(x, collections.Sequence) and\n        not isinstance(x, six.string_types)):\n    return tuple(x)\n  else:\n    return (x,)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_from_queue(cls, input_queue, replay_size, batch_size):\n    return cls(\n        lambda: input_queue.dequeue_many(batch_size),\n        replay_size,\n        batch_size=batch_size)", "response": "Builds a ReplayableQueue that draws from a regular input_queue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replay_scope(self, sess):\n    current_replay = self.replay(sess)\n    try:\n      self.set_replay(sess, True)\n      yield\n    finally:\n      self.set_replay(sess, current_replay)", "response": "Enters a replay scope that unsets it at the end."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging the current replay setting on the graph.", "response": "def set_replay(self, sess, replay):\n    \"\"\"Changes the current replay setting on the graph.\"\"\"\n    sess.run(self._set_replay, {self._set_replay_ph: replay})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refill(self, sess):\n    sess.run(self._clear_queue)\n    # Run until full.\n    while sess.run(self._fill_queue):\n      pass", "response": "Clears the current queue then refills it with new data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef maybe_download(url, filename):\n  if not os.path.exists(WORK_DIRECTORY):\n    os.mkdir(WORK_DIRECTORY)\n  filepath = os.path.join(WORK_DIRECTORY, filename)\n  if not os.path.exists(filepath):\n    filepath, _ = request.urlretrieve(url + filename, filepath)\n    statinfo = os.stat(filepath)\n    print('Successfully downloaded', filename, statinfo.st_size, 'bytes.')\n  return filepath", "response": "Download the data from Yann s website unless it s already here."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts the labels into a 1 - hot matrix [ image index label index ].", "response": "def mnist_extract_labels(filename, num_images):\n  \"\"\"Extract the labels into a 1-hot matrix [image index, label index].\"\"\"\n  print('Extracting', filename)\n  with gzip.open(filename) as bytestream:\n    bytestream.read(8)\n    buf = bytestream.read(1 * num_images)\n    labels = np.frombuffer(buf, dtype=np.uint8)\n  # Convert to dense 1-hot representation.\n  return (np.arange(10) == labels[:, None]).astype(np.float32)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef permute_data(arrays, random_state=None):\n  if any(len(a) != len(arrays[0]) for a in arrays):\n    raise ValueError('All arrays must be the same length.')\n  if not random_state:\n    random_state = np.random\n  order = random_state.permutation(len(arrays[0]))\n  return [a[order] for a in arrays]", "response": "Permute multiple numpy arrays with the same order."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading MNIST and loads it into numpy arrays.", "response": "def mnist(training):\n  \"\"\"Downloads MNIST and loads it into numpy arrays.\"\"\"\n  if training:\n    data_filename = 'train-images-idx3-ubyte.gz'\n    labels_filename = 'train-labels-idx1-ubyte.gz'\n    count = 60000\n  else:\n    data_filename = 't10k-images-idx3-ubyte.gz'\n    labels_filename = 't10k-labels-idx1-ubyte.gz'\n    count = 10000\n  data_filename = maybe_download(MNIST_URL, data_filename)\n  labels_filename = maybe_download(MNIST_URL, labels_filename)\n\n  return (mnist_extract_data(data_filename, count),\n          mnist_extract_labels(labels_filename, count))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndownload Shakespeare converts it into ASCII codes and chunks it into chunks x chunk_size.", "response": "def shakespeare(chunk_size):\n  \"\"\"Downloads Shakespeare, converts it into ASCII codes and chunks it.\n\n  Args:\n    chunk_size: The dataset is broken down so that it is shaped into batches x\n      chunk_size.\n  Returns:\n    A numpy array of ASCII codes shaped into batches x chunk_size.\n  \"\"\"\n  file_name = maybe_download('http://cs.stanford.edu/people/karpathy/char-rnn/',\n                             'shakespear.txt')\n  with open(file_name) as f:\n    shakespeare_full = f.read()\n\n  # Truncate the data.\n  length = (len(shakespeare_full) // chunk_size) * chunk_size\n  if length < len(shakespeare_full):\n    shakespeare_full = shakespeare_full[:length]\n  arr = np.array([convert_to_int(c) for c in shakespeare_full])[\n      0:len(shakespeare_full) / chunk_size * chunk_size]\n  return arr.reshape((len(arr) / chunk_size, chunk_size))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef baby_names(max_length=15):\n  names = []\n  lengths = []\n  targets = []\n  with open(os.path.join(os.path.dirname(sys.modules[__name__].__file__),\n                         'baby_names.csv'), 'rb') as f:\n    first = True\n    for l in csv.reader(f, delimiter=','):\n      if first:\n        first = False\n        continue\n      assert len(l) == 4, l\n      name = l[0]\n      if max_length < len(name):\n        raise ValueError('Max length is too small: %d > %d' %\n                         (max_length, len(name)))\n      chars = [convert_to_int(c) for c in name]\n      names.append(chars + ([EOS] * (max_length - len(chars))))\n      lengths.append([len(name)])\n      values = [float(l[2]), float(l[3])]\n      if abs(sum(values) - 1) > 0.001:\n        raise ValueError('Each row must sum to 1: %s' % l)\n      targets.append(values)\n  return np.array(names), np.array(targets), np.array(lengths)", "response": "Opens the baby_names. csv file and produces numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply batch normalization to x as specified in arguments.", "response": "def batch_normalize_with_arguments(x, arguments):\n  \"\"\"Applies batch normalization to x as specified in arguments.\n\n  Args:\n    x: A Pretty Tensor.\n    arguments: Either a boolean to batch_normalize or a\n      BatchNormalizationArguments\n\n  Returns:\n    x with batch normalization applied.\n  \"\"\"\n  x = prettytensor.wrap(x)\n  # Backwards compatibility.\n  if isinstance(arguments, bool):\n    if arguments:\n      return x.batch_normalize()\n    else:\n      return x\n\n  # pylint: disable=protected-access\n  kwargs = arguments._asdict()\n  defaults = prettytensor._defaults\n  # pylint: enable=protected-access\n  for arg in ('learned_moments_update_rate', 'variance_epsilon',\n              'scale_after_normalization'):\n    if kwargs.get(arg, None) is None:\n      if arg in defaults:\n        kwargs[arg] = defaults[arg]\n      else:\n        del kwargs[arg]\n  return x.batch_normalize(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef multilayer_fully_connected(images, labels):\n  # Pretty Tensor is a thin wrapper on Tensors.\n  # Change this method to experiment with other architectures\n  images = pt.wrap(images)\n  with pt.defaults_scope(activation_fn=tf.nn.relu, l2loss=0.00001):\n    return (images.flatten().fully_connected(100).fully_connected(100)\n            .softmax_classifier(10, labels))", "response": "Creates a multi - layer network of fully_connected layers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a multi - layer convolutional network.", "response": "def lenet5(images, labels):\n  \"\"\"Creates a multi layer convolutional network.\n\n  The architecture is similar to that defined in LeNet 5.\n  Please change this to experiment with architectures.\n\n  Args:\n    images: The input images.\n    labels: The labels as dense one-hot vectors.\n  Returns:\n    A softmax result.\n  \"\"\"\n  images = pt.wrap(images)\n  with pt.defaults_scope(activation_fn=tf.nn.relu, l2loss=0.00001):\n    return (images.conv2d(5, 20).max_pool(2, 2).conv2d(5, 50).max_pool(2, 2)\n            .flatten().fully_connected(500).softmax_classifier(10, labels))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _full_map(self):\n    result = {}\n    if self._parent:\n      result.update(self._parent)\n    result.update(self._map)\n    return result", "response": "Creates a full mapping of this and all parent key value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nyield a variable scope and a name scope.", "response": "def var_and_name_scope(names):\n  \"\"\"Creates a variable scope and a name scope.\n\n  If a variable_scope is provided, this will reenter that variable scope.\n  However, if none is provided then the variable scope will match the generated\n  part of the name scope.\n\n  Args:\n    names: A tuple of name_scope, variable_scope or None.\n  Yields:\n    The result of name_scope and variable_scope as a tuple.\n  \"\"\"\n  # pylint: disable=protected-access\n  if not names:\n    yield None, None\n  else:\n    name, var_scope = names\n    with tf.name_scope(name) as scope:\n      # TODO(eiderman): This is a workaround until the variable_scope updates land\n      # in a TF release.\n      old_vs = tf.get_variable_scope()\n      if var_scope is None:\n        count = len(name.split('/'))\n        scoped_name = '/'.join(scope.split('/')[-count - 1:-1])\n        full_name = (old_vs.name + '/' + scoped_name).lstrip('/')\n      else:\n        full_name = var_scope.name\n\n      vs_key = tf.get_collection_ref(variable_scope._VARSCOPE_KEY)\n      try:\n        # TODO(eiderman): Remove this hack or fix the full file.\n        try:\n          vs_key[0] = tf.VariableScope(\n              old_vs.reuse,\n              name=full_name,\n              initializer=old_vs.initializer,\n              regularizer=old_vs.regularizer,\n              caching_device=old_vs.caching_device)\n        except AttributeError:\n          vs_key[0] = variable_scope._VariableScope(\n              old_vs.reuse,\n              name=full_name,\n              initializer=old_vs.initializer)\n\n        vs_key[0].name_scope = scope\n        yield scope, vs_key[0]\n      finally:\n        vs_key[0] = old_vs"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the current name scope.", "response": "def get_current_name_scope():\n  \"\"\"Gets the current name scope.\"\"\"\n  # pylint: disable=protected-access\n  g = tf.get_default_graph()\n  # TODO(eiderman): Remove this hack once TF update is released.\n  if isinstance(g._name_stack, tuple):\n    return g._name_stack[0] + '/'\n  else:\n    return g._name_stack + '/'"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_template(name, func, *args, **kwargs):\n  if args or kwargs:\n    func = functools.partial(func, *args, **kwargs)\n  return Template(name, func)", "response": "Given an arbitrary function wrap it so that it does parameter sharing."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef skip_common_stack_elements(stacktrace, base_case):\n  for i, (trace, base) in enumerate(zip(stacktrace, base_case)):\n    if trace != base:\n      return stacktrace[i:]\n  return stacktrace[-1:]", "response": "Skips items that the target stacktrace shares with the base stacktrace."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a 2 layer LSTM model with dropout.", "response": "def create_model(text_in, timesteps, phase):\n  \"\"\"Creates a 2 layer LSTM model with dropout.\n\n  Args:\n    text_in: The input text as ASCII ordinals in a Tensor.\n    timesteps: The number of timesteps in the sequence.\n    phase: Phase controls whether or not dropout is active.  In training mode\n      we want to perform dropout, but in test we want to disable it.\n  Returns:\n    The logits.\n  \"\"\"\n  with pt.defaults_scope(activation_fn=tf.nn.relu, l2loss=0.00001):\n    # The embedding lookup must be placed on a cpu.\n    with tf.device('/cpu:0'):\n      embedded = text_in.embedding_lookup(CHARS, [EMBEDDING_SIZE])\n    # Because the sequence LSTM expects each timestep to be its own Tensor,\n    # we need to cleave the sequence.\n    # Below we can build a stacked 2 layer LSTM by just chaining them together.\n    # You can stack as many layers as you want.\n    lstm = (embedded\n            .cleave_sequence(timesteps)\n            .sequence_lstm(LOWER)\n            .sequence_lstm(UPPER))\n\n    # The classifier is much more efficient if it runs across the entire\n    # dataset at once, so we want to squash (i.e. uncleave).\n    # Note: if phase is test, dropout is a noop.\n    return (lstm.squash_sequence()\n            .dropout(keep_prob=0.8, phase=phase)\n            .fully_connected(CHARS, activation_fn=None))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsampling from the LSTM model.", "response": "def sample(\n    input_placeholder, logits, seed=None, max_length=1024, temperature=1.0):\n  \"\"\"Samples from the LSTM model.\n\n  Sampling is done by first running either the seed or an arbitrary character\n  through the model and then drawing the next character from the probability\n  distribution definted by `softmax`.\n\n  Args:\n    input_placeholder: A placeholder that expects a scalar feed.\n    logits: The logits.  This works with the logits so that it can apply the\n      temperature.\n    seed: Either a string of characters to prime the network or None.\n    max_length: The maximum length to draw in case EOS is not reached.\n    temperature: A value that is used to renormalize the inputs.  A higher value\n      selects less likely choices.\n  Returns:\n    A string that was sampled from the model.\n  \"\"\"\n  assert temperature > 0, 'Temperature must be greater than 0.'\n  if not seed:\n    # The model expects an input to do inference, so seed with a single letter.\n    seed = chr(ord('A') + random.randint(0, 25))\n  result = ''\n\n  # The recurrent runner takes care of tracking the model's state at each step\n  # and provides a reset call to zero it out for each query.\n  recurrent_runner = pt.train.RecurrentRunner()\n\n  # We need to reset the hidden state for each query.\n  recurrent_runner.reset()\n  # Initialize the system\n  for c in seed[:-1]:\n    recurrent_runner.run([logits],\n                         {input_placeholder: data_utils.convert_to_int(c)})\n    result += c\n\n  # Start sampling!\n  ci = ord(seed[-1])\n  while len(result) < max_length and ci != data_utils.EOS:\n    result += chr(ci)\n    # The softmax is probability normalized and would have been appropriate here\n    # if we weren't applying the temperature (temperature could also be done in\n    # TensorFlow).\n    logit_result = recurrent_runner.run([logits],\n                                        {input_placeholder: ci})[0][0]\n    logit_result /= temperature\n\n    # Apply the softmax in numpy to convert from logits to probabilities.\n    # Subtract off the max for numerical stability -- logits are invariant to\n    # additive scaling and this eliminates overflows.\n    logit_result -= logit_result.max()\n\n    distribution = numpy.exp(logit_result)\n    distribution /= distribution.sum()\n\n    # Numpy multinomial needs the value to be strictly < 1\n    distribution -= .00000001\n    ci = numpy.argmax(numpy.random.multinomial(1, distribution))\n  result += chr(ci)  # Add the last letter.\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninfer unknown dimensions from the current shape.", "response": "def _infer_unknown_dims(old_shape, shape_spec):\n  \"\"\"Attempts to replace DIM_REST (if present) with a value.\n\n  Because of `pt.DIM_SAME`, this has more information to compute a shape value\n  than the default reshape's shape function.\n\n  Args:\n    old_shape: The current shape of the Tensor as a list.\n    shape_spec: A shape spec, see `pt.reshape`.\n  Returns:\n    A list derived from `shape_spec` with `pt.DIM_SAME` replaced by the value\n    from old_shape (if possible) and `pt.DIM_REST` computed (if possible).\n  Raises:\n    ValueError: If there are two many unknown dimensions or the shape_spec\n    requires out of range DIM_SAME.\n    TypeError: If shape_spec if not iterable.\n  \"\"\"\n\n  # To compute the dimension of an unknown, we need to track which of the values\n  # from old_shape are not copied for the numerator and any values specified as\n  # integers for the denominator.\n  #\n  # After the loop, if any input dimension is unknown and not DIM_SAME, the\n  # numerator will be 0. Otherwise it is the product of all non-DIM_SAME\n  # dimensions.  This means that the dimension of DIM_REST is\n  # numerator / denominator\n  numerator_elements = [x if x else 0 for x in old_shape]\n  denominator = 1\n  unknowns = 0\n\n  normalized_shape_spec = []\n  for s in shape_spec:\n    # Equality of tf.Dimension is broken and upstream fix hasn't been accepted.\n    if isinstance(s, tf.Dimension):\n      normalized_shape_spec.append(s.value)\n    elif isinstance(s, tf.TensorShape):\n      for dim in s:\n        normalized_shape_spec.append(dim.value)\n    else:\n      normalized_shape_spec.append(s)\n  result = []\n  for i, s in enumerate(normalized_shape_spec):\n    if s == DIM_SAME:\n      if i >= len(old_shape):\n        raise ValueError('%d exceeds the input shape' % i)\n      if old_shape[i] is None:\n        result.append(DIM_SAME)\n      else:\n        result.append(old_shape[i])\n      numerator_elements[i] = 1\n    elif s in (DIM_REST, -1, None):\n      result.append(-1)\n      unknowns += 1\n    else:\n      x = int(s)\n      result.append(x)\n      denominator *= x\n\n  numerator = 1\n  for x in numerator_elements:\n    numerator *= x\n  if unknowns > 1:\n    raise ValueError('Only one unknown value (-1 or *) is allowed: %s' %\n                     shape_spec)\n  elif numerator % denominator != 0:\n    raise ValueError('Input (%s) cannot be reshaped to %s.' %\n                     (old_shape, shape_spec))\n  elif unknowns == 0 and numerator > 0 and numerator != denominator:\n    raise ValueError('Input (%s) cannot be reshaped to %s.' %\n                     (old_shape, shape_spec))\n  if numerator and unknowns:\n    unknown_elements = int(numerator / denominator)\n    return [unknown_elements if x == -1 else x for x in result]\n  else:\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nflattening this. is .", "response": "def flatten(input_layer, preserve_batch=True):\n  \"\"\"Flattens this.\n\n  If preserve_batch is True, the result is rank 2 and the first dim (batch) is\n  unchanged. Otherwise the result is rank 1.\n\n  Args:\n    input_layer: The Pretty Tensor object, supplied.\n    preserve_batch: If True (the default), then preserve the first dimension.\n  Returns:\n    A LayerWrapper with the flattened tensor.\n  \"\"\"\n  if preserve_batch:\n    return reshape(input_layer, [DIM_SAME, -1])\n  else:\n    return reshape(input_layer, [-1])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncut off the gradient at this point.", "response": "def stop_gradient(input_layer):\n  \"\"\"Cuts off the gradient at this point.\n\n  This works on both sequence and regular Pretty Tensors.\n\n  Args:\n    input_layer: The input.\n  Returns:\n    A new Pretty Tensor of the same type with stop_gradient applied.\n  \"\"\"\n  if input_layer.is_sequence():\n    result = [tf.stop_gradient(t) for t in input_layer.sequence]\n    return input_layer.with_sequence(result)\n  else:\n    return tf.stop_gradient(input_layer)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply_with_summary(input_layer, operation, *op_args, **op_kwargs):\n  return layers.apply_activation(input_layer.bookkeeper,\n                                 input_layer.tensor,\n                                 operation,\n                                 activation_args=op_args,\n                                 activation_kwargs=op_kwargs)", "response": "Applies the given operation to input_layer and creates a summary."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies the given operation to this after expanding op_args.", "response": "def _rapply(input_layer, operation, *op_args, **op_kwargs):\n  \"\"\"Applies the given operation to this after expanding op_args.\n\n  Args:\n    input_layer: The input layer for this op.\n    operation: An operation that takes a tensor and the supplied args.\n    *op_args: Extra arguments for operation.\n    **op_kwargs: Keyword arguments for the operation.\n  Returns:\n    A new layer with operation applied.\n  \"\"\"\n  op_args = list(op_args)\n  op_args.append(input_layer.tensor)\n  return input_layer.with_tensor(operation(*op_args, **op_kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply_op(input_layer, operation, *op_args, **op_kwargs):\n  return input_layer.with_tensor(\n      operation(input_layer.tensor, *op_args, **op_kwargs))", "response": "Applies the given operation to this before without adding any summaries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\njoin the provided PrettyTensors with this.", "response": "def join(input_layer, others, include_self=True, join_function=None):\n  \"\"\"Joins the provided PrettyTensors with this using the join function.\n\n  Args:\n    input_layer: The input layer for this op.\n    others: Sequence of PrettyTensor objects.\n    include_self: Whether or not this includes itself or if the value is only\n      derived from others.\n    join_function: The function to use for joining, must accept a list of\n      tensors. Use None for concat on the final dimension.\n  Returns:\n    self.\n  \"\"\"\n  if include_self:\n    list_of_tensors = [input_layer]\n    list_of_tensors.extend(others)\n  else:\n    list_of_tensors = others\n  return prettytensor.join_pretty_tensors(list_of_tensors, input_layer,\n                                          join_function)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unzip(input_layer, split_dim=0, num_splits=2):\n  shape = input_layer.shape\n  _check_split_dims(num_splits, split_dim, shape)\n  splits = functions.unzip(input_layer, split_dim, shape[split_dim], num_splits)\n  return input_layer.with_sequence(splits)", "response": "Unzips this Tensor along the split_dim into num_splits Equal chunks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef concat(input_layer, concat_dim, other_tensors=None):\n  if input_layer.is_sequence():\n    all_tensors = input_layer.sequence\n    all_tensors.extend(other_tensors or [])\n  else:\n    all_tensors = [input_layer]\n    if other_tensors is None:\n      raise ValueError('Other Tensors must be supplied.')\n    all_tensors.extend(other_tensors)\n  # Edge cases really only apply when this is a sequence with 0 or 1 element.\n  if not all_tensors:\n    return prettytensor.wrap_sequence([])\n  else:\n    return tf.concat(all_tensors, concat_dim)", "response": "Concatenates input PrettyTensor with other_tensors along the specified dim."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsplits this Tensor along the split_dim into num_splits Equal chunks.", "response": "def split(input_layer, split_dim=0, num_splits=2):\n  \"\"\"Splits this Tensor along the split_dim into num_splits Equal chunks.\n\n  Examples:\n\n  * `[1, 2, 3, 4] -> [1, 2], [3, 4]`\n  * `[[1, 1], [2, 2], [3, 3], [4, 4]] -> [[1, 1], [2, 2]], [[3, 3], [4, 4]]`\n\n  Args:\n    input_layer: The chainable object, supplied.\n    split_dim: The dimension to split along. Defaults to batch.\n    num_splits: The number of splits.\n  Returns:\n    A list of PrettyTensors.\n  Raises:\n    ValueError: If split_dim is out of range or isn't divided evenly by\n      num_splits.\n  \"\"\"\n  shape = input_layer.shape\n  _check_split_dims(num_splits, split_dim, shape)\n  splits = tf.split(\n      value=input_layer, num_or_size_splits=num_splits, axis=split_dim)\n  return input_layer.with_sequence(splits)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _zip_with_scalars(args):\n  zipped = []\n  for arg in args:\n    if isinstance(arg, prettytensor.PrettyTensor):\n      zipped.append(arg if arg.is_sequence() else itertools.repeat(arg))\n    elif (isinstance(arg, collections.Sequence) and\n          not isinstance(arg, tf.compat.bytes_or_text_types)):\n      zipped.append(arg)\n    else:\n      zipped.append(itertools.repeat(arg))\n  assert len(args) == len(zipped)\n  return zip(*zipped)", "response": "Zips across args in order and replaces non - iterables with repeats."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmaps the given function across this sequence.", "response": "def map_(input_layer, fn):\n  \"\"\"Maps the given function across this sequence.\n\n  To map an entire template across the sequence, use the `as_fn` method on the\n  template.\n\n  Args:\n    input_layer: The input tensor.\n    fn: A function of 1 argument that is applied to each item in the sequence.\n  Returns:\n    A new sequence Pretty Tensor.\n  Raises:\n    ValueError: If the input_layer does not hold a sequence.\n  \"\"\"\n  if not input_layer.is_sequence():\n    raise ValueError('Can only map a sequence.')\n  return [fn(x) for x in input_layer]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _map_or_apply(input_layer, op, *args, **kwargs):\n  # Name is special because it can also set the name scope.\n  kwargs.pop('name')\n  right = kwargs.pop('right_', False)\n  if input_layer.is_sequence():\n    if right:\n      args += (input_layer,)\n    else:\n      args = ((input_layer,) + args)\n    result = [op(*x, **kwargs) for x in _zip_with_scalars(args)]\n    if len(result) != len(input_layer):\n      raise ValueError('Not all arguments were the same length.')\n    return result\n  else:\n    if right:\n      my_op = lambda x: op(*(args + (x,)), **kwargs)\n    else:\n      my_op = lambda x: op(x, *args, **kwargs)\n    return my_op(input_layer.tensor)", "response": "Map op across the input if it is a sequence otherwise apply it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef feed_numpy(batch_size, *arrays):\n  if not arrays:\n    raise ValueError('Arrays cannot be empty.')\n  size = len(arrays[0])\n  for a in arrays:\n    if size != len(a):\n      raise ValueError('All arrays must be the same size.')\n  count = int(size / batch_size)\n\n  for i in xrange(count):\n    start = i * batch_size\n    end = start + batch_size\n    yield [x[start:end] for x in arrays]\n  if count * batch_size < size:\n    yield [x[end:] for x in arrays]", "response": "Given a set of numpy arrays produce a list of slices of batch_size."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbatching data from an iterator that returns single items at a time.", "response": "def batch(input_iter, batch_size=32):\n  \"\"\"Batches data from an iterator that returns single items at a time.\"\"\"\n  input_iter = iter(input_iter)\n  next_ = list(itertools.islice(input_iter, batch_size))\n  while next_:\n    yield next_\n    next_ = list(itertools.islice(input_iter, batch_size))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprovide a slice based on the global_step.", "response": "def slice_constant(data, batch_size=32, name='constant_data', global_step=None):\n  \"\"\"Provide a slice based on the global_step.\n\n  This is useful when the entire data array can be stored in memory because it\n  allows you to feed the data very efficiently.\n\n  Args:\n    data: A numpy array or tensor.\n    batch_size: The batch size for the produced data.\n    name: An optional name for this data.\n    global_step: A global step variable that is used to read the data. If None\n      then the default prettytensor global_step is used.\n  Returns:\n    A tensor that produces the given data.\n  \"\"\"\n  with tf.name_scope(name):\n    all_data = tf.convert_to_tensor(data)\n    global_step = global_step or bookkeeper.global_step()\n\n    count = len(data) / batch_size\n    extra = len(data) - count * batch_size\n\n    if extra:\n      offset = tf.mod(global_step, count)\n      return tf.slice(all_data, offset * batch_size, batch_size)\n    else:\n      offset = tf.mod(global_step, count + 1)\n      return tf.slice(all_data, offset * batch_size,\n                      tf.where(tf.equal(offset, count), extra, batch_size))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake care of starting any local servers and stopping queues on exit. In general, the Runner is designed to work with any user provided session, but this provides a convenience for properly stopping the queues. Args: master: The master session to use. config: A tf.ConfigProto or None. Yields: A session.", "response": "def session(self, master='', config=None):\n    \"\"\"Takes care of starting any local servers and stopping queues on exit.\n\n    In general, the Runner is designed to work with any user provided session,\n    but this provides a convenience for properly stopping the queues.\n\n    Args:\n      master: The master session to use.\n      config: A tf.ConfigProto or None.\n\n    Yields:\n      A session.\n    \"\"\"\n    session_manager = SESSION_MANAGER_FACTORY()\n    # Initialization is handled manually at a later point and session_manager\n    # is just used for distributed compatibility.\n    with session_manager.prepare_session(master, None, config=config,\n                                         init_fn=lambda _: None) as sess:\n      try:\n        yield sess\n      finally:\n        self.stop_queues()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepare_model(self, sess, allow_initialize=True):\n    if self._follower:\n      self.wait_for_initialization()\n    else:\n      self._init_model(sess, allow_initialize)\n\n    if sess is not self._sess:\n      if self.threads:\n        raise ValueError('You must call stop_queues() before '\n                         'starting a new session with QueueRunners.')\n      self._sess = sess\n    self._start_threads(sess)", "response": "Initialize the model and if necessary launch the queue runners."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the model from the latest checkpoint.", "response": "def load_from_checkpoint(self, sess, latest_filename=None):\n    \"\"\"Loads the model from the most recent checkpoint.\n\n    This gets the most current list of checkpoints each time it is called.\n\n    Args:\n      sess: The current session.\n      latest_filename: The filename for the latest set of checkpoints, defaults\n        to 'checkpoints'.\n    Returns:\n      The loaded checkpoint or None if it failed to load.\n    \"\"\"\n    # Set list of not-yet-deleted checkpoints.\n    self._create_initializers()\n    if self._save_path:\n      ckpt = tf.train.get_checkpoint_state(\n          os.path.dirname(self._save_path), latest_filename)\n      if ckpt and ckpt.all_model_checkpoint_paths:\n        # Copy it because last_checkpoints is immutable.\n        # Manually configure a new Saver so that we get the latest snapshots.\n        self._saver = tf.train.Saver(saver_def=self._saver.as_saver_def())\n        self._saver.set_last_checkpoints(list(ckpt.all_model_checkpoint_paths))\n    if self._saver.last_checkpoints:\n      self._saver.restore(sess, self._saver.last_checkpoints[-1])\n      return self._saver.last_checkpoints[-1]\n    else:\n      return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the given list of operations and returns the model.", "response": "def run_model(self,\n                op_list,\n                num_steps,\n                feed_vars=(),\n                feed_data=None,\n                print_every=100,\n                allow_initialize=True):\n    \"\"\"Runs `op_list` for `num_steps`.\n\n    Args:\n      op_list: A list of ops to run.\n      num_steps: Number of steps to run this for.  If feeds are used, this is a\n        maximum. `None` can be used to signal \"forever\".\n      feed_vars: The variables to feed.\n      feed_data: An iterator that feeds data tuples.\n      print_every: Print a log line and checkpoing every so many steps.\n      allow_initialize: If True, the model will be initialized if any variable\n        is uninitialized, if False the model will not be initialized.\n    Returns:\n      The final run result as a list.\n    Raises:\n      ValueError: If feed_data doesn't match feed_vars.\n    \"\"\"\n    feed_data = feed_data or itertools.repeat(())\n\n    ops = [bookkeeper.global_step()]\n    ops.extend(op_list)\n\n    sess = tf.get_default_session()\n    self.prepare_model(sess, allow_initialize=allow_initialize)\n    results = []\n\n    try:\n      if num_steps is None:\n        counter = itertools.count(0)\n      elif num_steps >= 0:\n        counter = xrange(num_steps)\n      else:\n        raise ValueError('num_steps cannot be negative: %s' % num_steps)\n      for i, data in zip(counter, feed_data):\n        log_this_time = print_every and i % print_every == 0\n        if len(data) != len(feed_vars):\n          raise ValueError(\n              'feed_data and feed_vars must be the same length: %d vs %d' % (\n                  len(data), len(feed_vars)))\n        if self._coord.should_stop():\n          print('Coordinator stopped')\n          sys.stdout.flush()\n          self.stop_queues()\n          break\n        if len(feed_vars) != len(data):\n          raise ValueError('Feed vars must be the same length as data.')\n\n        if log_this_time and self._summary_writer:\n          results = sess.run(ops + [self._summaries],\n                             dict(zip(feed_vars, data)))\n          self._summary_writer.add_summary(results[-1], results[0])\n          results = results[:-1]\n        else:\n          results = sess.run(ops, dict(zip(feed_vars, data)))\n        if log_this_time:\n          self._log_and_save(sess, results)\n\n      # Print the last line if it wasn't just printed\n      if print_every and not log_this_time:\n        self._log_and_save(sess, results)\n    except tf.errors.OutOfRangeError as ex:\n      print('Done training -- epoch limit reached %s' % ex.message)\n      sys.stdout.flush()\n      self.stop_queues()\n    except BaseException as ex:\n      print('Exception -- stopping threads: %s' % ex, file=sys.stderr)\n      sys.stdout.flush()\n      self.stop_queues()\n      raise\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef train_model(self,\n                  train_op,\n                  cost_to_log,\n                  num_steps,\n                  feed_vars=(),\n                  feed_data=None,\n                  print_every=100):\n    \"\"\"Trains the given model.\n\n    Args:\n      train_op: The training operation.\n      cost_to_log: A cost to log.\n      num_steps: Number of batches to run.\n      feed_vars: A list or tuple of the variables that will be fed.\n      feed_data: A generator that produces tuples of the same length as\n        feed_vars.\n      print_every: Print and save every so many steps.\n    Returns:\n      `cost_to_log` from the final step.\n    \"\"\"\n    costs = [train_op]\n    if (isinstance(cost_to_log, collections.Sequence)\n        and not isinstance(cost_to_log, six.string_types)):\n      costs.extend(cost_to_log)\n    else:\n      costs.append(cost_to_log)\n    return self.run_model(costs,\n                          num_steps,\n                          feed_vars=feed_vars,\n                          feed_data=feed_data,\n                          print_every=print_every)[2:]", "response": "Trains the given model."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef evaluate_model(self,\n                     accuracy,\n                     num_steps,\n                     feed_vars=(),\n                     feed_data=None,\n                     summary_tag=None,\n                     print_every=0):\n    \"\"\"Evaluates the given model.\n\n    Args:\n      accuracy: The metric that is being evaluated or a tuple of metrics.\n      num_steps: The number of steps to run in the evaluator.\n      feed_vars: A list or tuple of the variables that will be fed.\n      feed_data: A generator that produces tuples of the same length as\n        feed_vars.\n      summary_tag: If provided, the final result of running the model will be\n        published to this tag.\n      print_every: Print a summary every so many steps, use 0 to disable.\n    Returns:\n      The accuracy.\n    Raises:\n      ValueError: If the wrong number of summary tags are provided or previously\n        running QueueRunners haven't been stopped.\n    \"\"\"\n    if not hasattr(self, '_saver'):\n      raise ValueError('Before evaluating, you must initialize the model with '\n                       'load_from_checkpoint, prepare or saver.')\n    self._run_init_test_vars_op()\n    if (not isinstance(accuracy, collections.Sequence) or\n        isinstance(accuracy, six.string_types)):\n      accuracy = (accuracy,)\n      if summary_tag:\n        summary_tag = (summary_tag,)\n    if summary_tag and len(summary_tag) != len(accuracy):\n      raise ValueError(\n          'If summaries are requested, there must be a tag per accuracy node.')\n\n    result = self.run_model(accuracy,\n                            num_steps,\n                            feed_vars=feed_vars,\n                            feed_data=feed_data,\n                            print_every=print_every,\n                            allow_initialize=False)\n    assert len(result) == len(accuracy) + 1, (\n        'results is wrong length, was %s but should be 1 longer than %s' %\n        (result, accuracy))\n    if summary_tag:\n      self.add_summaries(result[0], *zip(summary_tag, result[1:]))\n    return result[1:]", "response": "Evaluates the given model."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_summaries(self, step, *tags_and_values):\n    values = []\n    to_print = []\n    for tag, value in tags_and_values:\n      values.append(tf.Summary.Value(tag=tag, simple_value=float(value)))\n      to_print.append('%s=%g' % (tag, value))\n    if self._summary_writer:\n      summary = tf.Summary(value=values)\n      event = tf.Event(wall_time=time.time(),\n                       summary=summary,\n                       step=int(step))\n      self._summary_writer.add_event(event)\n    print('[%d] %s' % (step, ', '.join(to_print)))", "response": "Adds summaries to the writer and prints a log statement."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_new_checkpoint_when_available(\n      self, sess, current_checkpoint, sleep_seconds=10):\n    \"\"\"Waits for a new checkpoint to be available and then loads it.\n\n    Args:\n      sess: The current session.\n      current_checkpoint: The current checkpoint or None to just load the next\n        one.\n      sleep_seconds: How long to sleep between checks.\n\n    Returns:\n      The next checkpoint to use.\n    \"\"\"\n    # Load the checkpoint.\n    while True:\n      next_checkpoint = self.load_from_checkpoint(sess)\n      if not next_checkpoint or next_checkpoint == current_checkpoint:\n        print('Model not yet available, sleeping for %d seconds: '\n              'path %s; found: %s' %\n              (sleep_seconds,\n               os.path.dirname(self._save_path), current_checkpoint))\n        sys.stdout.flush()\n        time.sleep(sleep_seconds)\n      else:\n        return next_checkpoint", "response": "Waits for a new checkpoint to be available and then loads it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef evaluate_repeatedly(self,\n                          accuracy,\n                          num_steps,\n                          feed_vars=(),\n                          feed_data=None,\n                          summary_tag=None,\n                          evaluation_times=-1):\n    \"\"\"Runs the evaluation in a loop for `evaluation_times`.\n\n    On each iteration, `evaluate_model` is called with the supplied arguments.\n    This manages the queue threads itself.\n\n    Args:\n      accuracy: The metric that is being evaluated.\n      num_steps: The number of steps to run in the evaluator.\n      feed_vars: A list or tuple of the variables that will be fed.\n      feed_data: A generator that produces tuples of the same length as\n        feed_vars.\n      summary_tag: If provided, the final result of each evaluation will be\n        published to this tag.\n      evaluation_times: Run this loop for this many times or forever if it is\n        `-1`.\n\n    Returns:\n      The final evaluation result from `evaluate_model` if `evaluation_times`\n      ever ends.\n    \"\"\"\n    current_checkpoint = None\n    try:\n      for i in itertools.count(0):\n        # New session each time to reset queues - Yay.\n        with self.session() as sess:\n          current_checkpoint = self.load_new_checkpoint_when_available(\n              sess, current_checkpoint)\n          # Create relevant ops before starting queue runners.\n          self._run_init_test_vars_op()\n\n          accuracy_result = self.evaluate_model(accuracy,\n                                                num_steps,\n                                                summary_tag=summary_tag,\n                                                print_every=0,\n                                                feed_vars=feed_vars,\n                                                feed_data=feed_data)\n          if not summary_tag:\n            print('[%d] %s' % (sess.run(bookkeeper.global_step()),\n                               accuracy_result))\n          if (i + 1) == evaluation_times:\n            return accuracy_result\n    finally:\n      print('Shutting down')\n      sys.stdout.flush()\n      self.stop_queues()", "response": "Runs the evaluation in a loop for evaluation_times."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a model for running baby names.", "response": "def create_model(text_in,\n                 labels,\n                 timesteps,\n                 per_example_weights,\n                 phase=pt.Phase.train):\n  \"\"\"Creates a model for running baby names.\"\"\"\n  with pt.defaults_scope(phase=phase, l2loss=0.00001):\n    # The embedding lookup must be placed on a cpu.\n    with tf.device('/cpu:0'):\n      embedded = text_in.embedding_lookup(CHARS, [EMBEDDING_SIZE])\n    # We need to cleave the sequence because sequence lstm expect each\n    # timestep to be in its own Tensor.\n    lstm = (embedded.cleave_sequence(timesteps).sequence_lstm(CHARS))\n\n    # The classifier is much more efficient if it runs across the entire\n    # batch at once, so we want to squash (i.e. uncleave).\n    #\n    # Hidden nodes is set to 32 because it seems to work well.\n    return (lstm.squash_sequence().fully_connected(32,\n                                                   activation_fn=tf.nn.relu)\n            .dropout(0.7)\n            .softmax_classifier(SEXES,\n                                labels,\n                                per_example_weights=per_example_weights))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new bookkeeper for the default graph.", "response": "def for_default_graph(*args, **kwargs):\n  \"\"\"Creates a bookkeeper for the default graph.\n\n  Args:\n    *args: Arguments to pass into Bookkeeper's constructor.\n    **kwargs: Arguments to pass into Bookkeeper's constructor.\n  Returns:\n    A new Bookkeeper.\n  Raises:\n    ValueError: If args or kwargs are provided and the Bookkeeper already\n      exists.\n  \"\"\"\n  graph = tf.get_default_graph()\n  collection = graph.get_collection(_BOOKKEEPER)\n  if collection:\n    if args or kwargs:\n      raise ValueError('Requesting construction of a BookKeeper that already '\n                       'exists: %s %s' % (args, kwargs))\n    return collection[0]\n  else:\n    books = BOOKKEEPER_FACTORY(*args, g=graph, **kwargs)\n    graph.add_to_collection(_BOOKKEEPER, books)\n    return books"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a Bookkeeper for a new graph.", "response": "def for_new_graph(*args, **kwargs):\n  \"\"\"Creates a Bookkeeper for a new graph.\n\n  You must use `m.g.as_default()` to put the graph in scope:\n\n      m = Bookkeeper.for_new_graph()\n      with m.g.as_default():\n        ...\n\n  Args:\n    *args: Arguments to pass into Bookkeeper's constructor.\n    **kwargs: Arguments to pass into Bookkeeper's constructor.\n  Returns:\n    A new Bookkeeper.\n  \"\"\"\n  graph = tf.Graph()\n  with graph.as_default():\n    return for_default_graph(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef regroup_if_changed(group, op_list, name=None):\n  has_deltas = isinstance(op_list, sequence_with_deltas.SequenceWithDeltas)\n  if (group is None or len(group.control_inputs) != len(op_list) or\n      (has_deltas and op_list.has_changed())):\n    if has_deltas:\n      op_list.mark()\n    if op_list:\n      return tf.group(*op_list, name=name)\n    else:\n      return tf.no_op(name=name)\n  else:\n    return group", "response": "Creates a new group for op_list if it has changed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a composite loss that is the sum of all specified losses.", "response": "def create_composite_loss(losses=None,\n                          regularize=True,\n                          include_marked=True,\n                          name='cost'):\n  \"\"\"Creates a loss that is the sum of all specified losses.\n\n  Args:\n    losses: A sequence of losses to include.\n    regularize: Whether or not to include regularization losses.\n    include_marked: Whether or not to use the marked losses.\n    name: The name for this variable.\n  Returns:\n    A single tensor that is the sum of all losses.\n  \"\"\"\n  books = for_default_graph()\n  return books.create_composite_loss(losses,\n                                     regularize,\n                                     include_marked=include_marked,\n                                     name=name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply_optimizer(optimizer,\n                    losses,\n                    regularize=True,\n                    include_marked=True,\n                    clip_gradients_by_norm=None,\n                    **kwargs):\n  \"\"\"Apply an optimizer to the graph and returns a train_op.\n\n  The resulting operation will minimize the specified losses, plus the\n  regularization losses that have been collected during graph construction and\n  the losses that were marked by calling `mark_as_required`.\n\n  It will also apply any updates that have been collected (e.g. for moving\n  average summaries).\n\n  This is equivalent to:\n\n      total_loss = prettytensor.create_composite_loss(\n          losses=losses, regularize=regularize, include_marked=include_marked)\n      train_op_without_updates = optimizer.minimize(total_loss)\n      train_op = prettytensor.with_update_ops(train_op_without_updates)\n\n  N.B. Pay special attention to the `gate_gradients` argument to the optimizer.\n  If your graph is large, it will likely train unacceptably slow if you don't\n  specify it as GATE_NONE.\n\n  Args:\n    optimizer: The optimizer the minimize.\n    losses: A list of losses to apply.\n    regularize: Whether or not to include the regularization losses.\n    include_marked: Whether or not to use the marked losses.\n    clip_gradients_by_norm: If not None, clip gradients by the norm using\n      `tf.clip_by_norm`.\n    **kwargs: Additional arguments to pass into the optimizer.\n  Returns:\n    An operation to use for training that also updates any required ops such as\n      moving averages.\n  \"\"\"\n  books = for_default_graph()\n\n  g_step = kwargs.pop('global_step', books.global_step)\n  total_loss = books.create_composite_loss(losses=losses,\n                                           regularize=regularize,\n                                           include_marked=include_marked)\n\n  grads_and_vars = optimizer.compute_gradients(total_loss, **kwargs)\n  if clip_gradients_by_norm is not None:\n    clipped_grads_and_vars = []\n    for g, v in grads_and_vars:\n      if isinstance(g, tf.SparseTensor):\n        cg = tf.SparseTensor(\n            tf.clip_by_norm(g.values, clip_gradients_by_norm),\n            g.indices,\n            g.dense_shape)\n      elif isinstance(g, tf.IndexedSlices):\n        cg = tf.IndexedSlices(\n            tf.clip_by_norm(g.values, clip_gradients_by_norm),\n            g.indices)\n      else:\n        cg = tf.clip_by_norm(g, clip_gradients_by_norm)\n      clipped_grads_and_vars.append((cg, v))\n    grads_and_vars = clipped_grads_and_vars\n  train_op = optimizer.apply_gradients(grads_and_vars, global_step=g_step)\n  return books.with_update_ops(train_op)", "response": "Applies an optimizer to the graph and returns a train_op."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a global counter called once for setup by self. _global_step.", "response": "def _add_global_counter(self):\n    \"\"\"Adds a global counter, called once for setup by @property global_step.\"\"\"\n    assert self._global_step is None\n\n    # Force this into the top-level namescope. Instead of forcing top-level\n    # here, we could always call this in __init__() and then keep whatever\n    # namescopes are around then.\n    with self.g.as_default(), self.g.name_scope(None):\n      try:\n        self._global_step = self.g.get_tensor_by_name('global_step:0')\n      except KeyError:\n        self._global_step = tf.Variable(0, name='global_step', trainable=False)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_scalar_summary(self, x, tag=None):\n    if not self.summary_collections:\n      return\n    with self.g.as_default():\n      tag = tag or _tag_for(x.name)\n      summary = (tf.summary.scalar(\n          tag, x, collections=self.summary_collections))\n      return summary", "response": "Adds a scalar summary for x."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_histogram_summary(self, x, tag=None):\n    if not self.summary_collections:\n      return\n    with self.g.as_default():\n      tag = tag or _tag_for(x.name)\n      summary = tf.summary.histogram(\n          tag, x, collections=self.summary_collections)\n      return summary", "response": "Add a summary operation to visualize the histogram of x s values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exponential_moving_average(self,\n                                 var,\n                                 avg_var=None,\n                                 decay=0.999,\n                                 ignore_nan=False):\n    \"\"\"Calculates the exponential moving average.\n\n    TODO(): check if this implementation of moving average can now\n    be replaced by tensorflows implementation.\n\n    Adds a variable to keep track of the exponential moving average and adds an\n    update operation to the bookkeeper. The name of the variable is\n    '%s_average' % name prefixed with the current variable scope.\n\n    Args:\n       var: The variable for which a moving average should be computed.\n       avg_var: The variable to set the average into, if None create a zero\n         initialized one.\n       decay: How much history to use in the moving average.\n         Higher, means more history values [0, 1) accepted.\n       ignore_nan: If the value is NaN or Inf, skip it.\n    Returns:\n       The averaged variable.\n    Raises:\n      ValueError: if decay is not in [0, 1).\n    \"\"\"\n    with self._g.as_default():\n      if decay < 0 or decay >= 1.0:\n        raise ValueError('Decay is %5.2f, but has to be in [0, 1).' % decay)\n      if avg_var is None:\n        avg_name = '%s_average' % _bare_var_name(var)\n        with tf.control_dependencies(None):\n          with tf.name_scope(avg_name + '/Initializer/'):\n            if isinstance(var, tf.Variable):\n              init_val = var.initialized_value()\n            elif var.get_shape().is_fully_defined():\n              init_val = tf.constant(0,\n                                     shape=var.get_shape(),\n                                     dtype=var.dtype.base_dtype)\n            else:\n              init_val = tf.constant(0, dtype=var.dtype.base_dtype)\n          avg_var = tf.Variable(init_val, name=avg_name, trainable=False)\n\n      num_updates = tf.cast(self.global_step, tf.float32)\n      decay = tf.minimum(decay, tf.maximum(0.9, (1.0 + num_updates) /\n                                           (10.0 + num_updates)))\n      with tf.device(avg_var.device):\n        if ignore_nan:\n          var = tf.where(tf.is_finite(var), var, avg_var)\n        if var.get_shape().is_fully_defined():\n          avg_update = tf.assign_sub(avg_var, (1 - decay) * (avg_var - var))\n        else:\n          avg_update = tf.assign(avg_var,\n                                 avg_var - (1 - decay) * (avg_var - var),\n                                 validate_shape=False)\n      self._g.add_to_collection(GraphKeys.UPDATE_OPS, avg_update)\n      return avg_update", "response": "Calculates the exponential moving average of a variable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_average_summary(self, var, tag=None, decay=0.999, ignore_nan=True):\n    if not self.summary_collections:\n      return\n    with self.g.as_default():\n      if decay < 0.9 or decay >= 1.0:\n        raise ValueError('Decay is %5.2f, but has to be in [0, 1).' % decay)\n      avg_var = self.exponential_moving_average(var,\n                                                decay=decay,\n                                                ignore_nan=ignore_nan)\n      if tag is None:\n        tag = _bare_var_name(avg_var)\n        tag = self.g.unique_name(tag)\n      self.add_scalar_summary(avg_var, tag)\n      return avg_var", "response": "Adds a summary with the exponential moving average of var."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_loss(self, loss, name=None, regularization=False, add_summaries=True):\n    # TODO(eiderman): Strip name out and just rely on the name scope.\n    _ = name  # Eliminates pylint warning.\n    if regularization:\n      self._g.add_to_collection(GraphKeys.REGULARIZATION_LOSSES, loss)\n\n    tf.add_to_collection(GraphKeys.LOSSES, loss)\n    if add_summaries:\n      self.add_scalar_summary(loss, 'loss')\n      self.add_average_summary(loss, 'loss_average')", "response": "Adds a loss to the total loss for the network."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a composite loss that is the sum of all specified losses.", "response": "def create_composite_loss(self,\n                            losses,\n                            regularize=True,\n                            include_marked=True,\n                            name='cost'):\n    \"\"\"Creates a loss that is the sum of all specified losses.\n\n    Args:\n      losses: A sequence of losses to include.\n      regularize: Whether or not to include regularization losses.\n      include_marked: Whether or not to use the marked losses.\n      name: The name for this variable.\n    Returns:\n      A single tensor that is the sum of all losses.\n    Raises:\n      ValueError: if there are no losses.\n    \"\"\"\n    all_losses = []\n    if losses:\n      all_losses.extend(losses)\n    if include_marked:\n      all_losses.extend(self.marked_losses)\n    if not all_losses:\n      raise ValueError('No losses specified!')\n    if regularize:\n      all_losses.extend(self.regularization_losses)\n    with self._g.as_default():\n      result = tf.add_n(all_losses, name=name)\n      self.add_scalar_summary(result)\n      return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_state(self, state_name, initial_state, batch_size=None):\n    state_shape = initial_state.get_shape().as_list()\n    full_shape = [batch_size] + state_shape\n    if not batch_size:\n      # TODO(): -1 is now reserved for unknown, so this should be\n      # updated, but that requires coordination with the binary and is\n      # checkpoint incompatible.\n      # TODO(eiderman): When we make the above breaking change, we should make\n      # the C++ client use the initial state instead of passing in zeros.\n      shape_proto = self._as_shape_proto([0] + state_shape)\n      batch_size = 1\n    else:\n      shape_proto = self._as_shape_proto([batch_size] + state_shape)\n\n    # Add a constant tensor of zeros. At training time, this will initialize\n    # the state with the initial_state - at inference time,\n    # this node is replaced by a feed.\n    tiles = [batch_size] + ([1] * len(initial_state.get_shape()))\n    feed_op = tf.placeholder_with_default(\n        tf.tile(\n            tf.expand_dims(initial_state, [0]), tiles),\n        shape=full_shape,\n        name='%s_feed' % state_name)\n    s = {'feed_op': feed_op,\n         'feed_type': initial_state.dtype,\n         'feed_shape': shape_proto}\n    self._states[state_name] = s", "response": "Adds a state to the state saver."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a vector that specified one - hot per batch into a dense version.", "response": "def to_dense_one_hot(labels, class_count):\n  \"\"\"Converts a vector that specified one-hot per batch into a dense version.\n\n  Args:\n    labels: The labels input.\n    class_count: The number of classes as an int.\n  Returns:\n    One dense vector for each item in the batch.\n  Raises:\n    ValueError: If labels is not rank 1.\n    TypeError: If class_count is not an integer or labels is not an integer\n      Tensor.\n  \"\"\"\n  if not isinstance(class_count, tf.compat.integral_types):\n    raise TypeError('class_count must be an integer type.')\n  if labels.dtype.base_dtype not in (tf.int32, tf.int64):\n    raise TypeError('Labels must be an integer: %s' % labels.dtype)\n  if labels.get_shape().ndims != 1:\n    raise ValueError('Labels must be a rank 1 tensor: %s' % labels.get_shape())\n\n  dtype = labels.dtype.base_dtype\n  class_tensor = tf.convert_to_tensor(\n      class_count, dtype=dtype, name='class_count')\n\n  # Extract the batch from the shape so this is batch independent.\n  batch = tf.gather(tf.shape(labels), 0)\n  count = tf.expand_dims(tf.range(0, limit=batch), 1)\n  labels = tf.expand_dims(labels, 1)\n  batch = tf.gather(tf.shape(labels), 0)\n\n  if dtype != tf.int32:\n    count = tf.cast(count, dtype)\n    batch = tf.cast(batch, dtype)\n\n  result = tf.sparse_to_dense(\n      tf.concat([count, labels], 1),\n      tf.concat([tf.expand_dims(batch, 0), tf.expand_dims(class_tensor, 0)], 0),\n      1.0, 0.0)\n  result.set_shape([labels.get_shape().dims[0], class_count])\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert per_example_weights to a tensor and validates the shape.", "response": "def _convert_and_assert_per_example_weights_compatible(\n    input_, per_example_weights, dtype):\n  \"\"\"Converts per_example_weights to a tensor and validates the shape.\"\"\"\n  per_example_weights = tf.convert_to_tensor(\n      per_example_weights, name='per_example_weights', dtype=dtype)\n  if input_.get_shape().ndims:\n    expected_length = input_.get_shape().dims[0]\n    message = ('per_example_weights must have rank 1 and length %s, but was: %s'\n               % (expected_length, per_example_weights.get_shape()))\n  else:\n    expected_length = None\n    message = ('per_example_weights must have rank 1 and length equal to the '\n               'first dimension of inputs (unknown), but was: %s'\n               % per_example_weights.get_shape())\n\n  if per_example_weights.get_shape().ndims not in (1, None):\n    raise ValueError(message)\n\n  if not per_example_weights.get_shape().is_compatible_with((expected_length,)):\n    raise ValueError(message)\n\n  return per_example_weights"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply_regression(input_,\n                     regression_fn,\n                     target,\n                     regression_args=(),\n                     regression_kwargs=None,\n                     name=PROVIDED,\n                     loss_weight=None,\n                     per_example_weights=None):\n  \"\"\"Applies the given regression and adds the loss to the bookkeeper.\n\n  This does not change tensor.\n  Args:\n    input_: A Tensor or a Pretty Tensor holding the input.\n    regression_fn: A function that takes (in order) tensor, labels.\n    target: The targe of the regression.\n    regression_args: Other arguments for the regression.\n    regression_kwargs: Keyword args for the regression.\n    name: The name, also added to regression_kwargs.\n    loss_weight: A scalar multiplier for the loss.\n    per_example_weights: A Tensor with a weight per example.\n  Returns:\n    The loss tensor's name.\n  Raises:\n    ValueError: If the target is not a compatible shape with input_.\n  \"\"\"\n  if regression_kwargs is None:\n    regression_kwargs = {}\n  if name is not None and 'name' not in regression_kwargs:\n    regression_kwargs['name'] = name\n  elif name is None:\n    name = input_.tensor.op.name\n\n  tensor = input_.tensor\n  loss = regression_fn(tensor, target, *regression_args, **regression_kwargs)\n  if loss_weight is not None:\n    loss *= loss_weight\n  if per_example_weights is not None:\n    per_example_weights = _convert_and_assert_per_example_weights_compatible(\n        input_,\n        per_example_weights,\n        dtype=loss.dtype)\n    loss *= per_example_weights\n  # Use mean so that the learning rate is independent of the batch size.\n  if name is None:\n    name = loss.op.name\n  if tensor.get_shape()[0].value is not None:\n    # Try to use division instead of reduce_mean because reduce_mean doesn't\n    # work on GPU.\n    avg_loss = tf.reduce_sum(loss) / tensor.get_shape()[0].value\n  else:\n    avg_loss = tf.reduce_mean(loss)\n  return input_.add_loss(avg_loss, name=name)", "response": "Applies the given regression and adds the loss to the bookkeeper."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply an L2 Regression ( Sum of Squared Error to the target.", "response": "def l2_regression(\n    input_, target, name=PROVIDED, loss_weight=None,\n    per_example_weights=None):\n  \"\"\"Applies an L2 Regression (Sum of Squared Error) to the target.\"\"\"\n  target = _convert_and_assert_tensors_compatible(input_, target)\n  return apply_regression(input_,\n                          functions.l2_regression_sq_loss,\n                          target,\n                          [],\n                          name='%s_loss' % name,\n                          loss_weight=loss_weight,\n                          per_example_weights=per_example_weights)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply an L1 Regression to the target.", "response": "def l1_regression(\n    input_, target, name=PROVIDED, loss_weight=None,\n    per_example_weights=None):\n  \"\"\"Applies an L1 Regression (Sum of Absolute Error) to the target.\"\"\"\n  target = _convert_and_assert_tensors_compatible(input_, target)\n  return apply_regression(input_,\n                          functions.l1_regression_loss,\n                          target,\n                          [],\n                          name='%s_loss' % name,\n                          loss_weight=loss_weight,\n                          per_example_weights=per_example_weights)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the Cross Entropy of input_ vs labels.", "response": "def cross_entropy(input_,\n                  labels,\n                  name=PROVIDED,\n                  loss_weight=None,\n                  per_example_weights=None):\n  \"\"\"Calculates the Cross Entropy of input_ vs labels.\n\n  Args:\n    input_: A rank 2 `Tensor` or a Pretty Tensor holding the logits.\n    labels: A rank 2 tf.float32 or tf.float64 tensor containing the labels.\n    name: The optional name.\n    loss_weight: A weight to scale the loss. Used when there are multiple\n      losses.\n    per_example_weights: A weighting for each example.\n  Returns:\n    A loss.\n  Raises:\n    ValueError: if labels is None or the type is not float or double.\n  \"\"\"\n  if labels is None:\n    raise ValueError('Labels must be set')\n  labels = _convert_and_assert_tensors_compatible(input_, labels)\n\n  if per_example_weights is not None:\n    per_example_weights = _convert_and_assert_per_example_weights_compatible(\n        input_,\n        per_example_weights,\n        dtype=input_.dtype)\n\n  correct_predictions, examples = _compute_average_correct(\n      input_, labels, per_example_weights)\n  correct_ratio = correct_predictions / examples\n  if correct_ratio.get_shape().is_fully_defined():\n    input_.bookkeeper.add_average_summary(\n        correct_ratio, 'average_accuracy_%s' % name)\n  return apply_regression(\n      input_,\n      tf.contrib.nn.deprecated_flipped_softmax_cross_entropy_with_logits,\n      labels,\n      [],\n      name='%s_loss' % name,\n      loss_weight=loss_weight,\n      per_example_weights=per_example_weights)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the Cross Entropy of input_ vs labels.", "response": "def sparse_cross_entropy(input_,\n                         labels,\n                         name=PROVIDED,\n                         loss_weight=None,\n                         per_example_weights=None):\n  \"\"\"Calculates the Cross Entropy of input_ vs labels.\n\n  Args:\n    input_: A rank 2 `Tensor` or a Pretty Tensor holding the logits.\n    labels: A rank 1 integer `Tensor` with class ordinals\n    name: The optional name.\n    loss_weight: A weight to scale the loss. Used when there are multiple\n      losses.\n    per_example_weights: A weighting for each example.\n  Returns:\n    A loss.\n  Raises:\n    ValueError: if labels is None or the type is not float or double.\n  \"\"\"\n  if labels is None:\n    raise ValueError('Labels must be set')\n\n  if per_example_weights is not None:\n    per_example_weights = _convert_and_assert_per_example_weights_compatible(\n        input_,\n        per_example_weights,\n        dtype=input_.dtype)\n\n  return apply_regression(\n      input_,\n      tf.contrib.nn.deprecated_flipped_sparse_softmax_cross_entropy_with_logits,\n      labels,\n      [],\n      name='%s_loss' % name,\n      loss_weight=loss_weight,\n      per_example_weights=per_example_weights)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef binary_cross_entropy_with_logits(input_,\n                                     target,\n                                     name=PROVIDED,\n                                     loss_weight=None,\n                                     per_example_weights=None,\n                                     per_output_weights=None):\n  \"\"\"Calculates the binary cross entropy of the input_ vs inputs.\n\n  Expects unscaled logits. Do not pass in results of sigmoid operation.\n\n  Args:\n    input_: A rank 2 Tensor or a Pretty Tensor holding the logits.\n    target: A rank 2 tf.float32 or tf.float64 tensor containing class label\n      probabilities. Note that binary cross entropy is equivalent to logistic\n      loss.\n    name: The optional name.\n    loss_weight: A scalar multiplier for the loss.\n    per_example_weights: A `Tensor` with a weight per example.\n    per_output_weights: A weight `Tensor` that is the same shape as the\n      input_ that can be used to scale individual prediction losses.  See\n      `tf.tile` to turn a per-column weight vector into a `per_output_weights`\n      `Tensor`.\n  Returns:\n    Binary cross entropy loss after sigmoid operation.\n  Raises:\n    ValueError: if target is None or the type is not float or double.\n  \"\"\"\n  if target is None:\n    raise ValueError('target must be set')\n  target = _convert_and_assert_tensors_compatible(input_, target)\n\n  with tf.name_scope('stats'):\n    selected, sum_retrieved, sum_relevant = _compute_precision_recall(\n        input_, target, 0, per_example_weights)\n    precision = selected / sum_retrieved\n    recall = selected / sum_relevant\n    if precision.get_shape().is_fully_defined():\n      input_.bookkeeper.add_average_summary(\n          precision, 'average_precision_%s' % name)\n    if recall.get_shape().is_fully_defined():\n      input_.bookkeeper.add_average_summary(\n          recall, 'average_recall_%s' % name)\n    input_.bookkeeper.add_scalar_summary(\n        tf.reduce_sum(tf.to_float(tf.greater(input_, 0))), 'activations')\n    if per_output_weights is not None:\n      per_output_weights = tf.convert_to_tensor(\n          per_output_weights,\n          name='per_output_weights',\n          dtype=input_.dtype.base_dtype)\n      input_.get_shape().assert_is_compatible_with(\n          per_output_weights.get_shape())\n\n  def _batch_sum_bce(x, target, name='binary_cross_entropy'):\n    logits = functions.binary_cross_entropy_loss_with_logits(x,\n                                                             target,\n                                                             name=name)\n    if per_output_weights is not None:\n      logits *= per_output_weights\n    return functions.reduce_batch_sum(logits)\n\n  return apply_regression(\n      input_,\n      _batch_sum_bce,\n      target,\n      [],\n      name='%s_bce_loss' % name,\n      loss_weight=loss_weight,\n      per_example_weights=per_example_weights)", "response": "Calculates the binary cross entropy of the input_ vs inputs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef softmax_classifier_with_sampled_loss(inputs,\n                                         num_classes,\n                                         labels,\n                                         num_sampled,\n                                         num_true=None,\n                                         sampled_values=None,\n                                         remove_accidental_hits=True,\n                                         loss_weight=None,\n                                         per_example_weights=None,\n                                         weights=None,\n                                         bias=tf.zeros_initializer(),\n                                         parameter_modifier=parameters.identity,\n                                         name='softmax_classifier'):\n  \"\"\"Applies softmax and if labels is not None, then it adds a sampled loss.\n\n  This is a faster way to train a softmax classifier over a huge number of\n  classes. It is generally an underestimate of the full softmax loss.\n\n  At inference time, you can compute full softmax probabilities with the\n  expression `tf.nn.softmax(tf.matmul(inputs, weights) + biases)`.\n\n  See `tf.nn.sampled_softmax_loss` for more details.\n\n  Also see Section 3 of [Jean et al., 2014](http://arxiv.org/abs/1412.2007)\n  ([pdf](http://arxiv.org/pdf/1412.2007.pdf)) for the math.\n\n  Note: If you depend on the softmax part of the loss, then you will lose most\n  of the speed benefits of sampling the loss. It should be used for evaluation\n  only and not executed on every update op.\n\n  Note: This is not checkpoint compatible with `softmax_classifier` since it\n  optimizes a transpose by pushing it down to the `fully_connected` layer.\n\n  Args:\n    inputs: A `Tensor` of shape `[batch_size, dim]`.  The forward\n        activations of the input network.\n    num_classes: An `int`. The number of possible classes.\n    labels: A `Tensor` of type `int64` and shape `[batch_size,\n        num_true]`. The target classes.  Note that this format differs from\n        the `labels` argument of `nn.softmax_cross_entropy_with_logits`.\n    num_sampled: An `int`.  The number of classes to randomly sample per batch.\n    num_true: An `int`.  The number of target classes per training example,\n      defaults to the second dim of labels if known or 1.\n    sampled_values: a tuple of (`sampled_candidates`, `true_expected_count`,\n        `sampled_expected_count`) returned by a `*_candidate_sampler` function.\n        (if None, we default to `log_uniform_candidate_sampler`)\n    remove_accidental_hits:  A `bool`.  whether to remove \"accidental hits\"\n        where a sampled class equals one of the target classes.  Default is\n        True.\n    loss_weight: A scalar multiplier for the loss.\n    per_example_weights: A Tensor with a weight per example.\n    weights: The initializer for the weights (see `fully_connected`). Note:\n      This is the transpose of a normal fully_connected input layer!\n    bias: The initializer for the bias (see `fully_connected`).\n    parameter_modifier: A modifier for the parameters that compute the logits.\n    name: The optional name.\n  Returns:\n    A tuple of handles to the logits (fully connected layer) and loss.\n  Raises:\n    ValueError: If inputs or labels do not have the right shape.\n  \"\"\"\n  # Compound ops need to respect sequential, so take a snapshot.\n  input_copy = inputs.as_layer()\n\n  with tf.name_scope('sampled_softmax'):\n    full = inputs.fully_connected(num_classes,\n                                  activation_fn=None,\n                                  name=name,\n                                  transpose_weights=True,\n                                  weights=weights,\n                                  bias=bias,\n                                  parameter_modifier=parameter_modifier)\n    if labels is not None:\n      labels = tf.convert_to_tensor(labels, dtype=tf.int64, name='labels')\n      labels.get_shape().assert_is_compatible_with([input_copy.get_shape()[0],\n                                                    num_true])\n      if num_true is None:\n        if labels.get_shape().ndims and labels.get_shape().dims[1]:\n          num_true = labels.get_shape().dims[1].value\n        else:\n          num_true = 1\n\n      def _loss(input_, labels, name=None):\n        return tf.nn.sampled_softmax_loss(\n            weights=full.layer_parameters['weights'],\n            biases=full.layer_parameters['bias'],\n            labels=labels,\n            inputs=input_,\n            num_sampled=num_sampled,\n            num_classes=num_classes,\n            num_true=num_true,\n            sampled_values=sampled_values,\n            remove_accidental_hits=remove_accidental_hits,\n            name=name)\n\n      loss = apply_regression(input_copy,\n                              _loss,\n                              labels,\n                              [],\n                              name='%s_sampled_loss' % name,\n                              loss_weight=loss_weight,\n                              per_example_weights=per_example_weights)\n    else:\n      loss = None\n\n  return SampledSoftmaxResult(full, loss)", "response": "Applies softmax and adds a sampled loss to the most available base class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef softmax_classifier(input_,\n                       num_classes,\n                       labels=None,\n                       loss_weight=None,\n                       per_example_weights=None,\n                       weights=None,\n                       bias=tf.zeros_initializer(),\n                       parameter_modifier=parameters.identity,\n                       name=PROVIDED):\n  \"\"\"Creates a fully-connected linear layer followed by a softmax.\n\n  This returns `(softmax, loss)` where `loss` is the cross entropy loss.\n\n  Args:\n    input_: A rank 2 Tensor or a Pretty Tensor holding the activation before\n      the logits (penultimate layer).\n    num_classes: The number of classes.\n    labels: The target labels to learn as a float tensor.  Use None to not\n      include a training loss.\n    loss_weight: A scalar multiplier for the loss.\n    per_example_weights: A Tensor with a weight per example.\n    weights: The initializer for the weights (see `fully_connected`).\n    bias: The initializer for the bias (see `fully_connected`).\n    parameter_modifier: A modifier for the parameters that compute the logits.\n    name: The optional name.\n  Returns:\n    A named tuple holding:\n\n    softmax: The result of this layer with softmax normalization.\n    loss: The cross entropy loss.\n  Raises:\n    ValueError: If the datatype is wrong.\n  \"\"\"\n  full = input_.fully_connected(num_classes,\n                                activation_fn=None,\n                                name=name,\n                                weights=weights,\n                                bias=bias,\n                                parameter_modifier=parameter_modifier)\n  return full.softmax(labels=labels,\n                      loss_weight=loss_weight,\n                      per_example_weights=per_example_weights,\n                      name=name)", "response": "Creates a fully - connected linear layer followed by a softmax."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef softmax(input_,\n            labels=None,\n            name=PROVIDED,\n            loss_weight=None,\n            per_example_weights=None):\n  \"\"\"Applies softmax and if labels is not None, then it also adds a loss.\n\n  Args:\n    input_: A rank 2 Tensor or a Pretty Tensor holding the logits.\n    labels: The target labels to learn as a float tensor.  Use None to not\n      include a training loss.\n    name: The optional name.\n    loss_weight: A scalar multiplier for the loss.\n    per_example_weights: A Tensor with a weight per example.\n  Returns:\n    A tuple of the a handle to softmax and a handle to the loss tensor.\n  Raises:\n    ValueError: If the datatype is wrong.\n  \"\"\"\n  if labels is not None:\n    # Cache the current layer because we only want softmax to change the head.\n    full = input_.as_layer()\n    return SoftmaxResult(input_.softmax_activation(),\n                         full.cross_entropy(\n                             labels,\n                             name=name,\n                             loss_weight=loss_weight,\n                             per_example_weights=per_example_weights))\n  else:\n    return SoftmaxResult(input_.softmax_activation(), None)", "response": "Applies softmax and adds a loss to the current layer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nevaluating the precision and recall of the prediction vs the target labels.", "response": "def evaluate_precision_recall(input_,\n                              labels,\n                              threshold=0.5,\n                              per_example_weights=None,\n                              name=PROVIDED,\n                              phase=Phase.train):\n  \"\"\"Computes the precision and recall of the prediction vs the labels.\n\n  Args:\n    input_: A rank 2 Tensor or a Pretty Tensor holding the result of the model.\n    labels: The target labels to learn as a float tensor.\n    threshold: The threshold to use to decide if the prediction is true.\n    per_example_weights: A Tensor with a weight per example.\n    name: An optional name.\n    phase: The phase of this model; non training phases compute a total across\n      all examples.\n  Returns:\n    Precision and Recall.\n  \"\"\"\n  _ = name  # Eliminate warning, name used for namescoping by PT.\n  selected, sum_retrieved, sum_relevant = _compute_precision_recall(\n      input_, labels, threshold, per_example_weights)\n\n  if phase != Phase.train:\n    dtype = tf.float32\n    # Create the variables in all cases so that the load logic is easier.\n    relevant_count = tf.get_variable(\n        'relevant_count', [],\n        dtype,\n        tf.zeros_initializer(),\n        collections=[bookkeeper.GraphKeys.TEST_VARIABLES],\n        trainable=False)\n    retrieved_count = tf.get_variable(\n        'retrieved_count', [],\n        dtype,\n        tf.zeros_initializer(),\n        collections=[bookkeeper.GraphKeys.TEST_VARIABLES],\n        trainable=False)\n    selected_count = tf.get_variable(\n        'selected_count', [],\n        dtype,\n        tf.zeros_initializer(),\n        collections=[bookkeeper.GraphKeys.TEST_VARIABLES],\n        trainable=False)\n\n    with input_.g.device(selected_count.device):\n      selected = tf.assign_add(selected_count, selected)\n    with input_.g.device(retrieved_count.device):\n      sum_retrieved = tf.assign_add(retrieved_count, sum_retrieved)\n    with input_.g.device(relevant_count.device):\n      sum_relevant = tf.assign_add(relevant_count, sum_relevant)\n\n  return (tf.where(tf.equal(sum_retrieved, 0),\n                   tf.zeros_like(selected),\n                   selected/sum_retrieved),\n          tf.where(tf.equal(sum_relevant, 0),\n                   tf.zeros_like(selected),\n                   selected/sum_relevant))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _eval_metric(input_, topk, correct_predictions, examples, phase):\n  my_parameters = {}\n  if phase in (Phase.test, Phase.infer):\n    dtype = tf.float32\n    # Create the variables using tf.Variable because we don't want to share.\n    count = tf.Variable(tf.constant(0, dtype=dtype),\n                        name='count_%d' % topk,\n                        collections=[bookkeeper.GraphKeys.TEST_VARIABLES],\n                        trainable=False)\n    correct = tf.Variable(tf.constant(0, dtype=dtype),\n                          name='correct_%d' % topk,\n                          collections=[bookkeeper.GraphKeys.TEST_VARIABLES],\n                          trainable=False)\n    my_parameters['count'] = count\n    my_parameters['correct'] = correct\n    with input_.g.device(count.device):\n      examples = tf.assign_add(count, examples)\n    with input_.g.device(correct.device):\n      correct_predictions = tf.assign_add(correct, correct_predictions)\n  return correct_predictions, examples, my_parameters", "response": "Creates the standard tracking varibles if in test and returns accuracy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nevaluate the classifier fraction of the current layer.", "response": "def evaluate_classifier_fraction(input_,\n                                 labels,\n                                 per_example_weights=None,\n                                 topk=1,\n                                 name=PROVIDED,\n                                 phase=Phase.train):\n  \"\"\"Calculates the total of correct predictions and example count.\n\n  In test and infer mode, this creates variables in the graph collection\n  pt.GraphKeys.TEST_VARIABLES and does not add them to\n  tf.GraphKeys.ALL_VARIABLES.  This means that you must initialize them\n  separately from tf.global_variables_initializer().\n\n  In the case of `topk == 1`, this breaks ties left-to-right, in all other cases\n  it follows `tf.nn.in_top_k`. *Note*: the tie behavior will change in the\n  future.\n\n  Args:\n    input_: A rank 2 Tensor or a Pretty Tensor holding the result of the model.\n    labels: A float or double `Tensor` containing the target for this layer *or*\n      an integer `Tensor` with the sparse one-hot indices.\n    per_example_weights: Weights that are applied to every example.\n    topk: Integer k for 'accuracy at top k' metric.\n    name: The name of this layer.\n    phase: In training mode the batch accuracy is returned and in eval/infer\n      modes a total average is calculated.\n  Returns:\n    A Pretty Tensor that contains correct_predictions, num_examples.\n  Raises:\n    ValueError: If labels is not the correct shape.\n  \"\"\"\n  _ = name  # Suppress lint\n  if not (tf.float32.is_compatible_with(labels.dtype) or\n          tf.float64.is_compatible_with(labels.dtype)):\n    raise ValueError('labels must be floating point: %s.' % labels.dtype)\n  correct_predictions, examples = _compute_average_correct(input_,\n                                                           labels,\n                                                           per_example_weights,\n                                                           topk=topk)\n  correct_predictions, examples, my_parameters = _eval_metric(\n      input_, topk, correct_predictions, examples, phase)\n  return input_.with_sequence([correct_predictions, examples], my_parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nevaluating the classifier fraction of all examples seen.", "response": "def evaluate_classifier(input_, labels, per_example_weights=None,\n                        topk=1, name=PROVIDED, phase=Phase.train):\n  \"\"\"Calculates the total ratio of correct predictions across all examples seen.\n\n  In test and infer mode, this creates variables in the graph collection\n  pt.GraphKeys.TEST_VARIABLES and does not add them to\n  tf.GraphKeys.ALL_VARIABLES.  This means that you must initialize them\n  separately from tf.global_variables_initializer().\n\n  In the case of `topk == 1`, this breaks ties left-to-right, in all other cases\n  it follows `tf.nn.in_top_k`. *Note*: the tie behavior will change in the\n  future.\n\n  Args:\n    input_: A rank 2 Tensor or a Pretty Tensor holding the result of the model.\n    labels: A float or double `Tensor` containing the target for this layer.\n    per_example_weights: Weights that are applied to every example.\n    topk: Integer k for 'accuracy at top k' metric.\n    name: The name of this layer.\n    phase: In training mode the batch accuracy is returned and in eval/infer\n      modes a total average is calculated.\n  Returns:\n    A Pretty Tensor with the ratio of correct to total examples seen.\n  Raises:\n    ValueError: If labels is not the correct shape.\n  \"\"\"\n  result = input_.evaluate_classifier_fraction(\n      labels,\n      per_example_weights=per_example_weights,\n      topk=topk,\n      name=name,\n      phase=phase)\n\n  return input_.with_tensor(result[0] / result[1], result.layer_parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nevaluate the fraction of the classifier fraction.", "response": "def evaluate_classifier_fraction_sparse(input_,\n                                        labels,\n                                        per_example_weights=None,\n                                        topk=1,\n                                        name=PROVIDED,\n                                        phase=Phase.train):\n  \"\"\"Calculates the total of correct predictions and example count.\n\n  In test and infer mode, this creates variables in the graph collection\n  pt.GraphKeys.TEST_VARIABLES and does not add them to\n  tf.GraphKeys.ALL_VARIABLES.  This means that you must initialize them\n  separately from tf.global_variables_initializer().\n\n  This breaks ties left-to-right.\n\n  Args:\n    input_: A rank 2 Tensor or Pretty Tensor holding the result of the\n      model.\n    labels: A float or double `Tensor` containing the target for this layer *or*\n      an integer `Tensor` with the sparse one-hot indices.\n    per_example_weights: Weights that are applied to every example.\n    topk: Integer k for 'accuracy at top k' metric.\n    name: The name of this layer.\n    phase: In training mode the batch accuracy is returned and in eval/infer\n      modes a total average is calculated.\n  Returns:\n    A Pretty Tensor that contains correct_predictions, num_examples.\n  Raises:\n    ValueError: If labels is not the correct shape.\n  \"\"\"\n  _ = name  # Suppress lint\n  if not (tf.int32.is_compatible_with(labels.dtype) or\n          tf.int64.is_compatible_with(labels.dtype)):\n    raise ValueError('Labels must be an integer type.: %s.' % labels.dtype)\n  correct_predictions, examples = _compute_sparse_average_correct(\n      input_, labels, per_example_weights, topk=topk)\n  correct_predictions, examples, my_parameters = _eval_metric(\n      input_, topk, correct_predictions, examples, phase)\n  return input_.with_sequence([correct_predictions, examples], my_parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nevaluate the total ratio of correct predictions across all examples seen.", "response": "def evaluate_classifier_sparse(input_,\n                               labels,\n                               per_example_weights=None,\n                               topk=1,\n                               name=PROVIDED,\n                               phase=Phase.train):\n  \"\"\"Calculates the total ratio of correct predictions across all examples seen.\n\n  In test and infer mode, this creates variables in the graph collection\n  pt.GraphKeys.TEST_VARIABLES and does not add them to\n  tf.GraphKeys.ALL_VARIABLES.  This means that you must initialize them\n  separately from tf.global_variables_initializer().\n\n  This breaks ties left-to-right.\n\n  Args:\n    input_: A rank 2 Tensor or Pretty Tensor holding the result of the model.\n    labels: An integer `Tensor` with the sparse one-hot indices as\n      [batch, num_true].\n    per_example_weights: Weights that are applied to every example.\n    topk: Integer k for 'accuracy at top k' metric.\n    name: The name of this layer.\n    phase: In training mode the batch accuracy is returned and in eval/infer\n      modes a total average is calculated.\n  Returns:\n    A Pretty Tensor with the ratio of correct to total examples seen.\n  Raises:\n    ValueError: If labels is not the correct shape.\n  \"\"\"\n  result = input_.evaluate_classifier_fraction_sparse(\n      labels,\n      per_example_weights=per_example_weights,\n      topk=topk,\n      name=name,\n      phase=phase)\n\n  return input_.with_tensor(result[0] / result[1], result.layer_parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the numerator of both the denominator of precision and recall.", "response": "def _compute_precision_recall(input_, labels, threshold,\n                              per_example_weights):\n  \"\"\"Returns the numerator of both, the denominator of precision and recall.\"\"\"\n\n  # To apply per_example_weights, we need to collapse each row to a scalar, but\n  # we really want the sum.\n  labels.get_shape().assert_is_compatible_with(input_.get_shape())\n  relevant = tf.to_float(tf.greater(labels, 0))\n  retrieved = tf.to_float(tf.greater(input_, threshold))\n  selected = relevant * retrieved\n\n  if per_example_weights is not None:\n    per_example_weights = _convert_and_assert_per_example_weights_compatible(\n        input_,\n        per_example_weights,\n        dtype=None)\n    per_example_weights = tf.to_float(tf.greater(per_example_weights, 0))\n    selected = functions.reduce_batch_sum(selected) * per_example_weights\n    relevant = functions.reduce_batch_sum(relevant) * per_example_weights\n    retrieved = functions.reduce_batch_sum(retrieved) * per_example_weights\n  sum_relevant = tf.reduce_sum(relevant)\n  sum_retrieved = tf.reduce_sum(retrieved)\n  selected = tf.reduce_sum(selected)\n  return selected, sum_retrieved, sum_relevant"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the numerator and denominator of classifier accuracy.", "response": "def _compute_average_correct(input_, labels, per_example_weights, topk=1):\n  \"\"\"Returns the numerator and denominator of classifier accuracy.\"\"\"\n  return _compute_sparse_average_correct(\n      input_,\n      tf.reshape(tf.argmax(labels, 1), [-1, 1]), per_example_weights, topk=topk)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the numerator and denominator of classifier accuracy.", "response": "def _compute_sparse_average_correct(\n    input_, labels, per_example_weights, topk=1):\n  \"\"\"Returns the numerator and denominator of classifier accuracy.\"\"\"\n  labels = tf.to_int64(labels)\n  labels.get_shape().assert_is_compatible_with(\n      [input_.get_shape()[0], None])\n  if topk == 1:\n    predictions = tf.reshape(tf.argmax(input_, 1), [-1, 1])\n    in_topk = tf.reduce_any(tf.equal(labels, predictions),\n                            reduction_indices=[1])\n  else:\n    # Use broadcasting to check if ANY of the predictions are in the top k.\n    # TODO(eiderman): For a multi-label top k, what does accuracy mean?\n    predictions = tf.reshape(tf.nn.top_k(input_, topk)[1], [-1, 1, topk])\n    labels = tf.expand_dims(labels, [-1])\n\n    in_topk = tf.reduce_any(tf.equal(tf.cast(labels, predictions.dtype),\n                                     predictions),\n                            reduction_indices=[1, 2])\n  correct_predictions = tf.to_float(in_topk)\n\n  # If individual examples are weighted, then we want to normalize by that.\n  if per_example_weights is not None:\n    per_example_weights = _convert_and_assert_per_example_weights_compatible(\n        input_,\n        per_example_weights,\n        dtype=None)\n    float_weights = tf.to_float(per_example_weights)\n    # TODO(eiderman): This should use an op that doesn't support broadcasting.\n    correct_predictions *= float_weights\n    num_examples = tf.reduce_sum(float_weights)\n  else:\n    # shape only holds ints, but we want to always return the same type\n    # for num_examples to make everything compatible.\n    num_examples = tf.to_float(tf.gather(tf.shape(input_), 0))\n  return tf.reduce_sum(correct_predictions), num_examples"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_recurrent_cell(state_fn, **kwargs):\n  def _fn(cell_fn):\n    \"\"\"The register_recurrent_cell decorator.\"\"\"\n    result = prettytensor.RegisterCompoundOp(**kwargs)(cell_fn)\n\n    method_name = kwargs.pop('method_name', cell_fn.__name__)\n    if method_name.endswith('_cell'):\n      method_name = method_name[:-5]\n    method_name = 'sequence_' + method_name\n\n    class _Sequence(prettytensor.VarStoreMethod):\n      \"\"\"Expands a cell into a sequence version.\n\n      This holds an internal template to ensure that the same parameters are\n      used each time it is called.\n      \"\"\"\n\n      def __init__(self):\n        super(self.__class__, self).__init__()\n        self.template = None\n\n      def __call__(self,\n                   input_layer,\n                   *args,\n                   **kwargs):\n        name = kwargs.pop('name', 'sequence')\n        lengths = kwargs.pop('lengths', None)\n        state_tuples = state_fn(input_layer, *args, **kwargs)\n        if not self.template:\n          template = prettytensor.template('input', input_layer.bookkeeper)\n          states = [prettytensor.UnboundVariable(s[0]) for s in state_tuples]\n          self.template = cell_fn(template, states, *args, **kwargs).as_fn(\n              'input', *[s[0] for s in state_tuples])\n\n        batch_size = input_layer.shape[0]\n        state_shapes = [[batch_size, s[1]] for s in state_tuples]\n        return unroll_state_saver(\n            input_layer, name, state_shapes, self.template, lengths)\n\n    doc_to_copy = result.__doc__\n    doc_to_copy = doc_to_copy[doc_to_copy.find('\\n') + 2:]\n    doc = \"\"\"Unrolls `{0}` over the input.\n\n  This takes an input that is a list of length timesteps where each element\n  is a `Tensor` of `[batch, *Dims]` and unrolls the recurrent cell. The input\n  and state to the cell are managed by this method, but the rest of the\n  arguments are passed through.\n\n    {1}\"\"\".format(cell_fn.__name__, doc_to_copy)\n    if hasattr(_Sequence.__call__, '__func__'):\n      _Sequence.__call__.__func__.__doc__ = doc\n    else:\n      _Sequence.__call__.__doc__ = doc\n    prettytensor.Register(method_name=method_name, **kwargs)(_Sequence)\n\n    return result\n  return _fn", "response": "Decorator to register a cell function with auxiliary functions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lstm_cell(input_layer,\n              states,\n              num_units,\n              bias=tf.zeros_initializer(),\n              peephole=True,\n              weights=None,\n              phase=prettytensor.Phase.train,\n              parameter_modifier=parameters.identity):\n  \"\"\"Long short-term memory cell (LSTM).\n\n  Args:\n    input_layer: The input layer.\n    states: The current state of the network, as\n      [[batch, num_units], [batch, num_units]] (c, h).\n    num_units: How big is the hidden state.\n    bias: An initializer for the bias or a Tensor. No bias if set to None.\n    peephole: Whether to use peephole connections as described in\n        http://www.jmlr.org/papers/volume3/gers02a/gers02a.pdf\n    weights:  An initializer for weights or a Tensor.\n    phase: The phase of graph construction.  See `pt.Phase`.\n    parameter_modifier: A function to modify parameters that is applied after\n      creation and before use.\n  Returns:\n    A RecurrentResult.\n  \"\"\"\n  # As a compound op, it needs to respect whether or not this is a sequential\n  # builder.\n  if input_layer.is_sequential_builder():\n    layer = input_layer.as_layer()\n  else:\n    layer = input_layer\n  c, h = [prettytensor.wrap(state, layer.bookkeeper) for state in states]\n  activation_input = layer.fully_connected(\n      4 * num_units,\n      bias=bias,\n      activation_fn=None,\n      weights=weights,\n      parameter_modifier=parameter_modifier,\n      phase=phase)\n  activation_h = h.fully_connected(4 * num_units,\n                                   bias=None,\n                                   activation_fn=None,\n                                   weights=weights,\n                                   parameter_modifier=parameter_modifier,\n                                   phase=phase)\n\n  activation = activation_input + activation_h\n\n  # i = input_gate, j = new_input, f = forget_gate, o = output_gate\n  split = activation.split(1, 4)\n  i = split[0]\n  j = split[1]\n  f = split[2]\n  if bias is not None:\n    # Biases of the forget gate are initialized to 1 in order to reduce the\n    # scale of forgetting in the beginning of the training.\n    f += 1.\n  o = split[3]\n  if peephole:\n    # TODO(eiderman): It would be worthwhile to determine the best initialization.\n    i += c.diagonal_matrix_mul(weights=weights,\n                               parameter_modifier=parameter_modifier,\n                               phase=phase)\n    f += c.diagonal_matrix_mul(weights=weights,\n                               parameter_modifier=parameter_modifier,\n                               phase=phase)\n\n  f_gate = f.apply(tf.sigmoid, name='f_gate')\n  new_c = (c * f_gate + i.apply(tf.sigmoid, name='i_gate') * j.apply(tf.tanh))\n  if peephole:\n    o += new_c.diagonal_matrix_mul(weights=weights,\n                                   parameter_modifier=parameter_modifier,\n                                   phase=phase)\n\n  new_h = new_c.apply(tf.tanh) * o.apply(tf.sigmoid, name='o_gate')\n\n  if input_layer.is_sequential_builder():\n    new_h = input_layer.set_head(input_layer)\n  return RecurrentResult(new_h, [new_c, new_h])", "response": "Long short - term memory cell."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngating recurrent unit memory cell.", "response": "def gru_cell(input_layer,\n             state,\n             num_units,\n             bias=tf.zeros_initializer(),\n             weights=None,\n             phase=prettytensor.Phase.train,\n             parameter_modifier=parameters.identity):\n  \"\"\"Gated recurrent unit memory cell (GRU).\n\n  Args:\n    input_layer: The input layer.\n    state: The current state of the network. For GRUs, this is a list with\n      one element (tensor) of shape [batch, num_units].\n    num_units: How big is the hidden state.\n    bias: An initializer for the bias or a Tensor. No bias if set to None.\n    weights: An initializer for weights or a Tensor.\n    phase: The phase of graph construction.  See `pt.Phase`.\n    parameter_modifier: A function to modify parameters that is applied after\n      creation and before use.\n  Returns:\n    A RecurrentResult.\n  \"\"\"\n  # As a compound op, it needs to respect whether or not this is a sequential\n  # builder.\n  if input_layer.is_sequential_builder():\n    layer = input_layer.as_layer()\n  else:\n    layer = input_layer\n  # We start with bias of 1.0 to not reset and not udpate.\n  # NB We compute activation_input and activation_state in two different ops,\n  # instead of concatenating them, followed by one matrix multiplication. The\n  # reason is that input has size [batch_size x input_size], while state has\n  # [ ? x state_size ], where the first dimension is 1 initially and will be\n  # batch_size only after the first RNN computation. We thus cannot concatenate\n  # input and state, and instead add the results of two fully connected ops,\n  # which works thanks to broadcasting, independent of state's batch size.\n  state = state[0]\n  state_pt = prettytensor.wrap(state, layer.bookkeeper)\n\n  activation_input = layer.fully_connected(\n      2 * num_units,\n      bias=None if bias is None else tf.constant_initializer(1.0),\n      activation_fn=None,\n      weights=weights,\n      phase=phase,\n      parameter_modifier=parameter_modifier)\n  activation_state = state_pt.fully_connected(\n      2 * num_units,\n      bias=None,\n      activation_fn=None,\n      weights=weights,\n      phase=phase,\n      parameter_modifier=parameter_modifier)\n\n  # adds batch_size x (2 * num_units) + ? x (2 * num_inputs)\n  activation = activation_input + activation_state\n  activation = activation.sigmoid()\n\n  split = activation.split(1, 2)\n  r = split[0]\n  u = split[1]\n\n  c = layer.concat(1, [r * state]).fully_connected(\n      num_units,\n      bias=bias,\n      activation_fn=None,\n      weights=weights,\n      phase=phase,\n      parameter_modifier=parameter_modifier).apply(tf.tanh)\n  new_h = u * state + (1 - u) * c\n  if input_layer.is_sequential_builder():\n    new_h = input_layer.set_head(input_layer)\n  return RecurrentResult(new_h, [new_h])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unroll_state_saver(input_layer, name, state_shapes, template, lengths=None):\n  state_saver = input_layer.bookkeeper.recurrent_state\n  state_names = [STATE_NAME % name + '_%d' % i\n                 for i in xrange(len(state_shapes))]\n  if hasattr(state_saver, 'add_state'):\n    for state_name, state_shape in zip(state_names, state_shapes):\n      initial_state = tf.zeros(state_shape[1:], dtype=input_layer.dtype)\n      state_saver.add_state(state_name,\n                            initial_state=initial_state,\n                            batch_size=state_shape[0])\n  if lengths is not None:\n    max_length = tf.reduce_max(lengths)\n  else:\n    max_length = None\n\n  results = []\n  prev_states = []\n  for state_name, state_shape in zip(state_names, state_shapes):\n    my_shape = list(state_shape)\n    my_shape[0] = -1\n    prev_states.append(tf.reshape(state_saver.state(state_name), my_shape))\n\n  my_parameters = None\n  for i, layer in enumerate(input_layer.sequence):\n    with input_layer.g.name_scope('unroll_%00d' % i):\n      if i > 0 and max_length is not None:\n        # TODO(eiderman): Right now the everything after length is undefined.\n        # If we can efficiently propagate the last result to the end, then\n        # models with only a final output would require a single softmax\n        # computation.\n        # pylint: disable=cell-var-from-loop\n        result = control_flow_ops.cond(\n            i < max_length,\n            lambda: unwrap_all(*template(layer, *prev_states).flatten()),\n            lambda: unwrap_all(out, *prev_states))\n        out = result[0]\n        prev_states = result[1:]\n      else:\n        out, prev_states = template(layer, *prev_states)\n    if my_parameters is None:\n      my_parameters = out.layer_parameters\n    results.append(prettytensor.unwrap(out))\n\n  updates = [state_saver.save_state(state_name, prettytensor.unwrap(prev_state))\n             for state_name, prev_state in zip(state_names, prev_states)]\n\n  # Set it up so that update is evaluated when the result of this method is\n  # evaluated by injecting a dependency on an arbitrary result.\n  with tf.control_dependencies(updates):\n    results[0] = tf.identity(results[0])\n  return input_layer.with_sequence(results, parameters=my_parameters)", "response": "Unrolls the given function with state taken from the state saver."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsquashing a sequence into a single Tensor with dim 1 being time * batch.", "response": "def squash_sequence(input_layer):\n  \"\"\"\"Squashes a sequence into a single Tensor with dim 1 being time*batch.\n\n  A sequence is an array of Tensors, which is not appropriate for most\n  operations, this squashes them together into Tensor.\n\n  Defaults are assigned such that cleave_sequence requires no args.\n\n  Args:\n    input_layer: The input layer.\n  Returns:\n    A PrettyTensor containing a single tensor with the first dim containing\n    both time and batch.\n  Raises:\n    ValueError: If the sequence is empty.\n  \"\"\"\n  timesteps = len(input_layer.sequence)\n  if not timesteps:\n    raise ValueError('Empty tensor sequence.')\n  elif timesteps == 1:\n    result = input_layer.sequence[0]\n  else:\n    result = tf.concat(input_layer.sequence, 0)\n  return input_layer.with_tensor(result).with_defaults(unroll=timesteps)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cleave_sequence(input_layer, unroll=None):\n  if unroll is None:\n    raise ValueError('You must set unroll either here or in the defaults.')\n\n  shape = input_layer.shape\n  if shape[0] is not None and shape[0] % unroll != 0:\n    raise ValueError('Must divide the split dimension evenly: %d mod %d != 0' %\n                     (shape[0], unroll))\n\n  if unroll <= 0:\n    raise ValueError('Unroll must be > 0: %s' % unroll)\n  elif unroll == 1:\n    splits = [input_layer.tensor]\n  else:\n    splits = tf.split(\n        value=input_layer.tensor, num_or_size_splits=unroll, axis=0)\n  result = input_layer.with_sequence(splits)\n\n  # This is an abuse of the defaults system, but it is safe because we are only\n  # modifying result.\n  defaults = result.defaults\n  if 'unroll' in defaults:\n    del defaults['unroll']\n  return result", "response": "Clears a tensor into a sequence."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lstm_state_tuples(num_nodes, name):\n  if not isinstance(num_nodes, tf.compat.integral_types):\n    raise ValueError('num_nodes must be an integer: %s' % num_nodes)\n  return [(STATE_NAME % name + '_0', tf.float32, num_nodes),\n          (STATE_NAME % name + '_1', tf.float32, num_nodes)]", "response": "Convenience method to create a list of tuples for lstm_state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gru_state_tuples(num_nodes, name):\n  if not isinstance(num_nodes, tf.compat.integral_types):\n    raise ValueError('num_nodes must be an integer: %s' % num_nodes)\n  return [(STATE_NAME % name + '_0', tf.float32, num_nodes)]", "response": "Convenience method to create a list of tuples for GRU state variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_sequence_pretty_tensor(sequence_input, shape=None, save_state=True):\n  inputs = prettytensor.wrap_sequence(sequence_input.inputs, tensor_shape=shape)\n  targets = prettytensor.wrap_sequence(sequence_input.targets)\n  if save_state:\n    bookkeeper.set_recurrent_state_saver(sequence_input)\n  return inputs, targets", "response": "Creates a PrettyTensor object for the given sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flatten(self):\n    ls = [self.output]\n    ls.extend(self.state)\n    return ls", "response": "Create a flattened version by putting output first then states."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the graph with the provided feeds and fetches.", "response": "def run(self, fetch_list, feed_dict=None, sess=None):\n    \"\"\"Runs the graph with the provided feeds and fetches.\n\n    This function wraps sess.Run(), but takes care of state saving and\n    restoring by feeding in states and storing the new state values.\n    Args:\n      fetch_list: A list of requested output tensors.\n      feed_dict: A dictionary of feeds - see Session.Run(). Optional.\n      sess: The Tensorflow session to run. Can be None.\n    Returns:\n      The requested tensors as numpy arrays.\n    Raises:\n      ValueError: If the default graph during object construction was\n      different from the current default graph.\n    \"\"\"\n    if tf.get_default_graph() != self._graph:\n      raise ValueError('The current default graph is different from the graph'\n                       ' used at construction time of RecurrentRunner.')\n    if feed_dict is None:\n      all_feeds_dict = {}\n    else:\n      all_feeds_dict = dict(feed_dict)\n    all_feeds_dict.update(self._state_feeds)\n    all_fetches_list = list(fetch_list)\n    all_fetches_list += self._state_fetches\n\n    sess = sess or tf.get_default_session()\n\n    # Run the compute graph.\n    fetches = sess.run(all_fetches_list, all_feeds_dict)\n    # Update the feeds for the next time step.\n    states = fetches[len(fetch_list):]\n    for i, s in enumerate(states):\n      self._state_feeds[self._state_feed_names[i]] = s\n\n    return fetches[:len(fetch_list)]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the best IP address for this device.", "response": "def get_ipaddr(self):\n        '''\n        Return the best IP address for this device.\n        Returns the first matching IP:\n            - Lowest Loopback interface\n            - Lowest SVI address/known IP\n        '''\n        # Loopbacks - first interface\n        if (len(self.loopbacks)):\n            ips = self.loopbacks[0].ips\n            if (len(ips)):\n                ips.sort()\n                return util.strip_slash_masklen(ips[0])\n\n        # SVIs + all known - lowest address\n        ips = []\n        for svi in self.svis:\n            ips.extend(svi.ip)\n        ips.extend(self.ip)\n        if (len(ips)):\n            ips.sort()\n            return util.strip_slash_masklen(ips[0])\n\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __get_vpc_info(self, ifarr):\n        '''\n        If VPC is enabled,\n        Return the VPC domain and interface name of the VPC peerlink.\n        '''\n        if (self.vpc_vbtbl == None):\n            self.vpc_vbtbl = self.snmpobj.get_bulk(OID_VPC_PEERLINK_IF)\n        if ((self.vpc_vbtbl == None) | (len(self.vpc_vbtbl) == 0)):\n            return (None, None)\n        domain = natlas_snmp.get_last_oid_token(self.vpc_vbtbl[0][0][0])\n        ifidx  = str(self.vpc_vbtbl[0][0][1])\n        ifname = self.snmpobj.cache_lookup(ifarr, OID_ETH_IF_DESC + '.' + ifidx)\n        ifname = self.shorten_port_name(ifname)\n        return (domain, ifname)", "response": "Get the VPC domain and interface name from the peerlink."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning array of MAC addresses from single node at IP", "response": "def get_macs(self, ip, display_progress):\n        '''\n        Return array of MAC addresses from single node at IP\n        '''\n        if (ip == '0.0.0.0'):\n            return None\n\n        ret_macs = []\n        snmpobj = natlas_snmp(ip)\n\n        # find valid credentials for this node\n        if (snmpobj.get_cred(self.config.snmp_creds) == 0):\n            return None\n\n        system_name = util.shorten_host_name(snmpobj.get_val(OID_SYSNAME), self.config.host_domains)\n\n        # cache some common MIB trees\n        vlan_vbtbl      = snmpobj.get_bulk(OID_VLANS)\n        ifname_vbtbl    = snmpobj.get_bulk(OID_IFNAME)\n\n        for vlan_row in vlan_vbtbl:\n            for vlan_n, vlan_v in vlan_row:\n                # get VLAN ID from OID\n                vlan = natlas_snmp.get_last_oid_token(vlan_n)\n                if (vlan >= 1002):\n                    continue\n                vmacs = self.get_macs_for_vlan(ip, vlan, display_progress, snmpobj, system_name, ifname_vbtbl)\n                if (vmacs != None):\n                    ret_macs.extend(vmacs)\n\n        if (display_progress == 1):\n            print('')\n\n        return ret_macs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_macs_for_vlan(self, ip, vlan, display_progress=0, snmpobj=None, system_name=None, ifname_vbtbl=None):\n        '''\n        Return array of MAC addresses for a single VLAN from a single node at an IP\n        '''\n        ret_macs = []\n\n        if (snmpobj == None):\n            snmpobj = natlas_snmp(ip)\n            if (snmpobj.get_cred(self.config.snmp_creds) == 0):\n                return None\n        if (ifname_vbtbl == None):\n            ifname_vbtbl = snmpobj.get_bulk(OID_IFNAME)\n        if (system_name == None):\n            system_name = util.shorten_host_name(snmpobj.get_val(OID_SYSNAME), self.config.host_domains)\n\n        # change our SNMP credentials\n        old_cred = snmpobj.v2_community\n        snmpobj.v2_community = old_cred + '@' + str(vlan)\n\n        if (display_progress == 1):\n            sys.stdout.write(str(vlan)) # found VLAN\n            sys.stdout.flush()\n\n        # get CAM table for this VLAN\n        cam_vbtbl       = snmpobj.get_bulk(OID_VLAN_CAM)\n        portnum_vbtbl   = snmpobj.get_bulk(OID_BRIDGE_PORTNUMS)\n        ifindex_vbtbl   = snmpobj.get_bulk(OID_IFINDEX)\n        cam_match       = None\n\n        if (cam_vbtbl == None):\n            # error getting CAM for VLAN\n            return None\n\n        for cam_row in cam_vbtbl:\n            for cam_n, cam_v in cam_row:\n                cam_entry = natlas_mac.mac_format_ascii(cam_v, 0)\n\n                # find the interface index\n                p               = cam_n.getOid()\n                portnum_oid     = '%s.%i.%i.%i.%i.%i.%i' % (OID_BRIDGE_PORTNUMS, p[11], p[12], p[13], p[14], p[15], p[16])\n                bridge_portnum  = snmpobj.cache_lookup(portnum_vbtbl, portnum_oid)\n\n                # get the interface index and description\n                try:\n                    ifidx       = snmpobj.cache_lookup(ifindex_vbtbl, OID_IFINDEX + '.' + bridge_portnum)\n                    port        = snmpobj.cache_lookup(ifname_vbtbl, OID_IFNAME + '.' + ifidx)\n                except TypeError:\n                    port = 'None'\n\n                mac_addr = natlas_mac.mac_format_ascii(cam_v, 1)\n                \n                if (display_progress == 1):\n                    sys.stdout.write('.') # found CAM entry\n                    sys.stdout.flush()\n\n                entry = natlas_mac.mac_object(system_name, ip, vlan, mac_addr, port)\n                ret_macs.append(entry)\n\n        # restore SNMP credentials\n        snmpobj.v2_community = old_cred\n        return ret_macs", "response": "Get the MAC addresses for a single VLAN from a single node at an IP."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mac_hex_to_ascii(mac_hex, inc_dots):\n        '''\n        Format a hex MAC string to ASCII\n\n        Args:\n            mac_hex:    Value from SNMP\n            inc_dots:   1 to format as aabb.ccdd.eeff, 0 to format aabbccddeeff\n\n        Returns:\n            String representation of the mac_hex\n        '''\n        v = mac_hex[2:]\n        ret = ''\n        for i in range(0, len(v), 4):\n            ret += v[i:i+4]\n            if ((inc_dots) & ((i+4) < len(v))):\n                ret += '.'\n\n        return ret", "response": "Format a hex MAC string to ASCII"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_switch_macs(self, switch_ip=None, node=None, vlan=None, mac=None, port=None, verbose=0):\n        '''\n        Get the CAM table from a switch.\n\n        Args:\n            switch_ip           IP address of the device\n            node                natlas_node from new_node()\n            vlan                Filter results by VLAN\n            MAC                 Filter results by MAC address (regex)\n            port                Filter results by port (regex)\n            verbose             Display progress to stdout\n\n            switch_ip or node is required\n\n        Return:\n            Array of natlas_mac objects\n        '''\n        if (switch_ip == None):\n            if (node == None):\n                raise Exception('get_switch_macs() requires switch_ip or node parameter')\n                return None\n            switch_ip = node.get_ipaddr()\n\n        mac_obj = natlas_mac(self.config)\n\n        if (vlan == None):\n            # get all MACs\n            macs = mac_obj.get_macs(switch_ip, verbose)\n        else:\n            # get MACs only for one VLAN\n            macs = mac_obj.get_macs_for_vlan(switch_ip, vlan, verbose)\n\n        if ((mac == None) & (port == None)):\n            return macs if macs else []\n\n        # filter results\n        ret = []\n        for m in macs:\n            if (mac != None):\n                if (re.match(mac, m.mac) == None):\n                    continue\n            if (port != None):\n                if (re.match(port, m.port) == None):\n                    continue\n            ret.append(m)\n        return ret", "response": "Get the switch MACs from a switch."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_arp_table(self, switch_ip, ip=None, mac=None, interf=None, arp_type=None):\n        '''\n        Get the ARP table from a switch.\n\n        Args:\n            switch_ip           IP address of the device\n            ip                  Filter results by IP (regex)\n            mac                 Filter results by MAC (regex)\n            interf              Filter results by INTERFACE (regex)\n            arp_type            Filter results by ARP Type\n\n        Return:\n            Array of natlas_arp objects\n        '''\n        node = natlas_node(switch_ip)\n        if (node.try_snmp_creds(self.config.snmp_creds) == 0):\n            return []\n        arp = node.get_arp_table()\n        if (arp == None):\n            return []\n\n        if ((ip == None) & (mac == None) & (interf == None) & (arp_type == None)):\n            # no filtering\n            return arp\n\n        interf = str(interf) if vlan else None\n\n        # filter the result table\n        ret = []\n        for a in arp:\n            if (ip != None):\n                if (re.match(ip, a.ip) == None):\n                    continue\n            if (mac != None):\n                if (re.match(mac, a.mac) == None):\n                    continue\n            if (interf != None):\n                if (re.match(interf, str(a.interf)) == None):\n                    continue\n            if (arp_type != None):\n                if (re.match(arp_type, a.arp_type) == None):\n                    continue\n            ret.append(a)\n        return ret", "response": "Get the ARP table from a switch."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __get_node_text(self, diagram, node, fmt):\n        '''\n        Generate the node text given the format string 'fmt'\n        '''\n        fmt_proc = fmt\n\n        # IF blocks\n        while (1):\n            if_block = re.search('<%if ([^%]*): ([^%]*)%>', fmt_proc)\n            if (if_block == None):\n                break\n\n            # evaluate condition\n            if_cond = if_block[1]\n            if_val  = if_block[2]\n            if (self.__eval_if_block(if_cond, node) == 0):\n                if_val = ''\n            fmt_proc = fmt_proc[:if_block.span()[0]] + if_val + fmt_proc[if_block.span()[1]:]\n\n        # {node.ip} = best IP\n        ip = node.get_ipaddr()\n        fmt_proc = fmt_proc.replace('{node.ip}', ip)\n\n        # stackwise\n        stack_block = re.search('<%stack ([^%]*)%>', fmt_proc)\n        if (stack_block != None):\n            if (node.stack.count == 0):\n                # no stackwise, remove this\n                fmt_proc = fmt_proc[:stack_block.span()[0]] + fmt_proc[stack_block.span()[1]:]\n            else:\n                val = ''\n                if (self.config.diagram.expand_stackwise == 0):\n                    if (self.config.diagram.get_stack_members):\n                        for smem in node.stack.members:\n                            nval = stack_block[1]\n                            nval = nval.replace('{stack.num}',    str(smem.num))\n                            nval = nval.replace('{stack.plat}',   smem.plat)\n                            nval = nval.replace('{stack.serial}', smem.serial)\n                            nval = nval.replace('{stack.role}',   smem.role)\n                            val += nval\n                fmt_proc = fmt_proc[:stack_block.span()[0]] + val + fmt_proc[stack_block.span()[1]:]\n        \n        # loopbacks\n        loopback_block = re.search('<%loopback ([^%]*)%>', fmt_proc)\n        if (loopback_block != None):\n            val = ''\n            for lo in node.loopbacks:\n                for lo_ip in lo.ips:\n                    nval = loopback_block[1]\n                    nval = nval.replace('{lo.name}', lo.name)\n                    nval = nval.replace('{lo.ip}', lo_ip)\n                    val += nval\n            fmt_proc = fmt_proc[:loopback_block.span()[0]] + val + fmt_proc[loopback_block.span()[1]:]\n\n        # SVIs\n        svi_block = re.search('<%svi ([^%]*)%>', fmt_proc)\n        if (svi_block != None):\n            val = ''\n            for svi in node.svis:\n                for svi_ip in svi.ip:\n                    nval = svi_block[1]\n                    nval = nval.replace('{svi.vlan}', svi.vlan)\n                    nval = nval.replace('{svi.ip}', svi_ip)\n                    val += nval\n            fmt_proc = fmt_proc[:svi_block.span()[0]] + val + fmt_proc[svi_block.span()[1]:]\n\n        # replace {stack.} with magic\n        fmt_proc = re.sub('{stack\\.(([a-zA-Z])*)}', '$stack2354$\\g<1>$stack2354$', fmt_proc)\n        fmt_proc = re.sub('{vss\\.(([a-zA-Z])*)}', '$vss2354$\\g<1>$vss2354$', fmt_proc)\n\n        # {node.} variables\n        fmt_proc = fmt_proc.format(node=node)\n        \n        # replace magics\n        fmt_proc = re.sub('\\$stack2354\\$(([a-zA-Z])*)\\$stack2354\\$', '{stack.\\g<1>}', fmt_proc)\n        fmt_proc = re.sub('\\$vss2354\\$(([a-zA-Z])*)\\$vss2354\\$', '{vss.\\g<1>}', fmt_proc)\n\n        return fmt_proc", "response": "Generate the node text given the format string fmt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndiscovering the network starting at the defined root node IP. Recursively enumerate the network tree up to self.depth. Populates self.nodes[] as a list of discovered nodes in the network with self.root_node being the root. This function will discover the network with minimal information. It is enough to define the structure of the network but will not include much data on each node. Call discover_details() after this to update the self.nodes[] array with more info.", "response": "def discover(self, ip):\n        '''\n        Discover the network starting at the defined root node IP.\n        Recursively enumerate the network tree up to self.depth.\n        Populates self.nodes[] as a list of discovered nodes in the\n        network with self.root_node being the root.\n\n        This function will discover the network with minimal information.\n        It is enough to define the structure of the network but will not\n        include much data on each node.  Call discover_details() after this\n        to update the self.nodes[] array with more info.\n        '''\n\n        if (self.verbose > 0):\n            print('Discovery codes:\\n'                                      \\\n                  '    . depth             %s connection error\\n'           \\\n                  '    %s discovering node  %s numerating adjacencies\\n'    \\\n                  '    %s include node      %s leaf node\\n' %\n                  (DCODE_ERR_SNMP_STR,\n                   DCODE_DISCOVERED_STR, DCODE_STEP_INTO_STR,\n                   DCODE_INCLUDE_STR, DCODE_LEAF_STR)\n                )\n\n            print('Discovering network...')\n\n        # Start the process of querying this node and recursing adjacencies.\n        node, new_node = self.__query_node(ip, 'UNKNOWN')\n        self.root_node = node\n\n        if (node != None):\n            self.nodes.append(node)\n            self.__print_step(node.ip[0], node.name, 0, DCODE_ROOT|DCODE_DISCOVERED)\n            self.__discover_node(node, 0)\n        else:\n            return\n\n        # we may have missed chassis info\n        for n in self.nodes:\n            if ((n.serial == None) | (n.plat == None) | (n.ios == None)):\n                n.opts.get_chassis_info = True\n                if (n.serial == None):\n                    n.opts.get_serial   = True\n                if (n.ios == None):\n                    n.opts.get_ios      = True\n                if (n.plat == None):\n                    n.opts.get_plat     = True\n                n.query_node()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nenumerating the discovered nodes and update the array with additional info.", "response": "def discover_details(self):\n        '''\n        Enumerate the discovered nodes from discover() and update the\n        nodes in the array with additional info.\n        '''\n        if (self.root_node == None):\n            return\n\n        if (self.verbose > 0):\n            print('\\nCollecting node details...')\n\n        ni = 0\n        for n in self.nodes:\n            ni = ni + 1\n\n            indicator = '+'\n            if (n.snmpobj.success == 0):\n                indicator = '!'\n\n            if (self.verbose > 0):\n                sys.stdout.write('[%i/%i]%s %s (%s)' % (ni, len(self.nodes), indicator, n.name, n.snmpobj._ip))\n                sys.stdout.flush()\n\n            # set what details to discover for this node\n            n.opts.get_router        = True\n            n.opts.get_ospf_id       = True\n            n.opts.get_bgp_las       = True\n            n.opts.get_hsrp_pri      = True\n            n.opts.get_hsrp_vip      = True\n            n.opts.get_serial        = True \n            n.opts.get_stack         = True\n            n.opts.get_stack_details = self.config.diagram.get_stack_members\n            n.opts.get_vss           = True\n            n.opts.get_vss_details   = self.config.diagram.get_vss_members\n            n.opts.get_svi           = True\n            n.opts.get_lo            = True\n            n.opts.get_vpc           = True\n            n.opts.get_ios           = True\n            n.opts.get_plat          = True\n\n            start = timer()\n            n.query_node()\n            end = timer()\n            if (self.verbose > 0):\n                print(' %.2f sec' % (end - start))\n\n        # There is some back fill information we can populate now that\n        # we know all there is to know.\n        if (self.verbose > 0):\n            print('\\nBack filling node details...')\n\n        for n in self.nodes:\n            # Find and link VPC nodes together for easy reference later\n            if ((n.vpc_domain != None) & (n.vpc_peerlink_node == None)):\n                for link in n.links:\n                    if ((link.local_port == n.vpc_peerlink_if) | (link.local_lag == n.vpc_peerlink_if)):\n                        n.vpc_peerlink_node         = link.node\n                        link.node.vpc_peerlink_node = n\n                        break"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nqueries this node. Return node details and if we already knew about it or if this is a new node. Don't save the node to the known list, just return info about it. Args: ip: IP Address of the node. host: Hostname of this known (if known from CDP/LLDP) Returns: natlas_node: Node of this object int: NODE_NEW = Newly discovered node NODE_NEWIP = Already knew about this node but not by this IP NODE_KNOWN = Already knew about this node", "response": "def __query_node(self, ip, host):\n        '''\n        Query this node.\n        Return node details and if we already knew about it or if this is a new node.\n        Don't save the node to the known list, just return info about it.\n\n        Args:\n            ip:                 IP Address of the node.\n            host:               Hostname of this known (if known from CDP/LLDP)\n\n        Returns:\n            natlas_node:        Node of this object\n            int:                NODE_NEW   = Newly discovered node\n                                NODE_NEWIP = Already knew about this node but not by this IP\n                                NODE_KNOWN = Already knew about this node\n        '''\n        host = util.shorten_host_name(host, self.config.host_domains)\n        node, node_updated = self.__get_known_node(ip, host)\n\n        if (node == None):\n            # new node\n            node        = natlas_node()\n            node.name   = host\n            node.ip     = [ip]\n            state       = NODE_NEW\n        else:\n            # existing node\n            if (node.snmpobj.success == 1):\n                # we already queried this node successfully - return it\n                return (node, NODE_KNOWN)\n            # existing node but we couldn't connect before\n            if (node_updated == 1):\n                state = NODE_NEWIP\n            else:\n                state = NODE_KNOWN\n            node.name = host\n\n        if (ip == 'UNKNOWN'):\n            return (node, state)\n\n        # vmware ESX reports the IP as 0.0.0.0\n        # LLDP can return an empty string for IPs.\n        if ((ip == '0.0.0.0') | (ip == '')):\n            return (node, state)\n\n        # find valid credentials for this node\n        if (node.try_snmp_creds(self.config.snmp_creds) == 0):\n            return (node, state)\n\n        node.name = node.get_system_name(self.config.host_domains)\n        if (node.name != host):\n            # the hostname changed (cdp/lldp vs snmp)!\n            # double check we don't already know about this node\n            if (state == NODE_NEW):\n                node2, node_updated2 = self.__get_known_node(ip, host)\n                if ((node2 != None) & (node_updated2 == 0)):\n                    return (node, NODE_KNOWN)\n                if (node_updated2 == 1):\n                    state = NODE_NEWIP\n\n        # Finally, if we still don't have a name, use the IP.\n        # e.g. Maybe CDP/LLDP was empty and we dont have good credentials\n        # for this device.  A blank name can break Dot.\n        if ((node.name == None) | (node.name == '')):\n            node.name = node.get_ipaddr()\n\n        node.opts.get_serial = True     # CDP/LLDP does not report, need for extended ACL\n        node.query_node()\n        return (node, state)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __get_known_node(self, ip, host):\n        '''\n        Look for known nodes by IP and HOST.\n        If found by HOST, add the IP if not already known.\n\n        Return:\n            node:       Node, if found. Otherwise None.\n            updated:    1=updated, 0=not updated\n        '''\n        # already known by IP ?\n        for ex in self.nodes:\n            for exip in ex.ip:\n                if (exip == '0.0.0.0'):\n                    continue\n                if (exip == ip):\n                    return (ex, 0)\n\n        # already known by HOST ?\n        node = self.__get_known_node_by_host(host)\n        if (node != None):\n            # node already known\n            if (ip not in node.ip):\n                node.ip.append(ip)\n                return (node, 1)\n            return (node, 0)\n\n        return (None, 0)", "response": "Look for known nodes by IP and HOST."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __discover_node(self, node, depth):\n        '''\n        Given a node, recursively enumerate its adjacencies\n        until we reach the specified depth (>0).\n\n        Args:\n            node:   natlas_node object to enumerate.\n            depth:  The depth left that we can go further away from the root.\n        '''\n        if (node == None):\n            return\n\n        if (depth >= self.max_depth):\n            return\n\n        if (node.discovered > 0):\n            return\n        node.discovered = 1\n\n        # vmware ESX can report IP as 0.0.0.0\n        # If we are allowing 0.0.0.0/32 in the config,\n        # then we added it as a leaf, but don't discover it\n        if (node.ip[0] == '0.0.0.0'):\n            return\n\n        # may be a leaf we couldn't connect to previously\n        if (node.snmpobj.success == 0):\n            return\n\n        # print some info to stdout\n        dcodes = DCODE_STEP_INTO\n        if (depth == 0):\n            dcodes |= DCODE_ROOT\n        self.__print_step(node.ip[0], node.name, depth, dcodes)\n\n        # get the cached snmp credentials\n        snmpobj = node.snmpobj\n\n        # list of valid neighbors to discover next\n        valid_neighbors = []\n\n        # get list of neighbors\n        cdp_neighbors  = node.get_cdp_neighbors()\n        lldp_neighbors = node.get_lldp_neighbors()\n        neighbors      = cdp_neighbors + lldp_neighbors\n        if (len(neighbors) == 0):\n            return\n\n        for n in neighbors:\n            # some neighbors may not advertise IP addresses - default them to 0.0.0.0\n            if (n.remote_ip == None):\n                n.remote_ip = '0.0.0.0'\n\n            # check the ACL\n            acl_action = self.__match_node_acl(n.remote_ip, n.remote_name)\n            if (acl_action == 'deny'):\n                # deny inclusion of this node\n                continue\n            \n            dcodes = DCODE_DISCOVERED\n            child = None\n            if (acl_action == 'include'):\n                # include this node but do not discover it\n                child    = natlas_node()\n                child.ip = [n.remote_ip]\n                dcodes  |= DCODE_INCLUDE\n            else:\n                # discover this node\n                child, query_result = self.__query_node(n.remote_ip, n.remote_name)\n\n            # if we couldn't pull info from SNMP fill in what we know\n            if (child.snmpobj.success == 0):\n                child.name = util.shorten_host_name(n.remote_name, self.config.host_domains)\n                dcodes  |= DCODE_ERR_SNMP\n            \n            # need to check the ACL again for extended ops (we have more info)\n            acl_action = self.__match_node_acl(n.remote_ip, n.remote_name, n.remote_plat, n.remote_ios, child.serial)\n            if (acl_action == 'deny'):\n                continue\n\n            if (query_result == NODE_NEW):\n                self.nodes.append(child)\n                if (acl_action == 'leaf'):          dcodes |= DCODE_LEAF\n                if (n.discovered_proto == 'cdp'):   dcodes |= DCODE_CDP\n                if (n.discovered_proto == 'lldp'):  dcodes |= DCODE_LLDP\n                self.__print_step(n.remote_ip, n.remote_name, depth+1, dcodes)\n\n            # CDP/LLDP advertises the platform\n            child.plat = n.remote_plat\n            child.ios  = n.remote_ios\n            \n            # add the discovered node to the link object and link to the parent\n            n.node = child\n            self.__add_link(node, n)\n\n            # if we need to discover this node then add it to the list\n            if ((query_result == NODE_NEW) & (acl_action != 'leaf') & (acl_action != 'include')):\n                valid_neighbors.append(child)\n\n        # discover the valid neighbors\n        for n in valid_neighbors:\n            self.__discover_node(n, depth+1)", "response": "Given a node enumerate its adjacencies and return the entry for that node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __get_known_node_by_host(self, hostname):\n        '''\n        Determine if the node is already known by hostname.\n        If it is, return it.\n        '''\n        for n in self.nodes:\n            if (n.name == hostname):\n                return n\n        return None", "response": "Determine if the node is already known by hostname."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_file_and_add_volume(self,\n                                   runtime,          # type: List[Text]\n                                   volume,           # type: MapperEnt\n                                   host_outdir_tgt,  # type: Optional[Text]\n                                   secret_store,     # type: Optional[SecretStore]\n                                   tmpdir_prefix     # type: Text\n                                   ):  # type: (...) -> Text\n        \"\"\"Create the file and add a mapping.\"\"\"\n        if not host_outdir_tgt:\n            tmp_dir, tmp_prefix = os.path.split(tmpdir_prefix)\n            new_file = os.path.join(\n                tempfile.mkdtemp(prefix=tmp_prefix, dir=tmp_dir),\n                os.path.basename(volume.resolved))\n        writable = True if volume.type == \"CreateWritableFile\" else False\n        if secret_store:\n            contents = secret_store.retrieve(volume.resolved)\n        else:\n            contents = volume.resolved\n        dirname = os.path.dirname(host_outdir_tgt or new_file)\n        if not os.path.exists(dirname):\n            os.makedirs(dirname)\n        with open(host_outdir_tgt or new_file, \"wb\") as file_literal:\n            file_literal.write(contents.encode(\"utf-8\"))\n        if not host_outdir_tgt:\n            self.append_volume(runtime, new_file, volume.target,\n                               writable=writable)\n        if writable:\n            ensure_writable(host_outdir_tgt or new_file)\n        else:\n            ensure_non_writable(host_outdir_tgt or new_file)\n        return host_outdir_tgt or new_file", "response": "Create the file and add a mapping."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_volumes(self,\n                    pathmapper,          # type: PathMapper\n                    runtime,             # type: List[Text]\n                    tmpdir_prefix,       # type: Text\n                    secret_store=None,   # type: Optional[SecretStore]\n                    any_path_okay=False  # type: bool\n                    ):  # type: (...) -> None\n        \"\"\"Append volume mappings to the runtime option list.\"\"\"\n\n        container_outdir = self.builder.outdir\n        for key, vol in (itm for itm in pathmapper.items() if itm[1].staged):\n            host_outdir_tgt = None  # type: Optional[Text]\n            if vol.target.startswith(container_outdir + \"/\"):\n                host_outdir_tgt = os.path.join(\n                    self.outdir, vol.target[len(container_outdir) + 1:])\n            if not host_outdir_tgt and not any_path_okay:\n                raise WorkflowException(\n                    \"No mandatory DockerRequirement, yet path is outside \"\n                    \"the designated output directory, also know as \"\n                    \"$(runtime.outdir): {}\".format(vol))\n            if vol.type in (\"File\", \"Directory\"):\n                self.add_file_or_directory_volume(\n                    runtime, vol, host_outdir_tgt)\n            elif vol.type == \"WritableFile\":\n                self.add_writable_file_volume(\n                    runtime, vol, host_outdir_tgt, tmpdir_prefix)\n            elif vol.type == \"WritableDirectory\":\n                self.add_writable_directory_volume(\n                    runtime, vol, host_outdir_tgt, tmpdir_prefix)\n            elif vol.type in [\"CreateFile\", \"CreateWritableFile\"]:\n                new_path = self.create_file_and_add_volume(\n                    runtime, vol, host_outdir_tgt, secret_store, tmpdir_prefix)\n                pathmapper.update(\n                    key, new_path, vol.target, vol.type, vol.staged)", "response": "Adds the volumes to the list of volumes in the specified container."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef docker_monitor(self, cidfile, tmpdir_prefix, cleanup_cidfile, process):\n        # type: (Text, Text, bool, subprocess.Popen) -> None\n        \"\"\"Record memory usage of the running Docker container.\"\"\"\n        # Todo: consider switching to `docker create` / `docker start`\n        # instead of `docker run` as `docker create` outputs the container ID\n        # to stdout, but the container is frozen, thus allowing us to start the\n        # monitoring process without dealing with the cidfile or too-fast\n        # container execution\n        cid = None\n        while cid is None:\n            time.sleep(1)\n            if process.returncode is not None:\n                if cleanup_cidfile:\n                    os.remove(cidfile)\n                return\n            try:\n                with open(cidfile) as cidhandle:\n                    cid = cidhandle.readline().strip()\n            except (OSError, IOError):\n                cid = None\n        max_mem = self.docker_get_memory(cid)\n        tmp_dir, tmp_prefix = os.path.split(tmpdir_prefix)\n        stats_file = tempfile.NamedTemporaryFile(prefix=tmp_prefix, dir=tmp_dir)\n        with open(stats_file.name, mode=\"w\") as stats_file_handle:\n            stats_proc = subprocess.Popen(\n                ['docker', 'stats', '--no-trunc', '--format', '{{.MemPerc}}',\n                 cid], stdout=stats_file_handle, stderr=subprocess.DEVNULL)\n            process.wait()\n            stats_proc.kill()\n        max_mem_percent = 0\n        with open(stats_file.name, mode=\"r\") as stats:\n            for line in stats:\n                try:\n                    mem_percent = float(re.sub(\n                        CONTROL_CODE_RE, '', line).replace('%', ''))\n                    if mem_percent > max_mem_percent:\n                        max_mem_percent = mem_percent\n                except ValueError:\n                    break\n        _logger.info(u\"[job %s] Max memory used: %iMiB\", self.name,\n                     int((max_mem_percent * max_mem) / (2 ** 20)))\n        if cleanup_cidfile:\n            os.remove(cidfile)", "response": "Monitor the memory usage of the running Docker container."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying a mapping function to each File path in the object rec.", "response": "def adjustFiles(rec, op):  # type: (Any, Union[Callable[..., Any], partial[Any]]) -> None\n    \"\"\"Apply a mapping function to each File path in the object `rec`.\"\"\"\n\n    if isinstance(rec, MutableMapping):\n        if rec.get(\"class\") == \"File\":\n            rec[\"path\"] = op(rec[\"path\"])\n        for d in rec:\n            adjustFiles(rec[d], op)\n    if isinstance(rec, MutableSequence):\n        for d in rec:\n            adjustFiles(d, op)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the source and sink types are pass warning or exception.", "response": "def check_types(srctype, sinktype, linkMerge, valueFrom):\n    # type: (Any, Any, Optional[Text], Optional[Text]) -> Text\n    \"\"\"Check if the source and sink types are \"pass\", \"warning\", or \"exception\".\n    \"\"\"\n\n    if valueFrom is not None:\n        return \"pass\"\n    if linkMerge is None:\n        if can_assign_src_to_sink(srctype, sinktype, strict=True):\n            return \"pass\"\n        if can_assign_src_to_sink(srctype, sinktype, strict=False):\n            return \"warning\"\n        return \"exception\"\n    if linkMerge == \"merge_nested\":\n        return check_types({\"items\": _get_type(srctype), \"type\": \"array\"},\n                           _get_type(sinktype), None, None)\n    if linkMerge == \"merge_flattened\":\n        return check_types(merge_flatten_type(_get_type(srctype)), _get_type(sinktype), None, None)\n    raise WorkflowException(u\"Unrecognized linkMerge enum '{}'\".format(linkMerge))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge_flatten_type(src):\n    # type: (Any) -> Any\n    \"\"\"Return the merge flattened type of the source type\n    \"\"\"\n\n    if isinstance(src, MutableSequence):\n        return [merge_flatten_type(t) for t in src]\n    if isinstance(src, MutableMapping) and src.get(\"type\") == \"array\":\n        return src\n    return {\"items\": src, \"type\": \"array\"}", "response": "Return the merge flattened type of the source type\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if source and sink are identical.", "response": "def can_assign_src_to_sink(src, sink, strict=False):  # type: (Any, Any, bool) -> bool\n    \"\"\"Check for identical type specifications, ignoring extra keys like inputBinding.\n\n    src: admissible source types\n    sink: admissible sink types\n\n    In non-strict comparison, at least one source type must match one sink type.\n    In strict comparison, all source types must match at least one sink type.\n    \"\"\"\n\n    if src == \"Any\" or sink == \"Any\":\n        return True\n    if isinstance(src, MutableMapping) and isinstance(sink, MutableMapping):\n        if sink.get(\"not_connected\") and strict:\n            return False\n        if src[\"type\"] == \"array\" and sink[\"type\"] == \"array\":\n            return can_assign_src_to_sink(src[\"items\"], sink[\"items\"], strict)\n        if src[\"type\"] == \"record\" and sink[\"type\"] == \"record\":\n            return _compare_records(src, sink, strict)\n        if src[\"type\"] == \"File\" and sink[\"type\"] == \"File\":\n            for sinksf in sink.get(\"secondaryFiles\", []):\n                if not [1 for srcsf in src.get(\"secondaryFiles\", []) if sinksf == srcsf]:\n                    if strict:\n                        return False\n            return True\n        return can_assign_src_to_sink(src[\"type\"], sink[\"type\"], strict)\n    if isinstance(src, MutableSequence):\n        if strict:\n            for this_src in src:\n                if not can_assign_src_to_sink(this_src, sink):\n                    return False\n            return True\n        for this_src in src:\n            if can_assign_src_to_sink(this_src, sink):\n                return True\n        return False\n    if isinstance(sink, MutableSequence):\n        for this_sink in sink:\n            if can_assign_src_to_sink(src, this_sink):\n                return True\n        return False\n    return src == sink"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompare two records, ensuring they have compatible fields. This handles normalizing record names, which will be relative to workflow step, so that they can be compared.", "response": "def _compare_records(src, sink, strict=False):\n    # type: (MutableMapping[Text, Any], MutableMapping[Text, Any], bool) -> bool\n    \"\"\"Compare two records, ensuring they have compatible fields.\n\n    This handles normalizing record names, which will be relative to workflow\n    step, so that they can be compared.\n    \"\"\"\n\n    def _rec_fields(rec):  # type: (MutableMapping[Text, Any]) -> MutableMapping[Text, Any]\n        out = {}\n        for field in rec[\"fields\"]:\n            name = shortname(field[\"name\"])\n            out[name] = field[\"type\"]\n        return out\n\n    srcfields = _rec_fields(src)\n    sinkfields = _rec_fields(sink)\n    for key in six.iterkeys(sinkfields):\n        if (not can_assign_src_to_sink(\n                srcfields.get(key, \"null\"), sinkfields.get(key, \"null\"), strict)\n                and sinkfields.get(key) is not None):\n            _logger.info(\"Record comparison failure for %s and %s\\n\"\n                         \"Did not match fields for %s: %s and %s\",\n                         src[\"name\"], sink[\"name\"], key, srcfields.get(key),\n                         sinkfields.get(key))\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if all source and sink types of a workflow are compatible before run time.", "response": "def static_checker(workflow_inputs, workflow_outputs, step_inputs, step_outputs, param_to_step):\n    # type: (List[Dict[Text, Any]], List[Dict[Text, Any]], List[Dict[Text, Any]], List[Dict[Text, Any]], Dict[Text, Dict[Text, Any]]) -> None\n    \"\"\"Check if all source and sink types of a workflow are compatible before run time.\n    \"\"\"\n\n    # source parameters: workflow_inputs and step_outputs\n    # sink parameters: step_inputs and workflow_outputs\n\n    # make a dictionary of source parameters, indexed by the \"id\" field\n    src_parms = workflow_inputs + step_outputs\n    src_dict = {}\n    for parm in src_parms:\n        src_dict[parm[\"id\"]] = parm\n\n    step_inputs_val = check_all_types(src_dict, step_inputs, \"source\")\n    workflow_outputs_val = check_all_types(src_dict, workflow_outputs, \"outputSource\")\n\n    warnings = step_inputs_val[\"warning\"] + workflow_outputs_val[\"warning\"]\n    exceptions = step_inputs_val[\"exception\"] + workflow_outputs_val[\"exception\"]\n\n    warning_msgs = []\n    exception_msgs = []\n    for warning in warnings:\n        src = warning.src\n        sink = warning.sink\n        linkMerge = warning.linkMerge\n        sinksf = sorted([p[\"pattern\"] for p in sink.get(\"secondaryFiles\", []) if p.get(\"required\", True)])\n        srcsf = sorted([p[\"pattern\"] for p in src.get(\"secondaryFiles\", [])])\n        # Every secondaryFile required by the sink, should be declared\n        # by the source\n        missing = missing_subset(srcsf, sinksf)\n        if missing:\n            msg1 = \"Parameter '%s' requires secondaryFiles %s but\" % (shortname(sink[\"id\"]), missing)\n            msg3 = SourceLine(src, \"id\").makeError(\n                \"source '%s' does not provide those secondaryFiles.\" % (shortname(src[\"id\"])))\n            msg4 = SourceLine(src.get(\"_tool_entry\", src), \"secondaryFiles\").makeError(\"To resolve, add missing secondaryFiles patterns to definition of '%s' or\" % (shortname(src[\"id\"])))\n            msg5 = SourceLine(sink.get(\"_tool_entry\", sink), \"secondaryFiles\").makeError(\"mark missing secondaryFiles in definition of '%s' as optional.\" % shortname(sink[\"id\"]))\n            msg = SourceLine(sink).makeError(\"%s\\n%s\" % (msg1, bullets([msg3, msg4, msg5], \"  \")))\n        elif sink.get(\"not_connected\"):\n            msg = SourceLine(sink, \"type\").makeError(\n                \"'%s' is not an input parameter of %s, expected %s\"\n                % (shortname(sink[\"id\"]), param_to_step[sink[\"id\"]][\"run\"],\n                   \", \".join(shortname(s[\"id\"])\n                             for s in param_to_step[sink[\"id\"]][\"inputs\"]\n                             if not s.get(\"not_connected\"))))\n        else:\n            msg = SourceLine(src, \"type\").makeError(\n                \"Source '%s' of type %s may be incompatible\"\n                % (shortname(src[\"id\"]), json_dumps(src[\"type\"]))) + \"\\n\" + \\\n                SourceLine(sink, \"type\").makeError(\n                    \"  with sink '%s' of type %s\"\n                    % (shortname(sink[\"id\"]), json_dumps(sink[\"type\"])))\n            if linkMerge is not None:\n                msg += \"\\n\" + SourceLine(sink).makeError(\"  source has linkMerge method %s\" % linkMerge)\n\n        warning_msgs.append(msg)\n    for exception in exceptions:\n        src = exception.src\n        sink = exception.sink\n        linkMerge = exception.linkMerge\n        msg = SourceLine(src, \"type\").makeError(\n            \"Source '%s' of type %s is incompatible\"\n            % (shortname(src[\"id\"]), json_dumps(src[\"type\"]))) + \"\\n\" + \\\n            SourceLine(sink, \"type\").makeError(\n                \"  with sink '%s' of type %s\"\n                % (shortname(sink[\"id\"]), json_dumps(sink[\"type\"])))\n        if linkMerge is not None:\n            msg += \"\\n\" + SourceLine(sink).makeError(\"  source has linkMerge method %s\" % linkMerge)\n        exception_msgs.append(msg)\n\n    for sink in step_inputs:\n        if ('null' != sink[\"type\"] and 'null' not in sink[\"type\"]\n                and \"source\" not in sink and \"default\" not in sink and \"valueFrom\" not in sink):\n            msg = SourceLine(sink).makeError(\n                \"Required parameter '%s' does not have source, default, or valueFrom expression\"\n                % shortname(sink[\"id\"]))\n            exception_msgs.append(msg)\n\n    all_warning_msg = strip_dup_lineno(\"\\n\".join(warning_msgs))\n    all_exception_msg = strip_dup_lineno(\"\\n\".join(exception_msgs))\n\n    if warnings:\n        _logger.warning(\"Workflow checker warning:\\n%s\", all_warning_msg)\n    if exceptions:\n        raise validate.ValidationException(all_exception_msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_all_types(src_dict, sinks, sourceField):\n    # type: (Dict[Text, Any], List[Dict[Text, Any]], Text) -> Dict[Text, List[SrcSink]]\n    # sourceField is either \"soure\" or \"outputSource\"\n    \"\"\"Given a list of sinks, check if their types match with the types of their sources.\n    \"\"\"\n\n    validation = {\"warning\": [], \"exception\": []}  # type: Dict[Text, List[SrcSink]]\n    for sink in sinks:\n        if sourceField in sink:\n            valueFrom = sink.get(\"valueFrom\")\n            if isinstance(sink[sourceField], MutableSequence):\n                srcs_of_sink = [src_dict[parm_id] for parm_id in sink[sourceField]]\n                linkMerge = sink.get(\"linkMerge\", (\"merge_nested\"\n                                                   if len(sink[sourceField]) > 1 else None))\n            else:\n                parm_id = sink[sourceField]\n                srcs_of_sink = [src_dict[parm_id]]\n                linkMerge = None\n            for src in srcs_of_sink:\n                check_result = check_types(src, sink, linkMerge, valueFrom)\n                if check_result == \"warning\":\n                    validation[\"warning\"].append(SrcSink(src, sink, linkMerge))\n                elif check_result == \"exception\":\n                    validation[\"exception\"].append(SrcSink(src, sink, linkMerge))\n    return validation", "response": "Given a list of sinks check if their types match with the types of their sources."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef output_callback(self, out, process_status):\n        self.final_status.append(process_status)\n        self.final_output.append(out)", "response": "Collect the final status and outputs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nselect resources from the requested cpu cores and memory.", "response": "def select_resources(self, request, runtime_context):  # pylint: disable=unused-argument\n        # type: (Dict[str, int], RuntimeContext) -> Dict[str, int]\n        \"\"\" Na\u00efve check for available cpu cores and memory. \"\"\"\n        result = {}  # type: Dict[str, int]\n        maxrsc = {\n            \"cores\": self.max_cores,\n            \"ram\": self.max_ram\n        }\n        for rsc in (\"cores\", \"ram\"):\n            if request[rsc+\"Min\"] > maxrsc[rsc]:\n                raise WorkflowException(\n                    \"Requested at least %d %s but only %d available\" %\n                    (request[rsc+\"Min\"], rsc, maxrsc[rsc]))\n            if request[rsc+\"Max\"] < maxrsc[rsc]:\n                result[rsc] = request[rsc+\"Max\"]\n            else:\n                result[rsc] = maxrsc[rsc]\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _runner(self, job, runtime_context):\n        try:\n            job.run(runtime_context)\n        except WorkflowException as err:\n            _logger.exception(\"Got workflow error\")\n            self.exceptions.append(err)\n        except Exception as err:  # pylint: disable=broad-except\n            _logger.exception(\"Got workflow error\")\n            self.exceptions.append(WorkflowException(Text(err)))\n        finally:\n            with runtime_context.workflow_eval_lock:\n                self.threads.remove(threading.current_thread())\n                if isinstance(job, JobBase):\n                    self.allocated_ram -= job.builder.resources[\"ram\"]\n                    self.allocated_cores -= job.builder.resources[\"cores\"]\n                runtime_context.workflow_eval_lock.notifyAll()", "response": "Runs the job in a thread."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute a single job in a seperate thread.", "response": "def run_job(self,\n                job,             # type: Union[JobBase, WorkflowJob, None]\n                runtime_context  # type: RuntimeContext\n               ):  # type: (...) -> None\n        \"\"\" Execute a single Job in a seperate thread. \"\"\"\n\n        if job is not None:\n            with self.pending_jobs_lock:\n                self.pending_jobs.append(job)\n\n        with self.pending_jobs_lock:\n            n = 0\n            while (n+1) <= len(self.pending_jobs):\n                job = self.pending_jobs[n]\n                if isinstance(job, JobBase):\n                    if ((job.builder.resources[\"ram\"])\n                        > self.max_ram\n                        or (job.builder.resources[\"cores\"])\n                        > self.max_cores):\n                        _logger.error(\n                            'Job \"%s\" cannot be run, requests more resources (%s) '\n                            'than available on this host (max ram %d, max cores %d',\n                            job.name, job.builder.resources,\n                            self.allocated_ram,\n                            self.allocated_cores,\n                            self.max_ram,\n                            self.max_cores)\n                        self.pending_jobs.remove(job)\n                        return\n\n                    if ((self.allocated_ram + job.builder.resources[\"ram\"])\n                        > self.max_ram\n                        or (self.allocated_cores + job.builder.resources[\"cores\"])\n                        > self.max_cores):\n                        _logger.debug(\n                            'Job \"%s\" cannot run yet, resources (%s) are not '\n                            'available (already allocated ram is %d, allocated cores is %d, '\n                            'max ram %d, max cores %d',\n                            job.name, job.builder.resources,\n                            self.allocated_ram,\n                            self.allocated_cores,\n                            self.max_ram,\n                            self.max_cores)\n                        n += 1\n                        continue\n\n                thread = threading.Thread(target=self._runner, args=(job, runtime_context))\n                thread.daemon = True\n                self.threads.add(thread)\n                if isinstance(job, JobBase):\n                    self.allocated_ram += job.builder.resources[\"ram\"]\n                    self.allocated_cores += job.builder.resources[\"cores\"]\n                thread.start()\n                self.pending_jobs.remove(job)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_for_next_completion(self, runtime_context):\n        # type: (RuntimeContext) -> None\n        \"\"\" Wait for jobs to finish. \"\"\"\n        if runtime_context.workflow_eval_lock is not None:\n            runtime_context.workflow_eval_lock.wait()\n        if self.exceptions:\n            raise self.exceptions[0]", "response": "Wait for all jobs to finish."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_image(docker_requirement,     # type: Dict[Text, Text]\n                  pull_image,             # type: bool\n                  force_pull=False,       # type: bool\n                  tmp_outdir_prefix=DEFAULT_TMP_PREFIX  # type: Text\n                 ):  # type: (...) -> bool\n        \"\"\"\n        Retrieve the relevant Docker container image.\n\n        Returns True upon success\n        \"\"\"\n        found = False\n\n        if \"dockerImageId\" not in docker_requirement \\\n                and \"dockerPull\" in docker_requirement:\n            docker_requirement[\"dockerImageId\"] = docker_requirement[\"dockerPull\"]\n\n        with _IMAGES_LOCK:\n            if docker_requirement[\"dockerImageId\"] in _IMAGES:\n                return True\n\n        for line in subprocess.check_output(\n                [\"docker\", \"images\", \"--no-trunc\", \"--all\"]).decode('utf-8').splitlines():\n            try:\n                match = re.match(r\"^([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\", line)\n                split = docker_requirement[\"dockerImageId\"].split(\":\")\n                if len(split) == 1:\n                    split.append(\"latest\")\n                elif len(split) == 2:\n                    #  if split[1] doesn't  match valid tag names, it is a part of repository\n                    if not re.match(r'[\\w][\\w.-]{0,127}', split[1]):\n                        split[0] = split[0] + \":\" + split[1]\n                        split[1] = \"latest\"\n                elif len(split) == 3:\n                    if re.match(r'[\\w][\\w.-]{0,127}', split[2]):\n                        split[0] = split[0] + \":\" + split[1]\n                        split[1] = split[2]\n                        del split[2]\n\n                # check for repository:tag match or image id match\n                if (match\n                        and (\n                            (split[0] == match.group(1) and split[1] == match.group(2))\n                            or docker_requirement[\"dockerImageId\"] == match.group(3))):\n                    found = True\n                    break\n            except ValueError:\n                pass\n\n        if (force_pull or not found) and pull_image:\n            cmd = []  # type: List[Text]\n            if \"dockerPull\" in docker_requirement:\n                cmd = [\"docker\", \"pull\", str(docker_requirement[\"dockerPull\"])]\n                _logger.info(Text(cmd))\n                subprocess.check_call(cmd, stdout=sys.stderr)\n                found = True\n            elif \"dockerFile\" in docker_requirement:\n                dockerfile_dir = str(tempfile.mkdtemp(prefix=tmp_outdir_prefix))\n                with open(os.path.join(\n                        dockerfile_dir, \"Dockerfile\"), \"wb\") as dfile:\n                    dfile.write(docker_requirement[\"dockerFile\"].encode('utf-8'))\n                cmd = [\"docker\", \"build\", \"--tag=%s\" %\n                       str(docker_requirement[\"dockerImageId\"]), dockerfile_dir]\n                _logger.info(Text(cmd))\n                subprocess.check_call(cmd, stdout=sys.stderr)\n                found = True\n            elif \"dockerLoad\" in docker_requirement:\n                cmd = [\"docker\", \"load\"]\n                _logger.info(Text(cmd))\n                if os.path.exists(docker_requirement[\"dockerLoad\"]):\n                    _logger.info(u\"Loading docker image from %s\", docker_requirement[\"dockerLoad\"])\n                    with open(docker_requirement[\"dockerLoad\"], \"rb\") as dload:\n                        loadproc = subprocess.Popen(cmd, stdin=dload, stdout=sys.stderr)\n                else:\n                    loadproc = subprocess.Popen(cmd, stdin=subprocess.PIPE,\n                                                stdout=sys.stderr)\n                    assert loadproc.stdin is not None  # nosec\n                    _logger.info(u\"Sending GET request to %s\", docker_requirement[\"dockerLoad\"])\n                    req = requests.get(docker_requirement[\"dockerLoad\"], stream=True)\n                    size = 0\n                    for chunk in req.iter_content(1024 * 1024):\n                        size += len(chunk)\n                        _logger.info(\"\\r%i bytes\", size)\n                        loadproc.stdin.write(chunk)\n                    loadproc.stdin.close()\n                rcode = loadproc.wait()\n                if rcode != 0:\n                    raise WorkflowException(\n                        \"Docker load returned non-zero exit status %i\" % (rcode))\n                found = True\n            elif \"dockerImport\" in docker_requirement:\n                cmd = [\"docker\", \"import\", str(docker_requirement[\"dockerImport\"]),\n                       str(docker_requirement[\"dockerImageId\"])]\n                _logger.info(Text(cmd))\n                subprocess.check_call(cmd, stdout=sys.stderr)\n                found = True\n\n        if found:\n            with _IMAGES_LOCK:\n                _IMAGES.add(docker_requirement[\"dockerImageId\"])\n\n        return found", "response": "Get the relevant Docker container image."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append_volume(runtime, source, target, writable=False):\n        # type: (List[Text], Text, Text, bool) -> None\n        \"\"\"Add binding arguments to the runtime list.\"\"\"\n        runtime.append(u\"--volume={}:{}:{}\".format(\n            docker_windows_path_adjust(source), target,\n            \"rw\" if writable else \"ro\"))", "response": "Adds the binding arguments to the runtime list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_file_or_directory_volume(self,\n                                     runtime,         # type: List[Text]\n                                     volume,          # type: MapperEnt\n                                     host_outdir_tgt  # type: Optional[Text]\n                                     ):  # type: (...) -> None\n        \"\"\"Append volume a file/dir mapping to the runtime option list.\"\"\"\n        if not volume.resolved.startswith(\"_:\"):\n            _check_docker_machine_path(docker_windows_path_adjust(\n                volume.resolved))\n            self.append_volume(runtime, volume.resolved, volume.target)", "response": "Append a file or directory volume to the runtime option list."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends a writable file mapping to the runtime option list.", "response": "def add_writable_file_volume(self,\n                                 runtime,          # type: List[Text]\n                                 volume,           # type: MapperEnt\n                                 host_outdir_tgt,  # type: Optional[Text]\n                                 tmpdir_prefix     # type: Text\n                                ):  # type: (...) -> None\n        \"\"\"Append a writable file mapping to the runtime option list.\"\"\"\n        if self.inplace_update:\n            self.append_volume(runtime, volume.resolved, volume.target,\n                               writable=True)\n        else:\n            if host_outdir_tgt:\n                # shortcut, just copy to the output directory\n                # which is already going to be mounted\n                if not os.path.exists(os.path.dirname(host_outdir_tgt)):\n                    os.makedirs(os.path.dirname(host_outdir_tgt))\n                shutil.copy(volume.resolved, host_outdir_tgt)\n            else:\n                tmp_dir, tmp_prefix = os.path.split(tmpdir_prefix)\n                tmpdir = tempfile.mkdtemp(prefix=tmp_prefix, dir=tmp_dir)\n                file_copy = os.path.join(\n                    tmpdir, os.path.basename(volume.resolved))\n                shutil.copy(volume.resolved, file_copy)\n                self.append_volume(runtime, file_copy, volume.target,\n                                   writable=True)\n            ensure_writable(host_outdir_tgt or file_copy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nappend a writable directory mapping to the runtime option list.", "response": "def add_writable_directory_volume(self,\n                                      runtime,          # type: List[Text]\n                                      volume,           # type: MapperEnt\n                                      host_outdir_tgt,  # type: Optional[Text]\n                                      tmpdir_prefix     # type: Text\n                                     ):  # type: (...) -> None\n        \"\"\"Append a writable directory mapping to the runtime option list.\"\"\"\n        if volume.resolved.startswith(\"_:\"):\n            # Synthetic directory that needs creating first\n            if not host_outdir_tgt:\n                tmp_dir, tmp_prefix = os.path.split(tmpdir_prefix)\n                new_dir = os.path.join(\n                    tempfile.mkdtemp(prefix=tmp_prefix, dir=tmp_dir),\n                    os.path.basename(volume.target))\n                self.append_volume(runtime, new_dir, volume.target,\n                                   writable=True)\n            elif not os.path.exists(host_outdir_tgt):\n                os.makedirs(host_outdir_tgt)\n        else:\n            if self.inplace_update:\n                self.append_volume(runtime, volume.resolved, volume.target,\n                                   writable=True)\n            else:\n                if not host_outdir_tgt:\n                    tmp_dir, tmp_prefix = os.path.split(tmpdir_prefix)\n                    tmpdir = tempfile.mkdtemp(prefix=tmp_prefix, dir=tmp_dir)\n                    new_dir = os.path.join(\n                        tmpdir, os.path.basename(volume.resolved))\n                    shutil.copytree(volume.resolved, new_dir)\n                    self.append_volume(\n                        runtime, new_dir, volume.target,\n                        writable=True)\n                else:\n                    shutil.copytree(volume.resolved, host_outdir_tgt)\n                ensure_writable(host_outdir_tgt or new_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make(self, cwl):\n        load = load_tool.load_tool(cwl, self.loading_context)\n        if isinstance(load, int):\n            raise Exception(\"Error loading tool\")\n        return Callable(load, self)", "response": "Instantiate a CWL object from a CWl document."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a single input schema into an example.", "response": "def generate_example_input(inptype,     # type: Any\n                           default      # type: Optional[Any]\n                          ):  # type: (...) -> Tuple[Any, Text]\n    \"\"\"Converts a single input schema into an example.\"\"\"\n    example = None\n    comment = u\"\"\n    defaults = {u'null': 'null',\n                u'Any': 'null',\n                u'boolean': False,\n                u'int': 0,\n                u'long': 0,\n                u'float': 0.1,\n                u'double': 0.1,\n                u'string': 'a_string',\n                u'File': yaml.comments.CommentedMap([\n                    ('class', 'File'), ('path', 'a/file/path')]),\n                u'Directory': yaml.comments.CommentedMap([\n                    ('class', 'Directory'), ('path', 'a/directory/path')])\n               }  # type: Dict[Text, Any]\n    if isinstance(inptype, collections.MutableSequence):\n        optional = False\n        if 'null' in inptype:\n            inptype.remove('null')\n            optional = True\n        if len(inptype) == 1:\n            example, comment = generate_example_input(inptype[0], default)\n            if optional:\n                if comment:\n                    comment = u\"{} (optional)\".format(comment)\n                else:\n                    comment = u\"optional\"\n        else:\n            example = yaml.comments.CommentedSeq()\n            for index, entry in enumerate(inptype):\n                value, e_comment = generate_example_input(entry, default)\n                example.append(value)\n                example.yaml_add_eol_comment(e_comment, index)\n            if optional:\n                comment = u\"optional\"\n    elif isinstance(inptype, collections.Mapping) and 'type' in inptype:\n        if inptype['type'] == 'array':\n            if len(inptype['items']) == 1 and 'type' in inptype['items'][0] \\\n                    and inptype['items'][0]['type'] == 'enum':\n                # array of just an enum then list all the options\n                example = inptype['items'][0]['symbols']\n                if 'name' in inptype['items'][0]:\n                    comment = u'array of type \"{}\".'.format(inptype['items'][0]['name'])\n            else:\n                value, comment = generate_example_input(inptype['items'], None)\n                comment = u\"array of \" + comment\n                if len(inptype['items']) == 1:\n                    example = [value]\n                else:\n                    example = value\n            if default is not None:\n                example = default\n        elif inptype['type'] == 'enum':\n            if default is not None:\n                example = default\n            elif 'default' in inptype:\n                example = inptype['default']\n            elif len(inptype['symbols']) == 1:\n                example = inptype['symbols'][0]\n            else:\n                example = '{}_enum_value'.format(inptype.get('name', 'valid'))\n            comment = u'enum; valid values: \"{}\"'.format(\n                '\", \"'.join(inptype['symbols']))\n        elif inptype['type'] == 'record':\n            example = yaml.comments.CommentedMap()\n            if 'name' in inptype:\n                comment = u'\"{}\" record type.'.format(inptype['name'])\n            for field in inptype['fields']:\n                value, f_comment = generate_example_input(field['type'], None)\n                example.insert(0, shortname(field['name']), value, f_comment)\n        elif 'default' in inptype:\n            example = inptype['default']\n            comment = u'default value of type \"{}\".'.format(inptype['type'])\n        else:\n            example = defaults.get(inptype['type'], Text(inptype))\n            comment = u'type \"{}\".'.format(inptype['type'])\n    else:\n        if not default:\n            example = defaults.get(Text(inptype), Text(inptype))\n            comment = u'type \"{}\"'.format(inptype)\n        else:\n            example = default\n            comment = u'default value of type \"{}\".'.format(inptype)\n    return example, comment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreplace references to named typed with the actual types.", "response": "def realize_input_schema(input_types,  # type: MutableSequence[Dict[Text, Any]]\n                         schema_defs   # type: Dict[Text, Any]\n                        ):  # type: (...) -> MutableSequence[Dict[Text, Any]]\n    \"\"\"Replace references to named typed with the actual types.\"\"\"\n    for index, entry in enumerate(input_types):\n        if isinstance(entry, string_types):\n            if '#' in entry:\n                _, input_type_name = entry.split('#')\n            else:\n                input_type_name = entry\n            if input_type_name in schema_defs:\n                entry = input_types[index] = schema_defs[input_type_name]\n        if isinstance(entry, collections.Mapping):\n            if isinstance(entry['type'], string_types) and '#' in entry['type']:\n                _, input_type_name = entry['type'].split('#')\n                if input_type_name in schema_defs:\n                    input_types[index]['type'] = realize_input_schema(\n                        schema_defs[input_type_name], schema_defs)\n            if isinstance(entry['type'], collections.MutableSequence):\n                input_types[index]['type'] = realize_input_schema(\n                    entry['type'], schema_defs)\n            if isinstance(entry['type'], collections.Mapping):\n                input_types[index]['type'] = realize_input_schema(\n                    [input_types[index]['type']], schema_defs)\n            if entry['type'] == 'array':\n                items = entry['items'] if \\\n                    not isinstance(entry['items'], string_types) else [entry['items']]\n                input_types[index]['items'] = realize_input_schema(items, schema_defs)\n            if entry['type'] == 'record':\n                input_types[index]['fields'] = realize_input_schema(\n                    entry['fields'], schema_defs)\n    return input_types"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_input_template(tool):\n    # type: (Process) -> Dict[Text, Any]\n    \"\"\"Generate an example input object for the given CWL process.\"\"\"\n    template = yaml.comments.CommentedMap()\n    for inp in realize_input_schema(tool.tool[\"inputs\"], tool.schemaDefs):\n        name = shortname(inp[\"id\"])\n        value, comment = generate_example_input(\n            inp['type'], inp.get('default', None))\n        template.insert(0, name, value, comment)\n    return template", "response": "Generate an example input object for the given CWL process."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting a JSON representation of the dependencies of the CWL document.", "response": "def printdeps(obj,              # type: Mapping[Text, Any]\n              document_loader,  # type: Loader\n              stdout,           # type: Union[TextIO, StreamWriter]\n              relative_deps,    # type: bool\n              uri,              # type: Text\n              basedir=None,     # type: Text\n              nestdirs=True     # type: bool\n             ):  # type: (...) -> None\n    \"\"\"Print a JSON representation of the dependencies of the CWL document.\"\"\"\n    deps = find_deps(obj, document_loader, uri, basedir=basedir,\n                     nestdirs=nestdirs)\n    if relative_deps == \"primary\":\n        base = basedir if basedir else os.path.dirname(uri_file_path(str(uri)))\n    elif relative_deps == \"cwd\":\n        base = os.getcwd()\n    visit_class(deps, (\"File\", \"Directory\"), functools.partial(\n        make_relative, base))\n    stdout.write(json_dumps(deps, indent=4))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_deps(obj,              # type: Mapping[Text, Any]\n              document_loader,  # type: Loader\n              uri,              # type: Text\n              basedir=None,     # type: Text\n              nestdirs=True     # type: bool\n             ):  # type: (...) -> Dict[Text, Any]\n    \"\"\"Find the dependencies of the CWL document.\"\"\"\n    deps = {\"class\": \"File\", \"location\": uri, \"format\": CWL_IANA}  # type: Dict[Text, Any]\n\n    def loadref(base, uri):\n        return document_loader.fetch(document_loader.fetcher.urljoin(base, uri))\n\n    sfs = scandeps(\n        basedir if basedir else uri, obj, {\"$import\", \"run\"},\n        {\"$include\", \"$schemas\", \"location\"}, loadref, nestdirs=nestdirs)\n    if sfs is not None:\n        deps[\"secondaryFiles\"] = sfs\n\n    return deps", "response": "Find the dependencies of the CWL document."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a CWL serialization of the CWL document in JSON.", "response": "def print_pack(document_loader,  # type: Loader\n               processobj,       # type: CommentedMap\n               uri,              # type: Text\n               metadata          # type: Dict[Text, Any]\n              ):  # type (...) -> Text\n    \"\"\"Return a CWL serialization of the CWL document in JSON.\"\"\"\n    packed = pack(document_loader, processobj, uri, metadata)\n    if len(packed[\"$graph\"]) > 1:\n        return json_dumps(packed, indent=4)\n    return json_dumps(packed[\"$graph\"][0], indent=4)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndefault finder for default containers.", "response": "def find_default_container(builder,                  # type: HasReqsHints\n                           default_container=None,   # type: Text\n                           use_biocontainers=None,  # type: bool\n                          ):  # type: (...) -> Optional[Text]\n    \"\"\"Default finder for default containers.\"\"\"\n    if not default_container and use_biocontainers:\n        default_container = get_container_from_software_requirements(\n            use_biocontainers, builder)\n    return default_container"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, value):  # type: (Text) -> Text\n        if not isinstance(value, string_types):\n            raise Exception(\"Secret store only accepts strings\")\n\n        if value not in self.secrets:\n            placeholder = \"(secret-%s)\" % Text(uuid.uuid4())\n            self.secrets[placeholder] = value\n            return placeholder\n        return value", "response": "Adds the given value to the store. Returns a placeholder value to use until the real value is needed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef store(self, secrets, job):\n        # type: (List[Text], MutableMapping[Text, Any]) -> None\n        \"\"\"Sanitize the job object of any of the given secrets.\"\"\"\n        for j in job:\n            if j in secrets:\n                job[j] = self.add(job[j])", "response": "Store the given job object of any of the given secrets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_secret(self, value):  # type: (Any) -> bool\n        if isinstance(value, string_types):\n            for k in self.secrets:\n                if k in value:\n                    return True\n        elif isinstance(value, MutableMapping):\n            for this_value in value.values():\n                if self.has_secret(this_value):\n                    return True\n        elif isinstance(value, MutableSequence):\n            for this_value in value:\n                if self.has_secret(this_value):\n                    return True\n        return False", "response": "Test if the provided document has any of our secrets."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef retrieve(self, value):  # type: (Any) -> Any\n        if isinstance(value, string_types):\n            for key, this_value in self.secrets.items():\n                value = value.replace(key, this_value)\n        elif isinstance(value, MutableMapping):\n            return {k: self.retrieve(v) for k, v in value.items()}\n        elif isinstance(value, MutableSequence):\n            return [self.retrieve(v) for k, v in enumerate(value)]\n        return value", "response": "Replace placeholders with their corresponding secrets."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the current operating system account as ( username fullname ).", "response": "def _whoami():\n    # type: () -> Tuple[Text,Text]\n    \"\"\"Return the current operating system account as (username, fullname).\"\"\"\n    username = getuser()\n    try:\n        if onWindows():\n            get_user_name = ctypes.windll.secur32.GetUserNameExW  # type: ignore\n            size = ctypes.pointer(ctypes.c_ulong(0))\n            get_user_name(3, None, size)\n\n            name_buffer = ctypes.create_unicode_buffer(size.contents.value)\n            get_user_name(3, name_buffer, size)\n            fullname = str(name_buffer.value)\n        else:\n            fullname = pwd.getpwuid(os.getuid())[4].split(',')[0]\n    except (KeyError, IndexError):\n        fullname = username\n\n    return (username, fullname)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck the numeric_string for its MOD - 11 - 2 checksum.", "response": "def _check_mod_11_2(numeric_string):\n    # type: (Text) -> bool\n    \"\"\"\n    Validate numeric_string for its MOD-11-2 checksum.\n\n    Any \"-\" in the numeric_string are ignored.\n\n    The last digit of numeric_string is assumed to be the checksum, 0-9 or X.\n\n    See ISO/IEC 7064:2003 and\n    https://support.orcid.org/knowledgebase/articles/116780-structure-of-the-orcid-identifier\n    \"\"\"\n    # Strip -\n    nums = numeric_string.replace(\"-\", \"\")\n    total = 0\n    # skip last (check)digit\n    for num in nums[:-1]:\n        digit = int(num)\n        total = (total+digit)*2\n    remainder = total % 11\n    result = (12-remainder) % 11\n    if result == 10:\n        checkdigit = \"X\"\n    else:\n        checkdigit = str(result)\n    # Compare against last digit or X\n    return nums[-1].upper() == checkdigit"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _valid_orcid(orcid):  # type: (Optional[Text]) -> Text\n    if orcid is None or not orcid:\n        raise ValueError(u'ORCID cannot be unspecified')\n    # Liberal in what we consume, e.g. ORCID.org/0000-0002-1825-009x\n    orcid = orcid.lower()\n    match = re.match(\n        # Note: concatinated r\"\" r\"\" below so we can add comments to pattern\n\n        # Optional hostname, with or without protocol\n        r\"(http://orcid\\.org/|https://orcid\\.org/|orcid\\.org/)?\"\n        # alternative pattern, but probably messier\n        # r\"^((https?://)?orcid.org/)?\"\n\n        # ORCID number is always 4x4 numerical digits,\n        # but last digit (modulus 11 checksum)\n        # can also be X (but we made it lowercase above).\n        # e.g. 0000-0002-1825-0097\n        # or   0000-0002-1694-233x\n        r\"(?P<orcid>(\\d{4}-\\d{4}-\\d{4}-\\d{3}[0-9x]))$\",\n        orcid)\n\n    help_url = u\"https://support.orcid.org/knowledgebase/articles/\"\\\n               \"116780-structure-of-the-orcid-identifier\"\n    if not match:\n        raise ValueError(u\"Invalid ORCID: %s\\n%s\" % (orcid, help_url))\n\n    # Conservative in what we produce:\n    # a) Ensure any checksum digit is uppercase\n    orcid_num = match.group(\"orcid\").upper()\n    # b) ..and correct\n    if not _check_mod_11_2(orcid_num):\n        raise ValueError(\n            u\"Invalid ORCID checksum: %s\\n%s\" % (orcid_num, help_url))\n\n    # c) Re-add the official prefix https://orcid.org/\n    return u\"https://orcid.org/%s\" % orcid_num", "response": "Ensure ORCID identifier is a valid ORCID identifier."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef checksum_copy(src_file,            # type: IO\n                  dst_file=None,      # type: Optional[IO]\n                  hasher=Hasher,        # type: Callable[[], Any]\n                  buffersize=1024*1024  # type: int\n                 ): # type: (...) -> str\n    \"\"\"Compute checksums while copying a file.\"\"\"\n    # TODO: Use hashlib.new(Hasher_str) instead?\n    checksum = hasher()\n    contents = src_file.read(buffersize)\n    if dst_file and hasattr(dst_file, \"name\") and hasattr(src_file, \"name\"):\n        temp_location = os.path.join(os.path.dirname(dst_file.name),\n                                     str(uuid.uuid4()))\n        try:\n            os.rename(dst_file.name, temp_location)\n            os.link(src_file.name, dst_file.name)\n            dst_file = None\n            os.unlink(temp_location)\n        except OSError:\n            pass\n        if os.path.exists(temp_location):\n            os.rename(temp_location, dst_file.name)  # type: ignore\n    while contents != b\"\":\n        if dst_file is not None:\n            dst_file.write(contents)\n        checksum.update(contents)\n        contents = src_file.read(buffersize)\n    if dst_file is not None:\n        dst_file.flush()\n    return checksum.hexdigest().lower()", "response": "Compute checksums while copying a file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy_job_order(job, job_order_object):\n    # type: (Any, Any) -> Any\n    \"\"\"Create copy of job object for provenance.\"\"\"\n    if not hasattr(job, \"tool\"):\n        # direct command line tool execution\n        return job_order_object\n    customised_job = {}  # new job object for RO\n    for each, i in enumerate(job.tool[\"inputs\"]):\n        with SourceLine(job.tool[\"inputs\"], each, WorkflowException,\n                        _logger.isEnabledFor(logging.DEBUG)):\n            iid = shortname(i[\"id\"])\n            if iid in job_order_object:\n                customised_job[iid] = copy.deepcopy(job_order_object[iid])\n                # add the input element in dictionary for provenance\n            elif \"default\" in i:\n                customised_job[iid] = copy.deepcopy(i[\"default\"])\n                # add the default elements in the dictionary for provenance\n            else:\n                pass\n    return customised_job", "response": "Create copy of job object for provenance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_prov_doc(self):\n        # type: () -> Tuple[str, ProvDocument]\n        \"\"\"Add basic namespaces.\"\"\"\n        def host_provenance(document):\n            # type: (ProvDocument) -> None\n            \"\"\"Record host provenance.\"\"\"\n            document.add_namespace(CWLPROV)\n            document.add_namespace(UUID)\n            document.add_namespace(FOAF)\n\n            hostname = getfqdn()\n            # won't have a foaf:accountServiceHomepage for unix hosts, but\n            # we can at least provide hostname\n            document.agent(\n                ACCOUNT_UUID, {provM.PROV_TYPE: FOAF[\"OnlineAccount\"],\n                               \"prov:location\": hostname,\n                               CWLPROV[\"hostname\"]: hostname})\n\n        self.cwltool_version = \"cwltool %s\" % versionstring().split()[-1]\n        self.document.add_namespace(\n            'wfprov', 'http://purl.org/wf4ever/wfprov#')\n        # document.add_namespace('prov', 'http://www.w3.org/ns/prov#')\n        self.document.add_namespace(\n            'wfdesc', 'http://purl.org/wf4ever/wfdesc#')\n        # TODO: Make this ontology. For now only has cwlprov:image\n        self.document.add_namespace('cwlprov', 'https://w3id.org/cwl/prov#')\n        self.document.add_namespace('foaf', 'http://xmlns.com/foaf/0.1/')\n        self.document.add_namespace('schema', 'http://schema.org/')\n        self.document.add_namespace('orcid', 'https://orcid.org/')\n        self.document.add_namespace('id', 'urn:uuid:')\n        # NOTE: Internet draft expired 2004-03-04 (!)\n        #  https://tools.ietf.org/html/draft-thiemann-hash-urn-01\n        # TODO: Change to nih:sha-256; hashes\n        #  https://tools.ietf.org/html/rfc6920#section-7\n        self.document.add_namespace('data', 'urn:hash::sha1:')\n        # Also needed for docker images\n        self.document.add_namespace(SHA256, \"nih:sha-256;\")\n\n        # info only, won't really be used by prov as sub-resources use /\n        self.document.add_namespace(\n            'researchobject', self.research_object.base_uri)\n        # annotations\n        self.metadata_ns = self.document.add_namespace(\n            'metadata', self.research_object.base_uri + _posix_path(METADATA)\n            + \"/\")\n        # Pre-register provenance directory so we can refer to its files\n        self.provenance_ns = self.document.add_namespace(\n            'provenance', self.research_object.base_uri\n            + _posix_path(PROVENANCE) + \"/\")\n        ro_identifier_workflow = self.research_object.base_uri \\\n            + \"workflow/packed.cwl#\"\n        self.wf_ns = self.document.add_namespace(\"wf\", ro_identifier_workflow)\n        ro_identifier_input = self.research_object.base_uri \\\n            + \"workflow/primary-job.json#\"\n        self.document.add_namespace(\"input\", ro_identifier_input)\n\n        # More info about the account (e.g. username, fullname)\n        # may or may not have been previously logged by user_provenance()\n        # .. but we always know cwltool was launched (directly or indirectly)\n        # by a user account, as cwltool is a command line tool\n        account = self.document.agent(ACCOUNT_UUID)\n        if self.orcid or self.full_name:\n            person = {provM.PROV_TYPE: PROV[\"Person\"],\n                      \"prov:type\": SCHEMA[\"Person\"]}\n            if self.full_name:\n                person[\"prov:label\"] = self.full_name\n                person[\"foaf:name\"] = self.full_name\n                person[\"schema:name\"] = self.full_name\n            else:\n                # TODO: Look up name from ORCID API?\n                pass\n            agent = self.document.agent(self.orcid or uuid.uuid4().urn,\n                                        person)\n            self.document.actedOnBehalfOf(account, agent)\n        else:\n            if self.host_provenance:\n                host_provenance(self.document)\n            if self.user_provenance:\n                self.research_object.user_provenance(self.document)\n        # The execution of cwltool\n        wfengine = self.document.agent(\n            self.engine_uuid,\n            {provM.PROV_TYPE: PROV[\"SoftwareAgent\"],\n             \"prov:type\": WFPROV[\"WorkflowEngine\"],\n             \"prov:label\": self.cwltool_version})\n        # FIXME: This datetime will be a bit too delayed, we should\n        # capture when cwltool.py earliest started?\n        self.document.wasStartedBy(\n            wfengine, None, account, datetime.datetime.now())\n        # define workflow run level activity\n        self.document.activity(\n            self.workflow_run_uri, datetime.datetime.now(), None,\n            {provM.PROV_TYPE: WFPROV[\"WorkflowRun\"],\n             \"prov:label\": \"Run of workflow/packed.cwl#main\"})\n            # association between SoftwareAgent and WorkflowRun\n        main_workflow = \"wf:main\"\n        self.document.wasAssociatedWith(\n            self.workflow_run_uri, self.engine_uuid, main_workflow)\n        self.document.wasStartedBy(\n            self.workflow_run_uri, None, self.engine_uuid,\n            datetime.datetime.now())\n        return (self.workflow_run_uri, self.document)", "response": "Generate a PROV document for a particular entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nevaluate the nature of a job.", "response": "def evaluate(self,\n                 process,           # type: Process\n                 job,               # type: Any\n                 job_order_object,  # type: Dict[Text, Text]\n                 research_obj       # type: ResearchObject\n                ):  # type: (...) -> None\n        \"\"\"Evaluate the nature of job\"\"\"\n        if not hasattr(process, \"steps\"):\n            # record provenance of independent commandline tool executions\n            self.prospective_prov(job)\n            customised_job = copy_job_order(job, job_order_object)\n            self.used_artefacts(customised_job, self.workflow_run_uri)\n            research_obj.create_job(customised_job, job)\n        elif hasattr(job, \"workflow\"):\n            # record provenance of workflow executions\n            self.prospective_prov(job)\n            customised_job = copy_job_order(job, job_order_object)\n            self.used_artefacts(customised_job, self.workflow_run_uri)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrecord the start of each Process.", "response": "def start_process(self, process_name, when, process_run_id=None):\n        # type: (Text, datetime.datetime, Optional[str]) -> str\n        \"\"\"Record the start of each Process.\"\"\"\n        if process_run_id is None:\n            process_run_id = uuid.uuid4().urn\n        prov_label = \"Run of workflow/packed.cwl#main/\" + process_name\n        self.document.activity(\n            process_run_id, None, None,\n            {provM.PROV_TYPE: WFPROV[\"ProcessRun\"],\n             provM.PROV_LABEL: prov_label})\n        self.document.wasAssociatedWith(\n            process_run_id, self.engine_uuid, str(\"wf:main/\" + process_name))\n        self.document.wasStartedBy(\n            process_run_id, None, self.workflow_run_uri,\n            when, None, None)\n        return process_run_id"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef declare_directory(self, value):  # type: (MutableMapping) -> ProvEntity\n        # FIXME: Calculate a hash-like identifier for directory\n        # so we get same value if it's the same filenames/hashes\n        # in a different location.\n        # For now, mint a new UUID to identify this directory, but\n        # attempt to keep it inside the value dictionary\n        dir_id = value.setdefault(\"@id\", uuid.uuid4().urn)\n\n        # New annotation file to keep the ORE Folder listing\n        ore_doc_fn = dir_id.replace(\"urn:uuid:\", \"directory-\") + \".ttl\"\n        dir_bundle = self.document.bundle(self.metadata_ns[ore_doc_fn])\n\n        coll = self.document.entity(\n            dir_id, [(provM.PROV_TYPE, WFPROV[\"Artifact\"]),\n                     (provM.PROV_TYPE, PROV[\"Collection\"]),\n                     (provM.PROV_TYPE, PROV[\"Dictionary\"]),\n                     (provM.PROV_TYPE, RO[\"Folder\"])])\n        # ORE description of ro:Folder, saved separately\n        coll_b = dir_bundle.entity(\n            dir_id, [(provM.PROV_TYPE, RO[\"Folder\"]),\n                     (provM.PROV_TYPE, ORE[\"Aggregation\"])])\n        self.document.mentionOf(dir_id + \"#ore\", dir_id, dir_bundle.identifier)\n\n        # dir_manifest = dir_bundle.entity(\n        #     dir_bundle.identifier, {PROV[\"type\"]: ORE[\"ResourceMap\"],\n        #                             ORE[\"describes\"]: coll_b.identifier})\n\n        coll_attribs = [(ORE[\"isDescribedBy\"], dir_bundle.identifier)]\n        coll_b_attribs = []  # type: List[Tuple[Identifier, ProvEntity]]\n\n        # FIXME: .listing might not be populated yet - hopefully\n        # a later call to this method will sort that\n        is_empty = True\n\n        if \"listing\" not in value:\n            fsaccess = StdFsAccess(\"\")\n            get_listing(fsaccess, value)\n        for entry in value.get(\"listing\", []):\n            is_empty = False\n            # Declare child-artifacts\n            entity = self.declare_artefact(entry)\n            self.document.membership(coll, entity)\n            # Membership relation aka our ORE Proxy\n            m_id = uuid.uuid4().urn\n            m_entity = self.document.entity(m_id)\n            m_b = dir_bundle.entity(m_id)\n\n            # PROV-O style Dictionary\n            # https://www.w3.org/TR/prov-dictionary/#dictionary-ontological-definition\n            # ..as prov.py do not currently allow PROV-N extensions\n            # like hadDictionaryMember(..)\n            m_entity.add_asserted_type(PROV[\"KeyEntityPair\"])\n\n            m_entity.add_attributes({\n                PROV[\"pairKey\"]: entry[\"basename\"],\n                PROV[\"pairEntity\"]: entity,\n            })\n\n            # As well as a being a\n            # http://wf4ever.github.io/ro/2016-01-28/ro/#FolderEntry\n            m_b.add_asserted_type(RO[\"FolderEntry\"])\n            m_b.add_asserted_type(ORE[\"Proxy\"])\n            m_b.add_attributes({\n                RO[\"entryName\"]: entry[\"basename\"],\n                ORE[\"proxyIn\"]: coll,\n                ORE[\"proxyFor\"]: entity,\n\n            })\n            coll_attribs.append((PROV[\"hadDictionaryMember\"], m_entity))\n            coll_b_attribs.append((ORE[\"aggregates\"], m_b))\n\n        coll.add_attributes(coll_attribs)\n        coll_b.add_attributes(coll_b_attribs)\n\n        # Also Save ORE Folder as annotation metadata\n        ore_doc = ProvDocument()\n        ore_doc.add_namespace(ORE)\n        ore_doc.add_namespace(RO)\n        ore_doc.add_namespace(UUID)\n        ore_doc.add_bundle(dir_bundle)\n        ore_doc = ore_doc.flattened()\n        ore_doc_path = posixpath.join(_posix_path(METADATA), ore_doc_fn)\n        with self.research_object.write_bag_file(ore_doc_path) as provenance_file:\n            ore_doc.serialize(provenance_file, format=\"rdf\", rdf_format=\"turtle\")\n        self.research_object.add_annotation(dir_id, [ore_doc_fn], ORE[\"isDescribedBy\"].uri)\n\n        if is_empty:\n            # Empty directory\n            coll.add_asserted_type(PROV[\"EmptyCollection\"])\n            coll.add_asserted_type(PROV[\"EmptyDictionary\"])\n        self.research_object.add_uri(coll.identifier.uri)\n        return coll", "response": "Declare any nested files and directories."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef declare_string(self, value):\n        # type: (Union[Text, str]) -> Tuple[ProvEntity,Text]\n        \"\"\"Save as string in UTF-8.\"\"\"\n        byte_s = BytesIO(str(value).encode(ENCODING))\n        data_file = self.research_object.add_data_file(byte_s, content_type=TEXT_PLAIN)\n        checksum = posixpath.basename(data_file)\n        # FIXME: Don't naively assume add_data_file uses hash in filename!\n        data_id = \"data:%s\" % posixpath.split(data_file)[1]\n        entity = self.document.entity(\n            data_id, {provM.PROV_TYPE: WFPROV[\"Artifact\"],\n                      provM.PROV_VALUE: str(value)})  # type: ProvEntity\n        return entity, checksum", "response": "Save as string in UTF - 8."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef declare_artefact(self, value):\n        # type: (Any) -> ProvEntity\n        \"\"\"Create data artefact entities for all file objects.\"\"\"\n        if value is None:\n            # FIXME: If this can happen in CWL, we'll\n            # need a better way to represent this in PROV\n            return self.document.entity(\n                CWLPROV[\"None\"], {provM.PROV_LABEL: \"None\"})\n\n        if isinstance(value, (bool, int, float)):\n            # Typically used in job documents for flags\n\n            # FIXME: Make consistent hash URIs for these\n            # that somehow include the type\n            # (so \"1\" != 1 != \"1.0\" != true)\n            entity = self.document.entity(\n                uuid.uuid4().urn, {provM.PROV_VALUE: value})\n            self.research_object.add_uri(entity.identifier.uri)\n            return entity\n\n        if isinstance(value, (Text, str)):\n            (entity, _) = self.declare_string(value)\n            return entity\n\n        if isinstance(value, bytes):\n            # If we got here then we must be in Python 3\n            byte_s = BytesIO(value)\n            data_file = self.research_object.add_data_file(byte_s)\n            # FIXME: Don't naively assume add_data_file uses hash in filename!\n            data_id = \"data:%s\" % posixpath.split(data_file)[1]\n            return self.document.entity(\n                data_id, {provM.PROV_TYPE: WFPROV[\"Artifact\"],\n                          provM.PROV_VALUE: str(value)})\n\n        if isinstance(value, MutableMapping):\n            if \"@id\" in value:\n                # Already processed this value, but it might not be in this PROV\n                entities = self.document.get_record(value[\"@id\"])\n                if entities:\n                    return entities[0]\n                # else, unknown in PROV, re-add below as if it's fresh\n\n            # Base case - we found a File we need to update\n            if value.get(\"class\") == \"File\":\n                (entity, _, _) = self.declare_file(value)\n                value[\"@id\"] = entity.identifier.uri\n                return entity\n\n            if value.get(\"class\") == \"Directory\":\n                entity = self.declare_directory(value)\n                value[\"@id\"] = entity.identifier.uri\n                return entity\n            coll_id = value.setdefault(\"@id\", uuid.uuid4().urn)\n            # some other kind of dictionary?\n            # TODO: also Save as JSON\n            coll = self.document.entity(\n                coll_id, [(provM.PROV_TYPE, WFPROV[\"Artifact\"]),\n                          (provM.PROV_TYPE, PROV[\"Collection\"]),\n                          (provM.PROV_TYPE, PROV[\"Dictionary\"])])\n\n            if value.get(\"class\"):\n                _logger.warning(\"Unknown data class %s.\", value[\"class\"])\n                # FIXME: The class might be \"http://example.com/somethingelse\"\n                coll.add_asserted_type(CWLPROV[value[\"class\"]])\n\n            # Let's iterate and recurse\n            coll_attribs = []  # type: List[Tuple[Identifier, ProvEntity]]\n            for (key, val) in value.items():\n                v_ent = self.declare_artefact(val)\n                self.document.membership(coll, v_ent)\n                m_entity = self.document.entity(uuid.uuid4().urn)\n                # Note: only support PROV-O style dictionary\n                # https://www.w3.org/TR/prov-dictionary/#dictionary-ontological-definition\n                # as prov.py do not easily allow PROV-N extensions\n                m_entity.add_asserted_type(PROV[\"KeyEntityPair\"])\n                m_entity.add_attributes({\n                    PROV[\"pairKey\"]: str(key),\n                    PROV[\"pairEntity\"]: v_ent\n                })\n                coll_attribs.append((PROV[\"hadDictionaryMember\"], m_entity))\n            coll.add_attributes(coll_attribs)\n            self.research_object.add_uri(coll.identifier.uri)\n            return coll\n\n        # some other kind of Collection?\n        # TODO: also save as JSON\n        try:\n            members = []\n            for each_input_obj in iter(value):\n                # Recurse and register any nested objects\n                e = self.declare_artefact(each_input_obj)\n                members.append(e)\n\n            # If we reached this, then we were allowed to iterate\n            coll = self.document.entity(\n                uuid.uuid4().urn, [(provM.PROV_TYPE, WFPROV[\"Artifact\"]),\n                                   (provM.PROV_TYPE, PROV[\"Collection\"])])\n            if not members:\n                coll.add_asserted_type(PROV[\"EmptyCollection\"])\n            else:\n                for member in members:\n                    # FIXME: This won't preserve order, for that\n                    # we would need to use PROV.Dictionary\n                    # with numeric keys\n                    self.document.membership(coll, member)\n            self.research_object.add_uri(coll.identifier.uri)\n            # FIXME: list value does not support adding \"@id\"\n            return coll\n        except TypeError:\n            _logger.warning(\"Unrecognized type %s of %r\",\n                            type(value), value)\n            # Let's just fall back to Python repr()\n            entity = self.document.entity(\n                uuid.uuid4().urn, {provM.PROV_LABEL: repr(value)})\n            self.research_object.add_uri(entity.identifier.uri)\n            return entity", "response": "Create data artefact entities for all file objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef used_artefacts(self,\n                       job_order,            # type: Dict\n                       process_run_id,       # type: str\n                       name=None             # type: str\n                      ):  # type: (...) -> None\n        \"\"\"Add used() for each data artefact.\"\"\"\n        # FIXME: Use workflow name in packed.cwl, \"main\" is wrong for nested workflows\n        base = \"main\"\n        if name is not None:\n            base += \"/\" + name\n        for key, value in job_order.items():\n            prov_role = self.wf_ns[\"%s/%s\" % (base, key)]\n            entity = self.declare_artefact(value)\n            self.document.used(\n                process_run_id, entity, datetime.datetime.now(), None,\n                {\"prov:role\": prov_role})", "response": "Add used to each data artefact."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_output_prov(self,\n                             final_output,    # type: Dict[Text, Any]\n                             process_run_id,  # type: Optional[str]\n                             name             # type: Optional[Text]\n                            ):   # type: (...) -> None\n        \"\"\"Call wasGeneratedBy() for each output,copy the files into the RO.\"\"\"\n        # Timestamp should be created at the earliest\n        timestamp = datetime.datetime.now()\n\n        # For each output, find/register the corresponding\n        # entity (UUID) and document it as generated in\n        # a role corresponding to the output\n        for output, value in final_output.items():\n            entity = self.declare_artefact(value)\n            if name is not None:\n                name = urllib.parse.quote(str(name), safe=\":/,#\")\n                # FIXME: Probably not \"main\" in nested workflows\n                role = self.wf_ns[\"main/%s/%s\" % (name, output)]\n            else:\n                role = self.wf_ns[\"main/%s\" % output]\n\n            if not process_run_id:\n                process_run_id = self.workflow_run_uri\n\n            self.document.wasGeneratedBy(\n                entity, process_run_id, timestamp, None, {\"prov:role\": role})", "response": "Call wasGeneratedBy() for each output copy the files into the RO."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates prospective prov recording as wfdesc prov. Plan.", "response": "def prospective_prov(self, job):\n        # type: (Any) -> None\n        \"\"\"Create prospective prov recording as wfdesc prov:Plan.\"\"\"\n        if not hasattr(job, \"steps\"):\n            # direct command line tool execution\n            self.document.entity(\n                \"wf:main\", {provM.PROV_TYPE: WFDESC[\"Process\"],\n                            \"prov:type\": PROV[\"Plan\"],\n                            \"prov:label\":\"Prospective provenance\"})\n            return\n\n        self.document.entity(\n            \"wf:main\", {provM.PROV_TYPE: WFDESC[\"Workflow\"],\n                        \"prov:type\": PROV[\"Plan\"],\n                        \"prov:label\":\"Prospective provenance\"})\n\n        for step in job.steps:\n            stepnametemp = \"wf:main/\" + str(step.name)[5:]\n            stepname = urllib.parse.quote(stepnametemp, safe=\":/,#\")\n            step = self.document.entity(\n                stepname, {provM.PROV_TYPE: WFDESC[\"Process\"],\n                           \"prov:type\": PROV[\"Plan\"]})\n            self.document.entity(\n                \"wf:main\", {\"wfdesc:hasSubProcess\": step,\n                            \"prov:label\": \"Prospective provenance\"})"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds http://www. w3. org / TR / prov - aq / relations to nested PROV files.", "response": "def activity_has_provenance(self, activity, prov_ids):\n        # type: (str, List[Identifier]) -> None\n        \"\"\"Add http://www.w3.org/TR/prov-aq/ relations to nested PROV files.\"\"\"\n        # NOTE: The below will only work if the corresponding metadata/provenance arcp URI\n        # is a pre-registered namespace in the PROV Document\n        attribs = [(PROV[\"has_provenance\"], prov_id) for prov_id in prov_ids]\n        self.document.activity(activity, other_attributes=attribs)\n        # Tip: we can't use https://www.w3.org/TR/prov-links/#term-mention\n        # as prov:mentionOf() is only for entities, not activities\n        uris = [i.uri for i in prov_ids]\n        self.research_object.add_annotation(activity, uris, PROV[\"has_provenance\"].uri)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef finalize_prov_profile(self, name):\n        # type: (Optional[Text]) -> List[Identifier]\n        \"\"\"Transfer the provenance related files to the RO.\"\"\"\n        # NOTE: Relative posix path\n        if name is None:\n            # master workflow, fixed filenames\n            filename = \"primary.cwlprov\"\n        else:\n            # ASCII-friendly filename, avoiding % as we don't want %2520 in manifest.json\n            wf_name = urllib.parse.quote(str(name), safe=\"\").replace(\"%\", \"_\")\n            # Note that the above could cause overlaps for similarly named\n            # workflows, but that's OK as we'll also include run uuid\n            # which also covers thhe case of this step being run in\n            # multiple places or iterations\n            filename = \"%s.%s.cwlprov\" % (wf_name, self.workflow_run_uuid)\n\n        basename = posixpath.join(_posix_path(PROVENANCE), filename)\n\n        # TODO: Also support other profiles than CWLProv, e.g. ProvOne\n\n        # list of prov identifiers of provenance files\n        prov_ids = []\n\n        # https://www.w3.org/TR/prov-xml/\n        with self.research_object.write_bag_file(basename + \".xml\") as provenance_file:\n            self.document.serialize(provenance_file, format=\"xml\", indent=4)\n            prov_ids.append(self.provenance_ns[filename + \".xml\"])\n\n        # https://www.w3.org/TR/prov-n/\n        with self.research_object.write_bag_file(basename + \".provn\") as provenance_file:\n            self.document.serialize(provenance_file, format=\"provn\", indent=2)\n            prov_ids.append(self.provenance_ns[filename + \".provn\"])\n\n        # https://www.w3.org/Submission/prov-json/\n        with self.research_object.write_bag_file(basename + \".json\") as provenance_file:\n            self.document.serialize(provenance_file, format=\"json\", indent=2)\n            prov_ids.append(self.provenance_ns[filename + \".json\"])\n\n        # \"rdf\" aka https://www.w3.org/TR/prov-o/\n        # which can be serialized to ttl/nt/jsonld (and more!)\n\n        # https://www.w3.org/TR/turtle/\n        with self.research_object.write_bag_file(basename + \".ttl\") as provenance_file:\n            self.document.serialize(provenance_file, format=\"rdf\", rdf_format=\"turtle\")\n            prov_ids.append(self.provenance_ns[filename + \".ttl\"])\n\n        # https://www.w3.org/TR/n-triples/\n        with self.research_object.write_bag_file(basename + \".nt\") as provenance_file:\n            self.document.serialize(provenance_file, format=\"rdf\", rdf_format=\"ntriples\")\n            prov_ids.append(self.provenance_ns[filename + \".nt\"])\n\n        # https://www.w3.org/TR/json-ld/\n        # TODO: Use a nice JSON-LD context\n        # see also https://eprints.soton.ac.uk/395985/\n        # 404 Not Found on https://provenance.ecs.soton.ac.uk/prov.jsonld :(\n        with self.research_object.write_bag_file(basename + \".jsonld\") as provenance_file:\n            self.document.serialize(provenance_file, format=\"rdf\", rdf_format=\"json-ld\")\n            prov_ids.append(self.provenance_ns[filename + \".jsonld\"])\n\n        _logger.debug(u\"[provenance] added provenance: %s\", prov_ids)\n        return prov_ids", "response": "Transfer the provenance related files to the RO."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites fixed bagit header.", "response": "def _initialize_bagit(self):  # type: () -> None\n        \"\"\"Write fixed bagit header.\"\"\"\n        self.self_check()\n        bagit = os.path.join(self.folder, \"bagit.txt\")\n        # encoding: always UTF-8 (although ASCII would suffice here)\n        # newline: ensure LF also on Windows\n        with open(bagit, \"w\", encoding=ENCODING, newline='\\n') as bag_it_file:\n            # TODO: \\n or \\r\\n ?\n            bag_it_file.write(u\"BagIt-Version: 0.97\\n\")\n            bag_it_file.write(u\"Tag-File-Character-Encoding: %s\\n\" % ENCODING)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the user provenance.", "response": "def user_provenance(self, document):  # type: (ProvDocument) -> None\n        \"\"\"Add the user provenance.\"\"\"\n        self.self_check()\n        (username, fullname) = _whoami()\n\n        if not self.full_name:\n            self.full_name = fullname\n\n        document.add_namespace(UUID)\n        document.add_namespace(ORCID)\n        document.add_namespace(FOAF)\n        account = document.agent(\n            ACCOUNT_UUID, {provM.PROV_TYPE: FOAF[\"OnlineAccount\"],\n                           \"prov:label\": username,\n                           FOAF[\"accountName\"]: username})\n\n        user = document.agent(\n            self.orcid or USER_UUID,\n            {provM.PROV_TYPE: PROV[\"Person\"],\n             \"prov:label\": self.full_name,\n             FOAF[\"name\"]: self.full_name,\n             FOAF[\"account\"]: account})\n        # cwltool may be started on the shell (directly by user),\n        # by shell script (indirectly by user)\n        # or from a different program\n        #   (which again is launched by any of the above)\n        #\n        # We can't tell in which way, but ultimately we're still\n        # acting in behalf of that user (even if we might\n        # get their name wrong!)\n        document.actedOnBehalfOf(account, user)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the bag file into our research object.", "response": "def write_bag_file(self, path, encoding=ENCODING):\n        # type: (Text, Optional[str]) -> IO\n        \"\"\"Write the bag file into our research object.\"\"\"\n        self.self_check()\n        # For some reason below throws BlockingIOError\n        #fp = BufferedWriter(WritableBagFile(self, path))\n        bag_file = cast(IO, WritableBagFile(self, path))\n        if encoding is not None:\n            # encoding: match Tag-File-Character-Encoding: UTF-8\n            # newline: ensure LF also on Windows\n            return cast(IO,\n                        TextIOWrapper(bag_file, encoding=encoding, newline=\"\\n\"))\n        return bag_file"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a tag file to our research object.", "response": "def add_tagfile(self, path, timestamp=None):\n        # type: (Text, datetime.datetime) -> None\n        \"\"\"Add tag files to our research object.\"\"\"\n        self.self_check()\n        checksums = {}\n        # Read file to calculate its checksum\n        if os.path.isdir(path):\n            return\n            # FIXME: do the right thing for directories\n        with open(path, \"rb\") as tag_file:\n            # FIXME: Should have more efficient open_tagfile() that\n            # does all checksums in one go while writing through,\n            # adding checksums after closing.\n            # Below probably OK for now as metadata files\n            # are not too large..?\n\n            checksums[SHA1] = checksum_copy(tag_file, hasher=hashlib.sha1)\n\n            tag_file.seek(0)\n            checksums[SHA256] = checksum_copy(tag_file, hasher=hashlib.sha256)\n\n            tag_file.seek(0)\n            checksums[SHA512] = checksum_copy(tag_file, hasher=hashlib.sha512)\n\n        rel_path = _posix_path(os.path.relpath(path, self.folder))\n        self.tagfiles.add(rel_path)\n        self.add_to_manifest(rel_path, checksums)\n        if timestamp is not None:\n            self._file_provenance[rel_path] = {\"createdOn\": timestamp.isoformat()}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ro_aggregates(self):\n        # type: () -> List[Dict[str, Any]]\n        \"\"\"Gather dictionary of files to be added to the manifest.\"\"\"\n        def guess_mediatype(rel_path):\n            # type: (str) -> Dict[str, str]\n            \"\"\"Return the mediatypes.\"\"\"\n            media_types = {\n                # Adapted from\n                # https://w3id.org/bundle/2014-11-05/#media-types\n\n                \"txt\": TEXT_PLAIN,\n                \"ttl\": 'text/turtle; charset=\"UTF-8\"',\n                \"rdf\": 'application/rdf+xml',\n                \"json\": 'application/json',\n                \"jsonld\": 'application/ld+json',\n                \"xml\": 'application/xml',\n                ##\n                \"cwl\": 'text/x+yaml; charset=\"UTF-8\"',\n                \"provn\": 'text/provenance-notation; charset=\"UTF-8\"',\n                \"nt\": 'application/n-triples',\n            }\n            conforms_to = {\n                \"provn\": 'http://www.w3.org/TR/2013/REC-prov-n-20130430/',\n                \"cwl\": 'https://w3id.org/cwl/',\n            }\n\n            prov_conforms_to = {\n                \"provn\": 'http://www.w3.org/TR/2013/REC-prov-n-20130430/',\n                \"rdf\": 'http://www.w3.org/TR/2013/REC-prov-o-20130430/',\n                \"ttl\": 'http://www.w3.org/TR/2013/REC-prov-o-20130430/',\n                \"nt\": 'http://www.w3.org/TR/2013/REC-prov-o-20130430/',\n                \"jsonld\": 'http://www.w3.org/TR/2013/REC-prov-o-20130430/',\n                \"xml\": 'http://www.w3.org/TR/2013/NOTE-prov-xml-20130430/',\n                \"json\": 'http://www.w3.org/Submission/2013/SUBM-prov-json-20130424/',\n            }\n\n\n            extension = rel_path.rsplit(\".\", 1)[-1].lower()  # type: Optional[str]\n            if extension == rel_path:\n                # No \".\", no extension\n                extension = None\n\n            local_aggregate = {}  # type: Dict[str, Any]\n            if extension in media_types:\n                local_aggregate[\"mediatype\"] = media_types[extension]\n\n            if extension in conforms_to:\n                # TODO: Open CWL file to read its declared \"cwlVersion\", e.g.\n                # cwlVersion = \"v1.0\"\n                local_aggregate[\"conformsTo\"] = conforms_to[extension]\n\n            if (rel_path.startswith(_posix_path(PROVENANCE))\n                    and extension in prov_conforms_to):\n                if \".cwlprov\" in rel_path:\n                    # Our own!\n                    local_aggregate[\"conformsTo\"] = [prov_conforms_to[extension], CWLPROV_VERSION]\n                else:\n                    # Some other PROV\n                    # TODO: Recognize ProvOne etc.\n                    local_aggregate[\"conformsTo\"] = prov_conforms_to[extension]\n            return local_aggregate\n\n        aggregates = [] # type: List[Dict]\n        for path in self.bagged_size.keys():\n            aggregate_dict = {}  # type: Dict[str, Any]\n\n            (folder, filename) = posixpath.split(path)\n\n            # NOTE: Here we end up aggregating the abstract\n            # data items by their sha1 hash, so that it matches\n            # the entity() in the prov files.\n\n            # TODO: Change to nih:sha-256; hashes\n            #  https://tools.ietf.org/html/rfc6920#section-7\n            aggregate_dict[\"uri\"] = 'urn:hash::sha1:' + filename\n            aggregate_dict[\"bundledAs\"] = {\n                # The arcp URI is suitable ORE proxy; local to this Research Object.\n                # (as long as we don't also aggregate it by relative path!)\n                \"uri\": self.base_uri + path,\n                # relate it to the data/ path\n                \"folder\": \"/%s/\" % folder,\n                \"filename\": filename,\n            }\n            if path in self._file_provenance:\n                # Made by workflow run, merge captured provenance\n                aggregate_dict[\"bundledAs\"].update(self._file_provenance[path])\n            else:\n                # Probably made outside wf run, part of job object?\n                pass\n            if path in self._content_types:\n                aggregate_dict[\"mediatype\"] = self._content_types[path]\n\n            aggregates.append(aggregate_dict)\n\n        for path in self.tagfiles:\n            if (not (path.startswith(METADATA) or path.startswith(WORKFLOW) or\n                     path.startswith(SNAPSHOT))):\n                # probably a bagit file\n                continue\n            if path == posixpath.join(METADATA, \"manifest.json\"):\n                # Should not really be there yet! But anyway, we won't\n                # aggregate it.\n                continue\n\n            rel_aggregates = {} # type: Dict[str, Any]\n            # These are local paths like metadata/provenance - but\n            # we need to relativize them for our current directory for\n            # as we are saved in metadata/manifest.json\n            uri = posixpath.relpath(path, METADATA)\n\n            rel_aggregates[\"uri\"] = uri\n            rel_aggregates.update(guess_mediatype(path))\n\n            if path in self._file_provenance:\n                # Propagate file provenance (e.g. timestamp)\n                rel_aggregates.update(self._file_provenance[path])\n            elif not path.startswith(SNAPSHOT):\n                # make new timestamp?\n                rel_aggregates.update(self._self_made())\n            aggregates.append(rel_aggregates)\n        aggregates.extend(self._external_aggregates)\n        return aggregates", "response": "Gather the dictionary of files to be added to the manifest."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd an annotation to the heap.", "response": "def add_annotation(self, about, content, motivated_by=\"oa:describing\"):\n        # type: (str, List[str], str) -> str\n        \"\"\"Cheap URI relativize for current directory and /.\"\"\"\n        self.self_check()\n        curr = self.base_uri + METADATA + \"/\"\n        content = [c.replace(curr, \"\").replace(self.base_uri, \"../\")\n                   for c in content]\n        uri = uuid.uuid4().urn\n        ann = {\n            \"uri\": uri,\n            \"about\": about,\n            \"content\": content,\n            \"oa:motivatedBy\": {\"@id\": motivated_by}\n        }\n        self.annotations.append(ann)\n        return uri"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncopy all of the CWL files to the snapshot directory.", "response": "def generate_snapshot(self, prov_dep):\n        # type: (MutableMapping[Text, Any]) -> None\n        \"\"\"Copy all of the CWL files to the snapshot/ directory.\"\"\"\n        self.self_check()\n        for key, value in prov_dep.items():\n            if key == \"location\" and value.split(\"/\")[-1]:\n                filename = value.split(\"/\")[-1]\n                path = os.path.join(self.folder, SNAPSHOT, filename)\n                filepath = ''\n                if \"file://\" in value:\n                    filepath = value[7:]\n                else:\n                    filepath = value\n\n                # FIXME: What if destination path already exists?\n                if os.path.exists(filepath):\n                    try:\n                        if os.path.isdir(filepath):\n                            shutil.copytree(filepath, path)\n                        else:\n                            shutil.copy(filepath, path)\n                        timestamp = datetime.datetime.fromtimestamp(os.path.getmtime(filepath))\n                        self.add_tagfile(path, timestamp)\n                    except PermissionError:\n                        pass  # FIXME: avoids duplicate snapshotting; need better solution\n            elif key in (\"secondaryFiles\", \"listing\"):\n                for files in value:\n                    if isinstance(files, MutableMapping):\n                        self.generate_snapshot(files)\n            else:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npack CWL description to generate re - runnable CWL object in RO.", "response": "def packed_workflow(self, packed):  # type: (Text) -> None\n        \"\"\"Pack CWL description to generate re-runnable CWL object in RO.\"\"\"\n        self.self_check()\n        rel_path = posixpath.join(_posix_path(WORKFLOW), \"packed.cwl\")\n        # Write as binary\n        with self.write_bag_file(rel_path, encoding=None) as write_pack:\n            # YAML is always UTF8, but json.dumps gives us str in py2\n            write_pack.write(packed.encode(ENCODING))\n        _logger.debug(u\"[provenance] Added packed workflow: %s\", rel_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconfirms the presence of the given file in the RO.", "response": "def has_data_file(self, sha1hash):  # type: (str) -> bool\n        \"\"\"Confirms the presence of the given file in the RO.\"\"\"\n        folder = os.path.join(self.folder, DATA, sha1hash[0:2])\n        hash_path = os.path.join(folder, sha1hash)\n        return os.path.isfile(hash_path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a file to the data folder.", "response": "def add_data_file(self, from_fp, timestamp=None, content_type=None):\n        # type: (IO, Optional[datetime.datetime], Optional[str]) -> Text\n        \"\"\"Copy inputs to data/ folder.\"\"\"\n        self.self_check()\n        tmp_dir, tmp_prefix = os.path.split(self.temp_prefix)\n        with tempfile.NamedTemporaryFile(\n                prefix=tmp_prefix, dir=tmp_dir, delete=False) as tmp:\n            checksum = checksum_copy(from_fp, tmp)\n\n        # Calculate hash-based file path\n        folder = os.path.join(self.folder, DATA, checksum[0:2])\n        path = os.path.join(folder, checksum)\n        # os.rename assumed safe, as our temp file should\n        # be in same file system as our temp folder\n        if not os.path.isdir(folder):\n            os.makedirs(folder)\n        os.rename(tmp.name, path)\n\n        # Relative posix path\n        # (to avoid \\ on Windows)\n        rel_path = _posix_path(os.path.relpath(path, self.folder))\n\n        # Register in bagit checksum\n        if Hasher == hashlib.sha1:\n            self._add_to_bagit(rel_path, sha1=checksum)\n        else:\n            _logger.warning(\n                u\"[provenance] Unknown hash method %s for bagit manifest\",\n                Hasher)\n            # Inefficient, bagit support need to checksum again\n            self._add_to_bagit(rel_path)\n        _logger.debug(u\"[provenance] Added data file %s\", path)\n        if timestamp is not None:\n            self._file_provenance[rel_path] = self._self_made(timestamp)\n        _logger.debug(u\"[provenance] Relative path for data file %s\", rel_path)\n\n        if content_type is not None:\n            self._content_types[rel_path] = content_type\n        return rel_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_to_manifest(self, rel_path, checksums):\n        # type: (Text, Dict[str,str]) -> None\n        \"\"\"Add files to the research object manifest.\"\"\"\n        self.self_check()\n        if posixpath.isabs(rel_path):\n            raise ValueError(\"rel_path must be relative: %s\" % rel_path)\n\n        if posixpath.commonprefix([\"data/\", rel_path]) == \"data/\":\n            # payload file, go to manifest\n            manifest = \"manifest\"\n        else:\n            # metadata file, go to tag manifest\n            manifest = \"tagmanifest\"\n\n        # Add checksums to corresponding manifest files\n        for (method, hash_value) in checksums.items():\n            # File not in manifest because we bailed out on\n            # existence in bagged_size above\n            manifestpath = os.path.join(\n                self.folder, \"%s-%s.txt\" % (manifest, method.lower()))\n            # encoding: match Tag-File-Character-Encoding: UTF-8\n            # newline: ensure LF also on Windows\n            with open(manifestpath, \"a\", encoding=ENCODING, newline='\\n') \\\n                    as checksum_file:\n                line = u\"%s  %s\\n\" % (hash_value, rel_path)\n                _logger.debug(u\"[provenance] Added to %s: %s\", manifestpath, line)\n                checksum_file.write(line)", "response": "Add files to the research object manifest."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_job(self,\n                   builder_job,    # type: Dict[Text, Any]\n                   wf_job=None,    # type: Callable[[Dict[Text, Text], Callable[[Any, Any], Any], RuntimeContext], Generator[Any, None, None]]\n                   is_output=False\n                  ):  # type: (...) -> Dict\n        #TODO customise the file\n        \"\"\"Generate the new job object with RO specific relative paths.\"\"\"\n        copied = copy.deepcopy(builder_job)\n        relativised_input_objecttemp = {}  # type: Dict[Text, Any]\n        self._relativise_files(copied)\n        def jdefault(o):\n            return dict(o)\n        if is_output:\n            rel_path = posixpath.join(_posix_path(WORKFLOW), \"primary-output.json\")\n        else:\n            rel_path = posixpath.join(_posix_path(WORKFLOW), \"primary-job.json\")\n        j = json_dumps(copied, indent=4, ensure_ascii=False, default=jdefault)\n        with self.write_bag_file(rel_path) as file_path:\n            file_path.write(j + u\"\\n\")\n        _logger.debug(u\"[provenance] Generated customised job file: %s\",\n                      rel_path)\n        # Generate dictionary with keys as workflow level input IDs and values\n        # as\n        # 1) for files the relativised location containing hash\n        # 2) for other attributes, the actual value.\n        relativised_input_objecttemp = {}\n        for key, value in copied.items():\n            if isinstance(value, MutableMapping):\n                if value.get(\"class\") in (\"File\", \"Directory\"):\n                    relativised_input_objecttemp[key] = value\n            else:\n                relativised_input_objecttemp[key] = value\n        self.relativised_input_object.update(\n            {k: v for k, v in relativised_input_objecttemp.items() if v})\n        return self.relativised_input_object", "response": "Generate the new job object with RO specific relative paths."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _relativise_files(self, structure):\n        # type: (Dict[Any, Any]) -> None\n        \"\"\"Save any file objects into the RO and update the local paths.\"\"\"\n        # Base case - we found a File we need to update\n        _logger.debug(u\"[provenance] Relativising: %s\", structure)\n\n        if isinstance(structure, MutableMapping):\n            if structure.get(\"class\") == \"File\":\n                relative_path = None\n                if \"checksum\" in structure:\n                    alg, checksum = structure[\"checksum\"].split(\"$\")\n                    if alg != SHA1:\n                        raise TypeError(\n                            \"Only SHA1 CWL checksums are currently supported: \"\n                            \"{}\".format(structure))\n                    if self.has_data_file(checksum):\n                        prefix = checksum[0:2]\n                        relative_path = posixpath.join(\n                            \"data\", prefix, checksum)\n\n                if not relative_path is not None and \"location\" in structure:\n                    # Register in RO; but why was this not picked\n                    # up by used_artefacts?\n                    _logger.info(\"[provenance] Adding to RO %s\", structure[\"location\"])\n                    fsaccess = StdFsAccess(\"\")\n                    with fsaccess.open(structure[\"location\"], \"rb\") as fp:\n                        relative_path = self.add_data_file(fp)\n                        checksum = posixpath.basename(relative_path)\n                        structure[\"checksum\"] = \"%s$%s\" % (SHA1, checksum)\n                if relative_path is not None:\n                    # RO-relative path as new location\n                    structure[\"location\"] = posixpath.join(\"..\", relative_path)\n                else:\n                    _logger.warning(\"Could not determine RO path for file %s\", structure)\n                if \"path\" in structure:\n                    del structure[\"path\"]\n\n            if structure.get(\"class\") == \"Directory\":\n                # TODO: Generate anonymoys Directory with a \"listing\"\n                # pointing to the hashed files\n                del structure[\"location\"]\n\n            for val in structure.values():\n                self._relativise_files(val)\n            return\n\n        if isinstance(structure, (str, Text)):\n            # Just a string value, no need to iterate further\n            return\n        try:\n            for obj in iter(structure):\n                # Recurse and rewrite any nested File objects\n                self._relativise_files(obj)\n        except TypeError:\n            pass", "response": "Relativise any files in the RO and update the local paths."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclose the Research Object optionally saving it to specified folder.", "response": "def close(self, save_to=None):\n        # type: (Optional[str]) -> None\n        \"\"\"Close the Research Object, optionally saving to specified folder.\n\n        Closing will remove any temporary files used by this research object.\n        After calling this method, this ResearchObject instance can no longer\n        be used, except for no-op calls to .close().\n\n        The 'saveTo' folder should not exist - if it does, it will be deleted.\n\n        It is safe to call this function multiple times without the\n        'saveTo' argument, e.g. within a try..finally block to\n        ensure the temporary files of this Research Object are removed.\n        \"\"\"\n        if save_to is None:\n            if not self.closed:\n                _logger.debug(u\"[provenance] Deleting temporary %s\", self.folder)\n                shutil.rmtree(self.folder, ignore_errors=True)\n        else:\n            save_to = os.path.abspath(save_to)\n            _logger.info(u\"[provenance] Finalizing Research Object\")\n            self._finalize()  # write manifest etc.\n            # TODO: Write as archive (.zip or .tar) based on extension?\n\n            if os.path.isdir(save_to):\n                _logger.info(u\"[provenance] Deleting existing %s\", save_to)\n                shutil.rmtree(save_to)\n            shutil.move(self.folder, save_to)\n            _logger.info(u\"[provenance] Research Object saved to %s\", save_to)\n            self.folder = save_to\n        self.closed = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef printrdf(wflow, ctx, style):  # type: (Process, ContextType, Text) -> Text\n    rdf = gather(wflow, ctx).serialize(format=style, encoding='utf-8')\n    if not rdf:\n        return u\"\"\n    return rdf.decode('utf-8')", "response": "Serialize the CWL document into a string ready for printing."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_image(dockerRequirement,  # type: Dict[Text, Text]\n                  pull_image,         # type: bool\n                  force_pull=False    # type: bool\n                 ):\n        # type: (...) -> bool\n        \"\"\"\n        Acquire the software container image in the specified dockerRequirement\n        using Singularity and returns the success as a bool. Updates the\n        provided dockerRequirement with the specific dockerImageId to the full\n        path of the local image, if found. Likewise the\n        dockerRequirement['dockerPull'] is updated to a docker:// URI if needed.\n        \"\"\"\n        found = False\n\n        candidates = []\n\n        if \"dockerImageId\" not in dockerRequirement and \"dockerPull\" in dockerRequirement:\n            match = re.search(pattern=r'([a-z]*://)', string=dockerRequirement[\"dockerPull\"])\n            candidate = _normalize_image_id(dockerRequirement['dockerPull'])\n            candidates.append(candidate)\n            dockerRequirement['dockerImageId'] = candidate\n            if not match:\n                dockerRequirement[\"dockerPull\"] = \"docker://\" + dockerRequirement[\"dockerPull\"]\n        elif \"dockerImageId\" in dockerRequirement:\n            candidates.append(dockerRequirement['dockerImageId'])\n            candidates.append(_normalize_image_id(dockerRequirement['dockerImageId']))\n\n        # check if Singularity image is available in $SINGULARITY_CACHEDIR\n        targets = [os.getcwd()]\n        for env in (\"SINGULARITY_CACHEDIR\", \"SINGULARITY_PULLFOLDER\"):\n            if env in os.environ:\n                targets.append(os.environ[env])\n        for target in targets:\n            for candidate in candidates:\n                path = os.path.join(target, candidate)\n                if os.path.isfile(path):\n                    _logger.info(\n                        \"Using local copy of Singularity image found in %s\",\n                        target)\n                    dockerRequirement[\"dockerImageId\"] = path\n                    found = True\n\n        if (force_pull or not found) and pull_image:\n            cmd = []  # type: List[Text]\n            if \"dockerPull\" in dockerRequirement:\n                cmd = [\"singularity\", \"pull\", \"--force\", \"--name\",\n                       str(dockerRequirement[\"dockerImageId\"]),\n                       str(dockerRequirement[\"dockerPull\"])]\n                _logger.info(Text(cmd))\n                check_call(cmd, stdout=sys.stderr)  # nosec\n                found = True\n            elif \"dockerFile\" in dockerRequirement:\n                raise WorkflowException(SourceLine(\n                    dockerRequirement, 'dockerFile').makeError(\n                        \"dockerFile is not currently supported when using the \"\n                        \"Singularity runtime for Docker containers.\"))\n            elif \"dockerLoad\" in dockerRequirement:\n                raise WorkflowException(SourceLine(\n                    dockerRequirement, 'dockerLoad').makeError(\n                        \"dockerLoad is not currently supported when using the \"\n                        \"Singularity runtime for Docker containers.\"))\n            elif \"dockerImport\" in dockerRequirement:\n                raise WorkflowException(SourceLine(\n                    dockerRequirement, 'dockerImport').makeError(\n                        \"dockerImport is not currently supported when using the \"\n                        \"Singularity runtime for Docker containers.\"))\n\n        return found", "response": "Get the software container image from the specified dockerRequirement."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_from_requirements(self,\n                              r,                      # type: Dict[Text, Text]\n                              pull_image,             # type: bool\n                              force_pull=False,       # type: bool\n                              tmp_outdir_prefix=None  # type: Text\n                             ):\n        # type: (...) -> Optional[Text]\n        \"\"\"\n        Returns the filename of the Singularity image (e.g.\n        hello-world-latest.img).\n        \"\"\"\n\n        if not bool(spawn.find_executable('singularity')):\n            raise WorkflowException('singularity executable is not available')\n\n        if not self.get_image(r, pull_image, force_pull):\n            raise WorkflowException(u\"Container image {} not \"\n                                    \"found\".format(r[\"dockerImageId\"]))\n\n        return os.path.abspath(r[\"dockerImageId\"])", "response": "Returns the image name of the container image."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_runtime(self,\n                       env,            # type: MutableMapping[Text, Text]\n                       runtime_context  # type: RuntimeContext\n                      ):  # type: (...) -> Tuple[List, Optional[Text]]\n        \"\"\" Returns the Singularity runtime list of commands and options.\"\"\"\n        any_path_okay = self.builder.get_requirement(\"DockerRequirement\")[1] \\\n            or False\n        runtime = [u\"singularity\", u\"--quiet\", u\"exec\", u\"--contain\", u\"--pid\",\n                   u\"--ipc\"]\n        if _singularity_supports_userns():\n            runtime.append(u\"--userns\")\n        runtime.append(u\"--bind\")\n        runtime.append(u\"{}:{}:rw\".format(\n            docker_windows_path_adjust(os.path.realpath(self.outdir)),\n            self.builder.outdir))\n        runtime.append(u\"--bind\")\n        tmpdir = \"/tmp\"  # nosec\n        runtime.append(u\"{}:{}:rw\".format(\n            docker_windows_path_adjust(os.path.realpath(self.tmpdir)), tmpdir))\n\n        self.add_volumes(self.pathmapper, runtime, any_path_okay=True,\n                         secret_store=runtime_context.secret_store,\n                         tmpdir_prefix=runtime_context.tmpdir_prefix)\n        if self.generatemapper is not None:\n            self.add_volumes(\n                self.generatemapper, runtime, any_path_okay=any_path_okay,\n                secret_store=runtime_context.secret_store,\n                tmpdir_prefix=runtime_context.tmpdir_prefix)\n\n        runtime.append(u\"--pwd\")\n        runtime.append(u\"%s\" % (docker_windows_path_adjust(self.builder.outdir)))\n\n        if runtime_context.custom_net:\n            raise UnsupportedRequirement(\n                \"Singularity implementation does not support custom networking\")\n        elif runtime_context.disable_net:\n            runtime.append(u\"--net\")\n\n        env[\"SINGULARITYENV_TMPDIR\"] = tmpdir\n        env[\"SINGULARITYENV_HOME\"] = self.builder.outdir\n\n        for name, value in self.environment.items():\n            env[\"SINGULARITYENV_{}\".format(name)] = str(value)\n        return (runtime, None)", "response": "Creates the Singularity runtime list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_output_and_strip(cmd):  # type: (List[Text]) -> Optional[Text]\n    try:\n        result = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return result.strip()\n    except (OSError, subprocess.CalledProcessError, TypeError, AttributeError):\n        # OSError is raised if command doesn't exist\n        # CalledProcessError is raised if command returns nonzero\n        # AttributeError is raised if result cannot be strip()ped\n        return None", "response": "Executes a command and returns the output of the command."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef docker_machine_id():  # type: () -> Tuple[Optional[int], Optional[int]]\n    machine_name = docker_machine_name()\n    if not machine_name:\n        return (None, None)\n    uid = cmd_output_to_int(['docker-machine', 'ssh', machine_name, \"id -u\"])\n    gid = cmd_output_to_int(['docker-machine', 'ssh', machine_name, \"id -g\"])\n    return (uid, gid)", "response": "Asks docker - machine for active machine and gets the UID of the docker user\n    inside the vm\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a CWL document.", "response": "def fetch_document(argsworkflow,        # type: Union[Text, Dict[Text, Any]]\n                   loadingContext=None  # type: Optional[LoadingContext]\n                  ):  # type: (...) -> Tuple[LoadingContext, CommentedMap, Text]\n    \"\"\"Retrieve a CWL document.\"\"\"\n\n    if loadingContext is None:\n        loadingContext = LoadingContext()\n        loadingContext.loader = default_loader()\n    else:\n        loadingContext = loadingContext.copy()\n        if loadingContext.loader is None:\n            loadingContext.loader = default_loader(loadingContext.fetcher_constructor)\n\n    if isinstance(argsworkflow, string_types):\n        uri, fileuri = resolve_tool_uri(argsworkflow,\n                                        resolver=loadingContext.resolver,\n                                        document_loader=loadingContext.loader)\n        workflowobj = loadingContext.loader.fetch(fileuri)\n        return loadingContext, workflowobj, uri\n    if isinstance(argsworkflow, dict):\n        uri = argsworkflow[\"id\"] if argsworkflow.get(\"id\") else \"_:\" + Text(uuid.uuid4())\n        workflowobj = cast(CommentedMap, cmap(argsworkflow, fn=uri))\n        loadingContext.loader.idx[uri] = workflowobj\n        return loadingContext, workflowobj, uri\n    raise ValidationException(\"Must be URI or object: '%s'\" % argsworkflow)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve a CWL document and validate it.", "response": "def resolve_and_validate_document(loadingContext,\n                      workflowobj,\n                      uri,\n                      preprocess_only=False,     # type: bool\n                      skip_schemas=None,         # type: bool\n                     ):\n    # type: (...) -> Tuple[LoadingContext, Text]\n    \"\"\"Validate a CWL document.\"\"\"\n\n    loadingContext = loadingContext.copy()\n\n    if not isinstance(workflowobj, MutableMapping):\n        raise ValueError(\"workflowjobj must be a dict, got '{}': {}\".format(\n            type(workflowobj), workflowobj))\n\n    jobobj = None\n    if \"cwl:tool\" in workflowobj:\n        jobobj, _ = loadingContext.loader.resolve_all(workflowobj, uri, checklinks=loadingContext.do_validate)\n        uri = urllib.parse.urljoin(uri, workflowobj[\"https://w3id.org/cwl/cwl#tool\"])\n        del cast(dict, jobobj)[\"https://w3id.org/cwl/cwl#tool\"]\n\n        workflowobj = fetch_document(uri, loadingContext)[1]\n\n    fileuri = urllib.parse.urldefrag(uri)[0]\n\n    cwlVersion = loadingContext.metadata.get(\"cwlVersion\")\n    if not cwlVersion:\n        cwlVersion = workflowobj.get(\"cwlVersion\")\n    if not cwlVersion:\n        raise ValidationException(\n            \"No cwlVersion found. \"\n            \"Use the following syntax in your CWL document to declare \"\n            \"the version: cwlVersion: <version>.\\n\"\n            \"Note: if this is a CWL draft-2 (pre v1.0) document then it \"\n            \"will need to be upgraded first.\")\n\n    if not isinstance(cwlVersion, string_types):\n        with SourceLine(workflowobj, \"cwlVersion\", ValidationException):\n            raise ValidationException(\"'cwlVersion' must be a string, \"\n                                      \"got {}\".format(\n                                          type(cwlVersion)))\n    # strip out version\n    cwlVersion = re.sub(\n        r\"^(?:cwl:|https://w3id.org/cwl/cwl#)\", \"\",\n        cwlVersion)\n    if cwlVersion not in list(ALLUPDATES):\n        # print out all the Supported Versions of cwlVersion\n        versions = []\n        for version in list(ALLUPDATES):\n            if \"dev\" in version:\n                version += \" (with --enable-dev flag only)\"\n            versions.append(version)\n        versions.sort()\n        raise ValidationException(\n            \"The CWL reference runner no longer supports pre CWL v1.0 \"\n            \"documents. Supported versions are: \"\n            \"\\n{}\".format(\"\\n\".join(versions)))\n\n    if isinstance(jobobj, CommentedMap) and \"http://commonwl.org/cwltool#overrides\" in jobobj:\n        loadingContext.overrides_list.extend(resolve_overrides(jobobj, uri, uri))\n        del jobobj[\"http://commonwl.org/cwltool#overrides\"]\n\n    if isinstance(jobobj, CommentedMap) and \"https://w3id.org/cwl/cwl#requirements\" in jobobj:\n        if cwlVersion not in (\"v1.1.0-dev1\",):\n            raise ValidationException(\n                    \"`cwl:requirements` in the input object is not part of CWL \"\n                    \"v1.0. You can adjust to use `cwltool:overrides` instead; or you \"\n                    \"can set the cwlVersion to v1.1.0-dev1 or greater and re-run with \"\n                    \"--enable-dev.\")\n        loadingContext.overrides_list.append({\"overrideTarget\": uri,\n                                              \"requirements\": jobobj[\"https://w3id.org/cwl/cwl#requirements\"]})\n        del jobobj[\"https://w3id.org/cwl/cwl#requirements\"]\n\n    (sch_document_loader, avsc_names) = \\\n        process.get_schema(cwlVersion)[:2]\n\n    if isinstance(avsc_names, Exception):\n        raise avsc_names\n\n    processobj = None  # type: Union[CommentedMap, CommentedSeq, Text, None]\n    document_loader = Loader(sch_document_loader.ctx,\n                             schemagraph=sch_document_loader.graph,\n                             idx=loadingContext.loader.idx,\n                             cache=sch_document_loader.cache,\n                             fetcher_constructor=loadingContext.fetcher_constructor,\n                             skip_schemas=skip_schemas)\n\n    if cwlVersion == \"v1.0\":\n        _add_blank_ids(workflowobj)\n\n    workflowobj[\"id\"] = fileuri\n    processobj, metadata = document_loader.resolve_all(\n        workflowobj, fileuri, checklinks=loadingContext.do_validate)\n    if loadingContext.metadata:\n        metadata = loadingContext.metadata\n    if not isinstance(processobj, (CommentedMap, CommentedSeq)):\n        raise ValidationException(\"Workflow must be a CommentedMap or CommentedSeq.\")\n    if not isinstance(metadata, CommentedMap):\n        raise ValidationException(\"metadata must be a CommentedMap, was %s\" % type(metadata))\n\n    _convert_stdstreams_to_files(workflowobj)\n\n    if preprocess_only:\n        return loadingContext, uri\n\n    if loadingContext.do_validate:\n        schema.validate_doc(avsc_names, processobj, document_loader, loadingContext.strict)\n\n    # None means default behavior (do update)\n    if loadingContext.do_update in (True, None):\n        processobj = cast(CommentedMap, cmap(update.update(\n            processobj, document_loader, fileuri, loadingContext.enable_dev, metadata)))\n        if isinstance(processobj, MutableMapping):\n            document_loader.idx[processobj[\"id\"]] = processobj\n        elif isinstance(processobj, MutableSequence):\n            document_loader.idx[metadata[\"id\"]] = metadata\n            for po in processobj:\n                document_loader.idx[po[\"id\"]] = po\n\n    if jobobj is not None:\n        loadingContext.jobdefaults = jobobj\n\n    loadingContext.loader = document_loader\n    loadingContext.avsc_names = avsc_names\n    loadingContext.metadata = metadata\n\n    return loadingContext, uri"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_tool(uri,                # type: Union[Text, CommentedMap, CommentedSeq]\n              loadingContext      # type: LoadingContext\n             ):  # type: (...) -> Process\n    \"\"\"Make a Python CWL object.\"\"\"\n    if loadingContext.loader is None:\n        raise ValueError(\"loadingContext must have a loader\")\n    resolveduri, metadata = loadingContext.loader.resolve_ref(uri)\n\n    processobj = None\n    if isinstance(resolveduri, MutableSequence):\n        for obj in resolveduri:\n            if obj['id'].endswith('#main'):\n                processobj = obj\n                break\n        if not processobj:\n            raise WorkflowException(\n                u\"Tool file contains graph of multiple objects, must specify \"\n                \"one of #%s\" % \", #\".join(\n                    urllib.parse.urldefrag(i[\"id\"])[1] for i in resolveduri\n                    if \"id\" in i))\n    elif isinstance(resolveduri, MutableMapping):\n        processobj = resolveduri\n    else:\n        raise Exception(\"Must resolve to list or dict\")\n\n    tool = loadingContext.construct_tool_object(processobj, loadingContext)\n\n    if loadingContext.jobdefaults:\n        jobobj = loadingContext.jobdefaults\n        for inp in tool.tool[\"inputs\"]:\n            if shortname(inp[\"id\"]) in jobobj:\n                inp[\"default\"] = jobobj[shortname(inp[\"id\"])]\n\n    return tool", "response": "Make a Python CWL object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_adjust(builder, file_o):\n    # type: (Builder, Dict[Text, Any]) -> Dict[Text, Any]\n    \"\"\"\n    Map files to assigned path inside a container.\n\n    We need to also explicitly walk over input, as implicit reassignment\n    doesn't reach everything in builder.bindings\n    \"\"\"\n\n    if not builder.pathmapper:\n            raise ValueError(\"Do not call check_adjust using a builder that doesn't have a pathmapper.\")\n    file_o[\"path\"] = docker_windows_path_adjust(\n        builder.pathmapper.mapper(file_o[\"location\"])[1])\n    dn, bn = os.path.split(file_o[\"path\"])\n    if file_o.get(\"dirname\") != dn:\n        file_o[\"dirname\"] = Text(dn)\n    if file_o.get(\"basename\") != bn:\n        file_o[\"basename\"] = Text(bn)\n    if file_o[\"class\"] == \"File\":\n        nr, ne = os.path.splitext(file_o[\"basename\"])\n        if file_o.get(\"nameroot\") != nr:\n            file_o[\"nameroot\"] = Text(nr)\n        if file_o.get(\"nameext\") != ne:\n            file_o[\"nameext\"] = Text(ne)\n    if not ACCEPTLIST_RE.match(file_o[\"basename\"]):\n        raise WorkflowException(\n            \"Invalid filename: '{}' contains illegal characters\".format(\n                file_o[\"basename\"]))\n    return file_o", "response": "Check that the file_o has the correct path and path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _flat_crossproduct_scatter(process,        # type: WorkflowJobStep\n                               joborder,       # type: MutableMapping[Text, Any]\n                               scatter_keys,   # type: MutableSequence[Text]\n                               callback,       # type: ReceiveScatterOutput\n                               startindex,     # type: int\n                               runtimeContext  # type: RuntimeContext\n                              ):  # type: (...) -> Tuple[List[Generator], int]\n    \"\"\" Inner loop. \"\"\"\n    scatter_key = scatter_keys[0]\n    jobl = len(joborder[scatter_key])\n    steps = []\n    put = startindex\n    for index in range(0, jobl):\n        sjob = copy.copy(joborder)\n        sjob[scatter_key] = joborder[scatter_key][index]\n\n        if len(scatter_keys) == 1:\n            if runtimeContext.postScatterEval is not None:\n                sjob = runtimeContext.postScatterEval(sjob)\n            steps.append(process.job(\n                sjob, functools.partial(callback.receive_scatter_output, put),\n                runtimeContext))\n            put += 1\n        else:\n            (add, _) = _flat_crossproduct_scatter(\n                process, sjob, scatter_keys[1:], callback, put, runtimeContext)\n            put += len(add)\n            steps.extend(add)\n\n    return (steps, put)", "response": "Inner loop for the crossproduct scattering."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining if fmt is a subclass of cls.", "response": "def formatSubclassOf(fmt, cls, ontology, visited):\n    # type: (Text, Text, Optional[Graph], Set[Text]) -> bool\n    \"\"\"Determine if `fmt` is a subclass of `cls`.\"\"\"\n\n    if URIRef(fmt) == URIRef(cls):\n        return True\n\n    if ontology is None:\n        return False\n\n    if fmt in visited:\n        return False\n\n    visited.add(fmt)\n\n    uriRefFmt = URIRef(fmt)\n\n    for s, p, o in ontology.triples((uriRefFmt, RDFS.subClassOf, None)):\n        # Find parent classes of `fmt` and search upward\n        if formatSubclassOf(o, cls, ontology, visited):\n            return True\n\n    for s, p, o in ontology.triples((uriRefFmt, OWL.equivalentClass, None)):\n        # Find equivalent classes of `fmt` and search horizontally\n        if formatSubclassOf(o, cls, ontology, visited):\n            return True\n\n    for s, p, o in ontology.triples((None, OWL.equivalentClass, uriRefFmt)):\n        # Find equivalent classes of `fmt` and search horizontally\n        if formatSubclassOf(s, cls, ontology, visited):\n            return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck that the format present in the file is valid for the allowed formats.", "response": "def check_format(actual_file,    # type: Union[Dict[Text, Any], List, Text]\n                 input_formats,  # type: Union[List[Text], Text]\n                 ontology        # type: Optional[Graph]\n                ):  # type: (...) -> None\n    \"\"\" Confirms that the format present is valid for the allowed formats.\"\"\"\n    for afile in aslist(actual_file):\n        if not afile:\n            continue\n        if \"format\" not in afile:\n            raise validate.ValidationException(\n                u\"File has no 'format' defined: {}\".format(\n                    json_dumps(afile, indent=4)))\n        for inpf in aslist(input_formats):\n            if afile[\"format\"] == inpf or \\\n                    formatSubclassOf(afile[\"format\"], inpf, ontology, set()):\n                return\n        raise validate.ValidationException(\n            u\"File has an incompatible format: {}\".format(\n                json_dumps(afile, indent=4)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking the validity of the version of the give CWL document.", "response": "def checkversion(doc,        # type: Union[CommentedSeq, CommentedMap]\n                 metadata,   # type: CommentedMap\n                 enable_dev  # type: bool\n):\n    # type: (...) -> Tuple[Union[CommentedSeq, CommentedMap], Text]\n    \"\"\"Checks the validity of the version of the give CWL document.\n\n    Returns the document and the validated version string.\n    \"\"\"\n\n    cdoc = None  # type: Optional[CommentedMap]\n    if isinstance(doc, CommentedSeq):\n        if not isinstance(metadata, CommentedMap):\n            raise Exception(\"Expected metadata to be CommentedMap\")\n        lc = metadata.lc\n        metadata = copy.deepcopy(metadata)\n        metadata.lc.data = copy.copy(lc.data)\n        metadata.lc.filename = lc.filename\n        metadata[u\"$graph\"] = doc\n        cdoc = metadata\n    elif isinstance(doc, CommentedMap):\n        cdoc = doc\n    else:\n        raise Exception(\"Expected CommentedMap or CommentedSeq\")\n\n    version = metadata[u\"cwlVersion\"]\n    cdoc[\"cwlVersion\"] = version\n\n    if version not in UPDATES:\n        if version in DEVUPDATES:\n            if enable_dev:\n                pass\n            else:\n                raise validate.ValidationException(\n                    u\"Version '%s' is a development or deprecated version.\\n \"\n                    \"Update your document to a stable version (%s) or use \"\n                    \"--enable-dev to enable support for development and \"\n                    \"deprecated versions.\" % (version, \", \".join(\n                        list(UPDATES.keys()))))\n        else:\n            raise validate.ValidationException(\n                u\"Unrecognized version %s\" % version)\n\n    return (cdoc, version)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_js_threshold_version(working_alias):\n    # type: (str) -> bool\n\n    \"\"\"Checks if the nodeJS engine version on the system\n    with the allowed minimum version.\n    https://github.com/nodejs/node/blob/master/CHANGELOG.md#nodejs-changelog\n    \"\"\"\n    # parse nodejs version into int Tuple: 'v4.2.6\\n' -> [4, 2, 6]\n    current_version_str = subprocess.check_output(\n        [working_alias, \"-v\"]).decode('utf-8')\n\n    current_version = [int(v) for v in current_version_str.strip().strip('v').split('.')]\n    minimum_node_version = [int(v) for v in minimum_node_version_str.split('.')]\n\n    return current_version >= minimum_node_version", "response": "Checks if the nodeJS engine version on the system\n    with the allowed minimum version."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlinks or copy files to their targets. Create them as needed.", "response": "def stage_files(pathmapper,             # type: PathMapper\n                stage_func=None,        # type: Callable[..., Any]\n                ignore_writable=False,  # type: bool\n                symlink=True,           # type: bool\n                secret_store=None       # type: SecretStore\n               ):  # type: (...) -> None\n    \"\"\"Link or copy files to their targets. Create them as needed.\"\"\"\n    for key, entry in pathmapper.items():\n        if not entry.staged:\n            continue\n        if not os.path.exists(os.path.dirname(entry.target)):\n            os.makedirs(os.path.dirname(entry.target))\n        if entry.type in (\"File\", \"Directory\") and os.path.exists(entry.resolved):\n            if symlink:  # Use symlink func if allowed\n                if onWindows():\n                    if entry.type == \"File\":\n                        shutil.copy(entry.resolved, entry.target)\n                    elif entry.type == \"Directory\":\n                        if os.path.exists(entry.target) \\\n                                and os.path.isdir(entry.target):\n                            shutil.rmtree(entry.target)\n                        copytree_with_merge(entry.resolved, entry.target)\n                else:\n                    os.symlink(entry.resolved, entry.target)\n            elif stage_func is not None:\n                stage_func(entry.resolved, entry.target)\n        elif entry.type == \"Directory\" and not os.path.exists(entry.target) \\\n                and entry.resolved.startswith(\"_:\"):\n            os.makedirs(entry.target)\n        elif entry.type == \"WritableFile\" and not ignore_writable:\n            shutil.copy(entry.resolved, entry.target)\n            ensure_writable(entry.target)\n        elif entry.type == \"WritableDirectory\" and not ignore_writable:\n            if entry.resolved.startswith(\"_:\"):\n                os.makedirs(entry.target)\n            else:\n                shutil.copytree(entry.resolved, entry.target)\n                ensure_writable(entry.target)\n        elif entry.type == \"CreateFile\" or entry.type == \"CreateWritableFile\":\n            with open(entry.target, \"wb\") as new:\n                if secret_store is not None:\n                    new.write(\n                        secret_store.retrieve(entry.resolved).encode(\"utf-8\"))\n                else:\n                    new.write(entry.resolved.encode(\"utf-8\"))\n            if entry.type == \"CreateFile\":\n                os.chmod(entry.target, stat.S_IRUSR)  # Read only\n            else:  # it is a \"CreateWritableFile\"\n                ensure_writable(entry.target)\n            pathmapper.update(\n                key, entry.target, entry.target, entry.type, entry.staged)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef avroize_type(field_type, name_prefix=\"\"):\n    # type: (Union[List[Dict[Text, Any]], Dict[Text, Any]], Text) -> Any\n    \"\"\"\n    adds missing information to a type so that CWL types are valid in schema_salad.\n    \"\"\"\n    if isinstance(field_type, MutableSequence):\n        for field in field_type:\n            avroize_type(field, name_prefix)\n    elif isinstance(field_type, MutableMapping):\n        if field_type[\"type\"] in (\"enum\", \"record\"):\n            if \"name\" not in field_type:\n                field_type[\"name\"] = name_prefix + Text(uuid.uuid4())\n        if field_type[\"type\"] == \"record\":\n            avroize_type(field_type[\"fields\"], name_prefix)\n        if field_type[\"type\"] == \"array\":\n            avroize_type(field_type[\"items\"], name_prefix)\n        if isinstance(field_type[\"type\"], MutableSequence):\n            for ctype in field_type[\"type\"]:\n                avroize_type(ctype, name_prefix)\n    return field_type", "response": "adds missing information to a type so that CWL types are valid in schema_salad."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetecting any textual reference to the cwl file.", "response": "def var_spool_cwl_detector(obj,           # type: Union[MutableMapping, List, Text]\n                           item=None,     # type: Optional[Any]\n                           obj_key=None,  # type: Optional[Any]\n                          ):              # type: (...)->bool\n    \"\"\" Detects any textual reference to /var/spool/cwl. \"\"\"\n    r = False\n    if isinstance(obj, string_types):\n        if \"var/spool/cwl\" in obj and obj_key != \"dockerOutputDirectory\":\n            _logger.warning(\n                SourceLine(item=item, key=obj_key, raise_type=Text).makeError(\n                    _VAR_SPOOL_ERROR.format(obj)))\n            r = True\n    elif isinstance(obj, MutableMapping):\n        for key, value in iteritems(obj):\n            r = var_spool_cwl_detector(value, obj, key) or r\n    elif isinstance(obj, MutableSequence):\n        for key, value in enumerate(obj):\n            r = var_spool_cwl_detector(value, obj, key) or r\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef versionstring():\n    # type: () -> Text\n    '''\n    version of CWLtool used to execute the workflow.\n    '''\n    pkg = pkg_resources.require(\"cwltool\")\n    if pkg:\n        return u\"%s %s\" % (sys.argv[0], pkg[0].version)\n    return u\"%s %s\" % (sys.argv[0], \"unknown version\")", "response": "Returns a version string for the CWLtool tool used to execute the workflow."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef docker_windows_path_adjust(path):\n    # type: (Text) -> Text\n    r\"\"\"\n    Changes only windows paths so that the can be appropriately passed to the\n    docker run command as as docker treats them as unix paths.\n\n    Example: 'C:\\Users\\foo to /C/Users/foo (Docker for Windows) or /c/Users/foo\n    (Docker toolbox).\n    \"\"\"\n    if onWindows():\n        split = path.split(':')\n        if len(split) == 2:\n            if platform.win32_ver()[0] in ('7', '8'):  # type: ignore\n                split[0] = split[0].lower()  # Docker toolbox uses lowecase windows Drive letters\n            else:\n                split[0] = split[0].capitalize()\n                # Docker for Windows uses uppercase windows Drive letters\n            path = ':'.join(split)\n        path = path.replace(':', '').replace('\\\\', '/')\n        return path if path[0] == '/' else '/' + path\n    return path", "response": "Adjusts windows paths so that the can be appropriately passed to docker run command as docker treats them as unix paths."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmp_like_py2(dict1, dict2):  # type: (Dict[Text, Any], Dict[Text, Any]) -> int\n    # extract lists from both dicts\n    first, second = dict1[\"position\"], dict2[\"position\"]\n    # iterate through both list till max of their size\n    for i, j in zip_longest(first, second):\n        if i == j:\n            continue\n        # in case 1st list is smaller\n        # should come first in sorting\n        if i is None:\n            return -1\n        # if 1st list is longer,\n        # it should come later in sort\n        elif j is None:\n            return 1\n\n        # if either of the list contains str element\n        # at any index, both should be str before comparing\n        if isinstance(i, str) or isinstance(j, str):\n            return 1 if str(i) > str(j) else -1\n        # int comparison otherwise\n        return 1 if i > j else -1\n    # if both lists are equal\n    return 0", "response": "Returns 1 if dict1 < dict2 0 otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bytes2str_in_dicts(inp  # type: Union[MutableMapping[Text, Any], MutableSequence[Any], Any]\n                      ):\n    # type: (...) -> Union[Text, MutableSequence[Any], MutableMapping[Text, Any]]\n    \"\"\"\n    Convert any present byte string to unicode string, inplace.\n    input is a dict of nested dicts and lists\n    \"\"\"\n\n    # if input is dict, recursively call for each value\n    if isinstance(inp, MutableMapping):\n        for k in inp:\n            inp[k] = bytes2str_in_dicts(inp[k])\n        return inp\n\n    # if list, iterate through list and fn call\n    # for all its elements\n    if isinstance(inp, MutableSequence):\n        for idx, value in enumerate(inp):\n            inp[idx] = bytes2str_in_dicts(value)\n            return inp\n\n    # if value is bytes, return decoded string,\n    elif isinstance(inp, bytes):\n        return inp.decode('utf-8')\n\n    # simply return elements itself\n    return inp", "response": "Convert any present byte string to unicode string inplace."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying a function to with class in cls.", "response": "def visit_class(rec, cls, op):\n    # type: (Any, Iterable, Union[Callable[..., Any], partial[Any]]) -> None\n    \"\"\"Apply a function to with \"class\" in cls.\"\"\"\n\n    if isinstance(rec, MutableMapping):\n        if \"class\" in rec and rec.get(\"class\") in cls:\n            op(rec)\n        for d in rec:\n            visit_class(rec[d], cls, op)\n    if isinstance(rec, MutableSequence):\n        for d in rec:\n            visit_class(d, cls, op)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies a function to mapping with field.", "response": "def visit_field(rec, field, op):\n    # type: (Any, Iterable, Union[Callable[..., Any], partial[Any]]) -> None\n    \"\"\"Apply a function to mapping with 'field'.\"\"\"\n\n    if isinstance(rec, MutableMapping):\n        if field in rec:\n            rec[field] = op(rec[field])\n        for d in rec:\n            visit_field(rec[d], field, op)\n    if isinstance(rec, MutableSequence):\n        for d in rec:\n            visit_field(d, field, op)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the random directory name chosen to use for tool / workflow output", "response": "def random_outdir():  # type: () -> Text\n    \"\"\" Return the random directory name chosen to use for tool / workflow output \"\"\"\n    # compute this once and store it as a function attribute - each subsequent call will return the same value\n    if not hasattr(random_outdir, 'outdir'):\n        random_outdir.outdir = '/' + ''.join([random.choice(string.ascii_letters) for _ in range(6)])  # type: ignore  # nosec\n    return random_outdir.outdir"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint a numeric result in various forms.", "response": "def print_num(num):\n    ''' Write a numeric result in various forms '''\n    out('hex: 0x{0:08x}'.format(num))\n    out('dec:   {0:d}'.format(num))\n    out('oct: 0o{0:011o}'.format(num))\n    out('bin: 0b{0:032b}'.format(num))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parser():\n    ''' Return the command-line parser '''\n    parser = argparse.ArgumentParser(\n        description=\"Reverse, undo, and calculate CRC32 checksums\")\n    subparsers = parser.add_subparsers(metavar='action')\n\n    poly_flip_parser = argparse.ArgumentParser(add_help=False)\n    subparser_group = poly_flip_parser.add_mutually_exclusive_group()\n    subparser_group.add_argument(\n        '-m', '--msbit', dest=\"msb\", action='store_true',\n        help='treat the polynomial as normal (msbit-first)')\n    subparser_group.add_argument('-l', '--lsbit', action='store_false',\n                                 help='treat the polynomial as reversed (lsbit-first) [default]')\n\n    desired_poly_parser = argparse.ArgumentParser(add_help=False)\n    desired_poly_parser.add_argument(\n        'desired', type=str, help='[int] desired checksum')\n\n    default_poly_parser = argparse.ArgumentParser(add_help=False)\n    default_poly_parser.add_argument(\n        'poly', default='0xEDB88320', type=str, nargs='?',\n        help='[int] polynomial [default: 0xEDB88320]')\n\n    accum_parser = argparse.ArgumentParser(add_help=False)\n    accum_parser.add_argument(\n        'accum', type=str, help='[int] accumulator (final checksum)')\n\n    default_accum_parser = argparse.ArgumentParser(add_help=False)\n    default_accum_parser.add_argument(\n        'accum', default='0', type=str, nargs='?',\n        help='[int] starting accumulator [default: 0]')\n\n    outfile_parser = argparse.ArgumentParser(add_help=False)\n    outfile_parser.add_argument('-o', '--outfile',\n                                metavar=\"f\",\n                                type=argparse.FileType('w'),\n                                default=sys.stdout,\n                                help=\"Output to a file instead of stdout\")\n\n    infile_parser = argparse.ArgumentParser(add_help=False)\n    subparser_group = infile_parser.add_mutually_exclusive_group()\n    subparser_group.add_argument('-i', '--infile',\n                                 metavar=\"f\",\n                                 type=argparse.FileType('rb'),\n                                 default=sys.stdin,\n                                 help=\"Input from a file instead of stdin\")\n    subparser_group.add_argument('-s', '--str',\n                                 metavar=\"s\",\n                                 type=str,\n                                 default='',\n                                 dest='instr',\n                                 help=\"Use a string as input\")\n\n    subparser = subparsers.add_parser('flip', parents=[outfile_parser],\n                                      help=\"flip the bits to convert normal(msbit-first) polynomials to reversed (lsbit-first) and vice versa\")\n    subparser.add_argument('poly', type=str, help='[int] polynomial')\n    subparser.set_defaults(\n        func=lambda: print_num(reverseBits(parse_dword(args.poly))))\n\n    subparser = subparsers.add_parser('reciprocal', parents=[outfile_parser],\n                                      help=\"find the reciprocal (Koopman notation) of a reversed (lsbit-first) polynomial and vice versa\")\n    subparser.add_argument('poly', type=str, help='[int] polynomial')\n    subparser.set_defaults(func=reciprocal_callback)\n\n    subparser = subparsers.add_parser('table', parents=[outfile_parser,\n                                                        poly_flip_parser,\n                                                        default_poly_parser],\n                                      help=\"generate a lookup table for a polynomial\")\n    subparser.set_defaults(func=table_callback)\n\n    subparser = subparsers.add_parser('reverse', parents=[\n        outfile_parser,\n        poly_flip_parser,\n        desired_poly_parser,\n        default_accum_parser,\n        default_poly_parser],\n        help=\"find a patch that causes the CRC32 checksum to become a desired value\")\n    subparser.set_defaults(func=reverse_callback)\n\n    subparser = subparsers.add_parser('undo', parents=[\n        outfile_parser,\n        poly_flip_parser,\n        accum_parser,\n        default_poly_parser,\n        infile_parser],\n        help=\"rewind a CRC32 checksum\")\n    subparser.add_argument('-n', '--len', metavar='l', type=str,\n                           default='0', help='[int] number of bytes to rewind [default: 0]')\n    subparser.set_defaults(func=undo_callback)\n\n    subparser = subparsers.add_parser('calc', parents=[\n        outfile_parser,\n        poly_flip_parser,\n        default_accum_parser,\n        default_poly_parser,\n        infile_parser],\n        help=\"calculate the CRC32 checksum\")\n    subparser.set_defaults(func=calc_callback)\n\n    return parser", "response": "Returns the command - line parser for the\n    command"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the program and handles command line options", "response": "def main(argv=None):\n    ''' Runs the program and handles command line options '''\n    parser = get_parser()\n\n    # Parse arguments and run the function\n    global args\n    args = parser.parse_args(argv)\n    args.func()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the value of the tinytag field by name", "response": "def _set_field(self, fieldname, bytestring, transfunc=None):\n        \"\"\"convienience function to set fields of the tinytag by name.\n        the payload (bytestring) can be changed using the transfunc\"\"\"\n        if getattr(self, fieldname):  # do not overwrite existing data\n            return\n        value = bytestring if transfunc is None else transfunc(bytestring)\n        if DEBUG:\n            stderr('Setting field \"%s\" to \"%s\"' % (fieldname, value))\n        if fieldname == 'genre' and value.isdigit() and int(value) < len(ID3.ID3V1_GENRES):\n            # funky: id3v1 genre hidden in a id3v2 field\n            value = ID3.ID3V1_GENRES[int(value)]\n        if fieldname in (\"track\", \"disc\"):\n            if type(value).__name__ in ('str', 'unicode') and '/' in value:\n                current, total = value.split('/')[:2]\n                setattr(self, \"%s_total\" % fieldname, total)\n            else:\n                current = value\n            setattr(self, fieldname, current)\n        else:\n            setattr(self, fieldname, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetch(self, card_id, data={}, **kwargs):\n        return super(Card, self).fetch(card_id, data, **kwargs)", "response": "Fetch a specific object from the cache"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all(self, data={}, **kwargs):\n        return super(VirtualAccount, self).all(data, **kwargs)", "response": "Fetch all Virtual Account entities\n\n        Returns a dictionary of Virtual Account data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch Virtual Account for given Id", "response": "def fetch(self, virtual_account_id, data={}, **kwargs):\n        \"\"\"\"\n        Fetch Virtual Account for given Id\n\n        Args:\n            virtual_account_id :\n                Id for which Virtual Account object has to be retrieved\n\n        Returns:\n            Virtual Account dict for given Virtual Account Id\n        \"\"\"\n        return super(VirtualAccount, self).fetch(\n            virtual_account_id,\n            data,\n            **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates Virtual Account from given dict Args: Param for Creating Virtual Account Returns: Virtual Account dict", "response": "def create(self, data={}, **kwargs):\n        \"\"\"\"\n        Create Virtual Account from given dict\n\n        Args:\n            Param for Creating Virtual Account\n\n        Returns:\n            Virtual Account dict\n        \"\"\"\n        url = self.base_url\n        return self.post_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose Virtual Account from given Id", "response": "def close(self, virtual_account_id, data={}, **kwargs):\n        \"\"\"\"\n        Close Virtual Account from given Id\n\n        Args:\n            virtual_account_id :\n                Id for which Virtual Account objects has to be Closed\n        \"\"\"\n        url = \"{}/{}\".format(self.base_url, virtual_account_id)\n        data['status'] = 'closed'\n        return self.patch_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches Payment for given Virtual Account Id", "response": "def payments(self, virtual_account_id, data={}, **kwargs):\n        \"\"\"\"\n        Fetch Payment for Virtual Account Id\n\n        Args:\n            virtual_account_id :\n                Id for which Virtual Account objects has to be retrieved\n\n        Returns:\n            Payment dict for given Virtual Account Id\n        \"\"\"\n        url = \"{}/{}/payments\".format(self.base_url, virtual_account_id)\n        return self.get_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches all Subscription entities", "response": "def all(self, data={}, **kwargs):\n        \"\"\"\"\n        Fetch all Subscription entities\n\n        Returns:\n            Dictionary of Subscription data\n        \"\"\"\n        return super(Subscription, self).all(data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch(self, subscription_id, data={}, **kwargs):\n        return super(Subscription, self).fetch(subscription_id, data, **kwargs)", "response": "Fetch Subscription for given Id\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncancel a subscription given by subscription_id", "response": "def cancel(self, subscription_id, data={}, **kwargs):\n        \"\"\"\n        Cancel subscription given by subscription_id\n\n        Args:\n            subscription_id : Id for which subscription has to be cancelled\n\n        Returns:\n            Subscription Dict for given subscription id\n        \"\"\"\n        url = \"{}/{}/cancel\".format(self.base_url, subscription_id)\n        return self.post_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches all Order entities", "response": "def all(self, data={}, **kwargs):\n        \"\"\"\"\n        Fetch all Order entities\n\n        Returns:\n            Dictionary of Order data\n        \"\"\"\n        return super(Order, self).all(data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self, order_id, data={}, **kwargs):\n        return super(Order, self).fetch(order_id, data, **kwargs)", "response": "Fetch Order for given Id\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self, customer_id, data={}, **kwargs):\n        return super(Customer, self).fetch(customer_id, data, **kwargs)", "response": "Fetch a customer object from the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nedits customer information from given dict", "response": "def edit(self, customer_id, data={}, **kwargs):\n        \"\"\"\"\n        Edit Customer information from given dict\n\n        Returns:\n            Customer Dict which was edited\n        \"\"\"\n        url = '{}/{}'.format(self.base_url, customer_id)\n\n        return self.put_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self, addon_id, data={}, **kwargs):\n        return super(Addon, self).fetch(addon_id, data, **kwargs)", "response": "Fetch addon for given Id\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting addon for given id", "response": "def delete(self, addon_id, data={}, **kwargs):\n        \"\"\"\n        Delete addon for given id\n\n        Args:\n            addon_id : Id for which addon object has to be deleted\n        \"\"\"\n        return super(Addon, self).delete(addon_id, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches All Refund Returns: Refund dict", "response": "def all(self, data={}, **kwargs):\n        \"\"\"\"\n        Fetch All Refund\n\n        Returns:\n            Refund dict\n        \"\"\"\n        return super(Refund, self).all(data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self, refund_id, data={}, **kwargs):\n        return super(Refund, self).fetch(refund_id, data, **kwargs)", "response": "Fetch a refund for a given refund Id"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches all Payment entities Returns a dictionary of Payment data", "response": "def all(self, data={}, **kwargs):\n        \"\"\"\"\n        Fetch all Payment entities\n\n        Returns:\n            Dictionary of Payment data\n        \"\"\"\n        return super(Payment, self).all(data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching Payment for given Id", "response": "def fetch(self, payment_id, data={}, **kwargs):\n        \"\"\"\"\n        Fetch Payment for given Id\n\n        Args:\n            payment_id : Id for which payment object has to be retrieved\n\n        Returns:\n            Payment dict for given payment Id\n        \"\"\"\n        return super(Payment, self).fetch(payment_id, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef capture(self, payment_id, amount, data={}, **kwargs):\n        url = \"{}/{}/capture\".format(self.base_url, payment_id)\n        data['amount'] = amount\n        return self.post_url(url, data, **kwargs)", "response": "Capture Payment for given Id\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates Transfer for given Payment Id", "response": "def transfer(self, payment_id, data={}, **kwargs):\n        \"\"\"\"\n        Create Transfer for given Payment Id\n\n        Args:\n            payment_id : Id for which payment object has to be transfered\n\n        Returns:\n            Payment dict after getting transfered\n        \"\"\"\n        url = \"{}/{}/transfers\".format(self.base_url, payment_id)\n        return self.post_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching all transfers for given Payment Id", "response": "def transfers(self, payment_id, data={}, **kwargs):\n        \"\"\"\"\n        Fetches all transfer for given Payment Id\n\n        Args:\n            payment_id : Id for which payment object has to be refunded\n            Amount : Amount for which the payment has to be refunded\n\n        Returns:\n            Payment dict after getting refunded\n        \"\"\"\n        url = \"{}/{}/transfers\".format(self.base_url, payment_id)\n        return self.get_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch Plan for given Id", "response": "def fetch(self, plan_id, data={}, **kwargs):\n        \"\"\"\"\n        Fetch Plan for given Id\n\n        Args:\n            plan_id : Id for which Plan object has to be retrieved\n\n        Returns:\n            Plan dict for given subscription Id\n        \"\"\"\n        return super(Plan, self).fetch(plan_id, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching all entities in the system", "response": "def all(self, data={}, **kwargs):\n        \"\"\"\"\n        Fetch all plan entities\n\n        Returns:\n            Dictionary of plan data\n        \"\"\"\n        return super(Plan, self).all(data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches Token for given Id and given customer Id", "response": "def fetch(self, customer_id, token_id, data={}, **kwargs):\n        \"\"\"\"\n        Fetch Token for given Id and given customer Id\n\n        Args:\n            customer_id : Customer Id for which tokens have to be fetched\n            token_id    : Id for which TOken object has to be fetched\n\n        Returns:\n            Token dict for given token Id\n        \"\"\"\n        url = \"{}/{}/tokens/{}\".format(self.base_url, customer_id, token_id)\n        return self.get_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all tokens for given cutomer Id", "response": "def all(self, customer_id, data={}, **kwargs):\n        \"\"\"\"\n        Get all tokens for given customer Id\n\n        Args:\n            customer_id : Customer Id for which tokens have to be fetched\n\n        Returns:\n            Token dicts for given cutomer Id\n        \"\"\"\n        url = \"{}/{}/tokens\".format(self.base_url, customer_id)\n        return self.get_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete Given Token For a Customer Delete Given Token For a Customer", "response": "def delete(self, customer_id, token_id, data={}, **kwargs):\n        \"\"\"\"\n        Delete Given Token For a Customer\n\n        Args:\n            customer_id : Customer Id for which tokens have to be deleted\n            token_id    : Id for which TOken object has to be deleted\n        Returns:\n            Dict for deleted token\n        \"\"\"\n        url = \"{}/{}/tokens/{}\".format(self.base_url, customer_id, token_id)\n        return self.delete_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all(self, data={}, **kwargs):\n        return super(Settlement, self).all(data, **kwargs)", "response": "Fetch all Settlement entities\nAttributeNames Returns a dictionary of Settlement objects"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching Settlement data for given Id", "response": "def fetch(self, settlement_id, data={}, **kwargs):\n        \"\"\"\"\n        Fetch Settlement data for given Id\n\n        Args:\n            settlement_id : Id for which settlement object has to be retrieved\n\n        Returns:\n            settlement dict for given settlement id\n        \"\"\"\n        return super(Settlement, self).fetch(settlement_id, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compare_string(self, expected_str, actual_str):\n        if len(expected_str) != len(actual_str):\n            return False\n        result = 0\n        for x, y in zip(expected_str, actual_str):\n            result |= ord(x) ^ ord(y)\n        return result == 0", "response": "Compares two strings of the same length and returns True if the two strings are equal False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch all Transfer entities", "response": "def all(self, data={}, **kwargs):\n        \"\"\"\"\n        Fetch all Transfer entities\n\n        Returns:\n            Dictionary of Transfer data\n        \"\"\"\n        if 'payment_id' in data:\n            url = \"/payments/{}/transfers\".format(data['payment_id'])\n\n            del data['payment_id']\n            return self.get_url(url, data, **kwargs)\n\n        return super(Transfer, self).all(data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch(self, transfer_id, data={}, **kwargs):\n        return super(Transfer, self).fetch(transfer_id, data, **kwargs)", "response": "Fetch Transfer for given Id"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreverses Transfer from given id", "response": "def reverse(self, transfer_id, data={}, **kwargs):\n        \"\"\"\"\n        Reverse Transfer from given id\n\n        Args:\n            transfer_id : Id for which transfer object has to be reversed\n\n        Returns:\n            Transfer Dict which was reversed\n        \"\"\"\n        url = \"{}/{}/reversals\".format(self.base_url, transfer_id)\n        return self.post_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reversals(self, transfer_id, data={}, **kwargs):\n        url = \"{}/{}/reversals\".format(self.base_url, transfer_id)\n        return self.get_url(url, data, **kwargs)", "response": "Get all Reversal Transfer from given id"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef request(self, method, path, **options):\n        options = self._update_user_agent_header(options)\n\n        url = \"{}{}\".format(self.base_url, path)\n\n        response = getattr(self.session, method)(url, auth=self.auth,\n                                                 verify=self.cert_path,\n                                                 **options)\n        if ((response.status_code >= HTTP_STATUS_CODE.OK) and\n                (response.status_code < HTTP_STATUS_CODE.REDIRECT)):\n            return response.json()\n        else:\n            msg = \"\"\n            code = \"\"\n            json_response = response.json()\n            if 'error' in json_response:\n                if 'description' in json_response['error']:\n                    msg = json_response['error']['description']\n                if 'code' in json_response['error']:\n                    code = str(json_response['error']['code'])\n\n            if str.upper(code) == ERROR_CODE.BAD_REQUEST_ERROR:\n                raise BadRequestError(msg)\n            elif str.upper(code) == ERROR_CODE.GATEWAY_ERROR:\n                raise GatewayError(msg)\n            elif str.upper(code) == ERROR_CODE.SERVER_ERROR:\n                raise ServerError(msg)\n            else:\n                raise ServerError(msg)", "response": "Dispatches a request to the Razorpay HTTP API and returns the response."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, path, params, **options):\n        return self.request('get', path, params=params, **options)", "response": "Parses GET request options and dispatches a request\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles a POST request.", "response": "def post(self, path, data, **options):\n        \"\"\"\n        Parses POST request options and dispatches a request\n        \"\"\"\n        data, options = self._update_request(data, options)\n        return self.request('post', path, data=data, **options)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef patch(self, path, data, **options):\n        data, options = self._update_request(data, options)\n        return self.request('patch', path, data=data, **options)", "response": "Handles a PATCH request. Parses data and dispatches a request\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, path, data, **options):\n        data, options = self._update_request(data, options)\n        return self.request('delete', path, data=data, **options)", "response": "Handles a DELETE request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling a PUT request. Parses PUT request options and dispatches a request", "response": "def put(self, path, data, **options):\n        \"\"\"\n        Parses PUT request options and dispatches a request\n        \"\"\"\n        data, options = self._update_request(data, options)\n        return self.request('put', path, data=data, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _update_request(self, data, options):\n        data = json.dumps(data)\n\n        if 'headers' not in options:\n            options['headers'] = {}\n\n        options['headers'].update({'Content-type': 'application/json'})\n\n        return data, options", "response": "Updates The resource data and header options"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all(self, data={}, **kwargs):\n        return super(Invoice, self).all(data, **kwargs)", "response": "Fetch all Invoice entities"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch Invoice for given Id", "response": "def fetch(self, invoice_id, data={}, **kwargs):\n        \"\"\"\"\n        Fetch Invoice for given Id\n\n        Args:\n            invoice_id : Id for which invoice object has to be retrieved\n\n        Returns:\n            Invoice dict for given invoice Id\n        \"\"\"\n        return super(Invoice, self).fetch(invoice_id, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef notify_by(self, invoice_id, medium, **kwargs):\n        url = \"{}/{}/notify_by/{}\".format(self.base_url, invoice_id, medium)\n        return self.post_url(url, {}, **kwargs)", "response": "Send and resend notifications to customer via email or sms"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncancels an unpaid invoice with given ID via API", "response": "def cancel(self, invoice_id, **kwargs):\n        \"\"\"\"\n        Cancel an unpaid Invoice with given ID via API\n        It can only be called on an invoice that is not in the paid state.\n\n        Args:\n            invoice_id : Id for cancel the invoice\n        Returns:\n            The response for the API will be the invoice entity, similar to create/update API response, with status attribute's value as cancelled\n        \"\"\"\n        url = \"{}/{}/cancel\".format(self.base_url, invoice_id)\n        return self.post_url(url, {}, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete an invoice in the draft state", "response": "def delete(self, invoice_id, **kwargs):\n        \"\"\"\"\n        Delete an invoice\n        You can delete an invoice which is in the draft state.\n\n        Args:\n            invoice_id : Id for delete the invoice\n        Returns:\n            The response is always be an empty array like this - []\n        \"\"\"\n        url = \"{}/{}\".format(self.base_url, invoice_id)\n        return self.delete_url(url, {}, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nissue an invoice in draft state", "response": "def issue(self, invoice_id, **kwargs):\n        \"\"\"\"\n        Issues an invoice in draft state\n\n        Args:\n            invoice_id : Id for delete the invoice\n        Returns:\n            Its response is the invoice entity, similar to create/update API response. Its status now would be issued.\n        \"\"\"\n        url = \"{}/{}/issue\".format(self.base_url, invoice_id)\n        return self.post_url(url, {}, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating an invoice s attributes.", "response": "def edit(self, invoice_id, data={}, **kwargs):\n        \"\"\"\"\n        Update an invoice\n        In draft state all the attributes are allowed.\n\n        Args:\n            invoice_id : Id for delete the invoice\n            data : Dictionary having keys using which invoice have to be updated\n        Returns:\n            Its response is the invoice entity, similar to create/update API response. Its status now would be issued.\n            Refer https://razorpay.com/docs/invoices/api/#entity-structure\n        \"\"\"\n        url = \"{}/{}\".format(self.base_url, invoice_id)\n        return self.patch_url(url, data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _unkown_type(self, uridecodebin, decodebin, caps):\n        # This is called *before* the stream becomes ready when the\n        # file can't be read.\n        streaminfo = caps.to_string()\n        if not streaminfo.startswith('audio/'):\n            # Ignore non-audio (e.g., video) decode errors.\n            return\n        self.read_exc = UnknownTypeError(streaminfo)\n        self.ready_sem.release()", "response": "The callback for decodebin s unknown - type signal."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose the file and clean up associated resources.", "response": "def close(self, force=False):\n        \"\"\"Close the file and clean up associated resources.\n\n        Calling `close()` a second time has no effect.\n        \"\"\"\n        if self.running or force:\n            self.running = False\n            self.finished = True\n\n            # Unregister for signals, which we registered for above with\n            # `add_signal_watch`. (Without this, GStreamer leaks file\n            # descriptors.)\n            self.pipeline.get_bus().remove_signal_watch()\n\n            # Stop reading the file.\n            self.dec.set_property(\"uri\", None)\n            # Block spurious signals.\n            self.sink.get_static_pad(\"sink\").disconnect(self.caps_handler)\n\n            # Make space in the output queue to let the decoder thread\n            # finish. (Otherwise, the thread blocks on its enqueue and\n            # the interpreter hangs.)\n            try:\n                self.queue.get_nowait()\n            except queue.Empty:\n                pass\n\n            # Halt the pipeline (closing file).\n            self.pipeline.set_state(Gst.State.NULL)\n\n            # Delete the pipeline object. This seems to be necessary on Python\n            # 2, but not Python 3 for some reason: on 3.5, at least, the\n            # pipeline gets dereferenced automatically.\n            del self.pipeline"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef byteswap(s):\n    assert len(s) % 2 == 0\n    parts = []\n    for i in range(0, len(s), 2):\n        chunk = s[i:i + 2]\n        newchunk = struct.pack('<h', *struct.unpack('>h', chunk))\n        parts.append(newchunk)\n    return b''.join(parts)", "response": "Swaps the endianness of the bytesting s."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating blocks of PCM data found in the file.", "response": "def read_data(self, block_samples=1024):\n        \"\"\"Generates blocks of PCM data found in the file.\"\"\"\n        old_width = self._file.getsampwidth()\n\n        while True:\n            data = self._file.readframes(block_samples)\n            if not data:\n                break\n\n            # Make sure we have the desired bitdepth and endianness.\n            data = audioop.lin2lin(data, old_width, TARGET_WIDTH)\n            if self._needs_byteswap and self._file.getcomptype() != 'sowt':\n                # Big-endian data. Swap endianness.\n                data = byteswap(data)\n            yield data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetermines whether Gstreamer and the Python GObject bindings are available.", "response": "def _gst_available():\n    \"\"\"Determine whether Gstreamer and the Python GObject bindings are\n    installed.\n    \"\"\"\n    try:\n        import gi\n    except ImportError:\n        return False\n\n    try:\n        gi.require_version('Gst', '1.0')\n    except (ValueError, AttributeError):\n        return False\n\n    try:\n        from gi.repository import Gst  # noqa\n    except ImportError:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of backends that are available on this system.", "response": "def available_backends():\n    \"\"\"Returns a list of backends that are available on this system.\"\"\"\n\n    # Standard-library WAV and AIFF readers.\n    from . import rawread\n    result = [rawread.RawAudioFile]\n\n    # Core Audio.\n    if _ca_available():\n        from . import macca\n        result.append(macca.ExtAudioFile)\n\n    # GStreamer.\n    if _gst_available():\n        from . import gstdec\n        result.append(gstdec.GstAudioFile)\n\n    # MAD.\n    if _mad_available():\n        from . import maddec\n        result.append(maddec.MadAudioFile)\n\n    # FFmpeg.\n    if ffdec.available():\n        result.append(ffdec.FFmpegAudioFile)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nopening an audio file using a list of available backend classes.", "response": "def audio_open(path, backends=None):\n    \"\"\"Open an audio file using a library that is available on this\n    system.\n\n    The optional `backends` parameter can be a list of audio file\n    classes to try opening the file with. If it is not provided,\n    `audio_open` tries all available backends. If you call this function\n    many times, you can avoid the cost of checking for available\n    backends every time by calling `available_backends` once and passing\n    the result to each `audio_open` call.\n\n    If all backends fail to read the file, a NoBackendError exception is\n    raised.\n    \"\"\"\n    if backends is None:\n        backends = available_backends()\n\n    for BackendClass in backends:\n        try:\n            return BackendClass(path)\n        except DecodeError:\n            pass\n\n    # All backends failed!\n    raise NoBackendError()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef popen_multiple(commands, command_args, *args, **kwargs):\n    for i, command in enumerate(commands):\n        cmd = [command] + command_args\n        try:\n            return subprocess.Popen(cmd, *args, **kwargs)\n        except OSError:\n            if i == len(commands) - 1:\n                # No more commands to try.\n                raise", "response": "Like subprocess. Popen but can try multiple commands in case\nFormula some are not available."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef available():\n    proc = popen_multiple(\n        COMMANDS,\n        ['-version'],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        creationflags=PROC_FLAGS,\n    )\n    proc.wait()\n    return (proc.returncode == 0)", "response": "Detect if the FFmpeg backend can be used on this system."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads blocks of raw PCM data from the file.", "response": "def read_data(self, timeout=10.0):\n        \"\"\"Read blocks of raw PCM data from the file.\"\"\"\n        # Read from stdout in a separate thread and consume data from\n        # the queue.\n        start_time = time.time()\n        while True:\n            # Wait for data to be available or a timeout.\n            data = None\n            try:\n                data = self.stdout_reader.queue.get(timeout=timeout)\n                if data:\n                    yield data\n                else:\n                    # End of file.\n                    break\n            except queue.Empty:\n                # Queue read timed out.\n                end_time = time.time()\n                if not data:\n                    if end_time - start_time >= timeout:\n                        # Nothing interesting has happened for a while --\n                        # FFmpeg is probably hanging.\n                        raise ReadTimeoutError('ffmpeg output: {}'.format(\n                            ''.join(self.stderr_reader.queue.queue)\n                        ))\n                    else:\n                        start_time = end_time\n                        # Keep waiting.\n                        continue"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_info(self):\n        out_parts = []\n        while True:\n            line = self.proc.stderr.readline()\n            if not line:\n                # EOF and data not found.\n                raise CommunicationError(\"stream info not found\")\n\n            # In Python 3, result of reading from stderr is bytes.\n            if isinstance(line, bytes):\n                line = line.decode('utf8', 'ignore')\n\n            line = line.strip().lower()\n\n            if 'no such file' in line:\n                raise IOError('file not found')\n            elif 'invalid data found' in line:\n                raise UnsupportedError()\n            elif 'duration:' in line:\n                out_parts.append(line)\n            elif 'audio:' in line:\n                out_parts.append(line)\n                self._parse_info(''.join(out_parts))\n                break", "response": "Reads the tool s output stream extracts the relevant information and parses it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive relevant data from ffmpeg output set audio parameter fields on this object.", "response": "def _parse_info(self, s):\n        \"\"\"Given relevant data from the ffmpeg output, set audio\n        parameter fields on this object.\n        \"\"\"\n        # Sample rate.\n        match = re.search(r'(\\d+) hz', s)\n        if match:\n            self.samplerate = int(match.group(1))\n        else:\n            self.samplerate = 0\n\n        # Channel count.\n        match = re.search(r'hz, ([^,]+),', s)\n        if match:\n            mode = match.group(1)\n            if mode == 'stereo':\n                self.channels = 2\n            else:\n                cmatch = re.match(r'(\\d+)\\.?(\\d)?', mode)\n                if cmatch:\n                    self.channels = sum(map(int, cmatch.group().split('.')))\n                else:\n                    self.channels = 1\n        else:\n            self.channels = 0\n\n        # Duration.\n        match = re.search(\n            r'duration: (\\d+):(\\d+):(\\d+).(\\d)', s\n        )\n        if match:\n            durparts = list(map(int, match.groups()))\n            duration = (\n                durparts[0] * 60 * 60 +\n                durparts[1] * 60 +\n                durparts[2] +\n                float(durparts[3]) / 10\n            )\n            self.duration = duration\n        else:\n            # No duration found.\n            self.duration = 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclose the ffmpeg process used to perform the decoding.", "response": "def close(self):\n        \"\"\"Close the ffmpeg process used to perform the decoding.\"\"\"\n        if hasattr(self, 'proc'):\n            # First check the process's execution status before attempting to\n            # kill it. This fixes an issue on Windows Subsystem for Linux where\n            # ffmpeg closes normally on its own, but never updates\n            # `returncode`.\n            self.proc.poll()\n\n            # Kill the process if it is still running.\n            if self.proc.returncode is None:\n                self.proc.kill()\n                self.proc.wait()\n\n            # Wait for the stream-reading threads to exit. (They need to\n            # stop reading before we can close the streams.)\n            if hasattr(self, 'stderr_reader'):\n                self.stderr_reader.join()\n            if hasattr(self, 'stdout_reader'):\n                self.stdout_reader.join()\n\n            # Close the stdout and stderr streams that were opened by Popen,\n            # which should occur regardless of if the process terminated\n            # cleanly.\n            self.proc.stdout.close()\n            self.proc.stderr.close()\n\n        # Close the handle to os.devnull, which is opened regardless of if\n        # a subprocess is successfully created.\n        self.devnull.close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_blocks(self, block_size=4096):\n        while True:\n            out = self.mf.read(block_size)\n            if not out:\n                break\n            yield bytes(out)", "response": "Generates a generator that yields audio data blocks of size block_size."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef channels(self):\n        if self.mf.mode() == mad.MODE_SINGLE_CHANNEL:\n            return 1\n        elif self.mf.mode() in (mad.MODE_DUAL_CHANNEL,\n                                mad.MODE_JOINT_STEREO,\n                                mad.MODE_STEREO):\n            return 2\n        else:\n            # Other mode?\n            return 2", "response": "The number of channels."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef multi_char_literal(chars):\n    num = 0\n    for index, char in enumerate(chars):\n        shift = (len(chars) - index - 1) * 8\n        num |= ord(char) << shift\n    return num", "response": "Emulates character integer literals in C. Given a string chars returns the value of the C single - quoted literal."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a CFURL Python object return an opened ExtAudioFileRef.", "response": "def _open_url(cls, url):\n        \"\"\"Given a CFURL Python object, return an opened ExtAudioFileRef.\n        \"\"\"\n        file_obj = ctypes.c_void_p()\n        check(_coreaudio.ExtAudioFileOpenURL(\n            url._obj, ctypes.byref(file_obj)\n        ))\n        return file_obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_client_format(self, desc):\n        assert desc.mFormatID == AUDIO_ID_PCM\n        check(_coreaudio.ExtAudioFileSetProperty(\n            self._obj, PROP_CLIENT_DATA_FORMAT, ctypes.sizeof(desc),\n            ctypes.byref(desc)\n        ))\n        self._client_fmt = desc", "response": "Set the client format description. This describes the client format that the program will read from."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_file_format(self):\n        # Have cached file format?\n        if self._file_fmt is not None:\n            return self._file_fmt\n\n        # Make the call to retrieve it.\n        desc = AudioStreamBasicDescription()\n        size = ctypes.c_int(ctypes.sizeof(desc))\n        check(_coreaudio.ExtAudioFileGetProperty(\n            self._obj, PROP_FILE_DATA_FORMAT, ctypes.byref(size),\n            ctypes.byref(desc)\n        ))\n\n        # Cache result.\n        self._file_fmt = desc\n        return desc", "response": "Get the file format description. This describes the type of\n        data stored on disk on disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the number of frames in the source file.", "response": "def nframes(self):\n        \"\"\"Gets the number of frames in the source file.\"\"\"\n        length = ctypes.c_long()\n        size = ctypes.c_int(ctypes.sizeof(length))\n        check(_coreaudio.ExtAudioFileGetProperty(\n            self._obj, PROP_LENGTH, ctypes.byref(size), ctypes.byref(length)\n        ))\n        return length.value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the client format parameters specifying the desired PCM audio data format to be read from the file.", "response": "def setup(self, bitdepth=16):\n        \"\"\"Set the client format parameters, specifying the desired PCM\n        audio data format to be read from the file. Must be called\n        before reading from the file.\n        \"\"\"\n        fmt = self.get_file_format()\n        newfmt = copy.copy(fmt)\n\n        newfmt.mFormatID = AUDIO_ID_PCM\n        newfmt.mFormatFlags = \\\n            PCM_IS_SIGNED_INT | PCM_IS_PACKED\n        newfmt.mBitsPerChannel = bitdepth\n        newfmt.mBytesPerPacket = \\\n            (fmt.mChannelsPerFrame * newfmt.mBitsPerChannel // 8)\n        newfmt.mFramesPerPacket = 1\n        newfmt.mBytesPerFrame = newfmt.mBytesPerPacket\n        self.set_client_format(newfmt)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating byte strings reflecting the audio data in the file.", "response": "def read_data(self, blocksize=4096):\n        \"\"\"Generates byte strings reflecting the audio data in the file.\n        \"\"\"\n        frames = ctypes.c_uint(blocksize // self._client_fmt.mBytesPerFrame)\n        buf = ctypes.create_string_buffer(blocksize)\n\n        buflist = AudioBufferList()\n        buflist.mNumberBuffers = 1\n        buflist.mBuffers[0].mNumberChannels = \\\n            self._client_fmt.mChannelsPerFrame\n        buflist.mBuffers[0].mDataByteSize = blocksize\n        buflist.mBuffers[0].mData = ctypes.cast(buf, ctypes.c_void_p)\n\n        while True:\n            check(_coreaudio.ExtAudioFileRead(\n                self._obj, ctypes.byref(frames), ctypes.byref(buflist)\n            ))\n\n            assert buflist.mNumberBuffers == 1\n            size = buflist.mBuffers[0].mDataByteSize\n            if not size:\n                break\n\n            data = ctypes.cast(buflist.mBuffers[0].mData,\n                               ctypes.POINTER(ctypes.c_char))\n            blob = data[:size]\n            yield blob"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclose the audio file and free associated memory.", "response": "def close(self):\n        \"\"\"Close the audio file and free associated memory.\"\"\"\n        if not self.closed:\n            check(_coreaudio.ExtAudioFileDispose(self._obj))\n            self.closed = True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmount a sub - app at the url of current app.", "response": "def mount(self, url, app):\n        \"Mount a sub-app at the url of current app.\"\n        # Inspired by Bottle. It might seem that dispatching to\n        # subapps would rather be handled by normal routes, but\n        # arguably, that's less efficient. Taking into account\n        # that paradigmatically there's difference between handing\n        # an action and delegating responisibilities to another\n        # app, Bottle's way was followed.\n        app.url = url\n        self.mounts.append(app)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nevaluate calls from call_queue and places the results in result_queue. This worker is run in a separate process. Args: call_queue: A multiprocessing.Queue of _CallItems that will be read and evaluated by the worker. result_queue: A multiprocessing.Queue of _ResultItems that will written to by the worker. shutdown: A multiprocessing.Event that will be set as a signal to the worker that it should exit when call_queue is empty.", "response": "def _process_worker(call_queue, result_queue):\n    \"\"\"Evaluates calls from call_queue and places the results in result_queue.\n\n    This worker is run in a separate process.\n\n    Args:\n        call_queue: A multiprocessing.Queue of _CallItems that will be read and\n            evaluated by the worker.\n        result_queue: A multiprocessing.Queue of _ResultItems that will written\n            to by the worker.\n        shutdown: A multiprocessing.Event that will be set as a signal to the\n            worker that it should exit when call_queue is empty.\n    \"\"\"\n    while True:\n        call_item = call_queue.get(block=True)\n        if call_item is None:\n            # Wake up queue management thread\n            result_queue.put(None)\n            return\n        try:\n            r = call_item.fn(*call_item.args, **call_item.kwargs)\n        except BaseException:\n            e = sys.exc_info()[1]\n            result_queue.put(_ResultItem(call_item.work_id,\n                                         exception=e))\n        else:\n            result_queue.put(_ResultItem(call_item.work_id,\n                                         result=r))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _queue_management_worker(executor_reference,\n                             processes,\n                             pending_work_items,\n                             work_ids_queue,\n                             call_queue,\n                             result_queue):\n    \"\"\"Manages the communication between this process and the worker processes.\n\n    This function is run in a local thread.\n\n    Args:\n        executor_reference: A weakref.ref to the ProcessPoolExecutor that owns\n            this thread. Used to determine if the ProcessPoolExecutor has been\n            garbage collected and that this function can exit.\n        process: A list of the multiprocessing.Process instances used as\n            workers.\n        pending_work_items: A dict mapping work ids to _WorkItems e.g.\n            {5: <_WorkItem...>, 6: <_WorkItem...>, ...}\n        work_ids_queue: A queue.Queue of work ids e.g. Queue([5, 6, ...]).\n        call_queue: A multiprocessing.Queue that will be filled with _CallItems\n            derived from _WorkItems for processing by the process workers.\n        result_queue: A multiprocessing.Queue of _ResultItems generated by the\n            process workers.\n    \"\"\"\n    nb_shutdown_processes = [0]\n    def shutdown_one_process():\n        \"\"\"Tell a worker to terminate, which will in turn wake us again\"\"\"\n        call_queue.put(None)\n        nb_shutdown_processes[0] += 1\n    while True:\n        _add_call_item_to_queue(pending_work_items,\n                                work_ids_queue,\n                                call_queue)\n\n        result_item = result_queue.get(block=True)\n        if result_item is not None:\n            work_item = pending_work_items[result_item.work_id]\n            del pending_work_items[result_item.work_id]\n\n            if result_item.exception:\n                work_item.future.set_exception(result_item.exception)\n            else:\n                work_item.future.set_result(result_item.result)\n            # Delete references to object. See issue16284\n            del work_item\n        # Check whether we should start shutting down.\n        executor = executor_reference()\n        # No more work items can be added if:\n        #   - The interpreter is shutting down OR\n        #   - The executor that owns this worker has been collected OR\n        #   - The executor that owns this worker has been shutdown.\n        if _shutdown or executor is None or executor._shutdown_thread:\n            # Since no new work items can be added, it is safe to shutdown\n            # this thread if there are no pending work items.\n            if not pending_work_items:\n                while nb_shutdown_processes[0] < len(processes):\n                    shutdown_one_process()\n                # If .join() is not called on the created processes then\n                # some multiprocessing.Queue methods may deadlock on Mac OS\n                # X.\n                for p in processes:\n                    p.join()\n                call_queue.close()\n                return\n        del executor", "response": "This function is a worker function that processes the process pool and processes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _map(expr, func, rtype=None, resources=None, args=(), **kwargs):\n\n    name = None\n    if isinstance(func, FunctionWrapper):\n        if func.output_names:\n            if len(func.output_names) > 1:\n                raise ValueError('Map column has more than one name')\n            name = func.output_names[0]\n        if func.output_types:\n            rtype = rtype or func.output_types[0]\n        func = func._func\n\n    if rtype is None:\n        rtype = utils.get_annotation_rtype(func)\n\n    from ...models import Function\n\n    rtype = rtype or expr.dtype\n    output_type = types.validate_data_type(rtype)\n\n    if isinstance(func, six.string_types):\n        pass\n    elif isinstance(func, Function):\n        pass\n    elif inspect.isclass(func):\n        pass\n    elif not callable(func):\n        raise ValueError('`func` must be a function or a callable class')\n\n    collection_resources = utils.get_collection_resources(resources)\n\n    is_seq = isinstance(expr, SequenceExpr)\n    if is_seq:\n        return MappedExpr(_data_type=output_type, _func=func, _inputs=[expr, ],\n                          _func_args=args, _func_kwargs=kwargs, _name=name,\n                          _resources=resources, _collection_resources=collection_resources)\n    else:\n        return MappedExpr(_value_type=output_type, _func=func, _inputs=[expr, ],\n                          _func_args=args, _func_kwargs=kwargs, _name=name,\n                          _resources=resources, _collection_resources=collection_resources)", "response": "Map a function on each element of this sequence."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _hash(expr, func=None):\n    if func is None:\n        func = lambda x: hash(x)\n\n    return _map(expr, func=func, rtype=types.int64)", "response": "Calculate the hash value of the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a sequence or scalar according to the input indicating if the values are null.", "response": "def _isnull(expr):\n    \"\"\"\n    Return a sequence or scalar according to the input indicating if the values are null.\n\n    :param expr: sequence or scalar\n    :return: sequence or scalar\n    \"\"\"\n\n    if isinstance(expr, SequenceExpr):\n        return IsNull(_input=expr, _data_type=types.boolean)\n    elif isinstance(expr, Scalar):\n        return IsNull(_input=expr, _value_type=types.boolean)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a sequence or scalar according to the input indicating if the values are not null.", "response": "def _notnull(expr):\n    \"\"\"\n    Return a sequence or scalar according to the input indicating if the values are not null.\n\n    :param expr: sequence or scalar\n    :return: sequence or scalar\n    \"\"\"\n\n    if isinstance(expr, SequenceExpr):\n        return NotNull(_input=expr, _data_type=types.boolean)\n    elif isinstance(expr, Scalar):\n        return NotNull(_input=expr, _value_type=types.boolean)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfill null with value.", "response": "def _fillna(expr, value):\n    \"\"\"\n    Fill null with value.\n\n    :param expr: sequence or scalar\n    :param value: value to fill into\n    :return: sequence or scalar\n    \"\"\"\n\n    if isinstance(expr, SequenceExpr):\n        return FillNa(_input=expr, _fill_value=value, _data_type=expr.dtype)\n    elif isinstance(expr, Scalar):\n        return FillNa(_input=expr, _fill_value=value, _value_type=expr.dtype)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a boolean sequence or scalar showing whether each element is exactly contained in the passed values.", "response": "def _isin(expr, values):\n    \"\"\"\n    Return a boolean sequence or scalar showing whether\n    each element is exactly contained in the passed `values`.\n\n    :param expr: sequence or scalar\n    :param values: `list` object or sequence\n    :return: boolean sequence or scalar\n    \"\"\"\n\n    from .merge import _make_different_sources\n\n    if isinstance(values, SequenceExpr):\n        expr, values = _make_different_sources(expr, values)\n\n    if isinstance(expr, SequenceExpr):\n        return IsIn(_input=expr, _values=values, _data_type=types.boolean)\n    elif isinstance(expr, Scalar):\n        return IsIn(_input=expr, _values=values, _value_type=types.boolean)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _notin(expr, values):\n\n    if isinstance(expr, SequenceExpr):\n        return NotIn(_input=expr, _values=values, _data_type=types.boolean)\n    elif isinstance(expr, Scalar):\n        return NotIn(_input=expr, _values=values, _value_type=types.boolean)", "response": "Returns a boolean sequence or scalar showing whether each element is not contained in the passed values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _between(expr, left, right, inclusive=True):\n\n    if isinstance(expr, SequenceExpr):\n        return Between(_input=expr, _left=left, _right=right,\n                       _inclusive=inclusive, _data_type=types.boolean)\n    elif isinstance(expr, Scalar):\n        return Between(_input=expr, _left=left, _right=right,\n                       _inclusive=inclusive, _value_type=types.boolean)", "response": "Return a boolean sequence or scalar show whether each element is between left and right."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the right or left of a sequence or scalar.", "response": "def _ifelse(expr, true_expr, false_expr):\n    \"\"\"\n    Given a boolean sequence or scalar, if true will return the left, else return the right one.\n\n    :param expr: sequence or scalar\n    :param true_expr:\n    :param false_expr:\n    :return: sequence or scalar\n\n    :Example:\n\n    >>> (df.id == 3).ifelse(df.id, df.fid.astype('int'))\n    >>> df.isMale.ifelse(df.male_count, df.female_count)\n    \"\"\"\n\n    tps = (SequenceExpr, Scalar)\n    if not isinstance(true_expr, tps):\n        true_expr = Scalar(_value=true_expr)\n    if not isinstance(false_expr, tps):\n        false_expr = Scalar(_value=false_expr)\n\n    output_type = utils.highest_precedence_data_type(\n            *[true_expr.dtype, false_expr.dtype])\n    is_sequence = isinstance(expr, SequenceExpr) or \\\n                  isinstance(true_expr, SequenceExpr) or \\\n                  isinstance(false_expr, SequenceExpr)\n\n    if is_sequence:\n        return IfElse(_input=expr, _then=true_expr, _else=false_expr,\n                      _data_type=output_type)\n    else:\n        return IfElse(_input=expr, _then=true_expr, _else=false_expr,\n                      _value_type=output_type)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _switch(expr, *args, **kw):\n    default = _scalar(kw.get('default'))\n\n    if len(args) <= 0:\n        raise errors.ExpressionError('Switch must accept more than one condition')\n\n    if all(isinstance(arg, tuple) and len(arg) == 2 for arg in args):\n        conditions, thens = zip(*args)\n    else:\n        conditions = [arg for i, arg in enumerate(args) if i % 2 == 0]\n        thens = [arg for i, arg in enumerate(args) if i % 2 == 1]\n\n    if len(conditions) == len(thens):\n        conditions, thens = _scalar(conditions), _scalar(thens)\n    else:\n        raise errors.ExpressionError('Switch should be called by case and then pairs')\n\n    if isinstance(expr, (Scalar, SequenceExpr)):\n        case = expr\n    else:\n        case = None\n        if not all(hasattr(it, 'dtype') and it.dtype == types.boolean for it in conditions):\n            raise errors.ExpressionError('Switch must be called by all boolean conditions')\n\n    res = thens if default is None else thens + [default, ]\n    output_type = utils.highest_precedence_data_type(*(it.dtype for it in res))\n\n    is_seq = isinstance(expr, SequenceExpr) or \\\n        any(isinstance(it, SequenceExpr) for it in conditions) or \\\n        any(isinstance(it, SequenceExpr) for it in res)\n    if case is not None:\n        is_seq = is_seq or isinstance(case, SequenceExpr)\n\n    kwargs = dict()\n    if is_seq:\n        kwargs['_data_type'] = output_type\n    else:\n        kwargs['_value_type'] = output_type\n    return Switch(_input=expr, _case=case, _conditions=conditions,\n                  _thens=thens, _default=default, **kwargs)", "response": "Returns a sequence or scalar depending on the condition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn indices of half - open bins to which each value of expr belongs.", "response": "def _cut(expr, bins, right=True, labels=None, include_lowest=False,\n         include_under=False, include_over=False):\n    \"\"\"\n    Return indices of half-open bins to which each value of `expr` belongs.\n\n    :param expr: sequence or scalar\n    :param bins: list of scalars\n    :param right: indicates whether the bins include the rightmost edge or not. If right == True(the default),\n                  then the bins [1, 2, 3, 4] indicate (1, 2], (2, 3], (3, 4]\n    :param labels: Usesd as labes for the resulting bins. Must be of the same length as the resulting bins.\n    :param include_lowest: Whether the first interval should be left-inclusive or not.\n    :param include_under: include the bin below the leftmost edge or not\n    :param include_over: include the bin above the rightmost edge or not\n    :return: sequence or scalar\n    \"\"\"\n\n    is_seq = isinstance(expr, SequenceExpr)\n    dtype = utils.highest_precedence_data_type(\n        *(types.validate_value_type(it) for it in labels)) \\\n        if labels is not None else types.int64\n    kw = {}\n    if is_seq:\n        kw['_data_type'] = dtype\n    else:\n        kw['_value_type'] = dtype\n\n    return Cut(_input=expr, _bins=bins, _right=right, _labels=labels,\n               _include_lowest=include_lowest, _include_under=include_under,\n               _include_over=include_over, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _int_to_datetime(expr):\n\n    if isinstance(expr, SequenceExpr):\n        return IntToDatetime(_input=expr, _data_type=types.datetime)\n    elif isinstance(expr, Scalar):\n        return IntToDatetime(_input=expr, _value_type=types.datetime)", "response": "Convert an integer expression to a datetime."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets DDL SQL statement for the given table.", "response": "def get_ddl(self, with_comments=True, if_not_exists=False):\n        \"\"\"\n        Get DDL SQL statement for the given table.\n\n        :param with_comments: append comment for table and each column\n        :return: DDL statement\n        \"\"\"\n        shard_num = self.shard.shard_num if self.shard is not None else None\n        return self.gen_create_table_sql(\n            self.name, self.schema, self.comment if with_comments else None,\n            if_not_exists=if_not_exists, with_column_comments=with_comments,\n            lifecycle=self.lifecycle, shard_num=shard_num, project=self.project.name,\n            storage_handler=self.storage_handler, serde_properties=self.serde_properties,\n            location=self.location, resources=self.resources,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the head records of a table or its partition.", "response": "def head(self, limit, partition=None, columns=None):\n        \"\"\"\n        Get the head records of a table or its partition.\n\n        :param limit: records' size, 10000 at most\n        :param partition: partition of this table\n        :param columns: the columns which is subset of the table columns\n        :type columns: list\n        :return: records\n        :rtype: list\n\n        .. seealso:: :class:`odps.models.Record`\n        \"\"\"\n\n        if limit <= 0:\n            raise ValueError('limit number should >= 0.')\n\n        params = {'data': '', 'linenum': limit}\n        if partition is not None:\n            if not isinstance(partition, odps_types.PartitionSpec):\n                partition = odps_types.PartitionSpec(partition)\n            params['partition'] = str(partition)\n        if columns is not None and len(columns) > 0:\n            col_name = lambda col: col.name if isinstance(col, odps_types.Column) else col\n            params['cols'] = ','.join(col_name(col) for col in columns)\n\n        resp = self._client.get(self.resource(), params=params, stream=True)\n        with readers.RecordReader(self.schema, resp) as reader:\n            for record in reader:\n                yield record"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nopening the reader to read the entire records from this table or its partition.", "response": "def open_reader(self, partition=None, **kw):\n        \"\"\"\n        Open the reader to read the entire records from this table or its partition.\n\n        :param partition: partition of this table\n        :param reopen: the reader will reuse last one, reopen is true means open a new reader.\n        :type reopen: bool\n        :param endpoint: the tunnel service URL\n        :param compress_option: compression algorithm, level and strategy\n        :type compress_option: :class:`odps.tunnel.CompressOption`\n        :param compress_algo: compression algorithm, work when ``compress_option`` is not provided,\n                              can be ``zlib``, ``snappy``\n        :param compress_level: used for ``zlib``, work when ``compress_option`` is not provided\n        :param compress_strategy: used for ``zlib``, work when ``compress_option`` is not provided\n        :param download_id: use existing download_id to download table contents\n        :return: reader, ``count`` means the full size, ``status`` means the tunnel status\n\n        :Example:\n\n        >>> with table.open_reader() as reader:\n        >>>     count = reader.count  # How many records of a table or its partition\n        >>>     for record in reader[0: count]:\n        >>>         # read all data, actually better to split into reading for many times\n        \"\"\"\n\n        from ..tunnel.tabletunnel import TableDownloadSession\n\n        reopen = kw.pop('reopen', False)\n        endpoint = kw.pop('endpoint', None)\n        download_id = kw.pop('download_id', None)\n\n        tunnel = self._create_table_tunnel(endpoint=endpoint)\n        if download_id is None:\n            download_ids = self._download_ids\n            download_id = download_ids.get(partition) if not reopen else None\n        download_session = tunnel.create_download_session(table=self, partition_spec=partition,\n                                                          download_id=download_id, **kw)\n\n        if download_id and download_session.status != TableDownloadSession.Status.Normal:\n            download_session = tunnel.create_download_session(table=self, partition_spec=partition, **kw)\n        download_ids[partition] = download_session.id\n\n        class RecordReader(readers.AbstractRecordReader):\n            def __init__(self):\n                self._it = iter(self)\n\n            @property\n            def download_id(self):\n                return download_session.id\n\n            @property\n            def count(self):\n                return download_session.count\n\n            @property\n            def status(self):\n                return download_session.status\n\n            def __iter__(self):\n                for record in self.read():\n                    yield record\n\n            def __next__(self):\n                return next(self._it)\n\n            next = __next__\n\n            def _iter(self, start=None, end=None, step=None):\n                count = self._calc_count(start, end, step)\n                return self.read(start=start, count=count, step=step)\n\n            def read(self, start=None, count=None, step=None,\n                     compress=False, columns=None):\n                start = start or 0\n                step = step or 1\n                count = count*step if count is not None else self.count-start\n\n                if count == 0:\n                    return\n\n                with download_session.open_record_reader(\n                        start, count, compress=compress, columns=columns) as reader:\n                    for record in reader[::step]:\n                        yield record\n\n            def __enter__(self):\n                return self\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                pass\n\n        return RecordReader()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nopens the writer to write records into this table or its partition.", "response": "def open_writer(self, partition=None, blocks=None, **kw):\n        \"\"\"\n        Open the writer to write records into this table or its partition.\n\n        :param partition: partition of this table\n        :param blocks: block ids to open\n        :param reopen: the reader will reuse last one, reopen is true means open a new reader.\n        :type reopen: bool\n        :param create_partition: if true, the partition will be created if not exist\n        :type create_partition: bool\n        :param endpoint: the tunnel service URL\n        :param upload_id: use existing upload_id to upload data\n        :param compress_option: compression algorithm, level and strategy\n        :type compress_option: :class:`odps.tunnel.CompressOption`\n        :param compress_algo: compression algorithm, work when ``compress_option`` is not provided,\n                              can be ``zlib``, ``snappy``\n        :param compress_level: used for ``zlib``, work when ``compress_option`` is not provided\n        :param compress_strategy: used for ``zlib``, work when ``compress_option`` is not provided\n        :return: writer, status means the tunnel writer status\n\n        :Example:\n\n        >>> with table.open_writer() as writer:\n        >>>     writer.write(records)\n        >>> with table.open_writer(partition='pt=test', blocks=[0, 1]):\n        >>>     writer.write(0, gen_records(block=0))\n        >>>     writer.write(1, gen_records(block=1))  # we can do this parallel\n        \"\"\"\n\n        from ..tunnel.tabletunnel import TableUploadSession\n        table_object = self\n\n        reopen = kw.pop('reopen', False)\n        commit = kw.pop('commit', True)\n        create_partition = kw.pop('create_partition', False)\n        endpoint = kw.pop('endpoint', None)\n        upload_id = kw.pop('upload_id', None)\n\n        if partition and not isinstance(partition, odps_types.PartitionSpec):\n            partition = odps_types.PartitionSpec(partition)\n        if create_partition and not self.exist_partition(create_partition):\n            self.create_partition(partition, if_not_exists=True)\n\n        tunnel = self._create_table_tunnel(endpoint=endpoint)\n        if upload_id is None:\n            upload_ids = self._upload_ids\n            upload_id = upload_ids.get(partition) if not reopen else None\n        upload_session = tunnel.create_upload_session(table=self, partition_spec=partition,\n                                                      upload_id=upload_id, **kw)\n\n        if upload_id and upload_session.status.value != TableUploadSession.Status.Normal.value:\n            # check upload session status\n            upload_session = tunnel.create_upload_session(table=self, partition_spec=partition, **kw)\n            upload_id = None\n        upload_ids[partition] = upload_session.id\n\n        blocks = blocks or upload_session.blocks or [0, ]\n        blocks_writes = [False] * len(blocks)\n        blocks_writers = [None] * len(blocks)\n\n        if upload_id:\n            for block in upload_session.blocks:\n                blocks_writes[blocks.index(block)] = True\n\n        class RecordWriter(object):\n            def __init__(self, table):\n                self._table = table\n                self._closed = False\n\n            @property\n            def upload_id(self):\n                return upload_session.id\n\n            @property\n            def status(self):\n                return upload_session.status\n\n            def write(self, *args, **kwargs):\n                from types import GeneratorType\n                from itertools import chain\n\n                if self._closed:\n                    raise IOError('Cannot write to a closed writer.')\n\n                block_id = kwargs.get('block_id')\n                if block_id is None:\n                    if isinstance(args[0], six.integer_types):\n                        block_id = args[0]\n                        args = args[1:]\n                    else:\n                        block_id = 0\n\n                if len(args) == 1:\n                    arg = args[0]\n                    if isinstance(arg, Record):\n                        records = [arg, ]\n                    elif isinstance(arg, (list, tuple)):\n                        if isinstance(arg[0], Record):\n                            records = arg\n                        elif isinstance(arg[0], (list, tuple)):\n                            records = (table_object.new_record(vals) for vals in arg)\n                        else:\n                            records = [table_object.new_record(arg), ]\n                    elif isinstance(arg, GeneratorType):\n                        try:\n                            # peek the first element and then put back\n                            next_arg = six.next(arg)\n                            chained = chain((next_arg, ), arg)\n                            if isinstance(next_arg, Record):\n                                records = chained\n                            else:\n                                records = (table_object.new_record(vals) for vals in chained)\n                        except StopIteration:\n                            records = ()\n                    else:\n                        raise ValueError('Unsupported record type.')\n                elif len(args) > 1:\n                    records = args\n                else:\n                    raise ValueError('Cannot write no records to table.')\n\n                compress = kwargs.get('compress', False)\n                idx = blocks.index(block_id)\n                writer = blocks_writers[idx]\n                if writer is None:\n                    writer = blocks_writers[idx] = \\\n                        upload_session.open_record_writer(block_id, compress=compress)\n\n                for record in records:\n                    writer.write(record)\n                blocks_writes[idx] = True\n\n            def close(self):\n                [writer.close() for writer in blocks_writers if writer is not None]\n\n                if commit:\n                    written_blocks = [block for block, block_write in zip(blocks, blocks_writes) if block_write]\n                    upload_session.commit(written_blocks)\n                    upload_ids[partition] = None\n\n                self._closed = True\n\n            def __enter__(self):\n                return self\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                # if an error occurs inside the with block, we do not commit\n                if exc_val is not None:\n                    return\n                self.close()\n\n        return RecordWriter(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a partition within the table.", "response": "def create_partition(self, partition_spec, if_not_exists=False, async_=False, **kw):\n        \"\"\"\n        Create a partition within the table.\n\n        :param partition_spec: specification of the partition.\n        :param if_not_exists:\n        :param async_:\n        :return: partition object\n        :rtype: odps.models.partition.Partition\n        \"\"\"\n        async_ = kw.get('async', async_)\n        return self.partitions.create(partition_spec, if_not_exists=if_not_exists, async_=async_)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_partition(self, partition_spec, if_exists=False, async_=False, **kw):\n        async_ = kw.get('async', async_)\n        return self.partitions.delete(partition_spec, if_exists=if_exists, async_=async_)", "response": "Delete a partition within the table."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exist_partitions(self, prefix_spec=None):\n        try:\n            next(self.partitions.iterate_partitions(spec=prefix_spec))\n        except StopIteration:\n            return False\n        return True", "response": "Check if partitions with provided conditions exist."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef truncate(self, async_=False, **kw):\n        from .tasks import SQLTask\n        async_ = kw.get('async', async_)\n        task = SQLTask(name='SQLTruncateTableTask', query='truncate table %s.%s' % (self.project.name, self.name))\n        instance = self.project.parent[self._client.project].instances.create(task=task)\n\n        if not async_:\n            instance.wait_for_success()\n        else:\n            return instance", "response": "truncate this table.\n\n        :param async_: run asynchronously if True\n        :return: None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef drop(self, async_=False, if_exists=False, **kw):\n        async_ = kw.get('async', async_)\n        return self.parent.delete(self, async_=async_, if_exists=if_exists)", "response": "Drop this table.\n\n        :param async_: run asynchronously if True\n        :return: None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn formatted strings specified by date_format", "response": "def _strftime(expr, date_format):\n    \"\"\"\n    Return formatted strings specified by date_format,\n    which supports the same string format as the python standard library.\n    Details of the string format can be found in python string format doc\n\n    :param expr:\n    :param date_format: date format string (e.g. \u201c%Y-%m-%d\u201d)\n    :type date_format: str\n    :return:\n    \"\"\"\n\n    return datetime_op(expr, Strftime, output_type=types.string,\n                       _date_format=date_format)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sort_values(expr, by, ascending=True):\n    if not isinstance(by, list):\n        by = [by, ]\n    by = [it(expr) if inspect.isfunction(it) else it for it in by]\n    return SortedCollectionExpr(expr, _sorted_fields=by, _ascending=ascending,\n                                _schema=expr._schema)", "response": "Sort the collection by values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef distinct(expr, on=None, *ons):\n\n    on = on or list()\n    if not isinstance(on, list):\n        on = [on, ]\n    on = on + list(ons)\n\n    on = [it(expr) if inspect.isfunction(it) else it for it in on]\n\n    return DistinctCollectionExpr(expr, _unique_fields=on, _all=(len(on) == 0))", "response": "Get collection with duplicate rows removed optionally only considering certain columns"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsample the sequence of items from the sequence of parts columns i and n.", "response": "def sample(expr, parts=None, columns=None, i=None, n=None, frac=None, replace=False,\n           weights=None, strata=None, random_state=None):\n    \"\"\"\n    Sample collection.\n\n    :param expr: collection\n    :param parts: how many parts to hash\n    :param columns: the columns to sample\n    :param i: the part to sample out, can be a list of parts, must be from 0 to parts-1\n    :param n: how many rows to sample. If `strata` is specified, `n` should be a dict with values in the strata column as dictionary keys and corresponding sample size as values\n    :param frac: how many fraction to sample. If `strata` is specified, `n` should be a dict with values in the strata column as dictionary keys and corresponding sample weight as values\n    :param replace: whether to perform replace sampling\n    :param weights: the column name of weights\n    :param strata: the name of strata column\n    :param random_state: the random seed when performing sampling\n    :return: collection\n\n    Note that n, frac, replace, weights, strata and random_state can only be used under Pandas DataFrames or\n    XFlow.\n\n    :Example:\n\n    Sampling with parts:\n\n    >>> df.sample(parts=1)\n    >>> df.sample(parts=5, i=0)\n    >>> df.sample(parts=10, columns=['name'])\n\n    Sampling with fraction or weights, replacement option can be specified:\n\n    >>> df.sample(n=100)\n    >>> df.sample(frac=100)\n    >>> df.sample(frac=100, replace=True)\n\n    Sampling with weight column:\n\n    >>> df.sample(n=100, weights='weight_col')\n    >>> df.sample(n=100, weights='weight_col', replace=True)\n\n    Stratified sampling. Note that currently we do not support stratified sampling with replacement.\n\n    >>> df.sample(strata='category', frac={'Iris Setosa': 0.5, 'Iris Versicolour': 0.4})\n    \"\"\"\n    if isinstance(expr, CollectionExpr):\n        if n is None and frac is None and parts is None:\n            raise ExpressionError('Either n or frac or parts should be provided')\n        if i is not None and parts is None:\n            raise ExpressionError('`parts` arg is required when `i` arg is specified')\n        if len([arg for arg in (n, frac, parts) if arg is not None]) > 1:\n            raise ExpressionError('You cannot specify `n` or `frac` or `parts` at the same time')\n        if strata is None and n is not None and frac is not None:\n            # strata can specify different types of strategies on different columns\n            raise ExpressionError('You cannot specify `n` and `frac` at the same time.')\n        if weights is not None and strata is not None:\n            raise ExpressionError('You cannot specify `weights` and `strata` at the same time.')\n        if strata is not None:\n            if frac is not None and not isinstance(frac, (six.string_types, dict)):\n                raise ExpressionError('`frac` should be a k-v string or a dictionary object.')\n            if isinstance(frac, six.string_types):\n                frac = str_to_kv(frac, float)\n\n            if n is not None and not isinstance(n, (six.string_types, dict)):\n                raise ExpressionError('`n` should be a k-v string or a dictionary object.')\n            if isinstance(n, six.string_types):\n                n = str_to_kv(n, int)\n\n            for val in six.itervalues(frac or dict()):\n                if val < 0 or val > 1:\n                    raise ExpressionError('Values in `frac` must be between 0 and 1')\n            if n is not None and frac is not None:\n                collides = set(six.iterkeys(n)).intersection(set(six.iterkeys(frac)))\n                if collides:\n                    raise ExpressionError('Values in `frac` and `n` collides with each other.')\n        else:\n            if frac is not None and (not isinstance(frac, (six.integer_types, float)) or frac < 0 or frac > 1):\n                raise ExpressionError('`frac` must be between 0 and 1')\n\n        if parts is not None:\n            if i is None:\n                i = (0, )\n            elif isinstance(i, list):\n                i = tuple(i)\n            elif not isinstance(i, tuple):\n                i = (i, )\n\n            for it in i:\n                if it >= parts or it < 0:\n                    raise ExpressionError('`i` should be positive numbers that less than `parts`')\n        elif hasattr(expr, '_xflow_sample'):\n            return expr._xflow_sample(n=n, frac=frac, replace=replace, weights=weights, strata=strata,\n                                      random_state=random_state)\n\n        return expr.__sample(parts=parts, columns=columns, i=i, n=n, frac=frac, replace=replace,\n                             weights=weights, strata=strata, random_state=random_state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying a function to a row or column of a sequence.", "response": "def apply(expr, func, axis=0, names=None, types=None, reduce=False,\n          resources=None, keep_nulls=False, args=(), **kwargs):\n    \"\"\"\n    Apply a function to a row when axis=1 or column when axis=0.\n\n    :param expr:\n    :param func: function to apply\n    :param axis: row when axis=1 else column\n    :param names: output names\n    :param types: output types\n    :param reduce: if True will return a sequence else return a collection\n    :param resources: resources to read\n    :param keep_nulls: if True, keep rows producing empty results, only work in lateral views\n    :param args: args for function\n    :param kwargs: kwargs for function\n    :return:\n\n    :Example:\n\n    Apply a function to a row:\n\n    >>> from odps.df import output\n    >>>\n    >>> @output(['iris_add', 'iris_sub'], ['float', 'float'])\n    >>> def handle(row):\n    >>>     yield row.sepallength - row.sepalwidth, row.sepallength + row.sepalwidth\n    >>>     yield row.petallength - row.petalwidth, row.petallength + row.petalwidth\n    >>>\n    >>> iris.apply(handle, axis=1).count()\n\n\n    Apply a function to a column:\n\n    >>> class Agg(object):\n    >>>\n    >>>     def buffer(self):\n    >>>         return [0.0, 0]\n    >>>\n    >>>     def __call__(self, buffer, val):\n    >>>         buffer[0] += val\n    >>>         buffer[1] += 1\n    >>>\n    >>>     def merge(self, buffer, pbuffer):\n    >>>         buffer[0] += pbuffer[0]\n    >>>         buffer[1] += pbuffer[1]\n    >>>\n    >>>     def getvalue(self, buffer):\n    >>>         if buffer[1] == 0:\n    >>>             return 0.0\n    >>>         return buffer[0] / buffer[1]\n    >>>\n    >>> iris.exclude('name').apply(Agg)\n    \"\"\"\n\n    if not isinstance(expr, CollectionExpr):\n        return\n\n    if isinstance(func, FunctionWrapper):\n        names = names or func.output_names\n        types = types or func.output_types\n        func = func._func\n\n    if axis == 0:\n        types = types or expr.schema.types\n        types = [validate_data_type(t) for t in types]\n\n        fields = [expr[n].agg(func, rtype=t, resources=resources)\n                  for n, t in zip(expr.schema.names, types)]\n        if names:\n            fields = [f.rename(n) for f, n in zip(fields, names)]\n        else:\n            names = [f.name for f in fields]\n        return Summary(_input=expr, _fields=fields, _schema=Schema.from_lists(names, types))\n    else:\n        collection_resources = utils.get_collection_resources(resources)\n\n        if types is not None:\n            if isinstance(types, list):\n                types = tuple(types)\n            elif isinstance(types, six.string_types):\n                types = (types,)\n\n            types = tuple(validate_data_type(t) for t in types)\n        if reduce:\n            from .element import MappedExpr\n            from ..backends.context import context\n\n            if names is not None and len(names) > 1:\n                raise ValueError('When reduce, at most one name can be specified')\n            name = names[0] if names is not None else None\n            if not types and kwargs.get('rtype', None) is not None:\n                types = [kwargs.pop('rtype')]\n            tp = types[0] if types is not None else (utils.get_annotation_rtype(func) or string)\n            if not context.is_cached(expr) and (hasattr(expr, '_fields') and expr._fields is not None):\n                inputs = [e.copy_tree(stop_cond=lambda x: any(i is expr.input for i in x.children()))\n                          for e in expr._fields]\n            else:\n                inputs = [expr[n] for n in expr.schema.names]\n            return MappedExpr(_func=func, _func_args=args, _func_kwargs=kwargs,\n                              _name=name, _data_type=tp,\n                              _inputs=inputs, _multiple=True,\n                              _resources=resources, _collection_resources=collection_resources)\n        else:\n            return _apply_horizontal(expr, func, names=names, types=types, resources=resources,\n                                     collection_resources=collection_resources, keep_nulls=keep_nulls,\n                                     args=args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reshuffle(expr, by=None, sort=None, ascending=True):\n\n    by = by or RandomScalar()\n\n    grouped = expr.groupby(by)\n    if sort:\n        grouped = grouped.sort_values(sort, ascending=ascending)\n\n    return ReshuffledCollectionExpr(_input=grouped, _schema=expr._schema)", "response": "Reshuffle data.\n\n    :param expr:\n    :param by: the sequence or scalar to shuffle by. RandomScalar as default\n    :param sort: the sequence or scalar to sort.\n    :param ascending: True if ascending else False\n    :return: collection"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef map_reduce(expr, mapper=None, reducer=None, group=None, sort=None, ascending=True,\n               combiner=None, combiner_buffer_size=1024,\n               mapper_output_names=None, mapper_output_types=None, mapper_resources=None,\n               reducer_output_names=None, reducer_output_types=None, reducer_resources=None):\n    \"\"\"\n    MapReduce API, mapper or reducer should be provided.\n\n    :param expr:\n    :param mapper: mapper function or class\n    :param reducer: reducer function or class\n    :param group: the keys to group after mapper\n    :param sort: the keys to sort after mapper\n    :param ascending: True if ascending else False\n    :param combiner: combiner function or class, combiner's output should be equal to mapper\n    :param combiner_buffer_size: combiner's buffer size, 1024 as default\n    :param mapper_output_names: mapper's output names\n    :param mapper_output_types: mapper's output types\n    :param mapper_resources: the resources for mapper\n    :param reducer_output_names: reducer's output names\n    :param reducer_output_types: reducer's output types\n    :param reducer_resources: the resources for reducer\n    :return:\n\n    :Example:\n\n    >>> from odps.df import output\n    >>>\n    >>> @output(['word', 'cnt'], ['string', 'int'])\n    >>> def mapper(row):\n    >>>     for word in row[0].split():\n    >>>         yield word.lower(), 1\n    >>>\n    >>> @output(['word', 'cnt'], ['string', 'int'])\n    >>> def reducer(keys):\n    >>>     cnt = [0]\n    >>>     def h(row, done):  # done illustrates that all the rows of the keys are processed\n    >>>         cnt[0] += row.cnt\n    >>>         if done:\n    >>>             yield keys.word, cnt[0]\n    >>>     return h\n    >>>\n    >>> words_df.map_reduce(mapper, reducer, group='word')\n    \"\"\"\n\n    def _adjust_partial(fun):\n        if isinstance(fun, functools.partial) and isinstance(fun.func, FunctionWrapper):\n            wrapped_fun = fun.func\n            partial_fun = functools.partial(wrapped_fun._func, *fun.args, **fun.keywords)\n            ret_fun = FunctionWrapper(partial_fun)\n            ret_fun.output_names = wrapped_fun.output_names\n            ret_fun.output_types = wrapped_fun.output_types\n            return ret_fun\n        else:\n            return fun\n\n    def conv(l):\n        if l is None:\n            return\n        if isinstance(l, tuple):\n            l = list(l)\n        elif not isinstance(l, list):\n            l = [l, ]\n\n        return l\n\n    def gen_name():\n        return 'pyodps_field_%s' % str(uuid.uuid4()).replace('-', '_')\n\n    def _gen_actual_reducer(reducer, group):\n        class ActualReducer(object):\n            def __init__(self, resources=None):\n                self._func = reducer\n                self._curr = None\n                self._prev_rows = None\n                self._key_named_tuple = namedtuple('NamedKeys', group)\n\n                self._resources = resources\n                self._f = None\n\n            def _is_generator_function(self, f):\n                if inspect.isgeneratorfunction(f):\n                    return True\n                elif hasattr(f, '__call__') and inspect.isgeneratorfunction(f.__call__):\n                    return True\n                return False\n\n            def __call__(self, row):\n                key = tuple(getattr(row, n) for n in group)\n                k = self._key_named_tuple(*key)\n\n                if self._prev_rows is not None:\n                    key_consumed = self._curr != key\n                    if self._is_generator_function(self._f):\n                        for it in self._f(self._prev_rows, key_consumed):\n                            yield it\n                    else:\n                        res = self._f(self._prev_rows, key_consumed)\n                        if res:\n                            yield res\n\n                self._prev_rows = row\n\n                if self._curr is None or self._curr != key:\n                    self._curr = key\n                    if self._resources and self._f is None:\n                        self._func = self._func(self._resources)\n                    self._f = self._func(k)\n\n            def close(self):\n                if self._prev_rows and self._curr:\n                    if self._is_generator_function(self._f):\n                        for it in self._f(self._prev_rows, True):\n                            yield it\n                    else:\n                        res = self._f(self._prev_rows, True)\n                        if res:\n                            yield res\n                self._prev_rows = None\n\n        return ActualReducer\n\n    def _gen_combined_mapper(mapper, combiner, names, group, sort, ascending,\n                             buffer_size, mapper_resources=None):\n        mapper = mapper if not isinstance(mapper, FunctionWrapper) else mapper._func\n        sort_indexes = [names.index(s) for s in sort]\n        if isinstance(ascending, bool):\n            ascending = [ascending] * len(sort)\n\n        class CombinedMapper(object):\n            def __init__(self, resources=None):\n                if mapper_resources:\n                    self.f = mapper(resources)\n                elif inspect.isclass(mapper):\n                    self.f = mapper()\n                else:\n                    self.f = mapper\n                self.buffer = list()\n                if inspect.isfunction(self.f):\n                    self.is_generator = inspect.isgeneratorfunction(self.f)\n                else:\n                    self.is_generator = inspect.isgeneratorfunction(self.f.__call__)\n\n            def _cmp_to_key(self, cmp):\n                \"\"\"Convert a cmp= function into a key= function\"\"\"\n\n                class K(object):\n                    def __init__(self, obj):\n                        self.obj = obj\n\n                    def __lt__(self, other):\n                        return cmp(self.obj, other.obj) < 0\n\n                    def __gt__(self, other):\n                        return cmp(self.obj, other.obj) > 0\n\n                    def __eq__(self, other):\n                        return cmp(self.obj, other.obj) == 0\n\n                    def __le__(self, other):\n                        return cmp(self.obj, other.obj) <= 0\n\n                    def __ge__(self, other):\n                        return cmp(self.obj, other.obj) >= 0\n\n                    def __ne__(self, other):\n                        return cmp(self.obj, other.obj) != 0\n\n                return K\n\n            def _combine(self):\n                def cmp(x, y):\n                    for asc, sort_idx in zip(ascending, sort_indexes):\n                        indict = 1 if asc else -1\n                        if x[sort_idx] > y[sort_idx]:\n                            return indict * 1\n                        elif x[sort_idx] < y[sort_idx]:\n                            return indict * -1\n                        else:\n                            continue\n\n                    return 0\n\n                self.buffer.sort(key=self._cmp_to_key(cmp))\n\n                ActualCombiner = _gen_actual_reducer(combiner, group)\n                ac = ActualCombiner()\n                named_row = namedtuple('NamedRow', names)\n                for r in self.buffer:\n                    row = named_row(*r)\n                    for l in ac(row):\n                        yield l\n                for l in ac.close():\n                    yield l\n\n                self.buffer = []\n\n            def _handle_output_line(self, line):\n                if len(self.buffer) >= buffer_size:\n                    for l in self._combine():\n                        yield l\n\n                self.buffer.append(line)\n\n            def __call__(self, row):\n                if self.is_generator:\n                    for it in self.f(row):\n                        for l in self._handle_output_line(it):\n                            yield l\n                else:\n                    for l in self._handle_output_line(self.f(row)):\n                        yield l\n\n            def close(self):\n                if len(self.buffer) > 0:\n                    for l in self._combine():\n                        yield l\n\n        return CombinedMapper\n\n    mapper = _adjust_partial(mapper)\n    reducer = _adjust_partial(reducer)\n    combiner = _adjust_partial(combiner)\n\n    if isinstance(mapper, FunctionWrapper):\n        mapper_output_names = mapper_output_names or mapper.output_names\n        mapper_output_types = mapper_output_types or mapper.output_types\n\n    mapper_output_names = conv(mapper_output_names)\n    mapper_output_types = conv(mapper_output_types)\n\n    if mapper_output_types is not None and mapper_output_names is None:\n        mapper_output_names = [gen_name() for _ in range(len(mapper_output_types))]\n\n    if mapper is None and mapper_output_names is None:\n        mapper_output_names = expr.schema.names\n\n    group = conv(group) or mapper_output_names\n    sort = sort or tuple()\n    sort = list(OrderedDict.fromkeys(group + conv(sort)))\n    if len(sort) > len(group):\n        ascending = [ascending, ] * (len(sort) - len(group)) \\\n            if isinstance(ascending, bool) else list(ascending)\n        if len(ascending) != len(sort):\n            ascending = [True] * len(group) + ascending\n\n    if not set(group + sort).issubset(mapper_output_names):\n        raise ValueError('group and sort have to be the column names of mapper')\n\n    if mapper is None:\n        if mapper_output_names and mapper_output_names != expr.schema.names:\n            raise ExpressionError(\n                'Null mapper cannot have mapper output names: %s' % mapper_output_names)\n        if mapper_output_types and mapper_output_types != expr.schema.types:\n            raise ExpressionError(\n                'Null mapper cannot have mapper output types: %s' % mapper_output_types)\n        mapped = expr\n        if combiner is not None:\n            raise ValueError('Combiner is not null when mapper is null')\n    else:\n        if combiner is not None:\n            if isinstance(combiner, FunctionWrapper):\n                if combiner.output_names and \\\n                        combiner.output_names != mapper_output_names:\n                    raise ExpressionError(\n                        'Combiner must have the same output names with mapper')\n                if combiner.output_types and \\\n                        combiner.output_types != mapper_output_types:\n                    raise ExpressionError(\n                        'Combiner must have the same output types with mapper')\n                combiner = combiner._func\n            mapper = _gen_combined_mapper(mapper, combiner, mapper_output_names,\n                                          group, sort, ascending, combiner_buffer_size,\n                                          mapper_resources=mapper_resources)\n        mapped = expr.apply(mapper, axis=1, names=mapper_output_names,\n                            types=mapper_output_types, resources=mapper_resources)\n\n    clustered = mapped.groupby(group).sort(sort, ascending=ascending)\n\n    if isinstance(reducer, FunctionWrapper):\n        reducer_output_names = reducer_output_names or reducer.output_names\n        reducer_output_types = reducer_output_types or reducer.output_types\n        reducer = reducer._func\n\n    if reducer is None:\n        if reducer_output_names and reducer_output_names != mapped.schema.names:\n            raise ExpressionError(\n                'Null reducer cannot have reducer output names %s' % reducer_output_names)\n        if reducer_output_types and reducer_output_types != mapped.schema.types:\n            raise ExpressionError(\n                'Null reducer cannot have reducer output types %s' % reducer_output_types)\n        return mapped\n\n    ActualReducer = _gen_actual_reducer(reducer, group)\n    return clustered.apply(ActualReducer, resources=reducer_resources,\n                           names=reducer_output_names, types=reducer_output_types)", "response": "MapReduce API for a sequence of words."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pivot(expr, rows, columns, values=None):\n\n    rows = [expr._get_field(r) for r in utils.to_list(rows)]\n    columns = [expr._get_field(c) for c in utils.to_list(columns)]\n    if values:\n        values = utils.to_list(values)\n    else:\n        names = set(c.name for c in rows + columns)\n        values = [n for n in expr.schema.names if n not in names]\n        if not values:\n            raise ValueError('No values found for pivot')\n    values = [expr._get_field(v) for v in values]\n\n    if len(columns) > 1:\n        raise ValueError('More than one `columns` are not supported yet')\n\n    return PivotCollectionExpr(_input=expr, _group=rows,\n                               _columns=columns, _values=values)", "response": "Produce \u2018pivot\u2019 table based on 3 columns of this DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pivot_table(expr, values=None, rows=None, columns=None, aggfunc='mean',\n                fill_value=None):\n    \"\"\"\n    Create a spreadsheet-style pivot table as a DataFrame.\n\n    :param expr: collection\n    :param values (optional): column to aggregate\n    :param rows: rows to group\n    :param columns: keys to group by on the pivot table column\n    :param aggfunc: aggregate function or functions\n    :param fill_value (optional): value to replace missing value with, default None\n    :return: collection\n\n    :Example:\n    >>> df\n        A    B      C   D\n    0  foo  one  small  1\n    1  foo  one  large  2\n    2  foo  one  large  2\n    3  foo  two  small  3\n    4  foo  two  small  3\n    5  bar  one  large  4\n    6  bar  one  small  5\n    7  bar  two  small  6\n    8  bar  two  large  7\n    >>> table = df.pivot_table(values='D', rows=['A', 'B'], columns='C', aggfunc='sum')\n    >>> table\n         A    B  large_D_sum   small_D_sum\n    0  bar  one          4.0           5.0\n    1  bar  two          7.0           6.0\n    2  foo  one          4.0           1.0\n    3  foo  two          NaN           6.0\n    \"\"\"\n\n    def get_names(iters):\n        return [r if isinstance(r, six.string_types) else r.name\n                for r in iters]\n\n    def get_aggfunc_name(f):\n        if isinstance(f, six.string_types):\n            if '(' in f:\n                f = re.sub(r' *\\( *', '_', f)\n                f = re.sub(r' *[+\\-\\*/,] *', '_', f)\n                f = re.sub(r' *\\) *', '', f)\n                f = f.replace('.', '_')\n            return f\n        if isinstance(f, FunctionWrapper):\n            return f.output_names[0]\n        return 'aggregation'\n\n    if not rows:\n        raise ValueError('No group keys passed')\n    rows = utils.to_list(rows)\n    rows_names = get_names(rows)\n    rows = [expr._get_field(r) for r in rows]\n\n    if isinstance(aggfunc, dict):\n        agg_func_names = lkeys(aggfunc)\n        aggfunc = lvalues(aggfunc)\n    else:\n        aggfunc = utils.to_list(aggfunc)\n        agg_func_names = [get_aggfunc_name(af) for af in aggfunc]\n\n    if not columns:\n        if values is None:\n            values = [n for n in expr.schema.names if n not in rows_names]\n        else:\n            values = utils.to_list(values)\n        values = [expr._get_field(v) for v in values]\n\n        names = rows_names\n        types = [r.dtype for r in rows]\n        for func, func_name in zip(aggfunc, agg_func_names):\n            for value in values:\n                if isinstance(func, six.string_types):\n                    seq = value.eval(func, rewrite=False)\n                    if isinstance(seq, ReprWrapper):\n                        seq = seq()\n                else:\n                    seq = value.agg(func)\n                seq = seq.rename('{0}_{1}'.format(value.name, func_name))\n                names.append(seq.name)\n                types.append(seq.dtype)\n        schema = Schema.from_lists(names, types)\n\n        return PivotTableCollectionExpr(_input=expr, _group=rows, _values=values,\n                                        _fill_value=fill_value, _schema=schema,\n                                        _agg_func=aggfunc, _agg_func_names=agg_func_names)\n    else:\n        columns = [expr._get_field(c) for c in utils.to_list(columns)]\n\n        if values:\n            values = utils.to_list(values)\n        else:\n            names = set(c.name for c in rows + columns)\n            values = [n for n in expr.schema.names if n not in names]\n            if not values:\n                raise ValueError('No values found for pivot_table')\n        values = [expr._get_field(v) for v in values]\n\n        if len(columns) > 1:\n            raise ValueError('More than one `columns` are not supported yet')\n\n        schema = DynamicSchema.from_lists(rows_names, [r.dtype for r in rows])\n        base_tp = PivotTableCollectionExpr\n        tp = type(base_tp.__name__, (DynamicCollectionExpr, base_tp), dict())\n        return tp(_input=expr, _group=rows, _values=values,\n                  _columns=columns, _agg_func=aggfunc,\n                  _fill_value=fill_value, _schema=schema,\n                  _agg_func_names=agg_func_names)", "response": "Create a spreadsheet - style pivot table as a DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef min_max_scale(expr, columns=None, feature_range=(0, 1), preserve=False, suffix='_scaled', group=None):\n    time_suffix = str(int(time.time()))\n\n    def calc_agg(expr, col):\n        return [\n            getattr(expr, col).min().rename(col + '_min_' + time_suffix),\n            getattr(expr, col).max().rename(col + '_max_' + time_suffix),\n        ]\n\n    def do_scale(expr, col):\n        f_min, f_max = feature_range\n        r = getattr(expr, col + '_max_' + time_suffix) - getattr(expr, col + '_min_' + time_suffix)\n        scaled = (r == 0).ifelse(Scalar(0), (getattr(expr, col) - getattr(expr, col + '_min_' + time_suffix)) / r)\n        return scaled * (f_max - f_min) + f_min\n\n    return _scale_values(expr, columns, calc_agg, do_scale, preserve=preserve, suffix=suffix, group=group)", "response": "Resize a data frame by min max and scale the data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract values in key - value represented columns into standalone columns.", "response": "def extract_kv(expr, columns=None, kv_delim=':', item_delim=',', dtype='float', fill_value=None):\n    \"\"\"\n    Extract values in key-value represented columns into standalone columns. New column names will\n    be the name of the key-value column followed by an underscore and the key.\n\n    :param DataFrame expr: input DataFrame\n    :param columns: the key-value columns to be extracted.\n    :param str kv_delim: delimiter between key and value.\n    :param str item_delim: delimiter between key-value pairs.\n    :param str dtype: type of value columns to generate.\n    :param fill_value: default value for missing key-value pairs.\n\n    :return: extracted data frame\n    :rtype: DataFrame\n\n    :Example:\n    >>> df\n        name   kv\n    0  name1  k1=1.0,k2=3.0,k5=10.0\n    1  name2  k2=3.0,k3=5.1\n    2  name3  k1=7.1,k7=8.2\n    3  name4  k2=1.2,k3=1.5\n    4  name5  k2=1.0,k9=1.1\n    >>> table = df.extract_kv(columns=['A', 'B'], kv_delim='=')\n    >>> table\n        name   kv_k1   kv_k2   kv_k3   kv_k5   kv_k7   kv_k9\n    0  name1  1.0     3.0     Nan     10.0    Nan     Nan\n    1  name2  Nan     3.0     5.1     Nan     Nan     Nan\n    2  name3  7.1     Nan     Nan     Nan     8.2     Nan\n    3  name4  Nan     1.2     1.5     Nan     Nan     Nan\n    4  name5  Nan     1.0     Nan     Nan     Nan     1.1\n    \"\"\"\n    if columns is None:\n        columns = [expr._get_field(c) for c in expr.schema.names]\n        intact_cols = []\n    else:\n        columns = [expr._get_field(c) for c in utils.to_list(columns)]\n        name_set = set([c.name for c in columns])\n        intact_cols = [expr._get_field(c) for c in expr.schema.names if c not in name_set]\n\n    column_type = types.validate_data_type(dtype)\n    if any(not isinstance(c.dtype, types.String) for c in columns):\n        raise ExpressionError('Key-value columns must be strings.')\n\n    schema = DynamicSchema.from_lists([c.name for c in intact_cols], [c.dtype for c in intact_cols])\n    return ExtractKVCollectionExpr(_input=expr, _columns=columns, _intact=intact_cols, _schema=schema,\n                                   _column_type=column_type, _default=fill_value,\n                                   _kv_delimiter=kv_delim, _item_delimiter=item_delim)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a DataFrame with the values in specified columns into a key - value represented column.", "response": "def to_kv(expr, columns=None, kv_delim=':', item_delim=',', kv_name='kv_col'):\n    \"\"\"\n    Merge values in specified columns into a key-value represented column.\n\n    :param DataFrame expr: input DataFrame\n    :param columns: the columns to be merged.\n    :param str kv_delim: delimiter between key and value.\n    :param str item_delim: delimiter between key-value pairs.\n    :param str kv_col: name of the new key-value column\n\n    :return: converted data frame\n    :rtype: DataFrame\n\n    :Example:\n    >>> df\n        name   k1   k2   k3   k5    k7   k9\n    0  name1  1.0  3.0  Nan  10.0  Nan  Nan\n    1  name2  Nan  3.0  5.1  Nan   Nan  Nan\n    2  name3  7.1  Nan  Nan  Nan   8.2  Nan\n    3  name4  Nan  1.2  1.5  Nan   Nan  Nan\n    4  name5  Nan  1.0  Nan  Nan   Nan  1.1\n    >>> table = df.to_kv(columns=['A', 'B'], kv_delim='=')\n    >>> table\n        name   kv_col\n    0  name1  k1=1.0,k2=3.0,k5=10.0\n    1  name2  k2=3.0,k3=5.1\n    2  name3  k1=7.1,k7=8.2\n    3  name4  k2=1.2,k3=1.5\n    4  name5  k2=1.0,k9=1.1\n    \"\"\"\n    if columns is None:\n        columns = [expr._get_field(c) for c in expr.schema.names]\n        intact_cols = []\n    else:\n        columns = [expr._get_field(c) for c in utils.to_list(columns)]\n        name_set = set([c.name for c in columns])\n        intact_cols = [expr._get_field(c) for c in expr.schema.names if c not in name_set]\n\n    mapped_cols = [c.isnull().ifelse(Scalar(''), c.name + kv_delim + c.astype('string')) for c in columns]\n    reduced_col = reduce(lambda a, b: (b == '').ifelse(a, (a == '').ifelse(b, a + item_delim + b)), mapped_cols)\n    return expr.__getitem__(intact_cols + [reduced_col.rename(kv_name)])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dropna(expr, how='any', thresh=None, subset=None):\n    if subset is None:\n        subset = [expr._get_field(c) for c in expr.schema.names]\n    else:\n        subset = [expr._get_field(c) for c in utils.to_list(subset)]\n\n    if not subset:\n        raise ValueError('Illegal subset is provided.')\n\n    if thresh is None:\n        thresh = len(subset) if how == 'any' else 1\n\n    sum_exprs = reduce(operator.add, (s.notnull().ifelse(1, 0) for s in subset))\n    return expr.filter(sum_exprs >= thresh)", "response": "Return DataFrame with missing labels on given axis omitted where alternately any or all of the data are missing."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fillna(expr, value=None, method=None, subset=None):\n    col_dict = OrderedDict([(c, expr._get_field(c)) for c in expr.schema.names])\n    if subset is None:\n        sel_col_names = expr.schema.names\n    else:\n        # when c is in expr._fields, _get_field may do substitution which will cause error\n        subset = (c.copy() if isinstance(c, Expr) else c for c in utils.to_list(subset))\n        sel_col_names = [expr._get_field(c).name for c in subset]\n\n    if method is not None and value is not None:\n        raise ValueError('The argument `method` is not compatible with `value`.')\n    if method is None and value is None:\n        raise ValueError('You should supply at least one argument in `method` and `value`.')\n    if method is not None and method not in ('backfill', 'bfill', 'pad', 'ffill'):\n        raise ValueError('Method value %s is illegal.' % str(method))\n\n    if method in ('backfill', 'bfill'):\n        sel_cols = list(reversed(sel_col_names))\n    else:\n        sel_cols = sel_col_names\n\n    if method is None:\n        for n in sel_col_names:\n            e = col_dict[n]\n            col_dict[n] = e.isnull().ifelse(value, e).rename(n)\n        return expr.select(list(col_dict.values()))\n\n    else:\n        names = list(col_dict.keys())\n        typs = list(c.dtype.name for c in col_dict.values())\n\n        @output(names, typs)\n        def mapper(row):\n            last_valid = None\n            update_dict = dict()\n\n            try:\n                import numpy as np\n\n                def isnan(v):\n                    try:\n                        return np.isnan(v)\n                    except TypeError:\n                        return False\n\n            except ImportError:\n                isnan = lambda v: False\n\n            for n in sel_cols:\n                old_val = getattr(row, n)\n                if old_val is None or isnan(old_val):\n                    if last_valid is not None:\n                        update_dict[n] = last_valid\n                else:\n                    last_valid = old_val\n\n            yield row.replace(**update_dict)\n\n        return expr.map_reduce(mapper)", "response": "Fill NA values with the specified value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending an ID column to current column to form a new DataFrame.", "response": "def append_id(expr, id_col='append_id'):\n    \"\"\"\n    Append an ID column to current column to form a new DataFrame.\n\n    :param str id_col: name of appended ID field.\n\n    :return: DataFrame with ID field\n    :rtype: DataFrame\n    \"\"\"\n    if hasattr(expr, '_xflow_append_id'):\n        return expr._xflow_append_id(id_col)\n    else:\n        return _append_id(expr, id_col)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef split(expr, frac, seed=None):\n    if hasattr(expr, '_xflow_split'):\n        return expr._xflow_split(frac, seed=seed)\n    else:\n        return _split(expr, frac, seed=seed)", "response": "Split the current column into two column objects with certain ratio."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef applymap(expr, func, rtype=None, resources=None, columns=None, excludes=None, args=(), **kwargs):\n    if columns is not None and excludes is not None:\n        raise ValueError('`columns` and `excludes` cannot be provided at the same time.')\n    if not columns:\n        excludes = excludes or []\n        if isinstance(excludes, six.string_types):\n            excludes = [excludes]\n        excludes = set([c if isinstance(c, six.string_types) else c.name for c in excludes])\n        columns = set([c for c in expr.schema.names if c not in excludes])\n    else:\n        if isinstance(columns, six.string_types):\n            columns = [columns]\n        columns = set([c if isinstance(c, six.string_types) else c.name for c in columns])\n    mapping = [expr[c] if c not in columns\n               else expr[c].map(func, rtype=rtype, resources=resources, args=args, **kwargs)\n               for c in expr.schema.names]\n    return expr.select(*mapping)", "response": "Applies func to each element of this sequence returning a new collection with the applied result."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread up to size bytes from the stream stopping early if we reach the end of the stream.", "response": "def read_string(self, size):\n        \"\"\"Reads up to 'size' bytes from the stream, stopping early\n        only if we reach the end of the stream.  Returns the bytes read\n        as a string.\n        \"\"\"\n        if size < 0:\n            raise errors.DecodeError('Negative size %d' % size)\n        s = self._input.read(size)\n        if len(s) != size:\n            raise errors.DecodeError('String claims to have %d bytes, but read %d' % (size, len(s)))\n        self._pos += len(s)  # Only advance by the number of bytes actually read.\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninterprets the next 4 bytes of the stream as a little - endian 32 - bit integer and returns that integer.", "response": "def read_little_endian32(self):\n        \"\"\"Interprets the next 4 bytes of the stream as a little-endian\n        encoded, unsiged 32-bit integer, and returns that integer.\n        \"\"\"\n        try:\n            i = struct.unpack(wire_format.FORMAT_UINT32_LITTLE_ENDIAN,\n                              self._input.read(4))\n            self._pos += 4\n            return i[0]  # unpack() result is a 1-element tuple.\n        except struct.error as e:\n            raise errors.DecodeError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninterpreting the next 8 bytes of the stream as a little - endian 64 - bit integer and returns that integer.", "response": "def read_little_endian64(self):\n        \"\"\"Interprets the next 8 bytes of the stream as a little-endian\n        encoded, unsiged 64-bit integer, and returns that integer.\n        \"\"\"\n        try:\n            i = struct.unpack(wire_format.FORMAT_UINT64_LITTLE_ENDIAN,\n                              self._input.read(8))\n            self._pos += 8\n            return i[0]  # unpack() result is a 1-element tuple.\n        except struct.error as e:\n            raise errors.DecodeError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_varint32(self):\n        i = self.read_varint64()\n        if not wire_format.INT32_MIN <= i <= wire_format.INT32_MAX:\n            raise errors.DecodeError('Value out of range for int32: %d' % i)\n        return int(i)", "response": "Reads a varint from the stream interprets this varint\n        as a signed 32 - bit integer and returns the integer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_var_uint32(self):\n        i = self.read_var_uint64()\n        if i > wire_format.UINT32_MAX:\n            raise errors.DecodeError('Value out of range for uint32: %d' % i)\n        return i", "response": "Reads a varint from the stream interprets this varint\n        as an unsigned 32 - bit integer and returns the integer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_varint64(self):\n        i = self.read_var_uint64()\n        if i > wire_format.INT64_MAX:\n            i -= (1 << 64)\n        return i", "response": "Reads a varint from the stream interprets this varint\n        as a signed 64 - bit integer and returns the integer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_var_uint64(self):\n        i = self._read_varint_helper()\n        if not 0 <= i <= wire_format.UINT64_MAX:\n            raise errors.DecodeError('Value out of range for uint64: %d' % i)\n        return i", "response": "Reads a varint from the stream interprets this varint\n        as an unsigned 64 - bit integer and returns the integer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _read_varint_helper(self):\n        result = 0\n        shift = 0\n        while 1:\n            if shift >= 64:\n                raise errors.DecodeError('Too many bytes when decoding varint.')\n            try:\n                b = ord(self._input.read(1))\n            except IndexError:\n                raise errors.DecodeError('Truncated varint.')\n            self._pos += 1\n            result |= ((b & 0x7f) << shift)\n            shift += 7\n            if not (b & 0x80):\n                return result", "response": "Helper for the varint - reading methods above."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nappending a tag containing field number and wire type information.", "response": "def append_tag(self, field_number, wire_type):\n        \"\"\"Appends a tag containing field number and wire type information.\"\"\"\n        self._stream.append_var_uint32(wire_format.pack_tag(field_number, wire_type))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending a 32 - bit integer to our buffer zigzag - encoded and then varint - encoded.", "response": "def append_sint32(self, value):\n        \"\"\"Appends a 32-bit integer to our buffer, zigzag-encoded and then\n        varint-encoded.\n        \"\"\"\n        zigzag_value = wire_format.zig_zag_encode(value)\n        self._stream.append_var_uint32(zigzag_value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append_sint64(self, value):\n        zigzag_value = wire_format.zig_zag_encode(value)\n        self._stream.append_var_uint64(zigzag_value)", "response": "Appends a 64 - bit integer to our buffer zigzag - encoded and then\n        varint - encoded."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef append_sfixed32(self, value):\n        sign = (value & 0x80000000) and -1 or 0\n        if value >> 32 != sign:\n            raise errors.EncodeError('SFixed32 out of range: %d' % value)\n        self._stream.append_little_endian32(value & 0xffffffff)", "response": "Appends a signed 32 - bit integer to our buffer in little - endian byte - order."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append_sfixed64(self, value):\n        sign = (value & 0x8000000000000000) and -1 or 0\n        if value >> 64 != sign:\n            raise errors.EncodeError('SFixed64 out of range: %d' % value)\n        self._stream.append_little_endian64(value & 0xffffffffffffffff)", "response": "Appends a signed 64 - bit integer to our buffer in little - endian byte - order."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends a length - prefixed string to our buffer with the length varint - encoded.", "response": "def append_string(self, value):\n        \"\"\"Appends a length-prefixed string to our buffer, with the\n        length varint-encoded.\n        \"\"\"\n        self._stream.append_var_uint32(len(value))\n        self._stream.append_raw_bytes(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn SHA1 hash of any string", "response": "def get_SHA1_bin(word):\n    \"\"\"\n    Return SHA1 hash of any string\n\n    :param word:\n    :return:\n    \"\"\"\n    from hashlib import sha1\n    if PY3 and isinstance(word, str):\n        word = word.encode('utf-8')\n\n    hash_s = sha1()\n    hash_s.update(word)\n    return bin(int(hash_s.hexdigest(), 16))[2:].zfill(160)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_index(binstr, end_index=160):\n    res = -1\n    try:\n        res = binstr.index('1') + 1\n    except ValueError:\n        res = end_index\n    return res", "response": "Return the index of the first 1 bit in the word until end_index"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the estimate of the cardinality", "response": "def _estimate(self, buffer):\n        \"\"\"\n        Return the estimate of the cardinality\n\n        :return: esitimate of the cardinality\n        \"\"\"\n        m = self._bucket_number\n        raw_e = self._alpha * pow(m, 2) / sum([pow(2, -x) for x in buffer])\n        if raw_e <= 5 / 2.0 * m:\n            v = buffer.count(0)\n            if v != 0:\n                return m * log(m / float(v), 2)\n            else:\n                return raw_e\n        elif raw_e <= 1 / 30.0 * 2 ** 160:\n            return raw_e\n        else:\n            return -2 ** 160 * log(1 - raw_e / 2.0 ** 160, 2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge(self, buffer, other_hyper_log_log):\n\n        for i in range(len(buffer)):\n            buffer[i] = max(buffer[i], other_hyper_log_log[i])", "response": "Merge the HyperLogLog with the HyperLogLog other_hyper_log."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_string(self):\n        length = self._stream.read_var_uint32()\n        return self._stream.read_string(length)", "response": "Reads and returns a length - delimited string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _justify(texts, max_len, mode='right'):\n    if mode == 'left':\n        return [x.ljust(max_len) for x in texts]\n    elif mode == 'center':\n        return [x.center(max_len) for x in texts]\n    else:\n        return [x.rjust(max_len) for x in texts]", "response": "Perform ljust center rjust against string or list - like\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntrim zeros and decimal points.", "response": "def _trim_zeros(str_floats, na_rep='NaN'):\n    \"\"\"\n    Trims zeros and decimal points.\n    \"\"\"\n    trimmed = str_floats\n\n    def _cond(values):\n        non_na = [x for x in values if x != na_rep]\n        return (len(non_na) > 0 and all([x.endswith('0') for x in non_na]) and\n                not(any([('e' in x) or ('E' in x) for x in non_na])))\n\n    while _cond(trimmed):\n        trimmed = [x[:-1] if x != na_rep else x for x in trimmed]\n\n    # trim decimal points\n    return [x[:-1] if x.endswith('.') and x != na_rep else x for x in trimmed]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _chk_truncate(self):\n        '''\n        Checks whether the frame should be truncated. If so, slices\n        the frame up.\n        '''\n\n        # Column of which first element is used to determine width of a dot col\n        self.tr_size_col = -1\n\n        # Cut the data to the information actually printed\n        max_cols = self.max_cols\n        max_rows = self.max_rows\n\n        if max_cols == 0 or max_rows == 0:  # assume we are in the terminal (why else = 0)\n            (w, h) = get_terminal_size()\n            self.w = w\n            self.h = h\n            if self.max_rows == 0:\n                dot_row = 1\n                prompt_row = 1\n                if self.show_dimensions:\n                    show_dimension_rows = 3\n                n_add_rows = self.header + dot_row + show_dimension_rows + prompt_row\n                max_rows_adj = self.h - n_add_rows  # rows available to fill with actual data\n                self.max_rows_adj = max_rows_adj\n\n            # Format only rows and columns that could potentially fit the screen\n            if max_cols == 0 and len(self.frame.columns) > w:\n                max_cols = w\n            if max_rows == 0 and len(self.frame) > h:\n                max_rows = h\n\n        if not hasattr(self, 'max_rows_adj'):\n            self.max_rows_adj = max_rows\n        if not hasattr(self, 'max_cols_adj'):\n            self.max_cols_adj = max_cols\n\n        max_cols_adj = self.max_cols_adj\n        max_rows_adj = self.max_rows_adj\n\n        truncate_h = max_cols_adj and (len(self.columns) > max_cols_adj)\n        truncate_v = max_rows_adj and (len(self.frame) > max_rows_adj)\n\n        frame = self.frame\n        if truncate_h:\n            if max_cols_adj == 0:\n                col_num = len(frame.columns)\n            elif max_cols_adj == 1:\n                frame = frame[:, :max_cols]\n                col_num = max_cols\n            else:\n                col_num = (max_cols_adj // 2)\n                frame = frame[:, :col_num].concat(frame[:, -col_num:], axis=1)\n            self.tr_col_num = col_num\n        if truncate_v:\n            if max_rows_adj == 0:\n                row_num = len(frame)\n            if max_rows_adj == 1:\n                row_num = max_rows\n                frame = frame[:max_rows, :]\n            else:\n                row_num = max_rows_adj // 2\n                frame = frame[:row_num, :].concat(frame[-row_num:, :])\n            self.tr_row_num = row_num\n\n        self.tr_frame = frame\n        self.truncate_h = truncate_h\n        self.truncate_v = truncate_v\n        self.is_truncated = self.truncate_h or self.truncate_v", "response": "Checks whether the frame should be truncated. If so slices the frame up."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering a DataFrame to a list of columns as strings.", "response": "def _to_str_columns(self):\n        \"\"\"\n        Render a DataFrame to a list of columns (as lists of strings).\n        \"\"\"\n        frame = self.tr_frame\n\n        # may include levels names also\n\n        str_index = self._get_formatted_index(frame)\n        str_columns = self._get_formatted_column_labels(frame)\n\n        if self.header:\n            stringified = []\n            for i, c in enumerate(frame.columns):\n                cheader = str_columns[i]\n                max_colwidth = max(self.col_space or 0,\n                                   *(self.adj.len(x) for x in cheader))\n                fmt_values = self._format_col(i)\n                fmt_values = _make_fixed_width(fmt_values, self.justify,\n                                               minimum=max_colwidth,\n                                               adj=self.adj)\n\n                max_len = max(max([self.adj.len(x) for x in fmt_values]),\n                              max_colwidth)\n                cheader = self.adj.justify(cheader, max_len, mode=self.justify)\n                stringified.append(cheader + fmt_values)\n        else:\n            stringified = []\n            for i, c in enumerate(frame):\n                fmt_values = self._format_col(i)\n                fmt_values = _make_fixed_width(fmt_values, self.justify,\n                                               minimum=(self.col_space or 0),\n                                               adj=self.adj)\n\n                stringified.append(fmt_values)\n\n        strcols = stringified\n        if self.index:\n            strcols.insert(0, str_index)\n\n        # Add ... to signal truncated\n        truncate_h = self.truncate_h\n        truncate_v = self.truncate_v\n\n        if truncate_h:\n            col_num = self.tr_col_num\n            col_width = self.adj.len(strcols[self.tr_size_col][0])  # infer from column header\n            strcols.insert(self.tr_col_num + 1, ['...'.center(col_width)] * (len(str_index)))\n        if truncate_v:\n            n_header_rows = len(str_index) - len(frame)\n            row_num = self.tr_row_num\n            for ix, col in enumerate(strcols):\n                cwidth = self.adj.len(strcols[ix][row_num])  # infer from above row\n                is_dot_col = False\n                if truncate_h:\n                    is_dot_col = ix == col_num + 1\n                if cwidth > 3 or is_dot_col:\n                    my_str = '...'\n                else:\n                    my_str = '..'\n\n                if ix == 0:\n                    dot_mode = 'left'\n                elif is_dot_col:\n                    cwidth = self.adj.len(strcols[self.tr_size_col][0])\n                    dot_mode = 'center'\n                else:\n                    dot_mode = 'right'\n                dot_str = self.adj.justify([my_str], cwidth, mode=dot_mode)[0]\n                strcols[ix].insert(row_num + n_header_rows, dot_str)\n        return strcols"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_string(self):\n        frame = self.frame\n\n        if len(frame.columns) == 0 or len(frame.index) == 0:\n            info_line = (u('Empty %s\\nColumns: %s\\nIndex: %s')\n                         % (type(self.frame).__name__,\n                            pprint_thing(frame.columns),\n                            pprint_thing(frame.index)))\n            text = info_line\n        else:\n            strcols = self._to_str_columns()\n            if self.line_width is None:  # no need to wrap around just print the whole frame\n                text = self.adj.adjoin(1, *strcols)\n            elif not isinstance(self.max_cols, int) or self.max_cols > 0:  # need to wrap around\n                text = self._join_multiline(*strcols)\n            else:  # max_cols == 0. Try to fit frame to terminal\n                text = self.adj.adjoin(1, *strcols).split('\\n')\n                row_lens = [len(it) for it in text]\n                max_len_col_ix = row_lens.index(max(row_lens))\n                max_len = row_lens[max_len_col_ix]\n                headers = [ele[0] for ele in strcols]\n                # Size of last col determines dot col size. See `self._to_str_columns\n                size_tr_col = len(headers[self.tr_size_col])\n                max_len += size_tr_col  # Need to make space for largest row plus truncate dot col\n                dif = max_len - self.w\n                adj_dif = dif\n                col_lens = [max(len(it) for it in ele) for ele in strcols]\n                n_cols = len(col_lens)\n                counter = 0\n                while adj_dif > 0 and n_cols > 1:\n                    counter += 1\n                    mid = int(round(n_cols / 2.))\n                    # mid_ix = col_lens.index[mid]\n                    col_len = col_lens[mid]\n                    adj_dif -= (col_len + 1)  # adjoin adds one\n                    col_lens = col_lens[:mid] + col_len[mid+1: ]\n                    n_cols = len(col_lens)\n                max_cols_adj = n_cols - self.index  # subtract index column\n                self.max_cols_adj = max_cols_adj\n\n                # Call again _chk_truncate to cut frame appropriately\n                # and then generate string representation\n                self._chk_truncate()\n                strcols = self._to_str_columns()\n                text = self.adj.adjoin(1, *strcols)\n\n        self.buf.writelines(text)\n\n        if self.should_show_dimensions:\n            self.buf.write(\"\\n\\n[%d rows x %d columns]\"\n                           % (len(frame), len(frame.columns)))", "response": "Render a DataFrame to a console - friendly tabular output."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_html(self, classes=None, notebook=False):\n        html_renderer = HTMLFormatter(self, classes=classes,\n                                      max_rows=self.max_rows,\n                                      max_cols=self.max_cols,\n                                      notebook=notebook)\n        if hasattr(self.buf, 'write'):\n            html_renderer.write_result(self.buf)\n        elif isinstance(self.buf, six.string_types):\n            with open(self.buf, 'w') as f:\n                html_renderer.write_result(f)\n        else:\n            raise TypeError('buf is not a file name and it has no write '\n                            ' method')", "response": "Render a DataFrame to a html table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _format_strings(self):\n\n        values = self.values\n        return [val.strftime('%Y-%m-%d %H:%M:%S') if val is not None else self.nat_rep for val in values]", "response": "Return a list of strings that can be used to format the TZ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_input_table(cls, name='inputTableName', input_name='input'):\n        obj = cls(name)\n        obj.exporter = 'get_input_table_name'\n        obj.input_name = input_name\n        return obj", "response": "Build an input table parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds an input table partition parameter", "response": "def build_input_partitions(cls, name='inputTablePartitions', input_name='input'):\n        \"\"\"\n        Build an input table partition parameter\n\n        :param name: parameter name\n        :type name: str\n        :param input_name: bind input port name\n        :param input_name: str\n        :return: input description\n        :rtype: ParamDef\n        \"\"\"\n        obj = cls(name)\n        obj.exporter = 'get_input_partitions'\n        obj.input_name = input_name\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an output table parameter", "response": "def build_output_table(cls, name='inputTableName', output_name='output'):\n        \"\"\"\n        Build an output table parameter\n\n        :param name: parameter name\n        :type name: str\n        :param output_name: bind input port name\n        :type output_name: str\n        :return: output description\n        :rtype: ParamDef\n        \"\"\"\n        obj = cls(name)\n        obj.exporter = 'get_output_table_name'\n        obj.output_name = output_name\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_output_partitions(cls, name='inputTablePartitions', output_name='output'):\n        obj = cls(name)\n        obj.exporter = 'get_output_table_partition'\n        obj.output_name = output_name\n        return obj", "response": "Build an output table partition parameter"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_model_name(cls, name='modelName', output_name='output'):\n        obj = cls(name)\n        obj.exporter = 'generate_model_name'\n        obj.output_name = output_name\n        return obj", "response": "Build an output model name parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a data input port.", "response": "def build_data_input(cls, name='input'):\n        \"\"\"\n        Build a data input port.\n\n        :param name: port name\n        :type name: str\n        :return: port object\n        :rtype: PortDef\n        \"\"\"\n        return cls(name, PortDirection.INPUT, type=PortType.DATA)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_data_output(cls, name='output', copy_input=None, schema=None):\n        return cls(name, PortDirection.OUTPUT, type=PortType.DATA, copy_input=copy_input, schema=schema)", "response": "Build a data output port."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding a model input port.", "response": "def build_model_input(cls, name='input'):\n        \"\"\"\n        Build a model input port.\n\n        :param name: port name\n        :type name: str\n        :return: port object\n        :rtype: PortDef\n        \"\"\"\n        return cls(name, PortDirection.INPUT, type=PortType.MODEL)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a model output port.", "response": "def build_model_output(cls, name='output'):\n        \"\"\"\n        Build a model output port.\n\n        :param name: port name\n        :type name: str\n        :return: port object\n        :rtype: PortDef\n        \"\"\"\n        return cls(name, PortDirection.OUTPUT, type=PortType.MODEL)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_port(self, port):\n        self.ports.append(port)\n        if port.io_type not in self.port_seqs:\n            self.port_seqs[port.io_type] = 0\n        self.port_seqs[port.io_type] += 1\n        port.sequence = self.port_seqs[port.io_type]\n        return self", "response": "Adds a port object to the definition\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_meta(self, name, value):\n        for mt in self.metas:\n            if mt.name == name:\n                mt.value = value\n                return self\n        self.metas.append(MetaDef(name, value))\n        return self", "response": "Add a pair of meta data to the definition\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialize(self):\n        # fill sequences\n        for keys, groups in groupby(self.ports, lambda x: x.io_type):\n            for seq, port in enumerate(groups):\n                port.sequence = seq\n        return super(AlgorithmDef, self).serialize()", "response": "Serialize the algorithm definition\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _contains(expr, pat, case=True, flags=0, regex=True):\n\n    if regex and isinstance(pat, six.string_types):\n        import re\n        try:\n            re.compile(pat, flags=flags)\n        except:\n            raise ValueError('Failed to compile regular expression, '\n                             'please check re.compile(\"{0}\")'.format(pat))\n\n    return _string_op(expr, Contains, output_type=types.boolean,\n                      _pat=pat, _case=case, _flags=flags, _regex=regex)", "response": "Returns boolean sequence whether given pattern or regex is contained in each string in the sequence or scalar sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncounting occurrences of pattern in each string of the sequence or scalar .", "response": "def _count(expr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the sequence or scalar\n\n    :param expr: sequence or scalar\n    :param pat: valid regular expression\n    :param flags: re module flags, e.g. re.IGNORECASE\n    :return:\n    \"\"\"\n    return _string_op(expr, Count, output_type=types.int64,\n                      _pat=pat, _flags=flags)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a boolean sequence or scalar indicating whether each string in the sequence or scalar ends with the passed pattern.", "response": "def _endswith(expr, pat):\n    \"\"\"\n    Return boolean sequence or scalar indicating whether each string in the sequence or scalar\n    ends with passed pattern. Equivalent to str.endswith().\n\n    :param expr:\n    :param pat: Character sequence\n    :return: sequence or scalar\n    \"\"\"\n\n    return _string_op(expr, Endswith, output_type=types.boolean, _pat=pat)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _startswith(expr, pat):\n\n    return _string_op(expr, Startswith, output_type=types.boolean, _pat=pat)", "response": "Returns a sequence or scalar indicating whether each string in the sequence or scalar starts with pattern."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _extract(expr, pat, flags=0, group=0):\n\n    return _string_op(expr, Extract, _pat=pat, _flags=flags, _group=group)", "response": "Extract group in each string in the Series using passed regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _find(expr, sub, start=0, end=None):\n\n    return _string_op(expr, Find, output_type=types.int64,\n                      _sub=sub, _start=start, _end=end)", "response": "Find the lowest indexes in each string in the sequence or scalar\n    where the substring is fully contained between [ start end )."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _rfind(expr, sub, start=0, end=None):\n\n    return _string_op(expr, RFind, output_type=types.int64,\n                      _sub=sub, _start=start, _end=end)", "response": "Return the highest indexes in each string in the sequence or scalar\n    where the substring is fully contained between [ start end )."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreplacing occurrence of pattern or regex in sequence or scalar with some other string.", "response": "def _replace(expr, pat, repl, n=-1, case=True, flags=0, regex=True):\n    \"\"\"\n    Replace occurrence of pattern/regex in the sequence or scalar with some other string.\n    Equivalent to str.replace()\n\n    :param expr:\n    :param pat: Character sequence or regular expression\n    :param repl: Replacement\n    :param n: Number of replacements to make from start\n    :param case: if True, case sensitive\n    :param flags: re module flag, e.g. re.IGNORECASE\n    :return: sequence or scalar\n    \"\"\"\n\n    return _string_op(expr, Replace, _pat=pat, _repl=repl,\n                      _n=n, _case=case, _flags=flags, _regex=regex)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a sequence or scalar with a left - side of the string.", "response": "def _ljust(expr, width, fillchar=' '):\n    \"\"\"\n    Filling right side of strings in the sequence or scalar with an additional character.\n    Equivalent to str.ljust().\n\n    :param expr:\n    :param width: Minimum width of resulting string; additional characters will be filled with `fillchar`\n    :param fillchar: Additional character for filling, default is whitespace.\n    :return: sequence or scalar\n    \"\"\"\n    return _string_op(expr, Ljust, _width=width, _fillchar=fillchar)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a sequence or scalar with a minimum width filled with fillchar.", "response": "def _rjust(expr, width, fillchar=' '):\n    \"\"\"\n    Filling left side of strings in the sequence or scalar with an additional character.\n    Equivalent to str.rjust().\n\n    :param expr:\n    :param width: Minimum width of resulting string; additional characters will be filled with `fillchar`\n    :param fillchar: Additional character for filling, default is whitespace.\n    :return: sequence or scalar\n    \"\"\"\n\n    return _string_op(expr, Rjust, _width=width, _fillchar=fillchar)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit each string in the Series or Index by given pattern.", "response": "def _split(expr, pat=None, n=-1):\n    \"\"\"\n    Split each string (a la re.split) in the Series/Index by given pattern, propagating NA values.\n    Equivalent to str.split().\n\n    :param expr:\n    :param pat: Separator to split on. If None, splits on whitespace\n    :param n: not supported right now\n    :return: list sequence or scalar\n    \"\"\"\n\n    return _string_op(expr, Split, output_type=types.List(types.string),\n                      _pat=pat, _n=n)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _rsplit(expr, pat=None, n=-1):\n\n    return _string_op(expr, RSplit, output_type=types.List(types.string),\n                      _pat=pat, _n=n)", "response": "Splits each string in the Series or Index by the given delimiter string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npads a sequence or scalar with an additional character to specified side.", "response": "def _pad(expr, width, side='left', fillchar=' '):\n    \"\"\"\n    Pad strings in the sequence or scalar with an additional character to specified side.\n\n    :param expr:\n    :param width: Minimum width of resulting string; additional characters will be filled with spaces\n    :param side: {\u2018left\u2019, \u2018right\u2019, \u2018both\u2019}, default \u2018left\u2019\n    :param fillchar: Additional character for filling, default is whitespace\n    :return: sequence or scalar\n    \"\"\"\n\n    if not isinstance(fillchar, six.string_types):\n        msg = 'fillchar must be a character, not {0}'\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError('fillchar must be a character, not str')\n\n    if side not in ('left', 'right', 'both'):\n        raise ValueError('Invalid side')\n\n    return _string_op(expr, Pad, _width=width, _side=side, _fillchar=fillchar)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _slice(expr, start=None, stop=None, step=None):\n\n    return _string_op(expr, Slice, _start=start, _end=stop, _step=step)", "response": "Slice substrings from each element in the sequence or scalar\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn datetimes specified by date_format.", "response": "def _strptime(expr, date_format):\n    \"\"\"\n    Return datetimes specified by date_format,\n    which supports the same string format as the python standard library.\n    Details of the string format can be found in python string format doc\n\n    :param expr:\n    :param date_format: date format string (e.g. \u201c%Y-%m-%d\u201d)\n    :type date_format: str\n    :return:\n    \"\"\"\n\n    return _string_op(expr, Strptime, _date_format=date_format,\n                      output_type=types.datetime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting the string sequence or scalar expr into a string dict given item and key - value delimiters.", "response": "def _todict(expr, item_delim=',', kv_delim='='):\n    \"\"\"\n    Convert the string sequence / expr into a string dict given item and key-value delimiters.\n\n    :param expr:\n    :param item_delim: delimiter between data items\n    :param kv_delim: delimiter between keys and values\n    :return: dict sequence or scalar\n    \"\"\"\n    return _string_op(expr, StringToDict, _item_delim=item_delim, _kv_delim=kv_delim,\n                      output_type=types.Dict(types.string, types.string))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlists all tables in a given project.", "response": "def _list_tables_model(self, prefix='', project=None):\n    \"\"\"\n    List all TablesModel in the given project.\n\n    :param prefix: model prefix\n    :param str project: project name, if you want to look up in another project\n    :rtype: list[str]\n    \"\"\"\n    tset = set()\n\n    if prefix.startswith(TEMP_TABLE_PREFIX):\n        prefix = TEMP_TABLE_MODEL_PREFIX + prefix[len(TEMP_TABLE_PREFIX):]\n        it = self.list_tables(project=project, prefix=prefix)\n    else:\n        it = self.list_tables(project=project, prefix=TABLE_MODEL_PREFIX + prefix)\n        if TEMP_TABLE_PREFIX.startswith(prefix):\n            new_iter = self.list_tables(project=project, prefix=TEMP_TABLE_MODEL_PREFIX)\n            it = itertools.chain(it, new_iter)\n\n    for table in it:\n        if TABLE_MODEL_SEPARATOR not in table.name:\n            continue\n        if not table.name.startswith(TEMP_TABLE_MODEL_PREFIX) and not table.name.startswith(TABLE_MODEL_PREFIX):\n            continue\n        model_name, _ = table.name.rsplit(TABLE_MODEL_SEPARATOR, 1)\n        if model_name.startswith(TEMP_TABLE_MODEL_PREFIX):\n            model_name = TEMP_TABLE_PREFIX + model_name[len(TEMP_TABLE_MODEL_PREFIX):]\n        else:\n            model_name = model_name[len(TABLE_MODEL_PREFIX):]\n        if model_name not in tset:\n            tset.add(model_name)\n            yield TablesModelObject(_odps=self, name=model_name, project=project)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens a file for read.", "response": "def open_reader(self, file_name, reopen=False, endpoint=None, start=None, length=None, **kwargs):\n        \"\"\"\n        Open a volume file for read. A file-like object will be returned which can be used to read contents from\n        volume files.\n\n        :param str file_name: name of the file\n        :param bool reopen: whether we need to open an existing read session\n        :param str endpoint: tunnel service URL\n        :param start: start position\n        :param length: length limit\n        :param compress_option: the compression algorithm, level and strategy\n        :type compress_option: :class:`odps.tunnel.CompressOption`\n\n        :Example:\n        >>> with partition.open_reader('file') as reader:\n        >>>     [print(line) for line in reader]\n        \"\"\"\n        tunnel = self._create_volume_tunnel(endpoint=endpoint)\n        download_id = self._download_id if not reopen else None\n        download_session = tunnel.create_download_session(volume=self.volume.name, partition_spec=self.name,\n                                                          file_name=file_name, download_id=download_id, **kwargs)\n        self._download_id = download_session.id\n\n        open_args = {}\n        if start is not None:\n            open_args['start'] = start\n        if length is not None:\n            open_args['length'] = length\n        return download_session.open(**open_args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening a new volume partition to write to.", "response": "def open_writer(self, reopen=False, endpoint=None, **kwargs):\n        \"\"\"\n        Open a volume partition to write to. You can use `open` method to open a file inside the volume and write to it,\n        or use `write` method to write to specific files.\n\n        :param bool reopen: whether we need to open an existing write session\n        :param str endpoint: tunnel service URL\n        :param compress_option: the compression algorithm, level and strategy\n        :type compress_option: :class:`odps.tunnel.CompressOption`\n        :Example:\n        >>> with partition.open_writer() as writer:\n        >>>     writer.open('file1').write('some content')\n        >>>     writer.write('file2', 'some content')\n        \"\"\"\n        tunnel = self._create_volume_tunnel(endpoint=endpoint)\n        upload_id = self._upload_id if not reopen else None\n        upload_session = tunnel.create_upload_session(volume=self.volume.name, partition_spec=self.name,\n                                                      upload_id=upload_id, **kwargs)\n        file_dict = dict()\n\n        class FilesWriter(object):\n            @property\n            def status(self):\n                return upload_session.status\n\n            @staticmethod\n            def open(file_name, **kwargs):\n                if file_name in file_dict:\n                    return file_dict[file_name]\n                writer = upload_session.open(file_name, **kwargs)\n                file_dict[file_name] = writer\n                return writer\n\n            @staticmethod\n            def write(file_name, buf, **kwargs):\n                writer = FilesWriter.open(file_name, **kwargs)\n                writer.write(buf)\n\n            @staticmethod\n            def close():\n                for w in six.itervalues(file_dict):\n                    w.close()\n\n                upload_session.commit(list(six.iterkeys(file_dict)))\n\n            def __enter__(self):\n                return self\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                self.close()\n\n        return FilesWriter()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbatch persist multiple DataFrames into ODPS.", "response": "def batch_persist(dfs, tables, *args, **kwargs):\n        \"\"\"\n        Persist multiple DataFrames into ODPS.\n\n        :param dfs: DataFrames to persist.\n        :param tables: Table names to persist to. Use (table, partition) tuple to store to a table partition.\n        :param args: args for Expr.persist\n        :param kwargs: kwargs for Expr.persist\n\n        :Examples:\n        >>> DataFrame.batch_persist([df1, df2], ['table_name1', ('table_name2', 'partition_name2')], lifecycle=1)\n        \"\"\"\n        from .delay import Delay\n\n        if 'async' in kwargs:\n            kwargs['async_'] = kwargs['async']\n        execute_keys = ('ui', 'async_', 'n_parallel', 'timeout', 'close_and_notify')\n        execute_kw = dict((k, v) for k, v in six.iteritems(kwargs) if k in execute_keys)\n        persist_kw = dict((k, v) for k, v in six.iteritems(kwargs) if k not in execute_keys)\n\n        delay = Delay()\n        persist_kw['delay'] = delay\n\n        for df, table in izip(dfs, tables):\n            if isinstance(table, tuple):\n                table, partition = table\n            else:\n                partition = None\n            df.persist(table, partition=partition, *args, **persist_kw)\n\n        return delay.execute(**execute_kw)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over the user s roles.", "response": "def iterate(self, name=None):\n        \"\"\"\n        :return:\n        \"\"\"\n        if not self._iter_local:\n            params = dict()\n            if name is not None:\n                params['name'] = name\n\n            url = self.resource()\n            resp = self._client.get(url, params=params)\n\n            Roles.parse(self._client, resp, obj=self)\n\n        for role in self.roles:\n            yield role"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _repr_fits_horizontal_(self, ignore_width=False):\n\n        width, height = get_console_size()\n        max_columns = options.display.max_columns\n        nb_columns = len(self.columns)\n\n        # exceed max columns\n        if ((max_columns and nb_columns > max_columns) or\n                ((not ignore_width) and width and nb_columns > (width // 2))):\n            return False\n\n        if (ignore_width  # used by repr_html under IPython notebook\n                # scripts ignore terminal dims\n                or not in_interactive_session()):\n            return True\n\n        if (options.display.width is not None or\n                in_ipython_frontend()):\n            # check at least the column row for excessive width\n            max_rows = 1\n        else:\n            max_rows = options.display.max_rows\n\n        # when auto-detecting, so width=None and not in ipython front end\n        # check whether repr fits horizontal by actualy checking\n        # the width of the rendered repr\n        buf = six.StringIO()\n\n        # only care about the stuff we'll actually print out\n        # and to_string on entire frame may be expensive\n        d = self\n\n        if not (max_rows is None):  # unlimited rows\n            # min of two, where one may be None\n            d = d[:min(max_rows, len(d))]\n        else:\n            return True\n\n        d.to_string(buf=buf)\n        value = buf.getvalue()\n        repr_width = max([len(l) for l in value.split('\\n')])\n\n        return repr_width < width", "response": "Check if full repr fits in horizontal boundaries imposed by the display. width and max_columns options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _repr_html_(self):\n        # qtconsole doesn't report its line width, and also\n        # behaves badly when outputting an HTML table\n        # that doesn't fit the window, so disable it.\n        # XXX: In IPython 3.x and above, the Qt console will not attempt to\n        # display HTML, so this check can be removed when support for IPython 2.x\n        # is no longer needed.\n\n        if self._pandas and options.display.notebook_repr_widget:\n            from .. import DataFrame\n            from ..ui import show_df_widget\n            show_df_widget(DataFrame(self._values, schema=self.schema))\n\n        if self._pandas:\n            return self._values._repr_html_()\n\n        if in_qtconsole():\n            # 'HTML output is disabled in QtConsole'\n            return None\n\n        if options.display.notebook_repr_html:\n            max_rows = options.display.max_rows\n            max_cols = options.display.max_columns\n            show_dimensions = options.display.show_dimensions\n\n            return self.to_html(max_rows=max_rows, max_cols=max_cols,\n                                show_dimensions=show_dimensions,\n                                notebook=True)\n        else:\n            return None", "response": "Return a html representation for a particular DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender a DataFrame as an HTML table.", "response": "def to_html(self, buf=None, columns=None, col_space=None,\n                header=True, index=True, na_rep='NaN', formatters=None,\n                float_format=None, sparsify=None, index_names=True,\n                justify=None, bold_rows=True, classes=None, escape=True,\n                max_rows=None, max_cols=None, show_dimensions=False,\n                notebook=False):\n        \"\"\"\n        Render a DataFrame as an HTML table.\n\n        `to_html`-specific options:\n\n        bold_rows : boolean, default True\n            Make the row labels bold in the output\n        classes : str or list or tuple, default None\n            CSS class(es) to apply to the resulting html table\n        escape : boolean, default True\n            Convert the characters <, >, and & to HTML-safe sequences.=\n        max_rows : int, optional\n            Maximum number of rows to show before truncating. If None, show\n            all.\n        max_cols : int, optional\n            Maximum number of columns to show before truncating. If None, show\n            all.\n\n        \"\"\"\n\n        formatter = fmt.ResultFrameFormatter(self, buf=buf, columns=columns,\n                                             col_space=col_space, na_rep=na_rep,\n                                             formatters=formatters,\n                                             float_format=float_format,\n                                             sparsify=sparsify,\n                                             justify=justify,\n                                             index_names=index_names,\n                                             header=header, index=index,\n                                             bold_rows=bold_rows,\n                                             escape=escape,\n                                             max_rows=max_rows,\n                                             max_cols=max_cols,\n                                             show_dimensions=show_dimensions)\n        formatter.to_html(classes=classes, notebook=notebook)\n\n        if buf is None:\n            return formatter.buf.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a registry key s values to a dictionary.", "response": "def valuestodict(key):\n    \"\"\"Convert a registry key's values to a dictionary.\"\"\"\n    dict = {}\n    size = winreg.QueryInfoKey(key)[1]\n    for i in range(size):\n        data = winreg.EnumValue(key, i)\n        dict[data[0]] = data[1]\n    return dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the zoneinfo - based tzinfo object that matches the Windows - configured timezone.", "response": "def get_localzone():\n    \"\"\"Returns the zoneinfo-based tzinfo object that matches the Windows-configured timezone.\"\"\"\n    global _cache_tz\n    if _cache_tz is None:\n        _cache_tz = pytz.timezone(get_localzone_name())\n\n    utils.assert_tz_offset(_cache_tz)\n    return _cache_tz"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reload_localzone():\n    global _cache_tz\n    _cache_tz = pytz.timezone(get_localzone_name())\n    utils.assert_tz_offset(_cache_tz)\n    return _cache_tz", "response": "Reload the cached localzone."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, async_=False, **kw):\n        async_ = kw.get('async', async_)\n        headers = {'Content-Type': 'application/xml'}\n\n        new_kw = dict()\n        if self.offline_model_name:\n            upload_keys = ('_parent', 'name', 'offline_model_name', 'offline_model_project', 'qos', 'instance_num')\n        else:\n            upload_keys = ('_parent', 'name', 'qos', '_model_resource', 'instance_num', 'predictor', 'runtime')\n\n        for k in upload_keys:\n            new_kw[k] = getattr(self, k)\n        new_kw.update(kw)\n\n        obj = type(self)(version='0', **new_kw)\n\n        data = obj.serialize()\n        self._client.put(self.resource(), data, headers=headers)\n        self.reload()\n\n        if not async_:\n            self.wait_for_service()", "response": "Update online model parameters to server."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwaits for the online model to be ready for service.", "response": "def wait_for_service(self, interval=1):\n        \"\"\"\n        Wait for the online model to be ready for service.\n\n        :param interval: check interval\n        \"\"\"\n        while self.status in (OnlineModel.Status.DEPLOYING, OnlineModel.Status.UPDATING):\n            time.sleep(interval)\n        if self.status == OnlineModel.Status.DEPLOY_FAILED:\n            raise OnlineModelError(self.last_fail_msg, self)\n        elif self.status != OnlineModel.Status.SERVING:\n            raise OnlineModelError('Unexpected status occurs: %s' % self.status.value, self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwait for the online model to be deleted.", "response": "def wait_for_deletion(self, interval=1):\n        \"\"\"\n        Wait for the online model to be deleted.\n\n        :param interval: check interval\n        \"\"\"\n        deleted = False\n        while True:\n            try:\n                if self.status != OnlineModel.Status.DELETING:\n                    break\n            except errors.NoSuchObject:\n                deleted = True\n                break\n            time.sleep(interval)\n\n        if not deleted:\n            if self.status == OnlineModel.Status.DELETE_FAILED:\n                raise OnlineModelError(self.last_fail_msg, self)\n            else:\n                raise OnlineModelError('Unexpected status occurs: %s' % self.status.value, self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npredicts data labels with current online model.", "response": "def predict(self, data, schema=None, endpoint=None):\n        \"\"\"\n        Predict data labels with current online model.\n\n        :param data: data to be predicted\n        :param schema: schema of input data\n        :param endpoint: endpoint of predict service\n        :return: prediction result\n        \"\"\"\n        from .. import Projects\n\n        if endpoint is not None:\n            self._endpoint = endpoint\n        if self._predict_rest is None:\n            # do not add project option\n            self._predict_rest = RestClient(self._client.account, self._endpoint, proxy=options.data_proxy)\n\n        json_data = json.dumps(self._build_predict_request(data, schema))\n        headers = {'Content-Type': 'application/json'}\n\n        predict_model = Projects(client=self._predict_rest)[self.project.name].online_models[self.name]\n        resp = self._predict_rest.post(predict_model.resource(), json_data, headers=headers)\n\n        if not self._client.is_ok(resp):\n            e = errors.ODPSError.parse(resp)\n            raise e\n        return ModelPredictResults.parse(resp).outputs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef move(self, new_path, replication=None):\n        if not new_path.startswith('/'):\n            new_path = self._normpath(self.dirname + '/' + new_path)\n        else:\n            new_path = self._normpath(new_path)\n        if new_path == self.path:\n            raise ValueError('New path should be different from the original one.')\n        update_def = self.UpdateRequestXML(path=new_path)\n        if replication:\n            update_def.replication = replication\n        headers = {\n            'Content-Type': 'application/xml',\n            'x-odps-volume-fs-path': self.path,\n        }\n        self._client.put(self.parent.resource(), params={'meta': ''}, headers=headers, data=update_def.serialize())\n        self._del_cache(self.path)\n        self.path = new_path\n        self.reload()", "response": "Move the current path to a new location."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_localzone(_root='/'):\n\n    tzenv = _try_tz_from_env()\n    if tzenv:\n        return tzenv\n\n    # Now look for distribution specific configuration files\n    # that contain the timezone name.\n    for configfile in ('etc/timezone', 'var/db/zoneinfo'):\n        tzpath = os.path.join(_root, configfile)\n        try:\n            with open(tzpath, 'rb') as tzfile:\n                data = tzfile.read()\n\n                # Issue #3 was that /etc/timezone was a zoneinfo file.\n                # That's a misconfiguration, but we need to handle it gracefully:\n                if data[:5] == b'TZif2':\n                    continue\n\n                etctz = data.strip().decode()\n                if not etctz:\n                    # Empty file, skip\n                    continue\n                for etctz in data.decode().splitlines():\n                    # Get rid of host definitions and comments:\n                    if ' ' in etctz:\n                        etctz, dummy = etctz.split(' ', 1)\n                    if '#' in etctz:\n                        etctz, dummy = etctz.split('#', 1)\n                    if not etctz:\n                        continue\n                    return pytz.timezone(etctz.replace(' ', '_'))\n        except IOError:\n            # File doesn't exist or is a directory\n            continue\n\n    # CentOS has a ZONE setting in /etc/sysconfig/clock,\n    # OpenSUSE has a TIMEZONE setting in /etc/sysconfig/clock and\n    # Gentoo has a TIMEZONE setting in /etc/conf.d/clock\n    # We look through these files for a timezone:\n\n    zone_re = re.compile(r'\\s*ZONE\\s*=\\s*\\\"')\n    timezone_re = re.compile(r'\\s*TIMEZONE\\s*=\\s*\\\"')\n    end_re = re.compile('\\\"')\n\n    for filename in ('etc/sysconfig/clock', 'etc/conf.d/clock'):\n        tzpath = os.path.join(_root, filename)\n        try:\n            with open(tzpath, 'rt') as tzfile:\n                data = tzfile.readlines()\n\n            for line in data:\n                # Look for the ZONE= setting.\n                match = zone_re.match(line)\n                if match is None:\n                    # No ZONE= setting. Look for the TIMEZONE= setting.\n                    match = timezone_re.match(line)\n                if match is not None:\n                    # Some setting existed\n                    line = line[match.end():]\n                    etctz = line[:end_re.search(line).start()]\n\n                    # We found a timezone\n                    return pytz.timezone(etctz.replace(' ', '_'))\n        except IOError:\n            # File doesn't exist or is a directory\n            continue\n\n    # systemd distributions use symlinks that include the zone name,\n    # see manpage of localtime(5) and timedatectl(1)\n    tzpath = os.path.join(_root, 'etc/localtime')\n    if os.path.exists(tzpath) and os.path.islink(tzpath):\n        tzpath = os.path.realpath(tzpath)\n        start = tzpath.find(\"/\")+1\n        while start is not 0:\n            tzpath = tzpath[start:]\n            try:\n                return pytz.timezone(tzpath)\n            except pytz.UnknownTimeZoneError:\n                pass\n            start = tzpath.find(\"/\")+1\n\n    # Are we under Termux on Android? It's not officially supported, because\n    # there is no reasonable way to run tests for this, but let's make an effort.\n    if os.path.exists('/system/bin/getprop'):\n        import subprocess\n        androidtz = subprocess.check_output(['getprop', 'persist.sys.timezone'])\n        return pytz.timezone(androidtz.strip().decode())\n\n    # No explicit setting existed. Use localtime\n    for filename in ('etc/localtime', 'usr/local/etc/localtime'):\n        tzpath = os.path.join(_root, filename)\n\n        if not os.path.exists(tzpath):\n            continue\n        with open(tzpath, 'rb') as tzfile:\n            return pytz.tzfile.build_tzinfo('local', tzfile)\n\n    raise pytz.UnknownTimeZoneError('Can not find any timezone configuration')", "response": "Tries to find the local timezone configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a default runner with specified udf class.", "response": "def get_default_runner(udf_class, input_col_delim=',', null_indicator='NULL', stdin=None):\n    \"\"\"Create a default runner with specified udf class.\n    \"\"\"\n    proto = udf.get_annotation(udf_class)\n    in_types, out_types = parse_proto(proto)\n    stdin = stdin or sys.stdin\n    arg_parser = ArgParser(in_types, stdin, input_col_delim, null_indicator)\n    stdin_feed = make_feed(arg_parser)\n    collector = StdoutCollector(out_types)\n    ctor = _get_runner_class(udf_class)\n    return ctor(udf_class, stdin_feed, collector)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_classifiers(algo_defs, env):\n    if not isinstance(algo_defs, Iterable):\n        algo_defs = [algo_defs, ]\n    load_algorithms(algo_defs, 'BaseTrainingAlgorithm', env)", "response": "Loads an algorithm into a module."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload an algorithm into a module.", "response": "def load_process_algorithm(algo_defs, env):\n    \"\"\"\n    Load an algorithm into a module. The algorithm is an instance of ``AlgorithmDef`` class.\n\n    :param algo_defs: algorithm definitions\n    :type algo_defs: AlgorithmDef | list[AlgorithmDef]\n    :param env: environment\n\n    :Example:\n    >>> import sys\n    >>> from odps.ml.algolib.loader import *\n    >>> a = XflowAlgorithmDef('SampleAlgorithm')\n    >>> a.add_param(ParamDef('param1', 'val1'))\n    >>> a.add_port(PortDef('input'))\n    >>> a.add_port(PortDef('output', PortDirection.OUTPUT))\n    >>> load_process_algorithm(a, sys.modules[__name__])\n    \"\"\"\n    if not isinstance(algo_defs, Iterable):\n        algo_defs = [algo_defs, ]\n    load_algorithms(algo_defs, 'BaseProcessAlgorithm', env)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets system s timezone offset using built - in library time.", "response": "def get_system_offset():\n    \"\"\"Get system's timezone offset using built-in library time.\n\n    For the Timezone constants (altzone, daylight, timezone, and tzname), the\n    value is determined by the timezone rules in effect at module load time or\n    the last time tzset() is called and may be incorrect for times in the past.\n\n    To keep compatibility with Windows, we're always importing time module here.\n    \"\"\"\n    import time\n    if time.daylight and time.localtime().tm_isdst > 0:\n        return -time.altzone\n    else:\n        return -time.timezone"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nasserting that the system s timezone offset equals to the timezone offset found.", "response": "def assert_tz_offset(tz):\n    \"\"\"Assert that system's timezone offset equals to the timezone offset found.\n\n    If they don't match, we probably have a misconfiguration, for example, an\n    incorrect timezone set in /etc/timezone file in systemd distributions.\"\"\"\n    tz_offset = get_tz_offset(tz)\n    system_offset = get_system_offset()\n    if tz_offset != system_offset:\n        msg = ('Timezone offset does not match system offset: {0} != {1}. '\n               'Please, check your config files.').format(\n                   tz_offset, system_offset\n               )\n        raise ValueError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning all the resources which this function refer to.", "response": "def resources(self):\n        \"\"\"\n        Return all the resources which this function refer to.\n\n        :return: resources\n        :rtype: list\n\n        .. seealso:: :class:`odps.models.Resource`\n        \"\"\"\n\n        if self._resources_objects is not None:\n            return self._resources_objects\n\n        resources = self.parent.parent.resources\n        resources = [resources[name] for name in self._resources]\n        self._resources_objects = resources\n        return resources"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates this function. :return: None", "response": "def update(self):\n        \"\"\"\n        Update this function.\n\n        :return: None\n        \"\"\"\n        if self._owner_changed:\n            self.update_owner(self.owner)\n\n        self._resources = [res.name for res in self.resources]\n        return self.parent.update(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_source(self, fullmodname):\n\n        submodname, is_package, relpath, fileobj = self._get_info(fullmodname)\n        fullpath = '%s%s%s' % (fileobj, os.sep, relpath)\n        if isinstance(fileobj, zipfile.ZipFile):\n            source = fileobj.read(relpath.replace(os.sep, '/'))\n        elif isinstance(fileobj, tarfile.TarFile):\n            source = fileobj.extractfile(relpath.replace(os.sep, '/')).read()\n        elif isinstance(fileobj, dict):\n            source = fileobj[relpath.replace(os.sep, '/')].read()\n        else:\n            source = open(fileobj[relpath.replace(os.sep, '/')], 'rb').read()\n        source = source.replace(b'\\r\\n', b'\\n').replace(b'\\r', b'\\n')\n        return submodname, is_package, fullpath, source", "response": "Internal helper for load_module."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_module(self, fullmodname):\n        submodname, is_package, fullpath, source = self._get_source(fullmodname)\n        code = compile(source, fullpath, 'exec')\n        mod = sys.modules.get(fullmodname)\n        try:\n            if mod is None:\n                mod = sys.modules[fullmodname] = types.ModuleType(fullmodname)\n            mod.__loader__ = self\n            mod.__file__ = fullpath\n            mod.__name__ = fullmodname\n            if is_package:\n                mod.__path__ = [os.path.dirname(mod.__file__)]\n            exec(code, mod.__dict__)\n        except:\n            if fullmodname in sys.modules:\n                del sys.modules[fullmodname]\n            raise\n        return mod", "response": "PEP - 302 - compliant load_module method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef confusion_matrix(df, col_true=None, col_pred=None):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_CLASS)\n    return _run_cm_node(df, col_true, col_pred)[0]", "response": "Compute confusion matrix of a predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef accuracy_score(df, col_true=None, col_pred=None, normalize=True):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_CLASS)\n    mat, _ = _run_cm_node(df, col_true, col_pred)\n    if np is not None:\n        acc_count = np.sum(np.diag(mat))\n        if not normalize:\n            return acc_count\n        else:\n            return acc_count * 1.0 / np.sum(mat)\n    else:\n        diag_sum = mat_sum = 0\n        mat_size = len(mat)\n        for i in compat.irange(mat_size):\n            for j in compat.irange(mat_size):\n                if i == j:\n                    diag_sum += mat[i][j]\n                mat_sum += mat[i][j]\n        if not normalize:\n            return diag_sum\n        else:\n            return diag_sum * 1.0 / mat_sum", "response": "Compute the accuracy of a predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef recall_score(df, col_true=None, col_pred='precision_result', pos_label=1, average=None):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_CLASS)\n    mat, label_list = _run_cm_node(df, col_true, col_pred)\n    class_dict = dict((label, idx) for idx, label in enumerate(label_list))\n    tps = np.diag(mat)\n    supp_count = np.sum(mat, axis=1)\n    if average is None:\n        return tps * 1.0 / supp_count\n    elif average == 'binary':\n        class_idx = class_dict[pos_label]\n        return tps[class_idx] * 1.0 / supp_count[class_idx]\n    elif average == 'micro' or average == 'weighted':\n        return np.sum(tps) / np.sum(supp_count)\n    elif average == 'macro':\n        return np.mean(tps * 1.0 / supp_count)", "response": "r Computes the recall of a predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef roc_curve(df, col_true=None, col_pred=None, col_scores=None, pos_label=1):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_CLASS)\n    if not col_scores:\n        col_scores = get_field_name_by_role(df, FieldRole.PREDICTED_SCORE)\n    thresh, tp, fn, tn, fp = _run_roc_node(df, pos_label, col_true, col_pred, col_scores)\n\n    if np is not None:\n        tpr = tp * 1.0 / (tp + fn)\n        fpr = fp * 1.0 / (fp + tn)\n    else:\n        tpr = [tp[i] * 1.0 / (tp[i] + fn[i]) for i in range(len(tp))]\n        fpr = [fp[i] * 1.0 / (fp[i] + tn[i]) for i in range(len(fp))]\n\n    roc_result = namedtuple('ROCResult', 'fpr tpr thresh')\n    return roc_result(fpr=fpr, tpr=tpr, thresh=thresh)", "response": "r Compute true positive rate false positive rate and threshold from predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing Area Under the Curve AUC from prediction scores with trapezoidal rule.", "response": "def roc_auc_score(df, col_true=None, col_pred=None, col_scores=None, pos_label=1):\n    \"\"\"\n    Compute Area Under the Curve (AUC) from prediction scores with trapezoidal rule.\n\n    Note that this method will trigger the defined flow to execute.\n\n    :param df: predicted data frame\n    :type df: DataFrame\n    :param pos_label: positive label\n    :type pos_label: str\n    :param col_true: true column\n    :type col_true: str\n    :param col_pred: predicted column, 'prediction_result' if absent.\n    :type col_pred: str\n    :param col_scores: score column, 'prediction_score' if absent.\n    :type col_scores: str\n    :return: AUC value\n    :rtype: float\n    \"\"\"\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_CLASS)\n    if not col_scores:\n        col_scores = get_field_name_by_role(df, FieldRole.PREDICTED_SCORE)\n    thresh, tp, fn, tn, fp = _run_roc_node(df, pos_label, col_true, col_pred, col_scores)\n    tpr = tp * 1.0 / (tp + fn)\n    fpr = fp * 1.0 / (fp + tn)\n    return auc(tpr, fpr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef average_precision_score(df, col_true=None, col_pred=None, col_scores=None, pos_label=1):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_CLASS)\n    if not col_scores:\n        col_scores = get_field_name_by_role(df, FieldRole.PREDICTED_SCORE)\n    thresh, tp, fn, tn, fp = _run_roc_node(df, pos_label, col_true, col_pred, col_scores)\n\n    precisions = np.squeeze(np.asarray(tp * 1.0 / (tp + fp)))\n    recalls = np.squeeze(np.asarray(tp * 1.0 / (tp + fn)))\n\n    return np.trapz(precisions, recalls)", "response": "Compute average precision score for a given ROC node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pack_tag(field_number, wire_type):\n    if not 0 <= wire_type <= _WIRETYPE_MAX:\n        raise errors.EncodeError('Unknown wire type: %d' % wire_type)\n    return (field_number << TAG_TYPE_BITS) | wire_type", "response": "Returns an unsigned 32 - bit integer that encodes the field number and wire type information in standard protocol message wire format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the number of bytes required to serialize a single varint.", "response": "def _var_uint64_byte_size_no_tag(uint64):\n    \"\"\"Returns the bytes required to serialize a single varint.\n    uint64 must be unsigned.\n    \"\"\"\n    if uint64 > UINT64_MAX:\n        raise errors.EncodeError('Value out of range: %d' % uint64)\n    bytes = 1\n    while uint64 > 0x7f:\n        bytes += 1\n        uint64 >>= 7\n    return bytes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef train(self, *args, **kwargs):\n        objs = self._do_transform(*args, **kwargs)\n        obj_list = [objs, ] if not isinstance(objs, Iterable) else objs\n        for obj in obj_list:\n            if not isinstance(obj, ODPSModelExpr):\n                continue\n            for meta in ['predictor', 'recommender']:\n                if meta not in self._metas:\n                    continue\n                mod = __import__(self.__class__.__module__.__name__, fromlist=[''])\\\n                    if not hasattr(self, '_env') else self._env\n                action_cls_name = underline_to_capitalized(self._metas[meta])\n                if not hasattr(mod, action_cls_name):\n                    action_cls_name = '_' + action_cls_name\n                setattr(obj, '_' + meta, mod + '.' + action_cls_name)\n\n        return objs", "response": "Perform training on a DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calc(self, *args, **kwargs):\n        cases = kwargs.pop('_cases', [])\n        if not isinstance(cases, Iterable):\n            cases = [cases, ]\n        result_callback = kwargs.pop('_result_callback', None)\n        execute_now = kwargs.pop('execute_now', True)\n\n        exec_id = self._get_exec_id()\n        params = dict((k, v.value) for k, v in six.iteritems(self._parameters))\n\n        obj_dict = self._map_inputs_from_args(*args, **kwargs)\n        engine_kw = dict(p for p in six.iteritems(kwargs) if p[0] not in obj_dict)\n\n        expr_kw = dict(_params=params, _exec_id=exec_id, _engine_kw=engine_kw)\n        if cases:\n            expr_kw['_cases'] = cases\n\n        expr_kw.update((ML_ARG_PREFIX + k, v) for k, v in six.iteritems(obj_dict))\n        if result_callback:\n            expr_kw['_result_callback'] = result_callback\n        expr = self._metrics_expr(**expr_kw)\n\n        if execute_now:\n            return expr.execute()\n        else:\n            return expr", "response": "Calculates the metrics expression for the current process."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwait for the given sequence of futures to complete.", "response": "def wait(fs, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the futures in the given sequence to complete.\n\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            wait upon.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        return_when: Indicates when this function should return. The options\n            are:\n\n            FIRST_COMPLETED - Return when any future finishes or is\n                              cancelled.\n            FIRST_EXCEPTION - Return when any future finishes by raising an\n                              exception. If no future raises an exception\n                              then it is equivalent to ALL_COMPLETED.\n            ALL_COMPLETED -   Return when all futures finish or are cancelled.\n\n    Returns:\n        A named 2-tuple of sets. The first set, named 'done', contains the\n        futures that completed (is finished or cancelled) before the wait\n        completed. The second set, named 'not_done', contains uncompleted\n        futures.\n    \"\"\"\n    with _AcquireFutures(fs):\n        done = set(f for f in fs\n                   if f._state in [CANCELLED_AND_NOTIFIED, FINISHED])\n        not_done = set(fs) - done\n\n        if (return_when == FIRST_COMPLETED) and done:\n            return DoneAndNotDoneFutures(done, not_done)\n        elif (return_when == FIRST_EXCEPTION) and done:\n            if any(f for f in done\n                   if not f.cancelled() and f.exception() is not None):\n                return DoneAndNotDoneFutures(done, not_done)\n\n        if len(done) == len(fs):\n            return DoneAndNotDoneFutures(done, not_done)\n\n        waiter = _create_and_install_waiters(fs, return_when)\n\n    waiter.event.wait(timeout)\n    for f in fs:\n        with f._condition:\n            f._waiters.remove(waiter)\n\n    done.update(waiter.finished_futures)\n    return DoneAndNotDoneFutures(done, set(fs) - done)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncanceling the current task if possible. Returns True if the task was cancelled False otherwise.", "response": "def cancel(self):\n        \"\"\"Cancel the future if possible.\n\n        Returns True if the future was cancelled, False otherwise. A future\n        cannot be cancelled if it is running or has already completed.\n        \"\"\"\n        with self._condition:\n            if self._state in [RUNNING, FINISHED]:\n                return False\n\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                return True\n\n            self._state = CANCELLED\n            self._condition.notify_all()\n\n        self._invoke_callbacks()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_done_callback(self, fn):\n        with self._condition:\n            if self._state not in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]:\n                self._done_callbacks.append(fn)\n                return\n        fn(self)", "response": "Attaches a callable that will be called when the future completes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef result(self, timeout=None):\n        with self._condition:\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self.__get_result()\n\n            self._condition.wait(timeout)\n\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self.__get_result()\n            else:\n                raise TimeoutError()", "response": "Returns the result of the call that the future represents."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef exception_info(self, timeout=None):\n        with self._condition:\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self._exception, self._traceback\n\n            self._condition.wait(timeout)\n\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self._exception, self._traceback\n            else:\n                raise TimeoutError()", "response": "Returns a tuple of exception traceback and condition for the exception raised by the call that the the\n            future represents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_exception_info(self, exception, traceback):\n        with self._condition:\n            self._exception = exception\n            self._traceback = traceback\n            self._state = FINISHED\n            for waiter in self._waiters:\n                waiter.add_exception(self)\n            self._condition.notify_all()\n        self._invoke_callbacks()", "response": "Sets the result of the future as being the given exception and traceback."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef map(self, fn, *iterables, **kwargs):\n        timeout = kwargs.get('timeout')\n        if timeout is not None:\n            end_time = timeout + time.time()\n\n        fs = [self.submit(fn, *args) for args in itertools.izip(*iterables)]\n\n        # Yield must be hidden in closure so that the futures are submitted\n        # before the first iterator value is required.\n        def result_iterator():\n            try:\n                for future in fs:\n                    if timeout is None:\n                        yield future.result()\n                    else:\n                        yield future.result(end_time - time.time())\n            finally:\n                for future in fs:\n                    future.cancel()\n        return result_iterator()", "response": "Returns an iterator equivalent to map ( fn iter )."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes obj as bytes streamed into file.", "response": "def dump(obj, file, protocol=None, dump_code=False):\n    \"\"\"Serialize obj as bytes streamed into file\n\n    protocol defaults to cloudpickle.DEFAULT_PROTOCOL which is an alias to\n    pickle.HIGHEST_PROTOCOL. This setting favors maximum communication speed\n    between processes running the same Python version.\n\n    Set protocol=pickle.DEFAULT_PROTOCOL instead if you need to ensure\n    compatibility with older versions of Python.\n    \"\"\"\n    CloudPickler(file, protocol=protocol, dump_code=dump_code).dump(obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a skeleton function object that contains just the provided code and the correct number of cells in func_closure.", "response": "def _make_skel_func(code, cell_count, base_globals=None):\n    \"\"\" Creates a skeleton function object that contains just the provided\n        code and the correct number of cells in func_closure.  All other\n        func attributes (e.g. func_globals) are empty.\n    \"\"\"\n    if base_globals is None:\n        base_globals = {}\n    elif isinstance(base_globals, string_types):\n        base_globals_name = base_globals\n        try:\n            # First try to reuse the globals from the module containing the\n            # function. If it is not possible to retrieve it, fallback to an\n            # empty dictionary.\n            if importlib is not None:\n                base_globals = vars(importlib.import_module(base_globals))\n            elif sys.modules.get(base_globals, None) is not None:\n                base_globals = vars(sys.modules[base_globals])\n            else:\n                raise ImportError\n        except ImportError:\n            base_globals = _dynamic_modules_globals.get(\n                    base_globals_name, None)\n            if base_globals is None:\n                base_globals = _DynamicModuleFuncGlobals()\n            _dynamic_modules_globals[base_globals_name] = base_globals\n\n    base_globals['__builtins__'] = __builtins__\n\n    closure = (\n        tuple(_make_empty_cell() for _ in range(cell_count))\n        if cell_count >= 0 else\n        None\n    )\n    return types.FunctionType(code, base_globals, None, None, closure)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving a module as an import", "response": "def save_module(self, obj):\n        \"\"\"\n        Save a module as an import\n        \"\"\"\n        self.modules.add(obj)\n        if _is_dynamic(obj):\n            self.save_reduce(dynamic_subimport, (obj.__name__, vars(obj)),\n                             obj=obj)\n        else:\n            self.save_reduce(subimport, (obj.__name__,), obj=obj)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave a code object", "response": "def save_codeobject(self, obj):\n        \"\"\"\n        Save a code object\n        \"\"\"\n        if self.dump_code:\n            print(obj.co_name)\n            dis.dis(obj.co_code)\n        self.save_reduce(types.CodeType, self._extract_code_args(obj), obj=obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract the data needed to recreate the function.", "response": "def extract_func_data(self, func):\n        \"\"\"\n        Turn the function into a tuple of data necessary to recreate it:\n            code, globals, defaults, closure_values, dict\n        \"\"\"\n        code = func.__code__\n\n        # extract all global ref's\n        func_global_refs = self.extract_code_globals(code)\n\n        # process all variables referenced by global environment\n        f_globals = {}\n        for var in func_global_refs:\n            if var in func.__globals__:\n                f_globals[var] = func.__globals__[var]\n\n        # defaults requires no processing\n        defaults = func.__defaults__\n\n        # process closure\n        closure = (\n            list(map(_get_cell_contents, func.__closure__))\n            if func.__closure__ is not None\n            else None\n        )\n\n        # save the dict\n        dct = func.__dict__\n\n        base_globals = self.globals_ref.get(id(func.__globals__), None)\n        if base_globals is None:\n            # For functions defined in a well behaved module use\n            # vars(func.__module__) for base_globals. This is necessary to\n            # share the global variables across multiple pickled functions from\n            # this module.\n            if hasattr(func, '__module__') and func.__module__ is not None:\n                base_globals = func.__module__\n            else:\n                base_globals = {}\n        self.globals_ref[id(func.__globals__)] = base_globals\n\n        return (code, f_globals, defaults, closure, dct, base_globals)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef persist(self, name, project=None, drop_model=False, **kwargs):\n        return super(ODPSModelExpr, self).persist(name, project=project, drop_model=drop_model, **kwargs)", "response": "Persist the execution into a new model."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef predict(self, *args, **kwargs):\n        return super(PmmlModel, self).predict(*args, **kwargs)", "response": "Predict given DataFrame using the given model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef predict(self, *args, **kwargs):\n        return super(TablesModel, self).predict(*args, **kwargs)", "response": "Predict given DataFrame using the given model."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget logs from worker.", "response": "def get_log(self, log_type, size=0):\n        \"\"\"\n        Get logs from worker.\n\n        :param log_type: type of logs. Possible log types contains {log_types}\n        :param size: length of the log to retrieve\n        :return: log content\n        \"\"\"\n        return self.parent.get_worker_log(self.log_id, log_type, size=size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes the DFAdapter s _get_ml_fields method.", "response": "def execute(self, sources, target):\n        \"\"\"\n        :type sources: list[DFAdapter]\n        :type target: DFAdapter\n        \"\"\"\n        fields = self._get_fields_list_from_eps(sources)\n        target._ml_fields = copy.deepcopy(fields[0])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the DFAdapter s operation.", "response": "def execute(self, sources, target):\n        \"\"\"\n        :type sources: list[DFAdapter]\n        :type target: DFAdapter\n        \"\"\"\n        fields = self._get_fields_list_from_eps(sources)\n        feature_set = set(self.feature_names)\n        target._ml_fields = list(self._add_field_roles(fields[0], feature_set, self.role, self.augment))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting the DFAdapter clear_ml_fields method.", "response": "def execute(self, sources, target):\n        \"\"\"\n        :type sources: list[DFAdapter]\n        :type target: DFAdapter\n        \"\"\"\n        fields = self._get_fields_list_from_eps(sources)\n        feature_set = set(self.exclude_names)\n        target._ml_fields = list(self._clear_field_roles(fields[0], feature_set))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute(self, sources, target):\n        fields = self._get_fields_list_from_eps(sources)\n        ret_fields = fields[0]\n        if self.clear_feature:\n            ret_fields = list(self._remove_field_roles(ret_fields, set(six.iterkeys(self.field_mapping)),\n                                                       FieldRole.FEATURE))\n        target._ml_fields = list(self._set_singleton_role(ret_fields, self.field_mapping))", "response": "Execute the DFAdapter s Execute method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the MLE operation on the DFAdapter.", "response": "def execute(self, sources, target):\n        \"\"\"\n        :type sources: list[DFAdapter]\n        :type target: DFAdapter\n        \"\"\"\n        fields = self._get_fields_list_from_eps(sources)\n        for f in fields[0]:\n            if f.name in self.continuity:\n                f.continuity = self.continuity[f.name]\n        for field_name in set(six.iterkeys(self.continuity)) - set(f.name for f in fields[0]):\n            fields[0].append(MLField(field_name, 'EXPECTED', None, continuity=self.continuity[field_name]))\n        target._ml_fields = fields[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting the DFAdapter s operation.", "response": "def execute(self, sources, target):\n        \"\"\"\n        :type sources: list[DFAdapter]\n        :type target: DFAdapter\n        \"\"\"\n        existing_ml_fields = self._get_fields_list_from_eps(sources)\n        dup_ml_fields = [f.copy() for f in self.fields]\n        if self.is_append:\n            src = list([copy.deepcopy(f) for f in existing_ml_fields[0]])\n            src.extend(dup_ml_fields)\n            target._ml_fields = src\n        else:\n            target._ml_fields = self.fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self, sources, target):\n        existing_ml_fields = self._get_fields_list_from_eps(sources)\n\n        def gen_field(field_str):\n            parts = field_str.split(':')\n            if len(parts) > 2:\n                roles = set(MLField.translate_role_name(rn) for rn in parts[2].strip().split('#')) - set([None])\n            else:\n                roles = set([FieldRole.FEATURE, ])\n            return MLField(parts[0].strip(), parts[1].strip(), roles)\n\n        fields = [gen_field(fstr) for fstr in self.evaluator().split(',')\n                  if fstr.strip() != '']\n\n        dup_ml_fields = [f.copy(None) for f in fields]\n        if self.is_append:\n            src = list([copy.deepcopy(f) for f in existing_ml_fields[0]])\n            src.extend(dup_ml_fields)\n            target._ml_fields = src\n        else:\n            target._ml_fields = fields", "response": "Execute the evaluator on the sources and target."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(self, sources, target):\n        existing_fields = self._get_fields_list_from_eps(sources)\n\n        def trans_columns(tid, fields):\n            sel_cols = self._selected_cols.get(tid)\n            exc_cols = self._excluded_cols.get(tid)\n            for field in fields:\n                if field.role is None:\n                    continue\n                if sel_cols and field.name not in sel_cols:\n                    continue\n                if exc_cols and field.name in exc_cols:\n                    continue\n                new_col = field.copy(field.role)\n                if self._auto_rename:\n                    new_col.name = 't%d_%s' % (tid, field.name)\n                yield new_col\n\n        new_fields = map(lambda tp: list(trans_columns(tp[0], tp[1])), enumerate(existing_fields))\n        target._ml_fields = list(reduce(lambda fa, fb: fa + fb, new_fields, []))\n        target._ml_uplink = sources", "response": ":type sources: list[DFAdapter]\n        :type target: DFAdapter"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalues counts the number of items in the sequence or group by.", "response": "def count(expr):\n    \"\"\"\n    Value counts\n\n    :param expr:\n    :return:\n    \"\"\"\n\n    if isinstance(expr, SequenceExpr):\n        unique_input = _extract_unique_input(expr)\n        if unique_input:\n            return nunique(unique_input).rename('count')\n        else:\n            return Count(_value_type=types.int64, _input=expr)\n    elif isinstance(expr, SequenceGroupBy):\n        return GroupedCount(_data_type=types.int64, _input=expr.to_column(),\n                            _grouped=expr.input)\n    elif isinstance(expr, CollectionExpr):\n        return Count(_value_type=types.int64, _input=expr).rename('count')\n    elif isinstance(expr, GroupBy):\n        return GroupedCount(_data_type=types.int64, _input=expr.input,\n                            _grouped=expr).rename('count')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsumming value of the .", "response": "def sum_(expr):\n    \"\"\"\n    Sum value\n\n    :param expr:\n    :return:\n    \"\"\"\n\n    output_type = None\n    if isinstance(expr, (SequenceExpr, SequenceGroupBy)):\n        if expr._data_type == types.boolean:\n            output_type = types.int64\n        else:\n            output_type = expr._data_type\n    return _reduction(expr, Sum, output_type)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef std(expr, **kw):\n\n    ddof = kw.get('ddof', kw.get('_ddof', 1))\n\n    output_type = _stats_type(expr)\n    return _reduction(expr, Std, output_type, _ddof=ddof)", "response": "Standard deviation of a sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef quantile(expr, prob=None, **kw):\n\n    prob = kw.get('_prob', prob)\n    output_type = _stats_type(expr)\n    if isinstance(prob, (list, set)) and not isinstance(expr, GroupBy):\n        output_type = types.List(output_type)\n    return _reduction(expr, Quantile, output_type, _prob=prob)", "response": "Get a new value for the quantile of the sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nunique(expr):\n    output_type = types.int64\n\n    if isinstance(expr, SequenceExpr):\n        return NUnique(_value_type=output_type, _inputs=[expr])\n    elif isinstance(expr, SequenceGroupBy):\n        return GroupedNUnique(_data_type=output_type, _inputs=[expr.to_column()], _grouped=expr.input)\n    elif isinstance(expr, CollectionExpr):\n        unique_input = _extract_unique_input(expr)\n        if unique_input:\n            return nunique(unique_input)\n        else:\n            return NUnique(_value_type=types.int64, _inputs=expr._project_fields)\n    elif isinstance(expr, GroupBy):\n        if expr._to_agg:\n            inputs = expr.input[expr._to_agg.names]._project_fields\n        else:\n            inputs = expr.input._project_fields\n        return GroupedNUnique(_data_type=types.int64, _inputs=inputs,\n                              _grouped=expr)", "response": "Returns the number of unique entries in the current node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cat(expr, others=None, sep=None, na_rep=None):\n\n    if others is not None:\n        from .strings import _cat as cat_str\n\n        return cat_str(expr, others, sep=sep, na_rep=na_rep)\n\n    return _cat(expr, sep=sep, na_rep=na_rep)", "response": "Concatenate strings in sequence with given separator"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the n - th order moment of the sequence.", "response": "def moment(expr, order, central=False):\n    \"\"\"\n    Calculate the n-th order moment of the sequence\n\n    :param expr:\n    :param order: moment order, must be an integer\n    :param central: if central moments are to be computed.\n    :return:\n    \"\"\"\n    if not isinstance(order, six.integer_types):\n        raise ValueError('Only integer-ordered moments are supported.')\n    if order < 0:\n        raise ValueError('Only non-negative orders are supported.')\n    output_type = _stats_type(expr)\n    return _reduction(expr, Moment, output_type, _order=order, _center=central)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npacks all data in the sequence into a list", "response": "def tolist(expr, **kwargs):\n    \"\"\"\n    Pack all data in the sequence into a list\n    :param expr:\n    :param unique: make every elements in the sequence to be unique\n    :return:\n    \"\"\"\n    unique = kwargs.get('unique', kwargs.get('_unique', False))\n    output_type = None\n\n    if isinstance(expr, (SequenceExpr, SequenceGroupBy)):\n        output_type = types.List(expr._data_type)\n    return _reduction(expr, ToList, output_type, _unique=unique)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstop this instance. :return: None", "response": "def stop(self):\n        \"\"\"\n        Stop this instance.\n\n        :return: None\n        \"\"\"\n\n        instance_status = Instance.InstanceStatus(status='Terminated')\n        xml_content = instance_status.serialize()\n\n        headers = {'Content-Type': 'application/xml'}\n        self._client.put(self.resource(), xml_content, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all the task results.", "response": "def get_task_results(self):\n        \"\"\"\n        Get all the task results.\n\n        :return: a dict which key is task name, and value is the task result as string\n        :rtype: dict\n        \"\"\"\n\n        results = self.get_task_results_without_format()\n        if options.tunnel.string_as_binary:\n            return compat.OrderedDict([(k, bytes(result)) for k, result in six.iteritems(results)])\n        else:\n            return compat.OrderedDict([(k, str(result)) for k, result in six.iteritems(results)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_task_summary(self, task_name):\n\n        params = {'instancesummary': '', 'taskname': task_name}\n        resp = self._client.get(self.resource(), params=params)\n\n        map_reduce = resp.json().get('Instance')\n        if map_reduce:\n            json_summary = map_reduce.get('JsonSummary')\n            if json_summary:\n                summary = Instance.TaskSummary(json.loads(json_summary))\n                summary.summary_text = map_reduce.get('Summary')\n                summary.json_summary = json_summary\n\n                return summary", "response": "Get a task s summary mostly used for MapReduce."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all tasks statuses", "response": "def get_task_statuses(self):\n        \"\"\"\n        Get all tasks' statuses\n\n        :return: a dict which key is the task name and value is the :class:`odps.models.Instance.Task` object\n        :rtype: dict\n        \"\"\"\n\n        params = {'taskstatus': ''}\n\n        resp = self._client.get(self.resource(), params=params)\n        self.parse(self._client, resp, obj=self)\n\n        return dict([(task.name, task) for task in self._tasks])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_task_cost(self, task_name):\n        summary = self.get_task_summary(task_name)\n        if summary is None:\n            return None\n\n        if 'Cost' in summary:\n            task_cost = summary['Cost']\n\n            cpu_cost = task_cost.get('CPU')\n            memory = task_cost.get('Memory')\n            input_size = task_cost.get('Input')\n\n            return Instance.TaskCost(cpu_cost, memory, input_size)", "response": "Get task cost\n\n        :param task_name: name of the task\n        :return: task cost\n        :rtype: Instance.TaskCost\n\n        :Example:\n\n        >>> cost = instance.get_task_cost(instance.get_task_names()[0])\n        >>> cost.cpu_cost\n        200\n        >>> cost.memory_cost\n        4096\n        >>> cost.input_size\n        0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_task_info(self, task_name, key):\n        params = OrderedDict([('info', ''), ('taskname', task_name), ('key', key)])\n\n        resp = self._client.get(self.resource(), params=params)\n        return resp.text", "response": "Get task related information."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nput information into a task.", "response": "def put_task_info(self, task_name, key, value):\n        \"\"\"\n        Put information into a task.\n\n        :param task_name: name of the task\n        :param key: key of the information item\n        :param value: value of the information item\n        \"\"\"\n        params = OrderedDict([('info', ''), ('taskname', task_name)])\n        headers = {'Content-Type': 'application/xml'}\n        body = self.TaskInfo(key=key, value=value).serialize()\n\n        self._client.put(self.resource(), params=params, headers=headers, data=body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the queueing info of the task.", "response": "def get_task_quota(self, task_name):\n        \"\"\"\n        Get queueing info of the task.\n        Note that time between two calls should larger than 30 seconds, otherwise empty dict is returned.\n\n        :param task_name: name of the task\n        :return: quota info in dict format\n        \"\"\"\n        params = OrderedDict([('instancequota', ''), ('taskname', task_name)])\n        resp = self._client.get(self.resource(), params=params)\n        return json.loads(resp.text)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_sql_task_cost(self):\n        resp = self.get_task_result(self.get_task_names()[0])\n        cost = json.loads(resp)\n        sql_cost = cost['Cost']['SQL']\n\n        udf_num = sql_cost.get('UDF')\n        complexity = sql_cost.get('Complexity')\n        input_size = sql_cost.get('Input')\n        return Instance.SQLCost(udf_num, complexity, input_size)", "response": "Get the SQL cost information of the sql task."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if this instance has finished or False if it has not yet finished.", "response": "def is_terminated(self, retry=False):\n        \"\"\"\n        If this instance has finished or not.\n\n        :return: True if finished else False\n        :rtype: bool\n        \"\"\"\n        retry_num = options.retry_times\n        while retry_num > 0:\n            try:\n                return self.status == Instance.Status.TERMINATED\n            except (errors.InternalServerError, errors.RequestTimeTooSkewed):\n                retry_num -= 1\n                if not retry or retry_num <= 0:\n                    raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the instance runs successfully False otherwise.", "response": "def is_successful(self, retry=False):\n        \"\"\"\n        If the instance runs successfully.\n\n        :return: True if successful else False\n        :rtype: bool\n        \"\"\"\n\n        if not self.is_terminated(retry=retry):\n            return False\n        retry_num = options.retry_times\n        while retry_num > 0:\n            try:\n                statuses = self.get_task_statuses()\n                return all(task.status == Instance.Task.TaskStatus.SUCCESS\n                           for task in statuses.values())\n            except (errors.InternalServerError, errors.RequestTimeTooSkewed):\n                retry_num -= 1\n                if not retry or retry_num <= 0:\n                    raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwaiting for the instance to complete and neglect the consequence.", "response": "def wait_for_completion(self, interval=1):\n        \"\"\"\n        Wait for the instance to complete, and neglect the consequence.\n\n        :param interval: time interval to check\n        :return: None\n        \"\"\"\n\n        while not self.is_terminated(retry=True):\n            try:\n                time.sleep(interval)\n            except KeyboardInterrupt:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait_for_success(self, interval=1):\n\n        self.wait_for_completion(interval=interval)\n\n        if not self.is_successful(retry=True):\n            for task_name, task in six.iteritems(self.get_task_statuses()):\n                exc = None\n                if task.status == Instance.Task.TaskStatus.FAILED:\n                    exc = errors.parse_instance_error(self.get_task_result(task_name))\n                elif task.status != Instance.Task.TaskStatus.SUCCESS:\n                    exc = errors.ODPSError('%s, status=%s' % (task_name, task.status.value))\n                if exc:\n                    exc.instance_id = self.id\n                    raise exc", "response": "Wait for the instance to complete and check if it is successful."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the current task s current progress.", "response": "def get_task_progress(self, task_name):\n        \"\"\"\n        Get task's current progress\n\n        :param task_name: task_name\n        :return: the task's progress\n        :rtype: :class:`odps.models.Instance.Task.TaskProgress`\n        \"\"\"\n\n        params = {'instanceprogress': task_name, 'taskname': task_name}\n\n        resp = self._client.get(self.resource(), params=params)\n        return Instance.Task.TaskProgress.parse(self._client, resp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_task_detail(self, task_name):\n        def _get_detail():\n            from ..compat import json  # fix object_pairs_hook parameter for Py2.6\n\n            params = {'instancedetail': '',\n                      'taskname': task_name}\n\n            resp = self._client.get(self.resource(), params=params)\n            return json.loads(resp.text if six.PY3 else resp.content,\n                              object_pairs_hook=OrderedDict)\n\n        result = _get_detail()\n        if not result:\n            # todo: this is a workaround for the bug that get_task_detail returns nothing.\n            self.get_task_detail2(task_name)\n            return _get_detail()\n        else:\n            return result", "response": "Get the task s detail according to the JSON version of the task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the task s detail v2", "response": "def get_task_detail2(self, task_name):\n        \"\"\"\n        Get task's detail v2\n\n        :param task_name: task name\n        :return: the task's detail\n        :rtype: list or dict according to the JSON\n        \"\"\"\n\n        from ..compat import json  # fix object_pairs_hook parameter for Py2.6\n\n        params = {'detail': '',\n                  'taskname': task_name}\n\n        resp = self._client.get(self.resource(), params=params)\n        res = resp.text if six.PY3 else resp.content\n        try:\n            return json.loads(res, object_pairs_hook=OrderedDict)\n        except ValueError:\n            return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget workers from task name.", "response": "def get_task_workers(self, task_name=None, json_obj=None):\n        \"\"\"\n        Get workers from task\n        :param task_name: task name\n        :param json_obj: json object parsed from get_task_detail2\n        :return: list of workers\n\n        .. seealso:: :class:`odps.models.Worker`\n        \"\"\"\n        if task_name is None and json_obj is None:\n            raise ValueError('Either task_name or json_obj should be provided')\n\n        if json_obj is None:\n            json_obj = self.get_task_detail2(task_name)\n        return WorkerDetail2.extract_from_json(json_obj, client=self._client, parent=self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_worker_log(self, log_id, log_type, size=0):\n        params = OrderedDict([('log', ''), ('id', log_id)])\n        if log_type is not None:\n            log_type = log_type.lower()\n            if log_type not in LOG_TYPES_MAPPING:\n                raise ValueError('log_type should choose a value in ' +\n                                 ' '.join(six.iterkeys(LOG_TYPES_MAPPING)))\n            params['logtype'] = LOG_TYPES_MAPPING[log_type]\n        if size > 0:\n            params['size'] = str(size)\n        resp = self._client.get(self.resource(), params=params)\n        return resp.text", "response": "Get logs from worker."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the logview address of the instance object by hours.", "response": "def get_logview_address(self, hours=None):\n        \"\"\"\n        Get logview address of the instance object by hours.\n\n        :param hours:\n        :return: logview address\n        :rtype: str\n        \"\"\"\n        hours = hours or options.log_view_hours\n\n        project = self.project\n        url = '%s/authorization' % project.resource()\n\n        policy = {\n            'expires_in_hours': hours,\n            'policy': {\n                'Statement': [{\n                    'Action': ['odps:Read'],\n                    'Effect': 'Allow',\n                    'Resource': 'acs:odps:*:projects/%s/instances/%s' % \\\n                                (project.name, self.id)\n                }],\n                'Version': '1',\n            }\n        }\n        headers = {'Content-Type': 'application/json'}\n        params = {'sign_bearer_token': ''}\n        data = json.dumps(policy)\n        res = self._client.post(url, data, headers=headers, params=params)\n\n        content = res.text if six.PY3 else res.content\n        root = ElementTree.fromstring(content)\n        token = root.find('Result').text\n\n        link = options.log_view_host + \"/logview/?h=\" + self._client.endpoint + \"&p=\" \\\n               + project.name + \"&i=\" + self.id + \"&token=\" + token\n        return link"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nopens the reader to read records from the result of the instance.", "response": "def open_reader(self, *args, **kwargs):\n        \"\"\"\n        Open the reader to read records from the result of the instance. If `tunnel` is `True`,\n        instance tunnel will be used. Otherwise conventional routine will be used. If instance tunnel\n        is not available and `tunnel` is not specified,, the method will fall back to the\n        conventional routine.\n        Note that the number of records returned is limited unless `options.limited_instance_tunnel`\n        is set to `True` or `limit=True` is configured under instance tunnel mode. Otherwise\n        the number of records returned is always limited.\n\n        :param tunnel: if true, use instance tunnel to read from the instance.\n                       if false, use conventional routine.\n                       if absent, `options.tunnel.use_instance_tunnel` will be used and automatic fallback\n                       is enabled.\n        :param reopen: the reader will reuse last one, reopen is true means open a new reader.\n        :type reopen: bool\n        :param endpoint: the tunnel service URL\n        :param compress_option: compression algorithm, level and strategy\n        :type compress_option: :class:`odps.tunnel.CompressOption`\n        :param compress_algo: compression algorithm, work when ``compress_option`` is not provided,\n                              can be ``zlib``, ``snappy``\n        :param compress_level: used for ``zlib``, work when ``compress_option`` is not provided\n        :param compress_strategy: used for ``zlib``, work when ``compress_option`` is not provided\n        :return: reader, ``count`` means the full size, ``status`` means the tunnel status\n\n        :Example:\n\n        >>> with instance.open_reader() as reader:\n        >>>     count = reader.count  # How many records of a table or its partition\n        >>>     for record in reader[0: count]:\n        >>>         # read all data, actually better to split into reading for many times\n        \"\"\"\n        use_tunnel = kwargs.get('use_tunnel', kwargs.get('tunnel'))\n        auto_fallback_result = use_tunnel is None\n        if use_tunnel is None:\n            use_tunnel = options.tunnel.use_instance_tunnel\n        result_fallback_errors = (errors.InvalidProjectTable, errors.InvalidArgument)\n        if use_tunnel:\n            # for compatibility\n            if 'limit_enabled' in kwargs:\n                kwargs['limit'] = kwargs['limit_enabled']\n                del kwargs['limit_enabled']\n\n            if 'limit' not in kwargs:\n                kwargs['limit'] = options.tunnel.limit_instance_tunnel\n\n            auto_fallback_protection = False\n            if kwargs['limit'] is None:\n                kwargs['limit'] = False\n                auto_fallback_protection = True\n\n            try:\n                return self._open_tunnel_reader(**kwargs)\n            except result_fallback_errors:\n                # service version too low to support instance tunnel.\n                if not auto_fallback_result:\n                    raise\n                if not kwargs.get('limit'):\n                    warnings.warn('Instance tunnel not supported, will fallback to '\n                                  'conventional ways. 10000 records will be limited.')\n            except requests.Timeout:\n                # tunnel creation timed out, which might be caused by too many files\n                # on the service.\n                if not auto_fallback_result:\n                    raise\n                if not kwargs.get('limit'):\n                    warnings.warn('Instance tunnel timed out, will fallback to '\n                                  'conventional ways. 10000 records will be limited.')\n            except (Instance.DownloadSessionCreationError, errors.InstanceTypeNotSupported):\n                # this is for DDL sql instances such as `show partitions` which raises\n                # InternalServerError when creating download sessions.\n                if not auto_fallback_result:\n                    raise\n            except errors.NoPermission:\n                # project is protected\n                if not auto_fallback_protection:\n                    raise\n                if not kwargs.get('limit'):\n                    warnings.warn('Project under protection, 10000 records will be limited.')\n                    kwargs['limit'] = True\n                    return self._open_tunnel_reader(**kwargs)\n\n        return self._open_result_reader(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if we re inside an IPython qtconsole", "response": "def in_qtconsole():\n    \"\"\"\n    check if we're inside an IPython qtconsole\n\n    DEPRECATED: This is no longer needed, or working, in IPython 3 and above.\n    \"\"\"\n    try:\n        ip = get_ipython()\n        front_end = (\n            ip.config.get('KernelApp', {}).get('parent_appname', \"\") or\n            ip.config.get('IPKernelApp', {}).get('parent_appname', \"\")\n        )\n        if 'qtconsole' in front_end.lower():\n            return True\n    except:\n        return False\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning console size as tuple = width height.", "response": "def get_console_size():\n    \"\"\"Return console size as tuple = (width, height).\n\n    Returns (None,None) in non-interactive session.\n    \"\"\"\n    display_width = options.display.width\n    # deprecated.\n    display_height = options.display.max_rows\n\n    # Consider\n    # interactive shell terminal, can detect term size\n    # interactive non-shell terminal (ipnb/ipqtconsole), cannot detect term\n    # size non-interactive script, should disregard term size\n\n    # in addition\n    # width,height have default values, but setting to 'None' signals\n    # should use Auto-Detection, But only in interactive shell-terminal.\n    # Simple. yeah.\n\n    if in_interactive_session():\n        if in_ipython_frontend():\n            # sane defaults for interactive non-shell terminal\n            # match default for width,height in config_init\n            try:\n                from pandas.core.config import get_default_val\n                terminal_width = get_default_val('display.width')\n                terminal_height = get_default_val('display.max_rows')\n            except ImportError:\n                terminal_width, terminal_height = None, None\n        else:\n            # pure terminal\n            terminal_width, terminal_height = get_terminal_size()\n    else:\n        terminal_width, terminal_height = None, None\n\n    # Note if the User sets width/Height to None (auto-detection)\n    # and we're in a script (non-inter), this will return (None,None)\n    # caller needs to deal.\n    return (display_width or terminal_width, display_height or terminal_height)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef isatty(file):\n    if (multiprocessing.current_process().name != 'MainProcess' or\n        threading.current_thread().getName() != 'MainThread'):\n        return False\n\n    if hasattr(file, 'isatty'):\n        return file.isatty()\n    elif (OutStream is not None and\n          isinstance(file, (OutStream, IPythonIOStream)) and\n          ((hasattr(file, 'name') and file.name == 'stdout') or\n           (hasattr(file, 'stream') and\n               isinstance(file.stream, PyreadlineConsole)))):\n        # File is an IPython OutStream or IOStream and\n        #    File name is 'stdout' or\n        #    File wraps a Console\n        return True\n    return False", "response": "Returns True if file is a tty."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the height and width of the terminal.", "response": "def _terminal_size(file=None):\n    \"\"\"\n    Returns a tuple (height, width) containing the height and width of\n    the terminal.\n\n    This function will look for the width in height in multiple areas\n    before falling back on the width and height in astropy's\n    configuration.\n    \"\"\"\n\n    if file is None:\n        file = _get_stdout()\n\n    try:\n        s = struct.pack(str(\"HHHH\"), 0, 0, 0, 0)\n        x = fcntl.ioctl(file, termios.TIOCGWINSZ, s)\n        (lines, width, xpixels, ypixels) = struct.unpack(str(\"HHHH\"), x)\n        if lines > 12:\n            lines -= 6\n        if width > 10:\n            width -= 1\n        return (lines, width)\n    except:\n        try:\n            # see if POSIX standard variables will work\n            return (int(os.environ.get('LINES')),\n                    int(os.environ.get('COLUMNS')))\n        except TypeError:\n            # fall back on configuration variables, or if not\n            # set, (25, 80)\n            lines = options.console.max_lines\n            width = options.console.max_width\n            if lines is None:\n                lines = 25\n            if width is None:\n                width = 80\n            return lines, width"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncoloring the text in a new ANSI terminal.", "response": "def _color_text(text, color):\n    \"\"\"\n    Returns a string wrapped in ANSI color codes for coloring the\n    text in a terminal::\n\n        colored_text = color_text('Here is a message', 'blue')\n\n    This won't actually effect the text until it is printed to the\n    terminal.\n\n    Parameters\n    ----------\n    text : str\n        The string to return, bounded by the color codes.\n    color : str\n        An ANSI terminal color name. Must be one of:\n        black, red, green, brown, blue, magenta, cyan, lightgrey,\n        default, darkgrey, lightred, lightgreen, yellow, lightblue,\n        lightmagenta, lightcyan, white, or '' (the empty string).\n    \"\"\"\n    color_mapping = {\n        'black': '0;30',\n        'red': '0;31',\n        'green': '0;32',\n        'brown': '0;33',\n        'blue': '0;34',\n        'magenta': '0;35',\n        'cyan': '0;36',\n        'lightgrey': '0;37',\n        'default': '0;39',\n        'darkgrey': '1;30',\n        'lightred': '1;31',\n        'lightgreen': '1;32',\n        'yellow': '1;33',\n        'lightblue': '1;34',\n        'lightmagenta': '1;35',\n        'lightcyan': '1;36',\n        'white': '1;37'}\n\n    if sys.platform == 'win32' and OutStream is None:\n        # On Windows do not colorize text unless in IPython\n        return text\n\n    color_code = color_mapping.get(color, '0;39')\n    return '\\033[{0}m{1}\\033[0m'.format(color_code, text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndecodes the supplied byte string using the preferred encoding for the locale.", "response": "def _decode_preferred_encoding(s):\n    \"\"\"Decode the supplied byte string using the preferred encoding\n    for the locale (`locale.getpreferredencoding`) or, if the default encoding\n    is invalid, fall back first on utf-8, then on latin-1 if the message cannot\n    be decoded with utf-8.\n    \"\"\"\n\n    enc = locale.getpreferredencoding()\n    try:\n        try:\n            return s.decode(enc)\n        except LookupError:\n            enc = _DEFAULT_ENCODING\n        return s.decode(enc)\n    except UnicodeDecodeError:\n        return s.decode('latin-1')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _write_with_fallback(s, write, fileobj):\n\n    if IPythonIOStream is not None and isinstance(fileobj, IPythonIOStream):\n        # If the output stream is an IPython.utils.io.IOStream object that's\n        # not going to be very helpful to us since it doesn't raise any\n        # exceptions when an error occurs writing to its underlying stream.\n        # There's no advantage to us using IOStream.write directly though;\n        # instead just write directly to its underlying stream:\n        write = fileobj.stream.write\n\n    try:\n        write(s)\n        return write\n    except UnicodeEncodeError:\n        # Let's try the next approach...\n        pass\n\n    enc = locale.getpreferredencoding()\n    try:\n        Writer = codecs.getwriter(enc)\n    except LookupError:\n        Writer = codecs.getwriter(_DEFAULT_ENCODING)\n\n    f = Writer(fileobj)\n    write = f.write\n\n    try:\n        write(s)\n        return write\n    except UnicodeEncodeError:\n        Writer = codecs.getwriter('latin-1')\n        f = Writer(fileobj)\n        write = f.write\n\n    # If this doesn't work let the exception bubble up; I'm out of ideas\n    write(s)\n    return write", "response": "Write the supplied string with the given write function like\n    write with a fallback for the locale s preferred encoding in case\n    of UnicodeEncodeError."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting a message to the terminal using ANSI escape sequences.", "response": "def color_print(*args, **kwargs):\n    \"\"\"\n    Prints colors and styles to the terminal uses ANSI escape\n    sequences.\n\n    ::\n\n       color_print('This is the color ', 'default', 'GREEN', 'green')\n\n    Parameters\n    ----------\n    positional args : str\n        The positional arguments come in pairs (*msg*, *color*), where\n        *msg* is the string to display and *color* is the color to\n        display it in.\n\n        *color* is an ANSI terminal color name.  Must be one of:\n        black, red, green, brown, blue, magenta, cyan, lightgrey,\n        default, darkgrey, lightred, lightgreen, yellow, lightblue,\n        lightmagenta, lightcyan, white, or '' (the empty string).\n\n    file : writeable file-like object, optional\n        Where to write to.  Defaults to `sys.stdout`.  If file is not\n        a tty (as determined by calling its `isatty` member, if one\n        exists), no coloring will be included.\n\n    end : str, optional\n        The ending of the message.  Defaults to ``\\\\n``.  The end will\n        be printed after resetting any color or font state.\n    \"\"\"\n\n    file = kwargs.get('file', _get_stdout())\n\n    end = kwargs.get('end', '\\n')\n\n    write = file.write\n    if isatty(file) and options.console.use_color:\n        for i in range(0, len(args), 2):\n            msg = args[i]\n            if i + 1 == len(args):\n                color = ''\n            else:\n                color = args[i + 1]\n\n            if color:\n                msg = _color_text(msg, color)\n\n            # Some file objects support writing unicode sensibly on some Python\n            # versions; if this fails try creating a writer using the locale's\n            # preferred encoding. If that fails too give up.\n            if not six.PY3 and isinstance(msg, bytes):\n                msg = _decode_preferred_encoding(msg)\n\n            write = _write_with_fallback(msg, write, file)\n\n        write(end)\n    else:\n        for i in range(0, len(args), 2):\n            msg = args[i]\n            if not six.PY3 and isinstance(msg, bytes):\n                # Support decoding bytes to unicode on Python 2; use the\n                # preferred encoding for the locale (which is *sometimes*\n                # sensible)\n                msg = _decode_preferred_encoding(msg)\n            write(msg)\n        write(end)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef human_time(seconds):\n    units = [\n        ('y', 60 * 60 * 24 * 7 * 52),\n        ('w', 60 * 60 * 24 * 7),\n        ('d', 60 * 60 * 24),\n        ('h', 60 * 60),\n        ('m', 60),\n        ('s', 1),\n    ]\n\n    seconds = int(seconds)\n\n    if seconds < 60:\n        return '   {0:2d}s'.format(seconds)\n    for i in range(len(units) - 1):\n        unit1, limit1 = units[i]\n        unit2, limit2 = units[i + 1]\n        if seconds >= limit1:\n            return '{0:2d}{1}{2:2d}{3}'.format(\n                seconds // limit1, unit1,\n                (seconds % limit1) // limit2, unit2)\n    return '  ~inf'", "response": "Returns a human - friendly string that is always exactly 6 characters long."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef human_file_size(size):\n    suffixes = ' kMGTPEZY'\n    if size == 0:\n        num_scale = 0\n    else:\n        num_scale = int(math.floor(math.log(size) / math.log(1000)))\n    num_scale = max(num_scale, 0)\n    if num_scale >= len(suffixes):\n        suffix = '?'\n    else:\n        suffix = suffixes[num_scale]\n    num_scale = int(math.pow(1000, num_scale))\n    value = float(size) / num_scale\n    str_value = str(value)\n    if suffix == ' ':\n        if '.' in str_value:\n            str_value = str_value[:str_value.index('.')]\n    elif str_value[2] == '.':\n        str_value = str_value[:2]\n    else:\n        str_value = str_value[:3]\n    return \"{0:>3s}{1}\".format(str_value, suffix)", "response": "Returns a human - friendly string representation of the size of the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the current value of the current value.", "response": "def update(self, value=None):\n        \"\"\"\n        Update progress bar via the console or notebook accordingly.\n        \"\"\"\n\n        # Update self.value\n        if value is None:\n            value = self._current_value + 1\n        self._current_value = value\n\n        # Choose the appropriate environment\n        if self._ipython_widget:\n            try:\n                self._update_ipython_widget(value)\n            except RuntimeError:\n                pass\n        else:\n            self._update_console(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _update_console(self, value=None):\n\n        if self._total == 0:\n            frac = 1.0\n        else:\n            frac = float(value) / float(self._total)\n\n        file = self._file\n        write = file.write\n\n        if frac > 1:\n            bar_fill = int(self._bar_length)\n        else:\n            bar_fill = int(float(self._bar_length) * frac)\n        write('\\r|')\n        color_print('=' * bar_fill, 'blue', file=file, end='')\n        if bar_fill < self._bar_length:\n            color_print('>', 'green', file=file, end='')\n            write('-' * (self._bar_length - bar_fill - 1))\n        write('|')\n\n        if value >= self._total:\n            t = time.time() - self._start_time\n            prefix = '     '\n        elif value <= 0:\n            t = None\n            prefix = ''\n        else:\n            t = ((time.time() - self._start_time) * (1.0 - frac)) / frac\n            prefix = ' ETA '\n        write(' {0:>4s}/{1:>4s}'.format(\n            human_file_size(value),\n            self._human_total))\n        write(' ({0:>6s}%)'.format('{0:.2f}'.format(frac * 100.0)))\n        write(prefix)\n        if t is not None:\n            write(human_time(t))\n        self._file.flush()", "response": "Update the console with the given value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_ipython_widget(self, value=None):\n\n        # Create and display an empty progress bar widget,\n        # if none exists.\n        if not hasattr(self, '_widget'):\n            self._widget = create_progress_widget()\n            if in_ipython_frontend() and is_widgets_available():\n                display(self._widget)\n            self._widget.value = 0\n\n        # Calculate percent completion, and update progress bar\n        percent = (float(value)/self._total) * 100.0\n        self._widget.value = percent\n        self._widget.description =' ({0:>6s}%)'.format('{0:.2f}'.format(percent))", "response": "Update the IPython notebook widget with the given value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef map(cls, function, items, multiprocess=False, file=None):\n\n        results = []\n\n        if file is None:\n            file = _get_stdout()\n\n        with cls(len(items), file=file) as bar:\n            step_size = max(200, bar._bar_length)\n            steps = max(int(float(len(items)) / step_size), 1)\n            if not multiprocess:\n                for i, item in enumerate(items):\n                    results.append(function(item))\n                    if (i % steps) == 0:\n                        bar.update(i)\n            else:\n                p = multiprocessing.Pool()\n                for i, result in enumerate(\n                    p.imap_unordered(function, items, steps)):\n                    bar.update(i)\n                    results.append(result)\n                p.close()\n                p.join()\n\n        return results", "response": "Does a map operation while displaying a progress bar with percentage complete."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate count of the elements in a sequence of HyperLogLog objects.", "response": "def hll_count(expr, error_rate=0.01, splitter=None):\n    \"\"\"\n    Calculate HyperLogLog count\n\n    :param expr:\n    :param error_rate: error rate\n    :type error_rate: float\n    :param splitter: the splitter to split the column value\n    :return: sequence or scalar\n\n    :Example:\n\n    >>> df = DataFrame(pd.DataFrame({'a': np.random.randint(100000, size=100000)}))\n    >>> df.a.hll_count()\n    63270\n    >>> df.a.nunique()\n    63250\n    \"\"\"\n\n    # to make the class pickled right by the cloudpickle\n    with open(os.path.join(path, 'lib', 'hll.py')) as hll_file:\n        local = {}\n        six.exec_(hll_file.read(), local)\n        HyperLogLog = local['HyperLogLog']\n\n        return expr.agg(HyperLogLog, rtype=types.int64, args=(error_rate, splitter))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bloomfilter(collection, on, column, capacity=3000, error_rate=0.01):\n\n\n    if not isinstance(column, Column):\n        raise TypeError('bloomfilter can only filter on the column of a collection')\n\n    # to make the class pickled right by the cloudpickle\n    with open(os.path.join(path, 'lib', 'bloomfilter.py')) as bloomfilter_file:\n        local = {}\n        six.exec_(bloomfilter_file.read(), local)\n        BloomFilter = local['BloomFilter']\n\n        col_name = column.source_name or column.name\n\n        on_name = on.name if isinstance(on, SequenceExpr) else on\n        rand_name = '%s_%s'% (on_name, str(uuid.uuid4()).replace('-', '_'))\n        on_col = collection._get_field(on).rename(rand_name)\n        src_collection = collection\n        collection = collection[collection, on_col]\n\n        @output(src_collection.schema.names, src_collection.schema.types)\n        class Filter(object):\n            def __init__(self, resources):\n                table = resources[0]\n\n                bloom = BloomFilter(capacity, error_rate)\n                for row in table:\n                    bloom.add(str(getattr(row, col_name)))\n\n                self.bloom = bloom\n\n            def __call__(self, row):\n                if str(getattr(row, rand_name)) not in self.bloom:\n                    return\n                return row[:-1]\n\n        return collection.apply(Filter, axis=1, resources=[column.input, ])", "response": "Filter a collection by BloomFilter built by column"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate cumulative summation of a sequence expression.", "response": "def cumsum(expr, sort=None, ascending=True, unique=False,\n           preceding=None, following=None):\n    \"\"\"\n    Calculate cumulative summation of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :param unique: whether to eliminate duplicate entries\n    :param preceding: the start point of a window\n    :param following: the end point of a window\n    :return: calculated column\n    \"\"\"\n    if expr._data_type == types.boolean:\n        output_type = types.int64\n    else:\n        output_type = expr._data_type\n    return _cumulative_op(expr, CumSum, sort=sort, ascending=ascending,\n                          unique=unique, preceding=preceding,\n                          following=following, data_type=output_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cummax(expr, sort=None, ascending=True, unique=False,\n           preceding=None, following=None):\n    \"\"\"\n    Calculate cumulative maximum of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :param unique: whether to eliminate duplicate entries\n    :param preceding: the start point of a window\n    :param following: the end point of a window\n    :return: calculated column\n    \"\"\"\n    return _cumulative_op(expr, CumMax, sort=sort, ascending=ascending,\n                          unique=unique, preceding=preceding,\n                          following=following)", "response": "Calculate cumulative maximum of a sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cummin(expr, sort=None, ascending=True, unique=False,\n           preceding=None, following=None):\n    \"\"\"\n    Calculate cumulative minimum of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :param unique: whether to eliminate duplicate entries\n    :param preceding: the start point of a window\n    :param following: the end point of a window\n    :return: calculated column\n    \"\"\"\n    return _cumulative_op(expr, CumMin, sort=sort, ascending=ascending,\n                          unique=unique, preceding=preceding,\n                          following=following)", "response": "Calculate cumulative minimum of a sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate cumulative mean of a sequence expression.", "response": "def cummean(expr, sort=None, ascending=True, unique=False,\n            preceding=None, following=None):\n    \"\"\"\n    Calculate cumulative mean of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :param unique: whether to eliminate duplicate entries\n    :param preceding: the start point of a window\n    :param following: the end point of a window\n    :return: calculated column\n    \"\"\"\n    data_type = _stats_type(expr)\n    return _cumulative_op(expr, CumMean, sort=sort, ascending=ascending,\n                          unique=unique, preceding=preceding,\n                          following=following, data_type=data_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cummedian(expr, sort=None, ascending=True, unique=False,\n              preceding=None, following=None):\n    \"\"\"\n    Calculate cumulative median of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :param unique: whether to eliminate duplicate entries\n    :param preceding: the start point of a window\n    :param following: the end point of a window\n    :return: calculated column\n    \"\"\"\n    data_type = _stats_type(expr)\n    return _cumulative_op(expr, CumMedian, sort=sort, ascending=ascending,\n                          unique=unique, preceding=preceding,\n                          following=following, data_type=data_type)", "response": "Calculate cumulative median of a sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cumcount(expr, sort=None, ascending=True, unique=False,\n             preceding=None, following=None):\n    \"\"\"\n    Calculate cumulative count of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :param unique: whether to eliminate duplicate entries\n    :param preceding: the start point of a window\n    :param following: the end point of a window\n    :return: calculated column\n    \"\"\"\n    data_type = types.int64\n    return _cumulative_op(expr, CumCount, sort=sort, ascending=ascending,\n                          unique=unique, preceding=preceding,\n                          following=following, data_type=data_type)", "response": "Calculate the cumulative count of a sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cumstd(expr, sort=None, ascending=True, unique=False,\n           preceding=None, following=None):\n    \"\"\"\n    Calculate cumulative standard deviation of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :param unique: whether to eliminate duplicate entries\n    :param preceding: the start point of a window\n    :param following: the end point of a window\n    :return: calculated column\n    \"\"\"\n    data_type = _stats_type(expr)\n    return _cumulative_op(expr, CumStd, sort=sort, ascending=ascending,\n                          unique=unique, preceding=preceding,\n                          following=following, data_type=data_type)", "response": "Calculate cumulative standard deviation of a sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nth_value(expr, nth, skip_nulls=False, sort=None, ascending=True):\n    return _cumulative_op(expr, NthValue, data_type=expr._data_type, sort=sort,\n                          ascending=ascending, _nth=nth, _skip_nulls=skip_nulls)", "response": "Get nth value of a grouped and sorted expression."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the rank of a sequence expression.", "response": "def rank(expr, sort=None, ascending=True):\n    \"\"\"\n    Calculate rank of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :return: calculated column\n    \"\"\"\n    return _rank_op(expr, Rank, types.int64, sort=sort, ascending=ascending)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates dense rank of a sequence expression.", "response": "def dense_rank(expr, sort=None, ascending=True):\n    \"\"\"\n    Calculate dense rank of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :return: calculated column\n    \"\"\"\n    return _rank_op(expr, DenseRank, types.int64, sort=sort, ascending=ascending)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef percent_rank(expr, sort=None, ascending=True):\n    return _rank_op(expr, PercentRank, types.float64, sort=sort, ascending=ascending)", "response": "Calculate the percentage rank of a sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef row_number(expr, sort=None, ascending=True):\n    return _rank_op(expr, RowNumber, types.int64, sort=sort, ascending=ascending)", "response": "Calculate the row number of a sequence expression."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating quantile - based bin indices of every element of a grouped and sorted expression.", "response": "def qcut(expr, bins, labels=False, sort=None, ascending=True):\n    \"\"\"\n    Get quantile-based bin indices of every element of a grouped and sorted expression.\n    The indices of bins start from 0. If cuts are not of equal sizes, extra items will\n    be appended into the first group.\n\n    :param expr: expression for calculation\n    :param bins: number of bins\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :return: calculated column\n    \"\"\"\n    if labels is None or labels:\n        raise NotImplementedError('Showing bins or customizing labels not supported')\n    return _rank_op(expr, QCut, types.int64, sort=sort, ascending=ascending,\n                    _bins=bins)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate cumulative ratio of a sequence expression.", "response": "def cume_dist(expr, sort=None, ascending=True):\n    \"\"\"\n    Calculate cumulative ratio of a sequence expression.\n\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :return: calculated column\n    \"\"\"\n    return _rank_op(expr, CumeDist, types.float64, sort=sort, ascending=ascending)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lag(expr, offset, default=None, sort=None, ascending=True):\n    return _shift_op(expr, Lag, offset, default=default,\n                     sort=sort, ascending=ascending)", "response": "Calculate the value of the column that is at least offset rows prior to the current row."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the value of the column that is the first row in the current row.", "response": "def lead(expr, offset, default=None, sort=None, ascending=True):\n    \"\"\"\n    Get value in the row ``offset`` rows after to the current row.\n\n    :param offset: the offset value\n    :param default: default value for the function, when there are no rows satisfying the offset\n    :param expr: expression for calculation\n    :param sort: name of the sort column\n    :param ascending: whether to sort in ascending order\n    :return: calculated column\n    \"\"\"\n    return _shift_op(expr, Lead, offset, default=default,\n                     sort=sort, ascending=ascending)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the PMML text of the current model.", "response": "def get_model(self):\n        \"\"\"\n        Get PMML text of the current model. Note that model file obtained\n        via this method might be incomplete due to size limitations.\n        \"\"\"\n        url = self.resource()\n        params = {'data': ''}\n        resp = self._client.get(url, params=params)\n\n        return resp.text"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_response(resp):\n    host_id, msg, code = None, None, None\n    try:\n        content = resp.content\n        root = ET.fromstring(content)\n        code = root.find('./Code').text\n        msg = root.find('./Message').text\n        request_id = root.find('./RequestId').text\n        host_id = root.find('./HostId').text\n    except ETParseError:\n        request_id = resp.headers.get('x-odps-request-id', None)\n        if len(resp.content) > 0:\n            obj = json.loads(resp.text)\n            msg = obj['Message']\n            code = obj.get('Code')\n            host_id = obj.get('HostId')\n            if request_id is None:\n                request_id = obj.get('RequestId')\n        else:\n            return\n    clz = globals().get(code, ODPSError)\n    return clz(msg, request_id=request_id, code=code, host_id=host_id)", "response": "Parses the content of the response and returns an exception object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef throw_if_parsable(resp):\n    e = None\n    try:\n        e = parse_response(resp)\n    except:\n        # Error occurred during parsing the response. We ignore it and delegate\n        # the situation to caller to handle.\n        LOG.debug(utils.stringify_expt())\n\n    if e is not None:\n        raise e\n\n    if resp.status_code == 404:\n        raise NoSuchObject('No such object.')\n    else:\n        text = resp.text if six.PY3 else resp.content\n        if text:\n            raise ODPSError(text, code=str(resp.status_code))\n        else:\n            raise ODPSError(str(resp.status_code))", "response": "Try to parse the content of the response and raise an exception\nCTYPE if neccessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge_data(*data_frames, **kwargs):\n    from .specialized import build_merge_expr\n    from ..utils import ML_ARG_PREFIX\n\n    if len(data_frames) <= 1:\n        raise ValueError('Count of DataFrames should be at least 2.')\n\n    norm_data_pairs = []\n    df_tuple = collections.namedtuple('MergeTuple', 'df cols exclude')\n    for pair in data_frames:\n        if isinstance(pair, tuple):\n            if len(pair) == 2:\n                df, cols = pair\n                exclude = False\n            else:\n                df, cols, exclude = pair\n            if isinstance(cols, six.string_types):\n                cols = cols.split(',')\n        else:\n            df, cols, exclude = pair, None, False\n        norm_data_pairs.append(df_tuple(df, cols, exclude))\n\n    auto_rename = kwargs.get('auto_rename', False)\n\n    sel_cols_dict = dict((idx, tp.cols) for idx, tp in enumerate(norm_data_pairs) if tp.cols and not tp.exclude)\n    ex_cols_dict = dict((idx, tp.cols) for idx, tp in enumerate(norm_data_pairs) if tp.cols and tp.exclude)\n\n    merge_expr = build_merge_expr(len(norm_data_pairs))\n    arg_dict = dict(_params={'autoRenameCol': str(auto_rename)},\n                    selected_cols=sel_cols_dict, excluded_cols=ex_cols_dict)\n    for idx, dp in enumerate(norm_data_pairs):\n        arg_dict[ML_ARG_PREFIX + 'input%d' % (1 + idx)] = dp.df\n\n    out_df = merge_expr(register_expr=True, _exec_id=uuid.uuid4(), _output_name='output', **arg_dict)\n\n    out_df._ml_uplink = [dp.df for dp in norm_data_pairs]\n    out_df._perform_operation(op.MergeFieldsOperation(auto_rename, sel_cols_dict, ex_cols_dict))\n    out_df._rebuild_df_schema()\n    return out_df", "response": "This method merges two DataFrames into one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef exclude_fields(self, *args):\n        if not args:\n            raise ValueError(\"Field list cannot be None.\")\n        new_df = copy_df(self)\n        fields = _render_field_set(args)\n        self._assert_ml_fields_valid(*fields)\n        new_df._perform_operation(op.ExcludeFieldsOperation(fields))\n        return new_df", "response": "Returns a new DataFrame with only the specified fields excluded."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nselects one or more fields as feature fields.", "response": "def select_features(self, *args, **kwargs):\n        \"\"\"\n        Select one or more fields as feature fields.\n\n        :rtype: DataFrame\n        \"\"\"\n        if not args:\n            raise ValueError(\"Field list cannot be empty.\")\n        # generate selected set from args\n        augment = kwargs.get('add', False)\n        fields = _render_field_set(args)\n        self._assert_ml_fields_valid(*fields)\n        return _batch_change_roles(self, fields, FieldRole.FEATURE, augment)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef weight_field(self, f):\n        if f is None:\n            raise ValueError(\"Field name cannot be None.\")\n        self._assert_ml_fields_valid(f)\n        return _change_singleton_roles(self, {f: FieldRole.WEIGHT}, clear_feature=True)", "response": "Select one field as the weight field."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef label_field(self, f):\n        if f is None:\n            raise ValueError(\"Label field name cannot be None.\")\n        self._assert_ml_fields_valid(f)\n        return _change_singleton_roles(self, {_get_field_name(f): FieldRole.LABEL}, clear_feature=True)", "response": "Select one field as the label field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new DataFrame with fields that are continuous.", "response": "def continuous(self, *args):\n        \"\"\"\n        Set fields to be continuous.\n\n        :rtype: DataFrame\n\n        :Example:\n\n        >>> # Table schema is create table test(f1 double, f2 string)\n        >>> # Original continuity: f1=DISCRETE, f2=DISCRETE\n        >>> # Now we want to set ``f1`` and ``f2`` into continuous\n        >>> new_ds = df.continuous('f1 f2')\n        \"\"\"\n        new_df = copy_df(self)\n        fields = _render_field_set(args)\n        self._assert_ml_fields_valid(*fields)\n        new_df._perform_operation(op.FieldContinuityOperation(dict((_get_field_name(f), True) for f in fields)))\n        return new_df"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef discrete(self, *args):\n        new_df = copy_df(self)\n        fields = _render_field_set(args)\n        self._assert_ml_fields_valid(*fields)\n        new_df._perform_operation(op.FieldContinuityOperation(dict((_get_field_name(f), False) for f in fields)))\n        return new_df", "response": "Returns a new DataFrame with the same columns as the current DataFrame but with discrete fields set to True."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new DataFrame with the specified fields set to be key - value represented.", "response": "def key_value(self, *args, **kwargs):\n        \"\"\"\n        Set fields to be key-value represented.\n\n        :rtype: DataFrame\n\n        :Example:\n\n        >>> new_ds = df.key_value('f1 f2', kv=':', item=',')\n        \"\"\"\n        new_df = copy_df(self)\n        fields = _render_field_set(args)\n        self._assert_ml_fields_valid(*fields)\n        new_df._perform_operation(\n            op.FieldKVConfigOperation(dict((_get_field_name(f), KVConfig(**kwargs)) for f in fields)))\n        return new_df"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nerases key - value represented fields.", "response": "def erase_key_value(self, *args):\n        \"\"\"\n        Erase key-value represented fields.\n\n        :rtype: DataFrame\n\n        :Example:\n\n        >>> new_ds = df.erase_key_value('f1 f2')\n        \"\"\"\n        new_df = copy_df(self)\n        fields = _render_field_set(args)\n        self._assert_ml_fields_valid(*fields)\n        new_df._perform_operation(op.FieldKVConfigOperation(dict((_get_field_name(f), None) for f in fields)))\n        return new_df"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef roles(self, clear_features=True, **field_roles):\n        field_roles = dict((k, v.name if isinstance(v, SequenceExpr) else v)\n                           for k, v in six.iteritems(field_roles))\n        self._assert_ml_fields_valid(*list(six.itervalues(field_roles)))\n        field_roles = dict((_get_field_name(f), MLField.translate_role_name(role))\n                           for role, f in six.iteritems(field_roles))\n        if field_roles:\n            return _change_singleton_roles(self, field_roles, clear_features)\n        else:\n            return self", "response": "Set roles of the fields\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split(self, frac):\n        from .. import preprocess\n        split_obj = getattr(preprocess, '_Split')(fraction=frac)\n        return split_obj.transform(self)", "response": "Split the DataFrame into two DataFrames with certain ratio."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new DataFrame with appended ID field.", "response": "def append_id(self, id_col_name='append_id', cols=None):\n        \"\"\"\n        Append an ID column to current DataFrame.\n\n        :param str id_col_name: name of appended ID field.\n        :param str cols: fields contained in output. All fields by default.\n\n        :return: DataFrame with ID field\n        :rtype: DataFrame\n        \"\"\"\n        from .. import preprocess\n        if id_col_name in self.schema:\n            raise ValueError('ID column collides with existing columns.')\n        append_id_obj = getattr(preprocess, '_AppendID')(id_col=id_col_name, selected_cols=cols)\n        return append_id_obj.transform(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new dataframe with the same columns as this one but with the same values as the original.", "response": "def continuous(self):\n        \"\"\"\n        Set sequence to be continuous.\n\n        :rtype: Column\n\n        :Example:\n\n        >>> # Table schema is create table test(f1 double, f2 string)\n        >>> # Original continuity: f1=DISCRETE, f2=DISCRETE\n        >>> # Now we want to set ``f1`` and ``f2`` into continuous\n        >>> new_ds = df.continuous('f1 f2')\n        \"\"\"\n        field_name = self.name\n        new_df = copy_df(self)\n        new_df._perform_operation(op.FieldContinuityOperation({field_name: True}))\n        return new_df"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef discrete(self):\n        field_name = self.name\n        new_df = copy_df(self)\n        new_df._perform_operation(op.FieldContinuityOperation({field_name: False}))\n        return new_df", "response": "Returns a new dataframe with the values set to be discrete."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef key_value(self, **kwargs):\n        field_name = self.name\n        new_df = copy_df(self)\n        new_df._perform_operation(op.FieldKVConfigOperation({field_name: KVConfig(**kwargs)}))\n        return new_df", "response": "Returns a new Dataset with the values of the key - value fields in the same order as the original dataset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef erase_key_value(self):\n        field_name = self.name\n        new_df = copy_df(self)\n        new_df._perform_operation(op.FieldKVConfigOperation({field_name: None}))\n        return new_df", "response": "Erase key - value represented fields."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef role(self, role_name):\n        field_name = self.name\n        field_roles = {field_name: MLField.translate_role_name(role_name)}\n        if field_roles:\n            return _change_singleton_roles(self, field_roles, True)\n        else:\n            return self", "response": "Set the role of current column."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting the SQL query.", "response": "def execute(self, **kwargs):\n        \"\"\"\n        :param hints: settings for SQL, e.g. `odps.sql.mapper.split.size`\n        :type hints: dict\n        :param priority: instance priority, 9 as default\n        :type priority: int\n        :param running_cluster: cluster to run this instance\n        :return: execution result\n        :rtype: :class:`odps.df.backends.frame.ResultFrame`\n        \"\"\"\n        _wrapper = kwargs.pop('wrapper', None)\n\n        def wrapper(result):\n            self.__execution = result\n            if _wrapper is not None:\n                return _wrapper(result)\n            else:\n                return result\n\n        return self._handle_delay_call('execute', self, wrapper=wrapper, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compile(self):\n\n        from ..engines import get_default_engine\n\n        engine = get_default_engine(self)\n        return engine.compile(self)", "response": "Compile this expression into an ODPS SQL\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef persist(self, name, partitions=None, partition=None, lifecycle=None, project=None, **kwargs):\n        if lifecycle is None and options.lifecycle is not None:\n            lifecycle = \\\n                options.lifecycle if not name.startswith(TEMP_TABLE_PREFIX) \\\n                    else options.temp_lifecycle\n\n        return self._handle_delay_call('persist', self, name, partitions=partitions, partition=partition,\n                                       lifecycle=lifecycle, project=project, **kwargs)", "response": "Persist the execution into a new table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query(self, expr):\n        from .query import CollectionVisitor\n\n        if not isinstance(expr, six.string_types):\n            raise ValueError('expr must be a string')\n\n        frame = sys._getframe(2).f_locals\n        try:\n            env = frame.copy()\n        finally:\n            del frame\n\n        visitor = CollectionVisitor(self, env)\n        predicate = visitor.eval(expr)\n        return self.filter(predicate)", "response": "Query the data with a boolean expression."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfilter the data by predicates", "response": "def filter(self, *predicates):\n        \"\"\"\n        Filter the data by predicates\n\n        :param predicates: the conditions to filter\n        :return: new collection\n        :rtype: :class:`odps.df.expr.expressions.CollectionExpr`\n        \"\"\"\n        predicates = self._get_fields(predicates)\n\n        predicate = reduce(operator.and_, predicates)\n        return FilterCollectionExpr(self, predicate, _schema=self._schema)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_parts(self, predicate='', exclude=True):\n        source = self._source_data\n        if source is None:\n            raise ExpressionError('Can only filter on data sources.')\n\n        def _parse_partition_predicate(p):\n            if '=' not in p:\n                raise ExpressionError('Illegal partition predicate.')\n            field_name, field_value = [s.strip() for s in p.split('=', 1)]\n            if not hasattr(source, 'schema'):\n                raise ExpressionError('filter_partition can only be applied on ODPS DataFrames')\n            if field_name not in source.schema:\n                raise ExpressionError('Column `%s` not exists in input collection' % field_name)\n            if field_name not in source.schema._partition_schema:\n                raise ExpressionError('`%s` is not a partition column' % field_name)\n            part_col = self[field_name]\n            if field_value.startswith('\\'') or field_value.startswith('\\\"'):\n                encoding = 'string-escape' if six.PY2 else 'unicode-escape'\n                field_value = to_binary(field_value.strip('\"\\'')).decode(encoding)\n\n            if isinstance(part_col.data_type, types.Integer):\n                field_value = int(field_value)\n            elif isinstance(part_col.data_type, types.Float):\n                field_value = float(field_value)\n            return part_col == field_value\n\n        from ...models.partition import Partition\n        from ...types import PartitionSpec\n\n        if isinstance(predicate, Partition):\n            predicate = predicate.partition_spec\n        if isinstance(predicate, PartitionSpec):\n            predicate = ','.join(\"%s='%s'\" % (k, v) for k, v in six.iteritems(predicate.kv))\n\n        if isinstance(predicate, list):\n            predicate = '/'.join(str(s) for s in predicate)\n        elif not isinstance(predicate, six.string_types):\n            raise ExpressionError('Only accept string predicates.')\n\n        if not predicate:\n            predicate_obj = None\n        else:\n            part_formatter = lambda p: reduce(operator.and_, map(_parse_partition_predicate, p.split(',')))\n            predicate_obj = reduce(operator.or_, map(part_formatter, predicate.split('/')))\n\n        if not source.schema.partitions:\n            raise ExpressionError('No partition columns in the collection.')\n        if exclude:\n            columns = [c for c in self.schema if c.name not in source.schema._partition_schema]\n            new_schema = types.Schema.from_lists([c.name for c in columns], [c.type for c in columns])\n            return FilterPartitionCollectionExpr(self, predicate_obj, _schema=new_schema, _predicate_string=predicate)\n        else:\n            return self.filter(predicate_obj)", "response": "Filter the data by partition string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select(self, *fields, **kw):\n        if len(fields) == 1 and isinstance(fields[0], list):\n            fields = fields[0]\n        else:\n            fields = list(fields)\n        if kw:\n            def handle(it):\n                it = self._defunc(it)\n                if not isinstance(it, Expr):\n                    it = Scalar(it)\n                return it\n            fields.extend([handle(f).rename(new_name)\n                           for new_name, f in six.iteritems(kw)])\n\n        return self._project(fields)", "response": "Projection columns. Remember to avoid column names conflict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exclude(self, *fields):\n\n        if len(fields) == 1 and isinstance(fields[0], list):\n            exclude_fields = fields[0]\n        else:\n            exclude_fields = list(fields)\n\n        exclude_fields = [self._defunc(it) for it in exclude_fields]\n        exclude_fields = [field.name if not isinstance(field, six.string_types) else field\n                          for field in exclude_fields]\n\n        fields = [name for name in self._schema.names\n                  if name not in exclude_fields]\n\n        return self._project(fields)", "response": "Returns a new collection expression that includes only the specified fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the first n rows. Execute at once. :param n: :return: result frame :rtype: :class:`odps.df.backends.frame.ResultFrame`", "response": "def head(self, n=None, **kwargs):\n        \"\"\"\n        Return the first n rows. Execute at once.\n\n        :param n:\n        :return: result frame\n        :rtype: :class:`odps.df.backends.frame.ResultFrame`\n        \"\"\"\n        if n is None:\n            n = options.display.max_rows\n        return self._handle_delay_call('execute', self, head=n, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the last n rows. Execute at once. :param n: :return: result frame :rtype: :class:`odps.df.backends.frame.ResultFrame`", "response": "def tail(self, n=None, **kwargs):\n        \"\"\"\n        Return the last n rows. Execute at once.\n\n        :param n:\n        :return: result frame\n        :rtype: :class:`odps.df.backends.frame.ResultFrame`\n        \"\"\"\n        if n is None:\n            n = options.display.max_rows\n        return self._handle_delay_call('execute', self, tail=n, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_pandas(self, wrap=False, **kwargs):\n\n        try:\n            import pandas as pd\n        except ImportError:\n            raise DependencyNotInstalledError(\n                    'to_pandas requires `pandas` library')\n\n        def wrapper(result):\n            res = result.values\n            if wrap:\n                from .. import DataFrame\n                return DataFrame(res, schema=self.schema)\n            return res\n\n        return self.execute(wrapper=wrapper, **kwargs)", "response": "Convert the resultset to a pandas DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef view(self):\n        proxied = get_proxied_expr(self)\n        kv = dict((attr, getattr(proxied, attr)) for attr in get_attrs(proxied))\n        return type(proxied)(**kv)", "response": "Clone a same collection. useful for self - join."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_pandas(self, wrap=False, **kwargs):\n\n        try:\n            import pandas as pd\n        except ImportError:\n            raise DependencyNotInstalledError(\n                    'to_pandas requires for `pandas` library')\n\n        def wrapper(result):\n            df = result.values\n            if wrap:\n                from .. import DataFrame\n                df = DataFrame(df)\n            return df[self.name]\n\n        return self.execute(wrapper=wrapper, **kwargs)", "response": "Convert the object to a pandas Series. Execute at once."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncasts to a new data type.", "response": "def astype(self, data_type):\n        \"\"\"\n        Cast to a new data type.\n\n        :param data_type: the new data type\n        :return: casted sequence\n\n        :Example:\n\n        >>> df.id.astype('float')\n        \"\"\"\n\n        data_type = types.validate_data_type(data_type)\n\n        if data_type == self._data_type:\n            return self\n\n        attr_dict = dict()\n        attr_dict['_data_type'] = data_type\n        attr_dict['_source_data_type'] = self._source_data_type\n        attr_dict['_input'] = self\n\n        new_sequence = AsTypedSequenceExpr(**attr_dict)\n\n        return new_sequence"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iterate(self):\n        if not self._iter_local:\n            params = dict()\n            url = self.resource()\n            resp = self._client.get(url, params=params)\n\n            Users.parse(self._client, resp, obj=self)\n\n        for user in self.users:\n            yield user", "response": "Iterate over the users in this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef explode(expr, *args, **kwargs):\n    if not isinstance(expr, Column):\n        expr = to_collection(expr)[expr.name]\n\n    if isinstance(expr, SequenceExpr):\n        dtype = expr.data_type\n    else:\n        dtype = expr.value_type\n\n    func_name = 'EXPLODE'\n    if args and isinstance(args[0], (list, tuple, set)):\n        names = list(args[0])\n    else:\n        names = args\n    pos = kwargs.get('pos', False)\n    if isinstance(expr, ListSequenceExpr):\n        if pos:\n            func_name = 'POSEXPLODE'\n            typos = [df_types.int64, dtype.value_type]\n            if not names:\n                names = [expr.name + '_pos', expr.name]\n            if len(names) == 1:\n                names = [names[0] + '_pos', names[0]]\n            if len(names) != 2:\n                raise ValueError(\"The length of parameter 'names' should be exactly 1.\")\n        else:\n            typos = [dtype.value_type]\n            if not names:\n                names = [expr.name]\n            if len(names) != 1:\n                raise ValueError(\"The length of parameter 'names' should be exactly 1.\")\n    elif isinstance(expr, DictSequenceExpr):\n        if pos:\n            raise ValueError('Cannot support explosion with pos on dicts.')\n        typos = [dtype.key_type, dtype.value_type]\n        if not names:\n            names = [expr.name + '_key', expr.name + '_value']\n        if len(names) != 2:\n            raise ValueError(\"The length of parameter 'names' should be exactly 2.\")\n    else:\n        raise ValueError('Cannot explode expression with type %s' % type(expr).__name__)\n    schema = Schema.from_lists(names, typos)\n    return RowAppliedCollectionExpr(_input=expr.input, _func=func_name, _schema=schema,\n                                    _fields=[expr], _keep_nulls=kwargs.get('keep_nulls', False))", "response": "Expands list or dict data into multiple rows\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking whether certain value is in the inspected list", "response": "def _contains(expr, value):\n    \"\"\"\n    Check whether certain value is in the inspected list\n\n    :param expr: list sequence / scalar\n    :param value: value to inspect\n    :return:\n    \"\"\"\n    return composite_op(expr, ListContains, df_types.boolean, _value=_scalar(value))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _keys(expr):\n    if isinstance(expr, SequenceExpr):\n        dtype = expr.data_type\n    else:\n        dtype = expr.value_type\n    return composite_op(expr, DictKeys, df_types.List(dtype.key_type))", "response": "Retrieve keys of a dict sequence or scalar"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve values of a dict sequence or scalar", "response": "def _values(expr):\n    \"\"\"\n    Retrieve values of a dict\n\n    :param expr: dict sequence / scalar\n    :return:\n    \"\"\"\n    if isinstance(expr, SequenceExpr):\n        dtype = expr.data_type\n    else:\n        dtype = expr.value_type\n    return composite_op(expr, DictValues, df_types.List(dtype.value_type))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute mean squared error of a predicted DataFrame.", "response": "def mean_squared_error(df, col_true, col_pred=None):\n    \"\"\"\n    Compute mean squared error of a predicted DataFrame.\n\n    Note that this method will trigger the defined flow to execute.\n\n    :param df: predicted data frame\n    :type df: DataFrame\n    :param col_true: column name of true value\n    :type col_true: str\n    :param col_true: column name of predicted value, 'prediction_score' by default.\n    :type col_pred: str\n    :return: Mean squared error\n    :rtype: float\n    \"\"\"\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['mse']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mean_absolute_error(df, col_true, col_pred=None):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['mae']", "response": "Compute mean absolute error of a predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute mean absolute percentage error of a predicted DataFrame.", "response": "def mean_absolute_percentage_error(df, col_true, col_pred=None):\n    \"\"\"\n    Compute mean absolute percentage error of a predicted DataFrame.\n\n    Note that this method will trigger the defined flow to execute.\n\n    :param df: predicted data frame\n    :type df: DataFrame\n    :param col_true: column name of true value\n    :type col_true: str\n    :param col_true: column name of predicted value, 'prediction_score' by default.\n    :type col_pred: str\n    :return: Mean absolute percentage error\n    :rtype: float\n    \"\"\"\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['mape']"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes total sum of squares of a predicted DataFrame.", "response": "def total_sum_of_squares(df, col_true, col_pred=None):\n    \"\"\"\n    Compute total sum of squares (SST) of a predicted DataFrame.\n\n    Note that this method will trigger the defined flow to execute.\n\n    :param df: predicted data frame\n    :type df: DataFrame\n    :param col_true: column name of true value\n    :type col_true: str\n    :param col_true: column name of predicted value, 'prediction_score' by default.\n    :type col_pred: str\n    :return: Mean absolute percentage error\n    :rtype: float\n    \"\"\"\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['sst']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef explained_sum_of_squares(df, col_true, col_pred=None):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['sse']", "response": "Compute the explained sum of squares of a predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef r2_score(df, col_true, col_pred=None):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['r2']", "response": "Compute determination coefficient of a predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef multi_corr(df, col_true, col_pred=None):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['r']", "response": "Compute multiple correlation coefficient of a predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the rooted mean squared error of a predicted DataFrame.", "response": "def rooted_mean_squared_error(df, col_true, col_pred=None):\n    \"\"\"\n    Compute rooted mean squared error (RMSE) of a predicted DataFrame.\n\n    Note that this method will trigger the defined flow to execute.\n\n    :param df: predicted data frame\n    :type df: DataFrame\n    :param col_true: column name of true value\n    :type col_true: str\n    :param col_true: column name of predicted value, 'prediction_score' by default.\n    :type col_pred: str\n    :return: Mean absolute percentage error\n    :rtype: float\n    \"\"\"\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['rmse']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mean_absolute_deviation(df, col_true, col_pred=None):\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['mad']", "response": "Compute mean absolute deviation of a predicted DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing histogram of residuals of a predicted DataFrame.", "response": "def residual_histogram(df, col_true, col_pred=None):\n    \"\"\"\n    Compute histogram of residuals of a predicted DataFrame.\n\n    Note that this method will trigger the defined flow to execute.\n\n    :param df: predicted data frame\n    :type df: DataFrame\n    :param col_true: column name of true value\n    :type col_true: str\n    :param col_true: column name of predicted value, 'prediction_score' by default.\n    :type col_pred: str\n    :return: histograms for every columns, containing histograms and bins.\n    \"\"\"\n    if not col_pred:\n        col_pred = get_field_name_by_role(df, FieldRole.PREDICTED_VALUE)\n    return _run_evaluation_node(df, col_true, col_pred)['hist']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef put_info(self, key, value):\n        return self.instance.put_task_info(self.name, key, value)", "response": "Put associated information of the task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending an unsigned 32 - bit integer to the internal buffer in little - endian byte order.", "response": "def append_little_endian32(self, unsigned_value):\n        \"\"\"Appends an unsigned 32-bit integer to the internal buffer,\n        in little-endian byte order.\n        \"\"\"\n        if not 0 <= unsigned_value <= wire_format.UINT32_MAX:\n            raise errors.EncodeError(\n                'Unsigned 32-bit out of range: %d' % unsigned_value)\n        self.append_raw_bytes(struct.pack(\n            wire_format.FORMAT_UINT32_LITTLE_ENDIAN, unsigned_value))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef append_little_endian64(self, unsigned_value):\n        if not 0 <= unsigned_value <= wire_format.UINT64_MAX:\n            raise errors.EncodeError(\n                'Unsigned 64-bit out of range: %d' % unsigned_value)\n        self.append_raw_bytes(struct.pack(\n            wire_format.FORMAT_UINT64_LITTLE_ENDIAN, unsigned_value))", "response": "Appends an unsigned 64 - bit integer to the internal buffer in little - endian byte order."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending a signed 32 - bit integer to the internal buffer encoded as a varint.", "response": "def append_varint32(self, value):\n        \"\"\"Appends a signed 32-bit integer to the internal buffer,\n        encoded as a varint.  (Note that a negative varint32 will\n        always require 10 bytes of space.)\n        \"\"\"\n        if not wire_format.INT32_MIN <= value <= wire_format.INT32_MAX:\n            raise errors.EncodeError('Value out of range: %d' % value)\n        self.append_varint64(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef append_var_uint32(self, value):\n        if not 0 <= value <= wire_format.UINT32_MAX:\n            raise errors.EncodeError('Value out of range: %d' % value)\n        self.append_var_uint64(value)", "response": "Appends an unsigned 32 - bit integer to the internal buffer encoded as a varint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nappend a signed 64 - bit integer to the internal buffer encoded as a varint.", "response": "def append_varint64(self, value):\n        \"\"\"Appends a signed 64-bit integer to the internal buffer,\n        encoded as a varint.\n        \"\"\"\n        if not wire_format.INT64_MIN <= value <= wire_format.INT64_MAX:\n            raise errors.EncodeError('Value out of range: %d' % value)\n        if value < 0:\n            value += (1 << 64)\n        self.append_var_uint64(value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append_var_uint64(self, unsigned_value):\n        if not 0 <= unsigned_value <= wire_format.UINT64_MAX:\n            raise errors.EncodeError('Value out of range: %d' % unsigned_value)\n        while True:\n            bits = unsigned_value & 0x7f\n            unsigned_value >>= 7\n            if unsigned_value:\n                bits |= 0x80\n            self._buffer.append(bits)\n            if not unsigned_value:\n                break", "response": "Appends an unsigned 64 - bit integer to the internal buffer encoded as a varint."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef groupby(expr, by, *bys):\n\n    if not isinstance(by, list):\n        by = [by, ]\n    if len(bys) > 0:\n        by = by + list(bys)\n    return GroupBy(_input=expr, _by=by)", "response": "Group collection by a series of sequences."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new expression that counts the number of unique values in the sequence.", "response": "def value_counts(expr, sort=True, ascending=False, dropna=False):\n    \"\"\"\n    Return object containing counts of unique values.\n\n    The resulting object will be in descending order so that the first element is the most frequently-occuring\n    element. Exclude NA values by default\n\n    :param expr: sequence\n    :param sort: if sort\n    :type sort: bool\n    :param dropna: Don\u2019t include counts of None, default False\n    :return: collection with two columns\n    :rtype: :class:`odps.df.expr.expressions.CollectionExpr`\n    \"\"\"\n\n    names = [expr.name, 'count']\n    typos = [expr.dtype, types.int64]\n    return ValueCounts(_input=expr, _schema=Schema.from_lists(names, typos),\n                       _sort=sort, _ascending=ascending, _dropna=dropna)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_hash(self, initial, capacity, error):\n        self.hash = 0\n        self.hashbits, self.num_hashes = self._optimal_size(capacity, error)\n\n        if len(initial):\n            if type(initial) == str:\n                self.add(initial)\n            else:\n                for t in initial:\n                    self.add(t)", "response": "Creates a new hash for the current set of resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _hashes(self, item):\n        item = self._binary(item)\n\n        m = hashlib.sha1()\n        m.update(item)\n        digits = m.hexdigest()\n\n        # Add another 160 bits for every 8 (20-bit long) hashes we need\n        for i in range(int(self.num_hashes // 8)):\n            m.update(self._binary(str(i)))\n            digits += m.hexdigest()\n\n        hashes = [int(digits[i*5:i*5+5], 16) % self.hashbits for i in range(self.num_hashes)]\n        return hashes", "response": "Create the hash functions for the given item."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the optimal size of the filter array and the number of hash functions given a maximum number of enteries and the desired error rate.", "response": "def _optimal_size(self, capacity, error):\n        \"\"\"Calculates minimum number of bits in filter array and\n        number of hash functions given a number of enteries (maximum)\n        and the desired error rate (falese positives).\n\n        Example:\n            m, k = self._optimal_size(3000, 0.01)   # m=28756, k=7\n        \"\"\"\n        m = math.ceil((capacity * math.log(error)) / math.log(1.0 / (math.pow(2.0, math.log(2.0)))))\n        k = math.ceil(math.log(2.0) * m / capacity)\n        return int(m), int(k)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an item to the filter. Cannot be removed later!", "response": "def add(self, item):\n        \"Add an item (string) to the filter. Cannot be removed later!\"\n        for pos in self._hashes(item):\n            self.hash |= (2 ** pos)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef join(left, right, on=None, how='inner', suffixes=('_x', '_y'), mapjoin=False):\n    if on is None and not mapjoin:\n        on = [name for name in left.schema.names if name in right.schema._name_indexes]\n\n    if isinstance(suffixes, (tuple, list)) and len(suffixes) == 2:\n        left_suffix, right_suffix = suffixes\n    else:\n        raise ValueError('suffixes must be a tuple or list with two elements, got %s' % suffixes)\n    if not isinstance(on, list):\n        on = [on, ]\n    for i in range(len(on)):\n        it = on[i]\n        if inspect.isfunction(it):\n            on[i] = it(left, right)\n\n    left, right = _make_different_sources(left, right, on)\n\n    try:\n        return _join_dict[how.upper()](_lhs=left, _rhs=right, _predicate=on, _left_suffix=left_suffix,\n                                       _right_suffix=right_suffix, _mapjoin=mapjoin)\n    except KeyError:\n        return JoinCollectionExpr(_lhs=left, _rhs=right, _predicate=on, _how=how, _left_suffix=left_suffix,\n                                  _right_suffix=right_suffix, _mapjoin=mapjoin)", "response": "Join two collections.\n\n    If `on` is not specified, we will find the common fields of the left and right collection.\n    `suffixes` means that if column names conflict, the suffixes will be added automatically.\n    For example, both left and right has a field named `col`,\n    there will be col_x, and col_y in the joined collection.\n\n    :param left: left collection\n    :param right: right collection\n    :param on: fields to join on\n    :param how: 'inner', 'left', 'right', or 'outer'\n    :param suffixes: when name conflict, the suffix will be added to both columns.\n    :param mapjoin: set use mapjoin or not, default value False.\n    :return: collection\n\n    :Example:\n\n    >>> df.dtypes.names\n    ['name', 'id']\n    >>> df2.dtypes.names\n    ['name', 'id1']\n    >>> df.join(df2)\n    >>> df.join(df2, on='name')\n    >>> df.join(df2, on=('id', 'id1'))\n    >>> df.join(df2, on=['name', ('id', 'id1')])\n    >>> df.join(df2, on=[df.name == df2.name, df.id == df2.id1])\n    >>> df.join(df2, mapjoin=False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef inner_join(left, right, on=None, suffixes=('_x', '_y'), mapjoin=False):\n\n    return join(left, right, on, suffixes=suffixes, mapjoin=mapjoin)", "response": "Inner join two collections."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nleaves join two collections.", "response": "def left_join(left, right, on=None, suffixes=('_x', '_y'), mapjoin=False, merge_columns=None):\n    \"\"\"\n    Left join two collections.\n\n    If `on` is not specified, we will find the common fields of the left and right collection.\n    `suffixes` means that if column names conflict, the suffixes will be added automatically.\n    For example, both left and right has a field named `col`,\n    there will be col_x, and col_y in the joined collection.\n\n    :param left: left collection\n    :param right: right collection\n    :param on: fields to join on\n    :param suffixes: when name conflict, the suffixes will be added to both columns.\n    :param mapjoin: set use mapjoin or not, default value False.\n    :param merge_columns: whether to merge columns with the same name into one column without suffix.\n                          If the value is True, columns in the predicate with same names will be merged,\n                          with non-null value. If the value is 'left' or 'right', the values of predicates\n                          on the left / right collection will be taken. You can also pass a dictionary to\n                          describe the behavior of each column, such as { 'a': 'auto', 'b': 'left' }.\n    :return: collection\n\n    :Example:\n\n    >>> df.dtypes.names\n    ['name', 'id']\n    >>> df2.dtypes.names\n    ['name', 'id1']\n    >>> df.left_join(df2)\n    >>> df.left_join(df2, on='name')\n    >>> df.left_join(df2, on=('id', 'id1'))\n    >>> df.left_join(df2, on=['name', ('id', 'id1')])\n    >>> df.left_join(df2, on=[df.name == df2.name, df.id == df2.id1])\n    \"\"\"\n    joined = join(left, right, on, how='left', suffixes=suffixes, mapjoin=mapjoin)\n    return joined._merge_joined_fields(merge_columns)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef concat(left, rights, distinct=False, axis=0):\n    from ..utils import to_collection\n\n    if isinstance(rights, Node):\n        rights = [rights, ]\n    if not rights:\n        raise ValueError('At least one DataFrame should be provided.')\n\n    if axis == 0:\n        for right in rights:\n            left = union(left, right, distinct=distinct)\n        return left\n    else:\n        rights = [to_collection(r) for r in rights]\n\n    ConcatCollectionExpr.validate_input(left, *rights)\n\n    if hasattr(left, '_xflow_concat'):\n        return left._xflow_concat(rights)\n    else:\n        return __horz_concat(left, rights)", "response": "Concat collections.\n\n    :param left: left collection\n    :param rights: right collections, can be a DataFrame object or a list of DataFrames\n    :param distinct: whether to remove duplicate entries. only available when axis == 0\n    :param axis: when axis == 0, the DataFrames are merged vertically, otherwise horizontally.\n    :return: collection\n\n    Note that axis==1 can only be used under Pandas DataFrames or XFlow.\n\n    :Example:\n    >>> df['name', 'id'].concat(df2['score'], axis=1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndrop data from a DataFrame.", "response": "def _drop(expr, data, axis=0, columns=None):\n    \"\"\"\n    Drop data from a DataFrame.\n\n    :param expr: collection to drop data from\n    :param data: data to be removed\n    :param axis: 0 for deleting rows, 1 for columns.\n    :param columns: columns of data to select, only useful when axis == 0\n    :return: collection\n\n    :Example:\n    >>> import pandas as pd\n    >>> df1 = DataFrame(pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6], 'c': [7, 8, 9]}))\n    >>> df2 = DataFrame(pd.DataFrame({'a': [2, 3], 'b': [5, 7]}))\n    >>> df1.drop(df2)\n       a  b  c\n    0  1  4  7\n    1  3  6  9\n    >>> df1.drop(df2, columns='a')\n       a  b  c\n    0  1  4  7\n    >>> df1.drop(['a'], axis=1)\n       b  c\n    0  4  7\n    1  5  8\n    2  6  9\n    >>> df1.drop(df2, axis=1)\n       c\n    0  7\n    1  8\n    2  9\n    \"\"\"\n    from ..utils import to_collection\n    expr = to_collection(expr)\n\n    if axis == 0:\n        if not isinstance(data, (CollectionExpr, SequenceExpr)):\n            raise ExpressionError('data should be a collection or sequence when axis == 1.')\n\n        data = to_collection(data)\n        if columns is None:\n            columns = [n for n in data.schema.names]\n        if isinstance(columns, six.string_types):\n            columns = [columns, ]\n\n        data = data.select(*columns).distinct()\n\n        drop_predicates = [data[n].isnull() for n in data.schema.names]\n        return expr.left_join(data, on=columns, suffixes=('', '_dp')).filter(*drop_predicates) \\\n            .select(*expr.schema.names)\n    else:\n        if isinstance(data, (CollectionExpr, SequenceExpr)):\n            data = to_collection(data).schema.names\n        return expr.exclude(data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexcluding data from a collection.", "response": "def setdiff(left, *rights, **kwargs):\n    \"\"\"\n    Exclude data from a collection, like `except` clause in SQL. All collections involved should\n    have same schema.\n\n    :param left: collection to drop data from\n    :param rights: collection or list of collections\n    :param distinct: whether to preserve duplicate entries\n    :return: collection\n\n    :Examples:\n    >>> import pandas as pd\n    >>> df1 = DataFrame(pd.DataFrame({'a': [1, 2, 3, 3, 3], 'b': [1, 2, 3, 3, 3]}))\n    >>> df2 = DataFrame(pd.DataFrame({'a': [1, 3], 'b': [1, 3]}))\n    >>> df1.setdiff(df2)\n       a  b\n    0  2  2\n    1  3  3\n    2  3  3\n    >>> df1.setdiff(df2, distinct=True)\n       a  b\n    0  2  2\n    \"\"\"\n    import time\n    from ..utils import output\n\n    distinct = kwargs.get('distinct', False)\n\n    if isinstance(rights[0], list):\n        rights = rights[0]\n\n    cols = [n for n in left.schema.names]\n    types = [n for n in left.schema.types]\n\n    counter_col_name = 'exc_counter_%d' % int(time.time())\n    left = left[left, Scalar(1).rename(counter_col_name)]\n    rights = [r[r, Scalar(-1).rename(counter_col_name)] for r in rights]\n\n    unioned = left\n    for r in rights:\n        unioned = unioned.union(r)\n\n    if distinct:\n        aggregated = unioned.groupby(*cols).agg(**{counter_col_name: unioned[counter_col_name].min()})\n        return aggregated.filter(aggregated[counter_col_name] == 1).select(*cols)\n    else:\n        aggregated = unioned.groupby(*cols).agg(**{counter_col_name: unioned[counter_col_name].sum()})\n\n        @output(cols, types)\n        def exploder(row):\n            import sys\n            irange = xrange if sys.version_info[0] < 3 else range\n            for _ in irange(getattr(row, counter_col_name)):\n                yield row[:-1]\n\n        return aggregated.map_reduce(mapper=exploder).select(*cols)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef intersect(left, *rights, **kwargs):\n    import time\n    from ..utils import output\n\n    distinct = kwargs.get('distinct', False)\n\n    if isinstance(rights[0], list):\n        rights = rights[0]\n\n    cols = [n for n in left.schema.names]\n    types = [n for n in left.schema.types]\n\n    collections = (left, ) + rights\n\n    idx_col_name = 'idx_%d' % int(time.time())\n    counter_col_name = 'exc_counter_%d' % int(time.time())\n\n    collections = [c[c, Scalar(idx).rename(idx_col_name)] for idx, c in enumerate(collections)]\n\n    unioned = reduce(lambda a, b: a.union(b), collections)\n    src_agg = unioned.groupby(*(cols + [idx_col_name])) \\\n        .agg(**{counter_col_name: unioned.count()})\n\n    aggregators = {\n        idx_col_name: src_agg[idx_col_name].nunique(),\n        counter_col_name: src_agg[counter_col_name].min(),\n    }\n    final_agg = src_agg.groupby(*cols).agg(**aggregators)\n    final_agg = final_agg.filter(final_agg[idx_col_name] == len(collections))\n\n    if distinct:\n        return final_agg.filter(final_agg[counter_col_name] > 0).select(*cols)\n    else:\n        @output(cols, types)\n        def exploder(row):\n            import sys\n            irange = xrange if sys.version_info[0] < 3 else range\n            for _ in irange(getattr(row, counter_col_name)):\n                yield row[:-2]\n\n        return final_agg.map_reduce(mapper=exploder).select(*cols)", "response": "Calculate intersection among datasets"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef roles_required(*required_rolenames):\n    def decorator(method):\n        @functools.wraps(method)\n        def wrapper(*args, **kwargs):\n            role_set = set([str(n) for n in required_rolenames])\n            _verify_and_add_jwt()\n            try:\n                MissingRoleError.require_condition(\n                    current_rolenames().issuperset(role_set),\n                    \"This endpoint requires all the following roles: {}\",\n                    [', '.join(role_set)],\n                )\n                return method(*args, **kwargs)\n            finally:\n                remove_jwt_data_from_app_context()\n        return wrapper\n    return decorator", "response": "Decorator that ensures that all uses accessing the route have all the required roles."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef roles_accepted(*accepted_rolenames):\n    def decorator(method):\n        @functools.wraps(method)\n        def wrapper(*args, **kwargs):\n            role_set = set([str(n) for n in accepted_rolenames])\n            _verify_and_add_jwt()\n            try:\n                MissingRoleError.require_condition(\n                    not current_rolenames().isdisjoint(role_set),\n                    \"This endpoint requires one of the following roles: {}\",\n                    [', '.join(role_set)],\n                )\n                return method(*args, **kwargs)\n            finally:\n                remove_jwt_data_from_app_context()\n        return wrapper\n    return decorator", "response": "This decorator ensures that any uses accessing the route have one of the required roles."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the Praetorian extension with the given flask app and user class.", "response": "def init_app(self, app, user_class, is_blacklisted=None):\n        \"\"\"\n        Initializes the Praetorian extension\n\n        :param: app:            The flask app to bind this extension to\n        :param: user_class:     The class used to interact with user data\n        :param: is_blacklisted: A method that may optionally be used to\n                                check the token against a blacklist when\n                                access or refresh is requested\n                                Should take the jti for the token to check\n                                as a single argument. Returns True if\n                                the jti is blacklisted, False otherwise.\n                                By default, always returns False.\n        \"\"\"\n        PraetorianError.require_condition(\n            app.config.get('SECRET_KEY') is not None,\n            \"There must be a SECRET_KEY app config setting set\",\n        )\n\n        possible_schemes = [\n            'argon2',\n            'bcrypt',\n            'pbkdf2_sha512',\n        ]\n        self.pwd_ctx = CryptContext(\n            default='pbkdf2_sha512',\n            schemes=possible_schemes + ['plaintext'],\n            deprecated=[],\n        )\n\n        self.hash_scheme = app.config.get('PRAETORIAN_HASH_SCHEME')\n        valid_schemes = self.pwd_ctx.schemes()\n        PraetorianError.require_condition(\n            self.hash_scheme in valid_schemes or self.hash_scheme is None,\n            \"If {} is set, it must be one of the following schemes: {}\",\n            'PRAETORIAN_HASH_SCHEME',\n            valid_schemes,\n        )\n\n        self.user_class = self._validate_user_class(user_class)\n        self.is_blacklisted = is_blacklisted or (lambda t: False)\n\n        self.encode_key = app.config['SECRET_KEY']\n        self.allowed_algorithms = app.config.get(\n            'JWT_ALLOWED_ALGORITHMS',\n            DEFAULT_JWT_ALLOWED_ALGORITHMS,\n        )\n        self.encode_algorithm = app.config.get(\n            'JWT_ALGORITHM',\n            DEFAULT_JWT_ALGORITHM,\n        )\n        self.access_lifespan = pendulum.Duration(**app.config.get(\n            'JWT_ACCESS_LIFESPAN',\n            DEFAULT_JWT_ACCESS_LIFESPAN,\n        ))\n        self.refresh_lifespan = pendulum.Duration(**app.config.get(\n            'JWT_REFRESH_LIFESPAN',\n            DEFAULT_JWT_REFRESH_LIFESPAN,\n        ))\n        self.header_name = app.config.get(\n            'JWT_HEADER_NAME',\n            DEFAULT_JWT_HEADER_NAME,\n        )\n        self.header_type = app.config.get(\n            'JWT_HEADER_TYPE',\n            DEFAULT_JWT_HEADER_TYPE,\n        )\n        self.user_class_validation_method = app.config.get(\n            'USER_CLASS_VALIDATION_METHOD',\n            DEFAULT_USER_CLASS_VALIDATION_METHOD,\n        )\n\n        if not app.config.get('DISABLE_PRAETORIAN_ERROR_HANDLER'):\n            app.register_error_handler(\n                PraetorianError,\n                PraetorianError.build_error_handler(),\n            )\n\n        self.is_testing = app.config.get('TESTING', False)\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions['praetorian'] = self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the supplied user_class to make sure that it has the necessary methods necessary to function correctly.", "response": "def _validate_user_class(cls, user_class):\n        \"\"\"\n        Validates the supplied user_class to make sure that it has the\n        class methods necessary to function correctly.\n\n        Requirements:\n\n        - ``lookup`` method. Accepts a string parameter, returns instance\n        - ``identify`` method. Accepts an identity parameter, returns instance\n        \"\"\"\n        PraetorianError.require_condition(\n            getattr(user_class, 'lookup', None) is not None,\n            textwrap.dedent(\"\"\"\n                The user_class must have a lookup class method:\n                user_class.lookup(<str>) -> <user instance>\n            \"\"\"),\n        )\n        PraetorianError.require_condition(\n            getattr(user_class, 'identify', None) is not None,\n            textwrap.dedent(\"\"\"\n                The user_class must have an identify class method:\n                user_class.identify(<identity>) -> <user instance>\n            \"\"\"),\n        )\n        # TODO: Figure out how to check for an identity property\n        return user_class"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nverify that a username matches the stored password and returns a User instance.", "response": "def authenticate(self, username, password):\n        \"\"\"\n        Verifies that a password matches the stored password for that username.\n        If verification passes, the matching user instance is returned\n        \"\"\"\n        PraetorianError.require_condition(\n            self.user_class is not None,\n            \"Praetorian must be initialized before this method is available\",\n        )\n        user = self.user_class.lookup(username)\n        MissingUserError.require_condition(\n            user is not None,\n            'Could not find the requested user',\n        )\n        AuthenticationError.require_condition(\n            self._verify_password(password, user.password),\n            'The password is incorrect',\n        )\n        return user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _verify_password(self, raw_password, hashed_password):\n        PraetorianError.require_condition(\n            self.pwd_ctx is not None,\n            \"Praetorian must be initialized before this method is available\",\n        )\n        return self.pwd_ctx.verify(raw_password, hashed_password)", "response": "Verifies that a plaintext password matches the hashed version of that password."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencrypting a plaintext password using the stored passlib password context", "response": "def encrypt_password(self, raw_password):\n        \"\"\"\n        Encrypts a plaintext password using the stored passlib password context\n        \"\"\"\n        PraetorianError.require_condition(\n            self.pwd_ctx is not None,\n            \"Praetorian must be initialized before this method is available\",\n        )\n        return self.pwd_ctx.encrypt(raw_password, scheme=self.hash_scheme)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef error_handler(self, error):\n        warnings.warn(\n            \"\"\"\n            error_handler is deprecated.\n            Use FlaskBuzz.build_error_handler instead\n            \"\"\",\n            warnings.DeprecationWarning,\n        )\n        return error.jsonify(), error.status_code, error.headers", "response": "Provides a Flask error handler that returns a dict of the error and the status code and headers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_user(self, user):\n        MissingUserError.require_condition(\n            user is not None,\n            'Could not find the requested user',\n        )\n        user_validate_method = getattr(\n            user, self.user_class_validation_method, None\n        )\n        if user_validate_method is None:\n            return\n        InvalidUserError.require_condition(\n            user_validate_method(),\n            \"The user is not valid or has had access revoked\",\n        )", "response": "Checks to make sure that a user is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encode_jwt_token(\n            self, user,\n            override_access_lifespan=None, override_refresh_lifespan=None,\n            **custom_claims\n    ):\n        \"\"\"\n        Encodes user data into a jwt token that can be used for authorization\n        at protected endpoints\n\n        :param: override_access_lifespan:  Override's the instance's access\n                                           lifespan to set a custom duration\n                                           after which the new token's\n                                           accessability will expire. May not\n                                           exceed the refresh_lifespan\n        :param: override_refresh_lifespan: Override's the instance's refresh\n                                           lifespan to set a custom duration\n                                           after which the new token's\n                                           refreshability will expire.\n        :param: custom_claims:             Additional claims that should\n                                           be packed in the payload. Note that\n                                           any claims supplied here must be\n                                           JSON compatible types\n        \"\"\"\n        ClaimCollisionError.require_condition(\n            set(custom_claims.keys()).isdisjoint(RESERVED_CLAIMS),\n            \"The custom claims collide with required claims\",\n        )\n        self._check_user(user)\n\n        moment = pendulum.now('UTC')\n\n        if override_refresh_lifespan is None:\n            refresh_lifespan = self.refresh_lifespan\n        else:\n            refresh_lifespan = override_refresh_lifespan\n        refresh_expiration = (moment + refresh_lifespan).int_timestamp\n\n        if override_access_lifespan is None:\n            access_lifespan = self.access_lifespan\n        else:\n            access_lifespan = override_access_lifespan\n        access_expiration = min(\n            (moment + access_lifespan).int_timestamp,\n            refresh_expiration,\n        )\n\n        payload_parts = dict(\n            iat=moment.int_timestamp,\n            exp=access_expiration,\n            rf_exp=refresh_expiration,\n            jti=str(uuid.uuid4()),\n            id=user.identity,\n            rls=','.join(user.rolenames),\n            **custom_claims\n        )\n        return jwt.encode(\n            payload_parts, self.encode_key, self.encode_algorithm,\n        ).decode('utf-8')", "response": "Encodes user data into a jwt token that can be used for authorization at protected endpoints."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode_eternal_jwt_token(self, user, **custom_claims):\n        return self.encode_jwt_token(\n            user,\n            override_access_lifespan=VITAM_AETERNUM,\n            override_refresh_lifespan=VITAM_AETERNUM,\n            **custom_claims\n        )", "response": "This utility function encodes an eagle jwt token that never expires by the user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new token for a user if and only if the old token's access permission is expired but its refresh permission is not yet expired. The new token's refresh expiration moment is the same as the old token's, but the new token's access expiration is refreshed :param: token: The existing jwt token that needs to be replaced with a new, refreshed token :param: override_access_lifespan: Override's the instance's access lifespan to set a custom duration after which the new token's accessability will expire. May not exceed the refresh lifespan", "response": "def refresh_jwt_token(self, token, override_access_lifespan=None):\n        \"\"\"\n        Creates a new token for a user if and only if the old token's access\n        permission is expired but its refresh permission is not yet expired.\n        The new token's refresh expiration moment is the same as the old\n        token's, but the new token's access expiration is refreshed\n\n        :param: token:                     The existing jwt token that needs to\n                                           be replaced with a new, refreshed\n                                           token\n        :param: override_access_lifespan:  Override's the instance's access\n                                           lifespan to set a custom duration\n                                           after which the new token's\n                                           accessability will expire. May not\n                                           exceed the refresh lifespan\n        \"\"\"\n        moment = pendulum.now('UTC')\n        # Note: we disable exp verification because we do custom checks here\n        with InvalidTokenHeader.handle_errors('failed to decode JWT token'):\n            data = jwt.decode(\n                token,\n                self.encode_key,\n                algorithms=self.allowed_algorithms,\n                options={'verify_exp': False},\n            )\n\n        self._validate_jwt_data(data, access_type=AccessType.refresh)\n\n        user = self.user_class.identify(data['id'])\n        self._check_user(user)\n\n        if override_access_lifespan is None:\n            access_lifespan = self.access_lifespan\n        else:\n            access_lifespan = override_access_lifespan\n        refresh_expiration = data['rf_exp']\n        access_expiration = min(\n            (moment + access_lifespan).int_timestamp,\n            refresh_expiration,\n        )\n\n        custom_claims = {\n            k: v for (k, v) in data.items() if k not in RESERVED_CLAIMS\n        }\n        payload_parts = dict(\n            iat=moment.int_timestamp,\n            exp=access_expiration,\n            rf_exp=refresh_expiration,\n            jti=data['jti'],\n            id=data['id'],\n            rls=','.join(user.rolenames),\n            **custom_claims\n        )\n        return jwt.encode(\n            payload_parts, self.encode_key, self.encode_algorithm,\n        ).decode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract a data dictionary from a jwt token", "response": "def extract_jwt_token(self, token):\n        \"\"\"\n        Extracts a data dictionary from a jwt token\n        \"\"\"\n        # Note: we disable exp verification because we will do it ourselves\n        with InvalidTokenHeader.handle_errors('failed to decode JWT token'):\n            data = jwt.decode(\n                token,\n                self.encode_key,\n                algorithms=self.allowed_algorithms,\n                options={'verify_exp': False},\n            )\n        self._validate_jwt_data(data, access_type=AccessType.access)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _validate_jwt_data(self, data, access_type):\n        MissingClaimError.require_condition(\n            'jti' in data,\n            'Token is missing jti claim',\n        )\n        BlacklistedError.require_condition(\n            not self.is_blacklisted(data['jti']),\n            'Token has a blacklisted jti',\n        )\n        MissingClaimError.require_condition(\n            'id' in data,\n            'Token is missing id field',\n        )\n        MissingClaimError.require_condition(\n            'exp' in data,\n            'Token is missing exp claim',\n        )\n        MissingClaimError.require_condition(\n            'rf_exp' in data,\n            'Token is missing rf_exp claim',\n        )\n        moment = pendulum.now('UTC').int_timestamp\n        if access_type == AccessType.access:\n            ExpiredAccessError.require_condition(\n                moment <= data['exp'],\n                'access permission has expired',\n            )\n        elif access_type == AccessType.refresh:\n            EarlyRefreshError.require_condition(\n                moment > data['exp'],\n                'access permission for token has not expired. may not refresh',\n            )\n            ExpiredRefreshError.require_condition(\n                moment <= data['rf_exp'],\n                'refresh permission for token has expired',\n            )", "response": "Validates that the data for a jwt token is valid."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _unpack_header(self, headers):\n        jwt_header = headers.get(self.header_name)\n        MissingTokenHeader.require_condition(\n            jwt_header is not None,\n            \"JWT token not found in headers under '{}'\",\n            self.header_name,\n        )\n\n        match = re.match(self.header_type + r'\\s*([\\w\\.-]+)', jwt_header)\n        InvalidTokenHeader.require_condition(\n            match is not None,\n            \"JWT header structure is invalid\",\n        )\n        token = match.group(1)\n        return token", "response": "Unpacks a jwt token from a request header"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npacking a jwt token into a header dict for a given user.", "response": "def pack_header_for_user(\n            self, user,\n            override_access_lifespan=None, override_refresh_lifespan=None,\n            **custom_claims\n    ):\n        \"\"\"\n        Encodes a jwt token and packages it into a header dict for a given user\n\n        :param: user:                      The user to package the header for\n        :param: override_access_lifespan:  Override's the instance's access\n                                           lifespan to set a custom duration\n                                           after which the new token's\n                                           accessability will expire. May not\n                                           exceed the refresh_lifespan\n        :param: override_refresh_lifespan: Override's the instance's refresh\n                                           lifespan to set a custom duration\n                                           after which the new token's\n                                           refreshability will expire.\n        :param: custom_claims:             Additional claims that should\n                                           be packed in the payload. Note that\n                                           any claims supplied here must be\n                                           JSON compatible types\n        \"\"\"\n        token = self.encode_jwt_token(\n            user,\n            override_access_lifespan=override_access_lifespan,\n            override_refresh_lifespan=override_refresh_lifespan,\n            **custom_claims\n        )\n        return {self.header_name: self.header_type + ' ' + token}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef login():\n    req = flask.request.get_json(force=True)\n    username = req.get('username', None)\n    password = req.get('password', None)\n    user = guard.authenticate(username, password)\n    ret = {'access_token': guard.encode_jwt_token(user)}\n    return (flask.jsonify(ret), 200)", "response": "Logs a user in by parsing a POST request containing user credentials and returning a JSON response containing the user s access token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef refresh():\n    old_token = guard.read_token_from_header()\n    new_token = guard.refresh_jwt_token(old_token)\n    ret = {'access_token': new_token}\n    return flask.jsonify(ret), 200", "response": "Refreshes an existing token by creating a new one and then refreshing it with a new one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisabling a user in the data store", "response": "def disable_user():\n    \"\"\"\n    Disables a user in the data store\n\n    .. example::\n        $ curl http://localhost:5000/disable_user -X POST \\\n          -H \"Authorization: Bearer <your_token>\" \\\n          -d '{\"username\":\"Walter\"}'\n    \"\"\"\n    req = flask.request.get_json(force=True)\n    usr = User.query.filter_by(username=req.get('username', None)).one()\n    usr.is_active = False\n    db.session.commit()\n    return flask.jsonify(message='disabled user {}'.format(usr.username))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blacklist_token():\n    req = flask.request.get_json(force=True)\n    data = guard.extract_jwt_token(req['token'])\n    blacklist.add(data['jti'])\n    return flask.jsonify(message='token blacklisted ({})'.format(req['token']))", "response": "Blacklists an existing JWT by registering its jti claim in the blacklist."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlogging a user in by parsing a POST request containing user credentials and issuing a JWT token.", "response": "def login():\n    \"\"\"\n    Logs a user in by parsing a POST request containing user credentials and\n    issuing a JWT token.\n\n    .. example::\n       $ curl http://localhost:5000/login -X POST \\\n         -d '{\"username\":\"Walter\",\"password\":\"calmerthanyouare\"}'\n    \"\"\"\n    req = flask.request.get_json(force=True)\n    username = req.pop('username', None)\n    password = req.pop('password', None)\n\n    user = guard.authenticate(username, password)\n    ret = {'access_token': guard.encode_jwt_token(\n        user,\n        firstname=user.firstname,\n        nickname=user.nickname,\n        surname=user.surname,\n    )}\n\n    return (flask.jsonify(ret), 200)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the current instance of flask - praetorian that is attached to the current flask app", "response": "def current_guard():\n    \"\"\"\n    Fetches the current instance of flask-praetorian that is attached to the\n    current flask app\n    \"\"\"\n    guard = flask.current_app.extensions.get('praetorian', None)\n    PraetorianError.require_condition(\n        guard is not None,\n        \"No current guard found; Praetorian must be initialized first\",\n    )\n    return guard"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching a dict of jwt token data from the top of the app context", "response": "def get_jwt_data_from_app_context():\n    \"\"\"\n    Fetches a dict of jwt token data from the top of the flask app's context\n    \"\"\"\n    ctx = flask._app_ctx_stack.top\n    jwt_data = getattr(ctx, 'jwt_data', None)\n    PraetorianError.require_condition(\n        jwt_data is not None,\n        \"\"\"\n        No jwt_data found in app context.\n        Make sure @auth_required decorator is specified *first* for route\n        \"\"\",\n    )\n    return jwt_data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef current_rolenames():\n    jwt_data = get_jwt_data_from_app_context()\n    if 'rls' not in jwt_data:\n        # This is necessary so our set arithmetic works correctly\n        return set(['non-empty-but-definitely-not-matching-subset'])\n    else:\n        return set(r.strip() for r in jwt_data['rls'].split(','))", "response": "This method returns the names of all roles associated with the current user\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef current_custom_claims():\n    jwt_data = get_jwt_data_from_app_context()\n    return {k: v for (k, v) in jwt_data.items() if k not in RESERVED_CLAIMS}", "response": "This method returns any custom claims in the current jwt\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck all return uris provided and returns the client type.", "response": "def check_redirect_uris(uris, client_type=None):\n    \"\"\"\n    This function checks all return uris provided and tries to deduce\n    as what type of client we should register.\n\n    :param uris: The redirect URIs to check.\n    :type uris: list\n    :param client_type: An indicator of which client type you are expecting\n        to be used. If this does not match the deduced type, an error will\n        be raised.\n    :type client_type: str\n    :returns: The deduced client type.\n    :rtype: str\n    :raises ValueError: An error occured while checking the redirect uris.\n\n    .. versionadded:: 1.0\n    \"\"\"\n    if client_type not in [None, 'native', 'web']:\n        raise ValueError('Invalid client type indicator used')\n\n    if not isinstance(uris, list):\n        raise ValueError('uris needs to be a list of strings')\n\n    if len(uris) < 1:\n        raise ValueError('At least one return URI needs to be provided')\n\n    for uri in uris:\n        if uri.startswith('https://'):\n            if client_type == 'native':\n                raise ValueError('https url with native client')\n            client_type = 'web'\n        elif uri.startswith('http://localhost'):\n            if client_type == 'web':\n                raise ValueError('http://localhost url with web client')\n            client_type = 'native'\n        else:\n            if (uri.startswith('http://') and \n                    not uri.startswith('http://localhost')):\n                raise ValueError('http:// url with non-localhost is illegal')\n            else:\n                raise ValueError('Invalid uri provided: %s' % uri)\n\n    return client_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_client(provider_info, redirect_uris):\n    client_type = check_redirect_uris(redirect_uris)\n\n    submit_info = {'redirect_uris': redirect_uris,\n                   'application_type': client_type,\n                   'token_endpoint_auth_method': 'client_secret_post'}\n\n    headers = {'Content-type': 'application/json'}\n\n    resp, content = httplib2.Http().request(\n        provider_info['registration_endpoint'], 'POST',\n        json.dumps(submit_info), headers=headers)\n\n    if int(resp['status']) >= 400:\n        raise Exception('Error: the server returned HTTP ' + resp['status'])\n\n    client_info = _json_loads(content)\n\n    if 'error' in client_info:\n        raise Exception('Error occured during registration: %s (%s)'\n                        % (client_info['error'],\n                           client_info.get('error_description')))\n\n    json_file = {'web': {\n        'client_id': client_info['client_id'],\n        'client_secret': client_info['client_secret'],\n        'auth_uri': provider_info['authorization_endpoint'],\n        'token_uri': provider_info['token_endpoint'],\n        'userinfo_uri': provider_info['userinfo_endpoint'],\n        'redirect_uris': redirect_uris,\n        'issuer': provider_info['issuer'],\n    }}\n\n    return json_file", "response": "This function registers a new client with the specified OpenID Connect Provider and returns the client ID and other information."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef discover_OP_information(OP_uri):\n    _, content = httplib2.Http().request(\n        '%s/.well-known/openid-configuration' % OP_uri)\n    return _json_loads(content)", "response": "Discovers information about the provided OpenID Provider."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init_app(self, app):\n        secrets = self.load_secrets(app)\n        self.client_secrets = list(secrets.values())[0]\n        secrets_cache = DummySecretsCache(secrets)\n\n        # Set some default configuration options\n        app.config.setdefault('OIDC_SCOPES', ['openid', 'email'])\n        app.config.setdefault('OIDC_GOOGLE_APPS_DOMAIN', None)\n        app.config.setdefault('OIDC_ID_TOKEN_COOKIE_NAME', 'oidc_id_token')\n        app.config.setdefault('OIDC_ID_TOKEN_COOKIE_PATH', '/')\n        app.config.setdefault('OIDC_ID_TOKEN_COOKIE_TTL', 7 * 86400)  # 7 days\n        # should ONLY be turned off for local debugging\n        app.config.setdefault('OIDC_COOKIE_SECURE', True)\n        app.config.setdefault('OIDC_VALID_ISSUERS',\n                              (self.client_secrets.get('issuer') or\n                               GOOGLE_ISSUERS))\n        app.config.setdefault('OIDC_CLOCK_SKEW', 60)  # 1 minute\n        app.config.setdefault('OIDC_REQUIRE_VERIFIED_EMAIL', False)\n        app.config.setdefault('OIDC_OPENID_REALM', None)\n        app.config.setdefault('OIDC_USER_INFO_ENABLED', True)\n        app.config.setdefault('OIDC_CALLBACK_ROUTE', '/oidc_callback')\n        app.config.setdefault('OVERWRITE_REDIRECT_URI', False)\n        app.config.setdefault(\"OIDC_EXTRA_REQUEST_AUTH_PARAMS\", {})\n        # Configuration for resource servers\n        app.config.setdefault('OIDC_RESOURCE_SERVER_ONLY', False)\n        app.config.setdefault('OIDC_RESOURCE_CHECK_AUD', False)\n\n        # We use client_secret_post, because that's what the Google\n        # oauth2client library defaults to\n        app.config.setdefault('OIDC_INTROSPECTION_AUTH_METHOD', 'client_secret_post')\n        app.config.setdefault('OIDC_TOKEN_TYPE_HINT', 'access_token')\n\n        if not 'openid' in app.config['OIDC_SCOPES']:\n            raise ValueError('The value \"openid\" must be in the OIDC_SCOPES')\n\n        # register callback route and cookie-setting decorator\n        if not app.config['OIDC_RESOURCE_SERVER_ONLY']:\n            app.route(app.config['OIDC_CALLBACK_ROUTE'])(self._oidc_callback)\n            app.before_request(self._before_request)\n            app.after_request(self._after_request)\n\n        # Initialize oauth2client\n        self.flow = flow_from_clientsecrets(\n            app.config['OIDC_CLIENT_SECRETS'],\n            scope=app.config['OIDC_SCOPES'],\n            cache=secrets_cache)\n        assert isinstance(self.flow, OAuth2WebServerFlow)\n\n        # create signers using the Flask secret key\n        self.extra_data_serializer = JSONWebSignatureSerializer(\n            app.config['SECRET_KEY'], salt='flask-oidc-extra-data')\n        self.cookie_serializer = JSONWebSignatureSerializer(\n            app.config['SECRET_KEY'], salt='flask-oidc-cookie')\n\n        try:\n            self.credentials_store = app.config['OIDC_CREDENTIALS_STORE']\n        except KeyError:\n            pass", "response": "Initialize the application with the OIDC."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user_getfield(self, field, access_token=None):\n        info = self.user_getinfo([field], access_token)\n        return info.get(field)", "response": "Request a single field of information about the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_getinfo(self, fields, access_token=None):\n        if g.oidc_id_token is None and access_token is None:\n            raise Exception('User was not authenticated')\n        info = {}\n        all_info = None\n        for field in fields:\n            if access_token is None and field in g.oidc_id_token:\n                info[field] = g.oidc_id_token[field]\n            elif current_app.config['OIDC_USER_INFO_ENABLED']:\n                # This was not in the id_token. Let's get user information\n                if all_info is None:\n                    all_info = self._retrieve_userinfo(access_token)\n                    if all_info is None:\n                        # To make sure we don't retry for every field\n                        all_info = {}\n                if field in all_info:\n                    info[field] = all_info[field]\n                else:\n                    # We didn't get this information\n                    pass\n        return info", "response": "Request multiple fields of information about the user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _retrieve_userinfo(self, access_token=None):\n        if 'userinfo_uri' not in self.client_secrets:\n            logger.debug('Userinfo uri not specified')\n            raise AssertionError('UserInfo URI not specified')\n\n        # Cache the info from this request\n        if '_oidc_userinfo' in g:\n            return g._oidc_userinfo\n\n        http = httplib2.Http()\n        if access_token is None:\n            try:\n                credentials = OAuth2Credentials.from_json(\n                    self.credentials_store[g.oidc_id_token['sub']])\n            except KeyError:\n                logger.debug(\"Expired ID token, credentials missing\",\n                             exc_info=True)\n                return None\n            credentials.authorize(http)\n            resp, content = http.request(self.client_secrets['userinfo_uri'])\n        else:\n            # We have been manually overriden with an access token\n            resp, content = http.request(\n                self.client_secrets['userinfo_uri'],\n                \"POST\",\n                body=urlencode({\"access_token\": access_token}),\n                headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n        logger.debug('Retrieved user info: %s' % content)\n        info = _json_loads(content)\n\n        g._oidc_userinfo = info\n\n        return info", "response": "Requests extra user information from the Provider s UserInfo and\n        returns the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting a new ID token cookie if the ID token has changed.", "response": "def _after_request(self, response):\n        \"\"\"\n        Set a new ID token cookie if the ID token has changed.\n        \"\"\"\n        # This means that if either the new or the old are False, we set\n        # insecure cookies.\n        # We don't define OIDC_ID_TOKEN_COOKIE_SECURE in init_app, because we\n        # don't want people to find it easily.\n        cookie_secure = (current_app.config['OIDC_COOKIE_SECURE'] and\n                         current_app.config.get('OIDC_ID_TOKEN_COOKIE_SECURE',\n                                                True))\n\n        if getattr(g, 'oidc_id_token_dirty', False):\n            if g.oidc_id_token:\n                signed_id_token = self.cookie_serializer.dumps(g.oidc_id_token)\n                response.set_cookie(\n                    current_app.config['OIDC_ID_TOKEN_COOKIE_NAME'],\n                    signed_id_token,\n                    secure=cookie_secure,\n                    httponly=True,\n                    max_age=current_app.config['OIDC_ID_TOKEN_COOKIE_TTL'])\n            else:\n                # This was a log out\n                response.set_cookie(\n                    current_app.config['OIDC_ID_TOKEN_COOKIE_NAME'],\n                    '',\n                    path=current_app.config['OIDC_ID_TOKEN_COOKIE_PATH'],\n                    secure=cookie_secure,\n                    httponly=True,\n                    expires=0)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nauthenticate or redirect to Google if the user is logged in.", "response": "def authenticate_or_redirect(self):\n        \"\"\"\n        Helper function suitable for @app.before_request and @check.\n        Sets g.oidc_id_token to the ID token if the user has successfully\n        authenticated, else returns a redirect object so they can go try\n        to authenticate.\n\n        :returns: A redirect object, or None if the user is logged in.\n        :rtype: Redirect\n\n        .. deprecated:: 1.0\n           Use :func:`require_login` instead.\n        \"\"\"\n        # the auth callback and error pages don't need user to be authenticated\n        if request.endpoint in frozenset(['_oidc_callback', '_oidc_error']):\n            return None\n\n        # retrieve signed ID token cookie\n        id_token = self._get_cookie_id_token()\n        if id_token is None:\n            return self.redirect_to_auth_server(request.url)\n\n        # ID token expired\n        # when Google is the IdP, this happens after one hour\n        if time.time() >= id_token['exp']:\n            # get credentials from store\n            try:\n                credentials = OAuth2Credentials.from_json(\n                    self.credentials_store[id_token['sub']])\n            except KeyError:\n                logger.debug(\"Expired ID token, credentials missing\",\n                             exc_info=True)\n                return self.redirect_to_auth_server(request.url)\n\n            # refresh and store credentials\n            try:\n                credentials.refresh(httplib2.Http())\n                if credentials.id_token:\n                    id_token = credentials.id_token\n                else:\n                    # It is not guaranteed that we will get a new ID Token on\n                    # refresh, so if we do not, let's just update the id token\n                    # expiry field and reuse the existing ID Token.\n                    if credentials.token_expiry is None:\n                        logger.debug('Expired ID token, no new expiry. Falling'\n                                     ' back to assuming 1 hour')\n                        id_token['exp'] = time.time() + 3600\n                    else:\n                        id_token['exp'] = calendar.timegm(\n                            credentials.token_expiry.timetuple())\n                self.credentials_store[id_token['sub']] = credentials.to_json()\n                self._set_cookie_id_token(id_token)\n            except AccessTokenRefreshError:\n                # Can't refresh. Wipe credentials and redirect user to IdP\n                # for re-authentication.\n                logger.debug(\"Expired ID token, can't refresh credentials\",\n                             exc_info=True)\n                del self.credentials_store[id_token['sub']]\n                return self.redirect_to_auth_server(request.url)\n\n        # make ID token available to views\n        g.oidc_id_token = id_token\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing this to decorate view functions that require a user to be logged in. If the user is not already logged in, they will be sent to the Provider to log in, after which they will be returned. .. versionadded:: 1.0 This was :func:`check` before.", "response": "def require_login(self, view_func):\n        \"\"\"\n        Use this to decorate view functions that require a user to be logged\n        in. If the user is not already logged in, they will be sent to the\n        Provider to log in, after which they will be returned.\n\n        .. versionadded:: 1.0\n           This was :func:`check` before.\n        \"\"\"\n        @wraps(view_func)\n        def decorated(*args, **kwargs):\n            if g.oidc_id_token is None:\n                return self.redirect_to_auth_server(request.url)\n            return view_func(*args, **kwargs)\n        return decorated"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions to check for a KeyCloak client role in JWT access token. This is intended to be replaced with a more generic 'require this value in token or claims' system, at which point backwards compatibility will be added. .. versionadded:: 1.5.0", "response": "def require_keycloak_role(self, client, role):\n        \"\"\"\n        Function to check for a KeyCloak client role in JWT access token.\n\n        This is intended to be replaced with a more generic 'require this value\n        in token or claims' system, at which point backwards compatibility will\n        be added.\n\n        .. versionadded:: 1.5.0\n        \"\"\"\n        def wrapper(view_func):\n            @wraps(view_func)\n            def decorated(*args, **kwargs):\n                pre, tkn, post = self.get_access_token().split('.')\n                access_token = json.loads(b64decode(tkn))\n                if role in access_token['resource_access'][client]['roles']:\n                    return view_func(*args, **kwargs)\n                else:\n                    return abort(403)\n            return decorated\n        return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _flow_for_request(self):\n        flow = copy(self.flow)\n        redirect_uri = current_app.config['OVERWRITE_REDIRECT_URI']\n        if not redirect_uri:\n            flow.redirect_uri = url_for('_oidc_callback', _external=True)\n        else:\n            flow.redirect_uri = redirect_uri\n        return flow", "response": "Build a flow with the correct absolute callback URL for this request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nredirecting the user to the Auth Server.", "response": "def redirect_to_auth_server(self, destination=None, customstate=None):\n        \"\"\"\n        Set a CSRF token in the session, and redirect to the IdP.\n\n        :param destination: The page that the user was going to,\n            before we noticed they weren't logged in.\n        :type destination: Url to return the client to if a custom handler is\n            not used. Not available with custom callback.\n        :param customstate: The custom data passed via the ODIC state.\n            Note that this only works with a custom_callback, and this will\n            ignore destination.\n        :type customstate: Anything that can be serialized\n        :returns: A redirect response to start the login process.\n        :rtype: Flask Response\n\n        .. deprecated:: 1.0\n           Use :func:`require_login` instead.\n        \"\"\"\n        if not self._custom_callback and customstate:\n            raise ValueError('Custom State is only avilable with a custom '\n                             'handler')\n        if 'oidc_csrf_token' not in session:\n            csrf_token = urlsafe_b64encode(os.urandom(24)).decode('utf-8')\n            session['oidc_csrf_token'] = csrf_token\n        state = {\n            'csrf_token': session['oidc_csrf_token'],\n        }\n        statefield = 'destination'\n        statevalue = destination\n        if customstate is not None:\n            statefield = 'custom'\n            statevalue = customstate\n        state[statefield] = self.extra_data_serializer.dumps(\n            statevalue).decode('utf-8')\n\n        extra_params = {\n            'state': urlsafe_b64encode(json.dumps(state).encode('utf-8')),\n        }\n        extra_params.update(current_app.config['OIDC_EXTRA_REQUEST_AUTH_PARAMS'])\n        if current_app.config['OIDC_GOOGLE_APPS_DOMAIN']:\n            extra_params['hd'] = current_app.config['OIDC_GOOGLE_APPS_DOMAIN']\n        if current_app.config['OIDC_OPENID_REALM']:\n            extra_params['openid.realm'] = current_app.config[\n                'OIDC_OPENID_REALM']\n\n        flow = self._flow_for_request()\n        auth_url = '{url}&{extra_params}'.format(\n            url=flow.step1_get_authorize_url(),\n            extra_params=urlencode(extra_params))\n        # if the user has an ID token, it's invalid, or we wouldn't be here\n        self._set_cookie_id_token(None)\n        return redirect(auth_url)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _is_id_token_valid(self, id_token):\n        if not id_token:\n            return False\n\n        # step 2: check issuer\n        if id_token['iss'] not in current_app.config['OIDC_VALID_ISSUERS']:\n            logger.error('id_token issued by non-trusted issuer: %s'\n                         % id_token['iss'])\n            return False\n\n        if isinstance(id_token['aud'], list):\n            # step 3 for audience list\n            if self.flow.client_id not in id_token['aud']:\n                logger.error('We are not a valid audience')\n                return False\n            # step 4\n            if 'azp' not in id_token and len(id_token['aud']) > 1:\n                logger.error('Multiple audiences and not authorized party')\n                return False\n        else:\n            # step 3 for single audience\n            if id_token['aud'] != self.flow.client_id:\n                logger.error('We are not the audience')\n                return False\n\n        # step 5\n        if 'azp' in id_token and id_token['azp'] != self.flow.client_id:\n            logger.error('Authorized Party is not us')\n            return False\n\n        # step 6-8: TLS checked\n\n        # step 9: check exp\n        if int(time.time()) >= int(id_token['exp']):\n            logger.error('Token has expired')\n            return False\n\n        # step 10: check iat\n        if id_token['iat'] < (time.time() -\n                              current_app.config['OIDC_CLOCK_SKEW']):\n            logger.error('Token issued in the past')\n            return False\n\n        # (not required if using HTTPS?) step 11: check nonce\n\n        # step 12-13: not requested acr or auth_time, so not needed to test\n\n        # additional steps specific to our usage\n        if current_app.config['OIDC_GOOGLE_APPS_DOMAIN'] and \\\n                id_token.get('hd') != current_app.config[\n                    'OIDC_GOOGLE_APPS_DOMAIN']:\n            logger.error('Invalid google apps domain')\n            return False\n\n        if not id_token.get('email_verified', False) and \\\n                current_app.config['OIDC_REQUIRE_VERIFIED_EMAIL']:\n            logger.error('Email not verified')\n            return False\n\n        return True", "response": "Check if the ID token is valid."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrap function to use a custom callback. The custom OIDC callback will get the custom state field passed in with redirect_to_auth_server.", "response": "def custom_callback(self, view_func):\n        \"\"\"\n        Wrapper function to use a custom callback.\n        The custom OIDC callback will get the custom state field passed in with\n        redirect_to_auth_server.\n        \"\"\"\n        @wraps(view_func)\n        def decorated(*args, **kwargs):\n            plainreturn, data = self._process_callback('custom')\n            if plainreturn:\n                return data\n            else:\n                return view_func(data, *args, **kwargs)\n        self._custom_callback = decorated\n        return decorated"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_callback(self, statefield):\n        # retrieve session and callback variables\n        try:\n            session_csrf_token = session.get('oidc_csrf_token')\n\n            state = _json_loads(urlsafe_b64decode(request.args['state'].encode('utf-8')))\n            csrf_token = state['csrf_token']\n\n            code = request.args['code']\n        except (KeyError, ValueError):\n            logger.debug(\"Can't retrieve CSRF token, state, or code\",\n                         exc_info=True)\n            return True, self._oidc_error()\n\n        # check callback CSRF token passed to IdP\n        # against session CSRF token held by user\n        if csrf_token != session_csrf_token:\n            logger.debug(\"CSRF token mismatch\")\n            return True, self._oidc_error()\n\n        # make a request to IdP to exchange the auth code for OAuth credentials\n        flow = self._flow_for_request()\n        credentials = flow.step2_exchange(code)\n        id_token = credentials.id_token\n        if not self._is_id_token_valid(id_token):\n            logger.debug(\"Invalid ID token\")\n            if id_token.get('hd') != current_app.config[\n                    'OIDC_GOOGLE_APPS_DOMAIN']:\n                return True, self._oidc_error(\n                    \"You must log in with an account from the {0} domain.\"\n                    .format(current_app.config['OIDC_GOOGLE_APPS_DOMAIN']),\n                    self.WRONG_GOOGLE_APPS_DOMAIN)\n            return True, self._oidc_error()\n\n        # store credentials by subject\n        # when Google is the IdP, the subject is their G+ account number\n        self.credentials_store[id_token['sub']] = credentials.to_json()\n\n        # Retrieve the extra statefield data\n        try:\n            response = self.extra_data_serializer.loads(state[statefield])\n        except BadSignature:\n            logger.error('State field was invalid')\n            return True, self._oidc_error()\n\n        # set a persistent signed cookie containing the ID token\n        # and redirect to the final destination\n        self._set_cookie_id_token(id_token)\n        return False, response", "response": "Process the callback from IdP and the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_token(self, token, scopes_required=None):\n        valid = self._validate_token(token, scopes_required)\n        if valid is True:\n            return True\n        else:\n            return ErrStr(valid)", "response": "This function is used to validate a token."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _validate_token(self, token, scopes_required=None):\n        if scopes_required is None:\n            scopes_required = []\n        scopes_required = set(scopes_required)\n\n        token_info = None\n        valid_token = False\n        has_required_scopes = False\n        if token:\n            try:\n                token_info = self._get_token_info(token)\n            except Exception as ex:\n                token_info = {'active': False}\n                logger.error('ERROR: Unable to get token info')\n                logger.error(str(ex))\n\n            valid_token = token_info.get('active', False)\n\n            if 'aud' in token_info and \\\n                    current_app.config['OIDC_RESOURCE_CHECK_AUD']:\n                valid_audience = False\n                aud = token_info['aud']\n                clid = self.client_secrets['client_id']\n                if isinstance(aud, list):\n                    valid_audience = clid in aud\n                else:\n                    valid_audience = clid == aud\n\n                if not valid_audience:\n                    logger.error('Refused token because of invalid '\n                                 'audience')\n                    valid_token = False\n\n            if valid_token:\n                token_scopes = token_info.get('scope', '').split(' ')\n            else:\n                token_scopes = []\n            has_required_scopes = scopes_required.issubset(\n                set(token_scopes))\n\n            if not has_required_scopes:\n                logger.debug('Token missed required scopes')\n\n        if (valid_token and has_required_scopes):\n            g.oidc_token_info = token_info\n            return True\n\n        if not valid_token:\n            return 'Token required but invalid'\n        elif not has_required_scopes:\n            return 'Token does not have required scopes'\n        else:\n            return 'Something went wrong checking your token'", "response": "The actual implementation of validate_token."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef accept_token(self, require_token=False, scopes_required=None,\n                           render_errors=True):\n        \"\"\"\n        Use this to decorate view functions that should accept OAuth2 tokens,\n        this will most likely apply to API functions.\n\n        Tokens are accepted as part of the query URL (access_token value) or\n        a POST form value (access_token).\n\n        Note that this only works if a token introspection url is configured,\n        as that URL will be queried for the validity and scopes of a token.\n\n        :param require_token: Whether a token is required for the current\n            function. If this is True, we will abort the request if there\n            was no token provided.\n        :type require_token: bool\n        :param scopes_required: List of scopes that are required to be\n            granted by the token before being allowed to call the protected\n            function.\n        :type scopes_required: list\n        :param render_errors: Whether or not to eagerly render error objects\n            as JSON API responses. Set to False to pass the error object back\n            unmodified for later rendering.\n        :type render_errors: callback(obj) or None\n\n        .. versionadded:: 1.0\n        \"\"\"\n\n        def wrapper(view_func):\n            @wraps(view_func)\n            def decorated(*args, **kwargs):\n                token = None\n                if 'Authorization' in request.headers and request.headers['Authorization'].startswith('Bearer '):\n                    token = request.headers['Authorization'].split(None,1)[1].strip()\n                if 'access_token' in request.form:\n                    token = request.form['access_token']\n                elif 'access_token' in request.args:\n                    token = request.args['access_token']\n\n                validity = self.validate_token(token, scopes_required)\n                if (validity is True) or (not require_token):\n                    return view_func(*args, **kwargs)\n                else:\n                    response_body = {'error': 'invalid_token',\n                                     'error_description': validity}\n                    if render_errors:\n                        response_body = json.dumps(response_body)\n                    return response_body, 401, {'WWW-Authenticate': 'Bearer'}\n\n            return decorated\n        return wrapper", "response": "Decorator that returns a view function that accepts a token."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the rows denoted by indices form the CSR sparse matrix mat.", "response": "def delete_rows_csr(mat, indices):\n    \"\"\"\n    Remove the rows denoted by ``indices`` form the CSR sparse matrix ``mat``.\n    \"\"\"\n    if not isinstance(mat, scipy.sparse.csr_matrix):\n        raise ValueError(\"works only for CSR format -- use .tocsr() first\")\n    indices = list(indices)\n    mask = np.ones(mat.shape[0], dtype=bool)\n    mask[indices] = False\n    return mat[mask]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the string without non ASCII characters", "response": "def strip_non_ascii(string):\n    ''' Returns the string without non ASCII characters'''\n    stripped = (c for c in string if 0 < ord(c) < 127)\n    return ''.join(stripped)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef restrict(self, support):\n        if self.has_been_restricted == True:\n            return self\n\n        new_numerical_cols = []\n        new_categorical_cols = []\n        new_additional_numerical_cols = []\n        new_feature_names = []\n        new_vocab = {}\n\n        for idx, val in enumerate(support):\n            if val == True:\n                feature_name = self.feature_names_[idx]\n                if self.separator in feature_name:\n                    base_feature_name = feature_name[:feature_name.rfind(self.separator)]\n                else:\n                    base_feature_name = feature_name\n                new_feature_names.append(feature_name)\n                new_vocab[feature_name] = len(new_vocab)\n                if feature_name in self.numerical_columns:\n                    new_numerical_cols.append(feature_name)\n                elif base_feature_name in self.categorical_columns and base_feature_name not in new_categorical_cols:\n                    new_categorical_cols.append(base_feature_name)\n                elif feature_name in self.additional_numerical_cols:\n                    new_additional_numerical_cols.append(feature_name)\n\n        self.feature_names_ = new_feature_names\n        self.vocabulary_ = new_vocab\n        self.numerical_columns = new_numerical_cols\n        self.categorical_columns = new_categorical_cols\n        self.additional_numerical_cols = new_additional_numerical_cols\n\n        self.has_been_restricted = True\n        return self", "response": "Restrict the features to those in support using feature selection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef agents(self):\n        if self.api and self.agent_ids:\n            return self.api._get_agents(self.agent_ids)", "response": "Return a list of agents involved in the chat"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the ID of the department that the chat belongs to", "response": "def department(self):\n        \"\"\"\n        |  Description: The ID of the department to which the chat is directed\n        \"\"\"\n        if self.api and self.department_id:\n            return self.api._get_department(self.department_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef zendesk_ticket(self):\n        if self.api and self.zendesk_ticket_id:\n            return self.api._get_zendesk_ticket(self.zendesk_ticket_id)", "response": "Returns the Zendesk Support ticket for this chat"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures the passed type matches this API s object_type.", "response": "def check_type(self, zenpy_objects):\n        \"\"\" Ensure the passed type matches this API's object_type. \"\"\"\n        expected_type = self.api._object_mapping.class_for_type(self.api.object_type)\n        if not isinstance(zenpy_objects, collections.Iterable):\n            zenpy_objects = [zenpy_objects]\n        for zenpy_object in zenpy_objects:\n            if type(zenpy_object) is not expected_type:\n                raise ZenpyException(\n                    \"Invalid type - expected {} found {}\".format(expected_type, type(zenpy_object))\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a name in camelCase return in snake_case", "response": "def to_snake_case(name):\n    \"\"\" Given a name in camelCase return in snake_case \"\"\"\n    s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)\n    return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_unix_ts(start_time):\n    if isinstance(start_time, datetime):\n        if is_timezone_aware(start_time):\n            start_time = start_time.astimezone(pytz.utc)\n        else:\n            log.warning(\n                \"Non timezone-aware datetime object passed to IncrementalEndpoint. \"\n                \"The Zendesk API expects UTC time, if this is not the case results will be incorrect!\"\n            )\n        unix_time = calendar.timegm(start_time.timetuple())\n    else:\n        unix_time = start_time\n\n    return int(unix_time)", "response": "Given a datetime object returns its value as a unix timestamp"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndetermines whether or not an object is iterable but not a string.", "response": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_singular(result_key):\n    if result_key.endswith('ies'):\n        return re.sub('ies$', 'y', result_key)\n    elif result_key.endswith('uses'):\n        return re.sub(\"uses$\", \"us\", result_key)\n    elif result_key.endswith('addresses'):  # Special case for '*addresses'\n        return result_key[:-2]\n    elif result_key.endswith('s'):\n        return result_key[:-1]\n    else:\n        return result_key", "response": "Given a result key return in the singular form\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a result key return in the plural form.", "response": "def as_plural(result_key):\n    \"\"\"\n    Given a result key, return in the plural form.\n    \"\"\"\n    # Not at all guaranteed to work in all cases...\n    if result_key.endswith('y'):\n        return re.sub(\"y$\", \"ies\", result_key)\n    elif result_key.endswith('address'):\n        return result_key + 'es'\n    elif result_key.endswith('us'):\n        return re.sub(\"us$\", \"uses\", result_key)\n    elif not result_key.endswith('s'):\n        return result_key + 's'\n    else:\n        return result_key"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_id(*object_types):\n\n    def outer(func):\n        def inner(*args, **kwargs):\n            def id_of(x):\n                return x.id if type(x) in object_types else x\n\n            new_args = [id_of(arg) for arg in args]\n            new_kwargs = {k: id_of(v) for k, v in kwargs.items()}\n            return func(*new_args, **new_kwargs)\n\n        return inner\n\n    return outer", "response": "Decorator for extracting id from passed parameters for specific types."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef json_encode(obj, serialize):\n    if hasattr(obj, 'to_dict'):\n        return obj.to_dict(serialize=serialize)\n    elif isinstance(obj, datetime):\n        return obj.date().isoformat()\n    elif isinstance(obj, date):\n        return obj.isoformat()\n    elif isinstance(obj, ProxyDict):\n        return dict(obj)\n    elif isinstance(obj, ProxyList):\n        return list(obj)\n    elif is_iterable_but_not_string(obj):\n        return list(obj)", "response": "Handle encoding complex types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute a Zendesk API call.", "response": "def _call_api(self, http_method, url, **kwargs):\n        \"\"\"\n        Execute a call to the Zendesk API. Handles rate limiting, checking the response\n        from Zendesk and deserialization of the Zendesk response. All\n        communication with Zendesk should go through this method.\n\n        :param http_method: The requests method to call (eg post, put, get).\n        :param url: The url to pass to to the requests method.\n        :param kwargs: Any additional kwargs to pass on to requests.\n        \"\"\"\n        log.debug(\"{}: {} - {}\".format(http_method.__name__.upper(), url, kwargs))\n        if self.ratelimit is not None:\n            # This path indicates we're taking a proactive approach to not hit the rate limit\n            response = self._ratelimit(http_method=http_method, url=url, **kwargs)\n        else:\n            response = http_method(url, **kwargs)\n\n        # If we are being rate-limited, wait the required period before trying again.\n        if response.status_code == 429:\n            while 'retry-after' in response.headers and int(response.headers['retry-after']) > 0:\n                retry_after_seconds = int(response.headers['retry-after'])\n                log.warning(\n                    \"Waiting for requested retry-after period: %s seconds\" % retry_after_seconds\n                )\n                while retry_after_seconds > 0:\n                    retry_after_seconds -= 1\n                    self.check_ratelimit_budget(1)\n                    log.debug(\"    -> sleeping: %s more seconds\" % retry_after_seconds)\n                    sleep(1)\n                response = http_method(url, **kwargs)\n\n        self._check_response(response)\n        self._update_callsafety(response)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the rate limit budget is exceeded.", "response": "def check_ratelimit_budget(self, seconds_waited):\n        \"\"\" If we have a ratelimit_budget, ensure it is not exceeded. \"\"\"\n        if self.ratelimit_budget is not None:\n            self.ratelimit_budget -= seconds_waited\n            if self.ratelimit_budget < 1:\n                raise RatelimitBudgetExceeded(\"Rate limit budget exceeded!\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring we don t hit the rate limit.", "response": "def _ratelimit(self, http_method, url, **kwargs):\n        \"\"\" Ensure we do not hit the rate limit. \"\"\"\n\n        def time_since_last_call():\n            if self.callsafety['lastcalltime'] is not None:\n                return int(time() - self.callsafety['lastcalltime'])\n            else:\n                return None\n\n        lastlimitremaining = self.callsafety['lastlimitremaining']\n\n        if time_since_last_call() is None or time_since_last_call() >= self.ratelimit_request_interval or \\\n                lastlimitremaining >= self.ratelimit:\n            response = http_method(url, **kwargs)\n        else:\n            # We hit our limit floor and aren't quite at ratelimit_request_interval value in seconds yet..\n            log.warning(\n                \"Safety Limit Reached of %s remaining calls and time since last call is under %s seconds\"\n                % (self.ratelimit, self.ratelimit_request_interval)\n            )\n            while time_since_last_call() < self.ratelimit_request_interval:\n                remaining_sleep = int(self.ratelimit_request_interval - time_since_last_call())\n                log.debug(\"  -> sleeping: %s more seconds\" % remaining_sleep)\n                self.check_ratelimit_budget(1)\n                sleep(1)\n            response = http_method(url, **kwargs)\n\n        self.callsafety['lastcalltime'] = time()\n        self.callsafety['lastlimitremaining'] = int(response.headers.get('X-Rate-Limit-Remaining', 0))\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the internal data structure of the callsafety data structure.", "response": "def _update_callsafety(self, response):\n        \"\"\" Update the callsafety data structure \"\"\"\n        if self.ratelimit is not None:\n            self.callsafety['lastcalltime'] = time()\n            self.callsafety['lastlimitremaining'] = int(response.headers.get('X-Rate-Limit-Remaining', 0))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_response(self, response, object_mapping=None):\n        try:\n            pretty_response = response.json()\n        except ValueError:\n            pretty_response = response\n        for handler in self._response_handlers:\n            if handler.applies_to(self, response):\n                log.debug(\"{} matched: {}\".format(handler.__name__, pretty_response))\n                r = handler(self, object_mapping).build(response)\n                self._clean_dirty_objects()\n                return r\n        raise ZenpyException(\"Could not handle response: {}\".format(pretty_response))", "response": "Process a response from Zenpy and return a Zenpy object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncleans all dirty attributes for the last object or list of objects successfully submitted to Zendesk.", "response": "def _clean_dirty_objects(self):\n        \"\"\"\n        Clear all dirty attributes for the last object or list of objects successfully submitted to Zendesk.\n        \"\"\"\n        if self._dirty_object is None:\n            return\n        if not is_iterable_but_not_string(self._dirty_object):\n            self._dirty_object = [self._dirty_object]\n\n        log.debug(\"Cleaning objects: {}\".format(self._dirty_object))\n        for o in self._dirty_object:\n            if isinstance(o, BaseObject):\n                o._clean_dirty()\n        self._dirty_object = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes a Zenpy object to JSON", "response": "def _serialize(self, zenpy_object):\n        \"\"\" Serialize a Zenpy object to JSON \"\"\"\n        # If it's a dict this object has already been serialized.\n        if not type(zenpy_object) == dict:\n            log.debug(\"Setting dirty object: {}\".format(zenpy_object))\n            self._dirty_object = zenpy_object\n        return json.loads(json.dumps(zenpy_object, default=json_encode_for_zendesk))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying Zendesk for items.", "response": "def _query_zendesk(self, endpoint, object_type, *endpoint_args, **endpoint_kwargs):\n        \"\"\"\n        Query Zendesk for items. If an id or list of ids are passed, attempt to locate these items\n         in the relevant cache. If they cannot be found, or no ids are passed, execute a call to Zendesk\n         to retrieve the items.\n\n        :param endpoint: target endpoint.\n        :param object_type: object type we are expecting.\n        :param endpoint_args: args for endpoint\n        :param endpoint_kwargs: kwargs for endpoint\n\n        :return: either a ResultGenerator or a Zenpy object.\n        \"\"\"\n\n        _id = endpoint_kwargs.get('id', None)\n        if _id:\n            item = self.cache.get(object_type, _id)\n            if item:\n                return item\n            else:\n                return self._get(url=self._build_url(endpoint(*endpoint_args, **endpoint_kwargs)))\n        elif 'ids' in endpoint_kwargs:\n            cached_objects = []\n            # Check to see if we have all objects in the cache.\n            # If we are missing even one we request them all again.\n            # This could be optimized to only request the missing objects.\n            for _id in endpoint_kwargs['ids']:\n                obj = self.cache.get(object_type, _id)\n                if not obj:\n                    return self._get(self._build_url(endpoint=endpoint(*endpoint_args, **endpoint_kwargs)))\n                cached_objects.append(obj)\n            return ZendeskResultGenerator(self, {}, response_objects=cached_objects, object_type=object_type)\n        else:\n            return self._get(self._build_url(endpoint=endpoint(*endpoint_args, **endpoint_kwargs)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_response(self, response):\n        if response.status_code > 299 or response.status_code < 200:\n            log.debug(\"Received response code [%s] - headers: %s\" % (response.status_code, str(response.headers)))\n            try:\n                _json = response.json()\n                err_type = _json.get(\"error\", '')\n                if err_type == 'RecordNotFound':\n                    raise RecordNotFoundException(json.dumps(_json), response=response)\n                elif err_type == \"TooManyValues\":\n                    raise TooManyValuesException(json.dumps(_json), response=response)\n                else:\n                    raise APIException(json.dumps(_json), response=response)\n            except ValueError:\n                response.raise_for_status()", "response": "Check the response code returned by Zendesk and raise an exception if it is outside the 200 range."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _build_url(self, endpoint):\n        if not issubclass(type(self), ChatApiBase) and not self.subdomain:\n            raise ZenpyException(\"subdomain is required when accessing the Zendesk API!\")\n\n        if self.subdomain:\n            endpoint.netloc = '{}.{}'.format(self.subdomain, self.domain)\n        else:\n            endpoint.netloc = self.domain\n\n        endpoint.prefix_path(self.api_prefix)\n        return endpoint.build()", "response": "Build the URL for the current API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate one or more API objects by external_id.", "response": "def update_by_external_id(self, api_objects):\n        \"\"\"\n        Update (PUT) one or more API objects by external_id.\n\n        :param api_objects:\n        \"\"\"\n        if not isinstance(api_objects, collections.Iterable):\n            api_objects = [api_objects]\n        return CRUDRequest(self).put(api_objects, update_many_external=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes one or more API objects by external_id.", "response": "def delete_by_external_id(self, api_objects):\n        \"\"\"\n        Delete (DELETE) one or more API objects by external_id.\n\n        :param api_objects:\n        \"\"\"\n        if not isinstance(api_objects, collections.Iterable):\n            api_objects = [api_objects]\n        return CRUDRequest(self).delete(api_objects, destroy_many_external=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting the most popular recent tags in decreasing popularity from a specific ticket.", "response": "def tags(self, ticket_id):\n        \"\"\"\n        Lists the most popular recent tags in decreasing popularity from a specific ticket.\n        \"\"\"\n        return self._query_zendesk(self.endpoint.tags, 'tag', id=ticket_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve bulk data from the incremental API.", "response": "def incremental(self, start_time, include=None):\n        \"\"\"\n        Retrieve bulk data from the incremental API.\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param start_time: The time of the oldest object you are interested in.\n        \"\"\"\n        return self._query_zendesk(self.endpoint.incremental, self.object_type, start_time=start_time, include=include)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve bulk data from the chat incremental API.", "response": "def incremental(self, start_time, **kwargs):\n        \"\"\"\n        Retrieve bulk data from the chat incremental API.\n\n        :param fields: list of fields to retrieve. `Chat API Docs\n            <https://developer.zendesk.com/rest_api/docs/chat/incremental_export#usage-notes-resource-expansion>`__.\n        :param start_time: The time of the oldest object you are interested in.\n        \"\"\"\n        return self._query_zendesk(self.endpoint.incremental, self.object_type, start_time=start_time, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing the specified identity for the specified user.", "response": "def show(self, user, identity):\n        \"\"\"\n        Show the specified identity for the specified user.\n\n        :param user: user id or User object\n        :param identity: identity id object\n        :return: Identity\n        \"\"\"\n        url = self._build_url(self.endpoint.show(user, identity))\n        return self._get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating specified identity for the specified user", "response": "def update(self, user, identity):\n        \"\"\"\n        Update specified identity for the specified user\n\n        :param user: User object or id\n        :param identity: Identity object to be updated.\n        :return: The updated Identity\n        \"\"\"\n        return UserIdentityRequest(self).put(self.endpoint.update, user, identity)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_primary(self, user, identity):\n        return UserIdentityRequest(self).put(self.endpoint.make_primary, user, identity)", "response": "Set the specified user as primary for the specified user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef request_verification(self, user, identity):\n        return UserIdentityRequest(self).put(self.endpoint.request_verification, user, identity)", "response": "Sends the user a verification email with a link to verify ownership of the email address."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nverify an identity for a user", "response": "def verify(self, user, identity):\n        \"\"\"\n        Verify an identity for a user\n\n        :param user: User id or object\n        :param identity: Identity id or object\n        :return: the verified Identity\n        \"\"\"\n        return UserIdentityRequest(self).put(self.endpoint.verify, user, identity)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the groups for this user.", "response": "def groups(self, user, include=None):\n        \"\"\"\n        Retrieve the groups for this user.\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param user: User object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.groups, 'group', id=user, include=include)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving the organizations for this user.", "response": "def organizations(self, user, include=None):\n        \"\"\"\n        Retrieve the organizations for this user.\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param user: User object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.organizations, 'organization', id=user, include=include)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves the requested tickets for this user.", "response": "def requested(self, user, include=None):\n        \"\"\"\n        Retrieve the requested tickets for this user.\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param user: User object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.requested, 'ticket', id=user, include=include)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cced(self, user, include=None):\n        return self._query_zendesk(self.endpoint.cced, 'ticket', id=user, include=include)", "response": "Retrieve the tickets this user is ccd into."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef assigned(self, user, include=None):\n        return self._query_zendesk(self.endpoint.assigned, 'ticket', id=user, include=include)", "response": "Retrieve the assigned tickets for this user."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves the group memberships for this user.", "response": "def group_memberships(self, user, include=None):\n        \"\"\"\n        Retrieve the group memberships for this user.\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param user: User object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.group_memberships, 'group_membership', id=user, include=include)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the UserRelated information for the requested User object or id", "response": "def related(self, user):\n        \"\"\"\n        Returns the UserRelated information for the requested User\n\n        :param user: User object or id\n        :return: UserRelated\n        \"\"\"\n        return self._query_zendesk(self.endpoint.related, 'user_related', id=user)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef me(self, include=None):\n        return self._query_zendesk(self.endpoint.me, 'user', include=include)", "response": "Return the logged in user"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve the user fields for this user.", "response": "def user_fields(self, user):\n        \"\"\"\n        Retrieve the user fields for this user.\n\n        :param user: User object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.user_fields, 'user_field', id=user)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving the organization memberships for this user.", "response": "def organization_memberships(self, user):\n        \"\"\"\n        Retrieve the organization memberships for this user.\n\n        :param user: User object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.organization_memberships, 'organization_membership', id=user)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef permanently_delete(self, user):\n        url = self._build_url(self.endpoint.deleted(id=user))\n        deleted_user = self._delete(url)\n        self.cache.delete(deleted_user)\n        return deleted_user", "response": "Permanently delete a user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef skips(self, user):\n        return self._get(self._build_url(self.endpoint.skips(id=user)))", "response": "Get the Skips for a user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the password for the passed user.", "response": "def set_password(self, user, password):\n        \"\"\"\n        Sets the password for the passed user.\n        Zendesk API `Reference <https://developer.zendesk.com/rest_api/docs/support/users#set-a-users-password>`__.\n\n        :param user: User object or id\n        :param password: new password\n        \"\"\"\n        url = self._build_url(self.endpoint.set_password(id=user))\n        return self._post(url, payload=dict(password=password))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef upload(self, fp, token=None, target_name=None, content_type=None):\n        return UploadRequest(self).post(fp, token=token, target_name=target_name, content_type=content_type)", "response": "Upload a file to Zendesk."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndownload an attachment from Zendesk.", "response": "def download(self, attachment_id, destination):\n        \"\"\"\n        Download an attachment from Zendesk.\n\n        :param attachment_id: id of the attachment to download\n        :param destination: destination path. If a directory, the file will be placed in the directory with\n                            the filename from the Attachment object.\n        :return: the path the file was written to\n        \"\"\"\n        attachment = self(id=attachment_id)\n        if os.path.isdir(destination):\n            destination = os.path.join(destination, attachment.file_name)\n        return self._download_file(attachment.content_url, destination)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves the organization fields for this organization.", "response": "def organization_fields(self, organization):\n        \"\"\"\n        Retrieve the organization fields for this organization.\n\n        :param organization: Organization object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.organization_fields, 'organization_field', id=organization)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving the tche organization fields for this organization.", "response": "def organization_memberships(self, organization):\n        \"\"\"\n        Retrieve tche organization fields for this organization.\n\n        :param organization: Organization object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.organization_memberships, 'organization_membership', id=organization)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef external(self, external_id, include=None):\n        return self._query_zendesk(self.endpoint.external, 'organization', id=external_id, include=include)", "response": "Locate an Organization by it s external_id attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing what a macro would do", "response": "def apply(self, macro):\n        \"\"\"\n        Show what a macro would do\n        Zendesk API `Reference <https://developer.zendesk.com/rest_api/docs/core/macros#show-changes-to-ticket>`__.\n\n        :param macro: Macro object or id.\n        \"\"\"\n\n        return self._query_zendesk(self.endpoint.apply, 'result', id=macro)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the tickets for this organization.", "response": "def organizations(self, organization, include=None):\n        \"\"\"\n        Retrieve the tickets for this organization.\n\n        :param include: list of objects to sideload. `Side-loading API Docs\n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param organization: Organization object or id\n        \"\"\"\n        return self._query_zendesk(self.endpoint.organizations, 'ticket', id=organization, include=include)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef recent(self, include=None):\n        return self._query_zendesk(self.endpoint.recent, 'ticket', id=None, include=include)", "response": "Retrieve the most recent tickets in this repository"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving the comments for a ticket.", "response": "def comments(self, ticket, include_inline_images=False):\n        \"\"\"\n        Retrieve the comments for a ticket.\n\n        :param ticket: Ticket object or id\n        :param include_inline_images: Boolean. If `True`, inline image attachments will be\n            returned in each comments' `attachments` field alongside non-inline attachments\n        \"\"\"\n        return self._query_zendesk(self.endpoint.comments, 'comment', id=ticket, include_inline_images=repr(include_inline_images).lower())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef permanently_delete(self, tickets):\n        endpoint_kwargs = dict()\n        if isinstance(tickets, collections.Iterable):\n            endpoint_kwargs['destroy_ids'] = [i.id for i in tickets]\n        else:\n            endpoint_kwargs['id'] = tickets.id\n        url = self._build_url(self.endpoint.deleted(**endpoint_kwargs))\n        deleted_ticket_job_id = self._delete(url)\n        self.cache.delete(tickets)\n        return deleted_ticket_job_id", "response": "Permanently delete a ticket."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving TicketEvents from the API.", "response": "def events(self, start_time, include=None):\n        \"\"\"\n        Retrieve TicketEvents\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param start_time: time to retrieve events from.\n        \"\"\"\n        return self._query_zendesk(self.endpoint.events, 'ticket_event', start_time=start_time, include=include)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving TicketAudits. If ticket is passed, return the tickets for a specific audit. If ticket_id is None, a TicketAuditGenerator is returned to handle pagination. The way this generator works is a different to the other Zenpy generators as it is cursor based, allowing you to change the direction that you are consuming objects. This is done with the reversed() python method. For example: .. code-block:: python for audit in reversed(zenpy_client.tickets.audits()): print(audit) See the `Zendesk docs <https://developer.zendesk.com/rest_api/docs/core/ticket_audits#pagination>`__ for information on additional parameters. :param include: list of objects to sideload. `Side-loading API Docs <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__. :param ticket: Ticket object or id", "response": "def audits(self, ticket=None, include=None, **kwargs):\n        \"\"\"\n        Retrieve TicketAudits. If ticket is passed, return the tickets for a specific audit.\n\n        If ticket_id is None, a TicketAuditGenerator is returned to handle pagination. The way this generator\n        works is a different to the other Zenpy generators as it is cursor based, allowing you to change the\n        direction that you are consuming objects. This is done with the reversed() python method.\n\n        For example:\n\n        .. code-block:: python\n\n            for audit in reversed(zenpy_client.tickets.audits()):\n                print(audit)\n\n        See the `Zendesk docs <https://developer.zendesk.com/rest_api/docs/core/ticket_audits#pagination>`__ for\n        information on additional parameters.\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param ticket: Ticket object or id\n        \"\"\"\n        if ticket is not None:\n            return self._query_zendesk(self.endpoint.audits, 'ticket_audit', id=ticket, include=include)\n        else:\n            return self._query_zendesk(self.endpoint.audits.cursor, 'ticket_audit', include=include, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef metrics(self, ticket):\n        return self._query_zendesk(self.endpoint.metrics, 'ticket_metric', id=ticket)", "response": "Retrieve TicketMetric.\n\n        :param ticket: Ticket object or id"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef metrics_incremental(self, start_time):\n        return self._query_zendesk(self.endpoint.metrics.incremental, 'ticket_metric_events', start_time=start_time)", "response": "Retrieve TicketMetric incremental from the API."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_macro_effect(self, ticket, macro):\n\n        url = self._build_url(self.endpoint.macro(ticket, macro))\n        macro_effect = self._get(url)\n        macro_effect._set_dirty()\n        return macro_effect", "response": "Show the macro effect of a ticket."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge(self, target, source,\n              target_comment=None, source_comment=None):\n        \"\"\"\n        Merge the ticket(s) or ticket ID(s) in source into the target ticket.\n\n        :param target: ticket id or object to merge tickets into\n        :param source: ticket id, object or list of tickets or ids to merge into target\n        :param source_comment: optional comment for the source ticket(s)\n        :param target_comment: optional comment for the target ticket\n\n        :return: a JobStatus object\n        \"\"\"\n        return TicketMergeRequest(self).post(target, source,\n                                             target_comment=target_comment,\n                                             source_comment=source_comment)", "response": "Merge the ticket ID in source into the target ticket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the Skips for a given ticket.", "response": "def skips(self, ticket):\n        \"\"\"\n        Skips for ticket See Zendesk API `Reference <https://developer.zendesk.com/rest_api/docs/core/ticket_skips>`__.\n        \"\"\"\n\n        return self._get(self._build_url(self.endpoint.skips(id=ticket)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show(self, ticket_field, custom_field_option):\n        return self._query_zendesk(self.endpoint.show, 'custom_field_option', ticket_field, custom_field_option)", "response": "Return a specific custom field option by its id"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow a variant. :param item: Item object or id :param variant: Variant object or id :return:", "response": "def show(self, item, variant):\n        \"\"\"\n        Show a variant.\n\n        :param item: Item object or id\n        :param variant: Variant object or id\n        :return:\n        \"\"\"\n        url = self._build_url(self.endpoint.show(item, variant))\n        return self._get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn comments for the given request.", "response": "def comments(self, request_id):\n        \"\"\"\n        Return comments for request\n        \"\"\"\n        return self._query_zendesk(self.endpoint.comments, 'comment', id=request_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for requests. See the `Zendesk docs <https://developer.zendesk.com/rest_api/docs/core/requests#searching-requests>`__ for more information on the syntax.", "response": "def search(self, *args, **kwargs):\n        \"\"\"\n        Search for requests. See the `Zendesk docs\n        <https://developer.zendesk.com/rest_api/docs/core/requests#searching-requests>`__ for more information on the\n        syntax.\n        \"\"\"\n        return self._query_zendesk(self.endpoint.search, 'request', *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef memberships(self, group, include=None):\n        return self._get(self._build_url(self.endpoint.memberships(id=group, include=include)))", "response": "Return the GroupMemberships for this group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef memberships_assignable(self, group, include=None):\n        return self._get(self._build_url(self.endpoint.memberships_assignable(id=group, include=include)))", "response": "Return the memberships that are assignable for this group."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef active(self, include=None):\n        return self._get(self._build_url(self.endpoint.active(include=include)))", "response": "Get all active views."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compact(self, include=None):\n        return self._get(self._build_url(self.endpoint.compact(include=include)))", "response": "Return compact views - See: Zendesk API `Reference\n        <https://developer.zendesk.com/rest_api/docs/core/views#list-views---compact>`__"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef execute(self, view, include=None):\n        return self._get(self._build_url(self.endpoint.execute(id=view, include=include)))", "response": "Execute a view.\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param view: View or view id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tickets(self, view, include=None):\n        return self._get(self._build_url(self.endpoint.tickets(id=view, include=include)))", "response": "Return the tickets in a view."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef count(self, view, include=None):\n        return self._get(self._build_url(self.endpoint.count(id=view, include=include)))", "response": "Return a ViewCount for a view."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn many ViewCounts. :param include: list of objects to sideload. `Side-loading API Docs <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__. :param views: iterable of View or view ids", "response": "def count_many(self, views, include=None):\n        \"\"\"\n        Return many ViewCounts.\n\n        :param include: list of objects to sideload. `Side-loading API Docs \n            <https://developer.zendesk.com/rest_api/docs/core/side_loading>`__.\n        :param views: iterable of View or view ids\n        \"\"\"\n        return self._get(self._build_url(self.endpoint(count_many=views, include=include)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef export(self, view, include=None):\n        return self._get(self._build_url(self.endpoint.export(id=view, include=include)))", "response": "Returns an Export object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches views. See Zendesk API `Reference <https://developer.zendesk.com/rest_api/docs/core/views#search-views>`__. :param args: query is the only accepted arg. :param kwargs: search parameters", "response": "def search(self, *args, **kwargs):\n        \"\"\"\n        Search views. See Zendesk API `Reference <https://developer.zendesk.com/rest_api/docs/core/views#search-views>`__.\n\n        :param args: query is the only accepted arg.\n        :param kwargs: search parameters\n        \"\"\"\n        return self._get(self._build_url(self.endpoint.search(*args, **kwargs)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the passed GroupMembership as default for the specified user.", "response": "def make_default(self, user, group_membership):\n        \"\"\"\n        Set the passed GroupMembership as default for the specified user.\n\n        :param user: User object or id\n        :param group_membership: GroupMembership object or id\n        \"\"\"\n        return self._put(self._build_url(self.endpoint.make_default(user, group_membership)), payload={})"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an Article in a Section", "response": "def create(self, section, article):\n        \"\"\"\n        Create (POST) an Article - See: Zendesk API `Reference\n        <https://developer.zendesk.com/rest_api/docs/help_center/articles#create-article>`__.\n\n        :param section: Section ID or object\n        :param article: Article to create\n        \"\"\"\n        return CRUDRequest(self).post(article, create=True, id=section)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving comments for an article.", "response": "def comments(self, article):\n        \"\"\"\n        Retrieve comments for an article\n\n        :param article: Article ID or object\n        \"\"\"\n        return self._query_zendesk(self.endpoint.comments, object_type='comment', id=article)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inline(self, article):\n        return self._query_zendesk(self.endpoint.inline, 'article_attachment', id=article)", "response": "Get all inline attachments associated with article_id where inline = True flag is set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget all block attachments associated with article_id.", "response": "def block(self, article):\n        \"\"\"\n        Returns all block attachments associated with article_id (Such attachments has ``inline=False``).\n\n        Block attachments are displayed as separated files attached to Article.\n\n        :param article: Numeric article id or :class:`Article` object.\n        :return: Generator with all associated block attachments.\n        \"\"\"\n        return self._query_zendesk(self.endpoint.block, 'article_attachment', id=article)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bulk_attachments(self, article, attachments):\n        return HelpdeskAttachmentRequest(self).post(self.endpoint.bulk_attachments, article=article,\n                                                    attachments=attachments)", "response": "This function implements associating attachments to an article after article creation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving NPS Recipients incremental", "response": "def recipients_incremental(self, start_time):\n        \"\"\"\n        Retrieve NPS Recipients incremental\n\n        :param start_time: time to retrieve events from.\n        \"\"\"\n        return self._query_zendesk(self.endpoint.recipients_incremental, 'recipients', start_time=start_time)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve NPS Responses incremental", "response": "def responses_incremental(self, start_time):\n        \"\"\"\n        Retrieve NPS Responses incremental\n\n        :param start_time: time to retrieve events from.\n        \"\"\"\n        return self._query_zendesk(self.endpoint.responses_incremental, 'responses', start_time=start_time)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping an element in a ProxyList or ProxyDict.", "response": "def _wrap_element(self, element):\n        \"\"\"\n        We want to know if an item is modified that is stored in this dict. If the element is a list or dict,\n        we wrap it in a ProxyList or ProxyDict, and if it is modified execute a callback that updates this\n        instance. If it is a ZenpyObject, then the callback updates the parent object.\n        \"\"\"\n\n        def dirty_callback():\n            self._set_dirty()\n\n        if isinstance(element, list):\n            element = ProxyList(element, dirty_callback=dirty_callback)\n        elif isinstance(element, dict):\n            element = ProxyDict(element, dirty_callback=dirty_callback)\n        # If it is a Zenpy object this will either return None or the previous wrapper.\n        elif getattr(element, '_dirty_callback', self._sentinel) is not self._sentinel:\n            # Don't set callback if already set.\n            if not callable(element._dirty_callback):\n                element._dirty_callback = dirty_callback\n        return element"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_pagination(self, page_num=None, page_size=None):\n        self._response_json = self.get_next_page(page_num=page_num, page_size=page_size)\n        self.update_attrs()\n        self.position = 0\n        self.values = self.process_page()", "response": "Handle retrieving and processing the next page of results."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the attributes of the resource object.", "response": "def update_attrs(self):\n        \"\"\" Add attributes such as count/end_time that can be present \"\"\"\n        for key, value in self._response_json.items():\n            if key != 'results' and type(value) not in (list, dict):\n                setattr(self, key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve the next page of results.", "response": "def get_next_page(self, page_num, page_size):\n        \"\"\" Retrieve the next page of results. \"\"\"\n        url = self._response_json.get(self.next_page_attr, None)\n        if url is None:\n            raise StopIteration()\n        params, url = self.process_url(page_num, page_size, url)\n        response = self.response_handler.api._get(url, raw_response=True, params=params)\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_url(self, page_num, page_size, url):\n        params = dict()\n        if page_num is not None:\n            url = re.sub('page=\\d+', '', url)\n            params['page'] = page_num\n        if page_size is not None:\n            url = re.sub('per_page=\\d+', '', url)\n            params['per_page'] = page_size\n        return params, url", "response": "When slicing remove the per_page and page parameters and pass to requests in the params dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef author(self):\n        if self.api and self.author_id:\n            return self.api._get_user(self.author_id)", "response": "Returns the user who wrote the article"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the section object that this article belongs to.", "response": "def section(self):\n        \"\"\"\n        |  Comment: The id of the section to which this article belongs\n        \"\"\"\n        if self.api and self.section_id:\n            return self.api._get_section(self.section_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef article(self):\n        if self.api and self.article_id:\n            return self.api._get_article(self.article_id)", "response": "Return the article object associated with the article."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef topic(self):\n        if self.api and self.topic_id:\n            return self.api._get_topic(self.topic_id)", "response": "Returns the topic that the post belongs to"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef category(self):\n        if self.api and self.category_id:\n            return self.api._get_category(self.category_id)", "response": "Return the category of the section"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef user_segment(self):\n        if self.api and self.user_segment_id:\n            return self.api._get_user_segment(self.user_segment_id)", "response": "Return the user segment that this section belongs to."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the user who has this subscription", "response": "def user(self):\n        \"\"\"\n        |  Comment: The id of the user who has this subscription\n        \"\"\"\n        if self.api and self.user_id:\n            return self.api._get_user(self.user_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the id of the user who created the translation", "response": "def created_by(self):\n        \"\"\"\n        |  Comment: The id of the user who created the translation\n        \"\"\"\n        if self.api and self.created_by_id:\n            return self.api._get_user(self.created_by_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the id of the user who last updated the translation", "response": "def updated_by(self):\n        \"\"\"\n        |  Comment: The id of the user who last updated the translation\n        \"\"\"\n        if self.api and self.updated_by_id:\n            return self.api._get_user(self.updated_by_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef organizations(self):\n        if self.api and self.organization_ids:\n            return self.api._get_organizations(self.organization_ids)", "response": "Returns a list of organizations that have access to this resource"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn self formatted as JSON.", "response": "def to_json(self, indent=2):\n        \"\"\" Return self formatted as JSON. \"\"\"\n        return json.dumps(self, default=json_encode_for_printing, indent=indent)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the group object for this entry", "response": "def group(self):\n        \"\"\"\n        |  Comment: The id of a group\n        \"\"\"\n        if self.api and self.group_id:\n            return self.api._get_group(self.group_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the organization associated with this user", "response": "def organization(self):\n        \"\"\"\n        |  Comment: The ID of the organization associated with this user, in this membership\n        \"\"\"\n        if self.api and self.organization_id:\n            return self.api._get_organization(self.organization_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the user who assigned the field to", "response": "def assignee(self):\n        \"\"\"\n        |  Comment: The id of the assignee if the field is visible to end users\n        \"\"\"\n        if self.api and self.assignee_id:\n            return self.api._get_user(self.assignee_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collaborators(self):\n        if self.api and self.collaborator_ids:\n            return self.api._get_users(self.collaborator_ids)", "response": "Return a list of collaborators."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the user who has the requester", "response": "def requester(self):\n        \"\"\"\n        |  Comment: The id of the requester\n        \"\"\"\n        if self.api and self.requester_id:\n            return self.api._get_user(self.requester_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef forum_topic(self):\n        if self.api and self.forum_topic_id:\n            return self.api._get_topic(self.forum_topic_id)", "response": "Returns the topic this ticket originated from."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the problem object for this ticket", "response": "def problem(self):\n        \"\"\"\n        |  Comment: For tickets of type \"incident\", the ID of the problem the incident is linked to\n        \"\"\"\n        if self.api and self.problem_id:\n            return self.api._get_problem(self.problem_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of ids of the sharing agreements used for this ticket.", "response": "def sharing_agreements(self):\n        \"\"\"\n        |  Comment: The ids of the sharing agreements used for this ticket\n        \"\"\"\n        if self.api and self.sharing_agreement_ids:\n            return self.api._get_sharing_agreements(self.sharing_agreement_ids)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef submitter(self):\n        if self.api and self.submitter_id:\n            return self.api._get_user(self.submitter_id)", "response": "The user who submitted the ticket."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef restricted_brands(self):\n        if self.api and self.restricted_brand_ids:\n            return self.api._get_restricted_brands(self.restricted_brand_ids)", "response": "Returns a list of restricted brands that this ticket form is restricted to."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all ticket fields in this ticket form", "response": "def ticket_fields(self):\n        \"\"\"\n        |  Comment: ids of all ticket fields which are in this ticket form\n        \"\"\"\n        if self.api and self.ticket_field_ids:\n            return self.api._get_ticket_fields(self.ticket_field_ids)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlocates and deserialize all objects in the returned JSON.", "response": "def deserialize(self, response_json):\n        \"\"\"\n        Locate and deserialize all objects in the returned JSON.\n\n        Return a dict keyed by object_type. If the key is plural, the value will be a list,\n        if it is singular, the value will be an object of that type.\n        :param response_json:\n        \"\"\"\n        response_objects = dict()\n        if all((t in response_json for t in ('ticket', 'audit'))):\n            response_objects[\"ticket_audit\"] = self.object_mapping.object_from_json(\n                \"ticket_audit\",\n                response_json\n            )\n\n        # Locate and store the single objects.\n        for zenpy_object_name in self.object_mapping.class_mapping:\n            if zenpy_object_name in response_json:\n                zenpy_object = self.object_mapping.object_from_json(\n                    zenpy_object_name,\n                    response_json[zenpy_object_name]\n                )\n                response_objects[zenpy_object_name] = zenpy_object\n\n        # Locate and store the collections of objects.\n        for key, value in response_json.items():\n            if isinstance(value, list):\n                zenpy_object_name = as_singular(key)\n                if zenpy_object_name in self.object_mapping.class_mapping:\n                    response_objects[key] = []\n                    for object_json in response_json[key]:\n                        zenpy_object = self.object_mapping.object_from_json(\n                            zenpy_object_name,\n                            object_json\n                        )\n                        response_objects[key].append(zenpy_object)\n        return response_objects"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build(self, response):\n        response_json = response.json()\n\n        # Special case for ticket audits.\n        if get_endpoint_path(self.api, response).startswith('/ticket_audits.json'):\n            return TicketAuditGenerator(self, response_json)\n\n        zenpy_objects = self.deserialize(response_json)\n\n        # Collection of objects (eg, users/tickets)\n        plural_object_type = as_plural(self.api.object_type)\n        if plural_object_type in zenpy_objects:\n            return ZendeskResultGenerator(self, response_json, response_objects=zenpy_objects[plural_object_type])\n\n        # Here the response matches the API object_type, seems legit.\n        if self.api.object_type in zenpy_objects:\n            return zenpy_objects[self.api.object_type]\n\n        # Could be anything, if we know of this object then return it.\n        for zenpy_object_name in self.object_mapping.class_mapping:\n            if zenpy_object_name in zenpy_objects:\n                return zenpy_objects[zenpy_object_name]\n\n        # Maybe a collection of known objects?\n        for zenpy_object_name in self.object_mapping.class_mapping:\n            plural_zenpy_object_name = as_plural(zenpy_object_name)\n            if plural_zenpy_object_name in zenpy_objects:\n                return ZendeskResultGenerator(self, response_json, object_type=plural_zenpy_object_name)\n\n        # Bummer, bail out.\n        raise ZenpyException(\"Unknown Response: \" + str(response_json))", "response": "Deserialize the returned objects and return either a single Zenpy object or a ResultGenerator in the case of multiple results."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_cache_impl(self, cache_impl, maxsize, **kwargs):\n        new_cache = self._get_cache_impl(cache_impl, maxsize, **kwargs)\n        self._populate_new_cache(new_cache)\n        self.cache = new_cache", "response": "Change the cache implementation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_maxsize(self, maxsize, **kwargs):\n        new_cache = self._get_cache_impl(self.impl_name, maxsize, **kwargs)\n        self._populate_new_cache(new_cache)\n        self.cache = new_cache", "response": "Set maxsize of the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a Zenpy object to the relevant cache.", "response": "def add(self, zenpy_object):\n        \"\"\" Add a Zenpy object to the relevant cache. If no cache exists for this object nothing is done. \"\"\"\n        object_type = get_object_type(zenpy_object)\n        if object_type not in self.mapping or self.disabled:\n            return\n        attr_name = self._cache_key_attribute(object_type)\n        cache_key = getattr(zenpy_object, attr_name)\n        log.debug(\"Caching: [{}({}={})]\".format(zenpy_object.__class__.__name__, attr_name, cache_key))\n        self.mapping[object_type][cache_key] = zenpy_object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes one or more items from the relevant caches", "response": "def delete(self, to_delete):\n        \"\"\" Purge one or more items from the relevant caches \"\"\"\n        if not isinstance(to_delete, list):\n            to_delete = [to_delete]\n        for zenpy_object in to_delete:\n            object_type = get_object_type(zenpy_object)\n            object_cache = self.mapping.get(object_type, None)\n            if object_cache:\n                removed_object = object_cache.pop(zenpy_object.id, None)\n                if removed_object:\n                    log.debug(\"Cache RM: [%s %s]\" % (object_type.capitalize(), zenpy_object.id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, object_type, cache_key):\n        if object_type not in self.mapping or self.disabled:\n            return None\n        cache = self.mapping[object_type]\n        if cache_key in cache:\n            log.debug(\"Cache HIT: [%s %s]\" % (object_type.capitalize(), cache_key))\n            return cache[cache_key]\n        else:\n            log.debug('Cache MISS: [%s %s]' % (object_type.capitalize(), cache_key))", "response": "Query the cache for a Zenpy object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef query_cache_by_object(self, zenpy_object):\n        object_type = get_object_type(zenpy_object)\n        cache_key = self._cache_key_attribute(object_type)\n        return self.get(object_type, getattr(zenpy_object, cache_key))", "response": "Query the cache for a given object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef purge_cache(self, object_type):\n        if object_type in self.mapping:\n            cache = self.mapping[object_type]\n            log.debug(\"Purging [{}] cache of {} values.\".format(object_type, len(cache)))\n            cache.purge()", "response": "Purge the named cache of all values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef in_cache(self, zenpy_object):\n        object_type = get_object_type(zenpy_object)\n        cache_key_attr = self._cache_key_attribute(object_type)\n        return self.get(object_type, getattr(zenpy_object, cache_key_attr)) is not None", "response": "Determines whether or not this object is in the cache"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprovide Zenpy s default HTTPAdapter args for those users providing their own adapter.", "response": "def http_adapter_kwargs():\n        \"\"\"\n        Provides Zenpy's default HTTPAdapter args for those users providing their own adapter.\n        \"\"\"\n\n        return dict(\n            # Transparently retry requests that are safe to retry, with the exception of 429. This is handled\n            # in the Api._call_api() method.\n            max_retries=Retry(\n                total=3,\n                status_forcelist=[r for r in Retry.RETRY_AFTER_STATUS_CODES if r != 429],\n                respect_retry_after_header=False\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the maxsize attribute of the named cache.", "response": "def set_cache_max(self, cache_name, maxsize, **kwargs):\n        \"\"\"\n        Sets the maxsize attribute of the named cache\n        \"\"\"\n        cache = self._get_cache(cache_name)\n        cache.set_maxsize(maxsize, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nchange the cache implementation for the named cache_name", "response": "def set_cache_implementation(self, cache_name, impl_name, maxsize, **kwargs):\n        \"\"\"\n        Changes the cache implementation for the named cache\n        \"\"\"\n        self._get_cache(cache_name).set_cache_impl(impl_name, maxsize, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new cache for the named object type and cache implementation", "response": "def add_cache(self, object_type, cache_impl_name, maxsize, **kwargs):\n        \"\"\"\n        Add a new cache for the named object type and cache implementation\n        \"\"\"\n        if object_type not in ZendeskObjectMapping.class_mapping:\n            raise ZenpyException(\"No such object type: %s\" % object_type)\n        self.cache.mapping[object_type] = ZenpyCache(cache_impl_name, maxsize, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a blob of JSON representing a Zenpy object and a parent object return the object.", "response": "def object_from_json(self, object_type, object_json, parent=None):\n        \"\"\"\n        Given a blob of JSON representing a Zenpy object, recursively deserialize it and\n         any nested objects it contains. This method also adds the deserialized object\n         to the relevant cache if applicable.\n        \"\"\"\n        if not isinstance(object_json, dict):\n            return object_json\n        obj = self.instantiate_object(object_type, parent)\n        for key, value in object_json.items():\n            if key not in self.skip_attrs:\n                key, value = self._deserialize(key, obj, value)\n            if isinstance(value, dict):\n                value = ProxyDict(value, dirty_callback=getattr(\n                    obj, '_dirty_callback', None))\n            elif isinstance(value, list):\n                value = ProxyList(value, dirty_callback=getattr(\n                    obj, '_dirty_callback', None))\n            setattr(obj, key, value)\n        if hasattr(obj, '_clean_dirty'):\n            obj._clean_dirty()\n        self.api.cache.add(obj)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef class_for_type(self, object_type):\n        if object_type not in self.class_mapping:\n            raise ZenpyException(\"Unknown object_type: \" + str(object_type))\n        else:\n            return self.class_mapping[object_type]", "response": "Returns the class associated with an object_type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dict with a key for each value of field and the first record with that value as value.", "response": "def index_by(self, field):\n        \"\"\"\n        Returns a dict with a key for each value of `field` and the first record with that value as value.\n        :param field: Name of the field to index by.\n        :type field: string.\n        \"\"\"\n        values = self[field].unique()\n        results = {}\n        for value in values:\n            results[value] = self.model_class(**self[self[field] == value].iloc[0])\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef destroy(self, force=False):\n        if self.persisted:\n            if self.soft_delete and not force:\n                self.__class__.update(\n                    values={\n                        self.__class__.deleted_at_column(): datetime.utcnow()\n                        },\n                    where=self.where_self\n                    )\n            else:\n                self.__class__.delete(\n                    where=self.where_self,\n                    skip_soft_delete=True\n                    )\n        else:\n            raise RecordNotPersisted(\"Record's primary key is None\")", "response": "Deletes the record. If the model has ``soft_delete`` activated, the record will not actually be deleted.\n\n        :param force: forces the record to be actually deleted if ``soft_delete`` is activated.\n        :type force: boolean"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms a SELECT statement on the replica database.", "response": "def select(self, **kwargs):\n        #select='*', where=None, inner_joins=None, left_joins=None, \n        #group=None, order=None, limit=None, db=None, role='replica'):\n        \"\"\"\n        Perform a SELECT statement on the model's table in the replica database.\n\n        :param select: Columns to return in the SELECT statement.\n        :type select: string, array, dict\n        :param where: WHERE clause of the SELECT statement. This can be a plain string, a dict or an array.\n        :type where: string, dict, array\n        :param inner_joins: Specifies an INNER JOIN clause. Can be a plain string (without the INNER JOIN part), an array of strings or an array of classes if the relationship was defined in the model.\n        :type inner_joins: string, array\n        :param left_joins: Specifies an LEFT JOIN clause. Can be a plain string (without the LEFT JOIN part), an array of strings or an array of classes if the relationship was defined in the model.\n        :type left_joins: string, array\n        :param group: Specifies a GROUP BY clause.\n        :type group: string\n        :param having: Specifies a HAVING clause.\n        :type having: string\n        :param order: ORDER BY clause.\n        :type order: string\n        :param limit: LIMIT clause.\n        :type limit: integer\n        :param db: Database name from your ``jardin_conf.py``, overrides the default database set in the model declaration.\n        :type db: string\n        :param role: One of ``('master', 'replica')`` to override the default.\n        :type role: string\n        :returns: ``jardin.Collection`` instance, which is a ``pandas.DataFrame``.\n        \"\"\"\n        db_adapter = self.db_adapter(\n            db_name=kwargs.get('db'),\n            role=kwargs.get('role', 'replica')\n            )\n\n        kwargs['stack'] = self.stack_mark(\n            inspect.stack(),\n            db_conn=db_adapter.db\n            )\n\n        return self.collection_instance(db_adapter.select(**kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef query(self, sql=None, filename=None, **kwargs):\n        results = query(\n            sql=sql,\n            filename=filename,\n            db=self.db_names[kwargs.get('role', 'replica')],\n            **kwargs\n            )\n\n        if results is None:\n            return None\n        else:\n            return self.collection_instance(results)", "response": "run raw sql from sql or file to get the database name and role from the model declaration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the number of entries in the replica database.", "response": "def count(self, **kwargs):\n        \"\"\"\n        Performs a COUNT statement on the model's table in the replica database.\n\n        :param select: Column to be counted.\n        :type select: string\n        :param where: WHERE clause of the SELECT statement. This can be a plain string, a dict or an array.\n        :type where: string, dict, array\n        :param db: Database name from your ``jardin_conf.py``, overrides the default database set in the model declaration.\n        :type db: string\n        :param role: One of ``('master', 'replica')`` to override the default.\n        :type role: string\n        :returns: integer\n        \"\"\"\n        if 'select' in kwargs:\n            kwargs['select'] = {'cnt': 'COUNT(%s)' % kwargs['select']}\n        else:\n            kwargs['select'] = {'cnt': 'COUNT(*)'}\n\n        res = self.db_adapter(\n            db_name=kwargs.get('db'),\n            role=kwargs.get('role', 'replica')\n            ).select(**kwargs)\n        return res.cnt[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insert(self, **kwargs):\n        if len(kwargs['values']) == 0:\n            config.logger.warning('No values to insert.')\n            return\n        values = kwargs['values']\n        if isinstance(values, self):\n            values = values.attributes.copy()\n        if isinstance(values, dict):\n            for (k, v) in values.items():\n                if v is None:\n                    del kwargs['values'][k]\n        kwargs['stack'] = self.stack_mark(inspect.stack())\n        kwargs['primary_key'] = self.primary_key\n        column_names = self.table_schema().keys()\n        now = datetime.utcnow()\n        for field in ('created_at', 'updated_at'):\n            if field in column_names:\n                kwargs['values'][field] = now\n        results = self.db_adapter(role='master').insert(**kwargs)\n        return self.record_or_model(results)", "response": "Performs an INSERT statement on the master database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, **kwargs):\n        kwargs['stack'] = self.stack_mark(inspect.stack())\n        kwargs['primary_key'] = self.primary_key\n        column_names = self.table_schema().keys()\n        now = datetime.utcnow()\n        if 'updated_at' in column_names:\n            kwargs['values']['updated_at'] = now\n        results = self.db_adapter(role='master').update(**kwargs)\n        return self.record_or_model(results)", "response": "Performs an UPDATE statement on the master database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nperforming a DELETE statement on the master database.", "response": "def delete(self, **kwargs):\n        \"\"\"\n        Performs a DELETE statement on the model's table in the master database.\n\n        :param where: The WHERE clause. This can be a plain string, a dict or an array.\n        :type where: string, dict, array\n        \"\"\"\n        kwargs['stack'] = self.stack_mark(inspect.stack())\n        \n        return self.db_adapter(role='master').delete(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the last limit records inserted in the replica database.", "response": "def last(self, limit=1, **kwargs):\n        \"\"\"\n        Returns the last `limit` records inserted in the model's table in the replica database. Rows are sorted by ``created_at``.\n        \"\"\"\n        return self.collection_instance(\n            self.db_adapter(\n                db_name=kwargs.get('db'),\n                role=kwargs.get('role', 'replica')\n                ).select(\n                    where='created_at IS NOT NULL',\n                    order='created_at DESC',\n                    limit=limit\n                    )\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a single record matching the criteria in values in the replica database.", "response": "def find_by(self, values={}, **kwargs):\n        \"\"\"\n        Returns a single record matching the criteria in ``values`` found in the model's table in the replica database.\n\n        :param values: Criteria to find the record.\n        :type values: dict\n        :returns: an instance of the model.\n        \"\"\"\n        try:\n            return self(\n                **self.select(\n                    where=values,\n                    limit=1,\n                    **kwargs\n                    ).to_dict(orient='records')[0]\n                )\n        except IndexError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding a record by its id in the replica database.", "response": "def find(self, id, **kwargs):\n        \"\"\"\n        Finds a record by its id in the model's table in the replica database.\n        :returns: an instance of the model.\n        \"\"\"\n        return self.find_by(values={self.primary_key: id}, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the current replication lag in seconds between the master and replica databases.", "response": "def replica_lag(self, **kwargs):\n        \"\"\"\n        Returns the current replication lag in seconds between the master and replica databases.\n\n        :returns: float\n        \"\"\"\n        if not self._use_replica():\n            return 0\n        try:\n            kwargs['stack'] = self.stack_mark(inspect.stack())\n            sql = \"select EXTRACT(EPOCH FROM NOW() - pg_last_xact_replay_timestamp()) AS replication_lag\"\n            return self.collection_instance(\n                self.db_adapter().raw_query(\n                    sql=sql, **kwargs\n                    )\n                ).squeeze()\n        except:\n            return 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the table schema for the current user.", "response": "def table_schema(self):\n        \"\"\"\n        Returns the table schema.\n\n        :returns: dict\n        \"\"\"\n        if self.__dict__.get('_table_schema') is None:\n            self._table_schema = None\n            table_schema = {}\n            for row in self.query_schema():\n                name, default, dtype = self.db().lexicon.column_info(row)\n                if isinstance(default, str):\n                    json_matches = re.findall(r\"^\\'(.*)\\'::jsonb$\", default)\n                    if len(json_matches) > 0:\n                        default = json.loads(json_matches[0])\n                if name == self.primary_key:\n                    default = None\n                table_schema[name] = {'default': default, 'type': dtype}\n            if len(table_schema):\n                self._table_schema = table_schema\n        return self._table_schema"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretries calling the decorated function using an exponential backoff. original from: http://wiki.python.org/moin/PythonDecoratorLibrary#Retry :param ExceptionToCheck: the exception to check. may be a tuple of exceptions to check :type ExceptionToCheck: Exception or tuple :param tries: number of times to try (not retry) before giving up :type tries: int :param delay: initial delay between retries in seconds :type delay: int :param backoff: backoff multiplier e.g. value of 2 will double the delay each retry :type backoff: int :param logger: logger to use. If None, print :type logger: logging.Logger instance", "response": "def retry(ExceptionToCheck, tries=4, delay=3, backoff=2, logger=None):\n    \"\"\"Retry calling the decorated function using an exponential backoff.\n    original from: http://wiki.python.org/moin/PythonDecoratorLibrary#Retry\n\n    :param ExceptionToCheck: the exception to check. may be a tuple of\n        exceptions to check\n    :type ExceptionToCheck: Exception or tuple\n    :param tries: number of times to try (not retry) before giving up\n    :type tries: int\n    :param delay: initial delay between retries in seconds\n    :type delay: int\n    :param backoff: backoff multiplier e.g. value of 2 will double the delay\n        each retry\n    :type backoff: int\n    :param logger: logger to use. If None, print\n    :type logger: logging.Logger instance\n    \"\"\"\n    def deco_retry(f):\n\n        @wraps(f)\n        def f_retry(*args, **kwargs):\n            mtries, mdelay = tries, delay\n            while mtries > 1:\n                try:\n                    return f(*args, **kwargs)\n                except ExceptionToCheck as e:\n                    msg = \"%s, Retrying in %d seconds...\" % (str(e), mdelay)\n                    if logger:\n                        logger.warning(msg)\n                    else:\n                        print(msg)\n                    time.sleep(mdelay)\n                    mtries -= 1\n                    mdelay *= backoff\n            return f(*args, **kwargs)\n\n        return f_retry  # true decorator\n\n    return deco_retry"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_vertex_buffer(self, fd, material, length):\n        material.vertices = struct.unpack('{}f'.format(length // 4), fd.read(length))", "response": "Loads the vertex data from file and stores it in the material."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _load_vertex_buffers(self):\n        fd = gzip.open(cache_name(self.file_name), 'rb')\n\n        for buff in self.meta.vertex_buffers:\n\n            mat = self.wavefront.materials.get(buff['material'])\n            if not mat:\n                mat = Material(name=buff['material'], is_default=True)\n                self.wavefront.materials[mat.name] = mat\n\n            mat.vertex_format = buff['vertex_format']\n            self.load_vertex_buffer(fd, mat, buff['byte_length'])\n\n        fd.close()", "response": "Load each vertex buffer into each material"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_mtllibs(self):\n        for mtllib in self.meta.mtllibs:\n            try:\n                materials = self.material_parser_cls(\n                    os.path.join(self.path, mtllib),\n                    encoding=self.encoding,\n                    strict=self.strict).materials\n            except IOError:\n                raise IOError(\"Failed to load mtl file:\".format(os.path.join(self.path, mtllib)))\n\n            for name, material in materials.items():\n                self.wavefront.materials[name] = material", "response": "Load mtl files and parse them into self. wavefront. materials."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a vertex buffer to the list of vertex buffers.", "response": "def add_vertex_buffer(self, material, vertex_format, byte_offset, byte_length):\n        \"\"\"Add a vertex buffer\"\"\"\n        self._vertex_buffers.append({\n            \"material\": material,\n            \"vertex_format\": vertex_format,\n            \"byte_offset\": byte_offset,\n            \"byte_length\": byte_length,\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the metadata as json", "response": "def write(self, path):\n        \"\"\"Save the metadata as json\"\"\"\n        with open(path, 'w') as fd:\n            fd.write(json.dumps(\n                {\n                    \"created_at\": self._created_at,\n                    \"version\": self._version,\n                    \"mtllibs\": self._mtllibs,\n                    \"vertex_buffers\": self._vertex_buffers,\n                },\n                indent=2,\n            ))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_material(self, new_material):\n        for material in self.materials:\n            if material.name == new_material.name:\n                return True\n\n        return False", "response": "Determine whether we already have a material of this name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_material(self, material):\n        if self.has_material(material):\n            return\n\n        self.materials.append(material)", "response": "Add a material to the mesh IF it s not already present."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef auto_consume(func):\n    def inner(*args, **kwargs):\n        func(*args, **kwargs)\n        args[0].consume_line()\n    return inner", "response": "Decorator for auto consuming lines when leaving the function"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_line_generator(self):\n\n        if self.file_name.endswith(\".gz\"):\n            if sys.version_info.major == 3:\n                gz = gzip.open(self.file_name, mode='rt', encoding=self.encoding)\n            else:\n                gz = gzip.open(self.file_name, mode='rt')\n\n            for line in gz.readlines():\n                yield line\n\n            gz.close()\n        else:\n            if sys.version_info.major == 3:\n                # Python 3 native `open` is much faster\n                file = open(self.file_name, mode='r', encoding=self.encoding)\n            else:\n                # Python 2 needs the codecs package to deal with encoding\n                file = codecs.open(self.file_name, mode='r', encoding=self.encoding)\n\n            for line in file:\n                yield line\n\n            file.close()", "response": "Creates a generator function yielding lines in the file\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next_line(self):\n        self.line = next(self.lines)  # Will raise StopIteration when there are no more lines\n        self.values = self.line.split()", "response": "Read the next line from the line generator and split it"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(self):\n        try:\n            # Continues until `next_line()` raises StopIteration\n            # This can trigger here or in parse functions in the subclass\n            while True:\n                # Only advance the parser if the previous line was consumed.\n                # Parse functions reading multiple lines can end up reading one line too far,\n                # so they return without consuming the line and we pick it up here\n                if not self.line:\n                    self.next_line()\n\n                if self.line[0] == '#' or len(self.values) < 2:\n                    self.consume_line()\n                    continue\n\n                self.dispatcher.get(self.values[0], self.parse_fallback)()\n        except StopIteration:\n            pass\n\n        if self.auto_post_parse:\n            self.post_parse()", "response": "Parse all the lines in the obj file and dispatch appropriately."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_fallback(self):\n        if self.strict:\n            raise PywavefrontException(\"Unimplemented OBJ format statement '%s' on line '%s'\"\n                                       % (self.values[0], self.line.rstrip()))\n        else:\n            logger.warning(\"Unimplemented OBJ format statement '%s' on line '%s'\"\n                            % (self.values[0], self.line.rstrip()))", "response": "Fallback method when parser doesn t know the statement"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _build_dispatch_map(self):\n        return {\"_\".join(a.split(\"_\")[1:]): getattr(self, a)\n                for a in dir(self)\n                if a.startswith(\"parse_\")}", "response": "Build a dispatch map that maps parse names to functions that are used to dispatch to the parse methods."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef draw_material(material, face=GL_FRONT_AND_BACK):\n    if material.gl_floats is None:\n        material.gl_floats = (GLfloat * len(material.vertices))(*material.vertices)\n        material.triangle_count = len(material.vertices) / material.vertex_size\n\n    vertex_format = VERTEX_FORMATS.get(material.vertex_format)\n    if not vertex_format:\n        raise ValueError(\"Vertex format {} not supported by pyglet\".format(material.vertex_format))\n\n    glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)\n    glPushAttrib(GL_CURRENT_BIT | GL_ENABLE_BIT | GL_LIGHTING_BIT)\n    glEnable(GL_CULL_FACE)\n    glCullFace(GL_BACK)\n\n    # Fall back to ambient texture if no diffuse\n    texture = material.texture or material.texture_ambient\n    if texture and material.has_uvs:\n        bind_texture(texture)\n    else:\n        glDisable(GL_TEXTURE_2D)\n\n    glMaterialfv(face, GL_DIFFUSE, gl_light(material.diffuse))\n    glMaterialfv(face, GL_AMBIENT, gl_light(material.ambient))\n    glMaterialfv(face, GL_SPECULAR, gl_light(material.specular))\n    glMaterialfv(face, GL_EMISSION, gl_light(material.emissive))\n    glMaterialf(face, GL_SHININESS, min(128.0, material.shininess))\n    glEnable(GL_LIGHT0)\n\n    if material.has_normals:\n        glEnable(GL_LIGHTING)\n    else:\n        glDisable(GL_LIGHTING)\n\n    glInterleavedArrays(vertex_format, 0, material.gl_floats)\n    glDrawArrays(GL_TRIANGLES, 0, int(material.triangle_count))\n\n    glPopAttrib()\n    glPopClientAttrib()", "response": "Draw a single material"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bind_texture(texture):\n    if not getattr(texture, 'image', None):\n        texture.image = load_image(texture.path)\n\n    glEnable(texture.image.target)\n    glBindTexture(texture.image.target, texture.image.id)\n    gl.glTexParameterf(texture.image.target,\n                       gl.GL_TEXTURE_WRAP_S, gl.GL_CLAMP_TO_EDGE)\n    gl.glTexParameterf(texture.image.target,\n                       gl.GL_TEXTURE_WRAP_T, gl.GL_CLAMP_TO_EDGE)", "response": "Draw a single texture"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload an image and verify its dimensions", "response": "def load_image(name):\n    \"\"\"Load an image\"\"\"\n    image = pyglet.image.load(name).texture\n    verify_dimensions(image)\n    return image"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pad_light(self, values):\n        while len(values) < 4:\n            values.append(0.)\n\n        return list(map(float, values))", "response": "Accept an array of up to 4 values and return an array of 4 values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_alpha(self, alpha):\n        self.transparency = alpha\n        self.diffuse[3] = alpha\n        self.ambient[3] = alpha\n        self.specular[3] = alpha\n        self.emissive[3] = alpha", "response": "Set alpha value on all four lighting attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_map_Kd(self):\n        Kd = os.path.join(self.dir, \" \".join(self.values[1:]))\n        self.this_material.set_texture(Kd)", "response": "Parse the diffuse map file and set the texture"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_map_Ka(self):\n        Kd = os.path.join(self.dir, \" \".join(self.values[1:]))\n        self.this_material.set_texture_ambient(Kd)", "response": "Parse the ambient map file and set the texture ambient."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_map_Ks(self):\n        Kd = os.path.join(self.dir, \" \".join(self.values[1:]))\n        self.this_material.set_texture_specular_color(Kd)", "response": "Parse the specular color map."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_map_Ns(self):\n        Kd = os.path.join(self.dir, \" \".join(self.values[1:]))\n        self.this_material.set_texture_specular_highlight(Kd)", "response": "Parse the specular color map file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the alpha map.", "response": "def parse_map_d(self):\n        \"\"\"Alpha map\"\"\"\n        Kd = os.path.join(self.dir, \" \".join(self.values[1:]))\n        self.this_material.set_texture_alpha(Kd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_map_bump(self):\n        Kd = os.path.join(self.dir, \" \".join(self.values[1:]))\n        self.this_material.set_texture_bump(Kd)", "response": "Parse the bump map file and set the texture bump"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntrigger cache load or call superclass parse", "response": "def parse(self):\n        \"\"\"Trigger cache load or call superclass parse()\"\"\"\n        start = time.time()\n\n        if self.cache:\n            self.load_cache()\n\n        if not self.cache_loaded:\n            super(ObjParser, self).parse()\n\n        logger.info(\"%s: Load time: %s\", self.file_name, time.time() - start)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_cache(self):\n        self.cache_loaded = self.cache_loader_cls(\n            self.file_name,\n            self.wavefront,\n            strict=self.strict,\n            create_materials=self.create_materials,\n            encoding=self.encoding,\n            parse=self.parse,\n        ).parse()", "response": "Loads the file using cached data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef post_parse(self):\n        if self.cache and not self.cache_loaded:\n            self.cache_writer_cls(self.file_name, self.wavefront).write()", "response": "Called after parsing is done"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef consume_vertices(self):\n        while True:\n            # Vertex color\n            if len(self.values) == 7:\n                yield (\n                    float(self.values[1]),\n                    float(self.values[2]),\n                    float(self.values[3]),\n                    float(self.values[4]),\n                    float(self.values[5]),\n                    float(self.values[6]),\n                )\n            # Positions only\n            else:\n                yield (\n                    float(self.values[1]),\n                    float(self.values[2]),\n                    float(self.values[3]),\n                )\n\n            try:\n                self.next_line()\n            except StopIteration:\n                break\n\n            if not self.values:\n                break\n\n            if self.values[0] != \"v\":\n                break", "response": "Consumes all consecutive vertices in the list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconsume all consecutive texture coordinate lines", "response": "def consume_normals(self):\n        \"\"\"Consumes all consecutive texture coordinate lines\"\"\"\n        # The first iteration processes the current/first vn statement.\n        # The loop continues until there are no more vn-statements or StopIteration is raised by generator\n        while True:\n            yield (\n                float(self.values[1]),\n                float(self.values[2]),\n                float(self.values[3]),\n            )\n\n            try:\n                self.next_line()\n            except StopIteration:\n                break\n\n            if not self.values:\n                break\n\n            if self.values[0] != \"vn\":\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconsume all consecutive texture coordinates", "response": "def consume_texture_coordinates(self):\n        \"\"\"Consume all consecutive texture coordinates\"\"\"\n        # The first iteration processes the current/first vt statement.\n        # The loop continues until there are no more vt-statements or StopIteration is raised by generator\n        while True:\n            yield (\n                float(self.values[1]),\n                float(self.values[2]),\n            )\n\n            try:\n                self.next_line()\n            except StopIteration:\n                break\n\n            if not self.values:\n                break\n\n            if self.values[0] != \"vt\":\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconsuming all consecutive faces If more than three vertices are specified, we triangulate by the following procedure: Let the face have n vertices in the order v_1 v_2 v_3 ... v_n, n >= 3. We emit the first face as usual: (v_1, v_2, v_3). For each remaining vertex v_j, j > 3, we emit (v_j, v_1, v_{j - 1}), e.g. (v_4, v_1, v_3), (v_5, v_1, v_4). In a perfect world we could consume all vertices straight forward and draw using GL_TRIANGLE_FAN (which exactly matches the procedure above). This is however rarely the case. * If the face is co-planar but concave, then you need to triangulate the face. * If the face is not-coplanar, you are screwed, because OBJ doesn't preserve enough information to know what tessellation was intended. We always triangulate to make it simple. :param collected_faces: A list into which all (possibly triangulated) faces will be written in the form of triples of the corresponding absolute vertex IDs. These IDs index the list self.wavefront.vertices. Specify None to prevent consuming faces (and thus saving memory usage).", "response": "def consume_faces(self, collected_faces = None):\n        \"\"\"\n        Consume all consecutive faces\n\n        If more than three vertices are specified, we triangulate by the following procedure:\n\n            Let the face have n vertices in the order v_1 v_2 v_3 ... v_n, n >= 3.\n            We emit the first face as usual: (v_1, v_2, v_3). For each remaining vertex v_j,\n            j > 3, we emit (v_j, v_1, v_{j - 1}), e.g. (v_4, v_1, v_3), (v_5, v_1, v_4).\n\n        In a perfect world we could consume all vertices straight forward and draw using\n        GL_TRIANGLE_FAN (which exactly matches the procedure above).\n        This is however rarely the case.\n\n        * If the face is co-planar but concave, then you need to triangulate the face.\n        * If the face is not-coplanar, you are screwed, because OBJ doesn't preserve enough information\n          to know what tessellation was intended.\n\n        We always triangulate to make it simple.\n\n            :param collected_faces: A list into which all (possibly triangulated) faces will be written in the form\n                                    of triples of the corresponding absolute vertex IDs. These IDs index the list\n                                    self.wavefront.vertices.\n                                    Specify None to prevent consuming faces (and thus saving memory usage).\n        \"\"\"\n\n        # Helper tuple and function\n        Vertex = namedtuple('Vertex', 'idx pos color uv normal')\n        def emit_vertex(vertex):\n            # Just yield all the values except for the index\n            for v in vertex.uv:\n                yield v\n\n            for v in vertex.color:\n                yield v\n\n            for v in vertex.normal:\n                yield v\n\n            for v in vertex.pos:\n                yield v\n\n\n        # Figure out the format of the first vertex\n        # We raise an exception if any following vertex has a different format\n        # NOTE: Order is always v/vt/vn where v is mandatory and vt and vn is optional\n        has_vt = False\n        has_vn = False\n        has_colors = False\n\n        parts = self.values[1].split('/')\n        # We assume texture coordinates are present\n        if len(parts) == 2:\n            has_vt = True\n\n        # We have a vn, but not necessarily a vt\n        elif len(parts) == 3:\n            # Check for empty vt \"1//1\"\n            if parts[1] != '':\n                has_vt = True\n            has_vn = True\n\n        # Are we referencing vertex with color info?\n        vindex = int(parts[0])\n        if vindex < 0:\n            vindex += len(self.wavefront.vertices)\n        else:\n            vindex -= 1\n\n        vertex = self.wavefront.vertices[vindex]\n        has_colors = len(vertex) == 6\n\n        # Prepare vertex format string\n        vertex_format = \"_\".join(e[0] for e in [\n            (\"T2F\", has_vt),\n            (\"C3F\", has_colors),\n            (\"N3F\", has_vn),\n            (\"V3F\", True)\n        ] if e[1])\n\n        # If the material already have vertex data, ensure the same format is used\n        if self.material.vertex_format and self.material.vertex_format != vertex_format:\n            raise ValueError((\n                \"Trying to merge vertex data with different format: {}. \"\n                \"Material {} has vertex format {}\"\n            ).format(vertex_format, self.material.name, self.material.vertex_format))\n\n        self.material.vertex_format = vertex_format\n\n        # The first iteration processes the current/first f statement.\n        # The loop continues until there are no more f-statements or StopIteration is raised by generator\n        while True:\n            # The very first vertex, the last encountered and the current one\n            v1, vlast, vcurrent = None, None, None\n\n            for i, v in enumerate(self.values[1:]):\n                parts = v.split('/')\n                v_index = (int(parts[0]) - 1)\n                t_index = (int(parts[1]) - 1) if has_vt else None\n                n_index = (int(parts[2]) - 1) if has_vn else None\n\n                # Resolve negative index lookups\n                if v_index < 0:\n                    v_index += len(self.wavefront.vertices) + 1\n\n                if has_vt and t_index < 0:\n                    t_index += len(self.tex_coords) + 1\n\n                if has_vn and n_index < 0:\n                    n_index += len(self.normals) + 1\n\n                vlast = vcurrent\n                vcurrent = Vertex(\n                    idx = v_index,\n                    pos = self.wavefront.vertices[v_index][0:3] if has_colors else self.wavefront.vertices[v_index],\n                    color = self.wavefront.vertices[v_index][3:] if has_colors else (),\n                    uv = self.tex_coords[t_index] if has_vt and t_index < len(self.tex_coords) else (),\n                    normal = self.normals[n_index] if has_vn and n_index < len(self.normals) else ()\n                )\n\n                yield from emit_vertex(vcurrent)\n\n                # Triangulation when more than 3 elements are present\n                if i >= 3:\n                    # The current vertex has already been emitted.\n                    # Now just emit the first and the third vertices from the face\n                    yield from emit_vertex(v1)\n                    yield from emit_vertex(vlast)\n\n                if i == 0:\n                    # Store the first vertex\n                    v1 = vcurrent\n\n                if (collected_faces is not None) and (i >= 2):\n                    if i == 2:\n                        # Append the first triangle face in usual order (i.e. as specified in the Wavefront file)\n                        collected_faces.append([v1.idx, vlast.idx, vcurrent.idx])\n                    if i >= 3:\n                        # Triangulate the remaining part of the face by putting the current, the first\n                        # and the last parsed vertex in that order as a new face.\n                        # This order coincides deliberately with the order from vertex yielding above.\n                        collected_faces.append([vcurrent.idx, v1.idx, vlast.idx])\n\n            # Break out of the loop when there are no more f statements\n\n            try:\n                self.next_line()\n            except StopIteration:\n                break\n\n            if not self.values:\n                break\n\n            if self.values[0] != \"f\":\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if an error code is set and raise an exception if not.", "response": "def check_error(code, context=\"client\"):\n    \"\"\"\n    check if the error code is set. If so, a Python log message is generated\n    and an error is raised.\n    \"\"\"\n    if code:\n        error = error_text(code, context)\n        logger.error(error)\n        raise Snap7Exception(error)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a textual explanation of a given error number", "response": "def error_text(error, context=\"client\"):\n    \"\"\"Returns a textual explanation of a given error number\n\n    :param error: an error integer\n    :param context: server, client or partner\n    :returns: the error string\n    \"\"\"\n    assert context in (\"client\", \"server\", \"partner\")\n    logger.debug(\"error text for %s\" % hex(error))\n    len_ = 1024\n    text_type = c_char * len_\n    text = text_type()\n    library = load_library()\n    if context == \"client\":\n        library.Cli_ErrorText(error, text, len_)\n    elif context == \"server\":\n        library.Srv_ErrorText(error, text, len_)\n    elif context == \"partner\":\n        library.Par_ErrorText(error, text, len_)\n    return text.value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a textual explanation of a given event object object omento.", "response": "def event_text(self, event):\n        \"\"\"Returns a textual explanation of a given event object\n\n        :param event: an PSrvEvent struct object\n        :returns: the error string\n        \"\"\"\n        logger.debug(\"error text for %s\" % hex(event.EvtCode))\n        len_ = 1024\n        text_type = ctypes.c_char * len_\n        text = text_type()\n        error = self.library.Srv_EventText(ctypes.byref(event),\n                                           ctypes.byref(text), len_)\n        check_error(error)\n        if six.PY2:\n            return text.value\n        else:\n            return text.value.decode('ascii')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_area(self, area_code, index, userdata):\n        size = ctypes.sizeof(userdata)\n        logger.info(\"registering area %s, index %s, size %s\" % (area_code,\n                                                                index, size))\n        size = ctypes.sizeof(userdata)\n        return self.library.Srv_RegisterArea(self.pointer, area_code, index,\n                                             ctypes.byref(userdata), size)", "response": "Register a memory area with the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_events_callback(self, call_back):\n        logger.info(\"setting event callback\")\n        callback_wrap = ctypes.CFUNCTYPE(None, ctypes.c_void_p,\n                                         ctypes.POINTER(snap7.snap7types.SrvEvent),\n                                         ctypes.c_int)\n\n        def wrapper(usrptr, pevent, size):\n            \"\"\"\n            Wraps python function into a ctypes function\n\n            :param usrptr: not used\n            :param pevent: pointer to snap7 event struct\n            :param size:\n            :returns: should return an int\n            \"\"\"\n            logger.info(\"callback event: \" + self.event_text(pevent.contents))\n            call_back(pevent.contents)\n            return 0\n\n        self._callback = callback_wrap(wrapper)\n        usrPtr = ctypes.c_void_p()\n        return self.library.Srv_SetEventsCallback(self.pointer, self._callback, usrPtr)", "response": "Sets the user callback that the Server object has to call when an event is created."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_read_events_callback(self, call_back):\n        logger.info(\"setting read event callback\")\n        callback_wrapper = ctypes.CFUNCTYPE(None, ctypes.c_void_p,\n                                            ctypes.POINTER(snap7.snap7types.SrvEvent),\n                                            ctypes.c_int)\n\n        def wrapper(usrptr, pevent, size):\n            \"\"\"\n            Wraps python function into a ctypes function\n\n            :param usrptr: not used\n            :param pevent: pointer to snap7 event struct\n            :param size:\n            :returns: should return an int\n            \"\"\"\n            logger.info(\"callback event: \" + self.event_text(pevent.contents))\n            call_back(pevent.contents)\n            return 0\n\n        self._read_callback = callback_wrapper(wrapper)\n        return self.library.Srv_SetReadEventsCallback(self.pointer,\n                                                      self._read_callback)", "response": "Sets the user callback that the Server object has to call when a ReadISOTimeEvent event is created."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a callback that logs the events that have been logged", "response": "def _set_log_callback(self):\n        \"\"\"Sets a callback that logs the events\n        \"\"\"\n        logger.debug(\"setting up event logger\")\n\n        def log_callback(event):\n            logger.info(\"callback event: \" + self.event_text(event))\n\n        self.set_events_callback(log_callback)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the server status the Virtual CPU status and the number of availabe clients connected.", "response": "def get_status(self):\n        \"\"\"Reads the server status, the Virtual CPU status and the number of\n        the clients connected.\n\n        :returns: server status, cpu status, client count\n        \"\"\"\n        logger.debug(\"get server status\")\n        server_status = ctypes.c_int()\n        cpu_status = ctypes.c_int()\n        clients_count = ctypes.c_int()\n        error = self.library.Srv_GetStatus(self.pointer, ctypes.byref(server_status),\n                                           ctypes.byref(cpu_status),\n                                           ctypes.byref(clients_count))\n        check_error(error)\n        logger.debug(\"status server %s cpu %s clients %s\" %\n                     (server_status.value, cpu_status.value,\n                      clients_count.value))\n        return snap7.snap7types.server_statuses[server_status.value], \\\n               snap7.snap7types.cpu_statuses[cpu_status.value], \\\n               clients_count.value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nunlocks a previously locked shared memory area.", "response": "def unlock_area(self, code, index):\n        \"\"\"Unlocks a previously locked shared memory area.\n        \"\"\"\n        logger.debug(\"unlocking area code %s index %s\" % (code, index))\n        return self.library.Srv_UnlockArea(self.pointer, code, index)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lock_area(self, code, index):\n        logger.debug(\"locking area code %s index %s\" % (code, index))\n        return self.library.Srv_LockArea(self.pointer, code, index)", "response": "Locks a shared memory area."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start_to(self, ip, tcpport=102):\n        if tcpport != 102:\n            logger.info(\"setting server TCP port to %s\" % tcpport)\n            self.set_param(snap7.snap7types.LocalPort, tcpport)\n        assert re.match(ipv4, ip), '%s is invalid ipv4' % ip\n        logger.info(\"starting server to %s:102\" % ip)\n        return self.library.Srv_Start(self.pointer, ip)", "response": "start server on a specific interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset an internal Server object parameter.", "response": "def set_param(self, number, value):\n        \"\"\"Sets an internal Server object parameter.\n        \"\"\"\n        logger.debug(\"setting param number %s to %s\" % (number, value))\n        return self.library.Srv_SetParam(self.pointer, number,\n                                         ctypes.byref(ctypes.c_int(value)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_mask(self, kind, mask):\n        logger.debug(\"setting mask kind %s to %s\" % (kind, mask))\n        return self.library.Srv_SetMask(self.pointer, kind, mask)", "response": "Writes the specified filter mask."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the Virtual CPU status.", "response": "def set_cpu_status(self, status):\n        \"\"\"Sets the Virtual CPU status.\n        \"\"\"\n        assert status in snap7.snap7types.cpu_statuses, 'unknown cpu state %s' % status\n        logger.debug(\"setting cpu status to %s\" % status)\n        return self.library.Srv_SetCpuStatus(self.pointer, status)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract an event from the Events queue.", "response": "def pick_event(self):\n        \"\"\"Extracts an event (if available) from the Events queue.\n        \"\"\"\n        logger.debug(\"checking event queue\")\n        event = snap7.snap7types.SrvEvent()\n        ready = ctypes.c_int32()\n        code = self.library.Srv_PickEvent(self.pointer, ctypes.byref(event),\n                                          ctypes.byref(ready))\n        check_error(code)\n        if ready:\n            logger.debug(\"one event ready: %s\" % event)\n            return event\n        logger.debug(\"no events ready\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_param(self, number):\n        logger.debug(\"retreiving param number %s\" % number)\n        value = ctypes.c_int()\n        code = self.library.Srv_GetParam(self.pointer, number,\n                                         ctypes.byref(value))\n        check_error(code)\n        return value.value", "response": "Reads an internal Server object parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_mask(self, kind):\n        logger.debug(\"retrieving mask kind %s\" % kind)\n        mask = snap7.snap7types.longword()\n        code = self.library.Srv_GetMask(self.pointer, kind, ctypes.byref(mask))\n        check_error(code)\n        return mask", "response": "Reads the specified filter mask."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef error_wrap(func):\n    def f(*args, **kw):\n        code = func(*args, **kw)\n        check_error(code, context=\"client\")\n    return f", "response": "Parses a s7 error code returned the decorated function."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a SNAP7 client", "response": "def create(self):\n        \"\"\"\n        create a SNAP7 client.\n        \"\"\"\n        logger.info(\"creating snap7 client\")\n        self.library.Cli_Create.restype = c_void_p\n        self.pointer = S7Object(self.library.Cli_Create())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_cpu_state(self):\n        state = c_int(0)\n        self.library.Cli_GetPlcStatus(self.pointer,byref(state))\n        \n        try:\n            status_string = cpu_statuses[state.value]\n        except KeyError:\n            status_string = None\n        \n        if not status_string:\n            raise Snap7Exception(\"The cpu state (%s) is invalid\" % state.value)\n        \n        logger.debug(\"CPU state is %s\" % status_string)\n        return status_string", "response": "Retrieves the CPU state from client"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves CPU info from client", "response": "def get_cpu_info(self):\n        \"\"\"\n        Retrieves CPU info from client\n        \"\"\"\n        info = snap7.snap7types.S7CpuInfo()\n        result = self.library.Cli_GetCpuInfo(self.pointer, byref(info))\n        check_error(result, context=\"client\")\n        return info"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting to a S7 server.", "response": "def connect(self, address, rack, slot, tcpport=102):\n        \"\"\"\n        Connect to a S7 server.\n\n        :param address: IP address of server\n        :param rack: rack on server\n        :param slot: slot on server.\n        \"\"\"\n        logger.info(\"connecting to %s:%s rack %s slot %s\" % (address, tcpport,\n                                                             rack, slot))\n\n        self.set_param(snap7.snap7types.RemotePort, tcpport)\n        return self.library.Cli_ConnectTo(\n            self.pointer, c_char_p(six.b(address)),\n            c_int(rack), c_int(slot))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self, block_type, block_num):\n        logger.info(\"deleting block\")\n        blocktype = snap7.snap7types.block_types[block_type]\n        result = self.library.Cli_Delete(self.pointer, blocktype, block_num)\n        return result", "response": "Delete a block of a specific type and number"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upload(self, block_num):\n        logger.debug(\"db_upload block_num: %s\" % (block_num))\n\n        block_type = snap7.snap7types.block_types['DB']\n        _buffer = buffer_type()\n        size = c_int(sizeof(_buffer))\n\n        result = self.library.Cli_Upload(self.pointer, block_type, block_num,\n                                         byref(_buffer), byref(size))\n\n        check_error(result, context=\"client\")\n        logger.info('received %s bytes' % size)\n        return bytearray(_buffer)", "response": "This function uploads a block body from AG\n to the server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef download(self, data, block_num=-1):\n        type_ = c_byte\n        size = len(data)\n        cdata = (type_ * len(data)).from_buffer_copy(data)\n        result = self.library.Cli_Download(self.pointer, block_num,\n                                           byref(cdata), size)\n        return result", "response": "Downloads a DB data into the AG."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef db_get(self, db_number):\n        logger.debug(\"db_get db_number: %s\" % db_number)\n        _buffer = buffer_type()\n        result = self.library.Cli_DBGet(\n            self.pointer, db_number, byref(_buffer),\n            byref(c_int(buffer_size)))\n        check_error(result, context=\"client\")\n        return bytearray(_buffer)", "response": "Uploads a DB from AG. ADBGet"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_blocks(self):\n        logger.debug(\"listing blocks\")\n        blocksList = BlocksList()\n        result = self.library.Cli_ListBlocks(self.pointer, byref(blocksList))\n        check_error(result, context=\"client\")\n        logger.debug(\"blocks: %s\" % blocksList)\n        return blocksList", "response": "Returns the AG blocks amount divided by type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_blocks_of_type(self, blocktype, size):\n\n        blocktype = snap7.snap7types.block_types.get(blocktype)\n\n        if not blocktype:\n            raise Snap7Exception(\"The blocktype parameter was invalid\")\n\n        logger.debug(\"listing blocks of type: %s size: %s\" %\n                      (blocktype, size))\n\n        if (size == 0):\n            return 0\n\t\t\n        data = (c_uint16 * size)()\n        count = c_int(size)\n        result = self.library.Cli_ListBlocksOfType(\n            self.pointer, blocktype,\n            byref(data),\n            byref(count))\n\n        logger.debug(\"number of items found: %s\" % count)\n\n        check_error(result, context=\"client\")\n        return data", "response": "This function returns the AG list of a specified block type and size."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_block_info(self, blocktype, db_number):\n\n        blocktype = snap7.snap7types.block_types.get(blocktype)\n\n        if not blocktype:\n            raise Snap7Exception(\"The blocktype parameter was invalid\")\n\n        logger.debug(\"retrieving block info for block %s of type %s\" %\n                      (db_number, blocktype))\n\n        data = TS7BlockInfo()\n\n        result = self.library.Cli_GetAgBlockInfo(\n            self.pointer, blocktype,\n            db_number, byref(data))\n        check_error(result, context=\"client\")\n        return data", "response": "Returns the block information for the specified block."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending the password to the PLC to meet its security level.", "response": "def set_session_password(self, password):\n        \"\"\"Send the password to the PLC to meet its security level.\"\"\"\n        assert len(password) <= 8, 'maximum password length is 8'\n        return self.library.Cli_SetSessionPassword(self.pointer,\n                                                   c_char_p(six.b(password)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_connection_params(self, address, local_tsap, remote_tsap):\n        assert re.match(ipv4, address), '%s is invalid ipv4' % address\n        result = self.library.Cli_SetConnectionParams(self.pointer, address,\n                                                      c_uint16(local_tsap),\n                                                      c_uint16(remote_tsap))\n        if result != 0:\n            raise Snap7Exception(\"The parameter was invalid\")", "response": "Sets internal IP LocalTSAP and RemoteTSAP coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_connection_type(self, connection_type):\n        result = self.library.Cli_SetConnectionType(self.pointer,\n                                                    c_uint16(connection_type))\n        if result != 0:\n            raise Snap7Exception(\"The parameter was invalid\")", "response": "Sets the connection type of the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_connected(self):\n        connected = c_int32()\n        result = self.library.Cli_GetConnected(self.pointer, byref(connected))\n        check_error(result, context=\"client\")\n        return bool(connected)", "response": "Returns the connection status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ab_read(self, start, size):\n        wordlen = snap7.snap7types.S7WLByte\n        type_ = snap7.snap7types.wordlen_to_ctypes[wordlen]\n        data = (type_ * size)()\n        logger.debug(\"ab_read: start: %s: size %s: \" % (start, size))\n        result = self.library.Cli_ABRead(self.pointer, start, size,\n                                         byref(data))\n        check_error(result, context=\"client\")\n        return bytearray(data)", "response": "This is a lean function of Cli_ReadArea that reads PLC process outputs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_db_get(self, db_number):\n        logger.debug(\"db_get db_number: %s\" % db_number)\n        _buffer = buffer_type()\n        result = self.library.Cli_AsDBGet(self.pointer, db_number,\n                                          byref(_buffer),\n                                          byref(c_int(buffer_size)))\n        check_error(result, context=\"client\")\n        return bytearray(_buffer)", "response": "This is the asynchronous counterpart of Cli_DBGet."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading a DB data into the AG asynchronously.", "response": "def as_download(self, data, block_num=-1):\n        \"\"\"\n        Downloads a DB data into the AG asynchronously.\n        A whole block (including header and footer) must be available into the\n        user buffer.\n\n        :param block_num: New Block number (or -1)\n        :param data: the user buffer\n        \"\"\"\n        size = len(data)\n        type_ = c_byte * len(data)\n        cdata = type_.from_buffer_copy(data)\n        return self.library.Cli_AsDownload(self.pointer, block_num,\n                                           byref(cdata), size)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset an internal Server object parameter.", "response": "def set_param(self, number, value):\n        \"\"\"Sets an internal Server object parameter.\n        \"\"\"\n        logger.debug(\"setting param number %s to %s\" % (number, value))\n        type_ = param_types[number]\n        return self.library.Cli_SetParam(self.pointer, number,\n                                         byref(type_(value)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread an internal Client object parameter.", "response": "def get_param(self, number):\n        \"\"\"Reads an internal Client object parameter.\n        \"\"\"\n        logger.debug(\"retreiving param number %s\" % number)\n        type_ = param_types[number]\n        value = type_()\n        code = self.library.Cli_GetParam(self.pointer, c_int(number),\n                                         byref(value))\n        check_error(code)\n        return value.value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the length of the current PDU.", "response": "def get_pdu_length(self):\n        \"\"\"\n        Returns info about the PDU length.\n        \"\"\"\n        logger.info(\"getting PDU length\")\n        requested_ = c_uint16()\n        negotiated_ = c_uint16()\n        code = self.library.Cli_GetPduLength(self.pointer, byref(requested_), byref(negotiated_))\n        check_error(code)\n\n        return negotiated_.value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_plc_datetime(self):\n        type_ = c_int32\n        buffer = (type_ * 9)()\n        result = self.library.Cli_GetPlcDateTime(self.pointer, byref(buffer))\n        check_error(result, context=\"client\")\n\n        return datetime(\n            year = buffer[5] + 1900,\n            month = buffer[4] + 1,\n            day = buffer[3],\n            hour = buffer[2],\n            minute = buffer[1],\n            second = buffer[0]\n        )", "response": "Get date and time from PLC."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_plc_datetime(self, dt):\n        type_ = c_int32\n        buffer = (type_ * 9)()\n        buffer[0] = dt.second\n        buffer[1] = dt.minute\n        buffer[2] = dt.hour\n        buffer[3] = dt.day\n        buffer[4] = dt.month - 1\n        buffer[5] = dt.year - 1900\n\n        return self.library.Cli_SetPlcDateTime(self.pointer, byref(buffer))", "response": "Set date and time in PLC\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_db1():\n    all_data = client.db_get(1)\n\n    for i in range(400):                 # items in db\n        row_size = 130                   # size of item\n        index = i * row_size\n        offset = index + row_size        # end of row in db\n        util.print_row(all_data[index:offset])", "response": "Read out DB1 data from the server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_db_row(db, start, size):\n    type_ = snap7.snap7types.wordlen_to_ctypes[snap7.snap7types.S7WLByte]\n    data = client.db_read(db, start, type_, size)\n    # print_row(data[:60])\n    return data", "response": "This function reads the data from the DB and returns it as a list of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_db_row(db, start, size, _bytearray):\n    client.db_write(db, start, size, _bytearray)", "response": "This function is used to replace a piece of data in a db block with a new row."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_row(x):\n\n    row_size = 126\n\n    while True:\n        data = get_db_row(1, 4 + x * row_size, row_size)\n        row = snap7.util.DB_Row(data, rc_if_db_1_layout,\n                                layout_offset=4)\n        print 'name', row['RC_IF_NAME']\n        print row['RC_IF_NAME']\n        break", "response": "shows the contents of the specified row in the DB of the specified object X in\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_row(x, row):\n    row_size = 126\n    set_db_row(1, 4 + x * row_size, row_size, row._bytearray)", "response": "Set a row in the PLC using db 1."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_bool(_bytearray, byte_index, bool_index):\n    index_value = 1 << bool_index\n    byte_value = _bytearray[byte_index]\n    current_value = byte_value & index_value\n    return current_value == index_value", "response": "Get the boolean value from the byte array at the given index."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting boolean value on location in bytearray", "response": "def set_bool(_bytearray, byte_index, bool_index, value):\n    \"\"\"\n    Set boolean value on location in bytearray\n    \"\"\"\n    assert value in [0, 1, True, False]\n    current_value = get_bool(_bytearray, byte_index, bool_index)\n    index_value = 1 << bool_index\n\n    # check if bool already has correct value\n    if current_value == value:\n        return\n\n    if value:\n        # make sure index_v is IN current byte\n        _bytearray[byte_index] += index_value\n    else:\n        # make sure index_v is NOT in current byte\n        _bytearray[byte_index] -= index_value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset value in bytearray to int", "response": "def set_int(bytearray_, byte_index, _int):\n    \"\"\"\n    Set value in bytearray to int\n    \"\"\"\n    # make sure were dealing with an int\n    _int = int(_int)\n    _bytes = struct.unpack('2B', struct.pack('>h', _int))\n    bytearray_[byte_index:byte_index + 2] = _bytes\n    return bytearray_"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets int value from bytearray.", "response": "def get_int(bytearray_, byte_index):\n    \"\"\"\n    Get int value from bytearray.\n\n    int are represented in two bytes\n    \"\"\"\n    data = bytearray_[byte_index:byte_index + 2]\n    data[1] = data[1] & 0xff\n    data[0] = data[0] & 0xff\n    packed = struct.pack('2B', *data)\n    value = struct.unpack('>h', packed)[0]\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_real(_bytearray, byte_index, real):\n    real = float(real)\n    real = struct.pack('>f', real)\n    _bytes = struct.unpack('4B', real)\n    for i, b in enumerate(_bytes):\n        _bytearray[byte_index + i] = b", "response": "Set Real value in the byte array."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_real(_bytearray, byte_index):\n    x = _bytearray[byte_index:byte_index + 4]\n    real = struct.unpack('>f', struct.pack('4B', *x))[0]\n    return real", "response": "Get real value. create float from 4 bytes\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_string(_bytearray, byte_index, value, max_size):\n    if six.PY2:\n        assert isinstance(value, (str, unicode))\n    else:\n        assert isinstance(value, str)\n\n    size = len(value)\n    # FAIL HARD WHEN trying to write too much data into PLC\n    if size > max_size:\n        raise ValueError('size %s > max_size %s %s' % (size, max_size, value))\n    # set len count on first position\n    _bytearray[byte_index + 1] = len(value)\n\n    i = 0\n    # fill array which chr integers\n    for i, c in enumerate(value):\n        _bytearray[byte_index + 2 + i] = ord(c)\n\n    # fill the rest with empty space\n    for r in range(i + 1, _bytearray[byte_index]):\n        _bytearray[byte_index + 2 + r] = ord(' ')", "response": "Set string value in the PLC file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses string from bytearray", "response": "def get_string(_bytearray, byte_index, max_size):\n    \"\"\"\n    parse string from bytearray\n    \"\"\"\n    size = _bytearray[byte_index + 1]\n\n    if max_size < size:\n        logger.error(\"the string is to big for the size encountered in specification\")\n        logger.error(\"WRONG SIZED STRING ENCOUNTERED\")\n        size = max_size\n\n    data = map(chr, _bytearray[byte_index + 2:byte_index + 2 + size])\n    return \"\".join(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_specification(db_specification):\n    parsed_db_specification = OrderedDict()\n\n    for line in db_specification.split('\\n'):\n        if line and not line.startswith('#'):\n            row = line.split('#')[0]  # remove trailing comment\n            index, var_name, _type = row.split()\n            parsed_db_specification[var_name] = (index, _type)\n\n    return parsed_db_specification", "response": "Parse a DB specification into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_bytearray(self):\n        if isinstance(self._bytearray, DB):\n            return self._bytearray._bytearray\n        return self._bytearray", "response": "get bytearray from self or DB parent\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexporting dictionary with values", "response": "def export(self):\n        \"\"\"\n        export dictionary with values\n        \"\"\"\n        data = {}\n        for key in self._specification:\n            data[key] = self[key]\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting current data to database in plc", "response": "def write(self, client):\n        \"\"\"\n        Write current data to db in plc\n        \"\"\"\n        assert(isinstance(self._bytearray, DB))\n        assert(self.row_size >= 0)\n\n        db_nr = self._bytearray.db_number\n        offset = self.db_offset\n        data = self.get_bytearray()[offset:offset+self.row_size]\n        db_offset = self.db_offset\n\n        # indicate start of write only area of row!\n        if self.row_offset:\n            data = data[self.row_offset:]\n            db_offset += self.row_offset\n\n        client.db_write(db_nr, db_offset, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, client):\n        assert(isinstance(self._bytearray, DB))\n        assert(self.row_size >= 0)\n        db_nr = self._bytearray.db_number\n        _bytearray = client.db_read(db_nr, self.db_offset, self.row_size)\n\n        data = self.get_bytearray()\n        # replace data in bytearray\n        for i, b in enumerate(_bytearray):\n            data[i + self.db_offset] = b", "response": "read current data of the current record from plc\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect(self, ip_address, tsap_snap7, tsap_logo, tcpport=102):\n        logger.info(\"connecting to %s:%s tsap_snap7 %s tsap_logo %s\" % (ip_address, tcpport,\n                                                             tsap_snap7, tsap_logo))\n        # special handling for Siemens Logo\n        # 1st set connection params\n        # 2nd connect without any parameters\n        self.set_param(snap7.snap7types.RemotePort, tcpport)\n        self.set_connection_params(ip_address, tsap_snap7, tsap_logo)\n        result = self.library.Cli_Connect(self.pointer)\n        check_error(result, context=\"client\") \n        return result", "response": "Connect to a Siemens Logo server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads from the given VM addresses of Siemens Logo memory.", "response": "def read(self, vm_address):\n        \"\"\"\n        Reads from VM addresses of Siemens Logo. Examples: read(\"V40\") / read(\"VW64\") / read(\"V10.2\") \n        \n        :param vm_address: of Logo memory (e.g. V30.1, VW32, V24)\n        :returns: integer\n        \"\"\"\n        area = snap7types.S7AreaDB\n        db_number = 1\n        size = 1\n        start = 0\n        wordlen = 0\n        logger.debug(\"read, vm_address:%s\" % (vm_address))\n        if re.match(\"V[0-9]{1,4}\\.[0-7]{1}\", vm_address):\n            ## bit value\n            logger.info(\"read, Bit address: \" + vm_address)\n            address = vm_address[1:].split(\".\")\n            # transform string to int\n            address_byte = int(address[0])\n            address_bit = int(address[1])\n            start = (address_byte*8)+address_bit\n            wordlen = snap7types.S7WLBit\n        elif re.match(\"V[0-9]+\", vm_address):\n            ## byte value\n            logger.info(\"Byte address: \" + vm_address)\n            start = int(vm_address[1:])\n            wordlen = snap7types.S7WLByte\n        elif re.match(\"VW[0-9]+\", vm_address):\n            ## byte value\n            logger.info(\"Word address: \" + vm_address)\n            start = int(vm_address[2:])\n            wordlen = snap7types.S7WLWord\n        elif re.match(\"VD[0-9]+\", vm_address):\n            ## byte value\n            logger.info(\"DWord address: \" + vm_address)\n            start = int(vm_address[2:])\n            wordlen = snap7types.S7WLDWord\n        else:\n            logger.info(\"Unknown address format\")\n            return 0\n             \n        type_ = snap7.snap7types.wordlen_to_ctypes[wordlen]\n        data = (type_ * size)()\n\n        logger.debug(\"start:%s, wordlen:%s, data-length:%s\" % (start, wordlen, len(data)) )\n\n        result = self.library.Cli_ReadArea(self.pointer, area, db_number, start,\n                                           size, wordlen, byref(data))\n        check_error(result, context=\"client\")\n        # transform result to int value\n        if wordlen == snap7types.S7WLBit:\n            return(data)[0]\n        if wordlen == snap7types.S7WLByte:\n            return struct.unpack_from(\">B\", data)[0]\n        if wordlen == snap7types.S7WLWord:\n            return struct.unpack_from(\">h\", data)[0]\n        if wordlen == snap7types.S7WLDWord:\n            return struct.unpack_from(\">l\", data)[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write (self, vm_address, value):\n        area = snap7types.S7AreaDB\n        db_number = 1\n        start = 0\n        amount = 1\n        wordlen = 0\n        data = bytearray(0)\n        logger.debug(\"write, vm_address:%s, value:%s\" %\n                     (vm_address, value))\n        if re.match(\"^V[0-9]{1,4}\\.[0-7]{1}$\", vm_address):\n            ## bit value\n            logger.info(\"read, Bit address: \" + vm_address)\n            address = vm_address[1:].split(\".\")\n            # transform string to int\n            address_byte = int(address[0])\n            address_bit = int(address[1])\n            start = (address_byte*8)+address_bit\n            wordlen = snap7types.S7WLBit\n            if value > 0:\n                data = bytearray([1])    \n            else:\n                data = bytearray([0])\n        elif re.match(\"^V[0-9]+$\", vm_address):\n            ## byte value\n            logger.info(\"Byte address: \" + vm_address)\n            start = int(vm_address[1:])\n            wordlen = snap7types.S7WLByte\n            data = bytearray(struct.pack(\">B\", value))\n        elif re.match(\"^VW[0-9]+$\", vm_address):\n            ## byte value\n            logger.info(\"Word address: \" + vm_address)\n            start = int(vm_address[2:])\n            wordlen = snap7types.S7WLWord\n            data = bytearray(struct.pack(\">h\", value))\n        elif re.match(\"^VD[0-9]+$\", vm_address):\n            ## byte value\n            logger.info(\"DWord address: \" + vm_address)\n            start = int(vm_address[2:])\n            wordlen = snap7types.S7WLDWord\n            data = bytearray(struct.pack(\">l\", value))\n        else:\n            logger.info(\"write, Unknown address format: \" + vm_address)\n            return 1\n        \n        if wordlen == snap7types.S7WLBit:\n            type_ = snap7.snap7types.wordlen_to_ctypes[snap7types.S7WLByte]\n        else:\n            type_ = snap7.snap7types.wordlen_to_ctypes[wordlen]\n        \n        cdata = (type_ * amount).from_buffer_copy(data)\n\n        logger.debug(\"write, vm_address:%s value:%s\" % (vm_address, value))\n\n        result = self.library.Cli_WriteArea(self.pointer, area, db_number, start,\n                                          amount, wordlen, byref(cdata))\n        check_error(result, context=\"client\")\n        return result", "response": "Writes to the VM addresses of the Siemens Logo."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_connection_params(self, ip_address, tsap_snap7, tsap_logo):\n        assert re.match(ipv4, ip_address), '%s is invalid ipv4' % ip_address\n        result = self.library.Cli_SetConnectionParams(self.pointer, ip_address.encode(),\n                                                      c_uint16(tsap_snap7),\n                                                      c_uint16(tsap_logo))\n        if result != 0:\n            raise Snap7Exception(\"The parameter was invalid\")", "response": "Sets internal connection parameters for the current TSAP SNAP7 client and TSAP Logo server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if the current asynchronous send job was completed and terminates immediately.", "response": "def check_as_b_send_completion(self):\n        \"\"\"\n        Checks if the current asynchronous send job was completed and terminates\n        immediately.\n        \"\"\"\n        op_result = ctypes.c_int32()\n        result = self.library.Par_CheckAsBSendCompletion(self.pointer,\n                                                 ctypes.byref(op_result))\n        return_values = {\n            0: \"job complete\",\n            1: \"job in progress\",\n            -2: \"invalid handled supplied\",\n        }\n\n        if result == -2:\n            raise Snap7Exception(\"The Client parameter was invalid\")\n\n        return return_values[result], op_result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, active=False):\n        self.library.Par_Create.restype = snap7.snap7types.S7Object\n        self.pointer = snap7.snap7types.S7Object(self.library.Par_Create(int(active)))", "response": "Creates a Partner and returns its handle"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndestroys a Partner of given handle. Before destruction the Partner is stopped, all clients disconnected and all shared memory blocks released.", "response": "def destroy(self):\n        \"\"\"\n        Destroy a Partner of given handle.\n        Before destruction the Partner is stopped, all clients disconnected and\n        all shared memory blocks released.\n        \"\"\"\n        if self.library:\n            return self.library.Par_Destroy(ctypes.byref(self.pointer))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the last error value from the library.", "response": "def get_last_error(self):\n        \"\"\"\n        Returns the last job result.\n        \"\"\"\n        error = ctypes.c_int32()\n        result = self.library.Par_GetLastError(self.pointer, ctypes.byref(error))\n        check_error(result, \"partner\")\n        return error"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread an internal Partner object parameter.", "response": "def get_param(self, number):\n        \"\"\"\n        Reads an internal Partner object parameter.\n        \"\"\"\n        logger.debug(\"retreiving param number %s\" % number)\n        type_ = snap7.snap7types.param_types[number]\n        value = type_()\n        code = self.library.Par_GetParam(self.pointer, ctypes.c_int(number),\n                                         ctypes.byref(value))\n        check_error(code)\n        return value.value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning some statistics. :returns: a tuple containing bytes send, received, send errors, recv errors", "response": "def get_stats(self):\n        \"\"\"\n        Returns some statistics.\n\n        :returns: a tuple containing bytes send, received, send errors, recv errors\n        \"\"\"\n        sent = ctypes.c_uint32()\n        recv = ctypes.c_uint32()\n        send_errors = ctypes.c_uint32()\n        recv_errors = ctypes.c_uint32()\n        result = self.library.Par_GetStats(self.pointer, ctypes.byref(sent),\n                                   ctypes.byref(recv),\n                                   ctypes.byref(send_errors),\n                                   ctypes.byref(recv_errors))\n        check_error(result, \"partner\")\n        return sent, recv, send_errors, recv_errors"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_status(self):\n        status = ctypes.c_int32()\n        result = self.library.Par_GetStatus(self.pointer, ctypes.byref(status))\n        check_error(result, \"partner\")\n        return status", "response": "Returns the Partner status."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the last send and recv jobs execution time in milliseconds.", "response": "def get_times(self):\n        \"\"\"\n        Returns the last send and recv jobs execution time in milliseconds.\n        \"\"\"\n        send_time = ctypes.c_int32()\n        recv_time = ctypes.c_int32()\n        result = self.library.Par_GetTimes(self.pointer, ctypes.byref(send_time),\n                                   ctypes.byref(recv_time))\n        check_error(result, \"partner\")\n        return send_time, recv_time"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting the Partner and binds it to the specified IP address and the IsoTCP port.", "response": "def start_to(self, local_ip, remote_ip, local_tsap, remote_tsap):\n        \"\"\"\n        Starts the Partner and binds it to the specified IP address and the\n        IsoTCP port.\n\n        :param local_ip: PC host IPV4 Address. \"0.0.0.0\" is the default adapter\n        :param remote_ip: PLC IPV4 Address\n        :param local_tsap: Local TSAP\n        :param remote_tsap: PLC TSAP\n        \"\"\"\n        assert re.match(ipv4, local_ip), '%s is invalid ipv4' % local_ip\n        assert re.match(ipv4, remote_ip), '%s is invalid ipv4' % remote_ip\n        logger.info(\"starting partnering from %s to %s\" % (local_ip, remote_ip))\n        return self.library.Par_StartTo(self.pointer, local_ip, remote_ip,\n                                        ctypes.c_uint16(local_tsap),\n                                        ctypes.c_uint16(remote_tsap))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_socket(_socket, session, timeout=1):\n    directions = session.block_directions()\n    if directions == 0:\n        return 0\n    readfds = [_socket] \\\n        if (directions & LIBSSH2_SESSION_BLOCK_INBOUND) else ()\n    writefds = [_socket] \\\n        if (directions & LIBSSH2_SESSION_BLOCK_OUTBOUND) else ()\n    return select(readfds, writefds, (), timeout)", "response": "This function blocks the calling thread for <timeout > seconds."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetects communities using the default settings. This function detects communities given the specified method in the ``partition_type``. This should be type derived from :class:`VertexPartition.MutableVertexPartition`, e.g. :class:`ModularityVertexPartition` or :class:`CPMVertexPartition`. Optionally an initial membership and edge weights can be provided. Remaining ``**kwargs`` are passed on to the constructor of the ``partition_type``, including for example a ``resolution_parameter``. Parameters ---------- graph : :class:`ig.Graph` The graph for which to detect communities. partition_type : type of :class:` The type of partition to use for optimisation. initial_membership : list of int Initial membership for the partition. If :obj:`None` then defaults to a singleton partition. weights : list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. n_iterations : int Number of iterations to run the Leiden algorithm. By default, 2 iterations are run. If the number of iterations is negative, the Leiden algorithm is run until an iteration in which there was no improvement. seed : int Seed for the random number generator. By default uses a random seed if nothing is specified. **kwargs Remaining keyword arguments, passed on to constructor of ``partition_type``. Returns ------- partition The optimised partition. See Also -------- :func:`Optimiser.optimise_partition` Examples -------- >>> G = ig.Graph.Famous('Zachary') >>> partition = la.find_partition(G, la.ModularityVertexPartition)", "response": "def find_partition(graph, partition_type, initial_membership=None, weights=None, n_iterations=2, seed=None, **kwargs):\n  \"\"\" Detect communities using the default settings.\n\n  This function detects communities given the specified method in the\n  ``partition_type``. This should be type derived from\n  :class:`VertexPartition.MutableVertexPartition`, e.g.\n  :class:`ModularityVertexPartition` or :class:`CPMVertexPartition`. Optionally\n  an initial membership and edge weights can be provided. Remaining\n  ``**kwargs`` are passed on to the constructor of the ``partition_type``,\n  including for example a ``resolution_parameter``.\n\n  Parameters\n  ----------\n  graph : :class:`ig.Graph`\n    The graph for which to detect communities.\n\n  partition_type : type of :class:`\n    The type of partition to use for optimisation.\n\n  initial_membership : list of int\n    Initial membership for the partition. If :obj:`None` then defaults to a\n    singleton partition.\n\n  weights : list of double, or edge attribute\n    Weights of edges. Can be either an iterable or an edge attribute.\n\n  n_iterations : int\n    Number of iterations to run the Leiden algorithm. By default, 2 iterations\n    are run. If the number of iterations is negative, the Leiden algorithm is\n    run until an iteration in which there was no improvement.\n\n  seed : int\n    Seed for the random number generator. By default uses a random seed\n    if nothing is specified.\n\n  **kwargs\n    Remaining keyword arguments, passed on to constructor of\n    ``partition_type``.\n\n  Returns\n  -------\n  partition\n    The optimised partition.\n\n  See Also\n  --------\n  :func:`Optimiser.optimise_partition`\n\n  Examples\n  --------\n  >>> G = ig.Graph.Famous('Zachary')\n  >>> partition = la.find_partition(G, la.ModularityVertexPartition)\n\n  \"\"\"\n  if not weights is None:\n    kwargs['weights'] = weights\n  partition = partition_type(graph,\n                             initial_membership=initial_membership,\n                             **kwargs)\n  optimiser = Optimiser()\n\n  if (not seed is None):\n    optimiser.set_rng_seed(seed)\n\n  optimiser.optimise_partition(partition, n_iterations)\n\n  return partition"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef time_slices_to_layers(graphs,\n                          interslice_weight=1,\n                          slice_attr='slice',\n                          vertex_id_attr='id',\n                          edge_type_attr='type',\n                          weight_attr='weight'):\n  \"\"\" Convert time slices to layer graphs.\n\n  Each graph is considered to represent a time slice. This function simply\n  connects all the consecutive slices (i.e. the slice graph) with an\n  ``interslice_weight``.  The further conversion is then delegated to\n  :func:`slices_to_layers`, which also provides further details.\n\n  See Also\n  --------\n  :func:`find_partition_temporal`\n\n  :func:`slices_to_layers`\n\n  \"\"\"\n  G_slices = _ig.Graph.Tree(len(graphs), 1, mode=_ig.TREE_UNDIRECTED)\n  G_slices.es[weight_attr] = interslice_weight\n  G_slices.vs[slice_attr] = graphs\n  return slices_to_layers(G_slices,\n                          slice_attr,\n                          vertex_id_attr,\n                          edge_type_attr,\n                          weight_attr)", "response": "Convert time slices to layer graphs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef slices_to_layers(G_coupling,\n                     slice_attr='slice',\n                     vertex_id_attr='id',\n                     edge_type_attr='type',\n                     weight_attr='weight'):\n  \"\"\" Convert a coupling graph of slices to layers of graphs.\n\n  This function converts a graph of slices to layers so that they can be used\n  with this package. This function assumes that the slices are represented by\n  nodes in ``G_coupling``, and stored in the attribute ``slice_attr``. In other\n  words, ``G_coupling.vs[slice_attr]`` should contain :class:`ig.Graph` s . The\n  slices will be converted to layers, and nodes in different slices will be\n  coupled if the two slices are connected in ``G_coupling``. Nodes in two\n  connected slices are identified on the basis of the ``vertex_id_attr``, i.e.\n  if two nodes in two connected slices have an identical value of the\n  ``vertex_id_attr`` they will be coupled. The ``vertex_id_attr`` should hence\n  be unique in each slice.  The weight of the coupling is determined by the\n  weight of this link in ``G_coupling``, as determined by the ``weight_attr``.\n\n  Parameters\n  ----------\n  G_coupling : :class:`ig.Graph`\n    The graph connecting the different slices.\n\n  slice_attr : string\n    The vertex attribute which contains the slices.\n\n  edge_type_attr : string\n    The edge attribute to use for indicating the type of link (``interslice``\n    or ``intraslice``).\n\n  weight_attr : string\n    The edge attribute used to indicate the (coupling) weight.\n\n  Returns\n  -------\n  G_layers : list of :class:`ig.Graph`\n    A list of slices converted to layers.\n\n  G_interslice : :class:`ig.Graph`\n    The interslice coupling layer.\n\n  G : :class:`ig.Graph`\n    The complete graph containing all layers and interslice couplings.\n\n  Notes\n  -----\n  The distinction between slices and layers is not easy to grasp. Slices in\n  this context refer to graphs that somehow represents different aspects of a\n  network. The simplest example is probably slices that represents time: there\n  are different snapshots network across time, and each snapshot is considered\n  a slice. Some nodes may drop out of the network over time, while others enter\n  the network. Edges may change over time, or the weight of the links may\n  change over time. This is just the simplest example of a slice, and there may\n  be different, more complex possibilities. Below an example with three time\n  slices:\n\n  .. image:: figures/slices.png\n\n  Now in order to optimise partitions across these different slices, we\n  represent them slightly differently, namely as layers. The idea of layers is\n  that all graphs always are defined on the same set of nodes, and that only\n  the links differ for different layers. We thus create new nodes as\n  combinations of original nodes and slices. For example, if node 1 existed in\n  both slice 1 and in slice 2, we will thus create two nodes to build the\n  layers: a node 1-1 and a node 1-2. Additionally, if the slices are connected\n  in the slice graph, the two nodes would also be connected, so there would be\n  a linke between node 1-1 and 1-2. Different slices will then correspond to\n  different layers: each layer only contains the link for that particular\n  slice. In addition, for methods such as :class:`CPMVertexPartition`,\n  so-called ``node_sizes`` are required, and for them to properly function,\n  they should be set to 0 (which is handled appropriately in this function, and\n  stored in the vertex attribute ``node_size``). We thus obtain equally many\n  layers as we have slices, and we need one more layer for representing the\n  interslice couplings.  For the example provided above, we thus obtain the\n  following:\n\n  .. image:: figures/layers_separate.png\n\n  The idea of doing community detection with slices is further detailed in [1].\n\n  References\n  ----------\n  .. [1] Mucha, P. J., Richardson, T., Macon, K., Porter, M. A., & Onnela,\n         J.-P. (2010).  Community structure in time-dependent, multiscale, and\n         multiplex networks. Science, 328(5980), 876-8.\n         `10.1126/science.1184819 <http://doi.org/10.1126/science.1184819>`_\n  See Also\n  --------\n  :func:`find_partition_temporal`\n\n  :func:`time_slices_to_layers`\n\n  \"\"\"\n  if not slice_attr in G_coupling.vertex_attributes():\n    raise ValueError(\"Could not find the vertex attribute {0} in the coupling graph.\".format(slice_attr))\n\n  if not weight_attr in G_coupling.edge_attributes():\n    raise ValueError(\"Could not find the edge attribute {0} in the coupling graph.\".format(weight_attr))\n\n  # Create disjoint union of the time graphs\n  for v_slice in G_coupling.vs:\n    H = v_slice[slice_attr]\n    H.vs[slice_attr] = v_slice.index\n    if not vertex_id_attr in H.vertex_attributes():\n      raise ValueError(\"Could not find the vertex attribute {0} to identify nodes in different slices.\".format(vertex_id_attr ))\n    if not weight_attr in H.edge_attributes():\n      H.es[weight_attr] = 1\n\n  G = disjoint_union_attrs(G_coupling.vs[slice_attr])\n  G.es[edge_type_attr] = 'intraslice'\n\n  for v_slice in G_coupling.vs:\n    for u_slice in v_slice.neighbors(mode=_ig.OUT):\n      if v_slice.index < u_slice.index or G_coupling.is_directed():\n        nodes_v = G.vs.select(lambda v: v[slice_attr]==v_slice.index)[vertex_id_attr]\n        if len(set(nodes_v)) != len(nodes_v):\n          err = '\\n'.join(\n            ['\\t{0} {1} times'.format(item, count) for item, count in Counter(nodes_v).items() if count > 1]\n            )\n          raise ValueError('No unique IDs for slice {0}, require unique IDs:\\n{1}'.format(v_slice.index, err))\n        nodes_u = G.vs.select(lambda v: v[slice_attr]==u_slice.index)[vertex_id_attr]\n        if len(set(nodes_u)) != len(nodes_u):\n          err = '\\n'.join(\n            ['\\t{0} {1} times'.format(item, count) for item, count in Counter(nodes_u).items() if count > 1]\n            )\n          raise ValueError('No unique IDs for slice {0}, require unique IDs:\\n{1}'.format(u_slice.index, err))\n        common_nodes = set(nodes_v).intersection(set(nodes_u))\n        nodes_v = sorted([v for v in G.vs if v[slice_attr] == v_slice.index and v[vertex_id_attr] in common_nodes], key=lambda v: v[vertex_id_attr])\n        nodes_u = sorted([v for v in G.vs if v[slice_attr] == u_slice.index and v[vertex_id_attr] in common_nodes], key=lambda v: v[vertex_id_attr])\n        edges = zip(nodes_v, nodes_u)\n        e_start = G.ecount()\n        G.add_edges(edges)\n        e_end = G.ecount()\n        e_idx = range(e_start, e_end)\n        interslice_weight = G_coupling.es[G_coupling.get_eid(v_slice, u_slice)][weight_attr]\n        if not interslice_weight is None:\n          G.es[e_idx][weight_attr] = interslice_weight\n        G.es[e_idx][edge_type_attr] = 'interslice'\n\n  # Convert aggregate graph to individual layers for each time slice.\n  G_layers = [None]*G_coupling.vcount()\n  for v_slice in G_coupling.vs:\n    H = G.subgraph_edges(G.es.select(_within=[v.index for v in G.vs if v[slice_attr] == v_slice.index]), delete_vertices=False)\n    H.vs['node_size'] = [1 if v[slice_attr] == v_slice.index else 0 for v in H.vs]\n    G_layers[v_slice.index] = H\n\n  # Create one graph for the interslice links.\n  G_interslice = G.subgraph_edges(G.es.select(type_eq='interslice'), delete_vertices=False)\n  G_interslice.vs['node_size'] = 0\n\n  return G_layers, G_interslice, G", "response": "This function converts a coupling graph of slices to layers of graphs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new partition from an existing partition.", "response": "def FromPartition(cls, partition, **kwargs):\n    \"\"\" Create a new partition from an existing partition.\n\n    Parameters\n    ----------\n    partition\n      The :class:`~VertexPartition.MutableVertexPartition` to replicate.\n\n    **kwargs\n      Any remaining keyword arguments will be passed on to the constructor of\n      the new partition.\n\n    Notes\n    -----\n    This may for example come in handy when determining the quality of a\n    partition using a different method. Suppose that we already have a\n    partition ``p`` and that we want to determine the Significance of that\n    partition. We can then simply use\n\n    >>> p = la.find_partition(ig.Graph.Famous('Zachary'),\n    ...                       la.ModularityVertexPartition)\n    >>> sig = la.SignificanceVertexPartition.FromPartition(p).quality()\n    \"\"\"\n    new_partition = cls(partition.graph, partition.membership, **kwargs)\n    return new_partition"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the membership of the partition.", "response": "def set_membership(self, membership):\n    \"\"\" Set membership. \"\"\"\n    _c_leiden._MutableVertexPartition_set_membership(self._partition, list(membership))\n    self._update_internal_membership()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef diff_move(self,v,new_comm):\n    return _c_leiden._MutableVertexPartition_diff_move(self._partition, v, new_comm)", "response": "Calculate the difference in the quality function if node v is moved to community new_comm."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naggregate the graph according to the current partition and provide a for the given partition.", "response": "def aggregate_partition(self, membership_partition=None):\n    \"\"\" Aggregate the graph according to the current partition and provide a\n    default partition for it.\n\n    The aggregated graph can then be found as a parameter of the partition\n    ``partition.graph``.\n\n    Notes\n    -----\n    This function contrasts to the function ``cluster_graph`` in igraph itself,\n    which also provides the aggregate graph, but we may require setting\n    the appropriate ``resolution_parameter``, ``weights`` and ``node_sizes``.\n    In particular, this function also ensures that the quality defined on the\n    aggregate partition is identical to the quality defined on the original\n    partition.\n\n    Examples\n    --------\n    >>> G = ig.Graph.Famous('Zachary')\n    >>> partition = la.find_partition(G, la.ModularityVertexPartition)\n    >>> aggregate_partition = partition.aggregate_partition(partition)\n    >>> aggregate_graph = aggregate_partition.graph\n    >>> aggregate_partition.quality() == partition.quality()\n    True\n    \"\"\"\n    partition_agg = self._FromCPartition(_c_leiden._MutableVertexPartition_aggregate_partition(self._partition))\n\n    if (not membership_partition is None):\n      membership = partition_agg.membership\n      for v in self.graph.vs:\n        membership[self.membership[v.index]] = membership_partition.membership[v.index]\n      partition_agg.set_membership(membership)\n\n    return partition_agg"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves node v to community new_comm.", "response": "def move_node(self,v,new_comm):\n    \"\"\" Move node ``v`` to community ``new_comm``.\n\n    Parameters\n    ----------\n    v\n      Node to move.\n\n    new_comm\n      Community to move to.\n\n    Examples\n    --------\n    >>> G = ig.Graph.Famous('Zachary')\n    >>> partition = la.ModularityVertexPartition(G)\n    >>> partition.move_node(0, 1)\n    \"\"\"\n    _c_leiden._MutableVertexPartition_move_node(self._partition, v, new_comm)\n    # Make sure this move is also reflected in the membership vector of the python object\n    self._membership[v] = new_comm\n    self._modularity_dirty = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the current partition according to the coarser partition.", "response": "def from_coarse_partition(self, partition, coarse_node=None):\n    \"\"\" Update current partition according to coarser partition.\n\n    Parameters\n    ----------\n    partition : :class:`~VertexPartition.MutableVertexPartition`\n      The coarser partition used to update the current partition.\n\n    coarse_node : list of int\n      The coarser node which represent the current node in the partition.\n\n    Notes\n    -----\n    This function is to be used to determine the correct partition for an\n    aggregated graph. In particular, suppose we move nodes and then get an\n    aggregate graph.\n\n    >>> diff = optimiser.move_nodes(partition)\n    >>> aggregate_partition = partition.aggregate_partition()\n\n    Now we also move nodes in the aggregate partition\n\n    >>> diff = optimiser.move_nodes(aggregate_partition)\n\n    Now we improved the quality function of ``aggregate_partition``, but this\n    is not yet reflected in the original ``partition``. We can thus call\n\n    >>> partition.from_coarse_partition(aggregate_partition)\n\n    so that ``partition`` now reflects the changes made to\n    ``aggregate_partition``.\n\n    The ``coarse_node`` can be used it the ``aggregate_partition`` is not\n    defined based on the membership of this partition. In particular the\n    membership of this partition is defined as follows:\n\n    >>> for v in G.vs:\n    ...   partition.membership[v] = aggregate_partition.membership[coarse_node[v]] # doctest: +SKIP\n\n    If ``coarse_node`` is :obj:`None` it is assumed the coarse node was defined\n    based on the membership of the current partition, so that\n\n    >>> for v in G.vs:\n    ...   partition.membership[v] = aggregate_partition.membership[partition.membership[v]] # doctest: +SKIP\n\n    This can be useful when the aggregate partition is defined on a more\n    refined partition.\n    \"\"\"\n    # Read the coarser partition\n    _c_leiden._MutableVertexPartition_from_coarse_partition(self._partition,\n                                                             partition.membership, coarse_node)\n    self._update_internal_membership()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the total number of edges or sum of weights from node v to community comm.", "response": "def weight_to_comm(self, v, comm):\n    \"\"\" The total number of edges (or sum of weights) from node ``v`` to\n    community ``comm``.\n\n    See Also\n    --------\n    :func:`~VertexPartition.MutableVertexPartition.weight_from_comm`\n    \"\"\"\n    return _c_leiden._MutableVertexPartition_weight_to_comm(self._partition, v, comm)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the total number of edges or sum of weights to node v from community comm.", "response": "def weight_from_comm(self, v, comm):\n    \"\"\" The total number of edges (or sum of weights) to node ``v`` from\n    community ``comm``.\n\n    See Also\n    --------\n    :func:`~VertexPartition.MutableVertexPartition.weight_to_comm`\n    \"\"\"\n    return _c_leiden._MutableVertexPartition_weight_from_comm(self._partition, v, comm)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\noptimise the given partition.", "response": "def optimise_partition(self, partition, n_iterations=2):\n    \"\"\" Optimise the given partition.\n\n    Parameters\n    ----------\n    partition\n      The :class:`~VertexPartition.MutableVertexPartition` to optimise.\n\n    n_iterations : int\n      Number of iterations to run the Leiden algorithm. By default, 2 iterations\n      are run. If the number of iterations is negative, the Leiden algorithm is\n      run until an iteration in which there was no improvement.\n\n    Returns\n    -------\n    float\n      Improvement in quality function.\n\n    Examples\n    --------\n\n    >>> G = ig.Graph.Famous('Zachary')\n    >>> optimiser = la.Optimiser()\n    >>> partition = la.ModularityVertexPartition(G)\n    >>> diff = optimiser.optimise_partition(partition)\n\n    \"\"\"\n\n    itr = 0\n    diff = 0\n    continue_iteration = itr < n_iterations or n_iterations < 0\n    while continue_iteration:\n      diff_inc = _c_leiden._Optimiser_optimise_partition(self._optimiser, partition._partition)\n      diff += diff_inc\n      itr += 1\n      if n_iterations < 0:\n        continue_iteration = (diff_inc > 0)\n      else:\n        continue_iteration = itr < n_iterations\n\n    partition._update_internal_membership()\n    return diff"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noptimise the given partitions simultaneously. Parameters ---------- partitions List of :class:`~VertexPartition.MutableVertexPartition` layers to optimise. layer_weights List of weights of layers. n_iterations : int Number of iterations to run the Leiden algorithm. By default, 2 iterations are run. If the number of iterations is negative, the Leiden algorithm is run until an iteration in which there was no improvement. Returns ------- float Improvement in quality of combined partitions, see `Notes <#notes-multiplex>`_. .. _notes-multiplex: Notes ----- This method assumes that the partitions are defined for graphs with the same vertices. The connections between the vertices may be different, but the vertices themselves should be identical. In other words, all vertices should have identical indices in all graphs (i.e. node `i` is assumed to be the same node in all graphs). The quality of the overall partition is simply the sum of the individual qualities for the various partitions, weighted by the layer_weight. If we denote by :math:`Q_k` the quality of layer :math:`k` and the weight by :math:`\\\\lambda_k`, the overall quality is then .. math:: Q = \\sum_k \\\\lambda_k Q_k. This is particularly useful for graphs containing negative links. When separating the graph in two graphs, the one containing only the positive links, and the other only the negative link, by supplying a negative weight to the latter layer, we try to find relatively many positive links within a community and relatively many negative links between communities. Note that in this case it may be better to assign a node to a community to which it is not connected so that :attr:`consider_comms` may be better set to :attr:`leidenalg.ALL_COMMS`. Besides multiplex graphs where each node is assumed to have a single community, it is also useful in the case of for example multiple time slices, or in situations where nodes can have different communities in different slices. The package includes some special helper functions for using :func:`optimise_partition_multiplex` in such cases, where there is a conversion required from (time) slices to layers suitable for use in this function. See Also -------- :func:`slices_to_layers` :func:`time_slices_to_layers` :func:`find_partition_multiplex` :func:`find_partition_temporal` Examples -------- >>> G_pos = ig.Graph.SBM(100, pref_matrix=[[0.5, 0.1], [0.1, 0.5]], block_sizes=[50, 50]) >>> G_neg = ig.Graph.SBM(100, pref_matrix=[[0.1, 0.5], [0.5, 0.1]], block_sizes=[50, 50]) >>> optimiser = la.Optimiser() >>> partition_pos = la.ModularityVertexPartition(G_pos) >>> partition_neg = la.ModularityVertexPartition(G_neg) >>> diff = optimiser.optimise_partition_multiplex( ... partitions=[partition_pos, partition_neg], ... layer_weights=[1,-1])", "response": "def optimise_partition_multiplex(self, partitions, layer_weights=None, n_iterations=2):\n    \"\"\" Optimise the given partitions simultaneously.\n\n    Parameters\n    ----------\n    partitions\n      List of :class:`~VertexPartition.MutableVertexPartition` layers to optimise.\n\n    layer_weights\n      List of weights of layers.\n\n    n_iterations : int\n      Number of iterations to run the Leiden algorithm. By default, 2 iterations\n      are run. If the number of iterations is negative, the Leiden algorithm is\n      run until an iteration in which there was no improvement.\n\n    Returns\n    -------\n    float\n      Improvement in quality of combined partitions, see `Notes <#notes-multiplex>`_.\n\n\n    .. _notes-multiplex:\n\n    Notes\n    -----\n\n    This method assumes that the partitions are defined for graphs with the\n    same vertices. The connections between the vertices may be different, but\n    the vertices themselves should be identical. In other words, all vertices\n    should have identical indices in all graphs (i.e. node `i` is assumed to be\n    the same node in all graphs). The quality of the overall partition is\n    simply the sum of the individual qualities for the various partitions,\n    weighted by the layer_weight. If we denote by :math:`Q_k` the quality of\n    layer :math:`k` and the weight by :math:`\\\\lambda_k`, the overall quality\n    is then\n\n    .. math:: Q = \\sum_k \\\\lambda_k Q_k.\n\n    This is particularly useful for graphs containing negative links. When\n    separating the graph in two graphs, the one containing only the positive\n    links, and the other only the negative link, by supplying a negative weight\n    to the latter layer, we try to find relatively many positive links within a\n    community and relatively many negative links between communities. Note that\n    in this case it may be better to assign a node to a community to which it\n    is not connected so that :attr:`consider_comms` may be better set to\n    :attr:`leidenalg.ALL_COMMS`.\n\n    Besides multiplex graphs where each node is assumed to have a single\n    community, it is also useful in the case of for example multiple time\n    slices, or in situations where nodes can have different communities in\n    different slices. The package includes some special helper functions for\n    using :func:`optimise_partition_multiplex` in such cases, where there is a\n    conversion required from (time) slices to layers suitable for use in this\n    function.\n\n    See Also\n    --------\n    :func:`slices_to_layers`\n\n    :func:`time_slices_to_layers`\n\n    :func:`find_partition_multiplex`\n\n    :func:`find_partition_temporal`\n\n    Examples\n    --------\n    >>> G_pos = ig.Graph.SBM(100, pref_matrix=[[0.5, 0.1], [0.1, 0.5]], block_sizes=[50, 50])\n    >>> G_neg = ig.Graph.SBM(100, pref_matrix=[[0.1, 0.5], [0.5, 0.1]], block_sizes=[50, 50])\n    >>> optimiser = la.Optimiser()\n    >>> partition_pos = la.ModularityVertexPartition(G_pos)\n    >>> partition_neg = la.ModularityVertexPartition(G_neg)\n    >>> diff = optimiser.optimise_partition_multiplex(\n    ...                     partitions=[partition_pos, partition_neg],\n    ...                     layer_weights=[1,-1])\n\n    \"\"\"\n    if not layer_weights:\n      layer_weights = [1]*len(partitions)\n\n    itr = 0\n    diff = 0\n    continue_iteration = itr < n_iterations or n_iterations < 0\n    while continue_iteration:\n      diff_inc = _c_leiden._Optimiser_optimise_partition_multiplex(\n        self._optimiser,\n        [partition._partition for partition in partitions],\n        layer_weights)\n      diff += diff_inc\n      itr += 1\n      if n_iterations < 0:\n        continue_iteration = (diff_inc > 0)\n      else:\n        continue_iteration = itr < n_iterations\n\n    for partition in partitions:\n      partition._update_internal_membership()\n    return diff"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves nodes to alternative communities for optimising the partition.", "response": "def move_nodes(self, partition, consider_comms=None):\n    \"\"\" Move nodes to alternative communities for *optimising* the partition.\n\n    Parameters\n    ----------\n    partition\n      The partition for which to move nodes.\n\n    consider_comms\n      If ``None`` uses :attr:`consider_comms`, but can be set to\n      something else.\n\n    Returns\n    -------\n    float\n      Improvement in quality function.\n\n    Notes\n    -----\n    When moving nodes, the function loops over nodes and considers moving the\n    node to an alternative community. Which community depends on\n    ``consider_comms``. The function terminates when no more nodes can be moved\n    to an alternative community.\n\n    See Also\n    --------\n    :func:`Optimiser.move_nodes_constrained`\n\n    :func:`Optimiser.merge_nodes`\n\n    Examples\n    --------\n    >>> G = ig.Graph.Famous('Zachary')\n    >>> optimiser = la.Optimiser()\n    >>> partition = la.ModularityVertexPartition(G)\n    >>> diff = optimiser.move_nodes(partition)\n\n    \"\"\"\n    if (consider_comms is None):\n      consider_comms = self.consider_comms\n    diff =  _c_leiden._Optimiser_move_nodes(self._optimiser, partition._partition, consider_comms)\n    partition._update_internal_membership()\n    return diff"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef move_nodes_constrained(self, partition, constrained_partition, consider_comms=None):\n    if (consider_comms is None):\n      consider_comms = self.refine_consider_comms\n    diff =  _c_leiden._Optimiser_move_nodes_constrained(self._optimiser, partition._partition, constrained_partition._partition, consider_comms)\n    partition._update_internal_membership()\n    return diff", "response": "Move nodes to alternative communities for constrained partitions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmerge nodes for optimising the partition.", "response": "def merge_nodes(self, partition, consider_comms=None):\n    \"\"\" Merge nodes for *optimising* the partition.\n\n    Parameters\n    ----------\n    partition\n      The partition for which to merge nodes.\n\n    consider_comms\n      If ``None`` uses :attr:`consider_comms`, but can be set to\n      something else.\n\n    Returns\n    -------\n    float\n      Improvement in quality function.\n\n    Notes\n    -----\n    This function loop over all nodes once and tries to merge them with another\n    community.  Merging in this case implies that a node will never be removed\n    from a community, only merged with other communities.\n\n    See Also\n    --------\n    :func:`Optimiser.move_nodes`\n\n    :func:`Optimiser.merge_nodes_constrained`\n\n    Examples\n    --------\n    >>> G = ig.Graph.Famous('Zachary')\n    >>> optimiser = la.Optimiser()\n    >>> partition = la.ModularityVertexPartition(G)\n    >>> diff = optimiser.merge_nodes(partition)\n\n    \"\"\"\n    if (consider_comms is None):\n      consider_comms = self.consider_comms\n    diff =  _c_leiden._Optimiser_merge_nodes(self._optimiser, partition._partition, consider_comms)\n    partition._update_internal_membership()\n    return diff"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new node - based decomposition of the given partition.", "response": "def merge_nodes_constrained(self, partition, constrained_partition, consider_comms=None):\n    \"\"\" Merge nodes for *refining* the partition.\n\n    Parameters\n    ----------\n    partition\n      The partition for which to merge nodes.\n\n    constrained_partition\n      The partition within which we may merge nodes.\n\n    consider_comms\n      If ``None`` uses :attr:`refine_consider_comms`, but can be set\n      to something else.\n\n    Returns\n    -------\n    float\n      Improvement in quality function.\n\n    Notes\n    -----\n    The idea is constrain the merging of nodes to another partition. In other\n    words, if there is a partition ``P`` which we want to refine, we can then\n    initialize a new singleton partition, and move nodes in that partition\n    constrained to ``P``.\n\n    See Also\n    --------\n    :func:`Optimiser.move_nodes_constrained`\n\n    :func:`Optimiser.merge_nodes`\n\n    Examples\n    --------\n    >>> G = ig.Graph.Famous('Zachary')\n    >>> optimiser = la.Optimiser()\n    >>> partition = la.ModularityVertexPartition(G)\n    >>> diff = optimiser.optimise_partition(partition)\n    >>> refine_partition = la.ModularityVertexPartition(G)\n    >>> diff = optimiser.move_nodes_constrained(refine_partition, partition)\n\n    \"\"\"\n    if (consider_comms is None):\n      consider_comms = self.refine_consider_comms\n    diff =  _c_leiden._Optimiser_merge_nodes_constrained(self._optimiser, partition._partition, constrained_partition._partition, consider_comms)\n    partition._update_internal_membership()\n    return diff"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a new resolution profile for the given set of partitions.", "response": "def resolution_profile(self,\n        graph,\n        partition_type,\n        resolution_range,\n        weights=None,\n        bisect_func=lambda p: p.bisect_value(),\n        min_diff_bisect_value=1,\n        min_diff_resolution=1e-3,\n        linear_bisection=False,\n        number_iterations=1,\n        **kwargs\n        ):\n    \"\"\" Use bisectioning on the resolution parameter in order to construct a\n    resolution profile.\n\n    Parameters\n    ----------\n    graph\n      The graph for which to construct a resolution profile.\n\n    partition_type\n      The type of :class:`~VertexPartition.MutableVertexPartition` used\n      to find a partition (must support resolution parameters obviously).\n\n    resolution_range\n      The range of resolution values that we would like to scan.\n\n    weights\n      If provided, indicates the edge attribute to use as a weight.\n\n    Returns\n    -------\n    list of :class:`~VertexPartition.MutableVertexPartition`\n      A list of partitions for different resolutions.\n\n    Other Parameters\n    ----------------\n    bisect_func\n      The function used for bisectioning. For the methods currently\n      implemented, this should usually not be altered.\n\n    min_diff_bisect_value\n      The difference in the value returned by the bisect_func below which the\n      bisectioning stops (i.e. by default, a difference of a single edge does\n      not trigger further bisectioning).\n\n    min_diff_resolution\n      The difference in resolution below which the bisectioning stops. For\n      positive differences, the logarithmic difference is used by default, i.e.\n      ``diff = log(res_1) - log(res_2) = log(res_1/res_2)``, for which ``diff >\n      min_diff_resolution`` to continue bisectioning. Set the linear_bisection\n      to true in order to use only linear bisectioning (in the case of negative\n      resolution parameters for example, which can happen with negative\n      weights).\n\n    linear_bisection\n      Whether the bisectioning will be done on a linear or on a logarithmic\n      basis (if possible).\n\n    number_iterations\n      Indicates the number of iterations of the algorithm to run. If negative\n      (or zero) the algorithm is run until a stable iteration.\n\n    Examples\n    --------\n    >>> G = ig.Graph.Famous('Zachary')\n    >>> optimiser = la.Optimiser()\n    >>> profile = optimiser.resolution_profile(G, la.CPMVertexPartition,\n    ...                                        resolution_range=(0,1))\n    \"\"\"\n\n    # Helper function for cleaning values to be a stepwise function\n    def clean_stepwise(bisect_values):\n      # Check best partition for each resolution parameter\n      for res, bisect in bisect_values.iteritems():\n        best_bisect = bisect\n        best_quality = bisect.partition.quality(res)\n        for res2, bisect2 in bisect_values.iteritems():\n          if bisect2.partition.quality(res) > best_quality:\n            best_bisect = bisect2\n            best_quality = bisect2.partition.quality(res)\n        if best_bisect != bisect:\n          bisect_values[res] = best_bisect\n\n      # We only need to keep the changes in the bisection values\n      bisect_list = sorted([(res, part.bisect_value) for res, part in\n        bisect_values.iteritems()], key=lambda x: x[0])\n      for (res1, v1), (res2, v2) \\\n          in zip(bisect_list,\n                 bisect_list[1:]):\n        # If two consecutive bisection values are the same, remove the second\n        # resolution parameter\n        if v1 == v2:\n          del bisect_values[res2]\n\n      for res, bisect in bisect_values.iteritems():\n        bisect.partition.resolution_parameter = res\n\n    # We assume here that the bisection values are\n    # monotonically decreasing with increasing resolution\n    # parameter values.\n    def ensure_monotonicity(bisect_values, new_res):\n      # First check if this partition improves on any other partition\n      for res, bisect_part in bisect_values.iteritems():\n        if bisect_values[new_res].partition.quality(res) > bisect_part.partition.quality(res):\n          bisect_values[res] = bisect_values[new_res]\n      # Then check what is best partition for the new_res\n      current_quality = bisect_values[new_res].partition.quality(new_res)\n      best_res = new_res\n      for res, bisect_part in bisect_values.iteritems():\n        if bisect_part.partition.quality(new_res) > current_quality:\n          best_res = new_res\n      bisect_values[new_res] = bisect_values[best_res]\n\n    def find_partition(self, graph, partition_type, weights=None, **kwargs):\n      partition = partition_type(graph,\n                             weights=weights,\n                             **kwargs)\n      n_itr = 0\n      while self.optimise_partition(partition) > 0 and \\\n        (n_itr < number_iterations or number_iterations <= 0):\n        n_itr += 1\n      return partition\n\n    assert issubclass(partition_type, LinearResolutionParameterVertexPartition), \"Bisectioning only works on partitions with a linear resolution parameter.\"\n    # Start actual bisectioning\n    bisect_values = {}\n    stack_res_range = []\n    # Push first range onto the stack\n    stack_res_range.append(resolution_range)\n    # Make sure the bisection values are calculated\n    # The namedtuple we will use in the bisection function\n    BisectPartition = namedtuple('BisectPartition',\n        ['partition', 'bisect_value'])\n    partition = find_partition(self, graph=graph, partition_type=partition_type,\n        weights=weights,resolution_parameter=resolution_range[0],\n        **kwargs)\n    bisect_values[resolution_range[0]] = BisectPartition(partition=partition,\n                                bisect_value=bisect_func(partition))\n    partition = find_partition(self, graph=graph, partition_type=partition_type,\n        weights=weights, resolution_parameter=resolution_range[1], **kwargs)\n    bisect_values[resolution_range[1]] = BisectPartition(partition=partition,\n                                bisect_value=bisect_func(partition))\n    # While stack of ranges not yet empty\n    while stack_res_range:\n      # Get the current range from the stack\n      current_range = stack_res_range.pop()\n      # Get the difference in bisection values\n      diff_bisect_value = abs(bisect_values[current_range[0]].bisect_value -\n                              bisect_values[current_range[1]].bisect_value)\n      # Get the difference in resolution parameter (in log space if 0 is not in\n      # the interval (assuming only non-negative resolution parameters).\n      if current_range[0] > 0 and current_range[1] > 0 and not linear_bisection:\n        diff_resolution = log(current_range[1]/current_range[0])\n      else:\n        diff_resolution = abs(current_range[1] - current_range[0])\n      # Check if we still want to scan a smaller interval\n      # If we would like to bisect this interval\n      if diff_bisect_value > min_diff_bisect_value and \\\n         diff_resolution > min_diff_resolution:\n        # Determine new resolution value\n        if current_range[0] > 0 and current_range[1] > 0 and not linear_bisection:\n          new_res = sqrt(current_range[1]*current_range[0])\n        else:\n          new_res = sum(current_range)/2.0\n        # Bisect left (push on stack)\n        stack_res_range.append((current_range[0], new_res))\n        # Bisect right (push on stack)\n        stack_res_range.append((new_res, current_range[1]))\n        # If we haven't scanned this resolution value yet,\n        # do so now\n        if not bisect_values.has_key(new_res):\n          partition = find_partition(self, graph, partition_type=partition_type,\n              weights=weights, resolution_parameter=new_res, **kwargs)\n          bisect_values[new_res] = BisectPartition(partition=partition,\n                                      bisect_value=bisect_func(partition))\n          # Because of stochastic differences in different runs, the monotonicity\n          # of the bisection values might be violated, so check for any\n          # inconsistencies\n          ensure_monotonicity(bisect_values, new_res)\n\n    # Ensure we only keep those resolution values for which\n    # the bisection values actually changed, instead of all of them\n    clean_stepwise(bisect_values)\n    # Use an ordered dict so that when iterating over it, the results appear in\n    # increasing order based on the resolution value.\n    return sorted((bisect.partition for res, bisect in\n      bisect_values.iteritems()), key=lambda x: x.resolution_parameter)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the given temporary directory if it exists.", "response": "def cleanup_tmpdir(dirname):\n    \"\"\"Removes the given temporary directory if it exists.\"\"\"\n    if dirname is not None and os.path.exists(dirname):\n        shutil.rmtree(dirname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_dir_unless_exists(*args):\n    path = os.path.join(*args)\n    if not os.path.isdir(path):\n        os.makedirs(path)", "response": "Creates a directory unless it exists already."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nensures that the given directory does not exist.", "response": "def ensure_dir_does_not_exist(*args):\n    \"\"\"Ensures that the given directory does not exist.\"\"\"\n    path = os.path.join(*args)\n    if os.path.isdir(path):\n        shutil.rmtree(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives the raw name of a library in library_name tries to find a static library with this name in the given library_path. library_path is automatically extended with common library directories on Linux and MacOS X.", "response": "def find_static_library(library_name, library_path):\n    \"\"\"Given the raw name of a library in `library_name`, tries to find a\n    static library with this name in the given `library_path`. `library_path`\n    is automatically extended with common library directories on Linux and Mac\n    OS X.\"\"\"\n\n    variants = [\"lib{0}.a\", \"{0}.a\", \"{0}.lib\", \"lib{0}.lib\"]\n    if is_unix_like():\n        extra_libdirs = [\"/usr/local/lib64\", \"/usr/local/lib\",\n                \"/usr/lib64\", \"/usr/lib\", \"/lib64\", \"/lib\"]\n    else:\n        extra_libdirs = []\n\n    for path in extra_libdirs:\n        if path not in library_path and os.path.isdir(path):\n            library_path.append(path)\n\n    for path in library_path:\n        for variant in variants:\n            full_path = os.path.join(path, variant.format(library_name))\n            if os.path.isfile(full_path):\n                return full_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_output(command):\n    p = Popen(command, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n    p.stdin.close()\n    p.stderr.close()\n    line=p.stdout.readline().strip()\n    p.wait()\n    if type(line).__name__ == \"bytes\":\n        line = str(line, encoding=\"utf-8\")\n    return line, p.returncode", "response": "Returns the output of a command returning a single line of output."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns whether the given HTTP URL exists in the sense that it does not return an HTTP error code or not. A URL is considered to exist if it does not return an HTTP error code or not.", "response": "def http_url_exists(url):\n    \"\"\"Returns whether the given HTTP URL 'exists' in the sense that it is returning\n    an HTTP error code or not. A URL is considered to exist if it does not return\n    an HTTP error code.\"\"\"\n    class HEADRequest(Request):\n        def get_method(self):\n            return \"HEAD\"\n    try:\n        response = urlopen(HEADRequest(url))\n        return True\n    except URLError:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_unix_like(platform=None):\n    platform = platform or sys.platform\n    platform = platform.lower()\n    return platform.startswith(\"linux\") or platform.startswith(\"darwin\") or \\\n            platform.startswith(\"cygwin\")", "response": "Returns True if the given platform is a Unix - like platform with the usual\n    Unix filesystem."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef version_variants(version):\n\n    result = [version]\n\n    # Add trailing \".0\" as needed to ensure that we have at least\n    # major.minor.patch\n    parts = version.split(\".\")\n    while len(parts) < 3:\n        parts.append(\"0\")\n        result.append(\".\".join(parts))\n\n    return result", "response": "Given an igraph version number returns a list of possible version\n    number variants to try when looking for a suitable nightly build of the version\n    C core to download from igraph. org."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tmpdir(self):\n        if self._tmpdir is None:\n            self._tmpdir = tempfile.mkdtemp(prefix=\"igraph.\")\n            atexit.register(cleanup_tmpdir, self._tmpdir)\n        return self._tmpdir", "response": "The temporary directory in which igraph is downloaded and extracted."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndownloads and compiles the C core of igraph.", "response": "def download_and_compile(self):\n        \"\"\"Downloads and compiles the C core of igraph.\"\"\"\n\n        def _progress_hook(count, block_size, total_size):\n            if total_size < 0:\n                sys.stdout.write(\"\\rDownloading %s... please wait.\" % local_file)\n            else:\n                percentage = count * block_size * 100.0 / total_size\n                percentage = min(percentage, 100.0)\n                sys.stdout.write(\"\\rDownloading %s... %.2f%%\" % (local_file, percentage))\n            sys.stdout.flush()\n\n        # Determine the remote URL if needed\n        if self.remote_url is None:\n            self.version, remote_url = self.find_first_version()\n            if not self.version:\n                print(\"Version %s of the C core of igraph is not found among the \"\n                        \"nightly builds.\" % self.versions_to_try[0])\n                print(\"Use the --c-core-version switch to try a different version.\")\n                print(\"\")\n                return False\n            local_file = \"igraph-%s.tar.gz\" % self.version\n        else:\n            remote_url = self.remote_url\n            local_file = remote_url.rsplit(\"/\", 1)[1]\n\n        # Now determine the full path where the C core will be downloaded\n        local_file_full_path = os.path.join(self.tmpdir, local_file)\n\n        # Download the C core\n        if self.show_progress_bar:\n            urlretrieve(remote_url, local_file_full_path, reporthook=_progress_hook)\n            print(\"\")\n        else:\n            print(\"Downloading %s... \" % local_file)\n            urlretrieve(remote_url, local_file_full_path)\n\n        # Extract it in the temporary directory\n        print(\"Extracting %s...\" % local_file)\n        archive = tarfile.open(local_file_full_path, \"r:gz\")\n        archive.extractall(self.tmpdir)\n\n        # Determine the name of the build directory\n        self.builddir = None\n        for name in os.listdir(self.tmpdir):\n            full_path = os.path.join(self.tmpdir, name)\n            if name.startswith(\"igraph\") and os.path.isdir(full_path):\n                self.builddir = full_path\n                break\n\n        if not self.builddir:\n            print(\"Downloaded tarball did not contain a directory whose name \"\n                    \"started with igraph; giving up build.\")\n            return False\n\n        # Try to compile\n        cwd = os.getcwd()\n        try:\n            print(\"Configuring igraph...\")\n            os.chdir(self.builddir)\n            retcode = subprocess.call(\"CFLAGS=-fPIC CXXFLAGS=-fPIC ./configure --disable-tls --disable-gmp\",\n                    shell=True)\n            if retcode:\n                return False\n\n            retcode = subprocess.call(\"make\", shell=True)\n            if retcode:\n                return False\n\n            libraries = []\n            for line in open(os.path.join(self.builddir, \"igraph.pc\")):\n                if line.startswith(\"Libs: \") or line.startswith(\"Libs.private: \"):\n                    words = line.strip().split()\n                    libraries.extend(word[2:] for word in words if word.startswith(\"-l\"))\n\n            if not libraries:\n                # Educated guess\n                libraries = [\"igraph\"]\n\n        finally:\n            os.chdir(cwd)\n\n        # Compilation succeeded; copy everything into igraphcore\n        create_dir_unless_exists(\"igraphcore\")\n        ensure_dir_does_not_exist(\"igraphcore\", \"include\")\n        ensure_dir_does_not_exist(\"igraphcore\", \"lib\")\n        shutil.copytree(os.path.join(self.builddir, \"include\"),\n                os.path.join(\"igraphcore\", \"include\"))\n        shutil.copytree(os.path.join(self.builddir, \"src\", \".libs\"),\n                os.path.join(\"igraphcore\", \"lib\"))\n        f = open(os.path.join(\"igraphcore\", \"build.cfg\"), \"w\")\n        f.write(repr(libraries))\n        f.close()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding the first version of igraph that exists in the nightly build repo from the version numbers provided in self. versions_to_try.", "response": "def find_first_version(self):\n        \"\"\"Finds the first version of igraph that exists in the nightly build\n        repo from the version numbers provided in ``self.versions_to_try``.\"\"\"\n        for version in self.versions_to_try:\n            remote_url = self.get_download_url(version=version)\n            if http_url_exists(remote_url):\n                return version, remote_url\n        return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns whether pkg - config is available on the current system and it knows about igraph or not.", "response": "def has_pkgconfig(self):\n        \"\"\"Returns whether ``pkg-config`` is available on the current system\n        and it knows about igraph or not.\"\"\"\n        if self._has_pkgconfig is None:\n            if self.use_pkgconfig:\n                line, exit_code = get_output(\"pkg-config igraph\")\n                self._has_pkgconfig = (exit_code == 0)\n            else:\n                self._has_pkgconfig = False\n        return self._has_pkgconfig"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef configure(self, ext):\n        ext.include_dirs += self.include_dirs\n        ext.library_dirs += self.library_dirs\n        ext.libraries += self.libraries\n        ext.extra_compile_args += self.extra_compile_args\n        ext.extra_link_args += self.extra_link_args\n        ext.extra_objects += self.extra_objects", "response": "Configures the given Extension object using this build configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef detect_from_pkgconfig(self):\n        if not buildcfg.has_pkgconfig:\n            print(\"Cannot find the C core of igraph on this system using pkg-config.\")\n            return False\n\n        cmd = \"pkg-config igraph --cflags --libs\"\n        if self.static_extension:\n            cmd += \" --static\"\n        line, exit_code = get_output(cmd)\n        if exit_code > 0 or len(line) == 0:\n            return False\n\n        opts = line.strip().split()\n        self.libraries = [opt[2:] for opt in opts if opt.startswith(\"-l\")]\n        self.library_dirs = [opt[2:] for opt in opts if opt.startswith(\"-L\")]\n        self.include_dirs = [opt[2:] for opt in opts if opt.startswith(\"-I\")]\n        return True", "response": "Detects the igraph include directory library directory and the\n        list of libraries to link to using pkg - config."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndownloads and compiles the C core of igraph.", "response": "def download_and_compile_igraph(self):\n        \"\"\"Downloads and compiles the C core of igraph.\"\"\"\n        print(\"We will now try to download and compile the C core from scratch.\")\n        print(\"Version number of the C core: %s\" % self.c_core_versions[0])\n        if len(self.c_core_versions) > 1:\n            print(\"We will also try: %s\" % \", \".join(self.c_core_versions[1:]))\n        print(\"\")\n\n        igraph_builder = IgraphCCoreBuilder(self.c_core_versions, self.c_core_url,\n                show_progress_bar=self.show_progress_bar)\n        if not igraph_builder.run():\n            print(\"Could not download and compile the C core of igraph.\")\n            print(\"\")\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint the include and library path being used for debugging purposes.", "response": "def print_build_info(self):\n        \"\"\"Prints the include and library path being used for debugging purposes.\"\"\"\n        if self.static_extension:\n            build_type = \"static extension\"\n        else:\n            build_type = \"dynamic extension\"\n        print(\"Build type: %s\" % build_type)\n        print(\"Include path: %s\" % \" \".join(self.include_dirs))\n        print(\"Library path: %s\" % \" \".join(self.library_dirs))\n        print(\"Linked dynamic libraries: %s\" % \" \".join(self.libraries))\n        print(\"Linked static libraries: %s\" % \" \".join(self.extra_objects))\n        print(\"Extra compiler options: %s\" % \" \".join(self.extra_compile_args))\n        print(\"Extra linker options: %s\" % \" \".join(self.extra_link_args))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef process_args_from_command_line(self):\n        # Yes, this is ugly, but we don't want to interfere with setup.py's own\n        # option handling\n        opts_to_remove = []\n        for idx, option in enumerate(sys.argv):\n            if not option.startswith(\"--\"):\n                continue\n            if option == \"--static\":\n                opts_to_remove.append(idx)\n                self.static_extension = True\n            elif option == \"--no-download\":\n                opts_to_remove.append(idx)\n                self.download_igraph_if_needed = False\n            elif option == \"--no-pkg-config\":\n                opts_to_remove.append(idx)\n                self.use_pkgconfig = False\n            elif option == \"--no-progress-bar\":\n                opts_to_remove.append(idx)\n                self.show_progress_bar = False\n            elif option == \"--no-wait\":\n                opts_to_remove.append(idx)\n                self.wait = False                \n            elif option.startswith(\"--c-core-version\"):\n                opts_to_remove.append(idx)\n                if option == \"--c-core-version\":\n                    value = sys.argv[idx+1]\n                    opts_to_remove.append(idx+1)\n                else:\n                    value = option.split(\"=\", 1)[1]\n                self.c_core_versions = [value]\n            elif option.startswith(\"--c-core-url\"):\n                opts_to_remove.append(idx)\n                if option == \"--c-core-url\":\n                    value = sys.argv[idx+1]\n                    opts_to_remove.append(idx+1)\n                else:\n                    value = option.split(\"=\", 1)[1]\n                self.c_core_url = value\n\n        for idx in reversed(opts_to_remove):\n            sys.argv[idx:(idx+1)] = []", "response": "Processes the command line options before they are passed to the build configuration and sets up the build configuration."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replace_static_libraries(self, exclusions=None):\n        if \"stdc++\" not in self.libraries:\n            self.libraries.append(\"stdc++\")\n\n        if exclusions is None:\n            exclusions = []\n\n        for library_name in set(self.libraries) - set(exclusions):\n            static_lib = find_static_library(library_name, self.library_dirs)\n            if static_lib:\n                self.libraries.remove(library_name)\n                self.extra_objects.append(static_lib)", "response": "Replaces references to libraries with full paths to their static version versions if the static version is to be found on the library path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef use_built_igraph(self):\n        buildcfg.include_dirs = [os.path.join(\"igraphcore\", \"include\")]\n        buildcfg.library_dirs = [os.path.join(\"igraphcore\", \"lib\")]\n        buildcfg.static_extension = True\n\n        buildcfg_file = os.path.join(\"igraphcore\", \"build.cfg\")\n        if os.path.exists(buildcfg_file):\n            buildcfg.libraries = eval(open(buildcfg_file).read())", "response": "Assumes that igraph is built in igraphcore and sets up\n        the include and library paths and the library names accordingly."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntrying to guess the proper library names include and library paths for the current igraph environment.", "response": "def use_educated_guess(self):\n        \"\"\"Tries to guess the proper library names, include and library paths\n        if everything else failed.\"\"\"\n\n        preprocess_fallback_config()\n\n        global LIBIGRAPH_FALLBACK_LIBRARIES\n        global LIBIGRAPH_FALLBACK_INCLUDE_DIRS\n        global LIBIGRAPH_FALLBACK_LIBRARY_DIRS\n\n        print(\"WARNING: we were not able to detect where igraph is installed on\")\n        print(\"your machine (if it is installed at all). We will use the fallback\")\n        print(\"library and include paths hardcoded in setup.py and hope that the\")\n        print(\"C core of igraph is installed there.\")\n        print(\"\")\n        print(\"If the compilation fails and you are sure that igraph is installed\")\n        print(\"on your machine, adjust the following two variables in setup.py\")\n        print(\"accordingly and try again:\")\n        print(\"\")\n        print(\"- LIBIGRAPH_FALLBACK_INCLUDE_DIRS\",\n            LIBIGRAPH_FALLBACK_INCLUDE_DIRS)\n        print(\"- LIBIGRAPH_FALLBACK_LIBRARY_DIRS\",\n            LIBIGRAPH_FALLBACK_LIBRARY_DIRS)\n        print(\"\")\n\n        seconds_remaining = 10 if self.wait else 0\n        while seconds_remaining > 0:\n            if seconds_remaining > 1:\n                plural = \"s\"\n            else:\n                plural = \"\"\n\n            sys.stdout.write(\"\\rContinuing in %2d second%s; press Enter to continue \"\n                    \"immediately. \" % (seconds_remaining, plural))\n            sys.stdout.flush()\n\n            if os.name == 'nt':\n              if msvcrt.kbhit():\n                  if msvcrt.getch() == b'\\r': # not '\\n'\n                      break\n              time.sleep(1)\n            else:\n              rlist, _, _ = select([sys.stdin], [], [], 1)\n              if rlist:\n                  sys.stdin.readline()\n                  break\n\n            seconds_remaining -= 1\n        sys.stdout.write(\"\\r\" + \" \"*65 + \"\\r\")\n\n        self.libraries = LIBIGRAPH_FALLBACK_LIBRARIES[:]\n        if self.static_extension:\n            self.libraries.extend([\"xml2\", \"z\", \"m\", \"stdc++\"])\n        self.include_dirs = LIBIGRAPH_FALLBACK_INCLUDE_DIRS[:]\n        self.library_dirs = LIBIGRAPH_FALLBACK_LIBRARY_DIRS[:]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncapture a frame of data.", "response": "def capture(self, data_buffer = None, log_time = False, debug_print = False, retry_reset = True):\n    \"\"\"Capture a frame of data.\n\n    Captures 80x60 uint16 array of non-normalized (raw 12-bit) data. Returns that frame and a frame_id (which\n    is currently just the sum of all pixels). The Lepton will return multiple, identical frames at a rate of up\n    to ~27 Hz, with unique frames at only ~9 Hz, so the frame_id can help you from doing additional work\n    processing duplicate frames.\n\n    Args:\n      data_buffer (numpy.ndarray): Optional. If specified, should be ``(60,80,1)`` with `dtype`=``numpy.uint16``.\n\n    Returns:\n      tuple consisting of (data_buffer, frame_id)\n    \"\"\"\n\n    start = time.time()\n\n    if data_buffer is None:\n      data_buffer = np.ndarray((Lepton.ROWS, Lepton.COLS, 1), dtype=np.uint16)\n    elif data_buffer.ndim < 2 or data_buffer.shape[0] < Lepton.ROWS or data_buffer.shape[1] < Lepton.COLS or data_buffer.itemsize < 2:\n      raise Exception(\"Provided input array not large enough\")\n\n    while True:\n      Lepton.capture_segment(self.__handle, self.__xmit_buf, self.__msg_size, self.__capture_buf[0])\n      if retry_reset and (self.__capture_buf[20, 0] & 0xFF0F) != 0x1400: # make sure that this is a well-formed frame, should find line 20 here\n        # Leave chip select deasserted for at least 185 ms to reset\n        if debug_print:\n          print(\"Garbage frame number reset waiting...\")\n        time.sleep(0.185)\n      else:\n        break\n\n    self.__capture_buf.byteswap(True)\n    data_buffer[:,:] = self.__capture_buf[:,2:]\n\n    end = time.time()\n\n    if debug_print:\n      print(\"---\")\n      for i in range(Lepton.ROWS):\n        fid = self.__capture_buf[i, 0, 0]\n        crc = self.__capture_buf[i, 1, 0]\n        fnum = fid & 0xFFF\n        print(\"0x{0:04x} 0x{1:04x} : Row {2:2} : crc={1}\".format(fid, crc, fnum))\n      print(\"---\")\n\n    if log_time:\n      print(\"frame processed int {0}s, {1}hz\".format(end-start, 1.0/(end-start)))\n\n    # TODO: turn on telemetry to get real frame id, sum on this array is fast enough though (< 500us)\n    return data_buffer, data_buffer.sum()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disambiguate(self, word):\n        matches = re.match(r'^per([bcdfghjklmnpqrstvwxyz])([a-z])er([aiueo])(.*)$', word)\n        if matches:\n            if matches.group(1) == 'r':\n                return\n            return matches.group(1) + matches.group(2) + 'er' + matches.group(3) + matches.group(4)", "response": "Disambiguate Prefix Rule 24 - > per - CAerV"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstem a text string to its common stem form.", "response": "def stem(self, text):\n        \"\"\"Stem a text string to its common stem form.\"\"\"\n        normalizedText = TextNormalizer.normalize_text(text)\n\n        words = normalizedText.split(' ')\n        stems = []\n\n        for word in words:\n            stems.append(self.stem_word(word))\n\n        return ' '.join(stems)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstem a word to its common stem form.", "response": "def stem_word(self, word):\n        \"\"\"Stem a word to its common stem form.\"\"\"\n        if self.is_plural(word):\n            return self.stem_plural_word(word)\n        else:\n            return self.stem_singular_word(word)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stem_plural_word(self, plural):\n        matches = re.match(r'^(.*)-(.*)$', plural)\n        #translated from PHP conditional check:\n        #if (!isset($words[1]) || !isset($words[2]))\n        if not matches:\n            return plural\n        words = [matches.group(1), matches.group(2)]\n\n        #malaikat-malaikat-nya -> malaikat malaikat-nya\n        suffix = words[1]\n        suffixes = ['ku', 'mu', 'nya', 'lah', 'kah', 'tah', 'pun']\n        matches = re.match(r'^(.*)-(.*)$', words[0])\n        if suffix in suffixes and matches:\n            words[0] = matches.group(1)\n            words[1] = matches.group(2) + '-' + suffix\n\n        #berbalas-balasan -> balas\n        rootWord1 = self.stem_singular_word(words[0])\n        rootWord2 = self.stem_singular_word(words[1])\n\n        #meniru-nirukan -> tiru\n        if not self.dictionary.contains(words[1]) and rootWord2 == words[1]:\n            rootWord2 = self.stem_singular_word('me' + words[1])\n\n        if rootWord1 == rootWord2:\n            return rootWord1\n        else:\n            return plural", "response": "Stem a plural word to its common stem form."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstem a singular word to its common stem form.", "response": "def stem_singular_word(self, word):\n        \"\"\"Stem a singular word to its common stem form.\"\"\"\n        context = Context(word, self.dictionary, self.visitor_provider)\n        context.execute()\n\n        return context.result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef execute(self):\n\n        #step 1 - 5\n        self.start_stemming_process()\n\n        #step 6\n        if self.dictionary.contains(self.current_word):\n            self.result = self.current_word\n        else:\n            self.result = self.original_word", "response": "Execute the stemming process ; the result can be retrieved with result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loop_pengembalian_akhiran(self):\n        self.restore_prefix()\n\n        removals = self.removals\n        reversed_removals = reversed(removals)\n        current_word = self.current_word\n\n        for removal in reversed_removals:\n            if not self.is_suffix_removal(removal):\n                continue\n            if removal.get_removed_part() == 'kan':\n                self.current_word = removal.result + 'k'\n\n                #step 4,5\n                self.remove_prefixes()\n                if self.dictionary.contains(self.current_word):\n                    return\n                self.current_word = removal.result + 'kan'\n            else:\n                self.current_word = removal.get_subject()\n\n            #step 4,5\n            self.remove_prefixes()\n            if self.dictionary.contains(self.current_word):\n                return\n\n            self.removals = removals\n            self.current_word = current_word", "response": "ECS Loop Pengembalian Akhiran"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef restore_prefix(self):\n        for removal in self.removals:\n            #return the word before precoding (the subject of first prefix removal)\n            self.current_word = removal.get_subject()\n            break\n\n        for removal in self.removals:\n            if removal.get_affix_type() == 'DP':\n                self.removals.remove(removal)", "response": "Restore prefix to proceed with ECS loop pengembalian akhiran"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves stop words from the dictionary.", "response": "def remove(self, text):\n        \"\"\"Remove stop words.\"\"\"\n        words = text.split(' ')\n        stopped_words = [word for word in words if not self.dictionary.contains(word)]\n\n        return ' '.join(stopped_words)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_stemmer(self, isDev=False):\n\n        words = self.get_words(isDev)\n        dictionary = ArrayDictionary(words)\n        stemmer = Stemmer(dictionary)\n\n        resultCache = ArrayCache()\n        cachedStemmer = CachedStemmer(resultCache, stemmer)\n\n        return cachedStemmer", "response": "Creates a Stemmer instance for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add(self, word):\n        if not word or word.strip() == '':\n            return\n        self.words[word]=word", "response": "Add a word to the dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Boolean(v):\n    if isinstance(v, basestring):\n        v = v.lower()\n        if v in ('1', 'true', 'yes', 'on', 'enable'):\n            return True\n        if v in ('0', 'false', 'no', 'off', 'disable'):\n            return False\n        raise ValueError\n    return bool(v)", "response": "Convert human - readable boolean values to a bool."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Email(v):\n    try:\n        if not v or \"@\" not in v:\n            raise EmailInvalid(\"Invalid Email\")\n        user_part, domain_part = v.rsplit('@', 1)\n\n        if not (USER_REGEX.match(user_part) and DOMAIN_REGEX.match(domain_part)):\n            raise EmailInvalid(\"Invalid Email\")\n        return v\n    except:\n        raise ValueError", "response": "Verify that the value is an Email or not."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nverifies that the value is a Fully qualified domain name URL.", "response": "def FqdnUrl(v):\n    \"\"\"Verify that the value is a Fully qualified domain name URL.\n\n    >>> s = Schema(FqdnUrl())\n    >>> with raises(MultipleInvalid, 'expected a Fully qualified domain name URL'):\n    ...   s(\"http://localhost/\")\n    >>> s('http://w3.org')\n    'http://w3.org'\n    \"\"\"\n    try:\n        parsed_url = _url_validation(v)\n        if \".\" not in parsed_url.netloc:\n            raise UrlInvalid(\"must have a domain name in URL\")\n        return v\n    except:\n        raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef IsFile(v):\n    try:\n        if v:\n            v = str(v)\n            return os.path.isfile(v)\n        else:\n            raise FileInvalid('Not a file')\n    except TypeError:\n        raise FileInvalid('Not a file')", "response": "Verify the file exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nverifies the directory exists.", "response": "def IsDir(v):\n    \"\"\"Verify the directory exists.\n\n    >>> IsDir()('/')\n    '/'\n    >>> with raises(DirInvalid, 'Not a directory'):\n    ...   IsDir()(None)\n    \"\"\"\n    try:\n        if v:\n            v = str(v)\n            return os.path.isdir(v)\n        else:\n            raise DirInvalid(\"Not a directory\")\n    except TypeError:\n        raise DirInvalid(\"Not a directory\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef PathExists(v):\n    try:\n        if v:\n            v = str(v)\n            return os.path.exists(v)\n        else:\n            raise PathInvalid(\"Not a Path\")\n    except TypeError:\n        raise PathInvalid(\"Not a Path\")", "response": "Verify the path exists regardless of its type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the precision and scale of the number.", "response": "def _get_precision_scale(self, number):\n        \"\"\"\n        :param number:\n        :return: tuple(precision, scale, decimal_number)\n        \"\"\"\n        try:\n            decimal_num = Decimal(number)\n        except InvalidOperation:\n            raise Invalid(self.msg or 'Value must be a number enclosed with string')\n\n        return (len(decimal_num.as_tuple().digits), -(decimal_num.as_tuple().exponent), decimal_num)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _compile_itemsort():\n    '''return sort function of mappings'''\n\n    def is_extra(key_):\n        return key_ is Extra\n\n    def is_remove(key_):\n        return isinstance(key_, Remove)\n\n    def is_marker(key_):\n        return isinstance(key_, Marker)\n\n    def is_type(key_):\n        return inspect.isclass(key_)\n\n    def is_callable(key_):\n        return callable(key_)\n\n    # priority list for map sorting (in order of checking)\n    # We want Extra to match last, because it's a catch-all. On the other hand,\n    # Remove markers should match first (since invalid values will not\n    # raise an Error, instead the validator will check if other schemas match\n    # the same value).\n    priority = [(1, is_remove),  # Remove highest priority after values\n                (2, is_marker),  # then other Markers\n                (4, is_type),  # types/classes lowest before Extra\n                (3, is_callable),  # callables after markers\n                (5, is_extra)]  # Extra lowest priority\n\n    def item_priority(item_):\n        key_ = item_[0]\n        for i, check_ in priority:\n            if check_(key_):\n                return i\n        # values have hightest priorities\n        return 0\n\n    return item_priority", "response": "return sort function of mappings"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _iterate_object(obj):\n    d = {}\n    try:\n        d = vars(obj)\n    except TypeError:\n        # maybe we have named tuple here?\n        if hasattr(obj, '_asdict'):\n            d = obj._asdict()\n    for item in iteritems(d):\n        yield item\n    try:\n        slots = obj.__slots__\n    except AttributeError:\n        pass\n    else:\n        for key in slots:\n            if key != '__dict__':\n                yield (key, getattr(obj, key))", "response": "Return iterator over object attributes. Respect objects with\n    defined __slots__."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _args_to_dict(func, args):\n    if sys.version_info >= (3, 0):\n        arg_count = func.__code__.co_argcount\n        arg_names = func.__code__.co_varnames[:arg_count]\n    else:\n        arg_count = func.func_code.co_argcount\n        arg_names = func.func_code.co_varnames[:arg_count]\n\n    arg_value_list = list(args)\n    arguments = dict((arg_name, arg_value_list[i])\n                     for i, arg_name in enumerate(arg_names)\n                     if i < len(arg_value_list))\n    return arguments", "response": "Returns argument names as values as key - value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _merge_args_with_kwargs(args_dict, kwargs_dict):\n    ret = args_dict.copy()\n    ret.update(kwargs_dict)\n    return ret", "response": "Merge args with kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(*a, **kw):\n    RETURNS_KEY = '__return__'\n\n    def validate_schema_decorator(func):\n\n        returns_defined = False\n        returns = None\n\n        schema_args_dict = _args_to_dict(func, a)\n        schema_arguments = _merge_args_with_kwargs(schema_args_dict, kw)\n\n        if RETURNS_KEY in schema_arguments:\n            returns_defined = True\n            returns = schema_arguments[RETURNS_KEY]\n            del schema_arguments[RETURNS_KEY]\n\n        input_schema = (Schema(schema_arguments, extra=ALLOW_EXTRA)\n                        if len(schema_arguments) != 0 else lambda x: x)\n        output_schema = Schema(returns) if returns_defined else lambda x: x\n\n        @wraps(func)\n        def func_wrapper(*args, **kwargs):\n            args_dict = _args_to_dict(func, args)\n            arguments = _merge_args_with_kwargs(args_dict, kwargs)\n            validated_arguments = input_schema(arguments)\n            output = func(**validated_arguments)\n            return output_schema(output)\n\n        return func_wrapper\n\n    return validate_schema_decorator", "response": "Decorator for validating arguments of a function against a given schema."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef infer(cls, data, **kwargs):\n        def value_to_schema_type(value):\n            if isinstance(value, dict):\n                if len(value) == 0:\n                    return dict\n                return {k: value_to_schema_type(v)\n                        for k, v in iteritems(value)}\n            if isinstance(value, list):\n                if len(value) == 0:\n                    return list\n                else:\n                    return [value_to_schema_type(v)\n                            for v in value]\n            return type(value)\n\n        return cls(value_to_schema_type(data), **kwargs)", "response": "Create a Schema from concrete data."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates validator for given mapping.", "response": "def _compile_mapping(self, schema, invalid_msg=None):\n        \"\"\"Create validator for given mapping.\"\"\"\n        invalid_msg = invalid_msg or 'mapping value'\n\n        # Keys that may be required\n        all_required_keys = set(key for key in schema\n                                if key is not Extra and\n                                ((self.required and not isinstance(key, (Optional, Remove))) or\n                                 isinstance(key, Required)))\n\n        # Keys that may have defaults\n        all_default_keys = set(key for key in schema\n                               if isinstance(key, Required) or\n                               isinstance(key, Optional))\n\n        _compiled_schema = {}\n        for skey, svalue in iteritems(schema):\n            new_key = self._compile(skey)\n            new_value = self._compile(svalue)\n            _compiled_schema[skey] = (new_key, new_value)\n\n        candidates = list(_iterate_mapping_candidates(_compiled_schema))\n\n        # After we have the list of candidates in the correct order, we want to apply some optimization so that each\n        # key in the data being validated will be matched against the relevant schema keys only.\n        # No point in matching against different keys\n        additional_candidates = []\n        candidates_by_key = {}\n        for skey, (ckey, cvalue) in candidates:\n            if type(skey) in primitive_types:\n                candidates_by_key.setdefault(skey, []).append((skey, (ckey, cvalue)))\n            elif isinstance(skey, Marker) and type(skey.schema) in primitive_types:\n                candidates_by_key.setdefault(skey.schema, []).append((skey, (ckey, cvalue)))\n            else:\n                # These are wildcards such as 'int', 'str', 'Remove' and others which should be applied to all keys\n                additional_candidates.append((skey, (ckey, cvalue)))\n\n        def validate_mapping(path, iterable, out):\n            required_keys = all_required_keys.copy()\n\n            # Build a map of all provided key-value pairs.\n            # The type(out) is used to retain ordering in case a ordered\n            # map type is provided as input.\n            key_value_map = type(out)()\n            for key, value in iterable:\n                key_value_map[key] = value\n\n            # Insert default values for non-existing keys.\n            for key in all_default_keys:\n                if not isinstance(key.default, Undefined) and \\\n                   key.schema not in key_value_map:\n                    # A default value has been specified for this missing\n                    # key, insert it.\n                    key_value_map[key.schema] = key.default()\n\n            error = None\n            errors = []\n            for key, value in key_value_map.items():\n                key_path = path + [key]\n                remove_key = False\n\n                # Optimization. Validate against the matching key first, then fallback to the rest\n                relevant_candidates = itertools.chain(candidates_by_key.get(key, []), additional_candidates)\n\n                # compare each given key/value against all compiled key/values\n                # schema key, (compiled key, compiled value)\n                for skey, (ckey, cvalue) in relevant_candidates:\n                    try:\n                        new_key = ckey(key_path, key)\n                    except er.Invalid as e:\n                        if len(e.path) > len(key_path):\n                            raise\n                        if not error or len(e.path) > len(error.path):\n                            error = e\n                        continue\n                    # Backtracking is not performed once a key is selected, so if\n                    # the value is invalid we immediately throw an exception.\n                    exception_errors = []\n                    # check if the key is marked for removal\n                    is_remove = new_key is Remove\n                    try:\n                        cval = cvalue(key_path, value)\n                        # include if it's not marked for removal\n                        if not is_remove:\n                            out[new_key] = cval\n                        else:\n                            remove_key = True\n                            continue\n                    except er.MultipleInvalid as e:\n                        exception_errors.extend(e.errors)\n                    except er.Invalid as e:\n                        exception_errors.append(e)\n\n                    if exception_errors:\n                        if is_remove or remove_key:\n                            continue\n                        for err in exception_errors:\n                            if len(err.path) <= len(key_path):\n                                err.error_type = invalid_msg\n                            errors.append(err)\n                        # If there is a validation error for a required\n                        # key, this means that the key was provided.\n                        # Discard the required key so it does not\n                        # create an additional, noisy exception.\n                        required_keys.discard(skey)\n                        break\n\n                    # Key and value okay, mark as found in case it was\n                    # a Required() field.\n                    required_keys.discard(skey)\n\n                    break\n                else:\n                    if remove_key:\n                        # remove key\n                        continue\n                    elif self.extra == ALLOW_EXTRA:\n                        out[key] = value\n                    elif self.extra != REMOVE_EXTRA:\n                        errors.append(er.Invalid('extra keys not allowed', key_path))\n                        # else REMOVE_EXTRA: ignore the key so it's removed from output\n\n            # for any required keys left that weren't found and don't have defaults:\n            for key in required_keys:\n                msg = key.msg if hasattr(key, 'msg') and key.msg else 'required key not provided'\n                errors.append(er.RequiredFieldInvalid(msg, path + [key]))\n            if errors:\n                raise er.MultipleInvalid(errors)\n\n            return out\n\n        return validate_mapping"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate an object. Has the same behavior as dictionary validator but work with object attributes. For example: >>> class Structure(object): ... def __init__(self, one=None, three=None): ... self.one = one ... self.three = three ... >>> validate = Schema(Object({'one': 'two', 'three': 'four'}, cls=Structure)) >>> with raises(er.MultipleInvalid, \"not a valid value for object value @ data['one']\"): ... validate(Structure(one='three'))", "response": "def _compile_object(self, schema):\n        \"\"\"Validate an object.\n\n        Has the same behavior as dictionary validator but work with object\n        attributes.\n\n        For example:\n\n            >>> class Structure(object):\n            ...     def __init__(self, one=None, three=None):\n            ...         self.one = one\n            ...         self.three = three\n            ...\n            >>> validate = Schema(Object({'one': 'two', 'three': 'four'}, cls=Structure))\n            >>> with raises(er.MultipleInvalid, \"not a valid value for object value @ data['one']\"):\n            ...   validate(Structure(one='three'))\n\n        \"\"\"\n        base_validate = self._compile_mapping(\n            schema, invalid_msg='object value')\n\n        def validate_object(path, data):\n            if schema.cls is not UNDEFINED and not isinstance(data, schema.cls):\n                raise er.ObjectInvalid('expected a {0!r}'.format(schema.cls), path)\n            iterable = _iterate_object(data)\n            iterable = ifilter(lambda item: item[1] is not None, iterable)\n            out = base_validate(path, iterable, {})\n            return type(data)(**out)\n\n        return validate_object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompile a dictionary into a dictionary.", "response": "def _compile_dict(self, schema):\n        \"\"\"Validate a dictionary.\n\n        A dictionary schema can contain a set of values, or at most one\n        validator function/type.\n\n        A dictionary schema will only validate a dictionary:\n\n            >>> validate = Schema({})\n            >>> with raises(er.MultipleInvalid, 'expected a dictionary'):\n            ...   validate([])\n\n        An invalid dictionary value:\n\n            >>> validate = Schema({'one': 'two', 'three': 'four'})\n            >>> with raises(er.MultipleInvalid, \"not a valid value for dictionary value @ data['one']\"):\n            ...   validate({'one': 'three'})\n\n        An invalid key:\n\n            >>> with raises(er.MultipleInvalid, \"extra keys not allowed @ data['two']\"):\n            ...   validate({'two': 'three'})\n\n\n        Validation function, in this case the \"int\" type:\n\n            >>> validate = Schema({'one': 'two', 'three': 'four', int: str})\n\n        Valid integer input:\n\n            >>> validate({10: 'twenty'})\n            {10: 'twenty'}\n\n        By default, a \"type\" in the schema (in this case \"int\") will be used\n        purely to validate that the corresponding value is of that type. It\n        will not Coerce the value:\n\n            >>> with raises(er.MultipleInvalid, \"extra keys not allowed @ data['10']\"):\n            ...   validate({'10': 'twenty'})\n\n        Wrap them in the Coerce() function to achieve this:\n            >>> from voluptuous import Coerce\n            >>> validate = Schema({'one': 'two', 'three': 'four',\n            ...                    Coerce(int): str})\n            >>> validate({'10': 'twenty'})\n            {10: 'twenty'}\n\n        Custom message for required key\n\n            >>> validate = Schema({Required('one', 'required'): 'two'})\n            >>> with raises(er.MultipleInvalid, \"required @ data['one']\"):\n            ...   validate({})\n\n        (This is to avoid unexpected surprises.)\n\n        Multiple errors for nested field in a dict:\n\n        >>> validate = Schema({\n        ...     'adict': {\n        ...         'strfield': str,\n        ...         'intfield': int\n        ...     }\n        ... })\n        >>> try:\n        ...     validate({\n        ...         'adict': {\n        ...             'strfield': 123,\n        ...             'intfield': 'one'\n        ...         }\n        ...     })\n        ... except er.MultipleInvalid as e:\n        ...     print(sorted(str(i) for i in e.errors)) # doctest: +NORMALIZE_WHITESPACE\n        [\"expected int for dictionary value @ data['adict']['intfield']\",\n         \"expected str for dictionary value @ data['adict']['strfield']\"]\n\n        \"\"\"\n        base_validate = self._compile_mapping(\n            schema, invalid_msg='dictionary value')\n\n        groups_of_exclusion = {}\n        groups_of_inclusion = {}\n        for node in schema:\n            if isinstance(node, Exclusive):\n                g = groups_of_exclusion.setdefault(node.group_of_exclusion, [])\n                g.append(node)\n            elif isinstance(node, Inclusive):\n                g = groups_of_inclusion.setdefault(node.group_of_inclusion, [])\n                g.append(node)\n\n        def validate_dict(path, data):\n            if not isinstance(data, dict):\n                raise er.DictInvalid('expected a dictionary', path)\n\n            errors = []\n            for label, group in groups_of_exclusion.items():\n                exists = False\n                for exclusive in group:\n                    if exclusive.schema in data:\n                        if exists:\n                            msg = exclusive.msg if hasattr(exclusive, 'msg') and exclusive.msg else \\\n                                \"two or more values in the same group of exclusion '%s'\" % label\n                            next_path = path + [VirtualPathComponent(label)]\n                            errors.append(er.ExclusiveInvalid(msg, next_path))\n                            break\n                        exists = True\n\n            if errors:\n                raise er.MultipleInvalid(errors)\n\n            for label, group in groups_of_inclusion.items():\n                included = [node.schema in data for node in group]\n                if any(included) and not all(included):\n                    msg = \"some but not all values in the same group of inclusion '%s'\" % label\n                    for g in group:\n                        if hasattr(g, 'msg') and g.msg:\n                            msg = g.msg\n                            break\n                    next_path = path + [VirtualPathComponent(label)]\n                    errors.append(er.InclusiveInvalid(msg, next_path))\n                    break\n\n            if errors:\n                raise er.MultipleInvalid(errors)\n\n            out = data.__class__()\n            return base_validate(path, iteritems(data), out)\n\n        return validate_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate a sequence type.", "response": "def _compile_sequence(self, schema, seq_type):\n        \"\"\"Validate a sequence type.\n\n        This is a sequence of valid values or validators tried in order.\n\n        >>> validator = Schema(['one', 'two', int])\n        >>> validator(['one'])\n        ['one']\n        >>> with raises(er.MultipleInvalid, 'expected int @ data[0]'):\n        ...   validator([3.5])\n        >>> validator([1])\n        [1]\n        \"\"\"\n        _compiled = [self._compile(s) for s in schema]\n        seq_type_name = seq_type.__name__\n\n        def validate_sequence(path, data):\n            if not isinstance(data, seq_type):\n                raise er.SequenceTypeInvalid('expected a %s' % seq_type_name, path)\n\n            # Empty seq schema, allow any data.\n            if not schema:\n                if data:\n                    raise er.MultipleInvalid([\n                        er.ValueInvalid('not a valid value', [value]) for value in data\n                    ])\n                return data\n\n            out = []\n            invalid = None\n            errors = []\n            index_path = UNDEFINED\n            for i, value in enumerate(data):\n                index_path = path + [i]\n                invalid = None\n                for validate in _compiled:\n                    try:\n                        cval = validate(index_path, value)\n                        if cval is not Remove:  # do not include Remove values\n                            out.append(cval)\n                        break\n                    except er.Invalid as e:\n                        if len(e.path) > len(index_path):\n                            raise\n                        invalid = e\n                else:\n                    errors.append(invalid)\n            if errors:\n                raise er.MultipleInvalid(errors)\n\n            if _isnamedtuple(data):\n                return type(data)(*out)\n            else:\n                return type(data)(out)\n\n        return validate_sequence"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates a set. A set is an unordered collection of unique elements. >>> validator = Schema({int}) >>> validator(set([42])) == set([42]) True >>> with raises(er.Invalid, 'expected a set'): ... validator(42) >>> with raises(er.MultipleInvalid, 'invalid value in set'): ... validator(set(['a']))", "response": "def _compile_set(self, schema):\n        \"\"\"Validate a set.\n\n        A set is an unordered collection of unique elements.\n\n        >>> validator = Schema({int})\n        >>> validator(set([42])) == set([42])\n        True\n        >>> with raises(er.Invalid, 'expected a set'):\n        ...   validator(42)\n        >>> with raises(er.MultipleInvalid, 'invalid value in set'):\n        ...   validator(set(['a']))\n        \"\"\"\n        type_ = type(schema)\n        type_name = type_.__name__\n\n        def validate_set(path, data):\n            if not isinstance(data, type_):\n                raise er.Invalid('expected a %s' % type_name, path)\n\n            _compiled = [self._compile(s) for s in schema]\n            errors = []\n            for value in data:\n                for validate in _compiled:\n                    try:\n                        validate(path, value)\n                        break\n                    except er.Invalid:\n                        pass\n                else:\n                    invalid = er.Invalid('invalid value in %s' % type_name, path)\n                    errors.append(invalid)\n\n            if errors:\n                raise er.MultipleInvalid(errors)\n\n            return data\n\n        return validate_set"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new schema by merging this and the provided schema.", "response": "def extend(self, schema, required=None, extra=None):\n        \"\"\"Create a new `Schema` by merging this and the provided `schema`.\n\n        Neither this `Schema` nor the provided `schema` are modified. The\n        resulting `Schema` inherits the `required` and `extra` parameters of\n        this, unless overridden.\n\n        Both schemas must be dictionary-based.\n\n        :param schema: dictionary to extend this `Schema` with\n        :param required: if set, overrides `required` of this `Schema`\n        :param extra: if set, overrides `extra` of this `Schema`\n        \"\"\"\n\n        assert type(self.schema) == dict and type(schema) == dict, 'Both schemas must be dictionary-based'\n\n        result = self.schema.copy()\n\n        # returns the key that may have been passed as arugment to Marker constructor\n        def key_literal(key):\n            return (key.schema if isinstance(key, Marker) else key)\n\n        # build a map that takes the key literals to the needed objects\n        # literal -> Required|Optional|literal\n        result_key_map = dict((key_literal(key), key) for key in result)\n\n        # for each item in the extension schema, replace duplicates\n        # or add new keys\n        for key, value in iteritems(schema):\n\n            # if the key is already in the dictionary, we need to replace it\n            # transform key to literal before checking presence\n            if key_literal(key) in result_key_map:\n\n                result_key = result_key_map[key_literal(key)]\n                result_value = result[result_key]\n\n                # if both are dictionaries, we need to extend recursively\n                # create the new extended sub schema, then remove the old key and add the new one\n                if type(result_value) == dict and type(value) == dict:\n                    new_value = Schema(result_value).extend(value).schema\n                    del result[result_key]\n                    result[key] = new_value\n                # one or the other or both are not sub-schemas, simple replacement is fine\n                # remove old key and add new one\n                else:\n                    del result[result_key]\n                    result[key] = value\n\n            # key is new and can simply be added\n            else:\n                result[key] = value\n\n        # recompile and send old object\n        result_cls = type(self)\n        result_required = (required if required is not None else self.required)\n        result_extra = (extra if extra is not None else self.extra)\n        return result_cls(result, required=result_required, extra=result_extra)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_upload_path(instance, filename):\n    if not instance.name:\n        instance.name = filename  # set original filename\n    date = timezone.now().date()\n    filename = '{name}.{ext}'.format(name=uuid4().hex,\n                                     ext=filename.split('.')[-1])\n\n    return os.path.join('post_office_attachments', str(date.year),\n                        str(date.month), str(date.day), filename)", "response": "Overriding to store the original filename"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_prep_value(self, value):\n        if isinstance(value, six.string_types):\n            return value\n        else:\n            return ', '.join(map(lambda s: s.strip(), value))", "response": "Prepare the value for the field."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(sender, recipients=None, cc=None, bcc=None, subject='', message='',\n           html_message='', context=None, scheduled_time=None, headers=None,\n           template=None, priority=None, render_on_delivery=False, commit=True,\n           backend=''):\n    \"\"\"\n    Creates an email from supplied keyword arguments. If template is\n    specified, email subject and content will be rendered during delivery.\n    \"\"\"\n    priority = parse_priority(priority)\n    status = None if priority == PRIORITY.now else STATUS.queued\n\n    if recipients is None:\n        recipients = []\n    if cc is None:\n        cc = []\n    if bcc is None:\n        bcc = []\n    if context is None:\n        context = ''\n\n    # If email is to be rendered during delivery, save all necessary\n    # information\n    if render_on_delivery:\n        email = Email(\n            from_email=sender,\n            to=recipients,\n            cc=cc,\n            bcc=bcc,\n            scheduled_time=scheduled_time,\n            headers=headers, priority=priority, status=status,\n            context=context, template=template, backend_alias=backend\n        )\n\n    else:\n\n        if template:\n            subject = template.subject\n            message = template.content\n            html_message = template.html_content\n\n        _context = Context(context or {})\n        subject = Template(subject).render(_context)\n        message = Template(message).render(_context)\n        html_message = Template(html_message).render(_context)\n\n        email = Email(\n            from_email=sender,\n            to=recipients,\n            cc=cc,\n            bcc=bcc,\n            subject=subject,\n            message=message,\n            html_message=html_message,\n            scheduled_time=scheduled_time,\n            headers=headers, priority=priority, status=status,\n            backend_alias=backend\n        )\n\n    if commit:\n        email.save()\n\n    return email", "response": "Creates an email from supplied keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_many(kwargs_list):\n    emails = []\n    for kwargs in kwargs_list:\n        emails.append(send(commit=False, **kwargs))\n    Email.objects.bulk_create(emails)", "response": "This function sends emails to many objects."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of emails that should be sent", "response": "def get_queued():\n    \"\"\"\n    Returns a list of emails that should be sent:\n     - Status is queued\n     - Has scheduled_time lower than the current time or None\n    \"\"\"\n    return Email.objects.filter(status=STATUS.queued) \\\n        .select_related('template') \\\n        .filter(Q(scheduled_time__lte=now()) | Q(scheduled_time=None)) \\\n        .order_by(*get_sending_order()).prefetch_related('attachments')[:get_batch_size()]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_queued(processes=1, log_level=None):\n    queued_emails = get_queued()\n    total_sent, total_failed = 0, 0\n    total_email = len(queued_emails)\n\n    logger.info('Started sending %s emails with %s processes.' %\n                (total_email, processes))\n\n    if log_level is None:\n        log_level = get_log_level()\n\n    if queued_emails:\n\n        # Don't use more processes than number of emails\n        if total_email < processes:\n            processes = total_email\n\n        if processes == 1:\n            total_sent, total_failed = _send_bulk(queued_emails,\n                                                  uses_multiprocessing=False,\n                                                  log_level=log_level)\n        else:\n            email_lists = split_emails(queued_emails, processes)\n\n            pool = Pool(processes)\n            results = pool.map(_send_bulk, email_lists)\n            pool.terminate()\n\n            total_sent = sum([result[0] for result in results])\n            total_failed = sum([result[1] for result in results])\n    message = '%s emails attempted, %s sent, %s failed' % (\n        total_email,\n        total_sent,\n        total_failed\n    )\n    logger.info(message)\n    return (total_sent, total_failed)", "response": "Sends all queued mails that have scheduled_time less than now or None."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend the given list of EmailMessages to the specified queue.", "response": "def send_messages(self, email_messages):\n        \"\"\"\n        Queue one or more EmailMessage objects and returns the number of\n        email messages sent.\n        \"\"\"\n        from .mail import create\n        from .utils import create_attachments\n\n        if not email_messages:\n            return\n\n        for email_message in email_messages:\n            subject = email_message.subject\n            from_email = email_message.from_email\n            message = email_message.body\n            headers = email_message.extra_headers\n\n            # Check whether email has 'text/html' alternative\n            alternatives = getattr(email_message, 'alternatives', ())\n            for alternative in alternatives:\n                if alternative[1].startswith('text/html'):\n                    html_message = alternative[0]\n                    break\n            else:\n                html_message = ''\n\n            attachment_files = {}\n            for attachment in email_message.attachments:\n                if isinstance(attachment, MIMEBase):\n                    attachment_files[attachment.get_filename()] = {\n                        'file': ContentFile(attachment.get_payload()),\n                        'mimetype': attachment.get_content_type(),\n                        'headers': OrderedDict(attachment.items()),\n                    }\n                else:\n                    attachment_files[attachment[0]] = ContentFile(attachment[1])\n\n            email = create(sender=from_email,\n                           recipients=email_message.to, cc=email_message.cc,\n                           bcc=email_message.bcc, subject=subject,\n                           message=message, html_message=html_message,\n                           headers=headers)\n\n            if attachment_files:\n                attachments = create_attachments(attachment_files)\n\n                email.attachments.add(*attachments)\n\n            if get_default_priority() == 'now':\n                email.dispatch()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the lock exists and is left over from an old process.", "response": "def valid_lock(self):\n        \"\"\"\n        See if the lock exists and is left over from an old process.\n        \"\"\"\n\n        lock_pid = self.get_lock_pid()\n\n        # If we're unable to get lock_pid\n        if lock_pid is None:\n            return False\n\n        # this is our process\n        if self._pid == lock_pid:\n            return True\n\n        # it is/was another process\n        # see if it is running\n        try:\n            os.kill(lock_pid, 0)\n        except OSError:\n            self.release()\n            return False\n\n        # it is running\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef acquire(self):\n\n        pid_file = os.open(self.pid_filename, os.O_CREAT | os.O_EXCL | os.O_RDWR)\n        os.write(pid_file, str(os.getpid()).encode('utf-8'))\n        os.close(pid_file)\n\n        if hasattr(os, 'symlink') and platform.system() != 'Windows':\n            os.symlink(self.pid_filename, self.lock_filename)\n        else:\n            # Windows platforms doesn't support symlinks, at least not through the os API\n            self.lock_filename = self.pid_filename", "response": "Acquire a new lock file for the current process."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to delete the lock files. Doesn t matter if we fail.", "response": "def release(self):\n        \"\"\"Try to delete the lock files. Doesn't matter if we fail\"\"\"\n        if self.lock_filename != self.pid_filename:\n            try:\n                os.unlink(self.lock_filename)\n            except OSError:\n                pass\n\n        try:\n            os.remove(self.pid_filename)\n        except OSError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_email_with_name(value):\n    value = force_text(value)\n\n    recipient = value\n    if '<' and '>' in value:\n        start = value.find('<') + 1\n        end = value.find('>')\n        if start < end:\n            recipient = value[start:end]\n\n    validate_email(recipient)", "response": "Validate email address.\n\n    Both \"Recipient Name <email@example.com>\" and \"email@example.com\" are valid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_comma_separated_emails(value):\n    if not isinstance(value, (tuple, list)):\n        raise ValidationError('Email list must be a list/tuple.')\n\n    for email in value:\n        try:\n            validate_email_with_name(email)\n        except ValidationError:\n            raise ValidationError('Invalid email: %s' % email, code='invalid')", "response": "Validate every email address in a comma separated list of emails."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating Django Template syntax.", "response": "def validate_template_syntax(source):\n    \"\"\"\n    Basic Django Template syntax validation. This allows for robuster template\n    authoring.\n    \"\"\"\n    try:\n        Template(source)\n    except (TemplateSyntaxError, TemplateDoesNotExist) as err:\n        raise ValidationError(text_type(err))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dictionary of available backend classes. For example the default backend is Django s SMTP. EmailBackend and the locationmem backend is LINMEM.", "response": "def get_available_backends():\n    \"\"\" Returns a dictionary of defined backend classes. For example:\n    {\n        'default': 'django.core.mail.backends.smtp.EmailBackend',\n        'locmem': 'django.core.mail.backends.locmem.EmailBackend',\n    }\n    \"\"\"\n    backends = get_config().get('BACKENDS', {})\n\n    if backends:\n        return backends\n\n    # Try to get backend settings from old style\n    # POST_OFFICE = {\n    #     'EMAIL_BACKEND': 'mybackend'\n    # }\n    backend = get_config().get('EMAIL_BACKEND')\n    if backend:\n        warnings.warn('Please use the new POST_OFFICE[\"BACKENDS\"] settings',\n                      DeprecationWarning)\n\n        backends['default'] = backend\n        return backends\n\n    # Fall back to Django's EMAIL_BACKEND definition\n    backends['default'] = getattr(\n        settings, 'EMAIL_BACKEND',\n        'django.core.mail.backends.smtp.EmailBackend')\n\n    # If EMAIL_BACKEND is set to use PostOfficeBackend\n    # and POST_OFFICE_BACKEND is not set, fall back to SMTP\n    if 'post_office.EmailBackend' in backends['default']:\n        backends['default'] = 'django.core.mail.backends.smtp.EmailBackend'\n\n    return backends"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends an email to the list of recipients.", "response": "def send_mail(subject, message, from_email, recipient_list, html_message='',\n              scheduled_time=None, headers=None, priority=PRIORITY.medium):\n    \"\"\"\n    Add a new message to the mail queue. This is a replacement for Django's\n    ``send_mail`` core email method.\n    \"\"\"\n\n    subject = force_text(subject)\n    status = None if priority == PRIORITY.now else STATUS.queued\n    emails = []\n    for address in recipient_list:\n        emails.append(\n            Email.objects.create(\n                from_email=from_email, to=address, subject=subject,\n                message=message, html_message=html_message, status=status,\n                headers=headers, priority=priority, scheduled_time=scheduled_time\n            )\n        )\n    if priority == PRIORITY.now:\n        for email in emails:\n            email.dispatch()\n    return emails"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction that returns an email template instance from cache or DB.", "response": "def get_email_template(name, language=''):\n    \"\"\"\n    Function that returns an email template instance, from cache or DB.\n    \"\"\"\n    use_cache = getattr(settings, 'POST_OFFICE_CACHE', True)\n    if use_cache:\n        use_cache = getattr(settings, 'POST_OFFICE_TEMPLATE_CACHE', True)\n    if not use_cache:\n        return EmailTemplate.objects.get(name=name, language=language)\n    else:\n        composite_name = '%s:%s' % (name, language)\n        email_template = cache.get(composite_name)\n        if email_template is not None:\n            return email_template\n        else:\n            email_template = EmailTemplate.objects.get(name=name,\n                                                       language=language)\n            cache.set(composite_name, email_template)\n            return email_template"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_attachments(attachment_files):\n    attachments = []\n    for filename, filedata in attachment_files.items():\n\n        if isinstance(filedata, dict):\n            content = filedata.get('file', None)\n            mimetype = filedata.get('mimetype', None)\n            headers = filedata.get('headers', None)\n        else:\n            content = filedata\n            mimetype = None\n            headers = None\n\n        opened_file = None\n\n        if isinstance(content, string_types):\n            # `content` is a filename - try to open the file\n            opened_file = open(content, 'rb')\n            content = File(opened_file)\n\n        attachment = Attachment()\n        if mimetype:\n            attachment.mimetype = mimetype\n        attachment.headers = headers\n        attachment.file.save(filename, content=content, save=True)\n\n        attachments.append(attachment)\n\n        if opened_file is not None:\n            opened_file.close()\n\n    return attachments", "response": "Create Attachment instances from a dict of file - like objects or a filename to open or a mimetype string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_emails(emails):\n\n    if isinstance(emails, string_types):\n        emails = [emails]\n    elif emails is None:\n        emails = []\n\n    for email in emails:\n        try:\n            validate_email_with_name(email)\n        except ValidationError:\n            raise ValidationError('%s is not a valid email address' % email)\n\n    return emails", "response": "A function that returns a list of valid email addresses."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_message(self, data: bytes) -> SegmentSequence:\n        if isinstance(data, bytes):\n            data = self.explode_segments(data)\n\n        message = SegmentSequence()\n        for segment in data:\n            seg = self.parse_segment(segment)\n            message.segments.append(seg)\n        return message", "response": "Takes a FinTS 3. 0 message as byte array and returns a parsed segment sequence"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serialize_message(self, message: SegmentSequence) -> bytes:\n        if isinstance(message, FinTS3Segment):\n            message = SegmentSequence([message])\n        if isinstance(message, (list, tuple, Iterable)):\n            message = SegmentSequence(list(message))\n\n        result = []\n\n        for segment in message.segments:\n            result.append(self.serialize_segment(segment))\n\n        return self.implode_segments(result)", "response": "Serialize a message into a byte array"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield an iterable of all matching segments in this Sequence.", "response": "def find_segments(self, query=None, version=None, callback=None, recurse=True, throw=False):\n        \"\"\"Yields an iterable of all matching segments.\n\n        :param query: Either a str or class specifying a segment type (such as 'HNHBK', or :class:`~fints.segments.message.HNHBK3`), or a list or tuple of strings or classes.\n                     If a list/tuple is specified, segments returning any matching type will be returned.\n        :param version: Either an int specifying a segment version, or a list or tuple of ints.\n                        If a list/tuple is specified, segments returning any matching version will be returned.\n        :param callback: A callable that will be given the segment as its sole argument and must return a boolean indicating whether to return this segment.\n        :param recurse: If True (the default), recurse into SegmentSequenceField values, otherwise only look at segments in this SegmentSequence.\n        :param throw: If True, a FinTSNoResponseError is thrown if no result is found. Defaults to False.\n\n        The match results of all given parameters will be AND-combined.\n        \"\"\"\n        found_something = False\n\n        if query is None:\n            query = []\n        elif isinstance(query, str) or not isinstance(query, (list, tuple, Iterable)):\n            query = [query]\n\n        if version is None:\n            version = []\n        elif not isinstance(version, (list, tuple, Iterable)):\n            version = [version]\n\n        if callback is None:\n            callback = lambda s: True\n\n        for s in self.segments:\n            if ((not query) or any((isinstance(s, t) if isinstance(t, type) else s.header.type == t) for t in query)) and \\\n                    ((not version) or any(s.header.version == v for v in version)) and \\\n                    callback(s):\n                yield s\n                found_something = True\n\n            if recurse:\n                for name, field in s._fields.items():\n                    val = getattr(s, name)\n                    if val and hasattr(val, 'find_segments'):\n                        for v in val.find_segments(query=query, version=version, callback=callback, recurse=recurse):\n                            yield v\n                            found_something = True\n\n        if throw and not found_something:\n            raise FinTSNoResponseError(\n                'The bank\\'s response did not contain a response to your request, please inspect debug log.'\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_segment_first(self, *args, **kwargs):\n\n        for m in self.find_segments(*args, **kwargs):\n            return m\n\n        return None", "response": "Finds the first matching segment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_segment_highest_version(self, query=None, version=None, callback=None, recurse=True, default=None):\n        # FIXME Test\n\n        retval = None\n\n        for s in self.find_segments(query=query, version=version, callback=callback, recurse=recurse):\n            if not retval or s.header.version > retval.header.version:\n                retval = s\n\n        if retval is None:\n            return default\n\n        return retval", "response": "Finds the highest matching segment.\n\n        Same parameters as find_segments but returns the match with the highest version or default."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_nested(self, stream=None, level=0, indent=\"    \", prefix=\"\", first_level_indent=True, trailer=\"\", print_doc=True, first_line_suffix=\"\"):\n        import sys\n        stream = stream or sys.stdout\n\n        stream.write(\n            ((prefix + level * indent) if first_level_indent else \"\")\n            + \"{}.{}(\".format(self.__class__.__module__, self.__class__.__name__)\n            + first_line_suffix\n            + \"\\n\"\n        )\n        for name, value in self._repr_items:\n            val = getattr(self, name)\n            if print_doc and not name.startswith(\"_\"):\n                docstring = self._fields[name]._inline_doc_comment(val)\n            else:\n                docstring = \"\"\n            if not hasattr(getattr(val, 'print_nested', None), '__call__'):\n                stream.write(\n                    (prefix + (level + 1) * indent) + \"{} = {!r},{}\\n\".format(name, val, docstring)\n                )\n            else:\n                stream.write(\n                    (prefix + (level + 1) * indent) + \"{} = \".format(name)\n                )\n                val.print_nested(stream=stream, level=level + 2, indent=indent, prefix=prefix, first_level_indent=False, trailer=\",\", print_doc=print_doc,\n                                 first_line_suffix=docstring)\n        stream.write((prefix + level * indent) + \"){}\\n\".format(trailer))", "response": "Structured nested print of the object to the given stream."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_data(cls, blob):\n        version, data = decompress_datablob(DATA_BLOB_MAGIC_RETRY, blob)\n\n        if version == 1:\n            for clazz in cls._all_subclasses():\n                if clazz.__name__ == data[\"_class_name\"]:\n                    return clazz._from_data_v1(data)\n\n        raise Exception(\"Invalid data blob data or version\")", "response": "Restore an object instance from a compressed datablob."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the state of this FinTSClient instance as an opaque datablob.", "response": "def deconstruct(self, including_private: bool=False) -> bytes:\n        \"\"\"Return state of this FinTSClient instance as an opaque datablob. You should not\n        use this object after calling this method.\n\n        Information about the connection is implicitly retrieved from the bank and\n        cached in the FinTSClient. This includes: system identifier, bank parameter\n        data, user parameter data. It's not strictly required to retain this information\n        across sessions, but beneficial. If possible, an API user SHOULD use this method\n        to serialize the client instance before destroying it, and provide the serialized\n        data next time an instance is constructed.\n\n        Parameter `including_private` should be set to True, if the storage is sufficiently\n        secure (with regards to confidentiality) to include private data, specifically,\n        account numbers and names. Most often this is the case.\n\n        Note: No connection information is stored in the datablob, neither is the PIN.\n        \"\"\"\n        data = self._deconstruct_v1(including_private=including_private)\n        return compress_datablob(DATA_BLOB_MAGIC, 1, data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_information(self):\n        retval = {\n            'bank': {},\n            'accounts': [],\n            'auth': {},\n        }\n        if self.bpa:\n            retval['bank']['name'] = self.bpa.bank_name\n        if self.bpd.segments:\n            retval['bank']['supported_operations'] = {\n                op: any(self.bpd.find_segment_first(cmd[0]+'I'+cmd[2:]+'S') for cmd in op.value)\n                for op in FinTSOperations\n            }\n            hispas = self.bpd.find_segment_first('HISPAS')\n            if hispas:\n                retval['bank']['supported_sepa_formats'] = list(hispas.parameter.supported_sepa_formats)\n            else:\n                retval['bank']['supported_sepa_formats'] = []\n        if self.upd.segments:\n            for upd in self.upd.find_segments('HIUPD'):\n                acc = {}\n                acc['iban'] = upd.iban\n                acc['account_number'] = upd.account_information.account_number\n                acc['subaccount_number'] = upd.account_information.subaccount_number\n                acc['bank_identifier'] = upd.account_information.bank_identifier\n                acc['customer_id'] = upd.customer_id\n                acc['type'] = upd.account_type\n                acc['currency'] = upd.account_currency\n                acc['owner_name'] = []\n                if upd.name_account_owner_1:\n                    acc['owner_name'].append(upd.name_account_owner_1)\n                if upd.name_account_owner_2:\n                    acc['owner_name'].append(upd.name_account_owner_2)\n                acc['product_name'] = upd.account_product_name\n                acc['supported_operations'] = {\n                    op: any(allowed_transaction.transaction in op.value for allowed_transaction in upd.allowed_transactions)\n                    for op in FinTSOperations\n                }\n                retval['accounts'].append(acc)\n        return retval", "response": "Returns the information about the connected bank."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_sepa_accounts(self):\n\n        with self._get_dialog() as dialog:\n            response = dialog.send(HKSPA1())\n            \n        self.accounts = []\n        for seg in response.find_segments(HISPA1, throw=True):\n            self.accounts.extend(seg.accounts)\n\n        return [a for a in [acc.as_sepa_account() for acc in self.accounts] if a]", "response": "Returns a list of SEPA accounts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting a sequence of fetch commands on dialog and return a list of responses.", "response": "def _fetch_with_touchdowns(self, dialog, segment_factory, *args, **kwargs):\n        \"\"\"Execute a sequence of fetch commands on dialog.\n        segment_factory must be a callable with one argument touchdown. Will be None for the\n        first call and contains the institute's touchdown point on subsequent calls.\n        segment_factory must return a command segment.\n        Extra arguments will be passed to FinTSMessage.response_segments.\n        Return value is a concatenated list of the return values of FinTSMessage.response_segments().\n        \"\"\"\n        responses = []\n        touchdown_counter = 1\n        touchdown = None\n\n        while touchdown or touchdown_counter == 1:\n            seg = segment_factory(touchdown)\n\n            rm = dialog.send(seg)\n\n            for resp in rm.response_segments(seg, *args, **kwargs):\n                responses.append(resp)\n\n            touchdown = None\n            for response in rm.responses(seg, '3040'):\n                touchdown = response.parameters[0]\n                break\n\n            if touchdown:\n                logger.info('Fetching more results ({})...'.format(touchdown_counter))\n\n            touchdown_counter += 1\n\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch the BPD for the highest supported version of a segment.", "response": "def _find_highest_supported_command(self, *segment_classes, **kwargs):\n        \"\"\"Search the BPD for the highest supported version of a segment.\"\"\"\n        return_parameter_segment = kwargs.get(\"return_parameter_segment\", False)\n\n        parameter_segment_name = \"{}I{}S\".format(segment_classes[0].TYPE[0], segment_classes[0].TYPE[2:])\n        version_map = dict((clazz.VERSION, clazz) for clazz in segment_classes)\n        max_version = self.bpd.find_segment_highest_version(parameter_segment_name, version_map.keys())\n        if not max_version:\n            raise FinTSUnsupportedOperation('No supported {} version found. I support {}, bank supports {}.'.format(\n                parameter_segment_name,\n                tuple(version_map.keys()),\n                tuple(v.header.version for v in self.bpd.find_segments(parameter_segment_name))\n            ))\n\n        if return_parameter_segment:\n            return max_version, version_map.get(max_version.header.version)\n        else:\n            return version_map.get(max_version.header.version)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_transactions(self, account: SEPAAccount, start_date: datetime.date = None, end_date: datetime.date = None):\n\n        with self._get_dialog() as dialog:\n            hkkaz = self._find_highest_supported_command(HKKAZ5, HKKAZ6, HKKAZ7)\n\n            logger.info('Start fetching from {} to {}'.format(start_date, end_date))\n            responses = self._fetch_with_touchdowns(\n                dialog,\n                lambda touchdown: hkkaz(\n                    account=hkkaz._fields['account'].type.from_sepa_account(account),\n                    all_accounts=False,\n                    date_start=start_date,\n                    date_end=end_date,\n                    touchdown_point=touchdown,\n                ),\n                'HIKAZ'\n            )\n            logger.info('Fetching done.')\n\n        statement = []\n        for seg in responses:\n            # Note: MT940 messages are encoded in the S.W.I.F.T character set,\n            # which is a subset of ISO 8859. There are no character in it that\n            # differ between ISO 8859 variants, so we'll arbitrarily chose 8859-1.\n            statement += mt940_to_array(seg.statement_booked.decode('iso-8859-1'))\n\n        logger.debug('Statement: {}'.format(statement))\n\n        return statement", "response": "Fetches the list of transactions of a certain bank account in a certain timeframe."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches the list of XML documents of a certain bank account in a certain timeframe as camt. 052.001. 02 XML files.", "response": "def get_transactions_xml(self, account: SEPAAccount, start_date: datetime.date = None,\n                             end_date: datetime.date = None) -> list:\n        \"\"\"\n        Fetches the list of transactions of a bank account in a certain timeframe as camt.052.001.02 XML files.\n\n        :param account: SEPA\n        :param start_date: First day to fetch\n        :param end_date: Last day to fetch\n        :return: A list of bytestrings containing XML documents\n        \"\"\"\n\n        with self._get_dialog() as dialog:\n            hkcaz = self._find_highest_supported_command(HKCAZ1)\n\n            logger.info('Start fetching from {} to {}'.format(start_date, end_date))\n            responses = self._fetch_with_touchdowns(\n                dialog,\n                lambda touchdown: hkcaz(\n                    account=hkcaz._fields['account'].type.from_sepa_account(account),\n                    all_accounts=False,\n                    date_start=start_date,\n                    date_end=end_date,\n                    touchdown_point=touchdown,\n                    supported_camt_messages=SupportedMessageTypes('urn:iso:std:iso:20022:tech:xsd:camt.052.001.02'),\n                ),\n                'HICAZ'\n            )\n            logger.info('Fetching done.')\n\n        xml_streams = []\n        for seg in responses:\n            xml_streams.append(seg.statement_booked)\n        return xml_streams"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_balance(self, account: SEPAAccount):\n\n        with self._get_dialog() as dialog:\n            hksal = self._find_highest_supported_command(HKSAL5, HKSAL6, HKSAL7)\n\n            seg = hksal(\n                account=hksal._fields['account'].type.from_sepa_account(account),\n                all_accounts=False,\n            )\n\n            response = dialog.send(seg)\n\n            for resp in response.response_segments(seg, 'HISAL'):\n                return resp.balance_booked.as_mt940_Balance()", "response": "Fetches an accounts current balance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_holdings(self, account: SEPAAccount):\n        # init dialog\n        with self._get_dialog() as dialog:\n            hkwpd = self._find_highest_supported_command(HKWPD5, HKWPD6)\n\n            responses = self._fetch_with_touchdowns(\n                dialog,\n                lambda touchdown: hkwpd(\n                    account=hkwpd._fields['account'].type.from_sepa_account(account),\n                    touchdown_point=touchdown,\n                ),\n                'HIWPD'\n            )\n\n        holdings = []\n        for resp in responses:\n            if type(resp.holdings) == bytes:\n                holding_str = resp.holdings.decode()\n            else:\n                holding_str = resp.holdings\n\n            mt535_lines = str.splitlines(holding_str)\n            # The first line is empty - drop it.\n            del mt535_lines[0]\n            mt535 = MT535_Miniparser()\n            holdings.extend(mt535.parse(mt535_lines))\n\n        if not holdings:\n            logger.debug('No HIWPD response segment found - maybe account has no holdings?')\n        return holdings", "response": "Retrieve holdings of an account."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the product name and version that is transmitted as part of our identification", "response": "def set_product(self, product_name, product_version):\n        \"\"\"Set the product name and version that is transmitted as part of our identification\n        \n        According to 'FinTS Financial Transaction Services, Schnittstellenspezifikation, Formals',\n        version 3.0, section C.3.1.3, you should fill this with useful information about the\n        end-user product, *NOT* the FinTS library.\"\"\"\n\n        self.product_name = product_name\n        self.product_version = product_version"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a compressed datablob representing this object.", "response": "def get_data(self) -> bytes:\n        \"\"\"Return a compressed datablob representing this object.\n        \n        To restore the object, use :func:`fints.client.NeedRetryResponse.from_data`.\n        \"\"\"\n        data = {\n            \"_class_name\": self.__class__.__name__,\n            \"version\": 1,\n            \"segments_bin\": SegmentSequence([self.command_seg, self.tan_request]).render_bytes(),\n            \"resume_method\": self.resume_method,\n            \"tan_request_structured\": self.tan_request_structured,\n        }\n        return compress_datablob(DATA_BLOB_MAGIC_RETRY, 1, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a TAN to confirm a pending operation.", "response": "def send_tan(self, challenge: NeedTANResponse, tan: str):\n        \"\"\"\n        Sends a TAN to confirm a pending operation.\n\n        :param challenge: NeedTANResponse to respond to\n        :param tan: TAN value\n        :return: Currently no response\n        \"\"\"\n\n        with self._get_dialog() as dialog:\n            tan_seg = self._get_tan_segment(challenge.command_seg, '2', challenge.tan_request)\n            self._pending_tan = tan\n\n            response = dialog.send(tan_seg)\n\n            resume_func = getattr(self, challenge.resume_method)\n            return resume_func(challenge.command_seg, response)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_tan_mechanisms(self):\n\n        retval = OrderedDict()\n\n        for version in sorted(IMPLEMENTED_HKTAN_VERSIONS.keys()):\n            for seg in self.bpd.find_segments('HITANS', version):\n                for parameter in seg.parameter.twostep_parameters:\n                    if parameter.security_function in self.allowed_security_functions:\n                        retval[parameter.security_function] = parameter\n\n        return retval", "response": "Get the available TAN mechanisms."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_tan_media(self, media_type = TANMediaType2.ALL, media_class = TANMediaClass4.ALL):\n\n        with self._get_dialog() as dialog:\n            hktab = self._find_highest_supported_command(HKTAB4, HKTAB5)\n\n            seg = hktab(\n                tan_media_type = media_type,\n                tan_media_class = str(media_class),\n            )\n\n            response = dialog.send(seg)\n\n            for resp in response.response_segments(seg, 'HITAB'):\n                return resp.tan_usage_option, list(resp.tan_media_list)", "response": "Get information about TAN lists or generators."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _generate_MAC(segments=6, segment_length=2, delimiter=\":\", charset=\"0123456789abcdef\"):\n        addr = []\n        for _ in range(segments):\n            sub = ''.join(random.choice(charset) for _ in range(segment_length))\n            addr.append(sub)\n        return delimiter.join(addr)", "response": "generate a non - guaranteed - unique mac address"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        if self.program:\n            self.program.start()\n        while self.keep_listening:\n            for interface in self.interfaces:\n                packet = interface.recv(self.mac_addr if not self.promiscuous else \"00:00:00:00:00:00\")\n                if packet:\n                    self.recv(packet, interface)\n                time.sleep(0.01)\n        self.log(\"Stopped listening.\")", "response": "runloop that gets triggered by node. start"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun incoming packet through the filters then place it in the inq list", "response": "def recv(self, packet, interface):\n        \"\"\"run incoming packet through the filters, then place it in its inq\"\"\"\n        # the packet is piped into the first filter, then the result of that into the second filter, etc.\n        for f in self.filters:\n            if not packet:\n                break\n            packet = f.tr(packet, interface)\n        if packet:\n            # if the packet wasn't dropped by a filter, log the recv and place it in the interface's inq\n            # self.log(\"IN      \", str(interface).ljust(30), packet.decode())\n            self.inq[interface].put(packet)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites packet to given interfaces", "response": "def send(self, packet, interfaces=None):\n        \"\"\"write packet to given interfaces, default is broadcast to all interfaces\"\"\"\n        interfaces = interfaces or self.interfaces  # default to all interfaces\n        interfaces = interfaces if hasattr(interfaces, '__iter__') else [interfaces]\n\n        for interface in interfaces:\n            for f in self.filters:\n                packet = f.tx(packet, interface)  # run outgoing packet through the filters\n            if packet:\n                # if not dropped, log the transmit and pass it to the interface's send method\n                # self.log(\"OUT     \", (\"<\"+\",\".join(i.name for i in interfaces)+\">\").ljust(30), packet.decode())\n                interface.send(packet)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchunking an iterable into chunks of size chunk_size", "response": "def chunk(iterable, chunk_size=20):\n    \"\"\"chunk an iterable [1,2,3,4,5,6,7,8] -> ([1,2,3], [4,5,6], [7,8])\"\"\"\n    items = []\n    for value in iterable:\n        items.append(value)\n        if len(items) == chunk_size:\n            yield items\n            items = []\n    if items:\n        yield items"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_cmd(command, verbose=True, shell='/bin/bash'):\n    process = Popen(command, shell=True, stdout=PIPE, stderr=STDOUT, executable=shell)\n    output = process.stdout.read().decode().strip().split('\\n')\n    if verbose:\n        # return full output including empty lines\n        return output\n    return [line for line in output if line.strip()]", "response": "internal helper function to run shell commands and get output"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_shell(cmd, timeout=60, verbose=False):\n    retcode = None\n    try:\n        p = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT, executable='/bin/bash')\n        continue_running = True\n    except Exception as e:\n        yield(\"Failed: %s\" % e)\n        continue_running = False\n\n    while continue_running:\n        try:\n            line = p.stdout.readline()\n            if verbose and line:\n                yield(line)\n            elif line.strip():\n                yield(line.strip())\n        except Exception:\n            pass\n\n        try:\n            data = irc.recv(4096)\n        except Exception as e:\n            data = \"\"\n            retcode = p.poll()  # returns None while subprocess is running\n\n        if '!cancel' in data:\n            retcode = \"Cancelled live output reading. You have to kill the process manually.\"\n            yield \"[X]: %s\" % retcode\n            break\n\n        elif retcode is not None:\n            try:\n                line = p.stdout.read()\n            except:\n                retcode = \"Too much output, read timed out. Process is still running in background.\"\n\n            if verbose and line:\n                yield line\n\n            if retcode != 0:\n                yield \"[X]: %s\" % retcode\n            elif retcode == 0 and verbose:\n                yield \"[\u221a]\"\n\n            break", "response": "run a shell command and return the output"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets OS X version or kernel version if mac version is not found", "response": "def get_platform():\n    \"\"\"get Mac OS X version or kernel version if mac version is not found\"\"\"\n    mac_version = str(platform.mac_ver()[0]).strip()    # e.g. 10.11.2\n    if mac_version:\n        return 'OS X %s' % mac_version\n    return platform.platform().strip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        while self.keep_listening:\n            for interface in self.node.interfaces:\n                try:\n                    self.recv(self.node.inq[interface].get(timeout=0), interface)\n                except Empty:\n                    sleep(0.01)", "response": "runloop that reads packets off the node s incoming packet buffer ( node. inq"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions to send an email to a specified address with the given attachments", "response": "def email(to='medusa@sweeting.me', _from=default_from, subject='BOT MSG', message=\"Info email\", attachments=None):\n    \"\"\"function to send mail to a specified address with the given attachments\"\"\"\n    for attachment in attachments or []:\n        filename = attachment.strip()\n        try:\n            result = run_cmd('uuencode %s %s | mailx -s \"%s\" %s' % (filename, filename, subject, to))[0]\n            return \"Sending email From: %s; To: %s; Subject: %s; Attachment: %s (%s)\" % (_from, to, subject, filename, result or 'Succeded')\n        except Exception as error:\n            return str(error)\n\n    if not attachments:\n        p = os.popen(\"/usr/sbin/sendmail -t\", \"w\")\n        p.write(\"From: %s\\n\" % _from)\n        p.write(\"To: %s\\n\" % to)\n        p.write(\"Subject: %s\\n\" % subject)\n        p.write(\"\\n\")   # blank line separating headers from body\n        p.write('%s\\n' % message)\n        result = p.close()\n\n    if not result:\n        return \"Sent email From: %s; To: %s; Subject: %s; Attachments: %s)\" % (_from, to, subject, ','.join(attachments or []))\n    else:\n        return \"Error: %s. Please fix Postfix:\\n %s\" % (result, help_str)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints the message to stdout and stderr for the link", "response": "def log(self, *args):\n        \"\"\"stdout and stderr for the link\"\"\"\n        print(\"%s %s\" % (str(self).ljust(8), \" \".join([str(x) for x in args])))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stop(self):\n        self.keep_listening = False\n        # if threaded, kill threads before going down\n        if hasattr(self, 'join'):\n            self.join()\n        self.log(\"Went down.\")\n        return True", "response": "Stop all the link threads and all the other threads."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef recv(self, mac_addr=broadcast_addr, timeout=0):\n        # recv on the broadcast address \"00:..:00\" will give you all packets (for promiscuous mode)\n        if self.keep_listening:\n            try:\n                return self.inq[str(mac_addr)].get(timeout=timeout)\n            except Empty:\n                return \"\"\n        else:\n            self.log(\"is down.\")", "response": "read a packet off the recv queue for a given address optional timeout to block and wait for packet"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self, packet, mac_addr=broadcast_addr):\n        if self.keep_listening:\n            if mac_addr == self.broadcast_addr:\n                for addr, recv_queue in self.inq.items():\n                    recv_queue.put(packet)\n            else:\n                self.inq[mac_addr].put(packet)\n                self.inq[self.broadcast_addr].put(packet)\n        else:\n            self.log(\"is down.\")", "response": "place sent packets directly into the reciever s queues ( as if they are connected by wire"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _initsocket(self):\n        self.send_socket = socket(AF_INET, SOCK_DGRAM)\n        self.send_socket.setblocking(0)\n        self.send_socket.setsockopt(SOL_SOCKET, SO_BROADCAST, 1)\n\n        self.recv_socket = socket(AF_INET, SOCK_DGRAM)\n        self.recv_socket.setblocking(0)\n        if IS_BSD:\n            self.recv_socket.setsockopt(SOL_SOCKET, SO_REUSEPORT, 1)  # requires sudo\n        self.recv_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)  # allows multiple UDPLinks to all listen for UDP packets\n        self.recv_socket.bind(('', self.port))", "response": "bind to the datagram socket and enable BROADCAST mode"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self):\n        # self.log(\"ready to receive.\")\n        # we use a runloop instead of synchronous recv so stopping the node mid-recv is possible\n        read_ready = None\n\n        while self.keep_listening:\n            try:\n                read_ready, w, x = select.select([self.recv_socket], [], [], 0.01)\n            except Exception:\n                # catch timeouts\n                pass\n\n            if read_ready:\n                packet, addr = read_ready[0].recvfrom(4096)\n                if addr[1] == self.port:\n                    # for each address listening to this link\n                    for mac_addr, recv_queue in self.inq.items():\n                        recv_queue.put(packet)  # put packet in node's recv queue\n                else:\n                    pass", "response": "runloop that reads incoming packets off the interface into the inq buffer"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send(self, packet, retry=True):\n        addr = ('255.255.255.255', self.port)  # 255. is the broadcast IP for UDP\n        try:\n            self.send_socket.sendto(packet, addr)\n        except Exception as e:\n            self.log(\"Link failed to send packet over socket %s\" % e)\n            sleep(0.2)\n            if retry:\n                self.send(packet, retry=False)", "response": "send a packet down the line to the inteface retry is True if the packet is too long"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send(self, packet, retry=True):\n        if not self.keep_listening:\n            self.log('is down.')\n            return\n\n        try:\n            # (because the IRC server sees this link as 1 connection no matter how many nodes use it, it wont send enough copies of the packet back)\n            # for each node listening to this link object locally\n            for mac_addr, recv_queue in self.inq.items():\n                recv_queue.put(packet) # put the packet directly in their in queue\n            # then send it down the wire to the IRC channel\n            self.net_socket.send(('PRIVMSG %s :%s\\r\\n' % (self.channel, packet.decode())).encode('utf-8'))\n        except Exception as e:\n            self.log(\"Link failed to send packet over socket %s\" % e)\n            sleep(0.2)\n            if retry:\n                self.send(packet, retry=False)", "response": "send a packet down the line to the inteface"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the number of hops between node1 and node2", "response": "def hops(node1, node2):\n    \"\"\"returns # of hops it takes to get from node1 to node2, 1 means they're on the same link\"\"\"\n    if node1 == node2:\n        return 0\n    elif set(node1.interfaces) & set(node2.interfaces):\n        # they share a common interface\n        return 1\n    else:\n        # Not implemented yet, graphsearch to find min hops between two nodes\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eigenvalue(nodes, node=None):\n    if node is None:\n        return sorted([eigenvalue(nodes, n) for n in nodes])[0]  # return lowest eigenvalue\n    else:\n        return len([1 for n in nodes if hops(node, n)])", "response": "calculate the eigenvalue for a given node in an array of nodes connected by an array of links\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the callback function to consume on network adapter changed events.", "response": "def register_on_network_adapter_changed(self, callback):\n        \"\"\"Set the callback function to consume on network adapter changed\n        events.\n\n        Callback receives a INetworkAdapterChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_network_adapter_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_on_serial_port_changed(self, callback):\n        event_type = library.VBoxEventType.on_serial_port_changed\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on serial port changed events."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the callback function to consume on serial port changed events.", "response": "def register_on_parallel_port_changed(self, callback):\n        \"\"\"Set the callback function to consume on serial port changed events.\n\n        Callback receives a IParallelPortChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_parallel_port_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the callback function to consume on medium changed events.", "response": "def register_on_medium_changed(self, callback):\n        \"\"\"Set the callback function to consume on medium changed events.\n\n        Callback receives a IMediumChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_medium_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the callback function to consume on clipboard mode changed events.", "response": "def register_on_clipboard_mode_changed(self, callback):\n        \"\"\"Set the callback function to consume on clipboard mode changed\n        events.\n\n        Callback receives a IClipboardModeChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_clipboard_mode_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the callback function to consume on drag and drop mode changed events.", "response": "def register_on_drag_and_drop_mode_changed(self, callback):\n        \"\"\"Set the callback function to consume on drag and drop mode changed\n        events.\n\n        Callback receives a IDragAndDropModeChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_drag_and_drop_mode_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the callback function to consume on VirtualBox Remote Desktop Extension ( VVRDE ) changed events.", "response": "def register_on_vrde_server_changed(self, callback):\n        \"\"\"Set the callback function to consume on VirtualBox Remote Desktop\n        Extension (VRDE) changed events.\n\n        Callback receives a IVRDEServerChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_vrde_server_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_on_shared_folder_changed(self, callback):\n        event_type = library.VBoxEventType.on_shared_folder_changed\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on shared folder changed events."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the callback function to consume on additions state changed events.", "response": "def register_on_additions_state_changed(self, callback):\n        \"\"\"Set the callback function to consume on additions state changed\n        events.\n\n        Callback receives a IAdditionsStateChangedEvent object.\n\n        Note: Interested callees should query IGuest attributes to find out\n              what has changed.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_additions_state_change\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the callback function to consume on state changed events in the system.", "response": "def register_on_state_changed(self, callback):\n        \"\"\"Set the callback function to consume on state changed events\n        which are generated when the state of the machine changes.\n\n        Callback receives a IStateChangeEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_state_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the callback function to consume on event source changed events. This occurs when a listener is added or removed.", "response": "def register_on_event_source_changed(self, callback):\n        \"\"\"Set the callback function to consume on event source changed\n        events.  This occurs when a listener is added or removed.\n\n        Callback receives a IEventStateChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_event_source_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_on_can_show_window(self, callback):\n        event_type = library.VBoxEventType.on_can_show_window\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on can show window events."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the callback function to consume on show window events.", "response": "def register_on_show_window(self, callback):\n        \"\"\"Set the callback function to consume on show window events.\n        This occurs when the console window is to be activated and brought to\n        the foreground of the desktop of the host PC.\n\n        Callback receives a IShowWindowEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_show_window\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the manager object in the global _managers dict.", "response": "def manager(self, value):\n        \"Set the manager object in the global _managers dict.\"\n        pid = current_process().ident\n        if _managers is None:\n            raise RuntimeError(\"Can not set the manager following a system exit.\")\n        if pid not in _managers:\n            _managers[pid] = value\n        else:\n            raise Exception(\"Manager already set for pid %s\" % pid)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a Session object for the current object.", "response": "def get_session(self):\n        \"\"\"Return a Session interface\n\n        :rtype: library.ISession\n        \"\"\"\n        # The inconsistent vboxapi implementation makes this annoying...\n        if hasattr(self.manager, 'mgr'):\n            manager = getattr(self.manager, 'mgr')\n        else:\n            manager = self.manager\n        return Session(interface=manager.getSessionObject(None))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cast_object(self, interface_object, interface_class):\n        name = interface_class.__name__\n        i = self.manager.queryInterface(interface_object._i, name)\n        return interface_class(interface=i)", "response": "Cast the obj to the interface class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _lock(self, timeout_ms=-1):\n        vbox = VirtualBox()\n        machine = vbox.find_machine(self.machine_name)\n        wait_time = 0\n        while True:\n            session = Session()\n            try:\n                machine.lock_machine(session, LockType.write)\n            except Exception as exc:\n                if timeout_ms != -1 and wait_time > timeout_ms:\n                    raise ValueError(\"Failed to acquire lock - %s\" % exc)\n                time.sleep(1)\n                wait_time += 1000\n            else:\n                try:\n                    yield session\n                finally:\n                    session.unlock_machine()\n                break", "response": "Lock the root machine."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _clones(self):\n        vbox = VirtualBox()\n        machines = []\n        for machine in vbox.machines:\n            if machine.name == self.machine_name:\n                continue\n            if machine.name.startswith(self.machine_name):\n                machines.append(machine)\n        return machines", "response": "Yield all machines under this pool"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef acquire(self, username, password, frontend='headless'):\n        with self._lock() as root_session:\n            for clone in self._clones:\n                # Search for a free clone\n                session = Session()\n                try:\n                    clone.lock_machine(session, LockType.write)\n                except Exception:\n                    continue\n                else:\n                    try:\n                        p = session.machine.restore_snapshot()\n                        p.wait_for_completion(60 * 1000)\n                    except Exception:\n                        pass\n                    session.unlock_machine()\n                    break\n            else:\n                # Build a new clone\n                machine = root_session.machine\n                clone = machine.clone(name=\"%s Pool\" % self.machine_name)\n                p = clone.launch_vm_process(type_p=frontend)\n                p.wait_for_completion(60 * 1000)\n                session = clone.create_session()\n                console = session.console\n                guest = console.guest\n                try:\n                    guest_session = guest.create_session(username, password,\n                                                         timeout_ms=300 * 1000)\n                    idle_count = 0\n                    timeout = 60\n                    while idle_count < 5 and timeout > 0:\n                        act = console.get_device_activity([DeviceType.hard_disk])\n                        if act[0] == DeviceActivity.idle:\n                            idle_count += 1\n                        time.sleep(0.5)\n                        timeout -= 0.5\n                    guest_session.close()\n                    console.pause()\n                    p, id_p = console.machine.take_snapshot('initialised',\n                                                            'machine pool',\n                                                            True)\n                    p.wait_for_completion(60 * 1000)\n                    self._power_down(session)\n                finally:\n                    if session.state == SessionState.locked:\n                        session.unlock_machine()\n\n            # Launch our clone\n            p = clone.launch_vm_process(type_p=frontend)\n            p.wait_for_completion(60 * 1000)\n            session = clone.create_session()\n            return session", "response": "Acquire a Machine resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreleases a machine session resource.", "response": "def release(self, session):\n        \"\"\"Release a machine session resource.\"\"\"\n        if session.state != SessionState.locked:\n            return\n        with self._lock():\n            return self._power_down(session)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_port_forward_rule(self, is_ipv6, rule_name, proto, host_ip, host_port, guest_ip, guest_port):\n        if not isinstance(is_ipv6, bool):\n            raise TypeError(\"is_ipv6 can only be an instance of type bool\")\n        if not isinstance(rule_name, basestring):\n            raise TypeError(\"rule_name can only be an instance of type basestring\")\n        if not isinstance(proto, NATProtocol):\n            raise TypeError(\"proto can only be an instance of type NATProtocol\")\n        if not isinstance(host_ip, basestring):\n            raise TypeError(\"host_ip can only be an instance of type basestring\")\n        if not isinstance(host_port, baseinteger):\n            raise TypeError(\"host_port can only be an instance of type baseinteger\")\n        if not isinstance(guest_ip, basestring):\n            raise TypeError(\"guest_ip can only be an instance of type basestring\")\n        if not isinstance(guest_port, baseinteger):\n            raise TypeError(\"guest_port can only be an instance of type baseinteger\")\n        self._call(\"addPortForwardRule\",\n                     in_p=[is_ipv6, rule_name, proto, host_ip, host_port, guest_ip, guest_port])", "response": "Adds a port - forward rule to the set of active NAT rules."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting the internal network trunk.", "response": "def start(self, trunk_type):\n        \"\"\"Type of internal network trunk.\n\n        in trunk_type of type str\n            Type of internal network trunk.\n\n        \"\"\"\n        if not isinstance(trunk_type, basestring):\n            raise TypeError(\"trunk_type can only be an instance of type basestring\")\n        self._call(\"start\",\n                     in_p=[trunk_type])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the specified option from the global option list", "response": "def remove_global_option(self, option):\n        \"\"\"removes the specified option\n\n        in option of type :class:`DhcpOpt`\n\n        raises :class:`OleErrorInvalidarg`\n            invalid option id supplied\n        \n        \"\"\"\n        if not isinstance(option, DhcpOpt):\n            raise TypeError(\"option can only be an instance of type DhcpOpt\")\n        self._call(\"removeGlobalOption\",\n                     in_p=[option])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_vm_slot_option(self, vmname, slot, option):\n        if not isinstance(vmname, basestring):\n            raise TypeError(\"vmname can only be an instance of type basestring\")\n        if not isinstance(slot, baseinteger):\n            raise TypeError(\"slot can only be an instance of type baseinteger\")\n        if not isinstance(option, DhcpOpt):\n            raise TypeError(\"option can only be an instance of type DhcpOpt\")\n        self._call(\"removeVmSlotOption\",\n                     in_p=[vmname, slot, option])", "response": "Removes the specified option from the specified VM slot."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_vm_slot_options(self, vmname, slot):\n        if not isinstance(vmname, basestring):\n            raise TypeError(\"vmname can only be an instance of type basestring\")\n        if not isinstance(slot, baseinteger):\n            raise TypeError(\"slot can only be an instance of type baseinteger\")\n        self._call(\"removeVmSlotOptions\",\n                     in_p=[vmname, slot])", "response": "removes all option for the specified VM or slot from the specified virtual machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_configuration(self, ip_address, network_mask, from_ip_address, to_ip_address):\n        if not isinstance(ip_address, basestring):\n            raise TypeError(\"ip_address can only be an instance of type basestring\")\n        if not isinstance(network_mask, basestring):\n            raise TypeError(\"network_mask can only be an instance of type basestring\")\n        if not isinstance(from_ip_address, basestring):\n            raise TypeError(\"from_ip_address can only be an instance of type basestring\")\n        if not isinstance(to_ip_address, basestring):\n            raise TypeError(\"to_ip_address can only be an instance of type basestring\")\n        self._call(\"setConfiguration\",\n                     in_p=[ip_address, network_mask, from_ip_address, to_ip_address])", "response": "Configures the server configuration for the specified IP address and network mask."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart DHCP server process.", "response": "def start(self, network_name, trunk_name, trunk_type):\n        \"\"\"Starts DHCP server process.\n\n        in network_name of type str\n            Name of internal network DHCP server should attach to.\n\n        in trunk_name of type str\n            Name of internal network trunk.\n\n        in trunk_type of type str\n            Type of internal network trunk.\n\n        raises :class:`OleErrorFail`\n            Failed to start the process.\n        \n        \"\"\"\n        if not isinstance(network_name, basestring):\n            raise TypeError(\"network_name can only be an instance of type basestring\")\n        if not isinstance(trunk_name, basestring):\n            raise TypeError(\"trunk_name can only be an instance of type basestring\")\n        if not isinstance(trunk_type, basestring):\n            raise TypeError(\"trunk_type can only be an instance of type basestring\")\n        self._call(\"start\",\n                     in_p=[network_name, trunk_name, trunk_type])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compose_machine_filename(self, name, group, create_flags, base_folder):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(group, basestring):\n            raise TypeError(\"group can only be an instance of type basestring\")\n        if not isinstance(create_flags, basestring):\n            raise TypeError(\"create_flags can only be an instance of type basestring\")\n        if not isinstance(base_folder, basestring):\n            raise TypeError(\"base_folder can only be an instance of type basestring\")\n        file_p = self._call(\"composeMachineFilename\",\n                     in_p=[name, group, create_flags, base_folder])\n        return file_p", "response": "This function returns a recommended full path of the settings file name for a new virtual machine."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_machine(self, settings_file, name, groups, os_type_id, flags):\n        if not isinstance(settings_file, basestring):\n            raise TypeError(\"settings_file can only be an instance of type basestring\")\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(groups, list):\n            raise TypeError(\"groups can only be an instance of type list\")\n        for a in groups[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(os_type_id, basestring):\n            raise TypeError(\"os_type_id can only be an instance of type basestring\")\n        if not isinstance(flags, basestring):\n            raise TypeError(\"flags can only be an instance of type basestring\")\n        machine = self._call(\"createMachine\",\n                     in_p=[settings_file, name, groups, os_type_id, flags])\n        machine = IMachine(machine)\n        return machine", "response": "Creates a new virtual machine with the given settings file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen a virtual machine from the specified settings file.", "response": "def open_machine(self, settings_file):\n        \"\"\"Opens a virtual machine from the existing settings file.\n        The opened machine remains unregistered until you call\n        :py:func:`register_machine` .\n        \n        The specified settings file name must be fully qualified.\n        The file must exist and be a valid machine XML settings file\n        whose contents will be used to construct the machine object.\n        \n        \n        :py:func:`IMachine.settings_modified`  will return\n        @c false for the opened machine, until any of machine settings\n        are changed.\n\n        in settings_file of type str\n            Name of the machine settings file.\n\n        return machine of type :class:`IMachine`\n            Opened machine object.\n\n        raises :class:`VBoxErrorFileError`\n            Settings file name invalid, not found or sharing violation.\n        \n        \"\"\"\n        if not isinstance(settings_file, basestring):\n            raise TypeError(\"settings_file can only be an instance of type basestring\")\n        machine = self._call(\"openMachine\",\n                     in_p=[settings_file])\n        machine = IMachine(machine)\n        return machine"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters the specified virtual machine with this VirtualBox instance.", "response": "def register_machine(self, machine):\n        \"\"\"Registers the machine previously created using\n        :py:func:`create_machine`  or opened using\n        :py:func:`open_machine`  within this VirtualBox installation. After\n        successful method invocation, the\n        :py:class:`IMachineRegisteredEvent`  event is fired.\n        \n        \n        This method implicitly calls :py:func:`IMachine.save_settings` \n        to save all current machine settings before registering it.\n\n        in machine of type :class:`IMachine`\n\n        raises :class:`VBoxErrorObjectNotFound`\n            No matching virtual machine found.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Virtual machine was not created within this VirtualBox instance.\n        \n        \"\"\"\n        if not isinstance(machine, IMachine):\n            raise TypeError(\"machine can only be an instance of type IMachine\")\n        self._call(\"registerMachine\",\n                     in_p=[machine])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nattempts to find a virtual machine given its name or UUID.", "response": "def find_machine(self, name_or_id):\n        \"\"\"Attempts to find a virtual machine given its name or UUID.\n        \n        Inaccessible machines cannot be found by name, only by UUID, because their name\n        cannot safely be determined.\n\n        in name_or_id of type str\n            What to search for. This can either be the UUID or the name of a virtual machine.\n\n        return machine of type :class:`IMachine`\n            Machine object, if found.\n\n        raises :class:`VBoxErrorObjectNotFound`\n            Could not find registered machine matching @a nameOrId.\n        \n        \"\"\"\n        if not isinstance(name_or_id, basestring):\n            raise TypeError(\"name_or_id can only be an instance of type basestring\")\n        machine = self._call(\"findMachine\",\n                     in_p=[name_or_id])\n        machine = IMachine(machine)\n        return machine"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn all machines which are in one of the specified groups.", "response": "def get_machines_by_groups(self, groups):\n        \"\"\"Gets all machine references which are in one of the specified groups.\n\n        in groups of type str\n            What groups to match. The usual group list rules apply, i.e.\n            passing an empty list will match VMs in the toplevel group, likewise\n            the empty string.\n\n        return machines of type :class:`IMachine`\n            All machines which matched.\n\n        \"\"\"\n        if not isinstance(groups, list):\n            raise TypeError(\"groups can only be an instance of type list\")\n        for a in groups[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        machines = self._call(\"getMachinesByGroups\",\n                     in_p=[groups])\n        machines = [IMachine(a) for a in machines]\n        return machines"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the state of several machines in a single operation.", "response": "def get_machine_states(self, machines):\n        \"\"\"Gets the state of several machines in a single operation.\n\n        in machines of type :class:`IMachine`\n            Array with the machine references.\n\n        return states of type :class:`MachineState`\n            Machine states, corresponding to the machines.\n\n        \"\"\"\n        if not isinstance(machines, list):\n            raise TypeError(\"machines can only be an instance of type list\")\n        for a in machines[:10]:\n            if not isinstance(a, IMachine):\n                raise TypeError(\n                        \"array can only contain objects of type IMachine\")\n        states = self._call(\"getMachineStates\",\n                     in_p=[machines])\n        states = [MachineState(a) for a in states]\n        return states"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new base medium object that will use the given format and location for medium data.", "response": "def create_medium(self, format_p, location, access_mode, a_device_type_type):\n        \"\"\"Creates a new base medium object that will use the given storage\n        format and location for medium data.\n        \n        The actual storage unit is not created by this method. In order to\n        do it, and before you are able to attach the created medium to\n        virtual machines, you must call one of the following methods to\n        allocate a format-specific storage unit at the specified location:\n        \n        :py:func:`IMedium.create_base_storage` \n        :py:func:`IMedium.create_diff_storage` \n        \n        \n        Some medium attributes, such as :py:func:`IMedium.id_p` , may\n        remain uninitialized until the medium storage unit is successfully\n        created by one of the above methods.\n        \n        Depending on the given device type, the file at the storage location\n        must be in one of the media formats understood by VirtualBox:\n        \n        \n        With a \"HardDisk\" device type, the file must be a hard disk image\n        in one of the formats supported by VirtualBox (see\n        :py:func:`ISystemProperties.medium_formats` ).\n        After the storage unit is successfully created and this method succeeds,\n        if the medium is a base medium, it\n        will be added to the :py:func:`hard_disks`  array attribute.\n        With a \"DVD\" device type, the file must be an ISO 9960 CD/DVD image.\n        After this method succeeds, the medium will be added to the\n        :py:func:`dvd_images`  array attribute.\n        With a \"Floppy\" device type, the file must be an RAW floppy image.\n        After this method succeeds, the medium will be added to the\n        :py:func:`floppy_images`  array attribute.\n        \n        \n        The list of all storage formats supported by this VirtualBox\n        installation can be obtained using\n        :py:func:`ISystemProperties.medium_formats` . If the @a format\n        attribute is empty or @c null then the default storage format\n        specified by :py:func:`ISystemProperties.default_hard_disk_format`  will\n        be used for disks r creating a storage unit of the medium.\n        \n        Note that the format of the location string is storage format specific.\n        See :py:func:`IMedium.location`  and IMedium for more details.\n\n        in format_p of type str\n            Identifier of the storage format to use for the new medium.\n\n        in location of type str\n            Location of the storage unit for the new medium.\n\n        in access_mode of type :class:`AccessMode`\n            Whether to open the image in read/write or read-only mode. For\n            a \"DVD\" device type, this is ignored and read-only mode is always assumed.\n\n        in a_device_type_type of type :class:`DeviceType`\n            Must be one of \"HardDisk\", \"DVD\" or \"Floppy\".\n\n        return medium of type :class:`IMedium`\n            Created medium object.\n\n        raises :class:`VBoxErrorObjectNotFound`\n            @a format identifier is invalid. See\n        \n        raises :class:`VBoxErrorFileError`\n            @a location is a not valid file name (for file-based formats only).\n        \n        \"\"\"\n        if not isinstance(format_p, basestring):\n            raise TypeError(\"format_p can only be an instance of type basestring\")\n        if not isinstance(location, basestring):\n            raise TypeError(\"location can only be an instance of type basestring\")\n        if not isinstance(access_mode, AccessMode):\n            raise TypeError(\"access_mode can only be an instance of type AccessMode\")\n        if not isinstance(a_device_type_type, DeviceType):\n            raise TypeError(\"a_device_type_type can only be an instance of type DeviceType\")\n        medium = self._call(\"createMedium\",\n                     in_p=[format_p, location, access_mode, a_device_type_type])\n        medium = IMedium(medium)\n        return medium"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding existing media or opens a medium from an existing storage location.", "response": "def open_medium(self, location, device_type, access_mode, force_new_uuid):\n        \"\"\"Finds existing media or opens a medium from an existing storage location.\n        \n        Once a medium has been opened, it can be passed to other VirtualBox\n        methods, in particular to :py:func:`IMachine.attach_device` .\n        \n        Depending on the given device type, the file at the storage location\n        must be in one of the media formats understood by VirtualBox:\n        \n        \n        With a \"HardDisk\" device type, the file must be a hard disk image\n        in one of the formats supported by VirtualBox (see\n        :py:func:`ISystemProperties.medium_formats` ).\n        After this method succeeds, if the medium is a base medium, it\n        will be added to the :py:func:`hard_disks`  array attribute.\n        With a \"DVD\" device type, the file must be an ISO 9960 CD/DVD image.\n        After this method succeeds, the medium will be added to the\n        :py:func:`dvd_images`  array attribute.\n        With a \"Floppy\" device type, the file must be an RAW floppy image.\n        After this method succeeds, the medium will be added to the\n        :py:func:`floppy_images`  array attribute.\n        \n        \n        After having been opened, the medium can be re-found by this method\n        and can be attached to virtual machines. See :py:class:`IMedium`  for\n        more details.\n        \n        The UUID of the newly opened medium will either be retrieved from the\n        storage location, if the format supports it (e.g. for hard disk images),\n        or a new UUID will be randomly generated (e.g. for ISO and RAW files).\n        If for some reason you need to change the medium's UUID, use\n        :py:func:`IMedium.set_ids` .\n        \n        If a differencing hard disk medium is to be opened by this method, the\n        operation will succeed only if its parent medium and all ancestors,\n        if any, are already known to this VirtualBox installation (for example,\n        were opened by this method before).\n        \n        This method attempts to guess the storage format of the specified medium\n        by reading medium data at the specified location.\n        \n        If @a accessMode is ReadWrite (which it should be for hard disks and floppies),\n        the image is opened for read/write access and must have according permissions,\n        as VirtualBox may actually write status information into the disk's metadata\n        sections.\n        \n        Note that write access is required for all typical hard disk usage in VirtualBox,\n        since VirtualBox may need to write metadata such as a UUID into the image.\n        The only exception is opening a source image temporarily for copying and\n        cloning (see :py:func:`IMedium.clone_to`  when the image will be closed\n        again soon.\n        \n        The format of the location string is storage format specific. See\n        :py:func:`IMedium.location`  and IMedium for more details.\n\n        in location of type str\n            Location of the storage unit that contains medium data in one of\n            the supported storage formats.\n\n        in device_type of type :class:`DeviceType`\n            Must be one of \"HardDisk\", \"DVD\" or \"Floppy\".\n\n        in access_mode of type :class:`AccessMode`\n            Whether to open the image in read/write or read-only mode. For\n            a \"DVD\" device type, this is ignored and read-only mode is always assumed.\n\n        in force_new_uuid of type bool\n            Allows the caller to request a completely new medium UUID for\n            the image which is to be opened. Useful if one intends to open an exact\n            copy of a previously opened image, as this would normally fail due to\n            the duplicate UUID.\n\n        return medium of type :class:`IMedium`\n            Opened medium object.\n\n        raises :class:`VBoxErrorFileError`\n            Invalid medium storage file location or could not find the medium\nat the specified location.\n        \n        raises :class:`VBoxErrorIprtError`\n            Could not get medium storage format.\n        \n        raises :class:`OleErrorInvalidarg`\n            Invalid medium storage format.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Medium has already been added to a media registry.\n        \n        \"\"\"\n        if not isinstance(location, basestring):\n            raise TypeError(\"location can only be an instance of type basestring\")\n        if not isinstance(device_type, DeviceType):\n            raise TypeError(\"device_type can only be an instance of type DeviceType\")\n        if not isinstance(access_mode, AccessMode):\n            raise TypeError(\"access_mode can only be an instance of type AccessMode\")\n        if not isinstance(force_new_uuid, bool):\n            raise TypeError(\"force_new_uuid can only be an instance of type bool\")\n        medium = self._call(\"openMedium\",\n                     in_p=[location, device_type, access_mode, force_new_uuid])\n        medium = IMedium(medium)\n        return medium"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_guest_os_type(self, id_p):\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        type_p = self._call(\"getGuestOSType\",\n                     in_p=[id_p])\n        type_p = IGuestOSType(type_p)\n        return type_p", "response": "Returns an object describing the specified guest OS type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_shared_folder(self, name, host_path, writable, automount, auto_mount_point):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(host_path, basestring):\n            raise TypeError(\"host_path can only be an instance of type basestring\")\n        if not isinstance(writable, bool):\n            raise TypeError(\"writable can only be an instance of type bool\")\n        if not isinstance(automount, bool):\n            raise TypeError(\"automount can only be an instance of type bool\")\n        if not isinstance(auto_mount_point, basestring):\n            raise TypeError(\"auto_mount_point can only be an instance of type basestring\")\n        self._call(\"createSharedFolder\",\n                     in_p=[name, host_path, writable, automount, auto_mount_point])", "response": "Creates a new global shared folder with the given name host path writable and auto mount point."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the global shared folder with the given name previously AttributeNames is not implemented.", "response": "def remove_shared_folder(self, name):\n        \"\"\"Removes the global shared folder with the given name previously\n        created by :py:func:`create_shared_folder`  from the collection of\n        shared folders and stops sharing it.\n        \n        In the current implementation, this operation is not\n        implemented.\n\n        in name of type str\n            Logical name of the shared folder to remove.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        self._call(\"removeSharedFolder\",\n                     in_p=[name])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nunlocking the secret data by passing the unlock password to the server.", "response": "def set_settings_secret(self, password):\n        \"\"\"Unlocks the secret data by passing the unlock password to the\n        server. The server will cache the password for that machine.\n\n        in password of type str\n            The cipher key.\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Virtual machine is not mutable.\n        \n        \"\"\"\n        if not isinstance(password, basestring):\n            raise TypeError(\"password can only be an instance of type basestring\")\n        self._call(\"setSettingsSecret\",\n                     in_p=[password])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a DHCP server settings to be used for the given internal network name.", "response": "def create_dhcp_server(self, name):\n        \"\"\"Creates a DHCP server settings to be used for the given internal network name\n\n        in name of type str\n            server name\n\n        return server of type :class:`IDHCPServer`\n            DHCP server settings\n\n        raises :class:`OleErrorInvalidarg`\n            Host network interface @a name already exists.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        server = self._call(\"createDHCPServer\",\n                     in_p=[name])\n        server = IDHCPServer(server)\n        return server"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_dhcp_server(self, server):\n        if not isinstance(server, IDHCPServer):\n            raise TypeError(\"server can only be an instance of type IDHCPServer\")\n        self._call(\"removeDHCPServer\",\n                     in_p=[server])", "response": "Removes the DHCP server settings from the specified server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_firmware_present(self, firmware_type, version):\n        if not isinstance(firmware_type, FirmwareType):\n            raise TypeError(\"firmware_type can only be an instance of type FirmwareType\")\n        if not isinstance(version, basestring):\n            raise TypeError(\"version can only be an instance of type basestring\")\n        (result, url, file_p) = self._call(\"checkFirmwarePresent\",\n                     in_p=[firmware_type, version])\n        return (result, url, file_p)", "response": "Checks if the given VirtualBox installation has a firmware of the given type and version available."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cd(self, dir_p):\n        if not isinstance(dir_p, basestring):\n            raise TypeError(\"dir_p can only be an instance of type basestring\")\n        progress = self._call(\"cd\",\n                     in_p=[dir_p])\n        progress = IProgress(progress)\n        return progress", "response": "Changes the current directory level."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef entry_list(self):\n        (names, types, sizes, modes) = self._call(\"entryList\")\n        return (names, types, sizes, modes)", "response": "Returns a list of files types sizes and modes for the entries."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the given file list exists in the current directory.", "response": "def exists(self, names):\n        \"\"\"Checks if the given file list exists in the current directory\n        level.\n\n        in names of type str\n            The names to check.\n\n        return exists of type str\n            The names which exist.\n\n        \"\"\"\n        if not isinstance(names, list):\n            raise TypeError(\"names can only be an instance of type list\")\n        for a in names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        exists = self._call(\"exists\",\n                     in_p=[names])\n        return exists"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove(self, names):\n        if not isinstance(names, list):\n            raise TypeError(\"names can only be an instance of type list\")\n        for a in names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        progress = self._call(\"remove\",\n                     in_p=[names])\n        progress = IProgress(progress)\n        return progress", "response": "Deletes the given files in the current directory level."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read(self, file_p):\n        if not isinstance(file_p, basestring):\n            raise TypeError(\"file_p can only be an instance of type basestring\")\n        progress = self._call(\"read\",\n                     in_p=[file_p])\n        progress = IProgress(progress)\n        return progress", "response": "Reads an OVF file into the appliance object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimporting the appliance into VirtualBox.", "response": "def import_machines(self, options):\n        \"\"\"Imports the appliance into VirtualBox by creating instances of :py:class:`IMachine` \n        and other interfaces that match the information contained in the appliance as\n        closely as possible, as represented by the import instructions in the\n        :py:func:`virtual_system_descriptions`  array.\n        \n        Calling this method is the final step of importing an appliance into VirtualBox;\n        see :py:class:`IAppliance`  for an overview.\n        \n        Since importing the appliance will most probably involve copying and converting\n        disk images, which can take a long time, this method operates asynchronously and\n        returns an IProgress object to allow the caller to monitor the progress.\n        \n        After the import succeeded, the UUIDs of the IMachine instances created can be\n        retrieved from the :py:func:`machines`  array attribute.\n\n        in options of type :class:`ImportOptions`\n            Options for the importing operation.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        \"\"\"\n        if not isinstance(options, list):\n            raise TypeError(\"options can only be an instance of type list\")\n        for a in options[:10]:\n            if not isinstance(a, ImportOptions):\n                raise TypeError(\n                        \"array can only contain objects of type ImportOptions\")\n        progress = self._call(\"importMachines\",\n                     in_p=[options])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates an instance of the VFSExplorer class for the given URI.", "response": "def create_vfs_explorer(self, uri):\n        \"\"\"Returns a :py:class:`IVFSExplorer`  object for the given URI.\n\n        in uri of type str\n            The URI describing the file system to use.\n\n        return explorer of type :class:`IVFSExplorer`\n\n        \"\"\"\n        if not isinstance(uri, basestring):\n            raise TypeError(\"uri can only be an instance of type basestring\")\n        explorer = self._call(\"createVFSExplorer\",\n                     in_p=[uri])\n        explorer = IVFSExplorer(explorer)\n        return explorer"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites the contents of the appliance to an OVF file.", "response": "def write(self, format_p, options, path):\n        \"\"\"Writes the contents of the appliance exports into a new OVF file.\n        \n        Calling this method is the final step of exporting an appliance from VirtualBox;\n        see :py:class:`IAppliance`  for an overview.\n        \n        Since exporting the appliance will most probably involve copying and converting\n        disk images, which can take a long time, this method operates asynchronously and\n        returns an IProgress object to allow the caller to monitor the progress.\n\n        in format_p of type str\n            Output format, as a string. Currently supported formats are \"ovf-0.9\", \"ovf-1.0\",\n            \"ovf-2.0\" and \"opc-1.0\"; future versions of VirtualBox may support additional formats.\n            The \"opc-1.0\" format is for creating tarballs for the Oracle Public Cloud.\n\n        in options of type :class:`ExportOptions`\n            Options for the exporting operation.\n\n        in path of type str\n            Name of appliance file to create.  There are certain restrictions with regard\n            to the file name suffix.  If the format parameter is \"opc-1.0\" a .tar.gz\n            suffix is required.  Otherwise the suffix must either be .ovf or\n            .ova, depending on whether the appliance is distributed as a set of\n            files or as a single file, respectively.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        \"\"\"\n        if not isinstance(format_p, basestring):\n            raise TypeError(\"format_p can only be an instance of type basestring\")\n        if not isinstance(options, list):\n            raise TypeError(\"options can only be an instance of type list\")\n        for a in options[:10]:\n            if not isinstance(a, ExportOptions):\n                raise TypeError(\n                        \"array can only contain objects of type ExportOptions\")\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        progress = self._call(\"write\",\n                     in_p=[format_p, options, path])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of medium identifiers which use the given password identifier.", "response": "def get_medium_ids_for_password_id(self, password_id):\n        \"\"\"Returns a list of medium identifiers which use the given password identifier.\n\n        in password_id of type str\n            The password identifier to get the medium identifiers for.\n\n        return identifiers of type str\n            The list of medium identifiers returned on success.\n\n        \"\"\"\n        if not isinstance(password_id, basestring):\n            raise TypeError(\"password_id can only be an instance of type basestring\")\n        identifiers = self._call(\"getMediumIdsForPasswordId\",\n                     in_p=[password_id])\n        return identifiers"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_passwords(self, identifiers, passwords):\n        if not isinstance(identifiers, list):\n            raise TypeError(\"identifiers can only be an instance of type list\")\n        for a in identifiers[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(passwords, list):\n            raise TypeError(\"passwords can only be an instance of type list\")\n        for a in passwords[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"addPasswords\",\n                     in_p=[identifiers, passwords])", "response": "Adds a list of passwords required to import or export encrypted virtual\n        machines."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_description(self):\n        (types, refs, ovf_values, v_box_values, extra_config_values) = self._call(\"getDescription\")\n        types = [VirtualSystemDescriptionType(a) for a in types]\n        return (types, refs, ovf_values, v_box_values, extra_config_values)", "response": "Returns the description of the virtual system as a list of array items."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_description_by_type(self, type_p):\n        if not isinstance(type_p, VirtualSystemDescriptionType):\n            raise TypeError(\"type_p can only be an instance of type VirtualSystemDescriptionType\")\n        (types, refs, ovf_values, v_box_values, extra_config_values) = self._call(\"getDescriptionByType\",\n                     in_p=[type_p])\n        types = [VirtualSystemDescriptionType(a) for a in types]\n        return (types, refs, ovf_values, v_box_values, extra_config_values)", "response": "This is the same as get_description but returns a list of types refs ovf_values v_box_values and extra_config_values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_description_by_type(self, type_p):\n        if not isinstance(type_p, VirtualSystemDescriptionType):\n            raise TypeError(\"type_p can only be an instance of type VirtualSystemDescriptionType\")\n        self._call(\"removeDescriptionByType\",\n                     in_p=[type_p])", "response": "Removes all records which are equal to the passed type from the list of available descriptions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_values_by_type(self, type_p, which):\n        if not isinstance(type_p, VirtualSystemDescriptionType):\n            raise TypeError(\"type_p can only be an instance of type VirtualSystemDescriptionType\")\n        if not isinstance(which, VirtualSystemDescriptionValueType):\n            raise TypeError(\"which can only be an instance of type VirtualSystemDescriptionValueType\")\n        values = self._call(\"getValuesByType\",\n                     in_p=[type_p, which])\n        return values", "response": "Returns a list of values of type type_p which are in the order of which they appear in the description."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an additional description entry to the stack of already - available entries.", "response": "def add_description(self, type_p, v_box_value, extra_config_value):\n        \"\"\"This method adds an additional description entry to the stack of already\n        available descriptions for this virtual system. This is handy for writing\n        values which aren't directly supported by VirtualBox. One example would\n        be the License type of :py:class:`VirtualSystemDescriptionType` .\n\n        in type_p of type :class:`VirtualSystemDescriptionType`\n\n        in v_box_value of type str\n\n        in extra_config_value of type str\n\n        \"\"\"\n        if not isinstance(type_p, VirtualSystemDescriptionType):\n            raise TypeError(\"type_p can only be an instance of type VirtualSystemDescriptionType\")\n        if not isinstance(v_box_value, basestring):\n            raise TypeError(\"v_box_value can only be an instance of type basestring\")\n        if not isinstance(extra_config_value, basestring):\n            raise TypeError(\"extra_config_value can only be an instance of type basestring\")\n        self._call(\"addDescription\",\n                     in_p=[type_p, v_box_value, extra_config_value])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_state(self, state):\n        if not isinstance(state, MachineState):\n            raise TypeError(\"state can only be an instance of type MachineState\")\n        self._call(\"updateState\",\n                     in_p=[state])", "response": "Updates the VM state."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntells VBoxSVC that the console is powered up.", "response": "def begin_power_up(self, progress):\n        \"\"\"Tells VBoxSVC that :py:func:`IConsole.power_up`  is under ways and\n        gives it the progress object that should be part of any pending\n        :py:func:`IMachine.launch_vm_process`  operations. The progress\n        object may be called back to reflect an early cancelation, so some care\n        have to be taken with respect to any cancelation callbacks. The console\n        object will call :py:func:`IInternalMachineControl.end_power_up` \n        to signal the completion of the progress object.\n\n        in progress of type :class:`IProgress`\n\n        \"\"\"\n        if not isinstance(progress, IProgress):\n            raise TypeError(\"progress can only be an instance of type IProgress\")\n        self._call(\"beginPowerUp\",\n                     in_p=[progress])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef end_power_up(self, result):\n        if not isinstance(result, baseinteger):\n            raise TypeError(\"result can only be an instance of type baseinteger\")\n        self._call(\"endPowerUp\",\n                     in_p=[result])", "response": "Tells VBoxSVC that power up has completed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nend powering down of the specified user - specified entry point.", "response": "def end_powering_down(self, result, err_msg):\n        \"\"\"Called by the VM process to inform the server that powering\n        down previously requested by #beginPoweringDown is either\n        successfully finished or there was a failure.\n\n        in result of type int\n            @c S_OK to indicate success.\n\n        in err_msg of type str\n            @c human readable error message in case of failure.\n\n        raises :class:`VBoxErrorFileError`\n            Settings file not accessible.\n        \n        raises :class:`VBoxErrorXmlError`\n            Could not parse the settings file.\n        \n        \"\"\"\n        if not isinstance(result, baseinteger):\n            raise TypeError(\"result can only be an instance of type baseinteger\")\n        if not isinstance(err_msg, basestring):\n            raise TypeError(\"err_msg can only be an instance of type basestring\")\n        self._call(\"endPoweringDown\",\n                     in_p=[result, err_msg])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nasking the server to run USB device filters against the given USB device.", "response": "def run_usb_device_filters(self, device):\n        \"\"\"Asks the server to run USB devices filters of the associated\n        machine against the given USB device and tell if there is\n        a match.\n        \n        Intended to be used only for remote USB devices. Local\n        ones don't require to call this method (this is done\n        implicitly by the Host and USBProxyService).\n\n        in device of type :class:`IUSBDevice`\n\n        out matched of type bool\n\n        out masked_interfaces of type int\n\n        \"\"\"\n        if not isinstance(device, IUSBDevice):\n            raise TypeError(\"device can only be an instance of type IUSBDevice\")\n        (matched, masked_interfaces) = self._call(\"runUSBDeviceFilters\",\n                     in_p=[device])\n        return (matched, masked_interfaces)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef capture_usb_device(self, id_p, capture_filename):\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        if not isinstance(capture_filename, basestring):\n            raise TypeError(\"capture_filename can only be an instance of type basestring\")\n        self._call(\"captureUSBDevice\",\n                     in_p=[id_p, capture_filename])", "response": "Requests a capture of the given host USB device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef detach_usb_device(self, id_p, done):\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        if not isinstance(done, bool):\n            raise TypeError(\"done can only be an instance of type bool\")\n        self._call(\"detachUSBDevice\",\n                     in_p=[id_p, done])", "response": "Detaches the USB device from the VM."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef detach_all_usb_devices(self, done):\n        if not isinstance(done, bool):\n            raise TypeError(\"done can only be an instance of type bool\")\n        self._call(\"detachAllUSBDevices\",\n                     in_p=[done])", "response": "Notification that a VM is being powered down."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_session_end(self, session):\n        if not isinstance(session, ISession):\n            raise TypeError(\"session can only be an instance of type ISession\")\n        progress = self._call(\"onSessionEnd\",\n                     in_p=[session])\n        progress = IProgress(progress)\n        return progress", "response": "Triggered by the given session object when the given session object is about\n        to close normally."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the list of the guest properties matching a set of patterns along with their values timestamps and flags and give responsibility for the console to manage properties.", "response": "def pull_guest_properties(self):\n        \"\"\"Get the list of the guest properties matching a set of patterns along\n        with their values, timestamps and flags and give responsibility for\n        managing properties to the console.\n\n        out names of type str\n            The names of the properties returned.\n\n        out values of type str\n            The values of the properties returned. The array entries match the\n            corresponding entries in the @a name array.\n\n        out timestamps of type int\n            The timestamps of the properties returned. The array entries match\n            the corresponding entries in the @a name array.\n\n        out flags of type str\n            The flags of the properties returned. The array entries match the\n            corresponding entries in the @a name array.\n\n        \"\"\"\n        (names, values, timestamps, flags) = self._call(\"pullGuestProperties\")\n        return (names, values, timestamps, flags)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating a single guest property in IMachine.", "response": "def push_guest_property(self, name, value, timestamp, flags):\n        \"\"\"Update a single guest property in IMachine.\n\n        in name of type str\n            The name of the property to be updated.\n\n        in value of type str\n            The value of the property.\n\n        in timestamp of type int\n            The timestamp of the property.\n\n        in flags of type str\n            The flags of the property.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(value, basestring):\n            raise TypeError(\"value can only be an instance of type basestring\")\n        if not isinstance(timestamp, baseinteger):\n            raise TypeError(\"timestamp can only be an instance of type baseinteger\")\n        if not isinstance(flags, basestring):\n            raise TypeError(\"flags can only be an instance of type basestring\")\n        self._call(\"pushGuestProperty\",\n                     in_p=[name, value, timestamp, flags])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntells VBoxSVC that the guest has ejected the medium associated with .", "response": "def eject_medium(self, attachment):\n        \"\"\"Tells VBoxSVC that the guest has ejected the medium associated with\n        the medium attachment.\n\n        in attachment of type :class:`IMediumAttachment`\n            The medium attachment where the eject happened.\n\n        return new_attachment of type :class:`IMediumAttachment`\n            A new reference to the medium attachment, as the config change can\n            result in the creation of a new instance.\n\n        \"\"\"\n        if not isinstance(attachment, IMediumAttachment):\n            raise TypeError(\"attachment can only be an instance of type IMediumAttachment\")\n        new_attachment = self._call(\"ejectMedium\",\n                     in_p=[attachment])\n        new_attachment = IMediumAttachment(new_attachment)\n        return new_attachment"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing statistics collected by VM (including guest statistics) to VBoxSVC. in valid_stats of type int Mask defining which parameters are valid. For example: 0x11 means that cpuIdle and XXX are valid. Other parameters should be ignored. in cpu_user of type int Percentage of processor time spent in user mode as seen by the guest. in cpu_kernel of type int Percentage of processor time spent in kernel mode as seen by the guest. in cpu_idle of type int Percentage of processor time spent idling as seen by the guest. in mem_total of type int Total amount of physical guest RAM. in mem_free of type int Free amount of physical guest RAM. in mem_balloon of type int Amount of ballooned physical guest RAM. in mem_shared of type int Amount of shared physical guest RAM. in mem_cache of type int Total amount of guest (disk) cache memory. in paged_total of type int Total amount of space in the page file. in mem_alloc_total of type int Total amount of memory allocated by the hypervisor. in mem_free_total of type int Total amount of free memory available in the hypervisor. in mem_balloon_total of type int Total amount of memory ballooned by the hypervisor. in mem_shared_total of type int Total amount of shared memory in the hypervisor. in vm_net_rx of type int Network receive rate for VM. in vm_net_tx of type int Network transmit rate for VM.", "response": "def report_vm_statistics(self, valid_stats, cpu_user, cpu_kernel, cpu_idle, mem_total, mem_free, mem_balloon, mem_shared, mem_cache, paged_total, mem_alloc_total, mem_free_total, mem_balloon_total, mem_shared_total, vm_net_rx, vm_net_tx):\n        \"\"\"Passes statistics collected by VM (including guest statistics) to VBoxSVC.\n\n        in valid_stats of type int\n            Mask defining which parameters are valid. For example: 0x11 means\n            that cpuIdle and XXX are valid. Other parameters should be ignored.\n\n        in cpu_user of type int\n            Percentage of processor time spent in user mode as seen by the guest.\n\n        in cpu_kernel of type int\n            Percentage of processor time spent in kernel mode as seen by the guest.\n\n        in cpu_idle of type int\n            Percentage of processor time spent idling as seen by the guest.\n\n        in mem_total of type int\n            Total amount of physical guest RAM.\n\n        in mem_free of type int\n            Free amount of physical guest RAM.\n\n        in mem_balloon of type int\n            Amount of ballooned physical guest RAM.\n\n        in mem_shared of type int\n            Amount of shared physical guest RAM.\n\n        in mem_cache of type int\n            Total amount of guest (disk) cache memory.\n\n        in paged_total of type int\n            Total amount of space in the page file.\n\n        in mem_alloc_total of type int\n            Total amount of memory allocated by the hypervisor.\n\n        in mem_free_total of type int\n            Total amount of free memory available in the hypervisor.\n\n        in mem_balloon_total of type int\n            Total amount of memory ballooned by the hypervisor.\n\n        in mem_shared_total of type int\n            Total amount of shared memory in the hypervisor.\n\n        in vm_net_rx of type int\n            Network receive rate for VM.\n\n        in vm_net_tx of type int\n            Network transmit rate for VM.\n\n        \"\"\"\n        if not isinstance(valid_stats, baseinteger):\n            raise TypeError(\"valid_stats can only be an instance of type baseinteger\")\n        if not isinstance(cpu_user, baseinteger):\n            raise TypeError(\"cpu_user can only be an instance of type baseinteger\")\n        if not isinstance(cpu_kernel, baseinteger):\n            raise TypeError(\"cpu_kernel can only be an instance of type baseinteger\")\n        if not isinstance(cpu_idle, baseinteger):\n            raise TypeError(\"cpu_idle can only be an instance of type baseinteger\")\n        if not isinstance(mem_total, baseinteger):\n            raise TypeError(\"mem_total can only be an instance of type baseinteger\")\n        if not isinstance(mem_free, baseinteger):\n            raise TypeError(\"mem_free can only be an instance of type baseinteger\")\n        if not isinstance(mem_balloon, baseinteger):\n            raise TypeError(\"mem_balloon can only be an instance of type baseinteger\")\n        if not isinstance(mem_shared, baseinteger):\n            raise TypeError(\"mem_shared can only be an instance of type baseinteger\")\n        if not isinstance(mem_cache, baseinteger):\n            raise TypeError(\"mem_cache can only be an instance of type baseinteger\")\n        if not isinstance(paged_total, baseinteger):\n            raise TypeError(\"paged_total can only be an instance of type baseinteger\")\n        if not isinstance(mem_alloc_total, baseinteger):\n            raise TypeError(\"mem_alloc_total can only be an instance of type baseinteger\")\n        if not isinstance(mem_free_total, baseinteger):\n            raise TypeError(\"mem_free_total can only be an instance of type baseinteger\")\n        if not isinstance(mem_balloon_total, baseinteger):\n            raise TypeError(\"mem_balloon_total can only be an instance of type baseinteger\")\n        if not isinstance(mem_shared_total, baseinteger):\n            raise TypeError(\"mem_shared_total can only be an instance of type baseinteger\")\n        if not isinstance(vm_net_rx, baseinteger):\n            raise TypeError(\"vm_net_rx can only be an instance of type baseinteger\")\n        if not isinstance(vm_net_tx, baseinteger):\n            raise TypeError(\"vm_net_tx can only be an instance of type baseinteger\")\n        self._call(\"reportVmStatistics\",\n                     in_p=[valid_stats, cpu_user, cpu_kernel, cpu_idle, mem_total, mem_free, mem_balloon, mem_shared, mem_cache, paged_total, mem_alloc_total, mem_free_total, mem_balloon_total, mem_shared_total, vm_net_rx, vm_net_tx])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef authenticate_external(self, auth_params):\n        if not isinstance(auth_params, list):\n            raise TypeError(\"auth_params can only be an instance of type list\")\n        for a in auth_params[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        result = self._call(\"authenticateExternal\",\n                     in_p=[auth_params])\n        return result", "response": "Verify credentials using the external auth library."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_feature_enabled(self, feature):\n        if not isinstance(feature, RecordingFeature):\n            raise TypeError(\"feature can only be an instance of type RecordingFeature\")\n        enabled = self._call(\"isFeatureEnabled\",\n                     in_p=[feature])\n        return enabled", "response": "Returns whether a particular recording feature is enabled for this screen or not."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the recording screen settings for a particular screen.", "response": "def get_screen_settings(self, screen_id):\n        \"\"\"Returns the recording settings for a particular screen.\n\n        in screen_id of type int\n            Screen ID to retrieve recording screen settings for.\n\n        return record_screen_settings of type :class:`IRecordingScreenSettings`\n            Recording screen settings for the requested screen.\n\n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        record_screen_settings = self._call(\"getScreenSettings\",\n                     in_p=[screen_id])\n        record_screen_settings = IRecordingScreenSettings(record_screen_settings)\n        return record_screen_settings"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_long(self, number):\n        if not isinstance(number, baseinteger):\n            raise TypeError(\"number can only be an instance of type baseinteger\")\n        self._call(\"fromLong\",\n                     in_p=[number])", "response": "Make a PCI address from a long."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lock_machine(self, session, lock_type):\n        if not isinstance(session, ISession):\n            raise TypeError(\"session can only be an instance of type ISession\")\n        if not isinstance(lock_type, LockType):\n            raise TypeError(\"lock_type can only be an instance of type LockType\")\n        self._call(\"lockMachine\",\n                     in_p=[session, lock_type])", "response": "Locks the given session for the given session."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nspawns a new VM process that will execute the virtual machine and obtains a shared lock on the calling session.", "response": "def launch_vm_process(self, session, name, environment):\n        \"\"\"Spawns a new process that will execute the virtual machine and obtains a shared\n        lock on the machine for the calling session.\n        \n        If launching the VM succeeds, the new VM process will create its own session\n        and write-lock the machine for it, preventing conflicting changes from other\n        processes. If the machine is already locked (because it is already running or\n        because another session has a write lock), launching the VM process will therefore\n        fail. Reversely, future attempts to obtain a write lock will also fail while the\n        machine is running.\n        \n        The caller's session object remains separate from the session opened by the new\n        VM process. It receives its own :py:class:`IConsole`  object which can be used\n        to control machine execution, but it cannot be used to change all VM settings\n        which would be available after a :py:func:`lock_machine`  call.\n        \n        The caller must eventually release the session's shared lock by calling\n        :py:func:`ISession.unlock_machine`  on the local session object once this call\n        has returned. However, the session's state (see :py:func:`ISession.state` )\n        will not return to \"Unlocked\" until the remote session has also unlocked\n        the machine (i.e. the machine has stopped running).\n        \n        Launching a VM process can take some time (a new VM is started in a new process,\n        for which memory and other resources need to be set up). Because of this,\n        an :py:class:`IProgress`  object is returned to allow the caller to wait\n        for this asynchronous operation to be completed. Until then, the caller's\n        session object remains in the \"Unlocked\" state, and its :py:func:`ISession.machine` \n        and :py:func:`ISession.console`  attributes cannot be accessed.\n        It is recommended to use :py:func:`IProgress.wait_for_completion`  or\n        similar calls to wait for completion. Completion is signalled when the VM\n        is powered on. If launching the VM fails, error messages can be queried\n        via the progress object, if available.\n        \n        The progress object will have at least 2 sub-operations. The first\n        operation covers the period up to the new VM process calls powerUp.\n        The subsequent operations mirror the :py:func:`IConsole.power_up` \n        progress object. Because :py:func:`IConsole.power_up`  may require\n        some extra sub-operations, the :py:func:`IProgress.operation_count` \n        may change at the completion of operation.\n        \n        For details on the teleportation progress operation, see\n        :py:func:`IConsole.power_up` .\n        \n        <!-- TODO/r=bird: What about making @a environment into a smart array?  Guess\n        this predates our safe array support by a year or so... Dmitry wrote the text here, right?\n        Just rename it to @a environmentChanges and shorten the documentation to say the string\n        are applied onto the server environment putenv style, i.e. \"VAR=VALUE\" for setting/replacing\n        and \"VAR\" for unsetting. -->\n        The @a environment argument is a string containing definitions of\n        environment variables in the following format:\n        \n        ::\n\n             NAME[=VALUE]\\n\n             NAME[=VALUE]\\n\n             ...\n\n\n        where \\\\n is the new line character. These environment\n        variables will be appended to the environment of the VirtualBox server\n        process. If an environment variable exists both in the server process\n        and in this list, the value from this list takes precedence over the\n        server's variable. If the value of the environment variable is\n        omitted, this variable will be removed from the resulting environment.\n        If the environment string is @c null or empty, the server environment\n        is inherited by the started process as is.\n\n        in session of type :class:`ISession`\n            Client session object to which the VM process will be connected (this\n            must be in \"Unlocked\" state).\n\n        in name of type str\n            Front-end to use for the new VM process. The following are currently supported:\n            \n            \"gui\": VirtualBox Qt GUI front-end\n            \"headless\": VBoxHeadless (VRDE Server) front-end\n            \"sdl\": VirtualBox SDL front-end\n            \"emergencystop\": reserved value, used for aborting\n            the currently running VM or session owner. In this case the\n            @a session parameter may be @c null (if it is non-null it isn't\n            used in any way), and the @a progress return value will be always\n            @c null. The operation completes immediately.\n            \"\": use the per-VM default frontend if set, otherwise\n            the global default defined in the system properties. If neither\n            are set, the API will launch a \"gui\" session, which may\n            fail if there is no windowing environment available. See\n            :py:func:`IMachine.default_frontend`  and\n            :py:func:`ISystemProperties.default_frontend` .\n\n        in environment of type str\n            Environment to pass to the VM process.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`OleErrorUnexpected`\n            Virtual machine not registered.\n        \n        raises :class:`OleErrorInvalidarg`\n            Invalid session type @a type.\n        \n        raises :class:`VBoxErrorObjectNotFound`\n            No machine matching @a machineId found.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Session already open or being opened.\n        \n        raises :class:`VBoxErrorIprtError`\n            Launching process for machine failed.\n        \n        raises :class:`VBoxErrorVmError`\n            Failed to assign machine to session.\n        \n        \"\"\"\n        if not isinstance(session, ISession):\n            raise TypeError(\"session can only be an instance of type ISession\")\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(environment, basestring):\n            raise TypeError(\"environment can only be an instance of type basestring\")\n        progress = self._call(\"launchVMProcess\",\n                     in_p=[session, name, environment])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the boot order of the given USB device.", "response": "def set_boot_order(self, position, device):\n        \"\"\"Puts the given device to the specified position in\n        the boot order.\n        \n        To indicate that no device is associated with the given position,\n        :py:attr:`DeviceType.null`  should be used.\n        \n        @todo setHardDiskBootOrder(), setNetworkBootOrder()\n\n        in position of type int\n            Position in the boot order (@c 1 to the total number of\n            devices the machine can boot from, as returned by\n            :py:func:`ISystemProperties.max_boot_position` ).\n\n        in device of type :class:`DeviceType`\n            The type of the device used to boot at the given position.\n\n        raises :class:`OleErrorInvalidarg`\n            Boot @a position out of range.\n        \n        raises :class:`OleErrorNotimpl`\n            Booting from USB @a device currently not supported.\n        \n        \"\"\"\n        if not isinstance(position, baseinteger):\n            raise TypeError(\"position can only be an instance of type baseinteger\")\n        if not isinstance(device, DeviceType):\n            raise TypeError(\"device can only be an instance of type DeviceType\")\n        self._call(\"setBootOrder\",\n                     in_p=[position, device])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attach_device(self, name, controller_port, device, type_p, medium):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(type_p, DeviceType):\n            raise TypeError(\"type_p can only be an instance of type DeviceType\")\n        if not isinstance(medium, IMedium):\n            raise TypeError(\"medium can only be an instance of type IMedium\")\n        self._call(\"attachDevice\",\n                     in_p=[name, controller_port, device, type_p, medium])", "response": "Attaches a device to a given storage controller."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef attach_device_without_medium(self, name, controller_port, device, type_p):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(type_p, DeviceType):\n            raise TypeError(\"type_p can only be an instance of type DeviceType\")\n        self._call(\"attachDeviceWithoutMedium\",\n                     in_p=[name, controller_port, device, type_p])", "response": "Attaches a device and optionally mounts a medium to the given storage controller."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the passthrough mode of an existing DVD device.", "response": "def passthrough_device(self, name, controller_port, device, passthrough):\n        \"\"\"Sets the passthrough mode of an existing DVD device. Changing the\n        setting while the VM is running is forbidden. The setting is only used\n        if at VM start the device is configured as a host DVD drive, in all\n        other cases it is ignored. The device must already exist; see\n        :py:func:`IMachine.attach_device`  for how to attach a new device.\n        \n        The @a controllerPort and @a device parameters specify the device slot and\n        have have the same meaning as with :py:func:`IMachine.attach_device` .\n\n        in name of type str\n            Name of the storage controller.\n\n        in controller_port of type int\n            Storage controller port.\n\n        in device of type int\n            Device slot in the given port.\n\n        in passthrough of type bool\n            New value for the passthrough setting.\n\n        raises :class:`OleErrorInvalidarg`\n            SATA device, SATA port, IDE port or IDE slot out of range.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Attempt to modify an unregistered virtual machine.\n        \n        raises :class:`VBoxErrorInvalidVmState`\n            Invalid machine state.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(passthrough, bool):\n            raise TypeError(\"passthrough can only be an instance of type bool\")\n        self._call(\"passthroughDevice\",\n                     in_p=[name, controller_port, device, passthrough])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the behavior for guest - triggered medium eject.", "response": "def temporary_eject_device(self, name, controller_port, device, temporary_eject):\n        \"\"\"Sets the behavior for guest-triggered medium eject. In some situations\n        it is desirable that such ejects update the VM configuration, and in\n        others the eject should keep the VM configuration. The device must\n        already exist; see :py:func:`IMachine.attach_device`  for how to\n        attach a new device.\n        \n        The @a controllerPort and @a device parameters specify the device slot and\n        have have the same meaning as with :py:func:`IMachine.attach_device` .\n\n        in name of type str\n            Name of the storage controller.\n\n        in controller_port of type int\n            Storage controller port.\n\n        in device of type int\n            Device slot in the given port.\n\n        in temporary_eject of type bool\n            New value for the eject behavior.\n\n        raises :class:`OleErrorInvalidarg`\n            SATA device, SATA port, IDE port or IDE slot out of range.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Attempt to modify an unregistered virtual machine.\n        \n        raises :class:`VBoxErrorInvalidVmState`\n            Invalid machine state.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(temporary_eject, bool):\n            raise TypeError(\"temporary_eject can only be an instance of type bool\")\n        self._call(\"temporaryEjectDevice\",\n                     in_p=[name, controller_port, device, temporary_eject])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a flag in the device information which indicates that the medium is not based on rotational technology.", "response": "def non_rotational_device(self, name, controller_port, device, non_rotational):\n        \"\"\"Sets a flag in the device information which indicates that the medium\n        is not based on rotational technology, i.e. that the access times are\n        more or less independent of the position on the medium. This may or may\n        not be supported by a particular drive, and is silently ignored in the\n        latter case. At the moment only hard disks (which is a misnomer in this\n        context) accept this setting. Changing the setting while the VM is\n        running is forbidden. The device must already exist; see\n        :py:func:`IMachine.attach_device`  for how to attach a new device.\n        \n        The @a controllerPort and @a device parameters specify the device slot and\n        have have the same meaning as with :py:func:`IMachine.attach_device` .\n\n        in name of type str\n            Name of the storage controller.\n\n        in controller_port of type int\n            Storage controller port.\n\n        in device of type int\n            Device slot in the given port.\n\n        in non_rotational of type bool\n            New value for the non-rotational device flag.\n\n        raises :class:`OleErrorInvalidarg`\n            SATA device, SATA port, IDE port or IDE slot out of range.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Attempt to modify an unregistered virtual machine.\n        \n        raises :class:`VBoxErrorInvalidVmState`\n            Invalid machine state.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(non_rotational, bool):\n            raise TypeError(\"non_rotational can only be an instance of type bool\")\n        self._call(\"nonRotationalDevice\",\n                     in_p=[name, controller_port, device, non_rotational])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the flag in the device information which indicates that the medium supports discarding unused blocks for a given SCSI device.", "response": "def set_auto_discard_for_device(self, name, controller_port, device, discard):\n        \"\"\"Sets a flag in the device information which indicates that the medium\n        supports discarding unused blocks (called trimming for SATA or unmap\n        for SCSI devices) .This may or may not be supported by a particular drive,\n        and is silently ignored in the latter case. At the moment only hard disks\n        (which is a misnomer in this context) accept this setting. Changing the\n        setting while the VM is running is forbidden. The device must already\n        exist; see :py:func:`IMachine.attach_device`  for how to attach a new\n        device.\n        \n        The @a controllerPort and @a device parameters specify the device slot and\n        have have the same meaning as with :py:func:`IMachine.attach_device` .\n\n        in name of type str\n            Name of the storage controller.\n\n        in controller_port of type int\n            Storage controller port.\n\n        in device of type int\n            Device slot in the given port.\n\n        in discard of type bool\n            New value for the discard device flag.\n\n        raises :class:`OleErrorInvalidarg`\n            SATA device, SATA port, SCSI port out of range.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Attempt to modify an unregistered virtual machine.\n        \n        raises :class:`VBoxErrorInvalidVmState`\n            Invalid machine state.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(discard, bool):\n            raise TypeError(\"discard can only be an instance of type bool\")\n        self._call(\"setAutoDiscardForDevice\",\n                     in_p=[name, controller_port, device, discard])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the hot - pluggable flag for the given controller port and device.", "response": "def set_hot_pluggable_for_device(self, name, controller_port, device, hot_pluggable):\n        \"\"\"Sets a flag in the device information which indicates that the attached\n        device is hot pluggable or not. This may or may not be supported by a\n        particular controller and/or drive, and is silently ignored in the\n        latter case. Changing the setting while the VM is running is forbidden.\n        The device must already exist; see :py:func:`IMachine.attach_device` \n        for how to attach a new device.\n        \n        The @a controllerPort and @a device parameters specify the device slot and\n        have have the same meaning as with :py:func:`IMachine.attach_device` .\n\n        in name of type str\n            Name of the storage controller.\n\n        in controller_port of type int\n            Storage controller port.\n\n        in device of type int\n            Device slot in the given port.\n\n        in hot_pluggable of type bool\n            New value for the hot-pluggable device flag.\n\n        raises :class:`OleErrorInvalidarg`\n            SATA device, SATA port, IDE port or IDE slot out of range.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Attempt to modify an unregistered virtual machine.\n        \n        raises :class:`VBoxErrorInvalidVmState`\n            Invalid machine state.\n        \n        raises :class:`VBoxErrorNotSupported`\n            Controller doesn't support hot plugging.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(hot_pluggable, bool):\n            raise TypeError(\"hot_pluggable can only be an instance of type bool\")\n        self._call(\"setHotPluggableForDevice\",\n                     in_p=[name, controller_port, device, hot_pluggable])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the bandwidth group for a given storage controller and device.", "response": "def set_bandwidth_group_for_device(self, name, controller_port, device, bandwidth_group):\n        \"\"\"Sets the bandwidth group of an existing storage device.\n        The device must already exist; see :py:func:`IMachine.attach_device` \n        for how to attach a new device.\n        \n        The @a controllerPort and @a device parameters specify the device slot and\n        have have the same meaning as with :py:func:`IMachine.attach_device` .\n\n        in name of type str\n            Name of the storage controller.\n\n        in controller_port of type int\n            Storage controller port.\n\n        in device of type int\n            Device slot in the given port.\n\n        in bandwidth_group of type :class:`IBandwidthGroup`\n            New value for the bandwidth group or @c null for no group.\n\n        raises :class:`OleErrorInvalidarg`\n            SATA device, SATA port, IDE port or IDE slot out of range.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Attempt to modify an unregistered virtual machine.\n        \n        raises :class:`VBoxErrorInvalidVmState`\n            Invalid machine state.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(bandwidth_group, IBandwidthGroup):\n            raise TypeError(\"bandwidth_group can only be an instance of type IBandwidthGroup\")\n        self._call(\"setBandwidthGroupForDevice\",\n                     in_p=[name, controller_port, device, bandwidth_group])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_no_bandwidth_group_for_device(self, name, controller_port, device):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        self._call(\"setNoBandwidthGroupForDevice\",\n                     in_p=[name, controller_port, device])", "response": "Sets the no bandwidth group for a given storage controller."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unmount_medium(self, name, controller_port, device, force):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(force, bool):\n            raise TypeError(\"force can only be an instance of type bool\")\n        self._call(\"unmountMedium\",\n                     in_p=[name, controller_port, device, force])", "response": "Unmounts any currently mounted medium from the given storage controller."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmount a medium to the given storage controller.", "response": "def mount_medium(self, name, controller_port, device, medium, force):\n        \"\"\"Mounts a medium (:py:class:`IMedium` , identified\n        by the given UUID @a id) to the given storage controller\n        (:py:class:`IStorageController` , identified by @a name),\n        at the indicated port and device. The device must already exist;\n        see :py:func:`IMachine.attach_device`  for how to attach a new device.\n        \n        This method is intended only for managing removable media, where the\n        device is fixed but media is changeable at runtime (such as DVDs\n        and floppies). It cannot be used for fixed media such as hard disks.\n        \n        The @a controllerPort and @a device parameters specify the device slot and\n        have have the same meaning as with :py:func:`IMachine.attach_device` .\n        \n        The specified device slot can have a medium mounted, which will be\n        unmounted first. Specifying a zero UUID (or an empty string) for\n        @a medium does just an unmount.\n        \n        See :py:class:`IMedium`  for more detailed information about\n        attaching media.\n\n        in name of type str\n            Name of the storage controller to attach the medium to.\n\n        in controller_port of type int\n            Port to attach the medium to.\n\n        in device of type int\n            Device slot in the given port to attach the medium to.\n\n        in medium of type :class:`IMedium`\n            Medium to mount or @c null for an empty drive.\n\n        in force of type bool\n            Allows to force unmount/mount of a medium which is locked by\n            the device slot in the given port to attach the medium to.\n\n        raises :class:`OleErrorInvalidarg`\n            SATA device, SATA port, IDE port or IDE slot out of range.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Attempt to attach medium to an unregistered virtual machine.\n        \n        raises :class:`VBoxErrorInvalidVmState`\n            Invalid machine state.\n        \n        raises :class:`VBoxErrorObjectInUse`\n            Medium already attached to this or another virtual machine.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        if not isinstance(medium, IMedium):\n            raise TypeError(\"medium can only be an instance of type IMedium\")\n        if not isinstance(force, bool):\n            raise TypeError(\"force can only be an instance of type bool\")\n        self._call(\"mountMedium\",\n                     in_p=[name, controller_port, device, medium, force])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_medium(self, name, controller_port, device):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        medium = self._call(\"getMedium\",\n                     in_p=[name, controller_port, device])\n        medium = IMedium(medium)\n        return medium", "response": "Returns the virtual medium attached to the given controller port and device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an array of medium attachments which are attached to the given storage controller with the given name.", "response": "def get_medium_attachments_of_controller(self, name):\n        \"\"\"Returns an array of medium attachments which are attached to the\n        the controller with the given name.\n\n        in name of type str\n\n        return medium_attachments of type :class:`IMediumAttachment`\n\n        raises :class:`VBoxErrorObjectNotFound`\n            A storage controller with given name doesn't exist.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        medium_attachments = self._call(\"getMediumAttachmentsOfController\",\n                     in_p=[name])\n        medium_attachments = [IMediumAttachment(a) for a in medium_attachments]\n        return medium_attachments"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_medium_attachment(self, name, controller_port, device):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(controller_port, baseinteger):\n            raise TypeError(\"controller_port can only be an instance of type baseinteger\")\n        if not isinstance(device, baseinteger):\n            raise TypeError(\"device can only be an instance of type baseinteger\")\n        attachment = self._call(\"getMediumAttachment\",\n                     in_p=[name, controller_port, device])\n        attachment = IMediumAttachment(attachment)\n        return attachment", "response": "Returns a medium attachment which corresponds to the given controller port and device slot."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef attach_host_pci_device(self, host_address, desired_guest_address, try_to_unbind):\n        if not isinstance(host_address, baseinteger):\n            raise TypeError(\"host_address can only be an instance of type baseinteger\")\n        if not isinstance(desired_guest_address, baseinteger):\n            raise TypeError(\"desired_guest_address can only be an instance of type baseinteger\")\n        if not isinstance(try_to_unbind, bool):\n            raise TypeError(\"try_to_unbind can only be an instance of type bool\")\n        self._call(\"attachHostPCIDevice\",\n                     in_p=[host_address, desired_guest_address, try_to_unbind])", "response": "Attaches the given host PCI device to the virtual machine."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef detach_host_pci_device(self, host_address):\n        if not isinstance(host_address, baseinteger):\n            raise TypeError(\"host_address can only be an instance of type baseinteger\")\n        self._call(\"detachHostPCIDevice\",\n                     in_p=[host_address])", "response": "Detaches the host PCI device from the virtual machine."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_network_adapter(self, slot):\n        if not isinstance(slot, baseinteger):\n            raise TypeError(\"slot can only be an instance of type baseinteger\")\n        adapter = self._call(\"getNetworkAdapter\",\n                     in_p=[slot])\n        adapter = INetworkAdapter(adapter)\n        return adapter", "response": "Returns the network adapter associated with the given slot."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_storage_controller(self, name, connection_type):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(connection_type, StorageBus):\n            raise TypeError(\"connection_type can only be an instance of type StorageBus\")\n        controller = self._call(\"addStorageController\",\n                     in_p=[name, connection_type])\n        controller = IStorageController(controller)\n        return controller", "response": "Adds a new storage controller to the current state of the specified storage bus."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a storage controller with the given name.", "response": "def get_storage_controller_by_name(self, name):\n        \"\"\"Returns a storage controller with the given name.\n\n        in name of type str\n\n        return storage_controller of type :class:`IStorageController`\n\n        raises :class:`VBoxErrorObjectNotFound`\n            A storage controller with given name doesn't exist.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        storage_controller = self._call(\"getStorageControllerByName\",\n                     in_p=[name])\n        storage_controller = IStorageController(storage_controller)\n        return storage_controller"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a storage controller with the given instance number.", "response": "def get_storage_controller_by_instance(self, connection_type, instance):\n        \"\"\"Returns a storage controller of a specific storage bus\n        with the given instance number.\n\n        in connection_type of type :class:`StorageBus`\n\n        in instance of type int\n\n        return storage_controller of type :class:`IStorageController`\n\n        raises :class:`VBoxErrorObjectNotFound`\n            A storage controller with given instance number doesn't exist.\n        \n        \"\"\"\n        if not isinstance(connection_type, StorageBus):\n            raise TypeError(\"connection_type can only be an instance of type StorageBus\")\n        if not isinstance(instance, baseinteger):\n            raise TypeError(\"instance can only be an instance of type baseinteger\")\n        storage_controller = self._call(\"getStorageControllerByInstance\",\n                     in_p=[connection_type, instance])\n        storage_controller = IStorageController(storage_controller)\n        return storage_controller"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_storage_controller(self, name):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        self._call(\"removeStorageController\",\n                     in_p=[name])", "response": "Removes a storage controller from the machine with all devices attached to it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the bootable flag of the storage controller with the given name.", "response": "def set_storage_controller_bootable(self, name, bootable):\n        \"\"\"Sets the bootable flag of the storage controller with the given name.\n\n        in name of type str\n\n        in bootable of type bool\n\n        raises :class:`VBoxErrorObjectNotFound`\n            A storage controller with given name doesn't exist.\n        \n        raises :class:`VBoxErrorObjectInUse`\n            Another storage controller is marked as bootable already.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(bootable, bool):\n            raise TypeError(\"bootable can only be an instance of type bool\")\n        self._call(\"setStorageControllerBootable\",\n                     in_p=[name, bootable])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a new USB controller to the machine and returns it as an IUSBController instance.", "response": "def add_usb_controller(self, name, type_p):\n        \"\"\"Adds a new USB controller to the machine and returns it as an instance of\n        :py:class:`IUSBController` .\n\n        in name of type str\n\n        in type_p of type :class:`USBControllerType`\n\n        return controller of type :class:`IUSBController`\n\n        raises :class:`VBoxErrorObjectInUse`\n            A USB controller with given type exists already.\n        \n        raises :class:`OleErrorInvalidarg`\n            Invalid @a controllerType.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(type_p, USBControllerType):\n            raise TypeError(\"type_p can only be an instance of type USBControllerType\")\n        controller = self._call(\"addUSBController\",\n                     in_p=[name, type_p])\n        controller = IUSBController(controller)\n        return controller"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove a USB controller from the machine.", "response": "def remove_usb_controller(self, name):\n        \"\"\"Removes a USB controller from the machine.\n\n        in name of type str\n\n        raises :class:`VBoxErrorObjectNotFound`\n            A USB controller with given type doesn't exist.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        self._call(\"removeUSBController\",\n                     in_p=[name])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_usb_controller_by_name(self, name):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        controller = self._call(\"getUSBControllerByName\",\n                     in_p=[name])\n        controller = IUSBController(controller)\n        return controller", "response": "Returns a USB controller with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the number of USB controllers of the given type attached to the VM.", "response": "def get_usb_controller_count_by_type(self, type_p):\n        \"\"\"Returns the number of USB controllers of the given type attached to the VM.\n\n        in type_p of type :class:`USBControllerType`\n\n        return controllers of type int\n\n        \"\"\"\n        if not isinstance(type_p, USBControllerType):\n            raise TypeError(\"type_p can only be an instance of type USBControllerType\")\n        controllers = self._call(\"getUSBControllerCountByType\",\n                     in_p=[type_p])\n        return controllers"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_serial_port(self, slot):\n        if not isinstance(slot, baseinteger):\n            raise TypeError(\"slot can only be an instance of type baseinteger\")\n        port = self._call(\"getSerialPort\",\n                     in_p=[slot])\n        port = ISerialPort(port)\n        return port", "response": "Returns the serial port associated with the given slot."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_parallel_port(self, slot):\n        if not isinstance(slot, baseinteger):\n            raise TypeError(\"slot can only be an instance of type baseinteger\")\n        port = self._call(\"getParallelPort\",\n                     in_p=[slot])\n        port = IParallelPort(port)\n        return port", "response": "Returns the parallel port associated with the given slot."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_cpu_property(self, property_p):\n        if not isinstance(property_p, CPUPropertyType):\n            raise TypeError(\"property_p can only be an instance of type CPUPropertyType\")\n        value = self._call(\"getCPUProperty\",\n                     in_p=[property_p])\n        return value", "response": "Returns the virtual CPU boolean value of the specified property."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the virtual CPU boolean value of the specified property.", "response": "def set_cpu_property(self, property_p, value):\n        \"\"\"Sets the virtual CPU boolean value of the specified property.\n\n        in property_p of type :class:`CPUPropertyType`\n            Property type to query.\n\n        in value of type bool\n            Property value.\n\n        raises :class:`OleErrorInvalidarg`\n            Invalid property.\n        \n        \"\"\"\n        if not isinstance(property_p, CPUPropertyType):\n            raise TypeError(\"property_p can only be an instance of type CPUPropertyType\")\n        if not isinstance(value, bool):\n            raise TypeError(\"value can only be an instance of type bool\")\n        self._call(\"setCPUProperty\",\n                     in_p=[property_p, value])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_cpuid_leaf_by_ordinal(self, ordinal):\n        if not isinstance(ordinal, baseinteger):\n            raise TypeError(\"ordinal can only be an instance of type baseinteger\")\n        (idx, idx_sub, val_eax, val_ebx, val_ecx, val_edx) = self._call(\"getCPUIDLeafByOrdinal\",\n                     in_p=[ordinal])\n        return (idx, idx_sub, val_eax, val_ebx, val_ecx, val_edx)", "response": "Used to enumerate CPUID information override values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_cpuid_leaf(self, idx, idx_sub):\n        if not isinstance(idx, baseinteger):\n            raise TypeError(\"idx can only be an instance of type baseinteger\")\n        if not isinstance(idx_sub, baseinteger):\n            raise TypeError(\"idx_sub can only be an instance of type baseinteger\")\n        (val_eax, val_ebx, val_ecx, val_edx) = self._call(\"getCPUIDLeaf\",\n                     in_p=[idx, idx_sub])\n        return (val_eax, val_ebx, val_ecx, val_edx)", "response": "Returns the virtual CPU cpuid information for the specified leaf."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the virtual CPU cpuid information for the specified leaf.", "response": "def set_cpuid_leaf(self, idx, idx_sub, val_eax, val_ebx, val_ecx, val_edx):\n        \"\"\"Sets the virtual CPU cpuid information for the specified leaf. Note that these values\n        are not passed unmodified. VirtualBox clears features that it doesn't support.\n        \n        Currently supported index values for cpuid:\n        Standard CPUID leaves: 0 - 0x1f\n        Extended CPUID leaves: 0x80000000 - 0x8000001f\n        VIA CPUID leaves:      0xc0000000 - 0xc000000f\n        \n        The subleaf index is only applicable to certain leaves (see manuals as this is\n        subject to change).\n        \n        See the Intel, AMD and VIA programmer's manuals for detailed information\n        about the cpuid instruction and its leaves.\n        \n        Do not use this method unless you know exactly what you're doing. Misuse can lead to\n        random crashes inside VMs.\n\n        in idx of type int\n            CPUID leaf index.\n\n        in idx_sub of type int\n            CPUID leaf sub-index (ECX).  Set to 0xffffffff (or 0) if not applicable.\n            The 0xffffffff causes it to remove all other subleaves before adding one\n            with sub-index 0.\n\n        in val_eax of type int\n            CPUID leaf value for register eax.\n\n        in val_ebx of type int\n            CPUID leaf value for register ebx.\n\n        in val_ecx of type int\n            CPUID leaf value for register ecx.\n\n        in val_edx of type int\n            CPUID leaf value for register edx.\n\n        raises :class:`OleErrorInvalidarg`\n            Invalid index.\n        \n        \"\"\"\n        if not isinstance(idx, baseinteger):\n            raise TypeError(\"idx can only be an instance of type baseinteger\")\n        if not isinstance(idx_sub, baseinteger):\n            raise TypeError(\"idx_sub can only be an instance of type baseinteger\")\n        if not isinstance(val_eax, baseinteger):\n            raise TypeError(\"val_eax can only be an instance of type baseinteger\")\n        if not isinstance(val_ebx, baseinteger):\n            raise TypeError(\"val_ebx can only be an instance of type baseinteger\")\n        if not isinstance(val_ecx, baseinteger):\n            raise TypeError(\"val_ecx can only be an instance of type baseinteger\")\n        if not isinstance(val_edx, baseinteger):\n            raise TypeError(\"val_edx can only be an instance of type baseinteger\")\n        self._call(\"setCPUIDLeaf\",\n                     in_p=[idx, idx_sub, val_eax, val_ebx, val_ecx, val_edx])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_cpuid_leaf(self, idx, idx_sub):\n        if not isinstance(idx, baseinteger):\n            raise TypeError(\"idx can only be an instance of type baseinteger\")\n        if not isinstance(idx_sub, baseinteger):\n            raise TypeError(\"idx_sub can only be an instance of type baseinteger\")\n        self._call(\"removeCPUIDLeaf\",\n                     in_p=[idx, idx_sub])", "response": "Removes the virtual CPU cpuid leaf for the specified index and sub - index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_hw_virt_ex_property(self, property_p):\n        if not isinstance(property_p, HWVirtExPropertyType):\n            raise TypeError(\"property_p can only be an instance of type HWVirtExPropertyType\")\n        value = self._call(\"getHWVirtExProperty\",\n                     in_p=[property_p])\n        return value", "response": "Returns the value of the specified hardware virtualization boolean property."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets a new value for the specified hardware virtualization boolean property.", "response": "def set_hw_virt_ex_property(self, property_p, value):\n        \"\"\"Sets a new value for the specified hardware virtualization boolean property.\n\n        in property_p of type :class:`HWVirtExPropertyType`\n            Property type to set.\n\n        in value of type bool\n            New property value.\n\n        raises :class:`OleErrorInvalidarg`\n            Invalid property.\n        \n        \"\"\"\n        if not isinstance(property_p, HWVirtExPropertyType):\n            raise TypeError(\"property_p can only be an instance of type HWVirtExPropertyType\")\n        if not isinstance(value, bool):\n            raise TypeError(\"value can only be an instance of type bool\")\n        self._call(\"setHWVirtExProperty\",\n                     in_p=[property_p, value])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nchange the path of the settings file.", "response": "def set_settings_file_path(self, settings_file_path):\n        \"\"\"Currently, it is an error to change this property on any machine.\n        Later this will allow setting a new path for the settings file, with\n        automatic relocation of all files (including snapshots and disk images)\n        which are inside the base directory. This operation is only allowed\n        when there are no pending unsaved settings.\n        \n        \n        Setting this property to @c null or to an empty string is forbidden.\n        When setting this property, the specified path must be absolute.\n        The specified path may not exist, it will be created when necessary.\n\n        in settings_file_path of type str\n            New settings file path, will be used to determine the new\n            location for the attached media if it is in the same directory or\n            below as the original settings file.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`OleErrorNotimpl`\n            The operation is not implemented yet.\n        \n        \"\"\"\n        if not isinstance(settings_file_path, basestring):\n            raise TypeError(\"settings_file_path can only be an instance of type basestring\")\n        progress = self._call(\"setSettingsFilePath\",\n                     in_p=[settings_file_path])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes the configuration files associated with this machine.", "response": "def delete_config(self, media):\n        \"\"\"Deletes the files associated with this machine from disk. If medium objects are passed\n        in with the @a aMedia argument, they are closed and, if closing was successful, their\n        storage files are deleted as well. For convenience, this array of media files can be\n        the same as the one returned from a previous :py:func:`unregister`  call.\n        \n        This method must only be called on machines which are either write-locked (i.e. on instances\n        returned by :py:func:`ISession.machine` ) or on unregistered machines (i.e. not yet\n        registered machines created by :py:func:`IVirtualBox.create_machine`  or opened by\n        :py:func:`IVirtualBox.open_machine` , or after having called :py:func:`unregister` ).\n        \n        The following files will be deleted by this method:\n        \n        If :py:func:`unregister`  had been previously called with a @a cleanupMode\n        argument other than \"UnregisterOnly\", this will delete all saved state files that\n        the machine had in use; possibly one if the machine was in \"Saved\" state and one\n        for each online snapshot that the machine had.\n        On each medium object passed in the @a aMedia array, this will call\n        :py:func:`IMedium.close` . If that succeeds, this will attempt to delete the\n        medium's storage on disk. Since the :py:func:`IMedium.close`  call will fail if the medium is still\n        in use, e.g. because it is still attached to a second machine; in that case the\n        storage will not be deleted.\n        Finally, the machine's own XML file will be deleted.\n        \n        \n        Since deleting large disk image files can be a time-consuming I/O operation, this\n        method operates asynchronously and returns an IProgress object to allow the caller\n        to monitor the progress. There will be one sub-operation for each file that is\n        being deleted (saved state or medium storage file).\n        \n        \n        :py:func:`settings_modified`  will return @c true after this\n        method successfully returns.\n\n        in media of type :class:`IMedium`\n            List of media to be closed and whose storage files will be deleted.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Machine is registered but not write-locked.\n        \n        raises :class:`VBoxErrorIprtError`\n            Could not delete the settings file.\n        \n        \"\"\"\n        if not isinstance(media, list):\n            raise TypeError(\"media can only be an instance of type list\")\n        for a in media[:10]:\n            if not isinstance(a, IMedium):\n                raise TypeError(\n                        \"array can only contain objects of type IMedium\")\n        progress = self._call(\"deleteConfig\",\n                     in_p=[media])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexports the machine to an OVF appliance.", "response": "def export_to(self, appliance, location):\n        \"\"\"Exports the machine to an OVF appliance. See :py:class:`IAppliance`  for the\n        steps required to export VirtualBox machines to OVF.\n\n        in appliance of type :class:`IAppliance`\n            Appliance to export this machine to.\n\n        in location of type str\n            The target location.\n\n        return description of type :class:`IVirtualSystemDescription`\n            VirtualSystemDescription object which is created for this machine.\n\n        \"\"\"\n        if not isinstance(appliance, IAppliance):\n            raise TypeError(\"appliance can only be an instance of type IAppliance\")\n        if not isinstance(location, basestring):\n            raise TypeError(\"location can only be an instance of type basestring\")\n        description = self._call(\"exportTo\",\n                     in_p=[appliance, location])\n        description = IVirtualSystemDescription(description)\n        return description"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_snapshot(self, name_or_id):\n        if not isinstance(name_or_id, basestring):\n            raise TypeError(\"name_or_id can only be an instance of type basestring\")\n        snapshot = self._call(\"findSnapshot\",\n                     in_p=[name_or_id])\n        snapshot = ISnapshot(snapshot)\n        return snapshot", "response": "Returns a snapshot of this virtual machine with the given name or UUID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_guest_property(self, name):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        (value, timestamp, flags) = self._call(\"getGuestProperty\",\n                     in_p=[name])\n        return (value, timestamp, flags)", "response": "Reads an entry from the machine s guest property store."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_guest_property_value(self, property_p):\n        if not isinstance(property_p, basestring):\n            raise TypeError(\"property_p can only be an instance of type basestring\")\n        value = self._call(\"getGuestPropertyValue\",\n                     in_p=[property_p])\n        return value", "response": "Reads a value from the machine s guest property store."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting or deletes an entry in the machine s guest property store.", "response": "def set_guest_property(self, property_p, value, flags):\n        \"\"\"Sets, changes or deletes an entry in the machine's guest property\n        store.\n\n        in property_p of type str\n            The name of the property to set, change or delete.\n\n        in value of type str\n            The new value of the property to set, change or delete. If the\n            property does not yet exist and value is non-empty, it will be\n            created. If the value is @c null or empty, the property will be\n            deleted if it exists.\n\n        in flags of type str\n            Additional property parameters, passed as a comma-separated list of\n            \"name=value\" type entries.\n\n        raises :class:`OleErrorAccessdenied`\n            Property cannot be changed.\n        \n        raises :class:`OleErrorInvalidarg`\n            Invalid @a flags.\n        \n        raises :class:`VBoxErrorInvalidVmState`\n            Virtual machine is not mutable or session not open.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Cannot set transient property when machine not running.\n        \n        \"\"\"\n        if not isinstance(property_p, basestring):\n            raise TypeError(\"property_p can only be an instance of type basestring\")\n        if not isinstance(value, basestring):\n            raise TypeError(\"value can only be an instance of type basestring\")\n        if not isinstance(flags, basestring):\n            raise TypeError(\"flags can only be an instance of type basestring\")\n        self._call(\"setGuestProperty\",\n                     in_p=[property_p, value, flags])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_guest_property_value(self, property_p, value):\n        if not isinstance(property_p, basestring):\n            raise TypeError(\"property_p can only be an instance of type basestring\")\n        if not isinstance(value, basestring):\n            raise TypeError(\"value can only be an instance of type basestring\")\n        self._call(\"setGuestPropertyValue\",\n                     in_p=[property_p, value])", "response": "Sets or changes a value in the machine s guest property\n            store."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes an entry from the machine s guest property store.", "response": "def delete_guest_property(self, name):\n        \"\"\"Deletes an entry from the machine's guest property store.\n\n        in name of type str\n            The name of the property to delete.\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Machine session is not open.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        self._call(\"deleteGuestProperty\",\n                     in_p=[name])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef enumerate_guest_properties(self, patterns):\n        if not isinstance(patterns, basestring):\n            raise TypeError(\"patterns can only be an instance of type basestring\")\n        (names, values, timestamps, flags) = self._call(\"enumerateGuestProperties\",\n                     in_p=[patterns])\n        return (names, values, timestamps, flags)", "response": "Return a list of the guest properties matching a set of patterns along\n            with their values timestamps and flags."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nqueries the guest screen info from the saved state.", "response": "def query_saved_guest_screen_info(self, screen_id):\n        \"\"\"Returns the guest dimensions from the saved state.\n\n        in screen_id of type int\n            Saved guest screen to query info from.\n\n        out origin_x of type int\n            The X position of the guest monitor top left corner.\n\n        out origin_y of type int\n            The Y position of the guest monitor top left corner.\n\n        out width of type int\n            Guest width at the time of the saved state was taken.\n\n        out height of type int\n            Guest height at the time of the saved state was taken.\n\n        out enabled of type bool\n            Whether the monitor is enabled in the guest.\n\n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        (origin_x, origin_y, width, height, enabled) = self._call(\"querySavedGuestScreenInfo\",\n                     in_p=[screen_id])\n        return (origin_x, origin_y, width, height, enabled)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef query_saved_screenshot_info(self, screen_id):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        (bitmap_formats, width, height) = self._call(\"querySavedScreenshotInfo\",\n                     in_p=[screen_id])\n        bitmap_formats = [BitmapFormat(a) for a in bitmap_formats]\n        return (bitmap_formats, width, height)", "response": "Queries the available formats and size of the saved screenshot from the guest screen."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_saved_screenshot_to_array(self, screen_id, bitmap_format):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(bitmap_format, BitmapFormat):\n            raise TypeError(\"bitmap_format can only be an instance of type BitmapFormat\")\n        (data, width, height) = self._call(\"readSavedScreenshotToArray\",\n                     in_p=[screen_id, bitmap_format])\n        return (data, width, height)", "response": "Reads the saved screenshot to an array of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hot_plug_cpu(self, cpu):\n        if not isinstance(cpu, baseinteger):\n            raise TypeError(\"cpu can only be an instance of type baseinteger\")\n        self._call(\"hotPlugCPU\",\n                     in_p=[cpu])", "response": "Plugs a CPU into the machine."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a CPU from the machine.", "response": "def hot_unplug_cpu(self, cpu):\n        \"\"\"Removes a CPU from the machine.\n\n        in cpu of type int\n            The CPU id to remove.\n\n        \"\"\"\n        if not isinstance(cpu, baseinteger):\n            raise TypeError(\"cpu can only be an instance of type baseinteger\")\n        self._call(\"hotUnplugCPU\",\n                     in_p=[cpu])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cpu_status(self, cpu):\n        if not isinstance(cpu, baseinteger):\n            raise TypeError(\"cpu can only be an instance of type baseinteger\")\n        attached = self._call(\"getCPUStatus\",\n                     in_p=[cpu])\n        return attached", "response": "Returns the current status of the given CPU."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query_log_filename(self, idx):\n        if not isinstance(idx, baseinteger):\n            raise TypeError(\"idx can only be an instance of type baseinteger\")\n        filename = self._call(\"queryLogFilename\",\n                     in_p=[idx])\n        return filename", "response": "Queries for the VM log file name of a given index. Returns an empty string if no log file with that index exists. Returns an empty string if no log file with that index exists. Returns an empty string if no log file with that index exists."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_log(self, idx, offset, size):\n        if not isinstance(idx, baseinteger):\n            raise TypeError(\"idx can only be an instance of type baseinteger\")\n        if not isinstance(offset, baseinteger):\n            raise TypeError(\"offset can only be an instance of type baseinteger\")\n        if not isinstance(size, baseinteger):\n            raise TypeError(\"size can only be an instance of type baseinteger\")\n        data = self._call(\"readLog\",\n                     in_p=[idx, offset, size])\n        return data", "response": "Reads the VM log file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clone_to(self, target, mode, options):\n        if not isinstance(target, IMachine):\n            raise TypeError(\"target can only be an instance of type IMachine\")\n        if not isinstance(mode, CloneMode):\n            raise TypeError(\"mode can only be an instance of type CloneMode\")\n        if not isinstance(options, list):\n            raise TypeError(\"options can only be an instance of type list\")\n        for a in options[:10]:\n            if not isinstance(a, CloneOptions):\n                raise TypeError(\n                        \"array can only contain objects of type CloneOptions\")\n        progress = self._call(\"cloneTo\",\n                     in_p=[target, mode, options])\n        progress = IProgress(progress)\n        return progress", "response": "Creates a full or linked clone of this machine."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef move_to(self, folder, type_p):\n        if not isinstance(folder, basestring):\n            raise TypeError(\"folder can only be an instance of type basestring\")\n        if not isinstance(type_p, basestring):\n            raise TypeError(\"type_p can only be an instance of type basestring\")\n        progress = self._call(\"moveTo\",\n                     in_p=[folder, type_p])\n        progress = IProgress(progress)\n        return progress", "response": "Moves the current machine to a new place."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadopts the given saved state file to the virtual machine.", "response": "def adopt_saved_state(self, saved_state_file):\n        \"\"\"Associates the given saved state file to the virtual machine.\n        \n        On success, the machine will go to the Saved state. Next time it is\n        powered up, it will be restored from the adopted saved state and\n        continue execution from the place where the saved state file was\n        created.\n        \n        The specified saved state file path may be absolute or relative to the\n        folder the VM normally saves the state to (usually,\n        :py:func:`snapshot_folder` ).\n        \n        \n        It's a caller's responsibility to make sure the given saved state\n        file is compatible with the settings of this virtual machine that\n        represent its virtual hardware (memory size, storage disk configuration\n        etc.). If there is a mismatch, the behavior of the virtual machine\n        is undefined.\n\n        in saved_state_file of type str\n            Path to the saved state file to adopt.\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Virtual machine state neither PoweredOff nor Aborted.\n        \n        \"\"\"\n        if not isinstance(saved_state_file, basestring):\n            raise TypeError(\"saved_state_file can only be an instance of type basestring\")\n        self._call(\"adoptSavedState\",\n                     in_p=[saved_state_file])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef take_snapshot(self, name, description, pause):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(description, basestring):\n            raise TypeError(\"description can only be an instance of type basestring\")\n        if not isinstance(pause, bool):\n            raise TypeError(\"pause can only be an instance of type bool\")\n        (progress, id_p) = self._call(\"takeSnapshot\",\n                     in_p=[name, description, pause])\n        progress = IProgress(progress)\n        return (progress, id_p)", "response": "Creates a new snapshot of the specified name description and pause."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete the specified snapshot range.", "response": "def delete_snapshot_range(self, start_id, end_id):\n        \"\"\"Starts deleting the specified snapshot range. This is limited to\n        linear snapshot lists, which means there may not be any other child\n        snapshots other than the direct sequence between the start and end\n        snapshot. If the start and end snapshot point to the same snapshot this\n        method is completely equivalent to :py:func:`delete_snapshot` . See\n        :py:class:`ISnapshot`  for an introduction to snapshots. The\n        conditions and many details are the same as with\n        :py:func:`delete_snapshot` .\n        \n        This operation is generally faster than deleting snapshots one by one\n        and often also needs less extra disk space before freeing up disk space\n        by deleting the removed disk images corresponding to the snapshot.\n        \n        This API method is right now not implemented!\n\n        in start_id of type str\n            UUID of the first snapshot to delete.\n\n        in end_id of type str\n            UUID of the last snapshot to delete.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`VBoxErrorInvalidVmState`\n            The running virtual machine prevents deleting this snapshot. This\nhappens only in very specific situations, usually snapshots can be\ndeleted without trouble while a VM is running. The error message\ntext explains the reason for the failure.\n        \n        raises :class:`OleErrorNotimpl`\n            The method is not implemented yet.\n        \n        \"\"\"\n        if not isinstance(start_id, basestring):\n            raise TypeError(\"start_id can only be an instance of type basestring\")\n        if not isinstance(end_id, basestring):\n            raise TypeError(\"end_id can only be an instance of type basestring\")\n        progress = self._call(\"deleteSnapshotRange\",\n                     in_p=[start_id, end_id])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrestore the state of the given snapshot asynchronously.", "response": "def restore_snapshot(self, snapshot):\n        \"\"\"Starts resetting the machine's current state to the state contained\n        in the given snapshot, asynchronously. All current settings of the\n        machine will be reset and changes stored in differencing media\n        will be lost.\n        See :py:class:`ISnapshot`  for an introduction to snapshots.\n        \n        After this operation is successfully completed, new empty differencing\n        media are created for all normal media of the machine.\n        \n        If the given snapshot is an online snapshot, the machine will go to\n        the :py:attr:`MachineState.saved` saved state, so that the\n        next time it is powered on, the execution state will be restored\n        from the state of the snapshot.\n        \n        \n        The machine must not be running, otherwise the operation will fail.\n        \n        \n        \n        If the machine state is :py:attr:`MachineState.saved` Saved\n        prior to this operation, the saved state file will be implicitly\n        deleted (as if :py:func:`IMachine.discard_saved_state`  were\n        called).\n\n        in snapshot of type :class:`ISnapshot`\n            The snapshot to restore the VM state from.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Virtual machine is running.\n        \n        \"\"\"\n        if not isinstance(snapshot, ISnapshot):\n            raise TypeError(\"snapshot can only be an instance of type ISnapshot\")\n        progress = self._call(\"restoreSnapshot\",\n                     in_p=[snapshot])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies the defaults for the guest OS type.", "response": "def apply_defaults(self, flags):\n        \"\"\"Applies the defaults for the configured guest OS type. This is\n        primarily for getting sane settings straight after creating a\n        new VM, but it can also be applied later.\n        \n        \n        This is primarily a shortcut, centralizing the tedious job of\n        getting the recommended settings and translating them into\n        settings updates. The settings are made at the end of the call,\n        but not saved.\n\n        in flags of type str\n            Additional flags, to be defined later.\n\n        raises :class:`OleErrorNotimpl`\n            This method is not implemented yet.\n        \n        \"\"\"\n        if not isinstance(flags, basestring):\n            raise TypeError(\"flags can only be an instance of type basestring\")\n        self._call(\"applyDefaults\",\n                     in_p=[flags])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef webcam_attach(self, path, settings):\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(settings, basestring):\n            raise TypeError(\"settings can only be an instance of type basestring\")\n        self._call(\"webcamAttach\",\n                     in_p=[path, settings])", "response": "Attaches the emulated USB webcam to the VM."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetaching the emulated USB webcam from the VM in path of type str", "response": "def webcam_detach(self, path):\n        \"\"\"Detaches the emulated USB webcam from the VM\n\n        in path of type str\n            The host path of the capture device to detach.\n\n        \"\"\"\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        self._call(\"webcamDetach\",\n                     in_p=[path])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the current activity type of given devices or device groups.", "response": "def get_device_activity(self, type_p):\n        \"\"\"Gets the current activity type of given devices or device groups.\n\n        in type_p of type :class:`DeviceType`\n\n        return activity of type :class:`DeviceActivity`\n\n        raises :class:`OleErrorInvalidarg`\n            Invalid device type.\n        \n        \"\"\"\n        if not isinstance(type_p, list):\n            raise TypeError(\"type_p can only be an instance of type list\")\n        for a in type_p[:10]:\n            if not isinstance(a, DeviceType):\n                raise TypeError(\n                        \"array can only contain objects of type DeviceType\")\n        activity = self._call(\"getDeviceActivity\",\n                     in_p=[type_p])\n        activity = [DeviceActivity(a) for a in activity]\n        return activity"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef teleport(self, hostname, tcpport, password, max_downtime):\n        if not isinstance(hostname, basestring):\n            raise TypeError(\"hostname can only be an instance of type basestring\")\n        if not isinstance(tcpport, baseinteger):\n            raise TypeError(\"tcpport can only be an instance of type baseinteger\")\n        if not isinstance(password, basestring):\n            raise TypeError(\"password can only be an instance of type basestring\")\n        if not isinstance(max_downtime, baseinteger):\n            raise TypeError(\"max_downtime can only be an instance of type baseinteger\")\n        progress = self._call(\"teleport\",\n                     in_p=[hostname, tcpport, password, max_downtime])\n        progress = IProgress(progress)\n        return progress", "response": "Tells the virtual machine to a different host machine or process."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a password to the hard disk encryption for the specified medium.", "response": "def add_disk_encryption_password(self, id_p, password, clear_on_suspend):\n        \"\"\"Adds a password used for hard disk encryption/decryption.\n\n        in id_p of type str\n            The identifier used for the password. Must match the identifier\n            used when the encrypted medium was created.\n\n        in password of type str\n            The password.\n\n        in clear_on_suspend of type bool\n            Flag whether to clear the password on VM suspend (due to a suspending host\n            for example). The password must be supplied again before the VM can resume.\n\n        raises :class:`VBoxErrorPasswordIncorrect`\n            The password provided wasn't correct for at least one disk using the provided\nID.\n        \n        \"\"\"\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        if not isinstance(password, basestring):\n            raise TypeError(\"password can only be an instance of type basestring\")\n        if not isinstance(clear_on_suspend, bool):\n            raise TypeError(\"clear_on_suspend can only be an instance of type bool\")\n        self._call(\"addDiskEncryptionPassword\",\n                     in_p=[id_p, password, clear_on_suspend])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_disk_encryption_passwords(self, ids, passwords, clear_on_suspend):\n        if not isinstance(ids, list):\n            raise TypeError(\"ids can only be an instance of type list\")\n        for a in ids[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(passwords, list):\n            raise TypeError(\"passwords can only be an instance of type list\")\n        for a in passwords[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(clear_on_suspend, bool):\n            raise TypeError(\"clear_on_suspend can only be an instance of type bool\")\n        self._call(\"addDiskEncryptionPasswords\",\n                     in_p=[ids, passwords, clear_on_suspend])", "response": "Adds a password used for hard disk encryption and decryption."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_disk_encryption_password(self, id_p):\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        self._call(\"removeDiskEncryptionPassword\",\n                     in_p=[id_p])", "response": "Removes a password used for hard disk encryption and decryption from the running VM."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef enable_static_ip_config(self, ip_address, network_mask):\n        if not isinstance(ip_address, basestring):\n            raise TypeError(\"ip_address can only be an instance of type basestring\")\n        if not isinstance(network_mask, basestring):\n            raise TypeError(\"network_mask can only be an instance of type basestring\")\n        self._call(\"enableStaticIPConfig\",\n                     in_p=[ip_address, network_mask])", "response": "sets and enables the static IP V4 configuration for the given interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets and enables the static IP V6 configuration for the given interface.", "response": "def enable_static_ip_config_v6(self, ipv6_address, ipv6_network_mask_prefix_length):\n        \"\"\"sets and enables the static IP V6 configuration for the given interface.\n\n        in ipv6_address of type str\n            IP address.\n\n        in ipv6_network_mask_prefix_length of type int\n            network mask.\n\n        \"\"\"\n        if not isinstance(ipv6_address, basestring):\n            raise TypeError(\"ipv6_address can only be an instance of type basestring\")\n        if not isinstance(ipv6_network_mask_prefix_length, baseinteger):\n            raise TypeError(\"ipv6_network_mask_prefix_length can only be an instance of type baseinteger\")\n        self._call(\"enableStaticIPConfigV6\",\n                     in_p=[ipv6_address, ipv6_network_mask_prefix_length])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the approximate maximum speed of a specified host CPU in the specified host CPU.", "response": "def get_processor_speed(self, cpu_id):\n        \"\"\"Query the (approximate) maximum speed of a specified host CPU in\n        Megahertz.\n\n        in cpu_id of type int\n            Identifier of the CPU.\n\n        return speed of type int\n            Speed value. 0 is returned if value is not known or @a cpuId is\n            invalid.\n\n        \"\"\"\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        speed = self._call(\"getProcessorSpeed\",\n                     in_p=[cpu_id])\n        return speed"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_processor_feature(self, feature):\n        if not isinstance(feature, ProcessorFeature):\n            raise TypeError(\"feature can only be an instance of type ProcessorFeature\")\n        supported = self._call(\"getProcessorFeature\",\n                     in_p=[feature])\n        return supported", "response": "Query whether a CPU feature is supported or not."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying the model string of a specified host CPU.", "response": "def get_processor_description(self, cpu_id):\n        \"\"\"Query the model string of a specified host CPU.\n\n        in cpu_id of type int\n            Identifier of the CPU.\n            \n            The current implementation might not necessarily return the\n            description for this exact CPU.\n\n        return description of type str\n            Model string. An empty string is returned if value is not known or\n            @a cpuId is invalid.\n\n        \"\"\"\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        description = self._call(\"getProcessorDescription\",\n                     in_p=[cpu_id])\n        return description"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_processor_cpuid_leaf(self, cpu_id, leaf, sub_leaf):\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        if not isinstance(leaf, baseinteger):\n            raise TypeError(\"leaf can only be an instance of type baseinteger\")\n        if not isinstance(sub_leaf, baseinteger):\n            raise TypeError(\"sub_leaf can only be an instance of type baseinteger\")\n        (val_eax, val_ebx, val_ecx, val_edx) = self._call(\"getProcessorCPUIDLeaf\",\n                     in_p=[cpu_id, leaf, sub_leaf])\n        return (val_eax, val_ebx, val_ecx, val_edx)", "response": "Returns the cpuid information for the specified CPU and the specified leaf."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_host_only_network_interface(self):\n        (progress, host_interface) = self._call(\"createHostOnlyNetworkInterface\")\n        progress = IProgress(progress)\n        host_interface = IHostNetworkInterface(host_interface)\n        return (progress, host_interface)", "response": "Creates a new host only network interface."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_host_only_network_interface(self, id_p):\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        progress = self._call(\"removeHostOnlyNetworkInterface\",\n                     in_p=[id_p])\n        progress = IProgress(progress)\n        return progress", "response": "Removes the given Host Only Networking interface from the VBox server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new USB device filter.", "response": "def create_usb_device_filter(self, name):\n        \"\"\"Creates a new USB device filter. All attributes except\n        the filter name are set to empty (any match),\n        *active* is @c false (the filter is not active).\n        \n        The created filter can be added to the list of filters using\n        :py:func:`insert_usb_device_filter` .\n        \n        :py:func:`usb_device_filters` \n\n        in name of type str\n            Filter name. See :py:func:`IUSBDeviceFilter.name`  for more information.\n\n        return filter_p of type :class:`IHostUSBDeviceFilter`\n            Created filter object.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        filter_p = self._call(\"createUSBDeviceFilter\",\n                     in_p=[name])\n        filter_p = IHostUSBDeviceFilter(filter_p)\n        return filter_p"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insert_usb_device_filter(self, position, filter_p):\n        if not isinstance(position, baseinteger):\n            raise TypeError(\"position can only be an instance of type baseinteger\")\n        if not isinstance(filter_p, IHostUSBDeviceFilter):\n            raise TypeError(\"filter_p can only be an instance of type IHostUSBDeviceFilter\")\n        self._call(\"insertUSBDeviceFilter\",\n                     in_p=[position, filter_p])", "response": "Inserts a USB device into the specified position within the VirtualBox instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a USB device filter from the specified position in the USB device filter list.", "response": "def remove_usb_device_filter(self, position):\n        \"\"\"Removes a USB device filter from the specified position in the\n        list of filters.\n        \n        Positions are numbered starting from @c 0. Specifying a\n        position equal to or greater than the number of elements in\n        the list will produce an error.\n        \n        \n        If USB functionality is not available in the given edition of\n        VirtualBox, this method will set the result code to @c E_NOTIMPL.\n        \n        \n        :py:func:`usb_device_filters` \n\n        in position of type int\n            Position to remove the filter from.\n\n        raises :class:`OleErrorInvalidarg`\n            USB device filter list empty or invalid @a position.\n        \n        \"\"\"\n        if not isinstance(position, baseinteger):\n            raise TypeError(\"position can only be an instance of type baseinteger\")\n        self._call(\"removeUSBDeviceFilter\",\n                     in_p=[position])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch for a host DVD drive with the given name.", "response": "def find_host_dvd_drive(self, name):\n        \"\"\"Searches for a host DVD drive with the given @c name.\n\n        in name of type str\n            Name of the host drive to search for\n\n        return drive of type :class:`IMedium`\n            Found host drive object\n\n        raises :class:`VBoxErrorObjectNotFound`\n            Given @c name does not correspond to any host drive.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        drive = self._call(\"findHostDVDDrive\",\n                     in_p=[name])\n        drive = IMedium(drive)\n        return drive"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching through all host network interfaces with the given name.", "response": "def find_host_network_interface_by_name(self, name):\n        \"\"\"Searches through all host network interfaces for an interface with\n        the given @c name.\n        \n        The method returns an error if the given @c name does not\n        correspond to any host network interface.\n\n        in name of type str\n            Name of the host network interface to search for.\n\n        return network_interface of type :class:`IHostNetworkInterface`\n            Found host network interface object.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        network_interface = self._call(\"findHostNetworkInterfaceByName\",\n                     in_p=[name])\n        network_interface = IHostNetworkInterface(network_interface)\n        return network_interface"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_host_network_interface_by_id(self, id_p):\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        network_interface = self._call(\"findHostNetworkInterfaceById\",\n                     in_p=[id_p])\n        network_interface = IHostNetworkInterface(network_interface)\n        return network_interface", "response": "Searches through all host network interfaces with the given GUID and returns the host network interface object corresponding to the host network interface with the given GUID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_host_network_interfaces_of_type(self, type_p):\n        if not isinstance(type_p, HostNetworkInterfaceType):\n            raise TypeError(\"type_p can only be an instance of type HostNetworkInterfaceType\")\n        network_interfaces = self._call(\"findHostNetworkInterfacesOfType\",\n                     in_p=[type_p])\n        network_interfaces = [IHostNetworkInterface(a) for a in network_interfaces]\n        return network_interfaces", "response": "Searches through all host network interfaces and returns a list of host network interfaces of the specified type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for a USB device with the given UUID.", "response": "def find_usb_device_by_id(self, id_p):\n        \"\"\"Searches for a USB device with the given UUID.\n        \n        \n        \n        :py:func:`IUSBDevice.id_p` \n\n        in id_p of type str\n            UUID of the USB device to search for.\n\n        return device of type :class:`IHostUSBDevice`\n            Found USB device object.\n\n        raises :class:`VBoxErrorObjectNotFound`\n            Given @c id does not correspond to any USB device.\n        \n        \"\"\"\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        device = self._call(\"findUSBDeviceById\",\n                     in_p=[id_p])\n        device = IHostUSBDevice(device)\n        return device"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching for a USB device with the given host address.", "response": "def find_usb_device_by_address(self, name):\n        \"\"\"Searches for a USB device with the given host address.\n        \n        \n        \n        :py:func:`IUSBDevice.address` \n\n        in name of type str\n            Address of the USB device (as assigned by the host) to\n            search for.\n\n        return device of type :class:`IHostUSBDevice`\n            Found USB device object.\n\n        raises :class:`VBoxErrorObjectNotFound`\n            Given @c name does not correspond to any USB device.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        device = self._call(\"findUSBDeviceByAddress\",\n                     in_p=[name])\n        device = IHostUSBDevice(device)\n        return device"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a USB device source to the system.", "response": "def add_usb_device_source(self, backend, id_p, address, property_names, property_values):\n        \"\"\"Adds a new USB device source.\n\n        in backend of type str\n            The backend to use as the new device source.\n\n        in id_p of type str\n            Unique ID to identify the source.\n\n        in address of type str\n            Address to use, the format is dependent on the backend.\n            For USB/IP backends for example the notation is host[:port].\n\n        in property_names of type str\n            Array of property names for more detailed configuration. Not used at the moment.\n\n        in property_values of type str\n            Array of property values for more detailed configuration. Not used at the moment.\n\n        \"\"\"\n        if not isinstance(backend, basestring):\n            raise TypeError(\"backend can only be an instance of type basestring\")\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        if not isinstance(address, basestring):\n            raise TypeError(\"address can only be an instance of type basestring\")\n        if not isinstance(property_names, list):\n            raise TypeError(\"property_names can only be an instance of type list\")\n        for a in property_names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(property_values, list):\n            raise TypeError(\"property_values can only be an instance of type list\")\n        for a in property_values[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"addUSBDeviceSource\",\n                     in_p=[backend, id_p, address, property_names, property_values])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_usb_device_source(self, id_p):\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        self._call(\"removeUSBDeviceSource\",\n                     in_p=[id_p])", "response": "Removes a previously added USB device source."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_max_network_adapters(self, chipset):\n        if not isinstance(chipset, ChipsetType):\n            raise TypeError(\"chipset can only be an instance of type ChipsetType\")\n        max_network_adapters = self._call(\"getMaxNetworkAdapters\",\n                     in_p=[chipset])\n        return max_network_adapters", "response": "Returns the maximum number of network adapters associated with every chipset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the maximum number of network adapters that can be used for a given chipset and attachment type.", "response": "def get_max_network_adapters_of_type(self, chipset, type_p):\n        \"\"\"Maximum number of network adapters of a given attachment type,\n        associated with every :py:class:`IMachine`  instance.\n\n        in chipset of type :class:`ChipsetType`\n            The chipset type to get the value for.\n\n        in type_p of type :class:`NetworkAttachmentType`\n            Type of attachment.\n\n        return max_network_adapters of type int\n            The maximum number of network adapters allowed for\n            particular chipset and attachment type.\n\n        \"\"\"\n        if not isinstance(chipset, ChipsetType):\n            raise TypeError(\"chipset can only be an instance of type ChipsetType\")\n        if not isinstance(type_p, NetworkAttachmentType):\n            raise TypeError(\"type_p can only be an instance of type NetworkAttachmentType\")\n        max_network_adapters = self._call(\"getMaxNetworkAdaptersOfType\",\n                     in_p=[chipset, type_p])\n        return max_network_adapters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_max_devices_per_port_for_storage_bus(self, bus):\n        if not isinstance(bus, StorageBus):\n            raise TypeError(\"bus can only be an instance of type StorageBus\")\n        max_devices_per_port = self._call(\"getMaxDevicesPerPortForStorageBus\",\n                     in_p=[bus])\n        return max_devices_per_port", "response": "Returns the maximum number of devices which can be attached to a port for the given storage bus."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the minimum number of ports the given storage bus supports.", "response": "def get_min_port_count_for_storage_bus(self, bus):\n        \"\"\"Returns the minimum number of ports the given storage bus supports.\n\n        in bus of type :class:`StorageBus`\n            The storage bus type to get the value for.\n\n        return min_port_count of type int\n            The minimum number of ports for the given storage bus.\n\n        \"\"\"\n        if not isinstance(bus, StorageBus):\n            raise TypeError(\"bus can only be an instance of type StorageBus\")\n        min_port_count = self._call(\"getMinPortCountForStorageBus\",\n                     in_p=[bus])\n        return min_port_count"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_max_port_count_for_storage_bus(self, bus):\n        if not isinstance(bus, StorageBus):\n            raise TypeError(\"bus can only be an instance of type StorageBus\")\n        max_port_count = self._call(\"getMaxPortCountForStorageBus\",\n                     in_p=[bus])\n        return max_port_count", "response": "Returns the maximum number of ports the given storage bus supports."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_max_instances_of_storage_bus(self, chipset, bus):\n        if not isinstance(chipset, ChipsetType):\n            raise TypeError(\"chipset can only be an instance of type ChipsetType\")\n        if not isinstance(bus, StorageBus):\n            raise TypeError(\"bus can only be an instance of type StorageBus\")\n        max_instances = self._call(\"getMaxInstancesOfStorageBus\",\n                     in_p=[chipset, bus])\n        return max_instances", "response": "Returns the maximum number of storage bus instances which can be configured for each VM."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_device_types_for_storage_bus(self, bus):\n        if not isinstance(bus, StorageBus):\n            raise TypeError(\"bus can only be an instance of type StorageBus\")\n        device_types = self._call(\"getDeviceTypesForStorageBus\",\n                     in_p=[bus])\n        device_types = [DeviceType(a) for a in device_types]\n        return device_types", "response": "Returns the list of all the supported device types for the given storage bus."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_default_io_cache_setting_for_storage_controller(self, controller_type):\n        if not isinstance(controller_type, StorageControllerType):\n            raise TypeError(\"controller_type can only be an instance of type StorageControllerType\")\n        enabled = self._call(\"getDefaultIoCacheSettingForStorageController\",\n                     in_p=[controller_type])\n        return enabled", "response": "Returns the default I/O cache setting for the given storage controller type."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns whether the given storage controller supports hot - plugging devices.", "response": "def get_storage_controller_hotplug_capable(self, controller_type):\n        \"\"\"Returns whether the given storage controller supports\n        hot-plugging devices.\n\n        in controller_type of type :class:`StorageControllerType`\n            The storage controller to check the setting for.\n\n        return hotplug_capable of type bool\n            Returned flag indicating whether the controller is hotplug capable\n\n        \"\"\"\n        if not isinstance(controller_type, StorageControllerType):\n            raise TypeError(\"controller_type can only be an instance of type StorageControllerType\")\n        hotplug_capable = self._call(\"getStorageControllerHotplugCapable\",\n                     in_p=[controller_type])\n        return hotplug_capable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the maximum number of USB controller instances which can be configured for each VM.", "response": "def get_max_instances_of_usb_controller_type(self, chipset, type_p):\n        \"\"\"Returns the maximum number of USB controller instances which\n        can be configured for each VM. This corresponds to the number of\n        USB controllers one can have. Value may depend on chipset type\n        used.\n\n        in chipset of type :class:`ChipsetType`\n            The chipset type to get the value for.\n\n        in type_p of type :class:`USBControllerType`\n            The USB controller type to get the value for.\n\n        return max_instances of type int\n            The maximum number of instances for the given USB controller type.\n\n        \"\"\"\n        if not isinstance(chipset, ChipsetType):\n            raise TypeError(\"chipset can only be an instance of type ChipsetType\")\n        if not isinstance(type_p, USBControllerType):\n            raise TypeError(\"type_p can only be an instance of type USBControllerType\")\n        max_instances = self._call(\"getMaxInstancesOfUSBControllerType\",\n                     in_p=[chipset, type_p])\n        return max_instances"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a specific drag - n drop MIME / Content - type format is supported.", "response": "def is_format_supported(self, format_p):\n        \"\"\"Checks if a specific drag'n drop MIME / Content-type format is supported.\n\n        in format_p of type str\n            Format to check for.\n\n        return supported of type bool\n            Returns @c true if the specified format is supported, @c false if not.\n\n        \"\"\"\n        if not isinstance(format_p, basestring):\n            raise TypeError(\"format_p can only be an instance of type basestring\")\n        supported = self._call(\"isFormatSupported\",\n                     in_p=[format_p])\n        return supported"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_formats(self, formats):\n        if not isinstance(formats, list):\n            raise TypeError(\"formats can only be an instance of type list\")\n        for a in formats[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"addFormats\",\n                     in_p=[formats])", "response": "Adds MIME / Content - type formats to the supported formats."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef drag_is_pending(self, screen_id):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        (default_action, formats, allowed_actions) = self._call(\"dragIsPending\",\n                     in_p=[screen_id])\n        default_action = DnDAction(default_action)\n        allowed_actions = [DnDAction(a) for a in allowed_actions]\n        return (default_action, formats, allowed_actions)", "response": "Ask the source if there is any drag and drop operation pending."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef drop(self, format_p, action):\n        if not isinstance(format_p, basestring):\n            raise TypeError(\"format_p can only be an instance of type basestring\")\n        if not isinstance(action, DnDAction):\n            raise TypeError(\"action can only be an instance of type DnDAction\")\n        progress = self._call(\"drop\",\n                     in_p=[format_p, action])\n        progress = IProgress(progress)\n        return progress", "response": "Informs the source that a drop event occurred for a pending drop operation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enter(self, screen_id, y, x, default_action, allowed_actions, formats):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(y, baseinteger):\n            raise TypeError(\"y can only be an instance of type baseinteger\")\n        if not isinstance(x, baseinteger):\n            raise TypeError(\"x can only be an instance of type baseinteger\")\n        if not isinstance(default_action, DnDAction):\n            raise TypeError(\"default_action can only be an instance of type DnDAction\")\n        if not isinstance(allowed_actions, list):\n            raise TypeError(\"allowed_actions can only be an instance of type list\")\n        for a in allowed_actions[:10]:\n            if not isinstance(a, DnDAction):\n                raise TypeError(\n                        \"array can only contain objects of type DnDAction\")\n        if not isinstance(formats, list):\n            raise TypeError(\"formats can only be an instance of type list\")\n        for a in formats[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        result_action = self._call(\"enter\",\n                     in_p=[screen_id, y, x, default_action, allowed_actions, formats])\n        result_action = DnDAction(result_action)\n        return result_action", "response": "Informs the target about a drag and drop enter event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef leave(self, screen_id):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        self._call(\"leave\",\n                     in_p=[screen_id])", "response": "Informs the target about a drag and drop leave event."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_data(self, screen_id, format_p, data):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(format_p, basestring):\n            raise TypeError(\"format_p can only be an instance of type basestring\")\n        if not isinstance(data, list):\n            raise TypeError(\"data can only be an instance of type list\")\n        for a in data[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        progress = self._call(\"sendData\",\n                     in_p=[screen_id, format_p, data])\n        progress = IProgress(progress)\n        return progress", "response": "Sends data to the target."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies directories and files from guest to host.", "response": "def copy_from_guest(self, sources, filters, flags, destination):\n        \"\"\"Copies directories and/or files from guest to the host.\n        \n        This function requires several parallel arrays to be supplied, one\n        set for each source.\n\n        in sources of type str\n            Paths to directories and/or files on the guest side that should be\n            copied to the host. If the path ends with a path delimiter, only\n            the directory's content is being copied. Guest path style.\n\n        in filters of type str\n            Array of source filters. This uses the\n            DOS/NT style wildcard characters '?' and '*'.\n\n        in flags of type str\n            Array of comma-separated list of source flags.\n            \n            The following flags are available for directory sources:\n            \n            \n            \n            CopyIntoExisting\n            Allow copying into an existing destination directory.\n            \n            \n            \n            The following flags are available for file sources:\n            \n            \n            \n            NoReplace\n            Do not replace any destination object.\n            \n            \n            FollowLinks\n            Follows (and handles) (symbolic) links.\n            \n            \n            Update\n            Only copy when the source file is newer than the destination\n            file or when the destination file is missing.\n\n        in destination of type str\n            Where to put the sources on the host. Host path style.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation to completion.\n\n        \"\"\"\n        if not isinstance(sources, list):\n            raise TypeError(\"sources can only be an instance of type list\")\n        for a in sources[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(filters, list):\n            raise TypeError(\"filters can only be an instance of type list\")\n        for a in filters[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(destination, basestring):\n            raise TypeError(\"destination can only be an instance of type basestring\")\n        progress = self._call(\"copyFromGuest\",\n                     in_p=[sources, filters, flags, destination])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef directory_create(self, path, mode, flags):\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(mode, baseinteger):\n            raise TypeError(\"mode can only be an instance of type baseinteger\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, DirectoryCreateFlag):\n                raise TypeError(\n                        \"array can only contain objects of type DirectoryCreateFlag\")\n        self._call(\"directoryCreate\",\n                     in_p=[path, mode, flags])", "response": "Creates a directory in the guest."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef directory_create_temp(self, template_name, mode, path, secure):\n        if not isinstance(template_name, basestring):\n            raise TypeError(\"template_name can only be an instance of type basestring\")\n        if not isinstance(mode, baseinteger):\n            raise TypeError(\"mode can only be an instance of type baseinteger\")\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(secure, bool):\n            raise TypeError(\"secure can only be an instance of type bool\")\n        directory = self._call(\"directoryCreateTemp\",\n                     in_p=[template_name, mode, path, secure])\n        return directory", "response": "Creates a temporary directory in the guest."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef directory_open(self, path, filter_p, flags):\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(filter_p, basestring):\n            raise TypeError(\"filter_p can only be an instance of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, DirectoryOpenFlag):\n                raise TypeError(\n                        \"array can only contain objects of type DirectoryOpenFlag\")\n        directory = self._call(\"directoryOpen\",\n                     in_p=[path, filter_p, flags])\n        directory = IGuestDirectory(directory)\n        return directory", "response": "Opens a directory in the guest and creates a IGuestDirectory object that can be used for further operations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef directory_remove(self, path):\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        self._call(\"directoryRemove\",\n                     in_p=[path])", "response": "Removes a guest directory from the guest path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a guest directory recursively.", "response": "def directory_remove_recursive(self, path, flags):\n        \"\"\"Removes a guest directory recursively.\n        \n        <!--  Add this back when the warning can be removed:\n        Unless :py:attr:`DirectoryRemoveRecFlag.content_and_dir`  or\n        :py:attr:`DirectoryRemoveRecFlag.content_only`  is given, only the\n        directory structure is removed.  Which means it will fail if there are\n        directories which are not empty in the directory tree @a path points to.\n        -->\n        \n        WARNING!! THE FLAGS ARE NOT CURRENTLY IMPLEMENTED.  THE IMPLEMENTATION\n        WORKS AS IF FLAGS WAS SET TO :py:attr:`DirectoryRemoveRecFlag.content_and_dir` .\n        \n        \n        If the final path component is a symbolic link, this method will\n        fail as it can only be applied to directories.\n\n        in path of type str\n            Path of the directory that is to be removed recursively. Guest\n            path style.\n\n        in flags of type :class:`DirectoryRemoveRecFlag`\n            Zero or more :py:class:`DirectoryRemoveRecFlag`  flags.\n            WARNING! SPECIFYING :py:attr:`DirectoryRemoveRecFlag.content_and_dir`  IS\n            MANDATORY AT THE MOMENT!!\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion. This is not implemented\n            yet and therefore this method call will block until deletion is completed.\n\n        \"\"\"\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, DirectoryRemoveRecFlag):\n                raise TypeError(\n                        \"array can only contain objects of type DirectoryRemoveRecFlag\")\n        progress = self._call(\"directoryRemoveRecursive\",\n                     in_p=[path, flags])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves an environment variable when creating the next guest process.", "response": "def environment_schedule_unset(self, name):\n        \"\"\"Schedules unsetting (removing) an environment variable when creating\n        the next guest process.  This affects the\n        :py:func:`IGuestSession.environment_changes`  attribute.\n\n        in name of type str\n            Name of the environment variable to unset.  This cannot be empty\n            nor can it contain any equal signs.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        self._call(\"environmentScheduleUnset\",\n                     in_p=[name])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef environment_does_base_variable_exist(self, name):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        exists = self._call(\"environmentDoesBaseVariableExist\",\n                     in_p=[name])\n        return exists", "response": "Checks if the given environment variable exists in the session base environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef file_copy(self, source, destination, flags):\n        if not isinstance(source, basestring):\n            raise TypeError(\"source can only be an instance of type basestring\")\n        if not isinstance(destination, basestring):\n            raise TypeError(\"destination can only be an instance of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, FileCopyFlag):\n                raise TypeError(\n                        \"array can only contain objects of type FileCopyFlag\")\n        progress = self._call(\"fileCopy\",\n                     in_p=[source, destination, flags])\n        progress = IProgress(progress)\n        return progress", "response": "Copies a file from one guest location to another."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a temporary file in the guest.", "response": "def file_create_temp(self, template_name, mode, path, secure):\n        \"\"\"Creates a temporary file in the guest.\n\n        in template_name of type str\n            Template for the name of the file to create. This must contain\n            at least one 'X' character. The first group of consecutive 'X'\n            characters in the template will be replaced by a random\n            alphanumeric string to produce a unique name.\n\n        in mode of type int\n            The UNIX-style access mode mask to create the file with.\n            Whether/how all three access groups and associated access rights are\n            realized is guest OS dependent.  The API does the best it can on each\n            OS.\n            \n            This parameter is ignore if the @a secure parameter is set to @c true.\n            It is strongly recommended to use 0600.\n\n        in path of type str\n            The path to the directory in which the temporary file should be\n            created.\n\n        in secure of type bool\n            Whether to fail if the file can not be securely created.\n            Currently this means that another unprivileged user cannot\n            manipulate the path specified or remove the temporary file after\n            it has been created. Also causes the mode specified to be ignored.\n            May not be supported on all guest types.\n\n        return file_p of type :class:`IGuestFile`\n            On success this will contain an open file object for the new\n            temporary file.\n\n        raises :class:`VBoxErrorNotSupported`\n            The operation is not possible as requested on this particular\nguest OS.\n        \n        raises :class:`OleErrorInvalidarg`\n            Invalid argument. This includes an incorrectly formatted template,\nor a non-absolute path.\n        \n        raises :class:`VBoxErrorIprtError`\n            The temporary file could not be created. Possible reasons include\na non-existing path or an insecure path when the secure\noption was requested.\n        \n        \"\"\"\n        if not isinstance(template_name, basestring):\n            raise TypeError(\"template_name can only be an instance of type basestring\")\n        if not isinstance(mode, baseinteger):\n            raise TypeError(\"mode can only be an instance of type baseinteger\")\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(secure, bool):\n            raise TypeError(\"secure can only be an instance of type bool\")\n        file_p = self._call(\"fileCreateTemp\",\n                     in_p=[template_name, mode, path, secure])\n        file_p = IGuestFile(file_p)\n        return file_p"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef file_open(self, path, access_mode, open_action, creation_mode):\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(access_mode, FileAccessMode):\n            raise TypeError(\"access_mode can only be an instance of type FileAccessMode\")\n        if not isinstance(open_action, FileOpenAction):\n            raise TypeError(\"open_action can only be an instance of type FileOpenAction\")\n        if not isinstance(creation_mode, baseinteger):\n            raise TypeError(\"creation_mode can only be an instance of type baseinteger\")\n        file_p = self._call(\"fileOpen\",\n                     in_p=[path, access_mode, open_action, creation_mode])\n        file_p = IGuestFile(file_p)\n        return file_p", "response": "Opens a file and creates a new file with the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nopens a file and creates a file_p object that represents the file.", "response": "def file_open_ex(self, path, access_mode, open_action, sharing_mode, creation_mode, flags):\n        \"\"\"Opens a file and creates a :py:class:`IGuestFile`  object that\n        can be used for further operations, extended version.\n\n        in path of type str\n            Path to file to open.  Guest path style.\n\n        in access_mode of type :class:`FileAccessMode`\n            The file access mode (read, write and/or append).\n            See :py:class:`FileAccessMode`  for details.\n\n        in open_action of type :class:`FileOpenAction`\n            What action to take depending on whether the file exists or not.\n            See :py:class:`FileOpenAction`  for details.\n\n        in sharing_mode of type :class:`FileSharingMode`\n            The file sharing mode in the guest. This parameter is currently\n            ignore for all guest OSes.  It will in the future be implemented for\n            Windows, OS/2 and maybe Solaris guests only, the others will ignore it.\n            Use :py:attr:`FileSharingMode.all_p` .\n\n        in creation_mode of type int\n            The UNIX-style access mode mask to create the file with if @a openAction\n            requested the file to be created (otherwise ignored).  Whether/how all\n            three access groups and associated access rights are realized is guest\n            OS dependent.  The API does the best it can on each OS.\n\n        in flags of type :class:`FileOpenExFlag`\n            Zero or more :py:class:`FileOpenExFlag`  values.\n\n        return file_p of type :class:`IGuestFile`\n            :py:class:`IGuestFile`  object representing the opened file.\n\n        raises :class:`VBoxErrorObjectNotFound`\n            File to open was not found.\n        \n        raises :class:`VBoxErrorIprtError`\n            Error while opening the file.\n        \n        \"\"\"\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(access_mode, FileAccessMode):\n            raise TypeError(\"access_mode can only be an instance of type FileAccessMode\")\n        if not isinstance(open_action, FileOpenAction):\n            raise TypeError(\"open_action can only be an instance of type FileOpenAction\")\n        if not isinstance(sharing_mode, FileSharingMode):\n            raise TypeError(\"sharing_mode can only be an instance of type FileSharingMode\")\n        if not isinstance(creation_mode, baseinteger):\n            raise TypeError(\"creation_mode can only be an instance of type baseinteger\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, FileOpenExFlag):\n                raise TypeError(\n                        \"array can only contain objects of type FileOpenExFlag\")\n        file_p = self._call(\"fileOpenEx\",\n                     in_p=[path, access_mode, open_action, sharing_mode, creation_mode, flags])\n        file_p = IGuestFile(file_p)\n        return file_p"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nqueries the size of a regular file in the guest.", "response": "def file_query_size(self, path, follow_symlinks):\n        \"\"\"Queries the size of a regular file in the guest.\n\n        in path of type str\n            Path to the file which size is requested.  Guest path style.\n\n        in follow_symlinks of type bool\n            It @c true, symbolic links in the final path component will be\n            followed to their target, and the size of the target is returned.\n            If @c false, symbolic links in the final path component will make\n            the method call fail (symblink is not a regular file).\n\n        return size of type int\n            Queried file size.\n\n        raises :class:`VBoxErrorObjectNotFound`\n            File to was not found.\n        \n        raises :class:`VBoxErrorIprtError`\n            Error querying file size.\n        \n        \"\"\"\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(follow_symlinks, bool):\n            raise TypeError(\"follow_symlinks can only be an instance of type bool\")\n        size = self._call(\"fileQuerySize\",\n                     in_p=[path, follow_symlinks])\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fs_obj_exists(self, path, follow_symlinks):\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(follow_symlinks, bool):\n            raise TypeError(\"follow_symlinks can only be an instance of type bool\")\n        exists = self._call(\"fsObjExists\",\n                     in_p=[path, follow_symlinks])\n        return exists", "response": "Checks whether a file system object exists in the guest or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fs_obj_query_info(self, path, follow_symlinks):\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(follow_symlinks, bool):\n            raise TypeError(\"follow_symlinks can only be an instance of type bool\")\n        info = self._call(\"fsObjQueryInfo\",\n                     in_p=[path, follow_symlinks])\n        info = IGuestFsObjInfo(info)\n        return info", "response": "Queries information about a file system object in the guest."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a file system object in the guest.", "response": "def fs_obj_remove(self, path):\n        \"\"\"Removes a file system object (file, symlink, etc) in the guest.  Will\n        not work on directories, use :py:func:`IGuestSession.directory_remove` \n        to remove directories.\n        \n        This method will remove symbolic links in the final path\n        component, not follow them.\n\n        in path of type str\n            Path to the file system object to remove.  Guest style path.\n\n        raises :class:`OleErrorNotimpl`\n            The method has not been implemented yet.\n        \n        raises :class:`VBoxErrorObjectNotFound`\n            The file system object was not found.\n        \n        raises :class:`VBoxErrorIprtError`\n            For most other errors. We know this is unhelpful, will fix shortly...\n        \n        \"\"\"\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        self._call(\"fsObjRemove\",\n                     in_p=[path])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fs_obj_remove_array(self, path):\n        if not isinstance(path, list):\n            raise TypeError(\"path can only be an instance of type list\")\n        for a in path[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        progress = self._call(\"fsObjRemoveArray\",\n                     in_p=[path])\n        progress = IProgress(progress)\n        return progress", "response": "Removes multiple file system objects in the guest."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fs_obj_rename(self, old_path, new_path, flags):\n        if not isinstance(old_path, basestring):\n            raise TypeError(\"old_path can only be an instance of type basestring\")\n        if not isinstance(new_path, basestring):\n            raise TypeError(\"new_path can only be an instance of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, FsObjRenameFlag):\n                raise TypeError(\n                        \"array can only contain objects of type FsObjRenameFlag\")\n        self._call(\"fsObjRename\",\n                     in_p=[old_path, new_path, flags])", "response": "Renames a file system object in the current path to the new path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fs_obj_move(self, source, destination, flags):\n        if not isinstance(source, basestring):\n            raise TypeError(\"source can only be an instance of type basestring\")\n        if not isinstance(destination, basestring):\n            raise TypeError(\"destination can only be an instance of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, FsObjMoveFlag):\n                raise TypeError(\n                        \"array can only contain objects of type FsObjMoveFlag\")\n        progress = self._call(\"fsObjMove\",\n                     in_p=[source, destination, flags])\n        progress = IProgress(progress)\n        return progress", "response": "Moves a file system object from one guest location to another."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the access control list of a file system object.", "response": "def fs_obj_set_acl(self, path, follow_symlinks, acl, mode):\n        \"\"\"Sets the access control list (ACL) of a file system object (file,\n        directory, etc) in the guest.\n\n        in path of type str\n            Full path of the file system object which ACL to set\n\n        in follow_symlinks of type bool\n            If @c true symbolic links in the final component will be followed,\n            otherwise, if @c false, the method will work directly on a symbolic\n            link in the final component.\n\n        in acl of type str\n            The ACL specification string. To-be-defined.\n\n        in mode of type int\n            UNIX-style mode mask to use if @a acl is empty. As mention in\n            :py:func:`IGuestSession.directory_create`  this is realized on\n            a best effort basis and the exact behavior depends on the Guest OS.\n\n        raises :class:`OleErrorNotimpl`\n            The method is not implemented yet.\n        \n        \"\"\"\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        if not isinstance(follow_symlinks, bool):\n            raise TypeError(\"follow_symlinks can only be an instance of type bool\")\n        if not isinstance(acl, basestring):\n            raise TypeError(\"acl can only be an instance of type basestring\")\n        if not isinstance(mode, baseinteger):\n            raise TypeError(\"mode can only be an instance of type baseinteger\")\n        self._call(\"fsObjSetACL\",\n                     in_p=[path, follow_symlinks, acl, mode])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_create(self, executable, arguments, environment_changes, flags, timeout_ms):\n        if not isinstance(executable, basestring):\n            raise TypeError(\"executable can only be an instance of type basestring\")\n        if not isinstance(arguments, list):\n            raise TypeError(\"arguments can only be an instance of type list\")\n        for a in arguments[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(environment_changes, list):\n            raise TypeError(\"environment_changes can only be an instance of type list\")\n        for a in environment_changes[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, ProcessCreateFlag):\n                raise TypeError(\n                        \"array can only contain objects of type ProcessCreateFlag\")\n        if not isinstance(timeout_ms, baseinteger):\n            raise TypeError(\"timeout_ms can only be an instance of type baseinteger\")\n        guest_process = self._call(\"processCreate\",\n                     in_p=[executable, arguments, environment_changes, flags, timeout_ms])\n        guest_process = IGuestProcess(guest_process)\n        return guest_process", "response": "This function creates a new process running in the guest."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_create_ex(self, executable, arguments, environment_changes, flags, timeout_ms, priority, affinity):\n        if not isinstance(executable, basestring):\n            raise TypeError(\"executable can only be an instance of type basestring\")\n        if not isinstance(arguments, list):\n            raise TypeError(\"arguments can only be an instance of type list\")\n        for a in arguments[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(environment_changes, list):\n            raise TypeError(\"environment_changes can only be an instance of type list\")\n        for a in environment_changes[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, ProcessCreateFlag):\n                raise TypeError(\n                        \"array can only contain objects of type ProcessCreateFlag\")\n        if not isinstance(timeout_ms, baseinteger):\n            raise TypeError(\"timeout_ms can only be an instance of type baseinteger\")\n        if not isinstance(priority, ProcessPriority):\n            raise TypeError(\"priority can only be an instance of type ProcessPriority\")\n        if not isinstance(affinity, list):\n            raise TypeError(\"affinity can only be an instance of type list\")\n        for a in affinity[:10]:\n            if not isinstance(a, baseinteger):\n                raise TypeError(\n                        \"array can only contain objects of type baseinteger\")\n        guest_process = self._call(\"processCreateEx\",\n                     in_p=[executable, arguments, environment_changes, flags, timeout_ms, priority, affinity])\n        guest_process = IGuestProcess(guest_process)\n        return guest_process", "response": "This method creates a new process running in the guest with the extended options in the options of the guest."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_get(self, pid):\n        if not isinstance(pid, baseinteger):\n            raise TypeError(\"pid can only be an instance of type baseinteger\")\n        guest_process = self._call(\"processGet\",\n                     in_p=[pid])\n        guest_process = IGuestProcess(guest_process)\n        return guest_process", "response": "Gets a certain guest process by its process ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef symlink_create(self, symlink, target, type_p):\n        if not isinstance(symlink, basestring):\n            raise TypeError(\"symlink can only be an instance of type basestring\")\n        if not isinstance(target, basestring):\n            raise TypeError(\"target can only be an instance of type basestring\")\n        if not isinstance(type_p, SymlinkType):\n            raise TypeError(\"type_p can only be an instance of type SymlinkType\")\n        self._call(\"symlinkCreate\",\n                     in_p=[symlink, target, type_p])", "response": "Creates a symbolic link in the guest."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking whether a symbolic link exists in the guest.", "response": "def symlink_exists(self, symlink):\n        \"\"\"Checks whether a symbolic link exists in the guest.\n\n        in symlink of type str\n            Path to the alleged symbolic link.  Guest path style.\n\n        return exists of type bool\n            Returns @c true if the symbolic link exists.  Returns @c false if it\n            does not exist, if the file system object identified by the path is\n            not a symbolic link, or if the object type is inaccessible to the\n            user, or if the @a symlink argument is empty.\n\n        raises :class:`OleErrorNotimpl`\n            The method is not implemented yet.\n        \n        \"\"\"\n        if not isinstance(symlink, basestring):\n            raise TypeError(\"symlink can only be an instance of type basestring\")\n        exists = self._call(\"symlinkExists\",\n                     in_p=[symlink])\n        return exists"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef symlink_read(self, symlink, flags):\n        if not isinstance(symlink, basestring):\n            raise TypeError(\"symlink can only be an instance of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, SymlinkReadFlag):\n                raise TypeError(\n                        \"array can only contain objects of type SymlinkReadFlag\")\n        target = self._call(\"symlinkRead\",\n                     in_p=[symlink, flags])\n        return target", "response": "Reads the target value of a symbolic link in the guest."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwait for one or more events to happen.", "response": "def wait_for_array(self, wait_for, timeout_ms):\n        \"\"\"Waits for one or more events to happen.\n        Scriptable version of :py:func:`wait_for` .\n\n        in wait_for of type :class:`GuestSessionWaitForFlag`\n            Specifies what to wait for;\n            see :py:class:`GuestSessionWaitForFlag`  for more information.\n\n        in timeout_ms of type int\n            Timeout (in ms) to wait for the operation to complete.\n            Pass 0 for an infinite timeout.\n\n        return reason of type :class:`GuestSessionWaitResult`\n            The overall wait result;\n            see :py:class:`GuestSessionWaitResult`  for more information.\n\n        \"\"\"\n        if not isinstance(wait_for, list):\n            raise TypeError(\"wait_for can only be an instance of type list\")\n        for a in wait_for[:10]:\n            if not isinstance(a, GuestSessionWaitForFlag):\n                raise TypeError(\n                        \"array can only contain objects of type GuestSessionWaitForFlag\")\n        if not isinstance(timeout_ms, baseinteger):\n            raise TypeError(\"timeout_ms can only be an instance of type baseinteger\")\n        reason = self._call(\"waitForArray\",\n                     in_p=[wait_for, timeout_ms])\n        reason = GuestSessionWaitResult(reason)\n        return reason"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_for(self, wait_for, timeout_ms):\n        if not isinstance(wait_for, baseinteger):\n            raise TypeError(\"wait_for can only be an instance of type baseinteger\")\n        if not isinstance(timeout_ms, baseinteger):\n            raise TypeError(\"timeout_ms can only be an instance of type baseinteger\")\n        reason = self._call(\"waitFor\",\n                     in_p=[wait_for, timeout_ms])\n        reason = ProcessWaitResult(reason)\n        return reason", "response": "Waits for one or more events to happen."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_for_array(self, wait_for, timeout_ms):\n        if not isinstance(wait_for, list):\n            raise TypeError(\"wait_for can only be an instance of type list\")\n        for a in wait_for[:10]:\n            if not isinstance(a, ProcessWaitForFlag):\n                raise TypeError(\n                        \"array can only contain objects of type ProcessWaitForFlag\")\n        if not isinstance(timeout_ms, baseinteger):\n            raise TypeError(\"timeout_ms can only be an instance of type baseinteger\")\n        reason = self._call(\"waitForArray\",\n                     in_p=[wait_for, timeout_ms])\n        reason = ProcessWaitResult(reason)\n        return reason", "response": "Waits for one or more events to happen."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite data to a running process.", "response": "def write(self, handle, flags, data, timeout_ms):\n        \"\"\"Writes data to a running process.\n\n        in handle of type int\n            Handle to write to. Usually 0 is stdin, 1 is stdout and 2 is stderr.\n\n        in flags of type int\n            A combination of :py:class:`ProcessInputFlag`  flags.\n\n        in data of type str\n            Array of bytes to write. The size of the array also specifies\n            how much to write.\n\n        in timeout_ms of type int\n            Timeout (in ms) to wait for the operation to complete.\n            Pass 0 for an infinite timeout.\n\n        return written of type int\n            How many bytes were written.\n\n        \"\"\"\n        if not isinstance(handle, baseinteger):\n            raise TypeError(\"handle can only be an instance of type baseinteger\")\n        if not isinstance(flags, baseinteger):\n            raise TypeError(\"flags can only be an instance of type baseinteger\")\n        if not isinstance(data, list):\n            raise TypeError(\"data can only be an instance of type list\")\n        for a in data[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(timeout_ms, baseinteger):\n            raise TypeError(\"timeout_ms can only be an instance of type baseinteger\")\n        written = self._call(\"write\",\n                     in_p=[handle, flags, data, timeout_ms])\n        return written"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self, to_read, timeout_ms):\n        if not isinstance(to_read, baseinteger):\n            raise TypeError(\"to_read can only be an instance of type baseinteger\")\n        if not isinstance(timeout_ms, baseinteger):\n            raise TypeError(\"timeout_ms can only be an instance of type baseinteger\")\n        data = self._call(\"read\",\n                     in_p=[to_read, timeout_ms])\n        return data", "response": "Reads data from this file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading data from an offset of this file.", "response": "def read_at(self, offset, to_read, timeout_ms):\n        \"\"\"Reads data from an offset of this file.\n\n        in offset of type int\n            Offset in bytes to start reading.\n\n        in to_read of type int\n            Number of bytes to read.\n\n        in timeout_ms of type int\n            Timeout (in ms) to wait for the operation to complete.\n            Pass 0 for an infinite timeout.\n\n        return data of type str\n            Array of data read.\n\n        raises :class:`OleErrorNotimpl`\n            The method is not implemented yet.\n        \n        \"\"\"\n        if not isinstance(offset, baseinteger):\n            raise TypeError(\"offset can only be an instance of type baseinteger\")\n        if not isinstance(to_read, baseinteger):\n            raise TypeError(\"to_read can only be an instance of type baseinteger\")\n        if not isinstance(timeout_ms, baseinteger):\n            raise TypeError(\"timeout_ms can only be an instance of type baseinteger\")\n        data = self._call(\"readAt\",\n                     in_p=[offset, to_read, timeout_ms])\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef seek(self, offset, whence):\n        if not isinstance(offset, baseinteger):\n            raise TypeError(\"offset can only be an instance of type baseinteger\")\n        if not isinstance(whence, FileSeekOrigin):\n            raise TypeError(\"whence can only be an instance of type FileSeekOrigin\")\n        new_offset = self._call(\"seek\",\n                     in_p=[offset, whence])\n        return new_offset", "response": "Changes the current file position of this file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_acl(self, acl, mode):\n        if not isinstance(acl, basestring):\n            raise TypeError(\"acl can only be an instance of type basestring\")\n        if not isinstance(mode, baseinteger):\n            raise TypeError(\"mode can only be an instance of type baseinteger\")\n        self._call(\"setACL\",\n                     in_p=[acl, mode])", "response": "Sets the ACL of this file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nchange the size of the current file.", "response": "def set_size(self, size):\n        \"\"\"Changes the file size.\n\n        in size of type int\n            The new file size.\n\n        raises :class:`OleErrorNotimpl`\n            The method is not implemented yet.\n        \n        \"\"\"\n        if not isinstance(size, baseinteger):\n            raise TypeError(\"size can only be an instance of type baseinteger\")\n        self._call(\"setSize\",\n                     in_p=[size])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the current status of a Guest Additions facility.", "response": "def get_facility_status(self, facility):\n        \"\"\"Get the current status of a Guest Additions facility.\n\n        in facility of type :class:`AdditionsFacilityType`\n            Facility to check status for.\n\n        out timestamp of type int\n            Timestamp (in ms) of last status update seen by the host.\n\n        return status of type :class:`AdditionsFacilityStatus`\n            The current (latest) facility status.\n\n        \"\"\"\n        if not isinstance(facility, AdditionsFacilityType):\n            raise TypeError(\"facility can only be an instance of type AdditionsFacilityType\")\n        (status, timestamp) = self._call(\"getFacilityStatus\",\n                     in_p=[facility])\n        status = AdditionsFacilityStatus(status)\n        return (status, timestamp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the current status of a certain Guest Additions run level.", "response": "def get_additions_status(self, level):\n        \"\"\"Retrieve the current status of a certain Guest Additions run level.\n\n        in level of type :class:`AdditionsRunLevelType`\n            Status level to check\n\n        return active of type bool\n            Flag whether the status level has been reached or not\n\n        raises :class:`VBoxErrorNotSupported`\n            Wrong status level specified.\n        \n        \"\"\"\n        if not isinstance(level, AdditionsRunLevelType):\n            raise TypeError(\"level can only be an instance of type AdditionsRunLevelType\")\n        active = self._call(\"getAdditionsStatus\",\n                     in_p=[level])\n        return active"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the login credentials for the guest operating system.", "response": "def set_credentials(self, user_name, password, domain, allow_interactive_logon):\n        \"\"\"Store login credentials that can be queried by guest operating\n        systems with Additions installed. The credentials are transient\n        to the session and the guest may also choose to erase them. Note\n        that the caller cannot determine whether the guest operating system\n        has queried or made use of the credentials.\n\n        in user_name of type str\n            User name string, can be empty\n\n        in password of type str\n            Password string, can be empty\n\n        in domain of type str\n            Domain name (guest logon scheme specific), can be empty\n\n        in allow_interactive_logon of type bool\n            Flag whether the guest should alternatively allow the user to\n            interactively specify different credentials. This flag might\n            not be supported by all versions of the Additions.\n\n        raises :class:`VBoxErrorVmError`\n            VMM device is not available.\n        \n        \"\"\"\n        if not isinstance(user_name, basestring):\n            raise TypeError(\"user_name can only be an instance of type basestring\")\n        if not isinstance(password, basestring):\n            raise TypeError(\"password can only be an instance of type basestring\")\n        if not isinstance(domain, basestring):\n            raise TypeError(\"domain can only be an instance of type basestring\")\n        if not isinstance(allow_interactive_logon, bool):\n            raise TypeError(\"allow_interactive_logon can only be an instance of type bool\")\n        self._call(\"setCredentials\",\n                     in_p=[user_name, password, domain, allow_interactive_logon])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_session(self, user, password, domain, session_name):\n        if not isinstance(user, basestring):\n            raise TypeError(\"user can only be an instance of type basestring\")\n        if not isinstance(password, basestring):\n            raise TypeError(\"password can only be an instance of type basestring\")\n        if not isinstance(domain, basestring):\n            raise TypeError(\"domain can only be an instance of type basestring\")\n        if not isinstance(session_name, basestring):\n            raise TypeError(\"session_name can only be an instance of type basestring\")\n        guest_session = self._call(\"createSession\",\n                     in_p=[user, password, domain, session_name])\n        guest_session = IGuestSession(guest_session)\n        return guest_session", "response": "Creates a new guest session for controlling the guest."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_session(self, session_name):\n        if not isinstance(session_name, basestring):\n            raise TypeError(\"session_name can only be an instance of type basestring\")\n        sessions = self._call(\"findSession\",\n                     in_p=[session_name])\n        sessions = [IGuestSession(a) for a in sessions]\n        return sessions", "response": "Finds guest sessions by their friendly name and returns an interface\n        array with all found guest sessions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_guest_additions(self, source, arguments, flags):\n        if not isinstance(source, basestring):\n            raise TypeError(\"source can only be an instance of type basestring\")\n        if not isinstance(arguments, list):\n            raise TypeError(\"arguments can only be an instance of type list\")\n        for a in arguments[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(flags, list):\n            raise TypeError(\"flags can only be an instance of type list\")\n        for a in flags[:10]:\n            if not isinstance(a, AdditionsUpdateFlag):\n                raise TypeError(\n                        \"array can only contain objects of type AdditionsUpdateFlag\")\n        progress = self._call(\"updateGuestAdditions\",\n                     in_p=[source, arguments, flags])\n        progress = IProgress(progress)\n        return progress", "response": "Updates the Guest Additions in a VM."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwaits until the task is done and returns the result of the calling task.", "response": "def wait_for_completion(self, timeout):\n        \"\"\"Waits until the task is done (including all sub-operations)\n        with a given timeout in milliseconds; specify -1 for an indefinite wait.\n        \n        Note that the VirtualBox/XPCOM/COM/native event queues of the calling\n        thread are not processed while waiting. Neglecting event queues may\n        have dire consequences (degrade performance, resource hogs,\n        deadlocks, etc.), this is specially so for the main thread on\n        platforms using XPCOM. Callers are advised wait for short periods\n        and service their event queues between calls, or to create a worker\n        thread to do the waiting.\n\n        in timeout of type int\n            Maximum time in milliseconds to wait or -1 to wait indefinitely.\n\n        raises :class:`VBoxErrorIprtError`\n            Failed to wait for task completion.\n        \n        \"\"\"\n        if not isinstance(timeout, baseinteger):\n            raise TypeError(\"timeout can only be an instance of type baseinteger\")\n        self._call(\"waitForCompletion\",\n                     in_p=[timeout])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwait until the given operation is done with a given timeout in milliseconds.", "response": "def wait_for_operation_completion(self, operation, timeout):\n        \"\"\"Waits until the given operation is done with a given timeout in\n        milliseconds; specify -1 for an indefinite wait.\n        \n        See :py:func:`wait_for_completion` for event queue considerations.\n\n        in operation of type int\n            Number of the operation to wait for.\n            Must be less than :py:func:`operation_count` .\n\n        in timeout of type int\n            Maximum time in milliseconds to wait or -1 to wait indefinitely.\n\n        raises :class:`VBoxErrorIprtError`\n            Failed to wait for operation completion.\n        \n        \"\"\"\n        if not isinstance(operation, baseinteger):\n            raise TypeError(\"operation can only be an instance of type baseinteger\")\n        if not isinstance(timeout, baseinteger):\n            raise TypeError(\"timeout can only be an instance of type baseinteger\")\n        self._call(\"waitForOperationCompletion\",\n                     in_p=[operation, timeout])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the current operation progress.", "response": "def set_current_operation_progress(self, percent):\n        \"\"\"Internal method, not to be called externally.\n\n        in percent of type int\n\n        \"\"\"\n        if not isinstance(percent, baseinteger):\n            raise TypeError(\"percent can only be an instance of type baseinteger\")\n        self._call(\"setCurrentOperationProgress\",\n                     in_p=[percent])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_next_operation(self, next_operation_description, next_operations_weight):\n        if not isinstance(next_operation_description, basestring):\n            raise TypeError(\"next_operation_description can only be an instance of type basestring\")\n        if not isinstance(next_operations_weight, baseinteger):\n            raise TypeError(\"next_operations_weight can only be an instance of type baseinteger\")\n        self._call(\"setNextOperation\",\n                     in_p=[next_operation_description, next_operations_weight])", "response": "Sets the next operation for the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef notify_complete(self, result_code, error_info):\n        if not isinstance(result_code, baseinteger):\n            raise TypeError(\"result_code can only be an instance of type baseinteger\")\n        if not isinstance(error_info, IVirtualBoxErrorInfo):\n            raise TypeError(\"error_info can only be an instance of type IVirtualBoxErrorInfo\")\n        self._call(\"notifyComplete\",\n                     in_p=[result_code, error_info])", "response": "Notify that the process has completed processing the current operation."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_ids(self, set_image_id, image_id, set_parent_id, parent_id):\n        if not isinstance(set_image_id, bool):\n            raise TypeError(\"set_image_id can only be an instance of type bool\")\n        if not isinstance(image_id, basestring):\n            raise TypeError(\"image_id can only be an instance of type basestring\")\n        if not isinstance(set_parent_id, bool):\n            raise TypeError(\"set_parent_id can only be an instance of type bool\")\n        if not isinstance(parent_id, basestring):\n            raise TypeError(\"parent_id can only be an instance of type basestring\")\n        self._call(\"setIds\",\n                     in_p=[set_image_id, image_id, set_parent_id, parent_id])", "response": "Changes the UUID and parent UUID for a hard disk medium."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an array of UUIDs of all snapshots of the given machine using this medium.", "response": "def get_snapshot_ids(self, machine_id):\n        \"\"\"Returns an array of UUIDs of all snapshots of the given machine where\n        this medium is attached to.\n        \n        If the medium is attached to the machine in the current state, then the\n        first element in the array will always be the ID of the queried machine\n        (i.e. the value equal to the @c machineId argument), followed by\n        snapshot IDs (if any).\n        \n        If the medium is not attached to the machine in the current state, then\n        the array will contain only snapshot IDs.\n        \n        The returned array may be @c null if this medium is not attached\n        to the given machine at all, neither in the current state nor in one of\n        the snapshots.\n\n        in machine_id of type str\n            UUID of the machine to query.\n\n        return snapshot_ids of type str\n            Array of snapshot UUIDs of the given machine using this medium.\n\n        \"\"\"\n        if not isinstance(machine_id, basestring):\n            raise TypeError(\"machine_id can only be an instance of type basestring\")\n        snapshot_ids = self._call(\"getSnapshotIds\",\n                     in_p=[machine_id])\n        return snapshot_ids"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_property(self, name):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        value = self._call(\"getProperty\",\n                     in_p=[name])\n        return value", "response": "Returns the value of the custom medium property with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value of the given custom medium property with the given name.", "response": "def set_property(self, name, value):\n        \"\"\"Sets the value of the custom medium property with the given name.\n        \n        The list of all properties supported by the given medium format can\n        be obtained with :py:func:`IMediumFormat.describe_properties` .\n        \n        Setting the property value to @c null or an empty string is\n        equivalent to deleting the existing value. A default value (if it is\n        defined for this property) will be used by the format backend in this\n        case.\n\n        in name of type str\n            Name of the property to set.\n\n        in value of type str\n            Property value to set.\n\n        raises :class:`VBoxErrorObjectNotFound`\n            Requested property does not exist (not supported by the format).\n        \n        raises :class:`OleErrorInvalidarg`\n            @a name is @c null or empty.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(value, basestring):\n            raise TypeError(\"value can only be an instance of type basestring\")\n        self._call(\"setProperty\",\n                     in_p=[name, value])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_properties(self, names):\n        if not isinstance(names, basestring):\n            raise TypeError(\"names can only be an instance of type basestring\")\n        (return_values, return_names) = self._call(\"getProperties\",\n                     in_p=[names])\n        return (return_values, return_names)", "response": "Returns the values for a group of properties in one call."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the values for a group of properties in one call.", "response": "def set_properties(self, names, values):\n        \"\"\"Sets values for a group of properties in one call.\n        \n        The names of the properties to set are passed in the @a names\n        array along with the new values for them in the @a values array. Both\n        arrays have the same number of elements with each element at the given\n        index in the first array corresponding to an element at the same index\n        in the second array.\n        \n        If there is at least one property name in @a names that is not valid,\n        the method will fail before changing the values of any other properties\n        from the @a names array.\n        \n        Using this method over :py:func:`set_property`  is preferred if you\n        need to set several properties at once since it is more efficient.\n        \n        The list of all properties supported by the given medium format can\n        be obtained with :py:func:`IMediumFormat.describe_properties` .\n        \n        Setting the property value to @c null or an empty string is equivalent\n        to deleting the existing value. A default value (if it is defined for\n        this property) will be used by the format backend in this case.\n\n        in names of type str\n            Names of properties to set.\n\n        in values of type str\n            Values of properties to set.\n\n        \"\"\"\n        if not isinstance(names, list):\n            raise TypeError(\"names can only be an instance of type list\")\n        for a in names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(values, list):\n            raise TypeError(\"values can only be an instance of type list\")\n        for a in values[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"setProperties\",\n                     in_p=[names, values])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_base_storage(self, logical_size, variant):\n        if not isinstance(logical_size, baseinteger):\n            raise TypeError(\"logical_size can only be an instance of type baseinteger\")\n        if not isinstance(variant, list):\n            raise TypeError(\"variant can only be an instance of type list\")\n        for a in variant[:10]:\n            if not isinstance(a, MediumVariant):\n                raise TypeError(\n                        \"array can only contain objects of type MediumVariant\")\n        progress = self._call(\"createBaseStorage\",\n                     in_p=[logical_size, variant])\n        progress = IProgress(progress)\n        return progress", "response": "Creates a base storage unit for the specified logical size and variant."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new empty differencing storage unit based on the given target and variant.", "response": "def create_diff_storage(self, target, variant):\n        \"\"\"Starts creating an empty differencing storage unit based on this\n        medium in the format and at the location defined by the @a target\n        argument.\n        \n        The target medium must be in :py:attr:`MediumState.not_created` \n        state (i.e. must not have an existing storage unit). Upon successful\n        completion, this operation will set the type of the target medium to\n        :py:attr:`MediumType.normal`  and create a storage unit necessary to\n        represent the differencing medium data in the given format (according\n        to the storage format of the target object).\n        \n        After the returned progress object reports that the operation is\n        successfully complete, the target medium gets remembered by this\n        VirtualBox installation and may be attached to virtual machines.\n        \n        \n        The medium will be set to :py:attr:`MediumState.locked_read` \n        state for the duration of this operation.\n\n        in target of type :class:`IMedium`\n            Target medium.\n\n        in variant of type :class:`MediumVariant`\n            Exact image variant which should be created (as a combination of\n            :py:class:`MediumVariant`  flags).\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`VBoxErrorObjectInUse`\n            Medium not in @c NotCreated state.\n        \n        \"\"\"\n        if not isinstance(target, IMedium):\n            raise TypeError(\"target can only be an instance of type IMedium\")\n        if not isinstance(variant, list):\n            raise TypeError(\"variant can only be an instance of type list\")\n        for a in variant[:10]:\n            if not isinstance(a, MediumVariant):\n                raise TypeError(\n                        \"array can only contain objects of type MediumVariant\")\n        progress = self._call(\"createDiffStorage\",\n                     in_p=[target, variant])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart merging the contents of this medium and all intermediate differencing media in the chain to the given target medium. The target medium must be either a descendant of this medium or its ancestor (otherwise this method will immediately return a failure). It follows that there are two logical directions of the merge operation: from ancestor to descendant (*forward merge*) and from descendant to ancestor (*backward merge*). Let us consider the following medium chain: Base <- Diff_1 <- Diff_2 Here, calling this method on the Base medium object with Diff_2 as an argument will be a forward merge; calling it on Diff_2 with Base as an argument will be a backward merge. Note that in both cases the contents of the resulting medium will be the same, the only difference is the medium object that takes the result of the merge operation. In case of the forward merge in the above example, the result will be written to Diff_2; in case of the backward merge, the result will be written to Base. In other words, the result of the operation is always stored in the target medium. Upon successful operation completion, the storage units of all media in the chain between this (source) medium and the target medium, including the source medium itself, will be automatically deleted and the relevant medium objects (including this medium) will become uninitialized. This means that any attempt to call any of their methods or attributes will fail with the \"Object not ready\" (E_ACCESSDENIED) error. Applied to the above example, the forward merge of Base to Diff_2 will delete and uninitialize both Base and Diff_1 media. Note that Diff_2 in this case will become a base medium itself since it will no longer be based on any other medium. Considering the above, all of the following conditions must be met in order for the merge operation to succeed: Neither this (source) medium nor any intermediate differencing medium in the chain between it and the target medium is attached to any virtual machine. Neither the source medium nor the target medium is an :py:attr:`MediumType.immutable` medium. The part of the medium tree from the source medium to the target medium is a linear chain, i.e. all medium in this chain have exactly one child which is the next medium in this chain. The only exception from this rule is the target medium in the forward merge operation; it is allowed to have any number of child media because the merge operation will not change its logical contents (as it is seen by the guest OS or by children). None of the involved media are in :py:attr:`MediumState.locked_read` or :py:attr:`MediumState.locked_write` state. This (source) medium and all intermediates will be placed to :py:attr:`MediumState.deleting` state and the target medium will be placed to :py:attr:`MediumState.locked_write` state and for the duration of this operation. in target of type :class:`IMedium` Target medium. return progress of type :class:`IProgress` Progress object to track the operation completion.", "response": "def merge_to(self, target):\n        \"\"\"Starts merging the contents of this medium and all intermediate\n        differencing media in the chain to the given target medium.\n        \n        The target medium must be either a descendant of this medium or\n        its ancestor (otherwise this method will immediately return a failure).\n        It follows that there are two logical directions of the merge operation:\n        from ancestor to descendant (*forward merge*) and from descendant to\n        ancestor (*backward merge*). Let us consider the following medium\n        chain:\n        \n        Base <- Diff_1 <- Diff_2\n        \n        Here, calling this method on the Base medium object with\n        Diff_2 as an argument will be a forward merge; calling it on\n        Diff_2 with Base as an argument will be a backward\n        merge. Note that in both cases the contents of the resulting medium\n        will be the same, the only difference is the medium object that takes\n        the result of the merge operation. In case of the forward merge in the\n        above example, the result will be written to Diff_2; in case of\n        the backward merge, the result will be written to Base. In\n        other words, the result of the operation is always stored in the target\n        medium.\n        \n        Upon successful operation completion, the storage units of all media in\n        the chain between this (source) medium and the target medium, including\n        the source medium itself, will be automatically deleted and the\n        relevant medium objects (including this medium) will become\n        uninitialized. This means that any attempt to call any of\n        their methods or attributes will fail with the\n        \"Object not ready\" (E_ACCESSDENIED) error. Applied to the above\n        example, the forward merge of Base to Diff_2 will\n        delete and uninitialize both Base and Diff_1 media.\n        Note that Diff_2 in this case will become a base medium\n        itself since it will no longer be based on any other medium.\n        \n        Considering the above, all of the following conditions must be met in\n        order for the merge operation to succeed:\n        \n        \n        Neither this (source) medium nor any intermediate\n        differencing medium in the chain between it and the target\n        medium is attached to any virtual machine.\n        \n        \n        Neither the source medium nor the target medium is an\n        :py:attr:`MediumType.immutable`  medium.\n        \n        \n        The part of the medium tree from the source medium to the\n        target medium is a linear chain, i.e. all medium in this\n        chain have exactly one child which is the next medium in this\n        chain. The only exception from this rule is the target medium in\n        the forward merge operation; it is allowed to have any number of\n        child media because the merge operation will not change its\n        logical contents (as it is seen by the guest OS or by children).\n        \n        \n        None of the involved media are in\n        :py:attr:`MediumState.locked_read`  or\n        :py:attr:`MediumState.locked_write`  state.\n        \n        \n        \n        \n        This (source) medium and all intermediates will be placed to :py:attr:`MediumState.deleting`  state and the target medium will be\n        placed to :py:attr:`MediumState.locked_write`  state and for the\n        duration of this operation.\n\n        in target of type :class:`IMedium`\n            Target medium.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        \"\"\"\n        if not isinstance(target, IMedium):\n            raise TypeError(\"target can only be an instance of type IMedium\")\n        progress = self._call(\"mergeTo\",\n                     in_p=[target])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef move_to(self, location):\n        if not isinstance(location, basestring):\n            raise TypeError(\"location can only be an instance of type basestring\")\n        progress = self._call(\"moveTo\",\n                     in_p=[location])\n        progress = IProgress(progress)\n        return progress", "response": "Moves the storage unit to a new location."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts resizing this medium. This means that the nominal size of the medium is set to the new value. Both increasing and decreasing the size is possible, and there are no safety checks, since VirtualBox does not make any assumptions about the medium contents. Resizing usually needs additional disk space, and possibly also some temporary disk space. Note that resize does not create a full temporary copy of the medium, so the additional disk space requirement is usually much lower than using the clone operation. This medium will be placed to :py:attr:`MediumState.locked_write` state for the duration of this operation. Please note that the results can be either returned straight away, or later as the result of the background operation via the object returned via the @a progress parameter. in logical_size of type int New nominal capacity of the medium in bytes. return progress of type :class:`IProgress` Progress object to track the operation completion. raises :class:`VBoxErrorNotSupported` Medium format does not support resizing.", "response": "def resize(self, logical_size):\n        \"\"\"Starts resizing this medium. This means that the nominal size of the\n        medium is set to the new value. Both increasing and decreasing the\n        size is possible, and there are no safety checks, since VirtualBox\n        does not make any assumptions about the medium contents.\n        \n        Resizing usually needs additional disk space, and possibly also\n        some temporary disk space. Note that resize does not create a full\n        temporary copy of the medium, so the additional disk space requirement\n        is usually much lower than using the clone operation.\n        \n        This medium will be placed to :py:attr:`MediumState.locked_write` \n        state for the duration of this operation.\n        \n        Please note that the results can be either returned straight away,\n        or later as the result of the background operation via the object\n        returned via the @a progress parameter.\n\n        in logical_size of type int\n            New nominal capacity of the medium in bytes.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`VBoxErrorNotSupported`\n            Medium format does not support resizing.\n        \n        \"\"\"\n        if not isinstance(logical_size, baseinteger):\n            raise TypeError(\"logical_size can only be an instance of type baseinteger\")\n        progress = self._call(\"resize\",\n                     in_p=[logical_size])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchanging the encryption of the current password and the new password.", "response": "def change_encryption(self, current_password, cipher, new_password, new_password_id):\n        \"\"\"Starts encryption of this medium. This means that the stored data in the\n        medium is encrypted.\n        \n        This medium will be placed to :py:attr:`MediumState.locked_write` \n        state.\n        \n        Please note that the results can be either returned straight away,\n        or later as the result of the background operation via the object\n        returned via the @a progress parameter.\n\n        in current_password of type str\n            The current password the medium is protected with. Use an empty string to indicate\n            that the medium isn't encrypted.\n\n        in cipher of type str\n            The cipher to use for encryption. An empty string indicates no encryption for the\n            result.\n\n        in new_password of type str\n            The new password the medium should be protected with. An empty password and password ID\n            will result in the medium being encrypted with the current password.\n\n        in new_password_id of type str\n            The ID of the new password when unlocking the medium.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`VBoxErrorNotSupported`\n            Encryption is not supported for this medium because it is attached to more than one VM\nor has children.\n        \n        \"\"\"\n        if not isinstance(current_password, basestring):\n            raise TypeError(\"current_password can only be an instance of type basestring\")\n        if not isinstance(cipher, basestring):\n            raise TypeError(\"cipher can only be an instance of type basestring\")\n        if not isinstance(new_password, basestring):\n            raise TypeError(\"new_password can only be an instance of type basestring\")\n        if not isinstance(new_password_id, basestring):\n            raise TypeError(\"new_password_id can only be an instance of type basestring\")\n        progress = self._call(\"changeEncryption\",\n                     in_p=[current_password, cipher, new_password, new_password_id])\n        progress = IProgress(progress)\n        return progress"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_encryption_password(self, password):\n        if not isinstance(password, basestring):\n            raise TypeError(\"password can only be an instance of type basestring\")\n        self._call(\"checkEncryptionPassword\",\n                     in_p=[password])", "response": "Checks whether the supplied password is correct for the medium."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_for_io(self, writable, password):\n        if not isinstance(writable, bool):\n            raise TypeError(\"writable can only be an instance of type bool\")\n        if not isinstance(password, basestring):\n            raise TypeError(\"password can only be an instance of type basestring\")\n        medium_io = self._call(\"openForIO\",\n                     in_p=[writable, password])\n        medium_io = IMediumIO(medium_io)\n        return medium_io", "response": "Open the medium for reading and writing."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef describe_file_extensions(self):\n        (extensions, types) = self._call(\"describeFileExtensions\")\n        types = [DeviceType(a) for a in types]\n        return (extensions, types)", "response": "Returns two arrays describing the supported file extensions and the device types for each extension. The second array contains the supported extensions and the seconds one that each extension supports. The third array contains the supported extensions and the second the type each extension supports."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn several arrays describing the properties supported by this format. Each element in each array describes the properties supported by this format. Each element in each array describes the properties supported by this format.", "response": "def describe_properties(self):\n        \"\"\"Returns several arrays describing the properties supported by this\n        format.\n        \n        An element with the given index in each array describes one\n        property. Thus, the number of elements in each returned array is the\n        same and corresponds to the number of supported properties.\n        \n        The returned arrays are filled in only if the\n        :py:attr:`MediumFormatCapabilities.properties`  flag is set.\n        All arguments must be non-@c null.\n        \n        :py:class:`DataType` , :py:class:`DataFlags` \n\n        out names of type str\n            Array of property names.\n\n        out descriptions of type str\n            Array of property descriptions.\n\n        out types of type :class:`DataType`\n            Array of property types.\n\n        out flags of type int\n            Array of property flags.\n\n        out defaults of type str\n            Array of default property values.\n\n        \"\"\"\n        (names, descriptions, types, flags, defaults) = self._call(\"describeProperties\")\n        types = [DataType(a) for a in types]\n        return (names, descriptions, types, flags, defaults)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, offset, data):\n        if not isinstance(offset, baseinteger):\n            raise TypeError(\"offset can only be an instance of type baseinteger\")\n        if not isinstance(data, list):\n            raise TypeError(\"data can only be an instance of type list\")\n        for a in data[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        written = self._call(\"write\",\n                     in_p=[offset, data])\n        return written", "response": "Writes data to the medium at the specified offset."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_fat(self, quick):\n        if not isinstance(quick, bool):\n            raise TypeError(\"quick can only be an instance of type bool\")\n        self._call(\"formatFAT\",\n                     in_p=[quick])", "response": "Formats the medium as FAT."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the partition table.", "response": "def initialize_partition_table(self, format_p, whole_disk_in_one_entry):\n        \"\"\"Writes an empty partition table to the disk.\n\n        in format_p of type :class:`PartitionTableType`\n            The partition table format.\n\n        in whole_disk_in_one_entry of type bool\n            When @c true a partition table entry for the whole disk is created.\n            Otherwise the partition table is empty.\n\n        \"\"\"\n        if not isinstance(format_p, PartitionTableType):\n            raise TypeError(\"format_p can only be an instance of type PartitionTableType\")\n        if not isinstance(whole_disk_in_one_entry, bool):\n            raise TypeError(\"whole_disk_in_one_entry can only be an instance of type bool\")\n        self._call(\"initializePartitionTable\",\n                     in_p=[format_p, whole_disk_in_one_entry])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the currently opened image into a stream of the specified format and variant.", "response": "def convert_to_stream(self, format_p, variant, buffer_size):\n        \"\"\"Converts the currently opened image into a stream of the specified\n        image type/variant. It is sufficient to open the image in read-only\n        mode. Only few types and variants are supported due to the inherent\n        restrictions of the output style.\n\n        in format_p of type str\n            Identifier of the storage format to use for output.\n\n        in variant of type :class:`MediumVariant`\n            The partition table format.\n\n        in buffer_size of type int\n            Requested buffer size (in bytes) for efficient conversion. Sizes\n            which are too small or too large are silently truncated to suitable\n            values. Tens to hundreds of Megabytes are a good choice.\n\n        out stream of type :class:`IDataStream`\n            Data stream object for reading the target image.\n\n        return progress of type :class:`IProgress`\n            Progress object to track the operation completion.\n\n        raises :class:`VBoxErrorNotSupported`\n            The requested format/variant combination cannot handle stream output.\n        \n        raises :class:`VBoxErrorFileError`\n            An error occurred during the conversion.\n        \n        \"\"\"\n        if not isinstance(format_p, basestring):\n            raise TypeError(\"format_p can only be an instance of type basestring\")\n        if not isinstance(variant, list):\n            raise TypeError(\"variant can only be an instance of type list\")\n        for a in variant[:10]:\n            if not isinstance(a, MediumVariant):\n                raise TypeError(\n                        \"array can only contain objects of type MediumVariant\")\n        if not isinstance(buffer_size, baseinteger):\n            raise TypeError(\"buffer_size can only be an instance of type baseinteger\")\n        (progress, stream) = self._call(\"convertToStream\",\n                     in_p=[format_p, variant, buffer_size])\n        progress = IProgress(progress)\n        stream = IDataStream(stream)\n        return (progress, stream)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put_scancode(self, scancode):\n        if not isinstance(scancode, baseinteger):\n            raise TypeError(\"scancode can only be an instance of type baseinteger\")\n        self._call(\"putScancode\",\n                     in_p=[scancode])", "response": "Sends a scancode to the virtual keyboard."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend an array of scancodes to the keyboard.", "response": "def put_scancodes(self, scancodes):\n        \"\"\"Sends an array of scancodes to the keyboard.\n\n        in scancodes of type int\n\n        return codes_stored of type int\n\n        raises :class:`VBoxErrorIprtError`\n            Could not send all scan codes to virtual keyboard.\n        \n        \"\"\"\n        if not isinstance(scancodes, list):\n            raise TypeError(\"scancodes can only be an instance of type list\")\n        for a in scancodes[:10]:\n            if not isinstance(a, baseinteger):\n                raise TypeError(\n                        \"array can only contain objects of type baseinteger\")\n        codes_stored = self._call(\"putScancodes\",\n                     in_p=[scancodes])\n        return codes_stored"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put_mouse_event(self, dx, dy, dz, dw, button_state):\n        if not isinstance(dx, baseinteger):\n            raise TypeError(\"dx can only be an instance of type baseinteger\")\n        if not isinstance(dy, baseinteger):\n            raise TypeError(\"dy can only be an instance of type baseinteger\")\n        if not isinstance(dz, baseinteger):\n            raise TypeError(\"dz can only be an instance of type baseinteger\")\n        if not isinstance(dw, baseinteger):\n            raise TypeError(\"dw can only be an instance of type baseinteger\")\n        if not isinstance(button_state, baseinteger):\n            raise TypeError(\"button_state can only be an instance of type baseinteger\")\n        self._call(\"putMouseEvent\",\n                     in_p=[dx, dy, dz, dw, button_state])", "response": "This method is used to send mouse events to virtual mouse."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put_mouse_event_absolute(self, x, y, dz, dw, button_state):\n        if not isinstance(x, baseinteger):\n            raise TypeError(\"x can only be an instance of type baseinteger\")\n        if not isinstance(y, baseinteger):\n            raise TypeError(\"y can only be an instance of type baseinteger\")\n        if not isinstance(dz, baseinteger):\n            raise TypeError(\"dz can only be an instance of type baseinteger\")\n        if not isinstance(dw, baseinteger):\n            raise TypeError(\"dw can only be an instance of type baseinteger\")\n        if not isinstance(button_state, baseinteger):\n            raise TypeError(\"button_state can only be an instance of type baseinteger\")\n        self._call(\"putMouseEventAbsolute\",\n                     in_p=[x, y, dz, dw, button_state])", "response": "This method moves the mouse pointer using absolute x and y coordinates and returns the virtual mouse event."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a multi - touch pointer event to the virtual device.", "response": "def put_event_multi_touch(self, count, contacts, scan_time):\n        \"\"\"Sends a multi-touch pointer event. The coordinates are expressed in\n        pixels and start from [1,1] which corresponds to the top left\n        corner of the virtual display.\n        \n        \n        \n        \n        The guest may not understand or may choose to ignore this event.\n        \n        \n        :py:func:`multi_touch_supported` \n\n        in count of type int\n            Number of contacts in the event.\n\n        in contacts of type int\n            Each array element contains packed information about one contact.\n            Bits 0..15: X coordinate in pixels.\n            Bits 16..31: Y coordinate in pixels.\n            Bits 32..39: contact identifier.\n            Bit 40: \"in contact\" flag, which indicates that there is a contact with the touch surface.\n            Bit 41: \"in range\" flag, the contact is close enough to the touch surface.\n            All other bits are reserved for future use and must be set to 0.\n\n        in scan_time of type int\n            Timestamp of the event in milliseconds. Only relative time between events is important.\n\n        raises :class:`OleErrorAccessdenied`\n            Console not powered up.\n        \n        raises :class:`VBoxErrorIprtError`\n            Could not send event to virtual device.\n        \n        \"\"\"\n        if not isinstance(count, baseinteger):\n            raise TypeError(\"count can only be an instance of type baseinteger\")\n        if not isinstance(contacts, list):\n            raise TypeError(\"contacts can only be an instance of type list\")\n        for a in contacts[:10]:\n            if not isinstance(a, baseinteger):\n                raise TypeError(\n                        \"array can only contain objects of type baseinteger\")\n        if not isinstance(scan_time, baseinteger):\n            raise TypeError(\"scan_time can only be an instance of type baseinteger\")\n        self._call(\"putEventMultiTouch\",\n                     in_p=[count, contacts, scan_time])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef put_event_multi_touch_string(self, count, contacts, scan_time):\n        if not isinstance(count, baseinteger):\n            raise TypeError(\"count can only be an instance of type baseinteger\")\n        if not isinstance(contacts, basestring):\n            raise TypeError(\"contacts can only be an instance of type basestring\")\n        if not isinstance(scan_time, baseinteger):\n            raise TypeError(\"scan_time can only be an instance of type baseinteger\")\n        self._call(\"putEventMultiTouchString\",\n                     in_p=[count, contacts, scan_time])", "response": "Stores the multi touch string for the specified set of contacts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query_bitmap_info(self):\n        (address, width, height, bits_per_pixel, bytes_per_line, bitmap_format) = self._call(\"queryBitmapInfo\")\n        bitmap_format = BitmapFormat(bitmap_format)\n        return (address, width, height, bits_per_pixel, bytes_per_line, bitmap_format)", "response": "Query the screen bitmap information."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninform about an update.", "response": "def notify_update(self, x, y, width, height):\n        \"\"\"Informs about an update.\n        Gets called by the display object where this buffer is\n        registered.\n\n        in x of type int\n\n        in y of type int\n\n        in width of type int\n\n        in height of type int\n\n        \"\"\"\n        if not isinstance(x, baseinteger):\n            raise TypeError(\"x can only be an instance of type baseinteger\")\n        if not isinstance(y, baseinteger):\n            raise TypeError(\"y can only be an instance of type baseinteger\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        self._call(\"notifyUpdate\",\n                     in_p=[x, y, width, height])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef notify_update_image(self, x, y, width, height, image):\n        if not isinstance(x, baseinteger):\n            raise TypeError(\"x can only be an instance of type baseinteger\")\n        if not isinstance(y, baseinteger):\n            raise TypeError(\"y can only be an instance of type baseinteger\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        if not isinstance(image, list):\n            raise TypeError(\"image can only be an instance of type list\")\n        for a in image[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"notifyUpdateImage\",\n                     in_p=[x, y, width, height, image])", "response": "Informs about an update and provides 32bpp bitmap."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrequests a size change.", "response": "def notify_change(self, screen_id, x_origin, y_origin, width, height):\n        \"\"\"Requests a size change.\n\n        in screen_id of type int\n            Logical guest screen number.\n\n        in x_origin of type int\n            Location of the screen in the guest.\n\n        in y_origin of type int\n            Location of the screen in the guest.\n\n        in width of type int\n            Width of the guest display, in pixels.\n\n        in height of type int\n            Height of the guest display, in pixels.\n\n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(x_origin, baseinteger):\n            raise TypeError(\"x_origin can only be an instance of type baseinteger\")\n        if not isinstance(y_origin, baseinteger):\n            raise TypeError(\"y_origin can only be an instance of type baseinteger\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        self._call(\"notifyChange\",\n                     in_p=[screen_id, x_origin, y_origin, width, height])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn whether the VMM device supports a given video mode.", "response": "def video_mode_supported(self, width, height, bpp):\n        \"\"\"Returns whether the frame buffer implementation is willing to\n        support a given video mode. In case it is not able to render\n        the video mode (or for some reason not willing), it should\n        return @c false. Usually this method is called when the guest\n        asks the VMM device whether a given video mode is supported\n        so the information returned is directly exposed to the guest.\n        It is important that this method returns very quickly.\n\n        in width of type int\n\n        in height of type int\n\n        in bpp of type int\n\n        return supported of type bool\n\n        \"\"\"\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        if not isinstance(bpp, baseinteger):\n            raise TypeError(\"bpp can only be an instance of type baseinteger\")\n        supported = self._call(\"videoModeSupported\",\n                     in_p=[width, height, bpp])\n        return supported"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_visible_region(self, rectangles, count):\n        if not isinstance(rectangles, basestring):\n            raise TypeError(\"rectangles can only be an instance of type basestring\")\n        if not isinstance(count, baseinteger):\n            raise TypeError(\"count can only be an instance of type baseinteger\")\n        count_copied = self._call(\"getVisibleRegion\",\n                     in_p=[rectangles, count])\n        return count_copied", "response": "Returns the visible region of this frame buffer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsuggesting a new visible region to this frame buffer.", "response": "def set_visible_region(self, rectangles, count):\n        \"\"\"Suggests a new visible region to this frame buffer. This region\n        represents the area of the VM display which is a union of regions of\n        all top-level windows of the guest operating system running inside the\n        VM (if the Guest Additions for this system support this\n        functionality). This information may be used by the frontends to\n        implement the seamless desktop integration feature.\n        \n        \n        The address of the provided array must be in the process space of\n        this IFramebuffer object.\n        \n        \n        The IFramebuffer implementation must make a copy of the provided\n        array of rectangles.\n        \n        \n        Method not yet implemented.\n\n        in rectangles of type str\n            Pointer to the @c RTRECT array.\n\n        in count of type int\n            Number of @c RTRECT elements in the @a rectangles array.\n\n        \"\"\"\n        if not isinstance(rectangles, basestring):\n            raise TypeError(\"rectangles can only be an instance of type basestring\")\n        if not isinstance(count, baseinteger):\n            raise TypeError(\"count can only be an instance of type baseinteger\")\n        self._call(\"setVisibleRegion\",\n                     in_p=[rectangles, count])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses a VHWACMD command.", "response": "def process_vhwa_command(self, command, enm_cmd, from_guest):\n        \"\"\"Posts a Video HW Acceleration Command to the frame buffer for processing.\n        The commands used for 2D video acceleration (DDraw surface creation/destroying, blitting, scaling, color conversion, overlaying, etc.)\n        are posted from quest to the host to be processed by the host hardware.\n        \n        \n        The address of the provided command must be in the process space of\n        this IFramebuffer object.\n\n        in command of type str\n            Pointer to VBOXVHWACMD containing the command to execute.\n\n        in enm_cmd of type int\n            The validated VBOXVHWACMD::enmCmd value from the command.\n\n        in from_guest of type bool\n            Set when the command origins from the guest, clear if host.\n\n        \"\"\"\n        if not isinstance(command, basestring):\n            raise TypeError(\"command can only be an instance of type basestring\")\n        if not isinstance(enm_cmd, baseinteger):\n            raise TypeError(\"enm_cmd can only be an instance of type baseinteger\")\n        if not isinstance(from_guest, bool):\n            raise TypeError(\"from_guest can only be an instance of type bool\")\n        self._call(\"processVHWACommand\",\n                     in_p=[command, enm_cmd, from_guest])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef notify3_d_event(self, type_p, data):\n        if not isinstance(type_p, baseinteger):\n            raise TypeError(\"type_p can only be an instance of type baseinteger\")\n        if not isinstance(data, list):\n            raise TypeError(\"data can only be an instance of type list\")\n        for a in data[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"notify3DEvent\",\n                     in_p=[type_p, data])", "response": "Notifies the framebuffer about a 3D backend event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef move(self, x, y):\n        if not isinstance(x, baseinteger):\n            raise TypeError(\"x can only be an instance of type baseinteger\")\n        if not isinstance(y, baseinteger):\n            raise TypeError(\"y can only be an instance of type baseinteger\")\n        self._call(\"move\",\n                     in_p=[x, y])", "response": "Changes the overlay s position relative to the IFramebuffer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_screen_resolution(self, screen_id):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        (width, height, bits_per_pixel, x_origin, y_origin, guest_monitor_status) = self._call(\"getScreenResolution\",\n                     in_p=[screen_id])\n        guest_monitor_status = GuestMonitorStatus(guest_monitor_status)\n        return (width, height, bits_per_pixel, x_origin, y_origin, guest_monitor_status)", "response": "Queries certain attributes such as display width height color depth xOrigin and yOrigin return the X and Y origin coordinates of the guest screen."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef attach_framebuffer(self, screen_id, framebuffer):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(framebuffer, IFramebuffer):\n            raise TypeError(\"framebuffer can only be an instance of type IFramebuffer\")\n        id_p = self._call(\"attachFramebuffer\",\n                     in_p=[screen_id, framebuffer])\n        return id_p", "response": "Sets the graphics update target for a screen."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detach_framebuffer(self, screen_id, id_p):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        self._call(\"detachFramebuffer\",\n                     in_p=[screen_id, id_p])", "response": "Removes the graphics updates target for a screen."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery the graphics updates targets for a screen.", "response": "def query_framebuffer(self, screen_id):\n        \"\"\"Queries the graphics updates targets for a screen.\n\n        in screen_id of type int\n\n        return framebuffer of type :class:`IFramebuffer`\n\n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        framebuffer = self._call(\"queryFramebuffer\",\n                     in_p=[screen_id])\n        framebuffer = IFramebuffer(framebuffer)\n        return framebuffer"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_video_mode_hint(self, display, enabled, change_origin, origin_x, origin_y, width, height, bits_per_pixel):\n        if not isinstance(display, baseinteger):\n            raise TypeError(\"display can only be an instance of type baseinteger\")\n        if not isinstance(enabled, bool):\n            raise TypeError(\"enabled can only be an instance of type bool\")\n        if not isinstance(change_origin, bool):\n            raise TypeError(\"change_origin can only be an instance of type bool\")\n        if not isinstance(origin_x, baseinteger):\n            raise TypeError(\"origin_x can only be an instance of type baseinteger\")\n        if not isinstance(origin_y, baseinteger):\n            raise TypeError(\"origin_y can only be an instance of type baseinteger\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        if not isinstance(bits_per_pixel, baseinteger):\n            raise TypeError(\"bits_per_pixel can only be an instance of type baseinteger\")\n        self._call(\"setVideoModeHint\",\n                     in_p=[display, enabled, change_origin, origin_x, origin_y, width, height, bits_per_pixel])", "response": "Asks VirtualBox to request the video mode from the given display."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nenabling or disables seamless guest display rendering.", "response": "def set_seamless_mode(self, enabled):\n        \"\"\"Enables or disables seamless guest display rendering (seamless desktop\n        integration) mode.\n        \n        Calling this method has no effect if :py:func:`IGuest.get_facility_status`  with facility @c Seamless\n        does not return @c Active.\n\n        in enabled of type bool\n\n        \"\"\"\n        if not isinstance(enabled, bool):\n            raise TypeError(\"enabled can only be an instance of type bool\")\n        self._call(\"setSeamlessMode\",\n                     in_p=[enabled])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a screen shot of the requested size and format and copies it to the caller s memory.", "response": "def take_screen_shot(self, screen_id, address, width, height, bitmap_format):\n        \"\"\"Takes a screen shot of the requested size and format and copies it to the\n        buffer allocated by the caller and pointed to by @a address.\n        The buffer size must be enough for a 32 bits per pixel bitmap,\n        i.e. width * height * 4 bytes.\n        \n        This API can be used only locally by a VM process through the\n        COM/XPCOM C++ API as it requires pointer support. It is not\n        available for scripting languages, Java or any webservice clients.\n        Unless you are writing a new VM frontend use\n        :py:func:`take_screen_shot_to_array` .\n\n        in screen_id of type int\n\n        in address of type str\n\n        in width of type int\n\n        in height of type int\n\n        in bitmap_format of type :class:`BitmapFormat`\n\n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(address, basestring):\n            raise TypeError(\"address can only be an instance of type basestring\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        if not isinstance(bitmap_format, BitmapFormat):\n            raise TypeError(\"bitmap_format can only be an instance of type BitmapFormat\")\n        self._call(\"takeScreenShot\",\n                     in_p=[screen_id, address, width, height, bitmap_format])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a guest screen shot of the requested size and format and returns it as an array of bytes.", "response": "def take_screen_shot_to_array(self, screen_id, width, height, bitmap_format):\n        \"\"\"Takes a guest screen shot of the requested size and format\n        and returns it as an array of bytes.\n\n        in screen_id of type int\n            The guest monitor to take screenshot from.\n\n        in width of type int\n            Desired image width.\n\n        in height of type int\n            Desired image height.\n\n        in bitmap_format of type :class:`BitmapFormat`\n            The requested format.\n\n        return screen_data of type str\n            Array with resulting screen data.\n\n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        if not isinstance(bitmap_format, BitmapFormat):\n            raise TypeError(\"bitmap_format can only be an instance of type BitmapFormat\")\n        screen_data = self._call(\"takeScreenShotToArray\",\n                     in_p=[screen_id, width, height, bitmap_format])\n        return screen_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndrawing a 32 - bpp image from the given buffer to the given point on the VM display.", "response": "def draw_to_screen(self, screen_id, address, x, y, width, height):\n        \"\"\"Draws a 32-bpp image of the specified size from the given buffer\n        to the given point on the VM display.\n\n        in screen_id of type int\n            Monitor to take the screenshot from.\n\n        in address of type str\n            Address to store the screenshot to\n\n        in x of type int\n            Relative to the screen top left corner.\n\n        in y of type int\n            Relative to the screen top left corner.\n\n        in width of type int\n            Desired image width.\n\n        in height of type int\n            Desired image height.\n\n        raises :class:`OleErrorNotimpl`\n            Feature not implemented.\n        \n        raises :class:`VBoxErrorIprtError`\n            Could not draw to screen.\n        \n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(address, basestring):\n            raise TypeError(\"address can only be an instance of type basestring\")\n        if not isinstance(x, baseinteger):\n            raise TypeError(\"x can only be an instance of type baseinteger\")\n        if not isinstance(y, baseinteger):\n            raise TypeError(\"y can only be an instance of type baseinteger\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        self._call(\"drawToScreen\",\n                     in_p=[screen_id, address, x, y, width, height])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef invalidate_and_update_screen(self, screen_id):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        self._call(\"invalidateAndUpdateScreen\",\n                     in_p=[screen_id])", "response": "Invalidate the VM screen."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsignals that the Video HW Acceleration command has completed.", "response": "def complete_vhwa_command(self, command):\n        \"\"\"Signals that the Video HW Acceleration command has completed.\n\n        in command of type str\n            Pointer to VBOXVHWACMD containing the completed command.\n\n        \"\"\"\n        if not isinstance(command, basestring):\n            raise TypeError(\"command can only be an instance of type basestring\")\n        self._call(\"completeVHWACommand\",\n                     in_p=[command])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsignals that the viewport has changed.", "response": "def viewport_changed(self, screen_id, x, y, width, height):\n        \"\"\"Signals that framebuffer window viewport has changed.\n\n        in screen_id of type int\n            Monitor to take the screenshot from.\n\n        in x of type int\n            Framebuffer x offset.\n\n        in y of type int\n            Framebuffer y offset.\n\n        in width of type int\n            Viewport width.\n\n        in height of type int\n            Viewport height.\n\n        raises :class:`OleErrorInvalidarg`\n            The specified viewport data is invalid.\n        \n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(x, baseinteger):\n            raise TypeError(\"x can only be an instance of type baseinteger\")\n        if not isinstance(y, baseinteger):\n            raise TypeError(\"y can only be an instance of type baseinteger\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        self._call(\"viewportChanged\",\n                     in_p=[screen_id, x, y, width, height])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query_source_bitmap(self, screen_id):\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        display_source_bitmap = self._call(\"querySourceBitmap\",\n                     in_p=[screen_id])\n        display_source_bitmap = IDisplaySourceBitmap(display_source_bitmap)\n        return display_source_bitmap", "response": "Queries the guest screen bitmap parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nnotifies OpenGL HGCM host service about graphics content scaling factor change.", "response": "def notify_scale_factor_change(self, screen_id, u32_scale_factor_w_multiplied, u32_scale_factor_h_multiplied):\n        \"\"\"Notify OpenGL HGCM host service about graphics content scaling factor change.\n\n        in screen_id of type int\n\n        in u32_scale_factor_w_multiplied of type int\n\n        in u32_scale_factor_h_multiplied of type int\n\n        \"\"\"\n        if not isinstance(screen_id, baseinteger):\n            raise TypeError(\"screen_id can only be an instance of type baseinteger\")\n        if not isinstance(u32_scale_factor_w_multiplied, baseinteger):\n            raise TypeError(\"u32_scale_factor_w_multiplied can only be an instance of type baseinteger\")\n        if not isinstance(u32_scale_factor_h_multiplied, baseinteger):\n            raise TypeError(\"u32_scale_factor_h_multiplied can only be an instance of type baseinteger\")\n        self._call(\"notifyScaleFactorChange\",\n                     in_p=[screen_id, u32_scale_factor_w_multiplied, u32_scale_factor_h_multiplied])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef notify_hi_dpi_output_policy_change(self, f_unscaled_hi_dpi):\n        if not isinstance(f_unscaled_hi_dpi, bool):\n            raise TypeError(\"f_unscaled_hi_dpi can only be an instance of type bool\")\n        self._call(\"notifyHiDPIOutputPolicyChange\",\n                     in_p=[f_unscaled_hi_dpi])", "response": "Notify OpenGL HGCM host service about HiDPI monitor scaling policy change."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the video modes for the guest screens.", "response": "def set_screen_layout(self, screen_layout_mode, guest_screen_info):\n        \"\"\"Set video modes for the guest screens.\n\n        in screen_layout_mode of type :class:`ScreenLayoutMode`\n\n        in guest_screen_info of type :class:`IGuestScreenInfo`\n\n        \"\"\"\n        if not isinstance(screen_layout_mode, ScreenLayoutMode):\n            raise TypeError(\"screen_layout_mode can only be an instance of type ScreenLayoutMode\")\n        if not isinstance(guest_screen_info, list):\n            raise TypeError(\"guest_screen_info can only be an instance of type list\")\n        for a in guest_screen_info[:10]:\n            if not isinstance(a, IGuestScreenInfo):\n                raise TypeError(\n                        \"array can only contain objects of type IGuestScreenInfo\")\n        self._call(\"setScreenLayout\",\n                     in_p=[screen_layout_mode, guest_screen_info])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef detach_screens(self, screen_ids):\n        if not isinstance(screen_ids, list):\n            raise TypeError(\"screen_ids can only be an instance of type list\")\n        for a in screen_ids[:10]:\n            if not isinstance(a, baseinteger):\n                raise TypeError(\n                        \"array can only contain objects of type baseinteger\")\n        self._call(\"detachScreens\",\n                     in_p=[screen_ids])", "response": "Detaches the screens from the virtual graphics card."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_guest_screen_info(self, display, status, primary, change_origin, origin_x, origin_y, width, height, bits_per_pixel):\n        if not isinstance(display, baseinteger):\n            raise TypeError(\"display can only be an instance of type baseinteger\")\n        if not isinstance(status, GuestMonitorStatus):\n            raise TypeError(\"status can only be an instance of type GuestMonitorStatus\")\n        if not isinstance(primary, bool):\n            raise TypeError(\"primary can only be an instance of type bool\")\n        if not isinstance(change_origin, bool):\n            raise TypeError(\"change_origin can only be an instance of type bool\")\n        if not isinstance(origin_x, baseinteger):\n            raise TypeError(\"origin_x can only be an instance of type baseinteger\")\n        if not isinstance(origin_y, baseinteger):\n            raise TypeError(\"origin_y can only be an instance of type baseinteger\")\n        if not isinstance(width, baseinteger):\n            raise TypeError(\"width can only be an instance of type baseinteger\")\n        if not isinstance(height, baseinteger):\n            raise TypeError(\"height can only be an instance of type baseinteger\")\n        if not isinstance(bits_per_pixel, baseinteger):\n            raise TypeError(\"bits_per_pixel can only be an instance of type baseinteger\")\n        guest_screen_info = self._call(\"createGuestScreenInfo\",\n                     in_p=[display, status, primary, change_origin, origin_x, origin_y, width, height, bits_per_pixel])\n        guest_screen_info = IGuestScreenInfo(guest_screen_info)\n        return guest_screen_info", "response": "Creates a IGuestScreenInfo object with the provided parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_property(self, key):\n        if not isinstance(key, basestring):\n            raise TypeError(\"key can only be an instance of type basestring\")\n        value = self._call(\"getProperty\",\n                     in_p=[key])\n        return value", "response": "Returns the value of the network attachment property with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dump_guest_core(self, filename, compression):\n        if not isinstance(filename, basestring):\n            raise TypeError(\"filename can only be an instance of type basestring\")\n        if not isinstance(compression, basestring):\n            raise TypeError(\"compression can only be an instance of type basestring\")\n        self._call(\"dumpGuestCore\",\n                     in_p=[filename, compression])", "response": "Dumps the guest core to a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the info of the specified entry.", "response": "def info(self, name, args):\n        \"\"\"Interfaces with the info dumpers (DBGFInfo).\n        \n        This feature is not implemented in the 4.0.0 release but it may show up\n        in a dot release.\n\n        in name of type str\n            The name of the info item.\n\n        in args of type str\n            Arguments to the info dumper.\n\n        return info of type str\n            The into string.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(args, basestring):\n            raise TypeError(\"args can only be an instance of type basestring\")\n        info = self._call(\"info\",\n                     in_p=[name, args])\n        return info"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmodifying the log groups of the debug or release logger.", "response": "def modify_log_groups(self, settings):\n        \"\"\"Modifies the group settings of the debug or release logger.\n\n        in settings of type str\n            The group settings string. See iprt/log.h for details. To target the\n            release logger, prefix the string with \"release:\".\n\n        \"\"\"\n        if not isinstance(settings, basestring):\n            raise TypeError(\"settings can only be an instance of type basestring\")\n        self._call(\"modifyLogGroups\",\n                     in_p=[settings])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmodifying the debug or release logger flags.", "response": "def modify_log_flags(self, settings):\n        \"\"\"Modifies the debug or release logger flags.\n\n        in settings of type str\n            The flags settings string. See iprt/log.h for details. To target the\n            release logger, prefix the string with \"release:\".\n\n        \"\"\"\n        if not isinstance(settings, basestring):\n            raise TypeError(\"settings can only be an instance of type basestring\")\n        self._call(\"modifyLogFlags\",\n                     in_p=[settings])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmodify the debug or release logger destinations.", "response": "def modify_log_destinations(self, settings):\n        \"\"\"Modifies the debug or release logger destinations.\n\n        in settings of type str\n            The destination settings string. See iprt/log.h for details. To target the\n            release logger, prefix the string with \"release:\".\n\n        \"\"\"\n        if not isinstance(settings, basestring):\n            raise TypeError(\"settings can only be an instance of type basestring\")\n        self._call(\"modifyLogDestinations\",\n                     in_p=[settings])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the guest physical memory.", "response": "def read_physical_memory(self, address, size):\n        \"\"\"Reads guest physical memory, no side effects (MMIO++).\n        \n        This feature is not implemented in the 4.0.0 release but may show up\n        in a dot release.\n\n        in address of type int\n            The guest physical address.\n\n        in size of type int\n            The number of bytes to read.\n\n        return bytes_p of type str\n            The bytes read.\n\n        \"\"\"\n        if not isinstance(address, baseinteger):\n            raise TypeError(\"address can only be an instance of type baseinteger\")\n        if not isinstance(size, baseinteger):\n            raise TypeError(\"size can only be an instance of type baseinteger\")\n        bytes_p = self._call(\"readPhysicalMemory\",\n                     in_p=[address, size])\n        return bytes_p"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_virtual_memory(self, cpu_id, address, size):\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        if not isinstance(address, baseinteger):\n            raise TypeError(\"address can only be an instance of type baseinteger\")\n        if not isinstance(size, baseinteger):\n            raise TypeError(\"size can only be an instance of type baseinteger\")\n        bytes_p = self._call(\"readVirtualMemory\",\n                     in_p=[cpu_id, address, size])\n        return bytes_p", "response": "Reads the virtual memory of the specified CPU."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_virtual_memory(self, cpu_id, address, size, bytes_p):\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        if not isinstance(address, baseinteger):\n            raise TypeError(\"address can only be an instance of type baseinteger\")\n        if not isinstance(size, baseinteger):\n            raise TypeError(\"size can only be an instance of type baseinteger\")\n        if not isinstance(bytes_p, list):\n            raise TypeError(\"bytes_p can only be an instance of type list\")\n        for a in bytes_p[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"writeVirtualMemory\",\n                     in_p=[cpu_id, address, size, bytes_p])", "response": "Writes the contents of the virtual memory to the specified memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_plug_in(self, name):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        plug_in_name = self._call(\"loadPlugIn\",\n                     in_p=[name])\n        return plug_in_name", "response": "Loads a DBGF plug - in."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unload_plug_in(self, name):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        self._call(\"unloadPlugIn\",\n                     in_p=[name])", "response": "Unloads a DBGF plug - in."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntrying to get the kernel log of the guest OS.", "response": "def query_os_kernel_log(self, max_messages):\n        \"\"\"Tries to get the kernel log (dmesg) of the guest OS.\n\n        in max_messages of type int\n            Max number of messages to return, counting from the end of the\n            log.  If 0, there is no limit.\n\n        return dmesg of type str\n            The kernel log.\n\n        \"\"\"\n        if not isinstance(max_messages, baseinteger):\n            raise TypeError(\"max_messages can only be an instance of type baseinteger\")\n        dmesg = self._call(\"queryOSKernelLog\",\n                     in_p=[max_messages])\n        return dmesg"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget one register. in cpu_id of type int The identifier of the Virtual CPU. in name of type str The register name, case is ignored. return value of type str The register value. This is usually a hex value (always 0x prefixed) but other format may be used for floating point registers (TBD).", "response": "def get_register(self, cpu_id, name):\n        \"\"\"Gets one register.\n\n        in cpu_id of type int\n            The identifier of the Virtual CPU.\n\n        in name of type str\n            The register name, case is ignored.\n\n        return value of type str\n            The register value. This is usually a hex value (always 0x prefixed)\n            but other format may be used for floating point registers (TBD).\n\n        \"\"\"\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        value = self._call(\"getRegister\",\n                     in_p=[cpu_id, name])\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_registers(self, cpu_id):\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        (names, values) = self._call(\"getRegisters\",\n                     in_p=[cpu_id])\n        return (names, values)", "response": "Gets all the registers for the given CPU."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_registers(self, cpu_id, names, values):\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        if not isinstance(names, list):\n            raise TypeError(\"names can only be an instance of type list\")\n        for a in names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(values, list):\n            raise TypeError(\"values can only be an instance of type list\")\n        for a in values[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"setRegisters\",\n                     in_p=[cpu_id, names, values])", "response": "Sets zero or more registers atomically."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dump_guest_stack(self, cpu_id):\n        if not isinstance(cpu_id, baseinteger):\n            raise TypeError(\"cpu_id can only be an instance of type baseinteger\")\n        stack = self._call(\"dumpGuestStack\",\n                     in_p=[cpu_id])\n        return stack", "response": "Produce a simple stack dump using the current guest state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreset VM statistics. in pattern of type str The selection pattern. A bit similar to filename globbing.", "response": "def reset_stats(self, pattern):\n        \"\"\"Reset VM statistics.\n\n        in pattern of type str\n            The selection pattern. A bit similar to filename globbing.\n\n        \"\"\"\n        if not isinstance(pattern, basestring):\n            raise TypeError(\"pattern can only be an instance of type basestring\")\n        self._call(\"resetStats\",\n                     in_p=[pattern])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dump_stats(self, pattern):\n        if not isinstance(pattern, basestring):\n            raise TypeError(\"pattern can only be an instance of type basestring\")\n        self._call(\"dumpStats\",\n                     in_p=[pattern])", "response": "Dumps VM statistics.\n\n        in pattern of type str\n            The selection pattern. A bit similar to filename globbing."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_stats(self, pattern, with_descriptions):\n        if not isinstance(pattern, basestring):\n            raise TypeError(\"pattern can only be an instance of type basestring\")\n        if not isinstance(with_descriptions, bool):\n            raise TypeError(\"with_descriptions can only be an instance of type bool\")\n        stats = self._call(\"getStats\",\n                     in_p=[pattern, with_descriptions])\n        return stats", "response": "Get the VM statistics in a XMLish format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_device_filter(self, name):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        filter_p = self._call(\"createDeviceFilter\",\n                     in_p=[name])\n        filter_p = IUSBDeviceFilter(filter_p)\n        return filter_p", "response": "Creates a new USB device filter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninserting the given USB device into the specified position within the collection of filters.", "response": "def insert_device_filter(self, position, filter_p):\n        \"\"\"Inserts the given USB device to the specified position\n        in the list of filters.\n        \n        Positions are numbered starting from 0. If the specified\n        position is equal to or greater than the number of elements in\n        the list, the filter is added to the end of the collection.\n        \n        \n        Duplicates are not allowed, so an attempt to insert a\n        filter that is already in the collection, will return an\n        error.\n        \n        \n        \n        \n        :py:func:`device_filters` \n\n        in position of type int\n            Position to insert the filter to.\n\n        in filter_p of type :class:`IUSBDeviceFilter`\n            USB device filter to insert.\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Virtual machine is not mutable.\n        \n        raises :class:`OleErrorInvalidarg`\n            USB device filter not created within this VirtualBox instance.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            USB device filter already in list.\n        \n        \"\"\"\n        if not isinstance(position, baseinteger):\n            raise TypeError(\"position can only be an instance of type baseinteger\")\n        if not isinstance(filter_p, IUSBDeviceFilter):\n            raise TypeError(\"filter_p can only be an instance of type IUSBDeviceFilter\")\n        self._call(\"insertDeviceFilter\",\n                     in_p=[position, filter_p])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nassigning the machine object associated with this direct - type session or informs the session that it will be a remote one.", "response": "def assign_machine(self, machine, lock_type, token):\n        \"\"\"Assigns the machine object associated with this direct-type\n        session or informs the session that it will be a remote one\n        (if @a machine == @c null).\n\n        in machine of type :class:`IMachine`\n\n        in lock_type of type :class:`LockType`\n\n        in token of type :class:`IToken`\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Session state prevents operation.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Session type prevents operation.\n        \n        \"\"\"\n        if not isinstance(machine, IMachine):\n            raise TypeError(\"machine can only be an instance of type IMachine\")\n        if not isinstance(lock_type, LockType):\n            raise TypeError(\"lock_type can only be an instance of type LockType\")\n        if not isinstance(token, IToken):\n            raise TypeError(\"token can only be an instance of type IToken\")\n        self._call(\"assignMachine\",\n                     in_p=[machine, lock_type, token])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nassigns the machine and the console object associated with this remote - type session.", "response": "def assign_remote_machine(self, machine, console):\n        \"\"\"Assigns the machine and the (remote) console object associated with\n        this remote-type session.\n\n        in machine of type :class:`IMachine`\n\n        in console of type :class:`IConsole`\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Session state prevents operation.\n        \n        \"\"\"\n        if not isinstance(machine, IMachine):\n            raise TypeError(\"machine can only be an instance of type IMachine\")\n        if not isinstance(console, IConsole):\n            raise TypeError(\"console can only be an instance of type IConsole\")\n        self._call(\"assignRemoteMachine\",\n                     in_p=[machine, console])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the state of the VM process.", "response": "def update_machine_state(self, machine_state):\n        \"\"\"Updates the machine state in the VM process.\n        Must be called only in certain cases\n        (see the method implementation).\n\n        in machine_state of type :class:`MachineState`\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Session state prevents operation.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Session type prevents operation.\n        \n        \"\"\"\n        if not isinstance(machine_state, MachineState):\n            raise TypeError(\"machine_state can only be an instance of type MachineState\")\n        self._call(\"updateMachineState\",\n                     in_p=[machine_state])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntrigger when settings of a network adapter of the virtual machine of the virtual machine of the virtual machine of the specified network adapter have changed.", "response": "def on_network_adapter_change(self, network_adapter, change_adapter):\n        \"\"\"Triggered when settings of a network adapter of the\n        associated virtual machine have changed.\n\n        in network_adapter of type :class:`INetworkAdapter`\n\n        in change_adapter of type bool\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Session state prevents operation.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Session type prevents operation.\n        \n        \"\"\"\n        if not isinstance(network_adapter, INetworkAdapter):\n            raise TypeError(\"network_adapter can only be an instance of type INetworkAdapter\")\n        if not isinstance(change_adapter, bool):\n            raise TypeError(\"change_adapter can only be an instance of type bool\")\n        self._call(\"onNetworkAdapterChange\",\n                     in_p=[network_adapter, change_adapter])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_serial_port_change(self, serial_port):\n        if not isinstance(serial_port, ISerialPort):\n            raise TypeError(\"serial_port can only be an instance of type ISerialPort\")\n        self._call(\"onSerialPortChange\",\n                     in_p=[serial_port])", "response": "Triggered when settings of a serial port of the associated virtual machine of the virtual machine of the specified virtual machine have changed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_medium_change(self, medium_attachment, force):\n        if not isinstance(medium_attachment, IMediumAttachment):\n            raise TypeError(\"medium_attachment can only be an instance of type IMediumAttachment\")\n        if not isinstance(force, bool):\n            raise TypeError(\"force can only be an instance of type bool\")\n        self._call(\"onMediumChange\",\n                     in_p=[medium_attachment, force])", "response": "Triggered when attached media of the virtual machine have changed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_storage_device_change(self, medium_attachment, remove, silent):\n        if not isinstance(medium_attachment, IMediumAttachment):\n            raise TypeError(\"medium_attachment can only be an instance of type IMediumAttachment\")\n        if not isinstance(remove, bool):\n            raise TypeError(\"remove can only be an instance of type bool\")\n        if not isinstance(silent, bool):\n            raise TypeError(\"silent can only be an instance of type bool\")\n        self._call(\"onStorageDeviceChange\",\n                     in_p=[medium_attachment, remove, silent])", "response": "Triggered when the storage devices of the associated virtual machine have changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_vm_process_priority_change(self, priority):\n        if not isinstance(priority, VMProcPriority):\n            raise TypeError(\"priority can only be an instance of type VMProcPriority\")\n        self._call(\"onVMProcessPriorityChange\",\n                     in_p=[priority])", "response": "Triggered when process priority of the associated virtual machine has changed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_clipboard_mode_change(self, clipboard_mode):\n        if not isinstance(clipboard_mode, ClipboardMode):\n            raise TypeError(\"clipboard_mode can only be an instance of type ClipboardMode\")\n        self._call(\"onClipboardModeChange\",\n                     in_p=[clipboard_mode])", "response": "Notification when the shared clipboard mode changes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_dn_d_mode_change(self, dnd_mode):\n        if not isinstance(dnd_mode, DnDMode):\n            raise TypeError(\"dnd_mode can only be an instance of type DnDMode\")\n        self._call(\"onDnDModeChange\",\n                     in_p=[dnd_mode])", "response": "Notification when the drag or drop mode changes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_cpu_change(self, cpu, add):\n        if not isinstance(cpu, baseinteger):\n            raise TypeError(\"cpu can only be an instance of type baseinteger\")\n        if not isinstance(add, bool):\n            raise TypeError(\"add can only be an instance of type bool\")\n        self._call(\"onCPUChange\",\n                     in_p=[cpu, add])", "response": "Notification when a CPU changes in the base CPU."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_cpu_execution_cap_change(self, execution_cap):\n        if not isinstance(execution_cap, baseinteger):\n            raise TypeError(\"execution_cap can only be an instance of type baseinteger\")\n        self._call(\"onCPUExecutionCapChange\",\n                     in_p=[execution_cap])", "response": "Notification when the CPU execution cap changes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_vrde_server_change(self, restart):\n        if not isinstance(restart, bool):\n            raise TypeError(\"restart can only be an instance of type bool\")\n        self._call(\"onVRDEServerChange\",\n                     in_p=[restart])", "response": "Triggered when settings of the VRDE server object of the associated virtual machine of the specified virtual machine have changed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_recording_change(self, enable):\n        if not isinstance(enable, bool):\n            raise TypeError(\"enable can only be an instance of type bool\")\n        self._call(\"onRecordingChange\",\n                     in_p=[enable])", "response": "Triggered when recording settings have changed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntriggering when a permanent shared folder has been created or removed.", "response": "def on_shared_folder_change(self, global_p):\n        \"\"\"Triggered when a permanent (global or machine) shared folder has been\n        created or removed.\n        \n        We don't pass shared folder parameters in this notification because\n        the order in which parallel notifications are delivered is not defined,\n        therefore it could happen that these parameters were outdated by the\n        time of processing this notification.\n\n        in global_p of type bool\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Session state prevents operation.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Session type prevents operation.\n        \n        \"\"\"\n        if not isinstance(global_p, bool):\n            raise TypeError(\"global_p can only be an instance of type bool\")\n        self._call(\"onSharedFolderChange\",\n                     in_p=[global_p])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_usb_device_attach(self, device, error, masked_interfaces, capture_filename):\n        if not isinstance(device, IUSBDevice):\n            raise TypeError(\"device can only be an instance of type IUSBDevice\")\n        if not isinstance(error, IVirtualBoxErrorInfo):\n            raise TypeError(\"error can only be an instance of type IVirtualBoxErrorInfo\")\n        if not isinstance(masked_interfaces, baseinteger):\n            raise TypeError(\"masked_interfaces can only be an instance of type baseinteger\")\n        if not isinstance(capture_filename, basestring):\n            raise TypeError(\"capture_filename can only be an instance of type basestring\")\n        self._call(\"onUSBDeviceAttach\",\n                     in_p=[device, error, masked_interfaces, capture_filename])", "response": "Triggered when a request to attach a USB device to a new entry in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntriggering when a request to detach the USB device is completed.", "response": "def on_usb_device_detach(self, id_p, error):\n        \"\"\"Triggered when a request to release the USB device (as a result\n        of machine termination or direct call to\n        :py:func:`IConsole.detach_usb_device` ) has completed.\n        A @c null @a error object means success, otherwise it\n        describes a failure.\n\n        in id_p of type str\n\n        in error of type :class:`IVirtualBoxErrorInfo`\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Session state prevents operation.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Session type prevents operation.\n        \n        \"\"\"\n        if not isinstance(id_p, basestring):\n            raise TypeError(\"id_p can only be an instance of type basestring\")\n        if not isinstance(error, IVirtualBoxErrorInfo):\n            raise TypeError(\"error can only be an instance of type IVirtualBoxErrorInfo\")\n        self._call(\"onUSBDeviceDetach\",\n                     in_p=[id_p, error])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_show_window(self, check):\n        if not isinstance(check, bool):\n            raise TypeError(\"check can only be an instance of type bool\")\n        (can_show, win_id) = self._call(\"onShowWindow\",\n                     in_p=[check])\n        return (can_show, win_id)", "response": "Called by VBox when the console window is shown."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef access_guest_property(self, name, value, flags, access_mode):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(value, basestring):\n            raise TypeError(\"value can only be an instance of type basestring\")\n        if not isinstance(flags, basestring):\n            raise TypeError(\"flags can only be an instance of type basestring\")\n        if not isinstance(access_mode, baseinteger):\n            raise TypeError(\"access_mode can only be an instance of type baseinteger\")\n        (ret_value, ret_timestamp, ret_flags) = self._call(\"accessGuestProperty\",\n                     in_p=[name, value, flags, access_mode])\n        return (ret_value, ret_timestamp, ret_flags)", "response": "Access the guest property of a specific entry in the virtual machine."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef online_merge_medium(self, medium_attachment, source_idx, target_idx, progress):\n        if not isinstance(medium_attachment, IMediumAttachment):\n            raise TypeError(\"medium_attachment can only be an instance of type IMediumAttachment\")\n        if not isinstance(source_idx, baseinteger):\n            raise TypeError(\"source_idx can only be an instance of type baseinteger\")\n        if not isinstance(target_idx, baseinteger):\n            raise TypeError(\"target_idx can only be an instance of type baseinteger\")\n        if not isinstance(progress, IProgress):\n            raise TypeError(\"progress can only be an instance of type IProgress\")\n        self._call(\"onlineMergeMedium\",\n                     in_p=[medium_attachment, source_idx, target_idx, progress])", "response": "Triggers online merging of a medium."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reconfigure_medium_attachments(self, attachments):\n        if not isinstance(attachments, list):\n            raise TypeError(\"attachments can only be an instance of type list\")\n        for a in attachments[:10]:\n            if not isinstance(a, IMediumAttachment):\n                raise TypeError(\n                        \"array can only contain objects of type IMediumAttachment\")\n        self._call(\"reconfigureMediumAttachments\",\n                     in_p=[attachments])", "response": "Reconfigure all specified medium attachments in one go making sure that the current state corresponds to the specified medium."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenabling or disables collection of VMM RAM statistics.", "response": "def enable_vmm_statistics(self, enable):\n        \"\"\"Enables or disables collection of VMM RAM statistics.\n\n        in enable of type bool\n            True enables statistics collection.\n\n        raises :class:`VBoxErrorInvalidVmState`\n            Machine session is not open.\n        \n        raises :class:`VBoxErrorInvalidObjectState`\n            Session type is not direct.\n        \n        \"\"\"\n        if not isinstance(enable, bool):\n            raise TypeError(\"enable can only be an instance of type bool\")\n        self._call(\"enableVMMStatistics\",\n                     in_p=[enable])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resume_with_reason(self, reason):\n        if not isinstance(reason, Reason):\n            raise TypeError(\"reason can only be an instance of type Reason\")\n        self._call(\"resumeWithReason\",\n                     in_p=[reason])", "response": "Resumes a VM with a specified reason code."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_metrics(self, metric_names, objects):\n        if not isinstance(metric_names, list):\n            raise TypeError(\"metric_names can only be an instance of type list\")\n        for a in metric_names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(objects, list):\n            raise TypeError(\"objects can only be an instance of type list\")\n        for a in objects[:10]:\n            if not isinstance(a, Interface):\n                raise TypeError(\n                        \"array can only contain objects of type Interface\")\n        metrics = self._call(\"getMetrics\",\n                     in_p=[metric_names, objects])\n        metrics = [IPerformanceMetric(a) for a in metrics]\n        return metrics", "response": "Returns the parameters of specified metrics for a set of objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the parameters of specified base metrics for a set of objects. Returns an array of IPerformanceMetric objects that have been affected.", "response": "def setup_metrics(self, metric_names, objects, period, count):\n        \"\"\"Sets parameters of specified base metrics for a set of objects. Returns\n        an array of :py:class:`IPerformanceMetric`  describing the metrics\n        have been affected.\n        \n        @c Null or empty metric name array means all metrics. @c Null or\n        empty object array means all existing objects. If metric name array\n        contains a single element and object array contains many, the single\n        metric name array element is applied to each object array element to\n        form metric/object pairs.\n\n        in metric_names of type str\n            Metric name filter. Comma-separated list of metrics with wildcard\n            support.\n\n        in objects of type Interface\n            Set of objects to setup metric parameters for.\n\n        in period of type int\n            Time interval in seconds between two consecutive samples of\n            performance data.\n\n        in count of type int\n            Number of samples to retain in performance data history. Older\n            samples get discarded.\n\n        return affected_metrics of type :class:`IPerformanceMetric`\n            Array of metrics that have been modified by the call to this method.\n\n        \"\"\"\n        if not isinstance(metric_names, list):\n            raise TypeError(\"metric_names can only be an instance of type list\")\n        for a in metric_names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(objects, list):\n            raise TypeError(\"objects can only be an instance of type list\")\n        for a in objects[:10]:\n            if not isinstance(a, Interface):\n                raise TypeError(\n                        \"array can only contain objects of type Interface\")\n        if not isinstance(period, baseinteger):\n            raise TypeError(\"period can only be an instance of type baseinteger\")\n        if not isinstance(count, baseinteger):\n            raise TypeError(\"count can only be an instance of type baseinteger\")\n        affected_metrics = self._call(\"setupMetrics\",\n                     in_p=[metric_names, objects, period, count])\n        affected_metrics = [IPerformanceMetric(a) for a in affected_metrics]\n        return affected_metrics"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nturn on collecting specified base metrics. Returns an array of IPerformanceMetric objects that have been modified by this method.", "response": "def enable_metrics(self, metric_names, objects):\n        \"\"\"Turns on collecting specified base metrics. Returns an array of\n        :py:class:`IPerformanceMetric`  describing the metrics have been\n        affected.\n        \n        @c Null or empty metric name array means all metrics. @c Null or\n        empty object array means all existing objects. If metric name array\n        contains a single element and object array contains many, the single\n        metric name array element is applied to each object array element to\n        form metric/object pairs.\n\n        in metric_names of type str\n            Metric name filter. Comma-separated list of metrics with wildcard\n            support.\n\n        in objects of type Interface\n            Set of objects to enable metrics for.\n\n        return affected_metrics of type :class:`IPerformanceMetric`\n            Array of metrics that have been modified by the call to this method.\n\n        \"\"\"\n        if not isinstance(metric_names, list):\n            raise TypeError(\"metric_names can only be an instance of type list\")\n        for a in metric_names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(objects, list):\n            raise TypeError(\"objects can only be an instance of type list\")\n        for a in objects[:10]:\n            if not isinstance(a, Interface):\n                raise TypeError(\n                        \"array can only contain objects of type Interface\")\n        affected_metrics = self._call(\"enableMetrics\",\n                     in_p=[metric_names, objects])\n        affected_metrics = [IPerformanceMetric(a) for a in affected_metrics]\n        return affected_metrics"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef query_metrics_data(self, metric_names, objects):\n        if not isinstance(metric_names, list):\n            raise TypeError(\"metric_names can only be an instance of type list\")\n        for a in metric_names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(objects, list):\n            raise TypeError(\"objects can only be an instance of type list\")\n        for a in objects[:10]:\n            if not isinstance(a, Interface):\n                raise TypeError(\n                        \"array can only contain objects of type Interface\")\n        (return_data, return_metric_names, return_objects, return_units, return_scales, return_sequence_numbers, return_data_indices, return_data_lengths) = self._call(\"queryMetricsData\",\n                     in_p=[metric_names, objects])\n        return_objects = [Interface(a) for a in return_objects]\n        return (return_data, return_metric_names, return_objects, return_units, return_scales, return_sequence_numbers, return_data_indices, return_data_lengths)", "response": "Queries collected metrics data for a set of objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the network settings of the current NAT engine.", "response": "def set_network_settings(self, mtu, sock_snd, sock_rcv, tcp_wnd_snd, tcp_wnd_rcv):\n        \"\"\"Sets network configuration of the NAT engine.\n\n        in mtu of type int\n            MTU (maximum transmission unit) of the NAT engine in bytes.\n\n        in sock_snd of type int\n            Capacity of the socket send buffer in bytes when creating a new socket.\n\n        in sock_rcv of type int\n            Capacity of the socket receive buffer in bytes when creating a new socket.\n\n        in tcp_wnd_snd of type int\n            Initial size of the NAT engine's sending TCP window in bytes when\n            establishing a new TCP connection.\n\n        in tcp_wnd_rcv of type int\n            Initial size of the NAT engine's receiving TCP window in bytes when\n            establishing a new TCP connection.\n\n        \"\"\"\n        if not isinstance(mtu, baseinteger):\n            raise TypeError(\"mtu can only be an instance of type baseinteger\")\n        if not isinstance(sock_snd, baseinteger):\n            raise TypeError(\"sock_snd can only be an instance of type baseinteger\")\n        if not isinstance(sock_rcv, baseinteger):\n            raise TypeError(\"sock_rcv can only be an instance of type baseinteger\")\n        if not isinstance(tcp_wnd_snd, baseinteger):\n            raise TypeError(\"tcp_wnd_snd can only be an instance of type baseinteger\")\n        if not isinstance(tcp_wnd_rcv, baseinteger):\n            raise TypeError(\"tcp_wnd_rcv can only be an instance of type baseinteger\")\n        self._call(\"setNetworkSettings\",\n                     in_p=[mtu, sock_snd, sock_rcv, tcp_wnd_snd, tcp_wnd_rcv])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the network configuration of NAT engine. See set_network_settings for parameter descriptions.", "response": "def get_network_settings(self):\n        \"\"\"Returns network configuration of NAT engine. See :py:func:`set_network_settings` \n        for parameter descriptions.\n\n        out mtu of type int\n\n        out sock_snd of type int\n\n        out sock_rcv of type int\n\n        out tcp_wnd_snd of type int\n\n        out tcp_wnd_rcv of type int\n\n        \"\"\"\n        (mtu, sock_snd, sock_rcv, tcp_wnd_snd, tcp_wnd_rcv) = self._call(\"getNetworkSettings\")\n        return (mtu, sock_snd, sock_rcv, tcp_wnd_snd, tcp_wnd_rcv)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_redirect(self, name, proto, host_ip, host_port, guest_ip, guest_port):\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(proto, NATProtocol):\n            raise TypeError(\"proto can only be an instance of type NATProtocol\")\n        if not isinstance(host_ip, basestring):\n            raise TypeError(\"host_ip can only be an instance of type basestring\")\n        if not isinstance(host_port, baseinteger):\n            raise TypeError(\"host_port can only be an instance of type baseinteger\")\n        if not isinstance(guest_ip, basestring):\n            raise TypeError(\"guest_ip can only be an instance of type basestring\")\n        if not isinstance(guest_port, baseinteger):\n            raise TypeError(\"guest_port can only be an instance of type baseinteger\")\n        self._call(\"addRedirect\",\n                     in_p=[name, proto, host_ip, host_port, guest_ip, guest_port])", "response": "Adds a new port - forwarding rule."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove a port - forwarding rule that was previously registered.", "response": "def remove_redirect(self, name):\n        \"\"\"Removes a port-forwarding rule that was previously registered.\n\n        in name of type str\n            The name of the rule to delete.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        self._call(\"removeRedirect\",\n                     in_p=[name])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query_license(self, preferred_locale, preferred_language, format_p):\n        if not isinstance(preferred_locale, basestring):\n            raise TypeError(\"preferred_locale can only be an instance of type basestring\")\n        if not isinstance(preferred_language, basestring):\n            raise TypeError(\"preferred_language can only be an instance of type basestring\")\n        if not isinstance(format_p, basestring):\n            raise TypeError(\"format_p can only be an instance of type basestring\")\n        license_text = self._call(\"queryLicense\",\n                     in_p=[preferred_locale, preferred_language, format_p])\n        return license_text", "response": "Query the license text for the specified locale and language."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query_object(self, obj_uuid):\n        if not isinstance(obj_uuid, basestring):\n            raise TypeError(\"obj_uuid can only be an instance of type basestring\")\n        return_interface = self._call(\"queryObject\",\n                     in_p=[obj_uuid])\n        return_interface = Interface(return_interface)\n        return return_interface", "response": "Queries the IUnknown interface to an object in the extension pack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef install(self, replace, display_info):\n        if not isinstance(replace, bool):\n            raise TypeError(\"replace can only be an instance of type bool\")\n        if not isinstance(display_info, basestring):\n            raise TypeError(\"display_info can only be an instance of type basestring\")\n        progess = self._call(\"install\",\n                     in_p=[replace, display_info])\n        progess = IProgress(progess)\n        return progess", "response": "Installs the extension pack with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the extension pack with the specified name if found.", "response": "def find(self, name):\n        \"\"\"Returns the extension pack with the specified name if found.\n\n        in name of type str\n            The name of the extension pack to locate.\n\n        return return_data of type :class:`IExtPack`\n            The extension pack if found.\n\n        raises :class:`VBoxErrorObjectNotFound`\n            No extension pack matching @a name was found.\n        \n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        return_data = self._call(\"find\",\n                     in_p=[name])\n        return_data = IExtPack(return_data)\n        return return_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nattempt to open an extension pack file in preparation for the extension pack file installation.", "response": "def open_ext_pack_file(self, path):\n        \"\"\"Attempts to open an extension pack file in preparation for\n        installation.\n\n        in path of type str\n            The path of the extension pack tarball. This can optionally be\n            followed by a \"::SHA-256=hex-digit\" of the tarball.\n\n        return file_p of type :class:`IExtPackFile`\n            The interface of the extension pack file object.\n\n        \"\"\"\n        if not isinstance(path, basestring):\n            raise TypeError(\"path can only be an instance of type basestring\")\n        file_p = self._call(\"openExtPackFile\",\n                     in_p=[path])\n        file_p = IExtPackFile(file_p)\n        return file_p"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef query_all_plug_ins_for_frontend(self, frontend_name):\n        if not isinstance(frontend_name, basestring):\n            raise TypeError(\"frontend_name can only be an instance of type basestring\")\n        plug_in_modules = self._call(\"queryAllPlugInsForFrontend\",\n                     in_p=[frontend_name])\n        return plug_in_modules", "response": "Returns the full path to all the plug - in modules for a given frontend."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the given extension pack is loaded and usable.", "response": "def is_ext_pack_usable(self, name):\n        \"\"\"Check if the given extension pack is loaded and usable.\n\n        in name of type str\n            The name of the extension pack to check for.\n\n        return usable of type bool\n            Is the given extension pack loaded and usable.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        usable = self._call(\"isExtPackUsable\",\n                     in_p=[name])\n        return usable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new bandwidth group.", "response": "def create_bandwidth_group(self, name, type_p, max_bytes_per_sec):\n        \"\"\"Creates a new bandwidth group.\n\n        in name of type str\n            Name of the bandwidth group.\n\n        in type_p of type :class:`BandwidthGroupType`\n            The type of the bandwidth group (network or disk).\n\n        in max_bytes_per_sec of type int\n            The maximum number of bytes which can be transfered by all\n            entities attached to this group during one second.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        if not isinstance(type_p, BandwidthGroupType):\n            raise TypeError(\"type_p can only be an instance of type BandwidthGroupType\")\n        if not isinstance(max_bytes_per_sec, baseinteger):\n            raise TypeError(\"max_bytes_per_sec can only be an instance of type baseinteger\")\n        self._call(\"createBandwidthGroup\",\n                     in_p=[name, type_p, max_bytes_per_sec])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes a new bandwidth group.", "response": "def delete_bandwidth_group(self, name):\n        \"\"\"Deletes a new bandwidth group.\n\n        in name of type str\n            Name of the bandwidth group to delete.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        self._call(\"deleteBandwidthGroup\",\n                     in_p=[name])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a bandwidth group by name.", "response": "def get_bandwidth_group(self, name):\n        \"\"\"Get a bandwidth group by name.\n\n        in name of type str\n            Name of the bandwidth group to get.\n\n        return bandwidth_group of type :class:`IBandwidthGroup`\n            Where to store the bandwidth group on success.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        bandwidth_group = self._call(\"getBandwidthGroup\",\n                     in_p=[name])\n        bandwidth_group = IBandwidthGroup(bandwidth_group)\n        return bandwidth_group"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all managed bandwidth groups.", "response": "def get_all_bandwidth_groups(self):\n        \"\"\"Get all managed bandwidth groups.\n\n        return bandwidth_groups of type :class:`IBandwidthGroup`\n            The array of managed bandwidth groups.\n\n        \"\"\"\n        bandwidth_groups = self._call(\"getAllBandwidthGroups\")\n        bandwidth_groups = [IBandwidthGroup(a) for a in bandwidth_groups]\n        return bandwidth_groups"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a machine is not available.", "response": "def check_machine_error(self, machine):\n        \"\"\"Perform error checking before using an :py:class:`IMachine`  object.\n        Generally useful before starting a VM and all other uses. If anything\n        is not as it should be then this method will return an appropriate\n        error.\n\n        in machine of type :class:`IMachine`\n            The machine object to check.\n\n        \"\"\"\n        if not isinstance(machine, IMachine):\n            raise TypeError(\"machine can only be an instance of type IMachine\")\n        self._call(\"checkMachineError\",\n                     in_p=[machine])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an aggregator event source for the specified set of subordinates.", "response": "def create_aggregator(self, subordinates):\n        \"\"\"Creates an aggregator event source, collecting events from multiple sources.\n        This way a single listener can listen for events coming from multiple sources,\n        using a single blocking :py:func:`get_event`  on the returned aggregator.\n\n        in subordinates of type :class:`IEventSource`\n            Subordinate event source this one aggregates.\n\n        return result of type :class:`IEventSource`\n            Event source aggregating passed sources.\n\n        \"\"\"\n        if not isinstance(subordinates, list):\n            raise TypeError(\"subordinates can only be an instance of type list\")\n        for a in subordinates[:10]:\n            if not isinstance(a, IEventSource):\n                raise TypeError(\n                        \"array can only contain objects of type IEventSource\")\n        result = self._call(\"createAggregator\",\n                     in_p=[subordinates])\n        result = IEventSource(result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister an event listener. To avoid system overload, the VirtualBox server process checks if passive event listeners call :py:func:`IEventSource.get_event` frequently enough. In the current implementation, if more than 500 pending events are detected for a passive event listener, it is forcefully unregistered by the system, and further :py:func:`get_event` calls will return @c VBOX_E_OBJECT_NOT_FOUND. in listener of type :class:`IEventListener` Listener to register. in interesting of type :class:`VBoxEventType` Event types listener is interested in. One can use wildcards like - :py:attr:`VBoxEventType.any_p` to specify wildcards, matching more than one event. in active of type bool Which mode this listener is operating in. In active mode, :py:func:`IEventListener.handle_event` is called directly. In passive mode, an internal event queue is created for this this IEventListener. For each event coming in, it is added to queues for all interested registered passive listeners. It is then up to the external code to call the listener's :py:func:`IEventListener.handle_event` method. When done with an event, the external code must call :py:func:`event_processed` .", "response": "def register_listener(self, listener, interesting, active):\n        \"\"\"Register an event listener.\n        \n        \n        To avoid system overload, the VirtualBox server process checks if passive event\n        listeners call :py:func:`IEventSource.get_event`  frequently enough. In the\n        current implementation, if more than 500 pending events are detected for a passive\n        event listener, it is forcefully unregistered by the system, and further\n        :py:func:`get_event`  calls will return @c VBOX_E_OBJECT_NOT_FOUND.\n\n        in listener of type :class:`IEventListener`\n            Listener to register.\n\n        in interesting of type :class:`VBoxEventType`\n            Event types listener is interested in. One can use wildcards like -\n            :py:attr:`VBoxEventType.any_p`  to specify wildcards, matching more\n            than one event.\n\n        in active of type bool\n            Which mode this listener is operating in.\n            In active mode, :py:func:`IEventListener.handle_event`  is called directly.\n            In passive mode, an internal event queue is created for this this IEventListener.\n            For each event coming in, it is added to queues for all interested registered passive\n            listeners. It is then up to the external code to call the listener's\n            :py:func:`IEventListener.handle_event`  method. When done with an event, the\n            external code must call :py:func:`event_processed` .\n\n        \"\"\"\n        if not isinstance(listener, IEventListener):\n            raise TypeError(\"listener can only be an instance of type IEventListener\")\n        if not isinstance(interesting, list):\n            raise TypeError(\"interesting can only be an instance of type list\")\n        for a in interesting[:10]:\n            if not isinstance(a, VBoxEventType):\n                raise TypeError(\n                        \"array can only contain objects of type VBoxEventType\")\n        if not isinstance(active, bool):\n            raise TypeError(\"active can only be an instance of type bool\")\n        self._call(\"registerListener\",\n                     in_p=[listener, interesting, active])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unregister_listener(self, listener):\n        if not isinstance(listener, IEventListener):\n            raise TypeError(\"listener can only be an instance of type IEventListener\")\n        self._call(\"unregisterListener\",\n                     in_p=[listener])", "response": "Unregister an event listener."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fire_event(self, event, timeout):\n        if not isinstance(event, IEvent):\n            raise TypeError(\"event can only be an instance of type IEvent\")\n        if not isinstance(timeout, baseinteger):\n            raise TypeError(\"timeout can only be an instance of type baseinteger\")\n        result = self._call(\"fireEvent\",\n                     in_p=[event, timeout])\n        return result", "response": "Fire an event for this source."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_event(self, listener, timeout):\n        if not isinstance(listener, IEventListener):\n            raise TypeError(\"listener can only be an instance of type IEventListener\")\n        if not isinstance(timeout, baseinteger):\n            raise TypeError(\"timeout can only be an instance of type baseinteger\")\n        event = self._call(\"getEvent\",\n                     in_p=[listener, timeout])\n        event = IEvent(event)\n        return event", "response": "Get an event from this peer s event queue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef event_processed(self, listener, event):\n        if not isinstance(listener, IEventListener):\n            raise TypeError(\"listener can only be an instance of type IEventListener\")\n        if not isinstance(event, IEvent):\n            raise TypeError(\"event can only be an instance of type IEvent\")\n        self._call(\"eventProcessed\",\n                     in_p=[listener, event])", "response": "Called by the event processing thread when a particular event has been processed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle event callback for active listeners. It is not called for passive listeners. After calling :py:func:`handle_event` on all active listeners and having received acknowledgement from all passive listeners via :py:func:`IEventSource.event_processed` , the event is marked as processed and :py:func:`IEvent.wait_processed` will return immediately. in event of type :class:`IEvent` Event available.", "response": "def handle_event(self, event):\n        \"\"\"Handle event callback for active listeners. It is not called for\n        passive listeners. After calling :py:func:`handle_event`  on all active listeners\n        and having received acknowledgement from all passive listeners via\n        :py:func:`IEventSource.event_processed` , the event is marked as\n        processed and :py:func:`IEvent.wait_processed`  will return\n        immediately.\n\n        in event of type :class:`IEvent`\n            Event available.\n\n        \"\"\"\n        if not isinstance(event, IEvent):\n            raise TypeError(\"event can only be an instance of type IEvent\")\n        self._call(\"handleEvent\",\n                     in_p=[event])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwaiting until time outs or this event is processed.", "response": "def wait_processed(self, timeout):\n        \"\"\"Wait until time outs, or this event is processed. Event must be waitable for this operation to have\n        described semantics, for non-waitable returns true immediately.\n\n        in timeout of type int\n            Maximum time to wait for event processing, in ms;\n            0 = no wait, -1 = indefinite wait.\n\n        return result of type bool\n            If this event was processed before timeout.\n\n        \"\"\"\n        if not isinstance(timeout, baseinteger):\n            raise TypeError(\"timeout can only be an instance of type baseinteger\")\n        result = self._call(\"waitProcessed\",\n                     in_p=[timeout])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a veto to this event.", "response": "def add_veto(self, reason):\n        \"\"\"Adds a veto on this event.\n\n        in reason of type str\n            Reason for veto, could be null or empty string.\n\n        \"\"\"\n        if not isinstance(reason, basestring):\n            raise TypeError(\"reason can only be an instance of type basestring\")\n        self._call(\"addVeto\",\n                     in_p=[reason])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an approval on this event.", "response": "def add_approval(self, reason):\n        \"\"\"Adds an approval on this event.\n\n        in reason of type str\n            Reason for approval, could be null or empty string.\n\n        \"\"\"\n        if not isinstance(reason, basestring):\n            raise TypeError(\"reason can only be an instance of type basestring\")\n        self._call(\"addApproval\",\n                     in_p=[reason])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef export_launch_vm(self, description, progress, virtual_box):\n        if not isinstance(description, IVirtualSystemDescription):\n            raise TypeError(\"description can only be an instance of type IVirtualSystemDescription\")\n        if not isinstance(progress, IProgress):\n            raise TypeError(\"progress can only be an instance of type IProgress\")\n        if not isinstance(virtual_box, IVirtualBox):\n            raise TypeError(\"virtual_box can only be an instance of type IVirtualBox\")\n        self._call(\"exportLaunchVM\",\n                     in_p=[description, progress, virtual_box])", "response": "Exports and optionally launch a VM described in description parameter\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_export_launch_description_form(self):\n        (progress, form) = self._call(\"getExportLaunchDescriptionForm\")\n        progress = IProgress(progress)\n        form = IVirtualSystemDescriptionForm(form)\n        return (progress, form)", "response": "Returns a progress object and the virtual system description form for editing the virtual system description."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the list of the instances in the Cloud.", "response": "def list_instances(self, machine_state):\n        \"\"\"Returns the list of the instances in the Cloud.\n\n        in machine_state of type :class:`CloudMachineState`\n\n        out return_names of type str\n            VM names.\n\n        return return_ids of type str\n            VM ids.\n\n        \"\"\"\n        if not isinstance(machine_state, CloudMachineState):\n            raise TypeError(\"machine_state can only be an instance of type CloudMachineState\")\n        (return_ids, return_names) = self._call(\"listInstances\",\n                     in_p=[machine_state])\n        return (return_ids, return_names)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_images(self, image_state):\n        if not isinstance(image_state, CloudImageState):\n            raise TypeError(\"image_state can only be an instance of type CloudImageState\")\n        (return_ids, return_names) = self._call(\"listImages\",\n                     in_p=[image_state])\n        return (return_ids, return_names)", "response": "Returns the list of the images in the Cloud."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the description of a property.", "response": "def get_property_description(self, name):\n        \"\"\"Property name.\n\n        in name of type str\n            Property name.\n\n        return description of type str\n            Property description.\n\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError(\"name can only be an instance of type basestring\")\n        description = self._call(\"getPropertyDescription\",\n                     in_p=[name])\n        return description"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_profile(self, profile_name, names, values):\n        if not isinstance(profile_name, basestring):\n            raise TypeError(\"profile_name can only be an instance of type basestring\")\n        if not isinstance(names, list):\n            raise TypeError(\"names can only be an instance of type list\")\n        for a in names[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        if not isinstance(values, list):\n            raise TypeError(\"values can only be an instance of type list\")\n        for a in values[:10]:\n            if not isinstance(a, basestring):\n                raise TypeError(\n                        \"array can only contain objects of type basestring\")\n        self._call(\"createProfile\",\n                     in_p=[profile_name, names, values])", "response": "Creates a new profile with the specified names and values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the callback function to consume on guest mouse events.", "response": "def register_on_guest_mouse(self, callback):\n        \"\"\"Set the callback function to consume on guest mouse events.\n\n        Callback receives a IGuestMouseEvent object.\n\n        Example:\n            def callback(event):\n                print((\"%s %s %s\" % (event.x, event.y, event.z))\n        \"\"\"\n        event_type = library.VBoxEventType.on_guest_mouse\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef put_keys(self, press_keys=None, hold_keys=None, press_delay=50):\n        if press_keys is None:\n            press_keys = []\n        if hold_keys is None:\n            hold_keys = []\n\n        release_codes = set()\n        put_codes = set()\n        try:\n            # hold the keys\n            for k in hold_keys:\n                put, release = self.SCANCODES[k]\n                # Avoid putting codes over and over\n                put = set(put) - put_codes\n                self.put_scancodes(list(put))\n                put_codes.update(put)\n                release_codes.update(release)\n            # press the keys\n            for k in press_keys:\n                put, release = self.SCANCODES[k]\n                # Avoid putting held codes\n                _put = set(put) - put_codes\n                if not _put:\n                    continue\n                release = set(release) - release_codes\n                # Avoid releasing held codes\n                if not release:\n                    continue\n                self.put_scancodes(list(put) + list(release))\n                time.sleep(press_delay / 1000.0)\n        finally:\n            # release the held keys\n            for code in release_codes:\n                self.put_scancode(code)", "response": "Put the keys in the sequence of keys in the sequence of keys in hold_keys."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the callback function to consume on guest keyboard events", "response": "def register_on_guest_keyboard(self, callback):\n        \"\"\"Set the callback function to consume on guest keyboard events\n\n        Callback receives a IGuestKeyboardEvent object.\n\n        Example:\n            def callback(event):\n                print(event.scancodes)\n        \"\"\"\n        return self.event_source.register_callback(callback,\n                                                   library.VBoxEventType.on_guest_keyboard)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes a command in the Guest and returns the IProcess stdout and stderr.", "response": "def execute(self, command, arguments=None, stdin=\"\", environment=None,\n                flags=None, priority=library.ProcessPriority.default,\n                affinity=None, timeout_ms=0):\n        \"\"\"Execute a command in the Guest\n\n            Arguments:\n                command - Command to execute.\n                arguments - List of arguments for the command\n                stdin - A buffer to write to the stdin of the command.\n                environment - See IGuestSession.create_process?\n                flags - List of ProcessCreateFlag objects.\n                    Default value set to [wait_for_std_err,\n                                          wait_for_stdout,\n                                          ignore_orphaned_processes]\n                timeout_ms - ms to wait for the process to complete.\n                    If 0, wait for ever...\n                priority - Set the ProcessPriority priority to be used for\n                    execution.\n                affinity - Process affinity to use for execution.\n\n            Return IProcess, stdout, stderr\n        \"\"\"\n        if arguments is None:\n            arguments = []\n        if environment is None:\n            environment = []\n        if flags is None:\n            flags = [library.ProcessCreateFlag.wait_for_std_err,\n                     library.ProcessCreateFlag.wait_for_std_out,\n                     library.ProcessCreateFlag.ignore_orphaned_processes]\n        if affinity is None:\n            affinity = []\n\n        def read_out(process, flags, stdout, stderr):\n            if library.ProcessCreateFlag.wait_for_std_err in flags:\n                process.wait_for(int(library.ProcessWaitResult.std_err))\n                e = utils.to_bytes(process.read(2, 65000, 0))\n                stderr.append(e)\n            if library.ProcessCreateFlag.wait_for_std_out in flags:\n                process.wait_for(int(library.ProcessWaitResult.std_out))\n                o = utils.to_bytes(process.read(1, 65000, 0))\n                stdout.append(o)\n\n        process = self.process_create_ex(command,\n                                         [command] + arguments, environment,\n                                         flags,\n                                         timeout_ms,\n                                         priority,\n                                         affinity)\n\n        process.wait_for(int(library.ProcessWaitResult.start), 0)\n\n        # write stdin to the process\n        if stdin:\n            process.wait_for(int(library.ProcessWaitResult.std_in), 0)\n            index = 0\n            flag_none = [library.ProcessInputFlag.none]\n            flag_eof = [library.ProcessInputFlag.end_of_file]\n            while index < len(stdin):\n                array = map(lambda a: str(ord(a)), stdin[index:])\n                wrote = process.write_array(0, flag_none, array, 0)\n                if wrote == 0:\n                    raise Exception(\"Failed to write ANY bytes to %s\" % process)\n                index += wrote\n            process.write_array(0, flag_eof, [], 0)\n\n        # read the process output and wait for\n        stdout = []\n        stderr = []\n        while process.status == library.ProcessStatus.started:\n            read_out(process, flags, stdout, stderr)\n            time.sleep(0.2)\n        # make sure we have read the remainder of the out\n        read_out(process, flags, stdout, stderr)\n\n        return process, b\"\".join(stdout), b\"\".join(stderr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntest if path exists", "response": "def path_exists(self, path, follow_symlinks=True):\n        \"test if path exists\"\n        return (\n            self.file_exists(path, follow_symlinks)\n            or self.symlink_exists(path, follow_symlinks)\n            or self.directory_exists(path, follow_symlinks)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads and interpret ova file into this Appliance object.", "response": "def read(self, ova_path):\n        \"Read and interpret ova file into this Appliance object.\"\n        p = super(IAppliance, self).read(ova_path)\n        p.wait_for_completion()\n        self.interpret()\n        warnings = self.get_warnings()\n        if warnings:\n            warning = Warning(\"\\n\".join(warnings))\n            warning.warnings = warnings\n            raise warning"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_description(self, name):\n        \"Find a description for the given appliance name.\"\n        for desc in self.virtual_system_descriptions:\n            values = desc.get_values_by_type(DescType.name,\n                                             DescValueType.original)\n            if name in values:\n                break\n        else:\n            raise Exception(\"Failed to find description for %s\" % name)\n        return desc", "response": "Find a description for the given appliance name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vbox_version(config_kmk):\n    \"Return the vbox config major, minor, build\"\n    with open(config_kmk, 'rb') as f:\n        config = f.read()\n    major = b\"6\"#re.search(b\"VBOX_VERSION_MAJOR = (?P<major>[\\d])\", config).groupdict()['major']\n    minor = b\"0\"#re.search(b\"VBOX_VERSION_MINOR = (?P<minor>[\\d])\", config).groupdict()['minor']\n    build = b\"4\"#re.search(b\"VBOX_VERSION_BUILD = (?P<build>[\\d])\", config).groupdict()['build']\n    return b\".\".join([major, minor, build])", "response": "Return the vbox config major minor build"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_on_machine_state_changed(self, callback):\n        event_type = library.VBoxEventType.on_machine_state_changed\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on machine state changed events."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the callback function to consume on machine data changed events.", "response": "def register_on_machine_data_changed(self, callback):\n        \"\"\"Set the callback function to consume on machine data changed events.\n\n        Callback receives a IMachineDataChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_machine_data_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_on_machine_registered(self, callback):\n        event_type = library.VBoxEventType.on_machine_registered\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on machine registered events."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the callback function to consume on snapshot deleted events.", "response": "def register_on_snapshot_deleted(self, callback):\n        \"\"\"Set the callback function to consume on snapshot deleted events.\n\n        Callback receives a ISnapshotDeletedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_snapshot_deleted\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_on_snapshot_taken(self, callback):\n        event_type = library.VBoxEventType.on_snapshot_taken\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on snapshot taken events."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_on_snapshot_changed(self, callback):\n        event_type = library.VBoxEventType.on_snapshot_changed\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on snapshot changed events\n        which occur when snapshot properties have been changed. Returns the callback_id that is returned."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_on_guest_property_changed(self, callback):\n        event_type = library.VBoxEventType.on_guest_property_changed\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on guest property changed\n        events."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the callback function to consume on session state changed events.", "response": "def register_on_session_state_changed(self, callback):\n        \"\"\"Set the callback function to consume on session state changed\n        events.\n\n        Callback receives a ISessionStateChangedEvent object.\n\n        Returns the callback_id\n        \"\"\"\n        event_type = library.VBoxEventType.on_session_state_changed\n        return self.event_source.register_callback(callback, event_type)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_on_extra_data_changed(self, callback):\n        event_type = library.VBoxEventType.on_extra_data_changed\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on extra data changed\n        events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_on_extra_data_can_change(self, callback):\n        event_type = library.VBoxEventType.on_extra_data_can_change\n        return self.event_source.register_callback(callback, event_type)", "response": "Set the callback function to consume on extra data changed\n        events."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef type_to_interface(event_type):\n    global _lookup\n    if not isinstance(event_type, library.VBoxEventType):\n        raise TypeError(\"event_type was not of VBoxEventType\")\n    if not _lookup:\n        for attr in dir(library):\n            event_interface = getattr(library, attr)\n            if not inspect.isclass(event_interface):\n                continue\n            if not issubclass(event_interface, library.Interface):\n                continue\n            et = getattr(event_interface, 'id', None)\n            if et is None:\n                continue\n            if not isinstance(et, library.VBoxEventType):\n                continue\n            _lookup[int(et)] = event_interface\n    return _lookup[int(event_type)]", "response": "Return the event interface object that corresponds to the event type\n    enumeration"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a callback function against an event source for a given event type", "response": "def register_callback(callback, event_source, event_type):\n    \"\"\"register a callback function against an event_source for a given\n    event_type.\n\n    Arguments:\n        callback - function to call when the event occurs\n        event_source - the source to monitor events in\n        event_type - the type of event we're monitoring for\n\n    returns the registration id (callback_id)\n    \"\"\"\n    global _callbacks\n    event_interface = type_to_interface(event_type)\n    listener = event_source.create_listener()\n    event_source.register_listener(listener, [event_type], False)\n    quit = threading.Event()\n    t = threading.Thread(target=_event_monitor, args=(callback,\n                                                      event_source,\n                                                      listener,\n                                                      event_interface,\n                                                      quit))\n    t.daemon = True\n    t.start()\n    while t.is_alive() is False:\n        continue\n    _callbacks[t.ident] = (t, quit)\n    return t.ident"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clone(self, snapshot_name_or_id=None,\n              mode=library.CloneMode.machine_state,\n              options=None, name=None,\n              uuid=None, groups=None, basefolder='', register=True):\n        \"\"\"Clone this Machine\n\n        Options:\n            snapshot_name_or_id - value can be either ISnapshot, name, or id\n            mode - set the CloneMode value\n            options - define the CloneOptions options\n            name - define a name of the new VM\n            uuid - set the uuid of the new VM\n            groups - specify which groups the new VM will exist under\n            basefolder - specify which folder to set the VM up under\n            register - register this VM with the server\n\n        Note: Default values create a linked clone from the current machine\n              state\n\n        Return a IMachine object for the newly cloned vm\n        \"\"\"\n        if options is None:\n            options = [library.CloneOptions.link]\n        if groups is None:\n            groups = []\n\n        vbox = virtualbox.VirtualBox()\n\n        if snapshot_name_or_id is not None:\n            if isinstance(snapshot_name_or_id, basestring):\n                snapshot = self.find_snapshot(snapshot_name_or_id)\n            else:\n                snapshot = snapshot_name_or_id\n            vm = snapshot.machine\n        else:\n            # linked clone can only be created from a snapshot...\n            # try grabbing the current_snapshot\n            if library.CloneOptions.link in options:\n                vm = self.current_snapshot.machine\n            else:\n                vm = self\n\n        if name is None:\n            name = \"%s Clone\" % vm.name\n\n        # Build the settings file\n        create_flags = ''\n        if uuid is not None:\n            create_flags = \"UUID=%s\" % uuid\n        primary_group = ''\n        if groups:\n            primary_group = groups[0]\n\n        # Make sure this settings file does not already exist\n        test_name = name\n        settings_file = ''\n        for i in range(1, 1000):\n            settings_file = vbox.compose_machine_filename(test_name,\n                                                          primary_group,\n                                                          create_flags,\n                                                          basefolder)\n            if not os.path.exists(os.path.dirname(settings_file)):\n                break\n            test_name = \"%s (%s)\" % (name, i)\n        name = test_name\n\n        # Create the new machine and clone it!\n        vm_clone = vbox.create_machine(settings_file, name, groups, '', create_flags)\n        progress = vm.clone_to(vm_clone, mode, options)\n        progress.wait_for_completion(-1)\n\n        if register:\n            vbox.register_machine(vm_clone)\n        return vm_clone", "response": "Creates a new VM from this one."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new session object for the specified lock type and returns it.", "response": "def create_session(self, lock_type=library.LockType.shared,\n                       session=None):\n        \"\"\"Lock this machine\n\n        Arguments:\n            lock_type - see IMachine.lock_machine for details\n            session - optionally define a session object to lock this machine\n                      against.  If not defined, a new ISession object is\n                      created to lock against\n\n        return an ISession object\n        \"\"\"\n        if session is None:\n            session = library.ISession()\n        # NOTE: The following hack handles the issue of unknown machine state.\n        #       This occurs most frequently when a machine is powered off and\n        #       in spite waiting for the completion event to end, the state of\n        #       machine still raises the following Error:\n        #          virtualbox.library.VBoxErrorVmError: 0x80bb0003 (Failed to \\\n        #          get a console object from the direct session (Unknown \\\n        #          Status 0x80BB0002))\n        error = None\n        for _ in range(10):\n            try:\n                self.lock_machine(session, lock_type)\n            except Exception as exc:\n                error = exc\n                time.sleep(1)\n                continue\n            else:\n                break\n        else:\n            if error is not None:\n                raise Exception(\"Failed to create clone - %s\" % error)\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_final_value(self, description_type, value):\n        types, _, _, vbox_values, extra_config = self.get_description()\n\n        # find offset to description type\n        for offset, t in enumerate(types):\n            if t == description_type:\n                break\n        else:\n            raise Exception(\"Failed to find type for %s\" % description_type)\n\n        enabled = [True] * len(types)\n        vbox_values = list(vbox_values)\n        extra_config = list(extra_config)\n\n        if isinstance(value, basestring):\n            final_value = value\n        elif isinstance(value, Enum):\n            final_value = str(value._value)\n        elif isinstance(value, int):\n            final_value = str(value)\n        else:\n            raise ValueError(\"Incorrect value type.\")\n\n        vbox_values[offset] = final_value\n        self.set_final_values(enabled, vbox_values, extra_config)", "response": "Set the value for the given description type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef chain_return_value(future, loop, return_value):\n    chained = asyncio.Future(loop=loop)\n\n    def copy(_future):\n        if _future.exception() is not None:\n            chained.set_exception(_future.exception())\n        else:\n            chained.set_result(return_value)\n\n    future._future.add_done_callback(functools.partial(loop.add_callback, copy))\n    return chained", "response": "Compatible way to return a value from a coroutine."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting the coroutine f and wraps its result in a Motor class.", "response": "def pymongo_class_wrapper(f, pymongo_class):\n    \"\"\"Executes the coroutine f and wraps its result in a Motor class.\n\n    See WrapAsync.\n    \"\"\"\n    @functools.wraps(f)\n    @coroutine\n    def _wrapper(self, *args, **kwargs):\n        result = yield f(self, *args, **kwargs)\n\n        # Don't call isinstance(), not checking subclasses.\n        if result.__class__ == pymongo_class:\n            # Delegate to the current object to wrap the result.\n            raise gen.Return(self.wrap(result))\n        else:\n            raise gen.Return(result)\n\n    return _wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a cursor which iterates over changes on all databases in this cluster.", "response": "def watch(self, pipeline=None, full_document='default', resume_after=None,\n              max_await_time_ms=None, batch_size=None, collation=None,\n              start_at_operation_time=None, session=None):\n        \"\"\"Watch changes on this cluster.\n\n        Returns a :class:`~MotorChangeStream` cursor which iterates over changes\n        on all databases in this cluster. Introduced in MongoDB 4.0.\n\n        See the documentation for :meth:`MotorCollection.watch` for more\n        details and examples.\n\n        :Parameters:\n          - `pipeline` (optional): A list of aggregation pipeline stages to\n            append to an initial ``$changeStream`` stage. Not all\n            pipeline stages are valid after a ``$changeStream`` stage, see the\n            MongoDB documentation on change streams for the supported stages.\n          - `full_document` (optional): The fullDocument option to pass\n            to the ``$changeStream`` stage. Allowed values: 'default',\n            'updateLookup'.  Defaults to 'default'.\n            When set to 'updateLookup', the change notification for partial\n            updates will include both a delta describing the changes to the\n            document, as well as a copy of the entire document that was\n            changed from some time after the change occurred.\n          - `resume_after` (optional): The logical starting point for this\n            change stream.\n          - `max_await_time_ms` (optional): The maximum time in milliseconds\n            for the server to wait for changes before responding to a getMore\n            operation.\n          - `batch_size` (optional): The maximum number of documents to return\n            per batch.\n          - `collation` (optional): The :class:`~pymongo.collation.Collation`\n            to use for the aggregation.\n          - `start_at_operation_time` (optional): If provided, the resulting\n            change stream will only return changes that occurred at or after\n            the specified :class:`~bson.timestamp.Timestamp`. Requires\n            MongoDB >= 4.0.\n          - `session` (optional): a\n            :class:`~pymongo.client_session.ClientSession`.\n\n        :Returns:\n          A :class:`~MotorChangeStream`.\n\n        .. versionadded:: 2.0\n\n        .. mongodoc:: changeStreams\n        \"\"\"\n        cursor_class = create_class_with_framework(\n            AgnosticChangeStream, self._framework, self.__module__)\n\n        # Latent cursor that will send initial command on first \"async for\".\n        return cursor_class(self, pipeline, full_document, resume_after,\n                            max_await_time_ms, batch_size, collation,\n                            start_at_operation_time, session)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts a multi - statement transaction.", "response": "def start_transaction(self, read_concern=None, write_concern=None,\n                          read_preference=None):\n        \"\"\"Start a multi-statement transaction.\n\n        Takes the same arguments as\n        :class:`~pymongo.client_session.TransactionOptions`.\n\n        Best used in a context manager block:\n\n        .. code-block:: python3\n\n          # Use \"await\" for start_session, but not for start_transaction.\n          async with await client.start_session() as s:\n              async with s.start_transaction():\n                  await collection.delete_one({'x': 1}, session=s)\n                  await collection.insert_one({'x': 2}, session=s)\n\n        \"\"\"\n        self.delegate.start_transaction(read_concern=read_concern,\n                                        write_concern=write_concern,\n                                        read_preference=read_preference)\n        return _MotorTransactionContext(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a MotorCursor. Same parameters as for PyMongo s Collection. find.", "response": "def find(self, *args, **kwargs):\n        \"\"\"Create a :class:`MotorCursor`. Same parameters as for\n        PyMongo's :meth:`~pymongo.collection.Collection.find`.\n\n        Note that ``find`` does not require an ``await`` expression, because\n        ``find`` merely creates a\n        :class:`MotorCursor` without performing any operations on the server.\n        ``MotorCursor`` methods such as :meth:`~MotorCursor.to_list`\n        perform actual operations.\n        \"\"\"\n        cursor = self.delegate.find(*unwrap_args_session(args),\n                                    **unwrap_kwargs_session(kwargs))\n        cursor_class = create_class_with_framework(\n            AgnosticCursor, self._framework, self.__module__)\n\n        return cursor_class(cursor, self)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_raw_batches(self, *args, **kwargs):\n        cursor = self.delegate.find_raw_batches(*unwrap_args_session(args),\n                                                **unwrap_kwargs_session(kwargs))\n        cursor_class = create_class_with_framework(\n            AgnosticRawBatchCursor, self._framework, self.__module__)\n\n        return cursor_class(cursor, self)", "response": "Query the database and retrieve batches of raw BSON."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting an aggregation pipeline on this collection.", "response": "def aggregate(self, pipeline, **kwargs):\n        \"\"\"Execute an aggregation pipeline on this collection.\n\n        The aggregation can be run on a secondary if the client is connected\n        to a replica set and its ``read_preference`` is not :attr:`PRIMARY`.\n\n        :Parameters:\n          - `pipeline`: a single command or list of aggregation commands\n          - `session` (optional): a\n            :class:`~pymongo.client_session.ClientSession`, created with\n            :meth:`~MotorClient.start_session`.\n          - `**kwargs`: send arbitrary parameters to the aggregate command\n\n        Returns a :class:`MotorCommandCursor` that can be iterated like a\n        cursor from :meth:`find`::\n\n          pipeline = [{'$project': {'name': {'$toUpper': '$name'}}}]\n          cursor = collection.aggregate(pipeline)\n          while (yield cursor.fetch_next):\n              doc = cursor.next_object()\n              print(doc)\n\n        In Python 3.5 and newer, aggregation cursors can be iterated elegantly\n        in native coroutines with `async for`::\n\n          async def f():\n              async for doc in collection.aggregate(pipeline):\n                  print(doc)\n\n        :class:`MotorCommandCursor` does not allow the ``explain`` option. To\n        explain MongoDB's query plan for the aggregation, use\n        :meth:`MotorDatabase.command`::\n\n          async def f():\n              plan = await db.command(\n                  'aggregate', 'COLLECTION-NAME',\n                  pipeline=[{'$project': {'x': 1}}],\n                  explain=True)\n\n              print(plan)\n\n        .. versionchanged:: 1.0\n           :meth:`aggregate` now **always** returns a cursor.\n\n        .. versionchanged:: 0.5\n           :meth:`aggregate` now returns a cursor by default,\n           and the cursor is returned immediately without a ``yield``.\n           See :ref:`aggregation changes in Motor 0.5 <aggregate_changes_0_5>`.\n\n        .. versionchanged:: 0.2\n           Added cursor support.\n\n        .. _aggregate command:\n            http://docs.mongodb.org/manual/applications/aggregation\n\n        \"\"\"\n        cursor_class = create_class_with_framework(\n            AgnosticLatentCommandCursor, self._framework, self.__module__)\n\n        # Latent cursor that will send initial command on first \"async for\".\n        return cursor_class(self, self._async_aggregate, pipeline,\n                            **unwrap_kwargs_session(kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform an aggregation and retrieve batches of raw BSON.", "response": "def aggregate_raw_batches(self, pipeline, **kwargs):\n        \"\"\"Perform an aggregation and retrieve batches of raw BSON.\n\n        Similar to the :meth:`aggregate` method but returns each batch as bytes.\n\n        This example demonstrates how to work with raw batches, but in practice\n        raw batches should be passed to an external library that can decode\n        BSON into another data type, rather than used with PyMongo's\n        :mod:`bson` module.\n\n        .. code-block:: python3\n\n          async def get_raw():\n              cursor = db.test.aggregate_raw_batches()\n              async for batch in cursor:\n                  print(bson.decode_all(batch))\n\n        Note that ``aggregate_raw_batches`` does not support sessions.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        cursor_class = create_class_with_framework(\n            AgnosticLatentCommandCursor, self._framework, self.__module__)\n\n        # Latent cursor that will send initial command on first \"async for\".\n        return cursor_class(self, self._async_aggregate_raw_batches, pipeline,\n                            **unwrap_kwargs_session(kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_indexes(self, session=None):\n        cursor_class = create_class_with_framework(\n            AgnosticLatentCommandCursor, self._framework, self.__module__)\n\n        # Latent cursor that will send initial command on first \"async for\".\n        return cursor_class(self, self._async_list_indexes, session=session)", "response": "Get a cursor over the index documents for this collection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitial query or getMore. Returns a Future.", "response": "def _get_more(self):\n        \"\"\"Initial query or getMore. Returns a Future.\"\"\"\n        if not self.alive:\n            raise pymongo.errors.InvalidOperation(\n                \"Can't call get_more() on a MotorCursor that has been\"\n                \" exhausted or killed.\")\n\n        self.started = True\n        return self._refresh()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_next(self):\n        if not self._buffer_size() and self.alive:\n            # Return the Future, which resolves to number of docs fetched or 0.\n            return self._get_more()\n        elif self._buffer_size():\n            future = self._framework.get_future(self.get_io_loop())\n            future.set_result(True)\n            return future\n        else:\n            # Dead\n            future = self._framework.get_future(self.get_io_loop())\n            future.set_result(False)\n            return future", "response": "A Future that returns the next document in the result set. Resolves to False if there are no more documents."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of documents.", "response": "def to_list(self, length):\n        \"\"\"Get a list of documents.\n\n        .. testsetup:: to_list\n\n          MongoClient().test.test_collection.delete_many({})\n          MongoClient().test.test_collection.insert_many([{'_id': i} for i in range(4)])\n\n          from tornado import ioloop\n\n        .. doctest:: to_list\n\n          >>> from motor.motor_tornado import MotorClient\n          >>> collection = MotorClient().test.test_collection\n          >>>\n          >>> @gen.coroutine\n          ... def f():\n          ...     cursor = collection.find().sort([('_id', 1)])\n          ...     docs = yield cursor.to_list(length=2)\n          ...     while docs:\n          ...         print(docs)\n          ...         docs = yield cursor.to_list(length=2)\n          ...\n          ...     print('done')\n          ...\n          >>> ioloop.IOLoop.current().run_sync(f)\n          [{'_id': 0}, {'_id': 1}]\n          [{'_id': 2}, {'_id': 3}]\n          done\n\n        :Parameters:\n         - `length`: maximum number of documents to return for this call, or\n           None\n\n         Returns a Future.\n\n        .. versionchanged:: 2.0\n           No longer accepts a callback argument.\n\n        .. versionchanged:: 0.2\n           `callback` must be passed as a keyword argument, like\n           ``to_list(10, callback=callback)``, and the\n           `length` parameter is no longer optional.\n        \"\"\"\n        if length is not None:\n            if not isinstance(length, int):\n                raise TypeError('length must be an int, not %r' % length)\n            elif length < 0:\n                raise ValueError('length must be non-negative')\n\n        if self._query_flags() & _QUERY_OPTIONS['tailable_cursor']:\n            raise pymongo.errors.InvalidOperation(\n                \"Can't call to_list on tailable cursor\")\n\n        future = self._framework.get_future(self.get_io_loop())\n\n        if not self.alive:\n            future.set_result([])\n        else:\n            the_list = []\n            self._framework.add_future(\n                self.get_io_loop(),\n                self._get_more(),\n                self._to_list, length, the_list, future)\n\n        return future"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadvancing the cursor. This method blocks until the next change document is returned or an unrecoverable error is raised. Raises :exc:`StopAsyncIteration` if this change stream is closed. You can iterate the change stream by calling ``await change_stream.next()`` repeatedly, or with an \"async for\" loop: .. code-block:: python3 async for change in db.collection.watch(): print(change)", "response": "def next(self):\n        \"\"\"Advance the cursor.\n\n        This method blocks until the next change document is returned or an\n        unrecoverable error is raised.\n\n        Raises :exc:`StopAsyncIteration` if this change stream is closed.\n\n        You can iterate the change stream by calling\n        ``await change_stream.next()`` repeatedly, or with an \"async for\" loop:\n\n        .. code-block:: python3\n\n          async for change in db.collection.watch():\n              print(change)\n\n        \"\"\"\n        loop = self.get_io_loop()\n        return self._framework.run_on_executor(loop, self._next)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclose this change stream.", "response": "def close(self):\n        \"\"\"Close this change stream.\n\n        Stops any \"async for\" loops using this change stream.\n        \"\"\"\n        if self.delegate:\n            return self._close()\n\n        # Never started.\n        future = self._framework.get_future(self.get_io_loop())\n        future.set_result(None)\n        return future"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef asynchronize(\n        framework, sync_method, doc=None, wrap_class=None, unwrap_class=None):\n    \"\"\"Decorate `sync_method` so it returns a Future.\n\n    The method runs on a thread and resolves the Future when it completes.\n\n    :Parameters:\n     - `motor_class`:       Motor class being created, e.g. MotorClient.\n     - `framework`:         An asynchronous framework\n     - `sync_method`:       Unbound method of pymongo Collection, Database,\n                            MongoClient, etc.\n     - `doc`:               Optionally override sync_method's docstring\n     - `wrap_class`:        Optional PyMongo class, wrap a returned object of\n                            this PyMongo class in the equivalent Motor class\n     - `unwrap_class`       Optional Motor class name, unwrap an argument with\n                            this Motor class name and pass the wrapped PyMongo\n                            object instead\n    \"\"\"\n    @functools.wraps(sync_method)\n    def method(self, *args, **kwargs):\n        if unwrap_class is not None:\n            # Don't call isinstance(), not checking subclasses.\n            unwrapped_args = [\n                obj.delegate\n                if obj.__class__.__name__.endswith(\n                    (unwrap_class, 'MotorClientSession'))\n                else obj\n                for obj in args]\n            unwrapped_kwargs = {\n                key: (obj.delegate\n                      if obj.__class__.__name__.endswith(\n                        (unwrap_class, 'MotorClientSession'))\n                      else obj)\n                for key, obj in kwargs.items()}\n        else:\n            # For speed, don't call unwrap_args_session/unwrap_kwargs_session.\n            unwrapped_args = [\n                obj.delegate\n                if obj.__class__.__name__.endswith('MotorClientSession')\n                else obj\n                for obj in args]\n            unwrapped_kwargs = {\n                key: (obj.delegate\n                      if obj.__class__.__name__.endswith('MotorClientSession')\n                      else obj)\n                for key, obj in kwargs.items()}\n\n        loop = self.get_io_loop()\n        return framework.run_on_executor(loop,\n                                         sync_method,\n                                         self.delegate,\n                                         *unwrapped_args,\n                                         **unwrapped_kwargs)\n\n    if wrap_class is not None:\n        method = framework.pymongo_class_wrapper(method, wrap_class)\n        method.is_wrap_method = True  # For Synchro.\n\n    # This is for the benefit of motor_extensions.py, which needs this info to\n    # generate documentation with Sphinx.\n    method.is_async_method = True\n    name = sync_method.__name__\n    method.pymongo_method_name = name\n\n    if doc is not None:\n        method.__doc__ = doc\n\n    return method", "response": "Decorate sync_method so it returns a Future."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wrap_synchro(fn):\n    @functools.wraps(fn)\n    def _wrap_synchro(*args, **kwargs):\n        motor_obj = fn(*args, **kwargs)\n\n        # Not all Motor classes appear here, only those we need to return\n        # from methods like map_reduce() or create_collection()\n        if isinstance(motor_obj, motor.MotorCollection):\n            client = MongoClient(delegate=motor_obj.database.client)\n            database = Database(client, motor_obj.database.name)\n            return Collection(database, motor_obj.name, delegate=motor_obj)\n        if isinstance(motor_obj, motor.motor_tornado.MotorClientSession):\n            return ClientSession(delegate=motor_obj)\n        if isinstance(motor_obj, _MotorTransactionContext):\n            return _SynchroTransactionContext(motor_obj)\n        if isinstance(motor_obj, motor.MotorDatabase):\n            client = MongoClient(delegate=motor_obj.client)\n            return Database(client, motor_obj.name, delegate=motor_obj)\n        if isinstance(motor_obj, motor.motor_tornado.MotorChangeStream):\n            return ChangeStream(motor_obj)\n        if isinstance(motor_obj, motor.motor_tornado.MotorLatentCommandCursor):\n            return CommandCursor(motor_obj)\n        if isinstance(motor_obj, motor.motor_tornado.MotorCommandCursor):\n            return CommandCursor(motor_obj)\n        if isinstance(motor_obj, _MotorRawBatchCommandCursor):\n            return CommandCursor(motor_obj)\n        if isinstance(motor_obj, motor.motor_tornado.MotorCursor):\n            return Cursor(motor_obj)\n        if isinstance(motor_obj, _MotorRawBatchCursor):\n            return Cursor(motor_obj)\n        if isinstance(motor_obj, motor.MotorGridIn):\n            return GridIn(None, delegate=motor_obj)\n        if isinstance(motor_obj, motor.MotorGridOut):\n            return GridOut(None, delegate=motor_obj)\n        if isinstance(motor_obj, motor.motor_tornado.MotorGridOutCursor):\n            return GridOutCursor(motor_obj)\n        else:\n            return motor_obj\n\n    return _wrap_synchro", "response": "Decorator for wrapping a Synchro function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unwrap_synchro(fn):\n    @functools.wraps(fn)\n    def _unwrap_synchro(*args, **kwargs):\n        def _unwrap_obj(obj):\n            if isinstance(obj, Synchro):\n                return obj.delegate\n            else:\n                return obj\n\n        args = [_unwrap_obj(arg) for arg in args]\n        kwargs = dict([\n            (key, _unwrap_obj(value)) for key, value in kwargs.items()])\n        return fn(*args, **kwargs)\n    return _unwrap_synchro", "response": "Unwrap Synchro objects passed to a method and pass Motor objects instead."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting next GridOut object from cursor.", "response": "def next_object(self):\n        \"\"\"Get next GridOut object from cursor.\"\"\"\n        grid_out = super(self.__class__, self).next_object()\n        if grid_out:\n            grid_out_class = create_class_with_framework(\n                AgnosticGridOut, self._framework, self.__module__)\n\n            return grid_out_class(self.collection, delegate=grid_out)\n        else:\n            # Exhausted.\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open(self):\n        return self._framework.chain_return_value(self._ensure_file(),\n                                                  self.get_io_loop(),\n                                                  self)", "response": "Retrieve this file s attributes from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stream_to_handler(self, request_handler):\n        written = 0\n        while written < self.length:\n            # Reading chunk_size at a time minimizes buffering.\n            f = self._framework.yieldable(self.read(self.chunk_size))\n            yield f\n            chunk = f.result()\n\n            # write() simply appends the output to a list; flush() sends it\n            # over the network and minimizes buffering in the handler.\n            request_handler.write(chunk)\n            request_handler.flush()\n            written += len(chunk)", "response": "Stream the contents of this file to a handler."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding and return the files collection documents that match the filter.", "response": "def find(self, *args, **kwargs):\n        \"\"\"Find and return the files collection documents that match ``filter``.\n\n        Returns a cursor that iterates across files matching\n        arbitrary queries on the files collection. Can be combined\n        with other modifiers for additional control.\n\n        For example::\n\n          cursor = bucket.find({\"filename\": \"lisa.txt\"}, no_cursor_timeout=True)\n          while (yield cursor.fetch_next):\n              grid_out = cursor.next_object()\n              data = yield grid_out.read()\n\n        This iterates through all versions of \"lisa.txt\" stored in GridFS.\n        Note that setting no_cursor_timeout to True may be important to\n        prevent the cursor from timing out during long multi-file processing\n        work.\n\n        As another example, the call::\n\n          most_recent_three = fs.find().sort(\"uploadDate\", -1).limit(3)\n\n        would return a cursor to the three most recently uploaded files\n        in GridFS.\n\n        Follows a similar interface to\n        :meth:`~motor.MotorCollection.find`\n        in :class:`~motor.MotorCollection`.\n\n        :Parameters:\n          - `filter`: Search query.\n          - `batch_size` (optional): The number of documents to return per\n            batch.\n          - `limit` (optional): The maximum number of documents to return.\n          - `no_cursor_timeout` (optional): The server normally times out idle\n            cursors after an inactivity period (10 minutes) to prevent excess\n            memory use. Set this option to True prevent that.\n          - `skip` (optional): The number of documents to skip before\n            returning.\n          - `sort` (optional): The order by which to sort results. Defaults to\n            None.\n          - `session` (optional): a\n            :class:`~pymongo.client_session.ClientSession`, created with\n            :meth:`~MotorClient.start_session`.\n\n        If a :class:`~pymongo.client_session.ClientSession` is passed to\n        :meth:`find`, all returned :class:`MotorGridOut` instances\n        are associated with that session.\n\n        .. versionchanged:: 1.2\n           Added session parameter.\n        \"\"\"\n        cursor = self.delegate.find(*args, **kwargs)\n        grid_out_cursor = create_class_with_framework(\n            AgnosticGridOutCursor, self._framework, self.__module__)\n\n        return grid_out_cursor(cursor, self.collection)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the attribute of the named attribute in the Motor class.", "response": "def get_motor_attr(motor_class, name, *defargs):\n    \"\"\"If any Motor attributes can't be accessed, grab the equivalent PyMongo\n    attribute. While we're at it, store some info about each attribute\n    in the global motor_info dict.\n    \"\"\"\n    attr = safe_getattr(motor_class, name)\n\n    # Store some info for process_motor_nodes()\n    full_name = '%s.%s.%s' % (\n        motor_class.__module__, motor_class.__name__, name)\n\n    full_name_legacy = 'motor.%s.%s.%s' % (\n        motor_class.__module__, motor_class.__name__, name)\n\n    # These sub-attributes are set in motor.asynchronize()\n    has_coroutine_annotation = getattr(attr, 'coroutine_annotation', False)\n    is_async_method = getattr(attr, 'is_async_method', False)\n    is_cursor_method = getattr(attr, 'is_motorcursor_chaining_method', False)\n    if is_async_method or is_cursor_method:\n        pymongo_method = getattr(\n            motor_class.__delegate_class__, attr.pymongo_method_name)\n    else:\n        pymongo_method = None\n\n    # attr.doc is set by statement like 'error = AsyncRead(doc=\"OBSOLETE\")'.\n    is_pymongo_doc = pymongo_method and attr.__doc__ == pymongo_method.__doc__\n\n    motor_info[full_name] = motor_info[full_name_legacy] = {\n        'is_async_method': is_async_method or has_coroutine_annotation,\n        'is_pymongo_docstring': is_pymongo_doc,\n        'pymongo_method': pymongo_method,\n    }\n\n    return attr"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the instruments attached to the pipette.", "response": "def get_attached_instruments(\n            self, expected: Dict[Mount, str])\\\n            -> Dict[Mount, Dict[str, Optional[str]]]:\n        \"\"\" Find the instruments attached to our mounts.\n\n        :param expected: A dict that may contain a mapping from mount to\n                         strings that should prefix instrument model names.\n                         When instruments are scanned, they are matched\n                         against the expectation (if present) and a\n                         :py:attr:`RuntimeError` is raised if there is no\n                         match.\n\n        :raises RuntimeError: If an instrument is expected but not found.\n        :returns: A dict with mounts as the top-level keys. Each mount value is\n            a dict with keys 'mount' (containing an instrument model name or\n            `None`) and 'id' (containing the serial number of the pipette\n            attached to that mount, or `None`).\n        \"\"\"\n        to_return: Dict[Mount, Dict[str, Optional[str]]] = {}\n        for mount in Mount:\n            found_model = self._smoothie_driver.read_pipette_model(\n                mount.name.lower())\n            found_id = self._smoothie_driver.read_pipette_id(\n                mount.name.lower())\n            expected_instr = expected.get(mount, None)\n            if expected_instr and\\\n               (not found_model or not found_model.startswith(expected_instr)):\n                raise RuntimeError(\n                    'mount {}: instrument {} was requested but {} is present'\n                    .format(mount.name, expected_instr, found_model))\n            to_return[mount] = {\n                'model': found_model,\n                'id': found_id}\n        return to_return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_active_current(self, axis, amp):\n        self._smoothie_driver.set_active_current({axis.name: amp})", "response": "This method sets the active current for an anatomical pipette axis."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef axis_bounds(self) -> Dict[str, Tuple[float, float]]:\n        return {ax: (0, pos+.05) for ax, pos\n                in self._smoothie_driver.homed_position.items()\n                if ax not in 'BC'}", "response": "The minimum and maximum bounds for each axis."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a probe and return the new position dict", "response": "def probe(self, axis: str, distance: float) -> Dict[str, float]:\n        \"\"\" Run a probe and return the new position dict\n        \"\"\"\n        return self._smoothie_driver.probe_axis(axis, distance)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def delay(self, duration_s: int):\n        self.pause()\n        await asyncio.sleep(duration_s)\n        self.resume()", "response": "Pause and sleep and resume the asyncio thread."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the pipette with the current model and the pipette s mount.", "response": "def init_pipette():\n    \"\"\"\n    Finds pipettes attached to the robot currently and chooses the correct one\n    to add to the session.\n\n    :return: The pipette type and mount chosen for deck calibration\n    \"\"\"\n    global session\n    pipette_info = set_current_mount(session.adapter, session)\n    pipette = pipette_info['pipette']\n    res = {}\n    if pipette:\n        session.current_model = pipette_info['model']\n        if not feature_flags.use_protocol_api_v2():\n            mount = pipette.mount\n            session.current_mount = mount\n        else:\n            mount = pipette.get('mount')\n            session.current_mount = mount_by_name[mount]\n        session.pipettes[mount] = pipette\n        res = {'mount': mount, 'model': pipette_info['model']}\n\n    log.info(\"Pipette info {}\".format(session.pipettes))\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_current_mount(hardware, session):\n\n    pipette = None\n    right_channel = None\n    left_channel = None\n    right_pipette, left_pipette = get_pipettes(hardware)\n    if right_pipette:\n        if not feature_flags.use_protocol_api_v2():\n            right_channel = right_pipette.channels\n        else:\n            right_channel = right_pipette.get('channels')\n            right_pipette['mount'] = 'right'\n\n    if left_pipette:\n        if not feature_flags.use_protocol_api_v2():\n            left_channel = left_pipette.channels\n        else:\n            left_channel = left_pipette.get('channels')\n            left_pipette['mount'] = 'left'\n\n    if right_channel == 1:\n        pipette = right_pipette\n    elif left_channel == 1:\n        pipette = left_pipette\n    elif right_pipette:\n        pipette = right_pipette\n        session.cp = CriticalPoint.FRONT_NOZZLE\n    elif left_pipette:\n        pipette = left_pipette\n        session.cp = CriticalPoint.FRONT_NOZZLE\n\n    model, id = _get_model_name(pipette, hardware)\n    session.pipette_id = id\n    return {'pipette': pipette, 'model': model}", "response": "Choose the pipette in which to execute commands."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattach a tip to the current pipette.", "response": "async def attach_tip(data):\n    \"\"\"\n    Attach a tip to the current pipette\n\n    :param data: Information obtained from a POST request.\n    The content type is application/json.\n    The correct packet form should be as follows:\n    {\n      'token': UUID token from current session start\n      'command': 'attach tip'\n      'tipLength': a float representing how much the length of a pipette\n        increases when a tip is added\n    }\n    \"\"\"\n    global session\n    tip_length = data.get('tipLength')\n\n    if not tip_length:\n        message = 'Error: \"tipLength\" must be specified in request'\n        status = 400\n    else:\n        if not feature_flags.use_protocol_api_v2():\n            pipette = session.pipettes[session.current_mount]\n            if pipette.tip_attached:\n                log.warning('attach tip called while tip already attached')\n                pipette._remove_tip(pipette._tip_length)\n            pipette._add_tip(tip_length)\n        else:\n            session.adapter.add_tip(session.current_mount, tip_length)\n            if session.cp:\n                session.cp = CriticalPoint.FRONT_NOZZLE\n        session.tip_length = tip_length\n\n        message = \"Tip length set: {}\".format(tip_length)\n        status = 200\n\n    return web.json_response({'message': message}, status=status)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndetach the tip from the current pipette", "response": "async def detach_tip(data):\n    \"\"\"\n    Detach the tip from the current pipette\n\n    :param data: Information obtained from a POST request.\n    The content type is application/json.\n    The correct packet form should be as follows:\n    {\n      'token': UUID token from current session start\n      'command': 'detach tip'\n    }\n    \"\"\"\n    global session\n\n    if not feature_flags.use_protocol_api_v2():\n        pipette = session.pipettes[session.current_mount]\n        if not pipette.tip_attached:\n            log.warning('detach tip called with no tip')\n        pipette._remove_tip(session.tip_length)\n    else:\n        session.adapter.remove_tip(session.current_mount)\n        if session.cp:\n            session.cp = CriticalPoint.NOZZLE\n    session.tip_length = None\n\n    return web.json_response({'message': \"Tip removed\"}, status=200)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def run_jog(data):\n    axis = data.get('axis')\n    direction = data.get('direction')\n    step = data.get('step')\n\n    if axis not in ('x', 'y', 'z'):\n        message = '\"axis\" must be \"x\", \"y\", or \"z\"'\n        status = 400\n    elif direction not in (-1, 1):\n        message = '\"direction\" must be -1 or 1'\n        status = 400\n    elif step is None:\n        message = '\"step\" must be specified'\n        status = 400\n    else:\n        position = jog(\n            axis,\n            direction,\n            step,\n            session.adapter,\n            session.current_mount,\n            session.cp)\n        message = 'Jogged to {}'.format(position)\n        status = 200\n\n    return web.json_response({'message': message}, status=status)", "response": "This function is used to jog the pipette around the deck map."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def move(data):\n    global session\n    point_name = data.get('point')\n    point = safe_points().get(point_name)\n    if point and len(point) == 3:\n        if not feature_flags.use_protocol_api_v2():\n            pipette = session.pipettes[session.current_mount]\n            channels = pipette.channels\n        # For multichannel pipettes in the V1 session, we use the tip closest\n        # to the front of the robot rather than the back (this is the tip that\n        # would go into well H1 of a plate when pipetting from the first row of\n        # a 96 well plate, for instance). Since moves are issued for the A1 tip\n        # we have to adjust the target point by 2 * Y_OFFSET_MULTI (where the\n        # offset value is the distance from the axial center of the pipette to\n        # the A1 tip). By sending the A1 tip to to the adjusted target, the H1\n        # tip should go to the desired point. Y_OFFSET_MULT must then be backed\n        # out of xy positions saved in the `save_xy` handler\n        # (not 2 * Y_OFFSET_MULTI, because the axial center of the pipette\n        # will only be off by 1* Y_OFFSET_MULTI).\n            if not channels == 1:\n                x = point[0]\n                y = point[1] + pipette_config.Y_OFFSET_MULTI * 2\n                z = point[2]\n                point = (x, y, z)\n            pipette.move_to((session.adapter.deck, point), strategy='arc')\n        else:\n            if not point_name == 'attachTip':\n                intermediate_pos = position(\n                    session.current_mount, session.adapter, session.cp)\n                session.adapter.move_to(\n                    session.current_mount,\n                    Point(\n                        x=intermediate_pos[0],\n                        y=intermediate_pos[1],\n                        z=session.tip_length),\n                    critical_point=session.cp)\n                session.adapter.move_to(\n                    session.current_mount,\n                    Point(x=point[0], y=point[1], z=session.tip_length),\n                    critical_point=session.cp)\n                session.adapter.move_to(\n                    session.current_mount,\n                    Point(x=point[0], y=point[1], z=point[2]),\n                    critical_point=session.cp)\n            else:\n                if session.cp:\n                    session.cp = CriticalPoint.NOZZLE\n                session.adapter.move_to(\n                    session.current_mount,\n                    Point(x=point[0], y=point[1], z=point[2]),\n                    critical_point=session.cp)\n        message = 'Moved to {}'.format(point)\n        status = 200\n    else:\n        message = '\"point\" must be one of \"1\", \"2\", \"3\", \"safeZ\", \"attachTip\"'\n        status = 400\n\n    return web.json_response({'message': message}, status=status)", "response": "Move a pipette to a specific point."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def save_xy(data):\n    global session\n    valid_points = list(session.points.keys())\n    point = data.get('point')\n    if point not in valid_points:\n        message = 'point must be one of {}'.format(valid_points)\n        status = 400\n    elif not session.current_mount:\n        message = \"Mount must be set before calibrating\"\n        status = 400\n    else:\n        if not feature_flags.use_protocol_api_v2():\n            mount = 'Z' if session.current_mount == 'left' else 'A'\n            x, y, _ = position(mount, session.adapter)\n            if session.pipettes[session.current_mount].channels != 1:\n                # See note in `move`\n                y = y - pipette_config.Y_OFFSET_MULTI\n            if session.current_mount == 'left':\n                dx, dy, _ = session.adapter.config.mount_offset\n                x = x + dx\n                y = y + dy\n        else:\n            x, y, _ = position(\n                session.current_mount, session.adapter, session.cp)\n\n        session.points[point] = (x, y)\n        message = \"Saved point {} value: {}\".format(\n            point, session.points[point])\n        status = 200\n    return web.json_response({'message': message}, status=status)", "response": "Save the current XY values for the calibration point."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def save_z(data):\n    if not session.tip_length:\n        message = \"Tip length must be set before calibrating\"\n        status = 400\n    else:\n        if not feature_flags.use_protocol_api_v2():\n            mount = 'Z' if session.current_mount == 'left' else 'A'\n            actual_z = position(\n                mount, session.adapter)[-1]\n            length_offset = pipette_config.load(\n                session.current_model, session.pipette_id).model_offset[-1]\n            session.z_value = actual_z - session.tip_length + length_offset\n        else:\n            session.z_value = position(\n                session.current_mount, session.adapter, session.cp)[-1]\n\n        message = \"Saved z: {}\".format(session.z_value)\n        status = 200\n    return web.json_response({'message': message}, status=status)", "response": "Save the current Z height value for the calibration data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave the transform matrix that calibrates the deck to the deck", "response": "async def save_transform(data):\n    \"\"\"\n    Calculate the transormation matrix that calibrates the gantry to the deck\n    :param data: Information obtained from a POST request.\n    The content type is application/json.\n    The correct packet form should be as follows:\n    {\n      'token': UUID token from current session start\n      'command': 'save transform'\n    }\n    \"\"\"\n    if any([v is None for v in session.points.values()]):\n        message = \"Not all points have been saved\"\n        status = 400\n    else:\n        # expected values based on mechanical drawings of the robot\n        expected_pos = expected_points()\n        expected = [\n            expected_pos[p] for p in expected_pos.keys()]\n        # measured data\n        actual = [session.points[p] for p in sorted(session.points.keys())]\n\n        # Generate a 2 dimensional transform matrix from the two matricies\n        flat_matrix = solve(expected, actual)\n        # Add the z component to form the 3 dimensional transform\n        calibration_matrix = add_z(flat_matrix, session.z_value)\n\n        session.adapter.update_config(gantry_calibration=list(\n                map(lambda i: list(i), calibration_matrix)))\n\n        robot_configs.save_deck_calibration(session.adapter.config)\n        robot_configs.backup_configuration(session.adapter.config)\n        message = \"Config file saved and backed up\"\n        status = 200\n    return web.json_response({'message': message}, status=status)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreleases a session :param data: Information obtained from a POST request. The content type is application/json. The correct packet form should be as follows: { 'token': UUID token from current session start 'command': 'release' }", "response": "async def release(data):\n    \"\"\"\n    Release a session\n\n    :param data: Information obtained from a POST request.\n    The content type is application/json.\n    The correct packet form should be as follows:\n    {\n      'token': UUID token from current session start\n      'command': 'release'\n    }\n    \"\"\"\n    global session\n    if not feature_flags.use_protocol_api_v2():\n        session.adapter.remove_instrument('left')\n        session.adapter.remove_instrument('right')\n    else:\n        session.adapter.cache_instruments()\n    session = None\n    return web.json_response({\"message\": \"calibration session released\"})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def start(request):\n    global session\n\n    try:\n        body = await request.json()\n    except json.decoder.JSONDecodeError:\n        # Body will be null for requests without parameters (normal operation)\n        log.debug(\"No body in {}\".format(request))\n        body = {}\n\n    if not session or body.get('force'):\n        hardware = hw_from_req(request)\n        if body.get('force') and session:\n            await release(data={})\n\n        session = SessionManager(hardware)\n        res = init_pipette()\n        if res:\n            status = 201\n            data = {'token': session.id, 'pipette': res}\n        else:\n            session = None\n            status = 403\n            data = {'message': 'Error, pipette not recognized'}\n    else:\n        data = {'message': 'Error, session in progress. Use \"force\" key in'\n                           ' request body to override'}\n        status = 409\n    return web.json_response(data, status=status)", "response": "Starts the session manager for factory calibration."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def dispatch(request):\n    if session:\n        message = ''\n        data = await request.json()\n        try:\n            log.info(\"Dispatching {}\".format(data))\n            _id = data.get('token')\n            if not _id:\n                message = '\"token\" field required for calibration requests'\n                raise AssertionError\n            command = data.get('command')\n            if not command:\n                message = '\"command\" field required for calibration requests'\n                raise AssertionError\n\n            if _id == session.id:\n                res = await router[command](data)\n            else:\n                res = web.json_response(\n                    {'message': 'Invalid token: {}'.format(_id)}, status=403)\n        except AssertionError:\n            res = web.json_response({'message': message}, status=400)\n        except Exception as e:\n            res = web.json_response(\n                {'message': 'Exception {} raised by dispatch of {}: {}'.format(\n                    type(e), data, e)},\n                status=500)\n    else:\n        res = web.json_response(\n            {'message': 'Session must be started before issuing commands'},\n            status=418)\n    return res", "response": "Dispatches commands to subhandlers based on the command field in the body."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _serial_poller(self):\n        while True:\n            _next = dict(self._poller.poll(POLLING_FREQUENCY_MS))\n            if self._halt_read_file.fileno() in _next:\n                log.debug(\"Poller [{}]: halt\".format(hash(self)))\n                self._halt_read_file.read()\n                # Note: this is discarded because we send a set message to halt\n                # the thread--don't currently need to parse it\n                break\n\n            elif self._connection.fileno() in _next:\n                # Lid-open interrupt\n                log.debug(\"Poller [{}]: interrupt\".format(hash(self)))\n                res = self._connection.read_until(SERIAL_ACK)\n                self._interrupt_callback(res)\n\n            elif self._send_read_file.fileno() in _next:\n                self._send_read_file.read(1)\n                command, callback = self._command_queue.get()\n                log.debug(\"Poller [{}]: send {}\".format(hash(self), command))\n                res = self._send_command(command)\n                callback(res)\n            else:\n                # Nothing else to do--update device status\n                log.debug(\"Poller [{}]: updating temp\".format(hash(self)))\n                res = self._send_command(GCODES['GET_PLATE_TEMP'])\n                self._status_callback(res)\n        log.info(\"Exiting TC poller loop [{}]\".format(hash(self)))", "response": "This method is used to poll the TC thread for a specific entry in the TC thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_temperature(self, celsius):\n        if self._driver and self._driver.is_connected():\n            self._driver.set_temperature(celsius)", "response": "Sets the internal temperature in degree Celsius."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deactivate(self):\n        if self._driver and self._driver.is_connected():\n            self._driver.deactivate()", "response": "Stop heating and cooling and turn off the fan"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconnects to the TempDeck port and create a Thread object.", "response": "def connect(self):\n        \"\"\"\n        Connect to the 'TempDeck' port\n        Planned change- will connect to the correct port in case of multiple\n        TempDecks\n        \"\"\"\n        if self._port:\n            self._driver = TempDeckDriver()\n            self._driver.connect(self._port)\n            self._device_info = self._driver.get_device_info()\n\n            self._poll_stop_event = Event()\n            Thread(target=self._poll_temperature).start()\n        else:\n            # Sanity check Should never happen, because connect should never\n            # be called without a port on Module\n            raise MissingDevicePortError(\n                \"TempDeck couldn't connect to port {}\".format(self._port)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disconnect(self):\n        '''\n        Disconnect from the serial port\n        '''\n        if self._poll_stop_event:\n            self._poll_stop_event.set()\n        if self._driver:\n            if self.status != 'idle':\n                self.deactivate()\n            self._driver.disconnect()", "response": "Disconnect from the serial port"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef temp_connect(self, hardware: hc.API):\n        old_hw = self._hw_manager.hardware\n        try:\n            self._hw_manager.set_hw(hardware)\n            yield self\n        finally:\n            self._hw_manager.set_hw(old_hw)", "response": "Connect temporarily to the specified hardware controller."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconnects to a running hardware API.", "response": "def connect(self, hardware: hc.API):\n        \"\"\" Connect to a running hardware API.\n\n        This can be either a simulator or a full hardware controller.\n\n        Note that there is no true disconnected state for a\n        :py:class:`.ProtocolContext`; :py:meth:`disconnect` simply creates\n        a new simulator and replaces the current hardware with it.\n        \"\"\"\n        self._hw_manager.set_hw(hardware)\n        self._hw_manager.hardware.cache_instruments()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the labware specified by labware_obj into the deck layout.", "response": "def load_labware(\n            self, labware_obj: Labware,\n            location: types.DeckLocation) -> Labware:\n        \"\"\" Specify the presence of a piece of labware on the OT2 deck.\n\n        This function loads the labware specified by `labware`\n        (previously loaded from a configuration file) to the location\n        specified by `location`.\n\n        :param Labware labware: The labware object to load\n        :param location: The slot into which to load the labware such as\n                         1 or '1'\n        :type location: int or str\n        \"\"\"\n        self._deck_layout[location] = labware_obj\n        return labware_obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_labware_by_name(\n            self, labware_name: str,\n            location: types.DeckLocation, label: str = None) -> Labware:\n        \"\"\" A convenience function to specify a piece of labware by name.\n\n        For labware already defined by Opentrons, this is a convient way\n        to collapse the two stages of labware initialization (creating\n        the labware and adding it to the protocol) into one.\n\n        This function returns the created and initialized labware for use\n        later in the protocol.\n\n        :param str labware_name: The name of the labware to load\n        :param location: The slot into which to load the labware such as\n                         1 or '1'\n        :type location: int or str\n        :param str label: An optional special name to give the labware. If\n                          specified, this is the name the labware will appear\n                          as in the run log and the calibration view in the\n                          Opentrons app.\n        \"\"\"\n        labware = load(labware_name,\n                       self._deck_layout.position_for(location),\n                       label)\n        return self.load_labware(labware, location)", "response": "Loads a piece of labware from Opentrons and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_instrument(\n            self,\n            instrument_name: str,\n            mount: Union[types.Mount, str],\n            tip_racks: List[Labware] = None,\n            replace: bool = False) -> 'InstrumentContext':\n        \"\"\" Load a specific instrument required by the protocol.\n\n        This value will actually be checked when the protocol runs, to\n        ensure that the correct instrument is attached in the specified\n        location.\n\n        :param str instrument_name: The name of the instrument model, or a\n                                    prefix. For instance, 'p10_single' may be\n                                    used to request a P10 single regardless of\n                                    the version.\n        :param mount: The mount in which this instrument should be attached.\n                      This can either be an instance of the enum type\n                      :py:class:`.types.Mount` or one of the strings `'left'`\n                      and `'right'`.\n        :type mount: types.Mount or str\n        :param tip_racks: A list of tip racks from which to pick tips if\n                          :py:meth:`.InstrumentContext.pick_up_tip` is called\n                          without arguments.\n        :type tip_racks: List[:py:class:`.Labware`]\n        :param bool replace: Indicate that the currently-loaded instrument in\n                             `mount` (if such an instrument exists) should be\n                             replaced by `instrument_name`.\n        \"\"\"\n        if isinstance(mount, str):\n            try:\n                checked_mount = types.Mount[mount.upper()]\n            except KeyError:\n                raise ValueError(\n                    \"If mount is specified as a string, it should be either\"\n                    \"'left' or 'right' (ignoring capitalization, which the\"\n                    \" system strips), not {}\".format(mount))\n        elif isinstance(mount, types.Mount):\n            checked_mount = mount\n        else:\n            raise TypeError(\n                \"mount should be either an instance of opentrons.types.Mount\"\n                \" or a string, but is {}.\".format(mount))\n        self._log.info(\"Trying to load {} on {} mount\"\n                       .format(instrument_name, checked_mount.name.lower()))\n        instr = self._instruments[checked_mount]\n        if instr and not replace:\n            raise RuntimeError(\"Instrument already present in {} mount: {}\"\n                               .format(checked_mount.name.lower(),\n                                       instr.name))\n        attached = {att_mount: instr.get('name', None)\n                    for att_mount, instr\n                    in self._hw_manager.hardware.attached_instruments.items()}\n        attached[checked_mount] = instrument_name\n        self._log.debug(\"cache instruments expectation: {}\"\n                        .format(attached))\n        self._hw_manager.hardware.cache_instruments(attached)\n        # If the cache call didn\u2019t raise, the instrument is attached\n        new_instr = InstrumentContext(\n            ctx=self,\n            hardware_mgr=self._hw_manager,\n            mount=checked_mount,\n            tip_racks=tip_racks,\n            log_parent=self._log)\n        self._instruments[checked_mount] = new_instr\n        self._log.info(\"Instrument {} loaded\".format(new_instr))\n        return new_instr", "response": "Load a specific instrument from the protocol."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef loaded_instruments(self) -> Dict[str, Optional['InstrumentContext']]:\n        return {mount.name.lower(): instr for mount, instr\n                in self._instruments.items()}", "response": "Returns a dictionary mapping mount names in lowercase to the instrument contexts in that mount."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelay protocol execution for a specific amount of time.", "response": "def delay(self, seconds=0, minutes=0, msg=None):\n        \"\"\" Delay protocol execution for a specific amount of time.\n\n        :param float seconds: A time to delay in seconds\n        :param float minutes: A time to delay in minutes\n\n        If both `seconds` and `minutes` are specified, they will be added.\n        \"\"\"\n        delay_time = seconds + minutes * 60\n        self._hw_manager.hardware.delay(delay_time)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naspirate a volume of liquid in microliters from the current position.", "response": "def aspirate(self,\n                 volume: float = None,\n                 location: Union[types.Location, Well] = None,\n                 rate: float = 1.0) -> 'InstrumentContext':\n        \"\"\"\n        Aspirate a volume of liquid (in microliters/uL) using this pipette\n        from the specified location\n\n        If only a volume is passed, the pipette will aspirate\n        from its current position. If only a location is passed,\n        :py:meth:`aspirate` will default to its :py:attr:`max_volume`.\n\n        :param volume: The volume to aspirate, in microliters. If not\n                       specified, :py:attr:`max_volume`.\n        :type volume: int or float\n        :param location: Where to aspirate from. If `location` is a\n                         :py:class:`.Well`, the robot will aspirate from\n                         :py:attr:`well_bottom_clearance` mm\n                         above the bottom of the well. If `location` is a\n                         :py:class:`.Location` (i.e. the result of\n                         :py:meth:`.Well.top` or :py:meth:`.Well.bottom`), the\n                         robot will aspirate from the exact specified location.\n                         If unspecified, the robot will aspirate from the\n                         current position.\n        :param rate: The relative plunger speed for this aspirate. During\n                     this aspirate, the speed of the plunger will be\n                     `rate` * :py:attr:`aspirate_speed`. If not specified,\n                     defaults to 1.0 (speed will not be modified).\n        :type rate: float\n        :returns: This instance.\n        \"\"\"\n        self._log.debug(\"aspirate {} from {} at {}\"\n                        .format(volume,\n                                location if location else 'current position',\n                                rate))\n\n        if isinstance(location, Well):\n            point, well = location.bottom()\n            loc = types.Location(\n                point + types.Point(0, 0, self.well_bottom_clearance),\n                well)\n            self.move_to(loc)\n        elif isinstance(location, types.Location):\n            loc = location\n            self.move_to(location)\n        elif location is not None:\n            raise TypeError(\n                'location should be a Well or Location, but it is {}'\n                .format(location))\n        elif self._ctx.location_cache:\n            loc = self._ctx.location_cache\n        else:\n            raise RuntimeError(\n                \"If aspirate is called without an explicit location, another\"\n                \" method that moves to a location (such as move_to or \"\n                \"dispense) must previously have been called so the robot \"\n                \"knows where it is.\")\n        cmds.do_publish(self.broker, cmds.aspirate, self.aspirate,\n                        'before', None, None, self, volume, loc, rate)\n        self._hw_manager.hardware.aspirate(self._mount, volume, rate)\n        cmds.do_publish(self.broker, cmds.aspirate, self.aspirate,\n                        'after', self, None, self, volume, loc, rate)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mix(self,\n            repetitions: int = 1,\n            volume: float = None,\n            location: Union[types.Location, Well] = None,\n            rate: float = 1.0) -> 'InstrumentContext':\n        \"\"\"\n        Mix a volume of liquid (uL) using this pipette.\n        If no location is specified, the pipette will mix from its current\n        position. If no Volume is passed, 'mix' will default to its max_volume.\n\n        :param repetitions: how many times the pipette should mix (default: 1)\n        :param volume: number of microlitres to mix (default: self.max_volume)\n        :param location: a Well or a position relative to well.\n                         e.g, `plate.rows()[0][0].bottom()`\n                         (types.Location type).\n        :param rate: Set plunger speed for this mix, where,\n                     speed = rate * (aspirate_speed or dispense_speed)\n        :raises NoTipAttachedError: If no tip is attached to the pipette.\n        :returns: This instance\n        \"\"\"\n        self._log.debug(\n            'mixing {}uL with {} repetitions in {} at rate={}'.format(\n                volume, repetitions,\n                location if location else 'current position', rate))\n        if not self.hw_pipette['has_tip']:\n            raise hc.NoTipAttachedError('Pipette has no tip. Aborting mix()')\n\n        self.aspirate(volume, location, rate)\n        while repetitions - 1 > 0:\n            self.dispense(volume, rate=rate)\n            self.aspirate(volume, rate=rate)\n            repetitions -= 1\n        self.dispense(volume, rate=rate)\n        return self", "response": "Mix a single volume of liquid with another pipette."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef blow_out(self,\n                 location: Union[types.Location, Well] = None\n                 ) -> 'InstrumentContext':\n        \"\"\"\n        Blow liquid out of the tip.\n\n        If :py:attr:`dispense` is used to completely empty a pipette,\n        usually a small amount of liquid will remain in the tip. This\n        method moves the plunger past its usual stops to fully remove\n        any remaining liquid from the tip. Regardless of how much liquid\n        was in the tip when this function is called, after it is done\n        the tip will be empty.\n\n        :param location: The location to blow out into. If not specified,\n                         defaults to the current location of the pipette\n        :type location: :py:class:`.Well` or :py:class:`.Location` or None\n\n        :raises RuntimeError: If no location is specified and location cache is\n                              None. This should happen if `blow_out` is called\n                              without first calling a method that takes a\n                              location (eg, :py:meth:`.aspirate`,\n                              :py:meth:`dispense`)\n        :returns: This instance\n        \"\"\"\n        if location is None:\n            if not self._ctx.location_cache:\n                raise RuntimeError('No valid current location cache present')\n            else:\n                location = self._ctx.location_cache.labware  # type: ignore\n                # type checked below\n\n        if isinstance(location, Well):\n            if location.parent.is_tiprack:\n                self._log.warning('Blow_out being performed on a tiprack. '\n                                  'Please re-check your code')\n            target = location.top()\n        elif isinstance(location, types.Location) and not \\\n                isinstance(location.labware, Well):\n            raise TypeError(\n                'location should be a Well or None, but it is {}'\n                .format(location))\n        else:\n            raise TypeError(\n                'location should be a Well or None, but it is {}'\n                .format(location))\n        self.move_to(target)\n        self._hw_manager.hardware.blow_out(self._mount)\n        return self", "response": "Blows out the liquid of the current pipette."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntouching the pipette tip to the sides of a well.", "response": "def touch_tip(self,\n                  location: Well = None,\n                  radius: float = 1.0,\n                  v_offset: float = -1.0,\n                  speed: float = 60.0) -> 'InstrumentContext':\n        \"\"\"\n        Touch the pipette tip to the sides of a well, with the intent of\n        removing left-over droplets\n\n        :param location: If no location is passed, pipette will\n                         touch tip at current well's edges\n        :type location: :py:class:`.Well` or None\n        :param radius: Describes the proportion of the target well's\n                       radius. When `radius=1.0`, the pipette tip will move to\n                       the edge of the target well; when `radius=0.5`, it will\n                       move to 50% of the well's radius. Default: 1.0 (100%)\n        :type radius: float\n        :param v_offset: The offset in mm from the top of the well to touch tip\n                         A positive offset moves the tip higher above the well,\n                         while a negative offset moves it lower into the well\n                         Default: -1.0 mm\n        :type v_offset: float\n        :param speed: The speed for touch tip motion, in mm/s.\n                      Default: 60.0 mm/s, Max: 80.0 mm/s, Min: 20.0 mm/s\n        :type speed: float\n        :raises NoTipAttachedError: if no tip is attached to the pipette\n        :raises RuntimeError: If no location is specified and location cache is\n                              None. This should happen if `touch_tip` is called\n                              without first calling a method that takes a\n                              location (eg, :py:meth:`.aspirate`,\n                              :py:meth:`dispense`)\n        :returns: This instance\n\n        .. note::\n\n            This is behavior change from legacy API (which accepts any\n            :py:class:`.Placeable` as the ``location`` parameter)\n\n        \"\"\"\n        if not self.hw_pipette['has_tip']:\n            raise hc.NoTipAttachedError('Pipette has no tip to touch_tip()')\n\n        if speed > 80.0:\n            self._log.warning('Touch tip speed above limit. Setting to 80mm/s')\n            speed = 80.0\n        elif speed < 20.0:\n            self._log.warning('Touch tip speed below min. Setting to 20mm/s')\n            speed = 20.0\n\n        # If location is a valid well, move to the well first\n        if location is None:\n            if not self._ctx.location_cache:\n                raise RuntimeError('No valid current location cache present')\n            else:\n                location = self._ctx.location_cache.labware  # type: ignore\n                # type checked below\n\n        if isinstance(location, Well):\n            if location.parent.is_tiprack:\n                self._log.warning('Touch_tip being performed on a tiprack. '\n                                  'Please re-check your code')\n            self.move_to(location.top())\n        else:\n            raise TypeError(\n                'location should be a Well, but it is {}'.format(location))\n\n        # Determine the touch_tip edges/points\n        offset_pt = types.Point(0, 0, v_offset)\n        well_edges = [\n            # right edge\n            location._from_center_cartesian(x=radius, y=0, z=1) + offset_pt,\n            # left edge\n            location._from_center_cartesian(x=-radius, y=0, z=1) + offset_pt,\n            # back edge\n            location._from_center_cartesian(x=0, y=radius, z=1) + offset_pt,\n            # front edge\n            location._from_center_cartesian(x=0, y=-radius, z=1) + offset_pt\n        ]\n        for edge in well_edges:\n            self._hw_manager.hardware.move_to(self._mount, edge, speed)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef air_gap(self,\n                volume: float = None,\n                height: float = None) -> 'InstrumentContext':\n        \"\"\"\n        Pull air into the pipette current tip at the current location\n\n        :param volume: The amount in uL to aspirate air into the tube.\n                       (Default will use all remaining volume in tip)\n        :type volume: float\n\n        :param height: The number of millimiters to move above the current Well\n                       to air-gap aspirate. (Default: 5mm above current Well)\n        :type height: float\n\n        :raises NoTipAttachedError: If no tip is attached to the pipette\n\n        :raises RuntimeError: If location cache is None.\n                              This should happen if `touch_tip` is called\n                              without first calling a method that takes a\n                              location (eg, :py:meth:`.aspirate`,\n                              :py:meth:`dispense`)\n\n        :returns: This instance\n        \"\"\"\n        if not self.hw_pipette['has_tip']:\n            raise hc.NoTipAttachedError('Pipette has no tip. Aborting air_gap')\n\n        if height is None:\n            height = 5\n        loc = self._ctx.location_cache\n        if not loc or not isinstance(loc.labware, Well):\n            raise RuntimeError('No previous Well cached to perform air gap')\n        target = loc.labware.top(height)\n        self.move_to(target)\n        self.aspirate(volume)\n        return self", "response": "Moves air into the current tip at the current location."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef return_tip(self) -> 'InstrumentContext':\n        if not self.hw_pipette['has_tip']:\n            self._log.warning('Pipette has no tip to return')\n        loc = self._last_tip_picked_up_from\n        if not isinstance(loc, Well):\n            raise TypeError('Last tip location should be a Well but it is: '\n                            '{}'.format(loc))\n        bot = loc.bottom()\n        bot = bot._replace(point=bot.point._replace(z=bot.point.z + 10))\n        self.drop_tip(bot)\n        return self", "response": "Returns the last tip that is currently being used for the pipette."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npick up a tip from the pipette.", "response": "def pick_up_tip(self, location: Union[types.Location, Well] = None,\n                    presses: int = 3,\n                    increment: float = 1.0) -> 'InstrumentContext':\n        \"\"\"\n        Pick up a tip for the pipette to run liquid-handling commands with\n\n        If no location is passed, the Pipette will pick up the next available\n        tip in its :py:attr:`InstrumentContext.tip_racks` list.\n\n        The tip to pick up can be manually specified with the `location`\n        argument. The `location` argument can be specified in several ways:\n\n        * If the only thing to specify is which well from which to pick\n          up a tip, `location` can be a :py:class:`.Well`. For instance,\n          if you have a tip rack in a variable called `tiprack`, you can\n          pick up a specific tip from it with\n          ``instr.pick_up_tip(tiprack.wells()[0])``. This style of call can\n          be used to make the robot pick up a tip from a tip rack that\n          was not specified when creating the :py:class:`.InstrumentContext`.\n\n        * If the position to move to in the well needs to be specified,\n          for instance to tell the robot to run its pick up tip routine\n          starting closer to or farther from the top of the tip,\n          `location` can be a :py:class:`.types.Location`; for instance,\n          you can call ``instr.pick_up_tip(tiprack.wells()[0].top())``.\n\n        :param location: The location from which to pick up a tip.\n        :type location: :py:class:`.types.Location` or :py:class:`.Well` to\n                        pick up a tip from.\n        :param presses: The number of times to lower and then raise the pipette\n                        when picking up a tip, to ensure a good seal (0 [zero]\n                        will result in the pipette hovering over the tip but\n                        not picking it up--generally not desireable, but could\n                        be used for dry-run).\n        :type presses: int\n        :param increment: The additional distance to travel on each successive\n                          press (e.g.: if `presses=3` and `increment=1.0`, then\n                          the first press will travel down into the tip by\n                          3.5mm, the second by 4.5mm, and the third by 5.5mm).\n        :type increment: float\n\n        :returns: This instance\n        \"\"\"\n        num_channels = self.channels\n\n        def _select_tiprack_from_list(tip_racks) -> Tuple[Labware, Well]:\n            try:\n                tr = tip_racks[0]\n            except IndexError:\n                raise OutOfTipsError\n            next_tip = tr.next_tip(num_channels)\n            if next_tip:\n                return tr, next_tip\n            else:\n                return _select_tiprack_from_list(tip_racks[1:])\n\n        if location and isinstance(location, types.Location):\n            if isinstance(location.labware, Labware):\n                tiprack = location.labware\n                target: Well = tiprack.next_tip(num_channels)  # type: ignore\n                if not target:\n                    raise OutOfTipsError\n            elif isinstance(location.labware, Well):\n                tiprack = location.labware.parent\n                target = location.labware\n        elif location and isinstance(location, Well):\n            tiprack = location.parent\n            target = location\n        elif not location:\n            tiprack, target = _select_tiprack_from_list(self.tip_racks)\n        else:\n            raise TypeError(\n                \"If specified, location should be an instance of \"\n                \"types.Location (e.g. the return value from \"\n                \"tiprack.wells()[0].top()) or a Well (e.g. tiprack.wells()[0].\"\n                \" However, it is a {}\".format(location))\n\n        assert tiprack.is_tiprack, \"{} is not a tiprack\".format(str(tiprack))\n\n        self.move_to(target.top())\n\n        self._hw_manager.hardware.pick_up_tip(\n            self._mount, tiprack.tip_length, presses, increment)\n        # Note that the hardware API pick_up_tip action includes homing z after\n\n        tiprack.use_tips(target, num_channels)\n        self._last_tip_picked_up_from = target\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef drop_tip(\n            self,\n            location: Union[types.Location, Well] = None)\\\n            -> 'InstrumentContext':\n        \"\"\"\n        Drop the current tip.\n\n        If no location is passed, the Pipette will drop the tip into its\n        :py:attr:`trash_container`, which if not specified defaults to\n        the fixed trash in slot 12.\n\n        The location in which to drop the tip can be manually specified with\n        the `location` argument. The `location` argument can be specified in\n        several ways:\n\n            - If the only thing to specify is which well into which to drop\n              a tip, `location` can be a :py:class:`.Well`. For instance,\n              if you have a tip rack in a variable called `tiprack`, you can\n              drop a tip into a specific well on that tiprack with the call\n              `instr.pick_up_tip(tiprack.wells()[0])`. This style of call can\n              be used to make the robot drop a tip into arbitrary labware.\n            - If the position to drop the tip from as well as the\n              :py:class:`.Well` to drop the tip into needs to be specified,\n              for instance to tell the robot to drop a tip from an unusually\n              large height above the tiprack, `location`\n              can be a :py:class:`.types.Location`; for instance, you can call\n              `instr.pick_up_tip(tiprack.wells()[0].top())`.\n\n        .. note::\n\n            OT1 required homing the plunger after dropping tips, so the prior\n            version of `drop_tip` automatically homed the plunger. This is no\n            longer needed in OT2. If you need to home the plunger, use\n            :py:meth:`home_plunger`.\n\n        :param location: The location to drop the tip\n        :type location: :py:class:`.types.Location` or :py:class:`.Well` or\n                        None\n\n        :returns: This instance\n        \"\"\"\n        if location and isinstance(location, types.Location):\n            if isinstance(location.labware, Well):\n                target = location\n            else:\n                raise TypeError(\n                    \"If a location is specified as a types.Location (for \"\n                    \"instance, as the result of a call to \"\n                    \"tiprack.wells()[0].top()) it must be a location \"\n                    \"relative to a well, since that is where a tip is \"\n                    \"dropped. The passed location, however, is in \"\n                    \"reference to {}\".format(location.labware))\n        elif location and isinstance(location, Well):\n            if 'fixedTrash' in quirks_from_any_parent(location):\n                target = location.top()\n            else:\n                bot = location.bottom()\n                target = bot._replace(\n                    point=bot.point._replace(z=bot.point.z + 10))\n        elif not location:\n            target = self.trash_container.wells()[0].top()\n        else:\n            raise TypeError(\n                \"If specified, location should be an instance of \"\n                \"types.Location (e.g. the return value from \"\n                \"tiprack.wells()[0].top()) or a Well (e.g. tiprack.wells()[0].\"\n                \" However, it is a {}\".format(location))\n        self.move_to(target)\n        self._hw_manager.hardware.drop_tip(self._mount)\n        self._last_tip_picked_up_from = None\n        return self", "response": "This method will drop the current tip from the Pipette."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhomes the robot. :returns: This instance.", "response": "def home(self) -> 'InstrumentContext':\n        \"\"\" Home the robot.\n\n        :returns: This instance.\n        \"\"\"\n        def home_dummy(mount): pass\n        cmds.do_publish(self.broker, cmds.home, home_dummy,\n                        'before', None, None, self._mount.name.lower())\n        self._hw_manager.hardware.home_z(self._mount)\n        self._hw_manager.hardware.home_plunger(self._mount)\n        cmds.do_publish(self.broker, cmds.home, home_dummy,\n                        'after', self, None, self._mount.name.lower())\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef distribute(self,\n                   volume: float,\n                   source: Well,\n                   dest: List[Well],\n                   *args, **kwargs) -> 'InstrumentContext':\n        \"\"\"\n        Move a volume of liquid from one source to multiple destinations.\n\n        :param volume: The amount of volume to distribute to each destination\n                       well.\n        :param source: A single well from where liquid will be aspirated.\n        :param dest: List of Wells where liquid will be dispensed to.\n        :param kwargs: See :py:meth:`transfer`.\n        :returns: This instance\n        \"\"\"\n        self._log.debug(\"Distributing {} from {} to {}\"\n                        .format(volume, source, dest))\n        kwargs['mode'] = 'distribute'\n        kwargs['disposal_volume'] = kwargs.get('disposal_vol', self.min_volume)\n        return self.transfer(volume, source, dest, **kwargs)", "response": "Move a volume of liquid from one source to multiple destinations."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves liquid from one list of wells to another.", "response": "def consolidate(self,\n                    volume: float,\n                    source: List[Well],\n                    dest: Well,\n                    *args, **kwargs) -> 'InstrumentContext':\n        \"\"\"\n        Move liquid from multiple wells (sources) to a single well(destination)\n\n        :param volume: The amount of volume to consolidate from each source\n                       well.\n        :param source: List of wells from where liquid will be aspirated.\n        :param dest: The single well into which liquid will be dispensed.\n        :param kwargs: See :py:meth:`transfer`.\n        :returns: This instance\n        \"\"\"\n        self._log.debug(\"Consolidate {} from {} to {}\"\n                        .format(volume, source, dest))\n        kwargs['mode'] = 'consolidate'\n        return self.transfer(volume, source, dest, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transfer(self,\n                 volume: Union[float, Sequence[float]],\n                 source,\n                 dest,\n                 **kwargs) -> 'InstrumentContext':\n        # source: Union[Well, List[Well], List[List[Well]]],\n        # dest: Union[Well, List[Well], List[List[Well]]],\n        # TODO: Reach consensus on kwargs\n        # TODO: Decide if to use a disposal_volume\n        # TODO: Accordingly decide if remaining liquid should be blown out to\n        # TODO: ..trash or the original well.\n        # TODO: What should happen if the user passes a non-first-row well\n        # TODO: ..as src/dest *while using multichannel pipette?\n        r\"\"\"\n        Transfer will move a volume of liquid from a source location(s)\n        to a dest location(s). It is a higher-level command, incorporating\n        other :py:class:`InstrumentContext` commands, like :py:meth:`aspirate`\n        and :py:meth:`dispense`, designed to make protocol writing easier at\n        the cost of specificity.\n\n        :param volume: The amount of volume to aspirate from each source and\n                       dispense to each destination.\n                       If volume is a list, each volume will be used for the\n                       sources/targets at the matching index. If volumes is a\n                       tuple with two elements, like `(20, 100)`, then a list\n                       of volumes will be generated with a linear gradient\n                       between the two volumes in the tuple.\n        :param source: A single well or a list of wells from where liquid\n                       will be aspirated.\n        :param dest: A single well or a list of wells where liquid\n                     will be dispensed to.\n        :param \\**kwargs: See below\n\n        :Keyword Arguments:\n\n            * *new_tip* (``string``) --\n\n                - 'never': no tips will be picked up or dropped during transfer\n                - 'once': (default) a single tip will be used for all commands.\n                - 'always': use a new tip for each transfer.\n\n            * *trash* (``boolean``) --\n              If `False` (default behavior), tips will be\n              returned to their tip rack. If `True` and a trash\n              container has been attached to this `Pipette`,\n              then the tip will be sent to the trash container.\n\n            * *touch_tip* (``boolean``) --\n              If `True`, a :py:meth:`touch_tip` will occur following each\n              :py:meth:`aspirate` and :py:meth:`dispense`. If set to `False`\n              (default behavior), no :py:meth:`touch_tip` will occur.\n\n            * *blow_out* (``boolean``) --\n              If `True`, a :py:meth:`blow_out` will occur following each\n              :py:meth:`dispense`, but only if the pipette has no liquid left\n              in it. If set to `False` (default), no :py:meth:`blow_out` will\n              occur.\n\n            * *mix_before* (``tuple``) --\n              The tuple, if specified, gives the amount of volume to\n              :py:meth:`mix` preceding each :py:meth:`aspirate` during the\n              transfer. The tuple is interpreted as (repetitions, volume).\n\n            * *mix_after* (``tuple``) --\n              The tuple, if specified, gives the amount of volume to\n              :py:meth:`mix` after each :py:meth:`dispense` during the\n              transfer. The tuple is interpreted as (repetitions, volume).\n\n            * *disposal_vol* (``float``) --\n              (:py:meth:`distribute` only) Volume of liquid to be disposed off\n              after distributing. When dispensing multiple times from the same\n              tip, it is recommended to aspirate an extra amount of liquid to\n              be disposed off after distributing.\n\n            * *carryover* (``boolean``) --\n              If `True` (default), any `volume` that exceeds the maximum volume\n              of this Pipette will be split into multiple smaller volumes.\n\n            * *gradient* (``lambda``) --\n              Function for calculating the curve used for gradient volumes.\n              When `volume` is a tuple of length 2, its values are used to\n              create a list of gradient volumes. The default curve for this\n              gradient is linear (lambda x: x), however a method can be passed\n              with the `gradient` keyword argument to create a custom curve.\n\n        :returns: This instance\n        \"\"\"\n        self._log.debug(\"Transfer {} from {} to {}\".format(\n            volume, source, dest))\n\n        kwargs['mode'] = kwargs.get('mode', 'transfer')\n        mix_opts = transfers.Mix()\n        if 'mix_before' in kwargs and 'mix_after' in kwargs:\n            mix_strategy = transfers.MixStrategy.BOTH\n            before_opts = kwargs['mix_before']\n            after_opts = kwargs['mix_after']\n            mix_opts = mix_opts._replace(\n                mix_after=mix_opts.mix_after._replace(\n                    repetitions=after_opts[0], volume=after_opts[1]),\n                mix_before=mix_opts.mix_before._replace(\n                    repetitions=before_opts[0], volume=before_opts[1]))\n        elif 'mix_before' in kwargs:\n            mix_strategy = transfers.MixStrategy.BEFORE\n            before_opts = kwargs['mix_before']\n            mix_opts = mix_opts._replace(\n                mix_before=mix_opts.mix_before._replace(\n                    repetitions=before_opts[0], volume=before_opts[1]))\n        elif 'mix_after' in kwargs:\n            mix_strategy = transfers.MixStrategy.AFTER\n            after_opts = kwargs['mix_after']\n            mix_opts = mix_opts._replace(\n                mix_after=mix_opts.mix_after._replace(\n                    repetitions=after_opts[0], volume=after_opts[1]))\n        else:\n            mix_strategy = transfers.MixStrategy.NEVER\n\n        if kwargs.get('trash'):\n            drop_tip = transfers.DropTipStrategy.TRASH\n        else:\n            drop_tip = transfers.DropTipStrategy.RETURN\n\n        new_tip = kwargs.get('new_tip')\n        if isinstance(new_tip, str):\n            new_tip = types.TransferTipPolicy[new_tip.upper()]\n\n        blow_out = None\n        if kwargs.get('blow_out'):\n            blow_out = transfers.BlowOutStrategy.TRASH\n\n        touch_tip = None\n        if kwargs.get('touch_tip'):\n            touch_tip = transfers.TouchTipStrategy.ALWAYS\n        default_args = transfers.Transfer()\n        transfer_args = transfers.Transfer(\n            new_tip=new_tip or default_args.new_tip,\n            air_gap=kwargs.get('air_gap') or default_args.air_gap,\n            carryover=kwargs.get('carryover') or default_args.carryover,\n            gradient_function=(kwargs.get('gradient_function') or\n                               default_args.gradient_function),\n            disposal_volume=(kwargs.get('disposal_volume') or\n                             default_args.disposal_volume),\n            mix_strategy=mix_strategy,\n            drop_tip_strategy=drop_tip,\n            blow_out_strategy=blow_out or default_args.blow_out_strategy,\n            touch_tip_strategy=(touch_tip or\n                                default_args.touch_tip_strategy)\n        )\n        transfer_options = transfers.TransferOptions(transfer=transfer_args,\n                                                     mix=mix_opts)\n        plan = transfers.TransferPlan(volume, source, dest, self,\n                                      kwargs['mode'], transfer_options)\n        self._execute_transfer(plan)\n        return self", "response": "This method transfers a liquid from one location to another."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmove the instrument to the specified location.", "response": "def move_to(self, location: types.Location, force_direct: bool = False,\n                minimum_z_height: float = None\n                ) -> 'InstrumentContext':\n        \"\"\" Move the instrument.\n\n        :param location: The location to move to.\n        :type location: :py:class:`.types.Location`\n        :param force_direct: If set to true, move directly to destination\n                        without arc motion.\n        :param minimum_z_height: When specified, this Z margin is able to raise\n                                 (but never lower) the mid-arc height.\n        \"\"\"\n        if self._ctx.location_cache:\n            from_lw = self._ctx.location_cache.labware\n        else:\n            from_lw = None\n\n        from_center = 'centerMultichannelOnWells'\\\n            in quirks_from_any_parent(from_lw)\n        cp_override = CriticalPoint.XY_CENTER if from_center else None\n        from_loc = types.Location(\n            self._hw_manager.hardware.gantry_position(\n                self._mount, critical_point=cp_override),\n            from_lw)\n\n        moves = geometry.plan_moves(from_loc, location, self._ctx.deck,\n                                    force_direct=force_direct,\n                                    minimum_z_height=minimum_z_height)\n        self._log.debug(\"move_to: {}->{} via:\\n\\t{}\"\n                        .format(from_loc, location, moves))\n        try:\n            for move in moves:\n                self._hw_manager.hardware.move_to(\n                    self._mount, move[0], critical_point=move[1])\n        except Exception:\n            self._ctx.location_cache = None\n            raise\n        else:\n            self._ctx.location_cache = location\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the flow rate of the pipette.", "response": "def flow_rate(self, new_flow_rate: Dict[str, float]) -> None:\n        \"\"\" Update the speeds (in uL/s) for the pipette.\n\n        :param new_flow_rate: A dict containing at least one of 'aspirate'\n                              and 'dispense', mapping to new speeds in uL/s.\n        \"\"\"\n        self._hw_manager.hardware.set_flow_rate(self._mount, **new_flow_rate)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef type(self) -> str:\n        model = self.name\n        if 'single' in model:\n            return 'single'\n        elif 'multi' in model:\n            return 'multi'\n        else:\n            raise RuntimeError(\"Bad pipette model name: {}\".format(model))", "response": "Return the type of the pipette."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hw_pipette(self) -> Dict[str, Any]:\n        pipette = self._hw_manager.hardware.attached_instruments[self._mount]\n        if pipette is None:\n            raise types.PipetteNotAttachedError\n        return pipette", "response": "View the information returned by the hardware API directly."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a piece of labware on the module.", "response": "def load_labware(self, labware: Labware) -> Labware:\n        \"\"\" Specify the presence of a piece of labware on the module.\n\n        :param labware: The labware object. This object should be already\n                        initialized and its parent should be set to this\n                        module's geometry. To initialize and load a labware\n                        onto the module in one step, see\n                        :py:meth:`load_labware_by_name`.\n        :returns: The properly-linked labware object\n        \"\"\"\n        mod_labware = self._geometry.add_labware(labware)\n        self._ctx.deck.recalculate_high_z()\n        return mod_labware"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a piece of labware by its name.", "response": "def load_labware_by_name(self, name: str) -> Labware:\n        \"\"\" Specify the presence of a piece of labware on the module.\n\n        :param name: The name of the labware object.\n        :returns: The initialized and loaded labware object.\n        \"\"\"\n        lw = load(name, self._geometry.location)\n        return self.load_labware(lw)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload labware onto a Magnetic Module checking if it is compatible with the Magnetic Module and if not load it onto a Magnetic Module checking if it is compatible with the Magnetic Module and if not load it onto a Magnetic Module", "response": "def load_labware(self, labware: Labware) -> Labware:\n        \"\"\"\n        Load labware onto a Magnetic Module, checking if it is compatible\n        \"\"\"\n        if labware.magdeck_engage_height is None:\n            MODULE_LOG.warning(\n                \"This labware ({}) is not explicitly compatible with the\"\n                \" Magnetic Module. You will have to specify a height when\"\n                \" calling engage().\")\n        return super().load_labware(labware)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef engage(self, height: float = None, offset: float = None):\n        if height:\n            dist = height\n        elif self.labware and self.labware.magdeck_engage_height is not None:\n            dist = self.labware.magdeck_engage_height\n            if offset:\n                dist += offset\n        else:\n            raise ValueError(\n                \"Currently loaded labware {} does not have a known engage \"\n                \"height; please specify explicitly with the height param\"\n                .format(self.labware))\n        self._module.engage(dist)", "response": "Raise the Magnetic Module s magnets."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses the lid and returns the lid status", "response": "def close(self):\n        \"\"\" Closes the lid\"\"\"\n        self._geometry.lid_status = self._module.close()\n        self._ctx.deck.recalculate_high_z()\n        return self._geometry.lid_status"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_temperature(self,\n                        temp: float,\n                        hold_time: float = None,\n                        ramp_rate: float = None):\n        \"\"\" Set the target temperature, in C.\n\n        Valid operational range yet to be determined.\n        :param temp: The target temperature, in degrees C.\n        :param hold_time: The time to hold after reaching temperature. If\n                          ``hold_time`` is not specified, the Thermocycler will\n                          hold this temperature indefinitely (requiring manual\n                          intervention to end the cycle).\n        :param ramp_rate: The target rate of temperature change, in degC/sec.\n                          If ``ramp_rate`` is not specified, it will default to\n                          the maximum ramp rate as defined in the device\n                          configuration.\n        \"\"\"\n        return self._module.set_temperature(\n            temp=temp, hold_time=hold_time, ramp_rate=ramp_rate)", "response": "Set the target temperature in C.\n        Valid operational range yet to be determined."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def enter_bootloader(driver, model):\n    # Required for old bootloader\n    ports_before_dfu_mode = await _discover_ports()\n\n    driver.enter_programming_mode()\n    driver.disconnect()\n    new_port = ''\n    try:\n        new_port = await asyncio.wait_for(\n            _port_poll(_has_old_bootloader(model), ports_before_dfu_mode),\n            PORT_SEARCH_TIMEOUT)\n    except asyncio.TimeoutError:\n        pass\n    return new_port", "response": "Using the driver method, enter bootloader mode of the atmega32u4.\n    The bootloader mode opens a new port on the uC to upload the hex file.\n    After receiving a 'dfu' command, the firmware provides a 3-second window to\n    close the current port so as to do a clean switch to the bootloader port.\n    The new port shows up as 'ttyn_bootloader' on the pi; upload fw through it.\n    NOTE: Modules with old bootloader will have the bootloader port show up as\n    a regular module port- 'ttyn_tempdeck'/ 'ttyn_magdeck' with the port number\n    being either different or same as the one that the module was originally on\n    So we check for changes in ports and use the appropriate one"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the module firmware for the specified port.", "response": "async def update_firmware(port: str,\n                          firmware_file_path: str,\n                          loop: Optional[asyncio.AbstractEventLoop])\\\n                          -> Tuple[str, Tuple[bool, str]]:\n    \"\"\"\n    Run avrdude firmware upload command. Switch back to normal module port\n\n    Note: For modules with old bootloader, the kernel could assign the module\n    a new port after the update (since the board is automatically reset).\n    Scan for such a port change and use the appropriate port.\n\n    Returns a tuple of the new port to communicate on (or None if it was not\n    found) and a tuple of success and message from avrdude.\n    \"\"\"\n\n    ports_before_update = await _discover_ports()\n    config_file_path = os.path.join(package_root,\n                                    'config', 'modules', 'avrdude.conf')\n    kwargs: Dict[str, Any] = {\n        'stdout': asyncio.subprocess.PIPE,\n        'stderr': asyncio.subprocess.PIPE\n    }\n    if loop:\n        kwargs['loop'] = loop\n    proc = await asyncio.create_subprocess_exec(\n        'avrdude', '-C{}'.format(config_file_path), '-v',\n        '-p{}'.format(PART_NO),\n        '-c{}'.format(PROGRAMMER_ID),\n        '-P{}'.format(port),\n        '-b{}'.format(BAUDRATE), '-D',\n        '-Uflash:w:{}:i'.format(firmware_file_path),\n        **kwargs)\n    await proc.wait()\n\n    _result = await proc.communicate()\n    result = _result[1].decode()\n    avrdude_res = _format_avrdude_response(result)\n    if avrdude_res[0]:\n        log.debug(result)\n    else:\n        log.error(\"Failed to update module firmware for {}: {}\"\n                  .format(port, avrdude_res[1]))\n    new_port = await _port_on_mode_switch(ports_before_update)\n    log.info(\"New port: {}\".format(new_port))\n    return new_port, avrdude_res"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npolls for the bootloader port.", "response": "async def _port_poll(is_old_bootloader, ports_before_switch=None):\n    \"\"\"\n    Checks for the bootloader port\n    \"\"\"\n    new_port = ''\n    while not new_port:\n        if is_old_bootloader:\n            new_port = await _port_on_mode_switch(ports_before_switch)\n        else:\n            ports = await _discover_ports()\n            if ports:\n                discovered_ports = list(filter(\n                    lambda x: x.endswith('bootloader'), ports))\n                if len(discovered_ports) == 1:\n                    new_port = '/dev/modules/{}'.format(discovered_ports[0])\n        await asyncio.sleep(0.05)\n    return new_port"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the critical point for the current pipette.", "response": "def critical_point(self, cp_override: CriticalPoint = None) -> Point:\n        \"\"\"\n        The vector from the pipette's origin to its critical point. The\n        critical point for a pipette is the end of the nozzle if no tip is\n        attached, or the end of the tip if a tip is attached.\n\n        If `cp_override` is specified and valid - so is either\n        :py:attr:`CriticalPoint.NOZZLE` or :py:attr:`CriticalPoint.TIP` when\n        we have a tip, or :py:attr:`CriticalPoint.XY_CENTER` - the specified\n        critical point will be used.\n        \"\"\"\n        if not self.has_tip or cp_override == CriticalPoint.NOZZLE:\n            cp_type = CriticalPoint.NOZZLE\n            tip_length = 0.0\n        else:\n            cp_type = CriticalPoint.TIP\n            tip_length = self.current_tip_length\n        if cp_override == CriticalPoint.XY_CENTER:\n            mod_offset_xy = [0, 0, self.config.model_offset[2]]\n            cp_type = CriticalPoint.XY_CENTER\n        elif cp_override == CriticalPoint.FRONT_NOZZLE:\n            mod_offset_xy = [\n                0, -self.config.model_offset[1], self.config.model_offset[2]]\n            cp_type = CriticalPoint.FRONT_NOZZLE\n        else:\n            mod_offset_xy = self.config.model_offset\n        mod_and_tip = Point(mod_offset_xy[0],\n                            mod_offset_xy[1],\n                            mod_offset_xy[2] - tip_length)\n        cp = mod_and_tip + self._instrument_offset._replace(z=0)\n        if self._log.isEnabledFor(logging.DEBUG):\n            mo = 'model offset: {} + '.format(self.config.model_offset)\\\n                if cp_type != CriticalPoint.XY_CENTER else ''\n            info_str = 'cp: {}{}: {}=({}instr offset xy: {}'\\\n                .format(cp_type, '(from override)' if cp_override else '',\n                        cp, mo,\n                        self._instrument_offset._replace(z=0))\n            if cp_type == CriticalPoint.TIP:\n                info_str += '- current_tip_length: {}=(true tip length: {}'\\\n                    ' - inst z: {}) (z only)'.format(\n                        self.current_tip_length, self._current_tip_length,\n                        self._instrument_offset.z)\n            info_str += ')'\n            self._log.debug(info_str)\n        return cp"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a tip to the pipette for position tracking and validation.", "response": "def add_tip(self, tip_length) -> None:\n        \"\"\"\n        Add a tip to the pipette for position tracking and validation\n        (effectively updates the pipette's critical point)\n\n        :param tip_length: a positive, non-zero float representing the distance\n            in Z from the end of the pipette nozzle to the end of the tip\n        :return:\n        \"\"\"\n        assert tip_length > 0.0, \"tip_length must be greater than 0\"\n        assert not self.has_tip\n        self._has_tip = True\n        self._current_tip_length = tip_length"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect_to_robot():\n    '''\n    Connect over Serial to the Smoothieware motor driver\n    '''\n    print()\n    import optparse\n    from opentrons import robot\n    print('Connecting to robot...')\n    parser = optparse.OptionParser(usage='usage: %prog [options] ')\n    parser.add_option(\n        \"-p\", \"--p\", dest=\"port\", default='',\n        type='str', help='serial port of the smoothie'\n    )\n\n    options, _ = parser.parse_args(args=None, values=None)\n    if options.port:\n        robot.connect(options.port)\n    else:\n        robot.connect()\n    return robot", "response": "Connect to the Smoothieware motor driver"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite identifiers to the specified pipette.", "response": "def write_identifiers(robot, mount, new_id, new_model):\n    '''\n    Send a bytearray to the specified mount, so that Smoothieware can\n    save the bytes to the pipette's memory\n    '''\n    robot._driver.write_pipette_id(mount, new_id)\n    read_id = robot._driver.read_pipette_id(mount)\n    _assert_the_same(new_id, read_id)\n    robot._driver.write_pipette_model(mount, new_model)\n    read_model = robot._driver.read_pipette_model(mount)\n    _assert_the_same(new_model, read_model)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _user_submitted_barcode(max_length):\n    '''\n    User can enter a serial number as a string of HEX values\n    Length of byte array must equal `num`\n    '''\n    barcode = input('BUTTON + SCAN: ').strip()\n    if len(barcode) > max_length:\n        raise Exception(BAD_BARCODE_MESSAGE.format(barcode))\n    # remove all characters before the letter P\n    # for example, remove ASCII selector code \"\\x1b(B\" on chinese keyboards\n    barcode = barcode[barcode.index('P'):]\n    barcode = barcode.split('\\r')[0].split('\\n')[0]  # remove any newlines\n    return barcode", "response": "User has entered a serial number as a string of HEX values"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmounting or unmount a unit.", "response": "def set_mounted(unitname: str, mounted: bool, swallow_exc: bool = False):\n    \"\"\" Mount or unmount a unit.\n\n    Worker for the contextlibs\n\n    :param unitname: The systemd unit for the mount to affect. This probably\n                     should be one of :py:attr:`_SYSROOT_INACTIVE_UNIT` or\n                     :py:attr:`_BOOT_UNIT` but it could be anything\n    :param mounted: ``True`` to start the mount unit, ``False`` to stop it\n    :param swallow_exc: ``True`` to capture all exceptions, ``False`` to pass\n                        them upwards. This is useful for when you don't super\n                        care about the success of the mount, like when trying\n                        to restore the system after you write the boot part\n    \"\"\"\n    try:\n        if mounted:\n            LOG.info(f\"Starting {unitname}\")\n            interface().StartUnit(unitname, 'replace')\n            LOG.info(f\"Started {unitname}\")\n        else:\n            LOG.info(f\"Stopping {unitname}\")\n            interface().StopUnit(unitname, 'replace')\n            LOG.info(f\"Stopped {unitname}\")\n    except Exception:\n        LOG.info(\n            f\"Exception {'starting' if mounted else 'stopping'} {unitname}\")\n        if not swallow_exc:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart the validation process.", "response": "def _begin_validation(\n        session: UpdateSession,\n        loop: asyncio.AbstractEventLoop,\n        downloaded_update_path: str,\n        robot_name: str) -> asyncio.futures.Future:\n    \"\"\" Start the validation process. \"\"\"\n    session.set_stage(Stages.VALIDATING)\n\n    validation_future \\\n        = asyncio.ensure_future(loop.run_in_executor(\n            None, validate_update,\n            downloaded_update_path, session.set_progress))\n\n    def validation_done(fut):\n        exc = fut.exception()\n        if exc:\n            session.set_error(getattr(exc, 'short', str(type(exc))),\n                              str(exc))\n        else:\n            rootfs_file, bootfs_file = fut.result()\n            loop.call_soon_threadsafe(_begin_write,\n                                      session,\n                                      loop,\n                                      rootfs_file,\n                                      robot_name)\n    validation_future.add_done_callback(validation_done)\n    return validation_future"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def commit(\n        request: web.Request, session: UpdateSession) -> web.Response:\n    \"\"\" Serves /update/:session/commit \"\"\"\n    if session.stage != Stages.DONE:\n        return web.json_response(\n            data={'error': 'not-ready',\n                  'message': f'System is not ready to commit the update '\n                  f'(currently {session.stage.value.short})'},\n            status=409)\n    with dbus_actions.unmount_boot():\n        write_file(os.path.join(session.download_path, BOOT_NAME),\n                   constants.BOOT_PARTITION_NAME,\n                   lambda x: None)\n\n    session.set_stage(Stages.READY_FOR_RESTART)\n\n    return web.json_response(\n        data=session.state,\n        status=200)", "response": "Serves / update/:session / commit"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def restart(request: web.Request) -> web.Response:\n    session = session_from_request(request)\n    if session and session.stage != Stages.READY_FOR_RESTART:\n        return web.json_response(\n            data={'error': 'not-ready',\n                  'message': 'System is not ready to restart '\n                  f'(currently {session.stage.value.short})'},\n            status=409)\n\n    asyncio.get_event_loop().call_later(1, dbus_actions.restart)\n    return web.json_response({'message': 'Restarting in 1s'},\n                             status=200)", "response": "Serves / update / server / restart"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the version field from a valid package. json file and returns the string or unknown", "response": "def get_version(path) -> str:\n    \"\"\"\n    Reads the version field from a package file\n\n    :param path: the path to a valid package.json file\n    :return: the version string or \"unknown\"\n    \"\"\"\n    if path and os.path.exists(path):\n        with open(path) as pkg:\n            package_dict = json.load(pkg)\n            version = package_dict.get('version')\n    else:\n        version = 'not available'\n    return version"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the list of tuples describing motions for doing the xy part of the tip probe box based on the tip probe box s description of the tip probe box.", "response": "def calculate_tip_probe_hotspots(\n        tip_length: float,\n        tip_probe_settings: tip_probe_config)\\\n        -> List[HotSpot]:\n    \"\"\"\n    Generate a list of tuples describing motions for doing the xy part of\n    tip probe based on the config's description of the tip probe box.\n    \"\"\"\n    # probe_dimensions is the external bounding box of the probe unit\n    size_x, size_y, size_z = tip_probe_settings.dimensions\n\n    rel_x_start = (size_x / 2) + tip_probe_settings.switch_clearance\n    rel_y_start = (size_y / 2) + tip_probe_settings.switch_clearance\n\n    # Ensure that the nozzle will clear the probe unit and tip will clear deck\n    nozzle_safe_z = round((size_z - tip_length)\n                          + tip_probe_settings.z_clearance.normal, 3)\n\n    z_start = max(tip_probe_settings.z_clearance.deck, nozzle_safe_z)\n    switch_offset = tip_probe_settings.switch_offset\n    # Each list item defines axis we are probing for, starting position vector\n    # and travel distance\n    neg_x = HotSpot('x',\n                    -rel_x_start,\n                    switch_offset[0],\n                    z_start,\n                    size_x)\n    pos_x = HotSpot('x',\n                    rel_x_start,\n                    switch_offset[0],\n                    z_start,\n                    -size_x)\n    neg_y = HotSpot('y',\n                    switch_offset[1],\n                    -rel_y_start,\n                    z_start,\n                    size_y)\n    pos_y = HotSpot('y',\n                    switch_offset[1],\n                    rel_y_start,\n                    z_start,\n                    -size_y)\n    z = HotSpot(\n        'z',\n        0,\n        switch_offset[2],\n        tip_probe_settings.center[2] + tip_probe_settings.z_clearance.start,\n        -size_z)\n\n    return [\n        neg_x,\n        pos_x,\n        neg_y,\n        pos_y,\n        z\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nenables a GPIO pin in the .", "response": "def _enable_pin(pin, direction):\n    \"\"\"\n    In order to enable a GPIO pin, the pin number must be written into\n    /sys/class/gpio/export, and then the direction (\"in\" or \"out\" must be\n    written to /sys/class/gpio/gpio<number>/direction\n\n    :param pin: An integer corresponding to the GPIO number of the pin in RPi\n      GPIO board numbering (not physical pin numbering)\n\n    :param direction: \"in\" or \"out\"\n    \"\"\"\n    _write_value(pin, \"{}/export\".format(_path_prefix))\n    _write_value(direction, \"{0}/gpio{1}/direction\".format(_path_prefix, pin))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting specified value into path.", "response": "def _write_value(value, path):\n    \"\"\"\n    Writes specified value into path. Note that the value is wrapped in single\n    quotes in the command, to prevent injecting bash commands.\n    :param value: The value to write (usually a number or string)\n    :param path: A valid system path\n    \"\"\"\n    base_command = \"echo '{0}' > {1}\"\n    # There is no common method for redirecting stderr to a null sink, so the\n    # command string is platform-dependent\n    if platform == 'win32':\n        command = \"{0} > NUL\".format(base_command)\n    else:\n        command = \"exec 2> /dev/null; {0}\".format(base_command)\n    os.system(command.format(value, path))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the value of the specified path.", "response": "def _read_value(path):\n    \"\"\"\n    Reads value of specified path.\n    :param path: A valid system path\n    \"\"\"\n    read_value = 0\n    if not os.path.exists(path):\n        # Path will generally only exist on a Raspberry Pi\n        pass\n    else:\n        with open(path) as f:\n            read_value = int(f.read())\n    return read_value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initialize():\n    for pin in sorted(OUTPUT_PINS.values()):\n        _enable_pin(pin, OUT)\n\n    for pin in sorted(INPUT_PINS.values()):\n        _enable_pin(pin, IN)", "response": "All named pins in OUTPUT_PINS and INPUT_PINS are exported, and set the\n    HALT pin high (normal running state), since the default value after export\n    is low."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init(loop=None, hardware: 'HardwareAPILike' = None):\n\n    app = web.Application(loop=loop, middlewares=[error_middleware])\n    if hardware:\n        checked_hardware = hardware\n    else:\n        checked_hardware = opentrons.hardware\n    app['com.opentrons.hardware'] = checked_hardware\n    app['com.opentrons.rpc'] = RPCServer(app, MainRouter(checked_hardware))\n    app['com.opentrons.http'] = HTTPServer(app, CONFIG['log_dir'])\n\n    return app", "response": "Builds an application and sets up RPC and HTTP servers with it."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts the Opentrons server application.", "response": "def run(hostname=None, port=None, path=None, loop=None):\n    \"\"\"\n    The arguments are not all optional. Either a path or hostname+port should\n    be specified; you have to specify one.\n    \"\"\"\n    if path:\n        log.debug(\"Starting Opentrons server application on {}\".format(\n            path))\n        hostname, port = None, None\n    else:\n        log.debug(\"Starting Opentrons server application on {}:{}\".format(\n            hostname, port))\n        path = None\n\n    web.run_app(init(loop), host=hostname, port=port, path=path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nscan for connected modules and instantiate handler classes", "response": "def discover() -> List[Tuple[str, str]]:\n    \"\"\" Scan for connected modules and instantiate handler classes\n    \"\"\"\n    if IS_ROBOT and os.path.isdir('/dev/modules'):\n        devices = os.listdir('/dev/modules')\n    else:\n        devices = []\n\n    discovered_modules = []\n\n    module_port_regex = re.compile('|'.join(MODULE_TYPES.keys()), re.I)\n    for port in devices:\n        match = module_port_regex.search(port)\n        if match:\n            name = match.group().lower()\n            if name not in MODULE_TYPES:\n                log.warning(\"Unexpected module connected: {} on {}\"\n                            .format(name, port))\n                continue\n            absolute_port = '/dev/modules/{}'.format(port)\n            discovered_modules.append((absolute_port, name))\n    log.info('Discovered modules: {}'.format(discovered_modules))\n\n    return discovered_modules"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def update_firmware(\n        module: AbstractModule,\n        firmware_file: str,\n        loop: Optional[asyncio.AbstractEventLoop]) -> AbstractModule:\n    \"\"\" Update a module.\n\n    If the update succeeds, an Module instance will be returned.\n\n    Otherwise, raises an UpdateError with the reason for the failure.\n    \"\"\"\n    simulating = module.is_simulated\n    cls = type(module)\n    old_port = module.port\n    flash_port = await module.prep_for_update()\n    callback = module.interrupt_callback\n    del module\n    after_port, results = await update.update_firmware(flash_port,\n                                                       firmware_file,\n                                                       loop)\n    await asyncio.sleep(1.0)\n    new_port = after_port or old_port\n    if not results[0]:\n        raise UpdateError(results[1])\n    return await cls.build(\n        port=new_port,\n        interrupt_callback=callback,\n        simulating=simulating)", "response": "Update a module s firmware."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef move(self, pose_tree, x=None, y=None, z=None, home_flagged_axes=True):\n        def defaults(_x, _y, _z):\n            _x = _x if x is not None else 0\n            _y = _y if y is not None else 0\n            _z = _z if z is not None else 0\n            return _x, _y, _z\n\n        dst_x, dst_y, dst_z = change_base(\n            pose_tree,\n            src=self._src,\n            dst=self._dst,\n            point=Point(*defaults(x, y, z)))\n        driver_target = {}\n\n        if 'x' in self._axis_mapping:\n            assert x is not None, \"Value must be set for each axis mapped\"\n            driver_target[self._axis_mapping['x']] = dst_x\n\n        if 'y' in self._axis_mapping:\n            assert y is not None, \"Value must be set for each axis mapped\"\n            driver_target[self._axis_mapping['y']] = dst_y\n\n        if 'z' in self._axis_mapping:\n            assert z is not None, \"Value must be set for each axis mapped\"\n            driver_target[self._axis_mapping['z']] = dst_z\n        self._driver.move(driver_target, home_flagged_axes=home_flagged_axes)\n\n        # Update pose with the new value. Since stepper motors are open loop\n        # there is no need to to query diver for position\n        return update(pose_tree, self, Point(*defaults(dst_x, dst_y, dst_z)))", "response": "Move the current object to another location."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_update(\n        filepath: str,\n        progress_callback: Callable[[float], None]) -> Tuple[str, str]:\n    \"\"\" Like otupdate.buildroot.file_actions.validate_update but moreso\n\n    Checks for the rootfs, rootfs hash, bootfs, and bootfs hash.\n\n    Returns the path to the rootfs and the path to the bootfs\n    \"\"\"\n    filenames = [ROOTFS_NAME, ROOTFS_HASH_NAME, BOOT_NAME, BOOT_HASH_NAME]\n\n    def zip_callback(progress):\n        progress_callback(progress/3.0)\n\n    files, sizes = unzip_update(filepath, zip_callback, filenames, filenames)\n\n    def rootfs_hash_callback(progress):\n        progress_callback(progress/3.0 + 0.33)\n\n    rootfs = files.get(ROOTFS_NAME)\n    assert rootfs\n    rootfs_calc_hash = hash_file(rootfs, rootfs_hash_callback,\n                                 file_size=sizes[ROOTFS_NAME])\n    rootfs_hashfile = files.get(ROOTFS_HASH_NAME)\n    assert rootfs_hashfile\n    rootfs_packaged_hash = open(rootfs_hashfile, 'rb').read().strip()\n    if rootfs_calc_hash != rootfs_packaged_hash:\n        msg = f\"Hash mismatch (rootfs): calculated {rootfs_calc_hash} != \"\\\n            f\"packaged {rootfs_packaged_hash}\"\n        LOG.error(msg)\n        raise HashMismatch(msg)\n\n    def bootfs_hash_callback(progress):\n        progress_callback(progress/3.0 + 0.66)\n\n    bootfs = files.get(BOOT_NAME)\n    assert bootfs\n    bootfs_calc_hash = hash_file(bootfs, bootfs_hash_callback,\n                                 file_size=sizes[BOOT_NAME])\n    bootfs_hashfile = files.get(BOOT_HASH_NAME)\n    assert bootfs_hashfile\n    bootfs_packaged_hash = open(bootfs_hashfile, 'rb').read().strip()\n    if bootfs_calc_hash != bootfs_packaged_hash:\n        msg = f\"Hash mismatch (bootfs): calculated {bootfs_calc_hash} != \"\\\n            f\"packged {bootfs_packaged_hash}\"\n        LOG.error(msg)\n        raise HashMismatch(msg)\n\n    return rootfs, bootfs", "response": "Validate the update file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the current sysroot and return the path to the active bootpart.", "response": "def find_active_sysroot() -> str:\n    \"\"\" Parse /proc/cmdline to find the active sysroot. Return the path \"\"\"\n    cmdline = _get_proc_cmdline()\n    match = re.search(b'root=([/a-zA-Z0-9.]+)', cmdline)\n    if not match:\n        raise RuntimeError(f\"Couldn't find bootpart from {cmdline}\")\n    return match.group(1).decode()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npatching any paths in a NetworkManager connection file to remove the balena host paths", "response": "def patch_connection_file_paths(connection: str) -> str:\n    \"\"\"\n    Patch any paths in a connection to remove the balena host paths\n\n    Undoes the changes applied by\n    :py:meth:`opentrons.system.nmcli._rewrite_key_path_to_host_path`\n\n    :param connection: The contents of a NetworkManager connection file\n    :return: The patches contents, suitable for writing somewher\n    \"\"\"\n    new_conn_lines = []\n    for line in connection.split('\\n'):\n        if '=' in line:\n            parts = line.split('=')\n            path_matches = re.search(\n                '/mnt/data/resin-data/[0-9]+/(.*)', parts[1])\n            if path_matches:\n                new_path = f'/data/{path_matches.group(1)}'\n                new_conn_lines.append(\n                    '='.join([parts[0], new_path]))\n                LOG.info(\n                    f\"migrate_connection_file: {parts[0]}: \"\n                    f\"{parts[1]}->{new_path}\")\n                continue\n        new_conn_lines.append(line)\n    return '\\n'.join(new_conn_lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmigrates all files in the app data directory to the root of the new partition.", "response": "def migrate(ignore: Sequence[str], name: str):\n    \"\"\" Copy everything in the app data to the root of the new partition\n\n    :param ignore: Files to ignore in the root. This should be populated\n                   with the names (with no directory elements) of the migration\n                   update zipfile and everything unzipped from it.\n    :param str: The name of the robot\n    \"\"\"\n    try:\n        with mount_data_partition() as datamount:\n            migrate_data(ignore, datamount, DATA_DIR_NAME)\n            migrate_connections(datamount)\n            migrate_hostname(datamount, name)\n    except Exception:\n        LOG.exception(\"Exception during data migration\")\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies all files in the app data directory to the new data directory.", "response": "def migrate_data(ignore: Sequence[str],\n                 new_data_path: str,\n                 old_data_path: str):\n    \"\"\" Copy everything in the app data to the root of the main data part\n\n    :param ignore: A list of files that should be ignored in the root of /data\n    :param new_data_path: Where the new data partition is mounted\n    :param old_data_path: Where the old date files are\n    \"\"\"\n    # the new \u2019data\u2019 path is actually /var and /data is in /var/data\n    dest_data = os.path.join(new_data_path, 'data')\n    LOG.info(f\"migrate_data: copying {old_data_path} to {dest_data}\")\n    os.makedirs(dest_data, exist_ok=True)\n    with os.scandir(old_data_path) as scanner:\n        for entry in scanner:\n            if entry.name in ignore:\n                LOG.info(f\"migrate_data: ignoring {entry.name}\")\n                continue\n            src = os.path.join(old_data_path, entry.name)\n            dest = os.path.join(dest_data, entry.name)\n            if os.path.exists(dest):\n                LOG.info(f\"migrate_data: removing dest tree {dest}\")\n                shutil.rmtree(dest, ignore_errors=True)\n            if entry.is_dir():\n                LOG.info(f\"migrate_data: copying tree {src}->{dest}\")\n                shutil.copytree(src, dest, symlinks=True,\n                                ignore=migrate_files_to_ignore)\n            else:\n                LOG.info(f\"migrate_data: copying file {src}->{dest}\")\n                shutil.copy2(src, dest)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmigrates the contents of a system - connections dir to a new location.", "response": "def migrate_system_connections(src_sc: str, dest_sc: str) -> bool:\n    \"\"\" Migrate the contents of a system-connections dir\n\n    :param dest_sc: The system-connections to copy to. Will be created if it\n                    does not exist\n    :param src_sc: The system-connections to copy from\n    :return: True if anything was moved\n    \"\"\"\n    found = False\n    LOG.info(f\"migrate_system_connections: checking {dest_sc}\")\n    os.makedirs(dest_sc, exist_ok=True)\n    with os.scandir(src_sc) as scanner:\n        for entry in scanner:\n            # ignore readme and sample\n            if entry.name.endswith('.ignore'):\n                continue\n            # ignore the hardwired connection added by api server\n            if entry.name == 'static-eth0':\n                continue\n            # ignore weird remnants of boot partition connections\n            if entry.name.startswith('._'):\n                continue\n            patched = patch_connection_file_paths(\n                open(os.path.join(src_sc, entry.name), 'r').read())\n            open(os.path.join(dest_sc, entry.name), 'w').write(patched)\n            LOG.info(f\"migrate_connections: migrated {entry.name}\")\n            found = True\n    return found"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmigrates wifi connection files to new locations and patch them", "response": "def migrate_connections(new_data_path: str):\n    \"\"\" Migrate wifi connection files to new locations and patch them\n\n    :param new_data_path: The path to where the new data partition is mounted\n    \"\"\"\n    dest_connections = os.path.join(\n        new_data_path, 'lib', 'NetworkManager', 'system-connections')\n    os.makedirs(dest_connections, exist_ok=True)\n\n    with mount_state_partition() as state_path:\n        src_connections = os.path.join(\n            state_path, 'root-overlay', 'etc', 'NetworkManager',\n            'system-connections')\n        LOG.info(f\"migrate_connections: moving nmcli connections from\"\n                 f\" {src_connections} to {dest_connections}\")\n        found = migrate_system_connections(src_connections, dest_connections)\n\n    if found:\n        return\n\n    LOG.info(\n        \"migrate_connections: No connections found in state, checking boot\")\n\n    with mount_boot_partition() as boot_path:\n        src_connections = os.path.join(\n            boot_path, 'system-connections')\n        LOG.info(f\"migrate_connections: moving nmcli connections from\"\n                 f\" {src_connections} to {dest_connections}\")\n        found = migrate_system_connections(src_connections, dest_connections)\n        if not found:\n            LOG.info(\"migrate_connections: No connections found in boot\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef migrate_hostname(dest_data: str, name: str):\n    if name.startswith('opentrons-'):\n        name = name[len('opentrons-'):]\n    LOG.info(\n        f\"migrate_hostname: writing name {name} to {dest_data}/hostname,\"\n        f\" {dest_data}/machine-info, {dest_data}/serial\")\n    with open(os.path.join(dest_data, 'hostname'), 'w') as hn:\n        hn.write(name + \"\\n\")\n    with open(os.path.join(dest_data, 'machine-info'), 'w') as mi:\n        mi.write(f'PRETTY_HOSTNAME={name}\\nDEPLOYMENT=production\\n')\n    with open(os.path.join(dest_data, 'serial'), 'w') as ser:\n        ser.write(name)", "response": "Write the machine name to a couple different places."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_flow_rate(pipette, params) -> None:\n    flow_rate_param = params['flowRate']\n\n    if not (flow_rate_param > 0):\n        raise RuntimeError('Positive flowRate param required')\n\n    pipette.flow_rate = {\n        'aspirate': flow_rate_param,\n        'dispense': flow_rate_param\n    }", "response": "Set flow rate in uL / mm to value obtained from command s params."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninfer the base directory of the config file.", "response": "def infer_config_base_dir() -> Path:\n    \"\"\" Return the directory to store data in.\n\n    Defaults are ~/.opentrons if not on a pi; OT_API_CONFIG_DIR is\n    respected here.\n\n    When this module is imported, this function is called automatically\n    and the result stored in :py:attr:`APP_DATA_DIR`.\n\n    This directory may not exist when the module is imported. Even if it\n    does exist, it may not contain data, or may require data to be moved\n    to it.\n\n    :return pathlib.Path: The path to the desired root settings dir.\n    \"\"\"\n    if 'OT_API_CONFIG_DIR' in os.environ:\n        return Path(os.environ['OT_API_CONFIG_DIR'])\n    elif IS_ROBOT:\n        return Path('/data')\n    else:\n        search = (Path.cwd(),\n                  Path.home()/'.opentrons')\n        for path in search:\n            if (path/_CONFIG_FILENAME).exists():\n                return path\n        else:\n            return search[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the settings directory tree and migrate it to the correct base directory.", "response": "def load_and_migrate() -> Dict[str, Path]:\n    \"\"\" Ensure the settings directory tree is properly configured.\n\n    This function does most of its work on the actual robot. It will move\n    all settings files from wherever they happen to be to the proper\n    place. On non-robots, this mostly just loads. In addition, it writes\n    a default config and makes sure all directories required exist (though\n    the files in them may not).\n    \"\"\"\n    if IS_ROBOT:\n        _migrate_robot()\n    base = infer_config_base_dir()\n    base.mkdir(parents=True, exist_ok=True)\n    index = _load_with_overrides(base)\n    return _ensure_paths_and_types(index)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads an existing config or write its defaults", "response": "def _load_with_overrides(base) -> Dict[str, str]:\n    \"\"\" Load an config or write its defaults \"\"\"\n    should_write = False\n    overrides = _get_environ_overrides()\n    try:\n        index = json.load((base/_CONFIG_FILENAME).open())\n    except (OSError, json.JSONDecodeError) as e:\n        sys.stderr.write(\"Error loading config from {}: {}\\nRewriting...\\n\"\n                         .format(str(base), e))\n        should_write = True\n        index = generate_config_index(overrides)\n\n    for key in CONFIG_ELEMENTS:\n        if key.name not in index:\n            sys.stderr.write(\n                f\"New config index key {key.name}={key.default}\"\n                \"\\nRewriting...\\n\")\n            if key.kind in (ConfigElementType.DIR, ConfigElementType.FILE):\n                index[key.name] = base/key.default\n            else:\n                index[key.name] = key.default\n            should_write = True\n\n    if should_write:\n        try:\n            write_config(index, path=base)\n        except Exception as e:\n            sys.stderr.write(\n                \"Error writing config to {}: {}\\nProceeding memory-only\\n\"\n                .format(str(base), e))\n    index.update(overrides)\n    return index"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake the direct results of loading the config and make sure that the filesystem reflects them.", "response": "def _ensure_paths_and_types(index: Dict[str, str]) -> Dict[str, Path]:\n    \"\"\" Take the direct results of loading the config and make sure\n    the filesystem reflects them.\n    \"\"\"\n    configs_by_name = {ce.name: ce for ce in CONFIG_ELEMENTS}\n    correct_types: Dict[str, Path] = {}\n    for key, item in index.items():\n        if key not in configs_by_name:  # old config, ignore\n            continue\n        if configs_by_name[key].kind == ConfigElementType.FILE:\n            it = Path(item)\n            it.parent.mkdir(parents=True, exist_ok=True)\n            correct_types[key] = it\n        elif configs_by_name[key].kind == ConfigElementType.DIR:\n            it = Path(item)\n            it.mkdir(parents=True, exist_ok=True)\n            correct_types[key] = it\n        else:\n            raise RuntimeError(\n                f\"unhandled kind in ConfigElements: {key}: \"\n                f\"{configs_by_name[key].kind}\")\n    return correct_types"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_environ_overrides() -> Dict[str, str]:\n    return {\n        ce.name: os.environ['OT_API_' + ce.name.upper()]\n        for ce in CONFIG_ELEMENTS\n        if 'OT_API_' + ce.name.upper() in os.environ}", "response": "Pull any overrides from the environ and return a dictionary of the names to values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntries and load an index file from the various places it might exist.", "response": "def _legacy_index() -> Union[None, Dict[str, str]]:\n    \"\"\" Try and load an index file from the various places it might exist.\n\n    If the legacy file cannot be found or cannot be parsed, return None.\n\n    This method should only be called on a robot.\n    \"\"\"\n    for index in _LEGACY_INDICES:\n        if index.exists():\n            try:\n                return json.load(open(index))\n            except (OSError, json.JSONDecodeError):\n                return None\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the most recent backup file that can be migrated.", "response": "def _find_most_recent_backup(normal_path: Optional[str]) -> Optional[str]:\n    \"\"\" Find the most recent old settings to migrate.\n\n    The input is the path to an unqualified settings file - e.g.\n    /mnt/usbdrive/config/robotSettings.json\n\n    This will return\n    - None if the input is None (to support chaining from dict.get())\n    - The input if it exists, or\n    - The file named normal_path-TIMESTAMP.json with the highest timestamp\n      if one can be found, or\n    - None\n    \"\"\"\n    if normal_path is None:\n        return None\n\n    if os.path.exists(normal_path):\n        return normal_path\n\n    dirname, basename = os.path.split(normal_path)\n    root, ext = os.path.splitext(basename)\n    backups = [fi for fi in os.listdir(dirname)\n               if fi.startswith(root) and fi.endswith(ext)]\n    ts_re = re.compile(r'.*-([0-9]+)' + ext + '$')\n\n    def ts_compare(filename):\n        match = ts_re.match(filename)\n        if not match:\n            return -1\n        else:\n            return int(match.group(1))\n\n    backups_sorted = sorted(backups, key=ts_compare)\n    if not backups_sorted:\n        return None\n    return os.path.join(dirname, backups_sorted[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a config index for the given set of configuration files.", "response": "def generate_config_index(defaults: Dict[str, str],\n                          base_dir=None) -> Dict[str, Path]:\n    \"\"\"\n    Determines where existing info can be found in the system, and creates a\n    corresponding data dict that can be written to index.json in the\n    baseDataDir.\n\n    The information in the files defined by the config index is information\n    required by the API itself and nothing else - labware definitions, feature\n    flags, robot configurations. It does not include configuration files that\n    relate to the rest of the system, such as network description file\n    definitions.\n\n    :param defaults: A dict of defaults to write, useful for specifying part\n                     (but not all) of the index succinctly. This is used both\n                     when loading a configuration file from disk and when\n                     generating a new one.\n    :param base_dir: If specified, a base path used if this function has to\n                     generate defaults. If not specified, falls back to\n                     :py:attr:`CONFIG_BASE_DIR`\n    :returns: The config object\n    \"\"\"\n    base = Path(base_dir) if base_dir else infer_config_base_dir()\n\n    def parse_or_default(\n            ce: ConfigElement, val: Optional[str]) -> Path:\n        if not val:\n            return base / Path(ce.default)\n        else:\n            return Path(val)\n\n    return {\n        ce.name: parse_or_default(ce,\n                                  defaults.get(ce.name))\n        for ce in CONFIG_ELEMENTS\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the config file.", "response": "def write_config(config_data: Dict[str, Path],\n                 path: Path = None):\n    \"\"\" Save the config file.\n\n    :param config_data: The index to save\n    :param base_dir: The place to save the file. If ``None``,\n                     :py:meth:`infer_config_base_dir()` will be used\n\n    Only keys that are in the config elements will be saved.\n    \"\"\"\n    path = Path(path) if path else infer_config_base_dir()\n    valid_names = [ce.name for ce in CONFIG_ELEMENTS]\n    try:\n        os.makedirs(path, exist_ok=True)\n        with (path/_CONFIG_FILENAME).open('w') as base_f:\n            json.dump({k: str(v) for k, v in config_data.items()\n                       if k in valid_names},\n                      base_f, indent=2)\n    except OSError as e:\n        sys.stderr.write(\"Config index write to {} failed: {}\\n\"\n                         .format(path/_CONFIG_FILENAME, e))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nincrease the step of the jog resolution without overrunning the list of values", "response": "def increase_step(self) -> str:\n        \"\"\"\n        Increase the jog resolution without overrunning the list of values\n        \"\"\"\n        if self._steps_index < len(self._steps) - 1:\n            self._steps_index = self._steps_index + 1\n        return 'step: {}'.format(self.current_step())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decrease_step(self) -> str:\n        if self._steps_index > 0:\n            self._steps_index = self._steps_index - 1\n        return 'step: {}'.format(self.current_step())", "response": "Decrease the jog resolution without overrunning the list of values\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string that is displayed on the pipette in the specified axis in direction and step.", "response": "def _jog(self, axis, direction, step):\n        \"\"\"\n        Move the pipette on `axis` in `direction` by `step` and update the\n        position tracker\n        \"\"\"\n        jog(axis, direction, step, self.hardware, self._current_mount)\n\n        self.current_position = self._position()\n        return 'Jog: {}'.format([axis, str(direction), str(step)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the robot to the home position and update the position tracker", "response": "def home(self) -> str:\n        \"\"\"\n        Return the robot to the home position and update the position tracker\n        \"\"\"\n        self.hardware.home()\n        self.current_position = self._position()\n        return 'Homed'"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_point(self) -> str:\n        if self._current_mount is left:\n            msg = self.save_mount_offset()\n            self._current_mount = right\n        elif self._current_mount is types.Mount.LEFT:\n            msg = self.save_mount_offset()\n            self._current_mount = types.Mount.RIGHT\n        else:\n            pos = self._position()[:-1]\n            self.actual_points[self._current_point] = pos\n            log.debug(\"Saving {} for point {}\".format(\n                pos, self._current_point))\n            msg = 'saved #{}: {}'.format(\n                self._current_point, self.actual_points[self._current_point])\n        return msg", "response": "Save the current point in the actual_points attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate(\n            self,\n            point: Tuple[float, float, float],\n            point_num: int,\n            pipette_mount) -> str:\n        \"\"\"\n        :param point: Expected values from mechanical drawings\n        :param point_num: The current position attempting to be validated\n        :param pipette: 'Z' for left mount or 'A' for right mount\n\n        :return:\n        \"\"\"\n        _, _, cz = self._driver_to_deck_coords(self._position())\n        if self._current_mount != pipette_mount and cz < SAFE_HEIGHT:\n            self.move_to_safe_height()\n\n        self._current_mount = pipette_mount\n        self._current_point = point_num\n\n        _, _, cz = self._driver_to_deck_coords(self._position())\n        if cz < SAFE_HEIGHT:\n            self.move_to_safe_height()\n\n        tx, ty, tz = self._deck_to_driver_coords(point)\n        if not feature_flags.use_protocol_api_v2():\n            self.hardware._driver.move({'X': tx, 'Y': ty})\n            self.hardware._driver.move({self._current_mount: tz})\n        else:\n            pt = types.Point(x=tx, y=ty, z=tz)\n            self.hardware.move_to(self._current_mount, pt)\n        return 'moved to point {}'.format(point)", "response": "Validate the current position of the current node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the most recent config matching prefix", "response": "def find_config(prefix: str) -> str:\n    \"\"\" Find the most recent config matching `prefix` \"\"\"\n    matches = [conf for conf in config_models if conf.startswith(prefix)]\n    if not matches:\n        raise KeyError('No match found for prefix {}'.format(prefix))\n    if prefix in matches:\n        return prefix\n    else:\n        return sorted(matches)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the internal cache of attached instruments.", "response": "def get_attached_instruments(\n            self, expected: Dict[types.Mount, str])\\\n            -> Dict[types.Mount, Dict[str, Optional[str]]]:\n        \"\"\" Update the internal cache of attached instruments.\n\n        This method allows after-init-time specification of attached simulated\n        instruments. The method will return\n        - the instruments specified at init-time, or if those do not exists,\n        - the instruments specified in expected, or if that is not passed,\n        - nothing\n\n        :param expected: A mapping of mount to instrument model prefixes. When\n                         loading instruments from a prefix, we return the\n                         lexically-first model that matches the prefix. If the\n                         models specified in expected do not match the models\n                         specified in the `attached_instruments` argument of\n                         :py:meth:`__init__`, :py:attr:`RuntimeError` is\n                         raised.\n        :raises RuntimeError: If an instrument is expected but not found.\n        :returns: A dict of mount to either instrument model names or `None`.\n        \"\"\"\n        to_return: Dict[types.Mount, Dict[str, Optional[str]]] = {}\n        for mount in types.Mount:\n            expected_instr = expected.get(mount, None)\n            init_instr = self._attached_instruments.get(mount, {})\n            found_model = init_instr.get('model', '')\n            if expected_instr and found_model\\\n                    and not found_model.startswith(expected_instr):\n                if self._strict_attached:\n                    raise RuntimeError(\n                        'mount {}: expected instrument {} but got {}'\n                        .format(mount.name, expected_instr, init_instr))\n                else:\n                    to_return[mount] = {\n                        'model': find_config(expected_instr),\n                        'id': None}\n            elif found_model and expected_instr:\n                # Instrument detected matches instrument expected (note:\n                # \"instrument detected\" means passed as an argument to the\n                # constructor of this class)\n                to_return[mount] = init_instr\n            elif found_model:\n                # Instrument detected and no expected instrument specified\n                to_return[mount] = init_instr\n            elif expected_instr:\n                # Expected instrument specified and no instrument detected\n                to_return[mount] = {\n                    'model': find_config(expected_instr),\n                    'id': None}\n            else:\n                # No instrument detected or expected\n                to_return[mount] = {\n                    'model': None,\n                    'id': None}\n        return to_return"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_device_info(self) -> Mapping[str, str]:\n        '''\n        Queries Temp-Deck for it's build version, model, and serial number\n\n        returns: dict\n            Where keys are the strings 'version', 'model', and 'serial',\n            and each value is a string identifier\n\n            {\n                'serial': '1aa11bb22',\n                'model': '1aa11bb22',\n                'version': '1aa11bb22'\n            }\n\n        Example input from Temp-Deck's serial response:\n            \"serial:aa11bb22 model:aa11bb22 version:aa11bb22\"\n        '''\n        try:\n            return self._recursive_get_info(DEFAULT_COMMAND_RETRIES)\n        except (TempDeckError, SerialException, SerialNoResponse) as e:\n            return {'error': str(e)}", "response": "Queries Temp - Deck for it s build version model and serial number and returns a dictionary of the information about that temp - depucible object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that the lpc21isp executable is executable.", "response": "def _ensure_programmer_executable():\n    \"\"\" Find the lpc21isp executable and ensure it is executable\n    \"\"\"\n    # Find the lpc21isp executable, explicitly allowing the case where it\n    # is not executable (since that\u2019s exactly what we\u2019re trying to fix)\n    updater_executable = shutil.which('lpc21isp',\n                                      mode=os.F_OK)\n    # updater_executable might be None; we\u2019re passing it here unchecked\n    # because if it is None, we\u2019re about to fail when we try to program\n    # the smoothie, and we want the exception to bubble up.\n    os.chmod(updater_executable, 0o777)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_ignored_version():\n    if os.path.exists(filepath):\n        with open(filepath) as data_file:\n            data = json.load(data_file)\n            version = data.get('version')\n    else:\n        version = None\n    return version", "response": "Get the most recently ignored API version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def set_ignore_version(request):\n    data = await request.json()\n    if 'version' in data.keys():\n        ignored_version = data.get('version')\n        log.debug('Set Ignore Version to {}'.format(ignored_version))\n        if ignored_version == '':\n            status = 400\n            res = {'version': None}\n        else:\n            _set_ignored_version(ignored_version)\n            status = 200\n            res = {'version': ignored_version}\n    else:\n        status = 400\n        res = {'version': None}\n\n    return web.json_response(res, status=status)", "response": "This handler sets the version of the node in the ignore list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def update_firmware(request):\n    log.debug('Update Firmware request received')\n    data = await request.post()\n    try:\n        res = await install_smoothie_firmware(data['hex'], request.loop)\n        status = 200\n    except Exception as e:\n        log.exception(\"Exception during firmware update:\")\n        res = {'message': 'Exception {} raised by update of {}: {}'.format(\n                type(e), data, e.__traceback__)}\n        status = 500\n    return web.json_response(res, status=status)", "response": "This handler handles the update of the firmware of the current node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def restart(request):\n    def wait_and_restart():\n        log.info('Restarting server')\n        sleep(1)\n        os.system('kill 1')\n    Thread(target=wait_and_restart).start()\n    return web.json_response({\"message\": \"restarting\"})", "response": "Returns OK, then waits approximately 1 second and restarts container"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild and return the aiohttp. web. Application that runs the server Formula", "response": "def get_app(system_version_file: str = None,\n            config_file_override: str = None,\n            name_override: str = None,\n            loop: asyncio.AbstractEventLoop = None) -> web.Application:\n    \"\"\" Build and return the aiohttp.web.Application that runs the server\n\n    The params can be overloaded for testing.\n    \"\"\"\n    if not system_version_file:\n        system_version_file = BR_BUILTIN_VERSION_FILE\n\n    version = get_version(system_version_file)\n    name = name_override or name_management.get_name()\n    config_obj = config.load(config_file_override)\n\n    LOG.info(\"Setup: \" + '\\n\\t'.join([\n        f'Device name: {name}',\n        f'Buildroot version:         '\n        f'{version.get(\"buildroot_version\", \"unknown\")}',\n        f'\\t(from git sha      '\n        f'{version.get(\"buildroot_sha\", \"unknown\")}',\n        f'API version:               '\n        f'{version.get(\"opentrons_api_version\", \"unknown\")}',\n        f'\\t(from git sha      '\n        f'{version.get(\"opentrons_api_sha\", \"unknown\")}',\n        f'Update server version:     '\n        f'{version.get(\"update_server_version\", \"unknown\")}',\n        f'\\t(from git sha      '\n        f'{version.get(\"update_server_sha\", \"unknown\")}',\n        f'Smoothie firmware version: TODO'\n    ]))\n\n    if not loop:\n        loop = asyncio.get_event_loop()\n\n    app = web.Application(loop=loop, middlewares=[log_error_middleware])\n    app[config.CONFIG_VARNAME] = config_obj\n    app[constants.RESTART_LOCK_NAME] = asyncio.Lock()\n    app[constants.DEVICE_NAME_VARNAME] = name\n    app.router.add_routes([\n        web.get('/server/update/health',\n                control.build_health_endpoint(version)),\n        web.post('/server/update/begin', update.begin),\n        web.post('/server/update/cancel', update.cancel),\n        web.get('/server/update/{session}/status', update.status),\n        web.post('/server/update/{session}/file', update.file_upload),\n        web.post('/server/update/{session}/commit', update.commit),\n        web.post('/server/restart', control.restart),\n        web.get('/server/ssh_keys', ssh_key_management.list_keys),\n        web.post('/server/ssh_keys', ssh_key_management.add),\n        web.delete('/server/ssh_keys/{key_md5}', ssh_key_management.remove),\n        web.post('/server/name', name_management.set_name_endpoint),\n        web.get('/server/name', name_management.get_name_endpoint),\n    ])\n    return app"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling the incoming request and returns a WebSocket response.", "response": "async def handler(self, request):\n        \"\"\"\n        Receives HTTP request and negotiates up to a Websocket session\n        \"\"\"\n\n        def task_done(future):\n            self.tasks.remove(future)\n            exception = future.exception()\n            if exception:\n                log.warning(\n                    'While processing message: {0}\\nDetails: {1}'.format(\n                        exception,\n                        traceback.format_exc())\n                )\n\n        client = web.WebSocketResponse()\n        client_id = id(client)\n\n        # upgrade to Websockets\n        await client.prepare(request)\n\n        log.info('Opening Websocket {0}'.format(id(client)))\n        log.debug('Tasks: {0}'.format(self.tasks))\n        log.debug('Clients: {0}'.format(self.clients))\n\n        try:\n            log.debug('Sending root info to {0}'.format(client_id))\n            await client.send_json({\n                '$': {'type': CONTROL_MESSAGE, 'monitor': True},\n                'root': self.call_and_serialize(lambda: self.root),\n                'type': self.call_and_serialize(lambda: type(self.root))\n            })\n            log.debug('Root info sent to {0}'.format(client_id))\n        except Exception:\n            log.exception('While sending root info to {0}'.format(client_id))\n\n        try:\n            self.clients[client] = self.send_worker(client)\n            # Async receive client data until websocket is closed\n            async for msg in client:\n                task = self.loop.create_task(self.process(msg))\n                task.add_done_callback(task_done)\n                self.tasks += [task]\n        except Exception:\n            log.exception('While reading from socket:')\n        finally:\n            log.info('Closing WebSocket {0}'.format(id(client)))\n            await client.close()\n            del self.clients[client]\n\n        return client"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nresolves function call arguments that have object ids into instances of these objects", "response": "def resolve_args(self, args):\n        \"\"\"\n        Resolve function call arguments that have object ids\n        into instances of these objects\n        \"\"\"\n        def resolve(a):\n            if isinstance(a, dict):\n                _id = a.get('i', None)\n                # If it's a compound type (including dict)\n                # Check if it has id (i) to determine that it has\n                # a reference in object storage. If it's None, then it's\n                # a dict originated at the remote\n                return self.objects[_id] if _id else a['v']\n            # if array, resolve it's elements\n            if isinstance(a, (list, tuple)):\n                return [resolve(i) for i in a]\n            return a\n\n        return [resolve(a) for a in args]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_flow_rate(\n        pipette_name, pipette, command_type, params, default_values):\n    \"\"\"\n    Set flow rate in uL/mm, to value obtained from command's params,\n    or if unspecified in command params, then from protocol's \"default-values\".\n    \"\"\"\n    default_aspirate = default_values.get(\n        'aspirate-flow-rate', {}).get(pipette_name)\n\n    default_dispense = default_values.get(\n        'dispense-flow-rate', {}).get(pipette_name)\n\n    flow_rate_param = params.get('flow-rate')\n\n    if flow_rate_param is not None:\n        if command_type == 'aspirate':\n            pipette.set_flow_rate(\n                aspirate=flow_rate_param,\n                dispense=default_dispense)\n            return\n        if command_type == 'dispense':\n            pipette.set_flow_rate(\n                aspirate=default_aspirate,\n                dispense=flow_rate_param)\n            return\n\n    pipette.set_flow_rate(\n        aspirate=default_aspirate,\n        dispense=default_dispense\n    )", "response": "Set flow rate in uL / mm to value obtained from command s params and protocol s default - values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist the serial ports available on the system", "response": "def get_serial_ports_list():\n    \"\"\" Lists serial port names\n\n        :raises EnvironmentError:\n            On unsupported or unknown platforms\n        :returns:\n            A list of the serial ports available on the system\n    \"\"\"\n    if sys.platform.startswith('win'):\n        ports = ['COM%s' % (i + 1) for i in range(256)]\n    elif (sys.platform.startswith('linux') or\n          sys.platform.startswith('cygwin')):\n        # this excludes your current terminal \"/dev/tty\"\n        ports = glob.glob('/dev/tty*')\n    elif sys.platform.startswith('darwin'):\n        ports = glob.glob('/dev/tty.*')\n    else:\n        raise EnvironmentError('Unsupported platform')\n\n    result = []\n    port_filter = {'usbmodem', 'usbserial', 'COM', 'ACM', 'USB'}\n    for port in ports:\n        try:\n            if any([f in port for f in port_filter]):\n                s = serial.Serial()\n                c = connection.Connection(\n                    s, port=port, baudrate=115200, timeout=0.01)\n                c.open()\n                result.append(port)\n        except Exception as e:\n            log.debug(\n                'Exception in testing port {}'.format(port))\n            log.debug(e)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a new hardware controller.", "response": "async def build_hardware_controller(\n            cls, config: robot_configs.robot_config = None,\n            port: str = None,\n            loop: asyncio.AbstractEventLoop = None,\n            force: bool = False) -> 'API':\n        \"\"\" Build a hardware controller that will actually talk to hardware.\n\n        This method should not be used outside of a real robot, and on a\n        real robot only one true hardware controller may be active at one\n        time.\n\n        :param config: A config to preload. If not specified, load the default.\n        :param port: A port to connect to. If not specified, the default port\n                     (found by scanning for connected FT232Rs).\n        :param loop: An event loop to use. If not specified, use the result of\n                     :py:meth:`asyncio.get_event_loop`.\n        :param force: If `True`, connect even if a lockfile is present. See\n                      :py:meth:`Controller.__init__`.\n        \"\"\"\n        if None is Controller:\n            raise RuntimeError(\n                'The hardware controller may only be instantiated on a robot')\n        checked_loop = loop or asyncio.get_event_loop()\n        backend = Controller(config, checked_loop, force=force)\n        await backend.connect(port)\n        return cls(backend, config=config, loop=checked_loop)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_hardware_simulator(\n            cls,\n            attached_instruments: Dict[top_types.Mount, Dict[str, Optional[str]]] = None,  # noqa E501\n            attached_modules: List[str] = None,\n            config: robot_configs.robot_config = None,\n            loop: asyncio.AbstractEventLoop = None,\n            strict_attached_instruments: bool = True) -> 'API':\n        \"\"\" Build a simulating hardware controller.\n\n        This method may be used both on a real robot and on dev machines.\n        Multiple simulating hardware controllers may be active at one time.\n        \"\"\"\n\n        if None is attached_instruments:\n            attached_instruments = {}\n\n        if None is attached_modules:\n            attached_modules = []\n        return cls(Simulator(attached_instruments,\n                             attached_modules,\n                             config, loop,\n                             strict_attached_instruments),\n                   config=config, loop=loop)", "response": "Build a simulating hardware controller."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nallowing the caller to register a callback and returns a closure that can be used to unregister the callback", "response": "async def register_callback(self, cb):\n        \"\"\" Allows the caller to register a callback, and returns a closure\n        that can be used to unregister the provided callback\n        \"\"\"\n        self._callbacks.add(cb)\n\n        def unregister():\n            self._callbacks.remove(cb)\n\n        return unregister"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_lights(self, button: bool = None, rails: bool = None):\n        self._backend.set_lights(button, rails)", "response": "Control the robot lights."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def identify(self, duration_s: int = 5):\n        count = duration_s * 4\n        on = False\n        for sec in range(count):\n            then = self._loop.time()\n            self.set_lights(button=on)\n            on = not on\n            now = self._loop.time()\n            await asyncio.sleep(max(0, 0.25-(now-then)))\n        self.set_lights(button=True)", "response": "Blink the button light to identify the robot."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def cache_instruments(self,\n                                require: Dict[top_types.Mount, str] = None):\n        \"\"\"\n         - Get the attached instrument on each mount and\n         - Cache their pipette configs from pipette-config.json\n\n        If specified, the require element should be a dict of mounts to\n        instrument models describing the instruments expected to be present.\n        This can save a subsequent of :py:attr:`attached_instruments` and also\n        serves as the hook for the hardware simulator to decide what is\n        attached.\n        \"\"\"\n        checked_require = require or {}\n        self._log.info(\"Updating instrument model cache\")\n        found = self._backend.get_attached_instruments(checked_require)\n        for mount, instrument_data in found.items():\n            model = instrument_data.get('model')\n            if model is not None:\n                p = Pipette(model,\n                            self._config.instrument_offset[mount.name.lower()],\n                            instrument_data['id'])\n                self._attached_instruments[mount] = p\n            else:\n                self._attached_instruments[mount] = None\n        mod_log.info(\"Instruments found: {}\".format(\n            self._attached_instruments))", "response": "Get the attached instruments on each mount and cache them for the pipette."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the firmware on the Smoothie board.", "response": "async def update_firmware(\n            self,\n            firmware_file: str,\n            loop: asyncio.AbstractEventLoop = None,\n            explicit_modeset: bool = True) -> str:\n        \"\"\" Update the firmware on the Smoothie board.\n\n        :param firmware_file: The path to the firmware file.\n        :param explicit_modeset: `True` to force the smoothie into programming\n                                 mode; `False` to assume it is already in\n                                 programming mode.\n        :param loop: An asyncio event loop to use; if not specified, the one\n                     associated with this instance will be used.\n        :returns: The stdout of the tool used to update the smoothie\n        \"\"\"\n        if None is loop:\n            checked_loop = self._loop\n        else:\n            checked_loop = loop\n        return await self._backend.update_firmware(firmware_file,\n                                                   checked_loop,\n                                                   explicit_modeset)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def home_z(self, mount: top_types.Mount = None):\n        if not mount:\n            axes = [Axis.Z, Axis.A]\n        else:\n            axes = [Axis.by_mount(mount)]\n        await self.home(axes)", "response": "Home the two z - axes"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def home_plunger(self, mount: top_types.Mount):\n        instr = self._attached_instruments[mount]\n        if instr:\n            await self.home([Axis.of_plunger(mount)])\n            await self._move_plunger(mount,\n                                     instr.config.bottom)", "response": "Home the plunger motor for a mount and then return it to the bottom."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def home(self, axes: List[Axis] = None):\n        # Initialize/update current_position\n        checked_axes = axes or [ax for ax in Axis]\n        gantry = [ax for ax in checked_axes if ax in Axis.gantry_axes()]\n        smoothie_gantry = [ax.name.upper() for ax in gantry]\n        smoothie_pos = {}\n        plungers = [ax for ax in checked_axes\n                    if ax not in Axis.gantry_axes()]\n        smoothie_plungers = [ax.name.upper() for ax in plungers]\n        async with self._motion_lock:\n            if smoothie_gantry:\n                smoothie_pos.update(self._backend.home(smoothie_gantry))\n            if smoothie_plungers:\n                smoothie_pos.update(self._backend.home(smoothie_plungers))\n            self._current_position = self._deck_from_smoothie(smoothie_pos)", "response": "Home the entire robot and initialize current position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _deck_from_smoothie(\n            self, smoothie_pos: Dict[str, float]) -> Dict[Axis, float]:\n        \"\"\" Build a deck-abs position store from the smoothie's position\n\n        This should take the smoothie style position {'X': float, etc}\n        and turn it into the position dict used here {Axis.X: float} in\n        deck-absolute coordinates. It runs the reverse deck transformation\n        for the axes that require it.\n\n        One piece of complexity is that if the gantry transformation includes\n        a transition between non parallel planes, the z position of the left\n        mount would depend on its actual position in deck frame, so we have\n        to apply the mount offset.\n\n        TODO: Figure out which frame the mount offset is measured in, because\n              if it's measured in the deck frame (e.g. by touching off points\n              on the deck) it has to go through the reverse transform to be\n              added to the smoothie coordinates here.\n        \"\"\"\n        with_enum = {Axis[k]: v for k, v in smoothie_pos.items()}\n        plunger_axes = {k: v for k, v in with_enum.items()\n                        if k not in Axis.gantry_axes()}\n        right = (with_enum[Axis.X], with_enum[Axis.Y],\n                 with_enum[Axis.by_mount(top_types.Mount.RIGHT)])\n        # Tell apply_transform to just do the change of base part of the\n        # transform rather than the full affine transform, because this is\n        # an offset\n        left = (with_enum[Axis.X],\n                with_enum[Axis.Y],\n                with_enum[Axis.by_mount(top_types.Mount.LEFT)])\n        right_deck = linal.apply_reverse(self.config.gantry_calibration,\n                                         right)\n        left_deck = linal.apply_reverse(self.config.gantry_calibration,\n                                        left)\n        deck_pos = {Axis.X: right_deck[0],\n                    Axis.Y: right_deck[1],\n                    Axis.by_mount(top_types.Mount.RIGHT): right_deck[2],\n                    Axis.by_mount(top_types.Mount.LEFT): left_deck[2]}\n        deck_pos.update(plunger_axes)\n        return deck_pos", "response": "Build a deck - abs position store from a smoothie s position."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current position of the specified critical point.", "response": "async def current_position(\n            self,\n            mount: top_types.Mount,\n            critical_point: CriticalPoint = None) -> Dict[Axis, float]:\n        \"\"\" Return the postion (in deck coords) of the critical point of the\n        specified mount.\n\n        This returns cached position to avoid hitting the smoothie driver\n        unless ``refresh`` is ``True``.\n\n        If `critical_point` is specified, that critical point will be applied\n        instead of the default one. For instance, if\n        `critical_point=CriticalPoints.MOUNT` then the position of the mount\n        will be returned. If the critical point specified does not exist, then\n        the next one down is returned - for instance, if there is no tip on the\n        specified mount but `CriticalPoint.TIP` was specified, the position of\n        the nozzle will be returned.\n        \"\"\"\n        if not self._current_position:\n            raise MustHomeError\n        async with self._motion_lock:\n            if mount == mount.RIGHT:\n                offset = top_types.Point(0, 0, 0)\n            else:\n                offset = top_types.Point(*self.config.mount_offset)\n            z_ax = Axis.by_mount(mount)\n            plunger_ax = Axis.of_plunger(mount)\n            cp = self._critical_point_for(mount, critical_point)\n            return {\n                Axis.X: self._current_position[Axis.X] + offset[0] + cp.x,\n                Axis.Y: self._current_position[Axis.Y] + offset[1] + cp.y,\n                z_ax: self._current_position[z_ax] + offset[2] + cp.z,\n                plunger_ax: self._current_position[plunger_ax]\n            }"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the position of the gantry to the critical point.", "response": "async def gantry_position(\n            self,\n            mount: top_types.Mount,\n            critical_point: CriticalPoint = None) -> top_types.Point:\n        \"\"\" Return the position of the critical point as pertains to the gantry\n\n        This ignores the plunger position and gives the Z-axis a predictable\n        name (as :py:attr:`.Point.z`).\n\n        `critical_point` specifies an override to the current critical point to\n        use (see :py:meth:`current_position`).\n        \"\"\"\n        cur_pos = await self.current_position(mount, critical_point)\n        return top_types.Point(x=cur_pos[Axis.X],\n                               y=cur_pos[Axis.Y],\n                               z=cur_pos[Axis.by_mount(mount)])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmove the critical point of the specified mount to the specified absolute position.", "response": "async def move_to(\n            self, mount: top_types.Mount, abs_position: top_types.Point,\n            speed: float = None,\n            critical_point: CriticalPoint = None):\n        \"\"\" Move the critical point of the specified mount to a location\n        relative to the deck, at the specified speed. 'speed' sets the speed\n        of all robot axes to the given value. So, if multiple axes are to be\n        moved, they will do so at the same speed\n\n        The critical point of the mount depends on the current status of\n        the mount:\n        - If the mount does not have anything attached, its critical point is\n          the bottom of the mount attach bracket.\n        - If the mount has a pipette attached and it is not known to have a\n          pipette tip, the critical point is the end of the nozzle of a single\n          pipette or the end of the backmost nozzle of a multipipette\n        - If the mount has a pipette attached and it is known to have a\n          pipette tip, the critical point is the end of the pipette tip for\n          a single pipette or the end of the tip of the backmost nozzle of a\n          multipipette\n\n        :param mount: The mount to move\n        :param abs_position: The target absolute position in\n                             :ref:`protocol-api-deck-coords` to move the\n                             critical point to\n        :param speed: An overall head speed to use during the move\n        :param critical_point: The critical point to move. In most situations\n                               this is not needed. If not specified, the\n                               current critical point will be moved. If\n                               specified, the critical point must be one that\n                               actually exists - that is, specifying\n                               :py:attr:`.CriticalPoint.NOZZLE` when no pipette\n                               is attached or :py:attr:`.CriticalPoint.TIP`\n                               when no tip is applied will result in an error.\n        \"\"\"\n        if not self._current_position:\n            raise MustHomeError\n\n        await self._cache_and_maybe_retract_mount(mount)\n        z_axis = Axis.by_mount(mount)\n        if mount == top_types.Mount.LEFT:\n            offset = top_types.Point(*self.config.mount_offset)\n        else:\n            offset = top_types.Point(0, 0, 0)\n        cp = self._critical_point_for(mount, critical_point)\n        target_position = OrderedDict(\n            ((Axis.X, abs_position.x - offset.x - cp.x),\n             (Axis.Y, abs_position.y - offset.y - cp.y),\n             (z_axis, abs_position.z - offset.z - cp.z))\n        )\n\n        await self._move(target_position, speed=speed)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmoving the critical point of the specified mount by a specified delta in a specified direction at the specified speed.", "response": "async def move_rel(self, mount: top_types.Mount, delta: top_types.Point,\n                       speed: float = None):\n        \"\"\" Move the critical point of the specified mount by a specified\n        displacement in a specified direction, at the specified speed.\n        'speed' sets the speed of all axes to the given value. So, if multiple\n        axes are to be moved, they will do so at the same speed\n        \"\"\"\n        if not self._current_position:\n            raise MustHomeError\n\n        await self._cache_and_maybe_retract_mount(mount)\n\n        z_axis = Axis.by_mount(mount)\n        try:\n            target_position = OrderedDict(\n                ((Axis.X,\n                  self._current_position[Axis.X] + delta.x),\n                 (Axis.Y,\n                  self._current_position[Axis.Y] + delta.y),\n                 (z_axis,\n                  self._current_position[z_axis] + delta.z))\n                )\n        except KeyError:\n            raise MustHomeError\n        await self._move(target_position, speed=speed)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretract the other mount if necessary.", "response": "async def _cache_and_maybe_retract_mount(self, mount: top_types.Mount):\n        \"\"\" Retract the 'other' mount if necessary\n\n        If `mount` does not match the value in :py:attr:`_last_moved_mount`\n        (and :py:attr:`_last_moved_mount` exists) then retract the mount\n        in :py:attr:`_last_moved_mount`. Also unconditionally update\n        :py:attr:`_last_moved_mount` to contain `mount`.\n        \"\"\"\n        if mount != self._last_moved_mount and self._last_moved_mount:\n            await self.retract(self._last_moved_mount, 10)\n        self._last_moved_mount = mount"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def _move(self, target_position: 'OrderedDict[Axis, float]',\n                    speed: float = None, home_flagged_axes: bool = True):\n        \"\"\" Worker function to apply robot motion.\n\n        Robot motion means the kind of motions that are relevant to the robot,\n        i.e. only one pipette plunger and mount move at the same time, and an\n        XYZ move in the coordinate frame of one of the pipettes.\n\n        ``target_position`` should be an ordered dict (ordered by XYZABC)\n        of deck calibrated values, containing any specified XY motion and\n        at most one of a ZA or BC components. The frame in which to move\n        is identified by the presence of (ZA) or (BC).\n        \"\"\"\n        # Transform only the x, y, and (z or a) axes specified since this could\n        # get the b or c axes as well\n        to_transform = tuple((tp\n                              for ax, tp in target_position.items()\n                              if ax in Axis.gantry_axes()))\n\n        # Pre-fill the dict we\u2019ll send to the backend with the axes we don\u2019t\n        # need to transform\n        smoothie_pos = {ax.name: pos for ax, pos in target_position.items()\n                        if ax not in Axis.gantry_axes()}\n\n        # We\u2019d better have all of (x, y, (z or a)) or none of them since the\n        # gantry transform requires them all\n        if len(to_transform) != 3:\n            self._log.error(\"Move derived {} axes to transform from {}\"\n                            .format(len(to_transform), target_position))\n            raise ValueError(\"Moves must specify either exactly an x, y, and \"\n                             \"(z or a) or none of them\")\n\n        # Type ignored below because linal.apply_transform (rightly) specifies\n        # Tuple[float, float, float] and the implied type from\n        # target_position.items() is (rightly) Tuple[float, ...] with unbounded\n        # size; unfortunately, mypy can\u2019t quite figure out the length check\n        # above that makes this OK\n        transformed = linal.apply_transform(  # type: ignore\n            self.config.gantry_calibration, to_transform)\n\n        # Since target_position is an OrderedDict with the axes ordered by\n        # (x, y, z, a, b, c), and we\u2019ll only have one of a or z (as checked\n        # by the len(to_transform) check above) we can use an enumerate to\n        # fuse the specified axes and the transformed values back together.\n        # While we do this iteration, we\u2019ll also check axis bounds.\n        bounds = self._backend.axis_bounds\n        for idx, ax in enumerate(target_position.keys()):\n            if ax in Axis.gantry_axes():\n                smoothie_pos[ax.name] = transformed[idx]\n                if smoothie_pos[ax.name] < bounds[ax.name][0]\\\n                   or smoothie_pos[ax.name] > bounds[ax.name][1]:\n                    deck_mins = self._deck_from_smoothie({ax: bound[0]\n                                                          for ax, bound\n                                                          in bounds.items()})\n                    deck_max = self._deck_from_smoothie({ax: bound[1]\n                                                         for ax, bound\n                                                         in bounds.items()})\n                    self._log.warning(\n                        \"Out of bounds move: {}={} (transformed: {}) not in\"\n                        \"limits ({}, {}) (transformed: ({}, {})\"\n                        .format(ax.name,\n                                target_position[ax],\n                                smoothie_pos[ax.name],\n                                deck_mins[ax], deck_max[ax],\n                                bounds[ax.name][0], bounds[ax.name][1]))\n        async with self._motion_lock:\n            try:\n                self._backend.move(smoothie_pos, speed=speed,\n                                   home_flagged_axes=home_flagged_axes)\n            except Exception:\n                self._log.exception('Move failed')\n                self._current_position.clear()\n                raise\n            else:\n                self._current_position.update(target_position)", "response": "This function is used to apply robot motion to the robot and mount motion."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef engaged_axes(self) -> Dict[Axis, bool]:\n        return {Axis[ax]: eng\n                for ax, eng in self._backend.engaged_axes().items()}", "response": "Which axes are engaged and holding."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npull the specified mount up to its home position.", "response": "async def retract(self, mount: top_types.Mount, margin: float):\n        \"\"\" Pull the specified mount up to its home position.\n\n        Works regardless of critical point or home status.\n        \"\"\"\n        smoothie_ax = Axis.by_mount(mount).name.upper()\n        async with self._motion_lock:\n            smoothie_pos = self._backend.fast_home(smoothie_ax, margin)\n            self._current_position = self._deck_from_smoothie(smoothie_pos)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _critical_point_for(\n            self, mount: top_types.Mount,\n            cp_override: CriticalPoint = None) -> top_types.Point:\n        \"\"\" Return the current critical point of the specified mount.\n\n        The mount's critical point is the position of the mount itself, if no\n        pipette is attached, or the pipette's critical point (which depends on\n        tip status).\n\n        If `cp_override` is specified, and that critical point actually exists,\n        it will be used instead. Invalid `cp_override`s are ignored.\n        \"\"\"\n        pip = self._attached_instruments[mount]\n        if pip is not None and cp_override != CriticalPoint.MOUNT:\n            return pip.critical_point(cp_override)\n        else:\n            # TODO: The smoothie\u2019s z/a home position is calculated to provide\n            # the offset for a P300 single. Here we should decide whether we\n            # implicitly accept this as correct (by returning a null offset)\n            # or not (by returning an offset calculated to move back up the\n            # length of the P300 single).\n            return top_types.Point(0, 0, 0)", "response": "Returns the current critical point for the specified mount."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def aspirate(self, mount: top_types.Mount, volume: float = None,\n                       rate: float = 1.0):\n        \"\"\"\n        Aspirate a volume of liquid (in microliters/uL) using this pipette\n        from the *current location*. If no volume is passed, `aspirate` will\n        default to max available volume (after taking into account the volume\n        already present in the tip).\n\n        mount : Mount.LEFT or Mount.RIGHT\n        volume : [float] The number of microliters to aspirate\n        rate : [float] Set plunger speed for this aspirate, where\n            speed = rate * aspirate_speed\n        \"\"\"\n        this_pipette = self._attached_instruments[mount]\n        if not this_pipette:\n            raise top_types.PipetteNotAttachedError(\n                \"No pipette attached to {} mount\".format(mount.name))\n        if volume is None:\n            asp_vol = this_pipette.available_volume\n            mod_log.debug(\n                \"No aspirate volume defined. Aspirating up to pipette \"\n                \"max_volume ({}uL)\".format(this_pipette.config.max_volume))\n        else:\n            asp_vol = volume\n\n        assert this_pipette.ok_to_add_volume(asp_vol), \\\n            \"Cannot aspirate more than pipette max volume\"\n        if asp_vol == 0:\n            return\n\n        self._backend.set_active_current(\n             Axis.of_plunger(mount), this_pipette.config.plunger_current)\n        dist = self._plunger_position(\n                this_pipette,\n                this_pipette.current_volume + asp_vol,\n                'aspirate')\n        speed = this_pipette.config.aspirate_flow_rate * rate\n        try:\n            await self._move_plunger(mount, dist, speed=speed)\n        except Exception:\n            self._log.exception('Aspirate failed')\n            this_pipette.set_current_volume(0)\n            raise\n        else:\n            this_pipette.add_current_volume(asp_vol)", "response": "Aspirate a volume of liquid using this pipette."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def dispense(self, mount: top_types.Mount, volume: float = None,\n                       rate: float = 1.0):\n        \"\"\"\n        Dispense a volume of liquid in microliters(uL) using this pipette\n        at the current location. If no volume is specified, `dispense` will\n        dispense all volume currently present in pipette\n\n        mount : Mount.LEFT or Mount.RIGHT\n        volume : [float] The number of microliters to dispense\n        rate : [float] Set plunger speed for this dispense, where\n            speed = rate * dispense_speed\n        \"\"\"\n        this_pipette = self._attached_instruments[mount]\n        if not this_pipette:\n            raise top_types.PipetteNotAttachedError(\n                \"No pipette attached to {} mount\".format(mount.name))\n        if volume is None:\n            disp_vol = this_pipette.current_volume\n            mod_log.debug(\"No dispense volume specified. Dispensing all \"\n                          \"remaining liquid ({}uL) from pipette\".format\n                          (disp_vol))\n        else:\n            disp_vol = volume\n        # Ensure we don't dispense more than the current volume\n        disp_vol = min(this_pipette.current_volume, disp_vol)\n\n        if disp_vol == 0:\n            return\n\n        self._backend.set_active_current(\n            Axis.of_plunger(mount), this_pipette.config.plunger_current)\n        dist = self._plunger_position(\n                this_pipette,\n                this_pipette.current_volume - disp_vol,\n                'dispense')\n        speed = this_pipette.config.dispense_flow_rate * rate\n        try:\n            await self._move_plunger(mount, dist, speed)\n        except Exception:\n            self._log.exception('Dispense failed')\n            this_pipette.set_current_volume(0)\n            raise\n        else:\n            this_pipette.remove_current_volume(disp_vol)", "response": "Dispense a liquid in microliters of the given mount."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def blow_out(self, mount):\n        this_pipette = self._attached_instruments[mount]\n        if not this_pipette:\n            raise top_types.PipetteNotAttachedError(\n                \"No pipette attached to {} mount\".format(mount.name))\n\n        self._backend.set_active_current(Axis.of_plunger(mount),\n                                         this_pipette.config.plunger_current)\n        try:\n            await self._move_plunger(\n                mount, this_pipette.config.blow_out)\n        except Exception:\n            self._log.exception('Blow out failed')\n            raise\n        finally:\n            this_pipette.set_current_volume(0)", "response": "Blow out the liquid of the pipette."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npicks up a nozzle from the current location.", "response": "async def pick_up_tip(self,\n                          mount,\n                          tip_length: float,\n                          presses: int = None,\n                          increment: float = None):\n        \"\"\"\n        Pick up tip from current location.\n\n        If ``presses`` or ``increment`` is not specified (or is ``None``),\n        their value is taken from the pipette configuration\n        \"\"\"\n        instr = self._attached_instruments[mount]\n        assert instr\n        assert not instr.has_tip, 'Tip already attached'\n        instr_ax = Axis.by_mount(mount)\n        plunger_ax = Axis.of_plunger(mount)\n        self._log.info('Picking up tip on {}'.format(instr.name))\n        # Initialize plunger to bottom position\n        self._backend.set_active_current(plunger_ax,\n                                         instr.config.plunger_current)\n        await self._move_plunger(\n            mount, instr.config.bottom)\n\n        if not presses or presses < 0:\n            checked_presses = instr.config.pick_up_presses\n        else:\n            checked_presses = presses\n\n        if not increment or increment < 0:\n            checked_increment = instr.config.pick_up_increment\n        else:\n            checked_increment = increment\n\n        # Press the nozzle into the tip <presses> number of times,\n        # moving further by <increment> mm after each press\n        for i in range(checked_presses):\n            # move nozzle down into the tip\n            with self._backend.save_current():\n                self._backend.set_active_current(instr_ax,\n                                                 instr.config.pick_up_current)\n                dist = -1.0 * instr.config.pick_up_distance\\\n                    + -1.0 * checked_increment * i\n                target_pos = top_types.Point(0, 0, dist)\n                await self.move_rel(\n                    mount, target_pos, instr.config.pick_up_speed)\n            # move nozzle back up\n            backup_pos = top_types.Point(0, 0, -dist)\n            await self.move_rel(mount, backup_pos)\n        instr.add_tip(tip_length=tip_length)\n        instr.set_current_volume(0)\n\n        # neighboring tips tend to get stuck in the space between\n        # the volume chamber and the drop-tip sleeve on p1000.\n        # This extra shake ensures those tips are removed\n        if 'needs-pickup-shake' in instr.config.quirks:\n            await self._shake_off_tips(mount)\n            await self._shake_off_tips(mount)\n\n        await self.retract(mount, instr.config.pick_up_distance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def drop_tip(self, mount, home_after=True):\n        instr = self._attached_instruments[mount]\n        assert instr\n        assert instr.has_tip, 'Cannot drop tip without a tip attached'\n        self._log.info(\"Dropping tip off from {}\".format(instr.name))\n        plunger_ax = Axis.of_plunger(mount)\n        droptip = instr.config.drop_tip\n        bottom = instr.config.bottom\n        self._backend.set_active_current(plunger_ax,\n                                         instr.config.plunger_current)\n        await self._move_plunger(mount, bottom)\n        self._backend.set_active_current(plunger_ax,\n                                         instr.config.drop_tip_current)\n        await self._move_plunger(\n            mount, droptip, speed=instr.config.drop_tip_speed)\n        await self._shake_off_tips(mount)\n        self._backend.set_active_current(plunger_ax,\n                                         instr.config.plunger_current)\n        instr.set_current_volume(0)\n        instr.remove_tip()\n        if home_after:\n            safety_margin = abs(bottom-droptip)\n            async with self._motion_lock:\n                smoothie_pos = self._backend.fast_home(\n                    plunger_ax.name.upper(), safety_margin)\n                self._current_position = self._deck_from_smoothie(smoothie_pos)\n            await self._move_plunger(mount, safety_margin)", "response": "Drop a tip from the current location."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset calibration values for the pipette plunger. This can be called multiple times as the user sets each value, or you can set them all at once. :param top: Touching but not engaging the plunger. :param bottom: Must be above the pipette's physical hard-stop, while still leaving enough room for 'blow_out' :param blow_out: Plunger is pushed down enough to expel all liquids. :param drop_tip: Position that causes the tip to be released from the pipette", "response": "def calibrate_plunger(self,\n                          mount: top_types.Mount,\n                          top: float = None, bottom: float = None,\n                          blow_out: float = None, drop_tip: float = None):\n        \"\"\"\n        Set calibration values for the pipette plunger.\n        This can be called multiple times as the user sets each value,\n        or you can set them all at once.\n        :param top: Touching but not engaging the plunger.\n        :param bottom: Must be above the pipette's physical hard-stop, while\n        still leaving enough room for 'blow_out'\n        :param blow_out: Plunger is pushed down enough to expel all liquids.\n        :param drop_tip: Position that causes the tip to be released from the\n        pipette\n        \"\"\"\n        instr = self._attached_instruments[mount]\n        if not instr:\n            raise top_types.PipetteNotAttachedError(\n                \"No pipette attached to {} mount\".format(mount.name))\n\n        pos_dict: Dict = {\n            'top': instr.config.top,\n            'bottom': instr.config.bottom,\n            'blow_out': instr.config.blow_out,\n            'drop_tip': instr.config.drop_tip}\n        if top is not None:\n            pos_dict['top'] = top\n        if bottom is not None:\n            pos_dict['bottom'] = bottom\n        if blow_out is not None:\n            pos_dict['blow_out'] = blow_out\n        if bottom is not None:\n            pos_dict['drop_tip'] = drop_tip\n        for key in pos_dict.keys():\n            instr.update_config_item(key, pos_dict[key])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def update_module(\n            self, module: modules.AbstractModule,\n            firmware_file: str,\n            loop: asyncio.AbstractEventLoop = None) -> Tuple[bool, str]:\n        \"\"\" Update a module's firmware.\n\n        Returns (ok, message) where ok is True if the update succeeded and\n        message is a human readable message.\n        \"\"\"\n        details = (module.port, module.name())\n        mod = self._attached_modules.pop(details[0] + details[1])\n        try:\n            new_mod = await self._backend.update_module(\n                mod, firmware_file, loop)\n        except modules.UpdateError as e:\n            return False, e.msg\n        else:\n            new_details = new_mod.port + new_mod.device_info['model']\n            self._attached_modules[new_details] = new_mod\n            return True, 'firmware update successful'", "response": "Update a module s firmware."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _do_tp(self, pip, mount) -> top_types.Point:\n        # Clear the old offset during calibration\n        pip.update_instrument_offset(top_types.Point())\n        # Hotspots based on our expectation of tip length and config\n        hotspots = robot_configs.calculate_tip_probe_hotspots(\n            pip.current_tip_length, self._config.tip_probe)\n        new_pos: Dict[Axis, List[float]] = {\n            ax: [] for ax in Axis.gantry_axes() if ax != Axis.A}\n        safe_z = self._config.tip_probe.z_clearance.crossover + \\\n            self._config.tip_probe.center[2]\n        for hs in hotspots:\n            ax_en = Axis[hs.axis.upper()]\n            overridden_center = {\n                ax: sum(vals)/len(vals)\n                if len(vals) == 2\n                else self._config.tip_probe.center[ax.value]\n                for ax, vals in new_pos.items()\n            }\n            x0 = overridden_center[Axis.X] + hs.x_start_offs\n            y0 = overridden_center[Axis.Y] + hs.y_start_offs\n            z0 = hs.z_start_abs\n            pos = await self.current_position(mount)\n\n            # Move safely to the setup point for the probe\n            await self.move_to(mount,\n                               top_types.Point(pos[Axis.X],\n                                               pos[Axis.Y],\n                                               safe_z))\n            await self.move_to(mount,\n                               top_types.Point(x0, y0, safe_z))\n            await self.move_to(mount,\n                               top_types.Point(x0, y0, z0))\n            if ax_en == Axis.Z:\n                to_probe = Axis.by_mount(mount)\n            else:\n                to_probe = ax_en\n            # Probe and retrieve the position afterwards\n            async with self._motion_lock:\n                self._current_position = self._deck_from_smoothie(\n                    self._backend.probe(\n                        to_probe.name.lower(), hs.probe_distance))\n            xyz = await self.gantry_position(mount)\n            # Store the upated position.\n            self._log.debug(\n                \"tip probe: hs {}: start: ({} {} {}) status {} will add {}\"\n                .format(hs, x0, y0, z0, new_pos, xyz[ax_en.value]))\n            new_pos[ax_en].append(xyz[ax_en.value])\n            # Before moving up, move back to clear the switches\n            bounce = self._config.tip_probe.bounce_distance\\\n                * (-1.0 if hs.probe_distance > 0 else 1.0)\n            await self.move_rel(mount,\n                                top_types.Point(\n                                    **{hs.axis: bounce}))\n            await self.move_to(mount, xyz._replace(z=safe_z))\n\n        to_ret = top_types.Point(**{ax.name.lower(): sum(vals)/len(vals)\n                                    for ax, vals in new_pos.items()})\n        self._log.info(\"Tip probe complete with {} {} on {}. \"\n                       \"New position: {} (default {}), averaged from {}\"\n                       .format(pip.name, pip.pipette_id, mount.name,\n                               to_ret, self._config.tip_probe.center,\n                               new_pos))\n        return to_ret", "response": "Perform the tip probe."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def locate_tip_probe_center(\n            self, mount, tip_length=None) -> top_types.Point:\n        \"\"\" Use the specified mount (which should have a tip) to find the\n        position of the tip probe target center relative to its definition\n\n        :param mount: The mount to use for the probe\n        :param tip_length: If specified (it should usually be specified),\n                           the length of the tip assumed to be attached.\n\n        The tip length specification is for the use case during protocol\n        calibration, when the machine cannot yet pick up a tip on its own.\n        For that reason, it is not universally necessary. Instead, there\n        are several cases:\n\n        1. A tip has previously been picked up with :py:meth:`pick_up_tip`.\n           ``tip_length`` should not be specified since the tip length is\n           known. If ``tip_length`` is not ``None``, this function asserts.\n        2. A tip has not previously been picked up, and ``tip_length`` is\n           specified. The pipette will internally have a tip added of the\n           specified length.\n        3. A tip has not previously been picked up, and ``tip_length`` is\n           not specified. The pipette will use the tip length from its\n           config.\n\n        The return value is a dict containing the updated position, in deck\n        coordinates, of the tip probe center.\n        \"\"\"\n        opt_pip = self._attached_instruments[mount]\n        assert opt_pip, '{} has no pipette'.format(mount.name.lower())\n        pip = opt_pip\n\n        if pip.has_tip and tip_length:\n            pip.remove_tip()\n\n        if not tip_length:\n            assert pip.has_tip,\\\n                'If pipette has no tip a tip length must be specified'\n            tip_length = pip._current_tip_length\n\n        # assure_tip lets us make sure we don\u2019t pollute the pipette\n        # state even if there\u2019s an exception in tip probe\n        @contextlib.contextmanager\n        def _assure_tip():\n            if pip.has_tip:\n                old_tip = pip._current_tip_length\n                pip.remove_tip()\n            else:\n                old_tip = None\n            pip.add_tip(tip_length)\n            try:\n                yield\n            finally:\n                pip.remove_tip()\n                if old_tip:\n                    pip.add_tip(old_tip)\n\n        with _assure_tip():\n            return await self._do_tp(pip, mount)", "response": "Locate the tip probe center relative to the given mount."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the instrument offset for a pipette on the specified mount.", "response": "def update_instrument_offset(self, mount,\n                                 new_offset: top_types.Point = None,\n                                 from_tip_probe: top_types.Point = None):\n        \"\"\" Update the instrument offset for a pipette on the specified mount.\n\n        This will update both the stored value in the robot settings and\n        the live value in the currently-loaded pipette.\n\n        This can be specified either directly by using the new_offset arg\n        or using the result of a previous call to\n        :py:meth:`locate_tip_probe_center` with the same mount.\n\n        :note: Z differences in the instrument offset cannot be\n               disambiguated between differences in the position of the\n               nozzle and differences in the length of the nozzle/tip\n               interface (assuming that tips are of reasonably uniform\n               length). For this reason, they are saved as adjustments\n               to the nozzle interface length and only applied when a\n               tip is present.\n        \"\"\"\n        if from_tip_probe:\n            new_offset = (top_types.Point(*self._config.tip_probe.center)\n                          - from_tip_probe)\n        elif not new_offset:\n            raise ValueError(\n                \"Either from_tip_probe or new_offset must be specified\")\n        opt_pip = self._attached_instruments[mount]\n        assert opt_pip, '{} has no pipette'.format(mount.name.lower())\n        pip = opt_pip\n        inst_offs = self._config.instrument_offset\n        pip_type = 'multi' if pip.config.channels > 1 else 'single'\n        inst_offs[mount.name.lower()][pip_type] = [new_offset.x,\n                                                   new_offset.y,\n                                                   new_offset.z]\n        self.update_config(instrument_offset=inst_offs)\n        pip.update_instrument_offset(new_offset)\n        robot_configs.save_robot_settings(self._config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenter bootloader mode of the atmega32u4 module.", "response": "async def enter_bootloader(module):\n    \"\"\"\n    Using the driver method, enter bootloader mode of the atmega32u4.\n    The bootloader mode opens a new port on the uC to upload the hex file.\n    After receiving a 'dfu' command, the firmware provides a 3-second window to\n    close the current port so as to do a clean switch to the bootloader port.\n    The new port shows up as 'ttyn_bootloader' on the pi; upload fw through it.\n    NOTE: Modules with old bootloader will have the bootloader port show up as\n    a regular module port- 'ttyn_tempdeck'/ 'ttyn_magdeck' with the port number\n    being either different or same as the one that the module was originally on\n    So we check for changes in ports and use the appropriate one\n    \"\"\"\n    # Required for old bootloader\n    ports_before_dfu_mode = await _discover_ports()\n\n    module._driver.enter_programming_mode()\n    module.disconnect()\n    new_port = ''\n    try:\n        new_port = await asyncio.wait_for(\n            _port_poll(_has_old_bootloader(module), ports_before_dfu_mode),\n            PORT_SEARCH_TIMEOUT)\n    except asyncio.TimeoutError:\n        pass\n    return new_port"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the avrdude firmware file for the specified module.", "response": "async def update_firmware(module, firmware_file_path, loop):\n    \"\"\"\n    Run avrdude firmware upload command. Switch back to normal module port\n\n    Note: For modules with old bootloader, the kernel could assign the module\n    a new port after the update (since the board is automatically reset).\n    Scan for such a port change and use the appropriate port\n    \"\"\"\n    # TODO: Make sure the module isn't in the middle of operation\n\n    ports_before_update = await _discover_ports()\n    config_file_path = os.path.join(package_root,\n                                    'config', 'modules', 'avrdude.conf')\n    proc = await asyncio.create_subprocess_exec(\n        'avrdude', '-C{}'.format(config_file_path), '-v',\n        '-p{}'.format(PART_NO),\n        '-c{}'.format(PROGRAMMER_ID),\n        '-P{}'.format(module.port),\n        '-b{}'.format(BAUDRATE), '-D',\n        '-Uflash:w:{}:i'.format(firmware_file_path),\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE, loop=loop)\n    await proc.wait()\n\n    _result = await proc.communicate()\n    result = _result[1].decode()\n    log.debug(result)\n    log.debug(\"Switching back to non-bootloader port\")\n    module._port = _port_on_mode_switch(ports_before_update)\n\n    return _format_avrdude_response(result)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(pipette_model: str, pipette_id: str = None) -> pipette_config:\n\n    # Load the model config and update with the name config\n    cfg = copy.deepcopy(configs[pipette_model])\n    cfg.update(copy.deepcopy(name_config()[cfg['name']]))\n    # Load overrides if we have a pipette id\n    if pipette_id:\n        try:\n            override = load_overrides(pipette_id)\n        except FileNotFoundError:\n            save_overrides(pipette_id, {}, pipette_model)\n            log.info(\n                \"Save defaults for pipette model {} and id {}\".format(\n                    pipette_model, pipette_id))\n        else:\n            cfg.update(override)\n\n    # the ulPerMm functions are structured in pipetteModelSpecs.json as\n    # a list sorted from oldest to newest. That means the latest functions\n    # are always the last element and, as of right now, the older ones are\n    # the first element (for models that only have one function, the first\n    # and last elements are the same, which is fine). If we add more in the\n    # future, we\u2019ll have to change this code to select items more\n    # intelligently\n    if ff.use_old_aspiration_functions():\n        log.info(\"Using old aspiration functions\")\n        ul_per_mm = cfg['ulPerMm'][0]\n    else:\n        log.info(\"Using new aspiration functions\")\n        ul_per_mm = cfg['ulPerMm'][-1]\n\n    res = pipette_config(\n        top=ensure_value(\n            cfg, 'top', mutable_configs),\n        bottom=ensure_value(\n            cfg, 'bottom', mutable_configs),\n        blow_out=ensure_value(\n            cfg, 'blowout', mutable_configs),\n        drop_tip=ensure_value(\n            cfg, 'dropTip', mutable_configs),\n        pick_up_current=ensure_value(cfg, 'pickUpCurrent', mutable_configs),\n        pick_up_distance=ensure_value(cfg, 'pickUpDistance', mutable_configs),\n        pick_up_increment=ensure_value(\n            cfg, 'pickUpIncrement', mutable_configs),\n        pick_up_presses=ensure_value(cfg, 'pickUpPresses', mutable_configs),\n        pick_up_speed=ensure_value(cfg, 'pickUpSpeed', mutable_configs),\n        aspirate_flow_rate=ensure_value(\n            cfg, 'defaultAspirateFlowRate', mutable_configs),\n        dispense_flow_rate=ensure_value(\n            cfg, 'defaultDispenseFlowRate', mutable_configs),\n        channels=ensure_value(cfg, 'channels', mutable_configs),\n        model_offset=ensure_value(cfg, 'modelOffset', mutable_configs),\n        plunger_current=ensure_value(cfg, 'plungerCurrent', mutable_configs),\n        drop_tip_current=ensure_value(cfg, 'dropTipCurrent', mutable_configs),\n        drop_tip_speed=ensure_value(cfg, 'dropTipSpeed', mutable_configs),\n        min_volume=ensure_value(cfg, 'minVolume', mutable_configs),\n        max_volume=ensure_value(cfg, 'maxVolume', mutable_configs),\n        ul_per_mm=ul_per_mm,\n        quirks=ensure_value(cfg, 'quirks', mutable_configs),\n        tip_length=ensure_value(cfg, 'tipLength', mutable_configs),\n        display_name=ensure_value(cfg, 'displayName', mutable_configs)\n    )\n\n    return res", "response": "Loads the configuration of a single pipette."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef piecewise_volume_conversion(\n        ul: float, sequence: List[List[float]]) -> float:\n    \"\"\"\n    Takes a volume in microliters and a sequence representing a piecewise\n    function for the slope and y-intercept of a ul/mm function, where each\n    sub-list in the sequence contains:\n\n      - the max volume for the piece of the function (minimum implied from the\n        max of the previous item or 0\n      - the slope of the segment\n      - the y-intercept of the segment\n\n    :return: the ul/mm value for the specified volume\n    \"\"\"\n    # pick the first item from the seq for which the target is less than\n    # the bracketing element\n    i = list(filter(lambda x: ul <= x[0], sequence))[0]\n    # use that element to calculate the movement distance in mm\n    return i[1]*ul + i[2]", "response": "This function takes a volume in microliters and a sequence representing a piecewise sequence and returns the value of the piecewise sequence function for the specified volume."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ensure_value(\n        config: dict,\n        name: Union[str, Tuple[str, ...]],\n        mutable_config_list: List[str]):\n    \"\"\"\n    Pull value of config data from file. Shape can either be a dictionary with\n    a value key -- indicating that it can be changed -- or another\n    data structure such as an array.\n    \"\"\"\n    if not isinstance(name, tuple):\n        path: Tuple[str, ...] = (name,)\n    else:\n        path = name\n    for element in path[:-1]:\n        config = config[element]\n\n    value = config[path[-1]]\n    if path[-1] in mutable_config_list:\n        value = value['value']\n    return value", "response": "Ensure that the value of the key in the config is set in mutable_config_list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef known_pipettes() -> Sequence[str]:\n    return [fi.stem\n            for fi in CONFIG['pipette_config_overrides_dir'].iterdir()\n            if fi.is_file() and '.json' in fi.suffixes]", "response": "List all pipettes which have known overrides"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_config_dict(pipette_id: str) -> Dict:\n    override = load_overrides(pipette_id)\n    model = override['model']\n    config = copy.deepcopy(model_config()['config'][model])\n    config.update(copy.deepcopy(name_config()[config['name']]))\n\n    for top_level_key in config.keys():\n        add_default(config[top_level_key])\n\n    config.update(override)\n\n    return config", "response": "Load the config dictionary for a pipette."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn dict of mutable configs only.", "response": "def list_mutable_configs(pipette_id: str) -> Dict[str, Any]:\n    \"\"\"\n    Returns dict of mutable configs only.\n    \"\"\"\n    cfg: Dict[str, Any] = {}\n\n    if pipette_id in known_pipettes():\n        config = load_config_dict(pipette_id)\n    else:\n        log.info('Pipette id {} not found'.format(pipette_id))\n        return cfg\n\n    for key in config:\n        if key in mutable_configs:\n            cfg[key] = config[key]\n    return cfg"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the key from a substring of the ISO - 8601 format.", "response": "def _parse_key_from_substring(substring) -> str:\n    '''\n    Returns the key in the expected string \"N:12.3\", where \"N\" is the\n    key, and \"12.3\" is a floating point value\n    '''\n    try:\n        return substring.split(':')[0]\n    except (ValueError, IndexError, TypeError, AttributeError):\n        log.exception('Unexpected argument to _parse_key_from_substring:')\n        raise ParseError(\n            'Unexpected argument to _parse_key_from_substring: {}'.format(\n                substring))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_device_information(device_info_string) -> dict:\n    '''\n    Parse the mag-deck's device information response.\n    Example response from temp-deck: \"serial:aa11 model:bb22 version:cc33\"\n    '''\n    error_msg = 'Unexpected argument to _parse_device_information: {}'.format(\n        device_info_string)\n    if not device_info_string or \\\n            not isinstance(device_info_string, str):\n        raise ParseError(error_msg)\n    parsed_values = device_info_string.strip().split(' ')\n    if len(parsed_values) < 3:\n        log.error(error_msg)\n        raise ParseError(error_msg)\n    res = {\n        _parse_key_from_substring(s): _parse_string_value_from_substring(s)\n        for s in parsed_values[:3]\n    }\n    for key in ['model', 'version', 'serial']:\n        if key not in res:\n            raise ParseError(error_msg)\n    return res", "response": "Parse the mag - depart s device information response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_distance_response(distance_string) -> float:\n    '''\n    Parse responses of 'GET_PLATE_HEIGHT' & 'GET_CURRENT_POSITION'\n    Example response of-\n    GET_PLATE_HEIGHT: \"height:12.34\"\n    GET_CURRENT_POSITION: \"Z:12.34\"\n    '''\n    err_msg = 'Unexpected argument to _parse_distance_response: {}'.format(\n        distance_string)\n    if not distance_string or \\\n            not isinstance(distance_string, str):\n        raise ParseError(err_msg)\n    if 'Z' not in distance_string and 'height' not in distance_string:\n        raise ParseError(err_msg)\n    return _parse_number_from_substring(  # type: ignore\n        distance_string.strip())", "response": "Parse the distance response from the API."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect(self, port=None) -> str:\n        '''\n        :param port: '/dev/modules/ttyn_magdeck'\n        NOTE: Using the symlink above to connect makes sure that the robot\n        connects/reconnects to the module even after a device\n        reset/reconnection\n        '''\n        if environ.get('ENABLE_VIRTUAL_SMOOTHIE', '').lower() == 'true':\n            return ''\n        try:\n            self.disconnect()\n            self._connect_to_port(port)\n            self._wait_for_ack()    # verify the device is there\n        except (SerialException, SerialNoResponse) as e:\n            return str(e)\n        return ''", "response": "Connect to the specified port and wait for ack."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprobe for the deck plate and calculates the plate distance from home.", "response": "def probe_plate(self) -> str:\n        '''\n        Probes for the deck plate and calculates the plate distance\n        from home.\n        To be used for calibrating MagDeck\n        '''\n        self.run_flag.wait()\n\n        try:\n            self._send_command(GCODES['PROBE_PLATE'])\n        except (MagDeckError, SerialException, SerialNoResponse) as e:\n            return str(e)\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef move(self, position_mm) -> str:\n        '''\n        Move the magnets along Z axis where the home position is 0.0;\n        position_mm-> a point along Z. Does not self-check if the position\n        is outside of the deck's linear range\n        '''\n        self.run_flag.wait()\n\n        try:\n            position_mm = round(float(position_mm), GCODE_ROUNDING_PRECISION)\n            self._send_command('{0} Z{1}'.format(GCODES['MOVE'], position_mm))\n        except (MagDeckError, SerialException, SerialNoResponse) as e:\n            return str(e)\n        return ''", "response": "Moves the magnet at the specified position in the deck along Z axis."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_device_info(self) -> dict:\n        '''\n        Queries Temp-Deck for it's build version, model, and serial number\n\n        returns: dict\n            Where keys are the strings 'version', 'model', and 'serial',\n            and each value is a string identifier\n\n            {\n                'serial': '1aa11bb22',\n                'model': '1aa11bb22',\n                'version': '1aa11bb22'\n            }\n\n        Example input from Temp-Deck's serial response:\n            \"serial:aa11bb22 model:aa11bb22 version:aa11bb22\"\n        '''\n        try:\n            return self._recursive_get_info(DEFAULT_COMMAND_RETRIES)\n        except (MagDeckError, SerialException, SerialNoResponse) as e:\n            return {'error': str(e)}", "response": "Queries Temp - Deck for it s build version model and serial number and returns a dict of the information about that Temp - Deck s device."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplan moves between one :py:class:`.Location` and another. Each :py:class:`.Location` instance might or might not have a specific kind of geometry attached. This function is intended to return series of moves that contain the minimum safe retractions to avoid (known) labware on the specified :py:class:`Deck`. :param from_loc: The last location. :param to_loc: The location to move to. :param deck: The :py:class:`Deck` instance describing the robot. :param float well_z_margin: How much extra Z margin to raise the cp by over the bare minimum to clear wells within the same labware. Default: 5mm :param float lw_z_margin: How much extra Z margin to raise the cp by over the bare minimum to clear different pieces of labware. Default: 20mm :param force_direct: If True, ignore any Z margins force a direct move :param minimum_z_height: When specified, this Z margin is able to raise (but never lower) the mid-arc height. :returns: A list of tuples of :py:class:`.Point` and critical point overrides to move through.", "response": "def plan_moves(\n        from_loc: types.Location,\n        to_loc: types.Location,\n        deck: 'Deck',\n        well_z_margin: float = 5.0,\n        lw_z_margin: float = 20.0,\n        force_direct: bool = False,\n        minimum_z_height: float = None)\\\n        -> List[Tuple[types.Point,\n                      Optional[CriticalPoint]]]:\n    \"\"\" Plan moves between one :py:class:`.Location` and another.\n\n    Each :py:class:`.Location` instance might or might not have a specific\n    kind of geometry attached. This function is intended to return series\n    of moves that contain the minimum safe retractions to avoid (known)\n    labware on the specified :py:class:`Deck`.\n\n    :param from_loc: The last location.\n    :param to_loc: The location to move to.\n    :param deck: The :py:class:`Deck` instance describing the robot.\n    :param float well_z_margin: How much extra Z margin to raise the cp by over\n                                the bare minimum to clear wells within the same\n                                labware. Default: 5mm\n    :param float lw_z_margin: How much extra Z margin to raise the cp by over\n                              the bare minimum to clear different pieces of\n                              labware. Default: 20mm\n    :param force_direct: If True, ignore any Z margins force a direct move\n    :param minimum_z_height: When specified, this Z margin is able to raise\n                             (but never lower) the mid-arc height.\n\n    :returns: A list of tuples of :py:class:`.Point` and critical point\n              overrides to move through.\n    \"\"\"\n\n    assert minimum_z_height is None or minimum_z_height >= 0.0\n\n    def _split_loc_labware(\n            loc: types.Location) -> Tuple[Optional[Labware], Optional[Well]]:\n        if isinstance(loc.labware, Labware):\n            return loc.labware, None\n        elif isinstance(loc.labware, Well):\n            return loc.labware.parent, loc.labware\n        else:\n            return None, None\n\n    to_point = to_loc.point\n    to_lw, to_well = _split_loc_labware(to_loc)\n    from_point = from_loc.point\n    from_lw, from_well = _split_loc_labware(from_loc)\n    dest_quirks = quirks_from_any_parent(to_lw)\n    from_quirks = quirks_from_any_parent(from_lw)\n    from_center = 'centerMultichannelOnWells' in from_quirks\n    to_center = 'centerMultichannelOnWells' in dest_quirks\n    dest_cp_override = CriticalPoint.XY_CENTER if to_center else None\n    origin_cp_override = CriticalPoint.XY_CENTER if from_center else None\n\n    is_same_location = ((to_lw and to_lw == from_lw)\n                        and (to_well and to_well == from_well))\n    if (force_direct or (is_same_location and not\n                         (minimum_z_height or 0) > 0)):\n        # If we\u2019re going direct, we can assume we\u2019re already in the correct\n        # cp so we can use the override without prep\n        return [(to_point, dest_cp_override)]\n\n    # Generate arc moves\n\n    # Find the safe z heights based on the destination and origin labware/well\n    if to_lw and to_lw == from_lw:\n        # If we know the labwares we\u2019re moving from and to, we can calculate\n        # a safe z based on their heights\n        if to_well:\n            to_safety = to_well.top().point.z + well_z_margin\n        else:\n            to_safety = to_lw.highest_z + well_z_margin\n        if from_well:\n            from_safety = from_well.top().point.z + well_z_margin\n        else:\n            from_safety = from_lw.highest_z + well_z_margin\n    else:\n        # One of our labwares is invalid so we have to just go above\n        # deck.highest_z since we don\u2019t know where we are\n        to_safety = deck.highest_z + lw_z_margin\n        from_safety = 0.0  # (ignore since it\u2019s in a max())\n\n    safe = max_many(\n        to_point.z,\n        from_point.z,\n        to_safety,\n        from_safety,\n        minimum_z_height or 0)\n\n    # We should use the origin\u2019s cp for the first move since it should\n    # move only in z and the destination\u2019s cp subsequently\n    return [(from_point._replace(z=safe), origin_cp_override),\n            (to_point._replace(z=safe), dest_cp_override),\n            (to_point, dest_cp_override)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_calibration(labware: Labware, delta: Point):\n    calibration_path = CONFIG['labware_calibration_offsets_dir_v4']\n    if not calibration_path.exists():\n        calibration_path.mkdir(parents=True, exist_ok=True)\n    labware_offset_path = calibration_path/'{}.json'.format(labware._id)\n    calibration_data = _helper_offset_data_format(\n        str(labware_offset_path), delta)\n    with labware_offset_path.open('w') as f:\n        json.dump(calibration_data, f)\n    labware.set_calibration(delta)", "response": "Function to be used when an updated delta is found for the first well\n    of a given labware."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction to be used when an updated tip length is found for a given tip rack.", "response": "def save_tip_length(labware: Labware, length: float):\n    \"\"\"\n    Function to be used whenever an updated tip length is found for\n    of a given tip rack. If an offset file does not exist, create the file\n    using labware id as the filename. If the file does exist, load it and\n    modify the length and the lastModified fields under the \"tipLength\" key.\n    \"\"\"\n    calibration_path = CONFIG['labware_calibration_offsets_dir_v4']\n    if not calibration_path.exists():\n        calibration_path.mkdir(parents=True, exist_ok=True)\n    labware_offset_path = calibration_path/'{}.json'.format(labware._id)\n    calibration_data = _helper_tip_length_data_format(\n        str(labware_offset_path), length)\n    with labware_offset_path.open('w') as f:\n        json.dump(calibration_data, f)\n    labware.tip_length = length"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a calibration from the given labware.", "response": "def load_calibration(labware: Labware):\n    \"\"\"\n    Look up a calibration if it exists and apply it to the given labware.\n    \"\"\"\n    calibration_path = CONFIG['labware_calibration_offsets_dir_v4']\n    labware_offset_path = calibration_path/'{}.json'.format(labware._id)\n    if labware_offset_path.exists():\n        calibration_data = _read_file(str(labware_offset_path))\n        offset_array = calibration_data['default']['offset']\n        offset = Point(x=offset_array[0], y=offset_array[1], z=offset_array[2])\n        labware.set_calibration(offset)\n        if 'tipLength' in calibration_data.keys():\n            tip_length = calibration_data['tipLength']['length']\n            labware.tip_length = tip_length"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_definition_by_name(name: str) -> dict:\n    def_path = 'shared_data/definitions2/{}.json'.format(name.lower())\n    labware_def = json.loads(pkgutil.get_data('opentrons', def_path))  # type: ignore # NOQA\n    return labware_def", "response": "Load a labware definition by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(name: str, parent: Location, label: str = None) -> Labware:\n    definition = load_definition_by_name(name)\n    return load_from_definition(definition, parent, label)", "response": "Loads a labware definition dict from disk and returns it"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_from_definition(\n        definition: dict, parent: Location, label: str = None) -> Labware:\n    \"\"\"\n    Return a labware object constructed from a provided labware definition dict\n\n    :param definition: A dict representing all required data for a labware,\n        including metadata such as the display name of the labware, a\n        definition of the order to iterate over wells, the shape of wells\n        (shape, physical dimensions, etc), and so on. The correct shape of\n        this definition is governed by the \"labware-designer\" project in\n        the Opentrons/opentrons repo.\n    :param parent: A :py:class:`.Location` representing the location where\n                   the front and left most point of the outside of labware is\n                   (often the front-left corner of a slot on the deck).\n    :param str label: An optional label that will override the labware's\n                      display name from its definition\n    \"\"\"\n    labware = Labware(definition, parent, label)\n    load_calibration(labware)\n    return labware", "response": "Returns a new labware object constructed from a provided labware definition dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete all calibration files for labware.", "response": "def clear_calibrations():\n    \"\"\"\n    Delete all calibration files for labware. This includes deleting tip-length\n    data for tipracks.\n    \"\"\"\n    calibration_path = CONFIG['labware_calibration_offsets_dir_v4']\n    try:\n        targets = [\n            f for f in calibration_path.iterdir() if f.suffix == '.json']\n        for target in targets:\n            target.unlink()\n    except FileNotFoundError:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_module_from_definition(\n        definition: dict, parent: Location) -> \\\n            Union[ModuleGeometry, ThermocyclerGeometry]:\n    \"\"\"\n    Return a :py:class:`ModuleGeometry` object from a specified definition\n\n    :param definition: A dict representing all required data for a module's\n                       geometry.\n    :param parent: A :py:class:`.Location` representing the location where\n                   the front and left most point of the outside of the module\n                   is (often the front-left corner of a slot on the deck).\n    \"\"\"\n    mod_name = definition['loadName']\n    if mod_name == 'thermocycler' or mod_name == 'semithermocycler':\n        mod: Union[ModuleGeometry, ThermocyclerGeometry] = \\\n                ThermocyclerGeometry(definition, parent)\n    else:\n        mod = ModuleGeometry(definition, parent)\n    # TODO: calibration\n    return mod", "response": "Load a module from a dictionary containing all required data for a module."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_module(name: str, parent: Location) -> ModuleGeometry:\n    def_path = 'shared_data/robot-data/moduleSpecs.json'\n    module_def = json.loads(  # type: ignore\n        pkgutil.get_data('opentrons', def_path))\n    return load_module_from_definition(module_def[name], parent)", "response": "Load a module from a definition."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef quirks_from_any_parent(\n        loc: Union[Labware, Well, str, ModuleGeometry, None]) -> List[str]:\n    \"\"\" Walk the tree of wells and labwares and extract quirks \"\"\"\n    def recursive_get_quirks(obj, found):\n        if isinstance(obj, Labware):\n            return found + obj.quirks\n        elif isinstance(obj, Well):\n            return recursive_get_quirks(obj.parent, found)\n        else:\n            return found\n    return recursive_get_quirks(loc, [])", "response": "Returns a list of quirks from any parent of a well or labware."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the top - center of the deck at the given z distance", "response": "def top(self, z: float = 0.0) -> Location:\n        \"\"\"\n        :param z: the z distance in mm\n        :return: a Point corresponding to the absolute position of the\n                 top-center of the well relative to the deck (with the\n                 front-left corner of slot 1 as (0,0,0)). If z is specified,\n                 returns a point offset by z mm from top-center\n        \"\"\"\n        return Location(self._position + Point(0, 0, z), self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bottom(self, z: float = 0.0) -> Location:\n        top = self.top()\n        bottom_z = top.point.z - self._depth + z\n        return Location(Point(x=top.point.x, y=top.point.y, z=bottom_z), self)", "response": "returns the bottom - center of the well with the front - left corner of the well as ( 0 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a Location corresponding to the absolute position of the center of the well relative to the deck.", "response": "def center(self) -> Location:\n        \"\"\"\n        :return: a Point corresponding to the absolute position of the center\n        of the well relative to the deck (with the front-left corner of slot 1\n        as (0,0,0))\n        \"\"\"\n        top = self.top()\n        center_z = top.point.z - (self._depth / 2.0)\n        return Location(Point(x=top.point.x, y=top.point.y, z=center_z), self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a Point representing the specified location in cartesian coordinates.", "response": "def _from_center_cartesian(\n            self, x: float, y: float, z: float) -> Point:\n        \"\"\"\n        Specifies an arbitrary point relative to the center of the well based\n        on percentages of the radius in each axis. For example, to specify the\n        back-right corner of a well at 1/4 of the well depth from the bottom,\n        the call would be `_from_center_cartesian(1, 1, -0.5)`.\n\n        No checks are performed to ensure that the resulting position will be\n        inside of the well.\n\n        :param x: a float in the range [-1.0, 1.0] for a percentage of half of\n            the radius/length in the X axis\n        :param y: a float in the range [-1.0, 1.0] for a percentage of half of\n            the radius/width in the Y axis\n        :param z: a float in the range [-1.0, 1.0] for a percentage of half of\n            the height above/below the center\n\n        :return: a Point representing the specified location in absolute deck\n        coordinates\n        \"\"\"\n        center = self.center()\n        if self._shape is WellShape.RECTANGULAR:\n            x_size = self._length\n            y_size = self._width\n        else:\n            x_size = self._diameter\n            y_size = self._diameter\n        z_size = self._depth\n\n        return Point(\n            x=center.point.x + (x * (x_size / 2.0)),\n            y=center.point.y + (y * (y_size / 2.0)),\n            z=center.point.z + (z * (z_size / 2.0)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _build_wells(self) -> List[Well]:\n        return [\n            Well(\n                self._well_definition[well],\n                Location(self._calibrated_offset, self),\n                \"{} of {}\".format(well, self._display_name),\n                self.is_tiprack)\n            for well in self._ordering]", "response": "Builds a list of wells that are used by all the wells in the calendar."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_indexed_dictionary(self, group=0):\n        dict_list = defaultdict(list)\n        for index, well_obj in zip(self._ordering, self._wells):\n            dict_list[self._pattern.match(index).group(group)].append(well_obj)\n        return dict_list", "response": "Creates a dictionary of lists of Wells."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_calibration(self, delta: Point):\n        self._calibrated_offset = Point(x=self._offset.x + delta.x,\n                                        y=self._offset.y + delta.y,\n                                        z=self._offset.z + delta.z)\n        self._wells = self._build_wells()", "response": "Updates the offset of the object based on the given delta."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndeprecate - use result of wells_by_index or wells_by_name", "response": "def well(self, idx) -> Well:\n        \"\"\"Deprecated---use result of `wells` or `wells_by_index`\"\"\"\n        if isinstance(idx, int):\n            res = self._wells[idx]\n        elif isinstance(idx, str):\n            res = self.wells_by_index()[idx]\n        else:\n            res = NotImplemented\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of all wells in a labware.", "response": "def wells(self, *args) -> List[Well]:\n        \"\"\"\n        Accessor function used to generate a list of wells in top -> down,\n        left -> right order. This is representative of moving down `rows` and\n        across `columns` (e.g. 'A1', 'B1', 'C1'...'A2', 'B2', 'C2')\n\n        With indexing one can treat it as a typical python\n        list. To access well A1, for example, simply write: labware.wells()[0]\n\n        Note that this method takes args for backward-compatibility, but use\n        of args is deprecated and will be removed in future versions. Args\n        can be either strings or integers, but must all be the same type (e.g.:\n        `self.wells(1, 4, 8)` or `self.wells('A1', 'B2')`, but\n        `self.wells('A1', 4)` is invalid.\n\n        :return: Ordered list of all wells in a labware\n        \"\"\"\n        if not args:\n            res = self._wells\n        elif isinstance(args[0], int):\n            res = [self._wells[idx] for idx in args]\n        elif isinstance(args[0], str):\n            res = [self.wells_by_index()[idx] for idx in args]\n        else:\n            raise TypeError\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wells_by_index(self) -> Dict[str, Well]:\n        return {well: wellObj\n                for well, wellObj in zip(self._ordering, self._wells)}", "response": "Returns a dictionary of wells keyed by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of lists of all the wells in the current table.", "response": "def rows(self, *args) -> List[List[Well]]:\n        \"\"\"\n        Accessor function used to navigate through a labware by row.\n\n        With indexing one can treat it as a typical python nested list.\n        To access row A for example, simply write: labware.rows()[0]. This\n        will output ['A1', 'A2', 'A3', 'A4'...]\n\n        Note that this method takes args for backward-compatibility, but use\n        of args is deprecated and will be removed in future versions. Args\n        can be either strings or integers, but must all be the same type (e.g.:\n        `self.rows(1, 4, 8)` or `self.rows('A', 'B')`, but  `self.rows('A', 4)`\n        is invalid.\n\n        :return: A list of row lists\n        \"\"\"\n        row_dict = self._create_indexed_dictionary(group=1)\n        keys = sorted(row_dict)\n\n        if not args:\n            res = [row_dict[key] for key in keys]\n        elif isinstance(args[0], int):\n            res = [row_dict[keys[idx]] for idx in args]\n        elif isinstance(args[0], str):\n            res = [row_dict[idx] for idx in args]\n        else:\n            raise TypeError\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary of Well lists keyed by row name.", "response": "def rows_by_index(self) -> Dict[str, List[Well]]:\n        \"\"\"\n        Accessor function used to navigate through a labware by row name.\n\n        With indexing one can treat it as a typical python dictionary.\n        To access row A for example, simply write: labware.rows_by_index()['A']\n        This will output ['A1', 'A2', 'A3', 'A4'...].\n\n        :return: Dictionary of Well lists keyed by row name\n        \"\"\"\n        row_dict = self._create_indexed_dictionary(group=1)\n        return row_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef columns(self, *args) -> List[List[Well]]:\n        col_dict = self._create_indexed_dictionary(group=2)\n        keys = sorted(col_dict, key=lambda x: int(x))\n\n        if not args:\n            res = [col_dict[key] for key in keys]\n        elif isinstance(args[0], int):\n            res = [col_dict[keys[idx]] for idx in args]\n        elif isinstance(args[0], str):\n            res = [col_dict[idx] for idx in args]\n        else:\n            raise TypeError\n        return res", "response": "Returns a list of lists of column names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef columns_by_index(self) -> Dict[str, List[Well]]:\n        col_dict = self._create_indexed_dictionary(group=2)\n        return col_dict", "response": "Returns a dictionary of lists keyed by column name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef next_tip(self, num_tips: int = 1) -> Optional[Well]:\n        assert num_tips > 0\n\n        columns: List[List[Well]] = self.columns()\n        drop_leading_empties = [\n            list(dropwhile(lambda x: not x.has_tip, column))\n            for column in columns]\n        drop_at_first_gap = [\n            list(takewhile(lambda x: x.has_tip, column))\n            for column in drop_leading_empties]\n        long_enough = [\n            column for column in drop_at_first_gap if len(column) >= num_tips]\n\n        try:\n            first_long_enough = long_enough[0]\n            result: Optional[Well] = first_long_enough[0]\n        except IndexError:\n            result = None\n\n        return result", "response": "Find the next valid start tip for pick - up."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_tips(self, start_well: Well, num_channels: int = 1):\n        assert num_channels > 0, 'Bad call to use_tips: num_channels==0'\n        # Select the column of the labware that contains the target well\n        target_column: List[Well] = [\n            col for col in self.columns() if start_well in col][0]\n\n        well_idx = target_column.index(start_well)\n        # Number of tips to pick up is the lesser of (1) the number of tips\n        # from the starting well to the end of the column, and (2) the number\n        # of channels of the pipette (so a 4-channel pipette would pick up a\n        # max of 4 tips, and picking up from the 2nd-to-bottom well in a\n        # column would get a maximum of 2 tips)\n        num_tips = min(len(target_column) - well_idx, num_channels)\n        target_wells = target_column[well_idx: well_idx + num_tips]\n\n        assert all([well.has_tip for well in target_wells]),\\\n            '{} is out of tips'.format(str(self))\n\n        for well in target_wells:\n            well.has_tip = False", "response": "This method will remove tips from the tip tracker."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the module firmware of a single object.", "response": "async def update_module_firmware(request):\n    \"\"\"\n     This handler accepts a POST request with Content-Type: multipart/form-data\n     and a file field in the body named \"module_firmware\". The file should\n     be a valid HEX image to be flashed to the atmega32u4. The received file is\n     sent via USB to the board and flashed by the avr109 bootloader. The file\n     is then deleted and a success code is returned\n    \"\"\"\n    log.debug('Update Firmware request received')\n    data = await request.post()\n    module_serial = request.match_info['serial']\n\n    res = await _update_module_firmware(request.app['com.opentrons.hardware'],\n                                        module_serial,\n                                        data['module_firmware'],\n                                        request.loop)\n    if 'successful' not in res['message']:\n        if 'avrdudeResponse' in res and \\\n           'checksum mismatch' in res['avrdudeResponse']:\n            status = 400\n        elif 'not found' in res['message']:\n            status = 404\n        else:\n            status = 500\n        log.error(res)\n    else:\n        status = 200\n        log.info(res)\n    return web.json_response(res, status=status)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def _upload_to_module(hw, serialnum, fw_filename, loop):\n\n    # ensure there is a reference to the port\n    if not hw.is_connected():\n        hw.connect()\n\n    hw.discover_modules()\n    hw_mods = hw.attached_modules.values()\n\n    res = {}\n    for module in hw_mods:\n        if module.device_info.get('serial') == serialnum:\n            log.info(\"Module with serial {} found\".format(serialnum))\n            bootloader_port = await modules.enter_bootloader(module)\n            if bootloader_port:\n                module._port = bootloader_port\n            # else assume old bootloader connection on existing module port\n            log.info(\"Uploading file to port: {}\".format(\n                module.port))\n            log.info(\"Flashing firmware. This will take a few seconds\")\n            try:\n                res = await asyncio.wait_for(\n                    modules.update_firmware(\n                        module, fw_filename, loop),\n                    UPDATE_TIMEOUT)\n            except asyncio.TimeoutError:\n                return {'message': 'AVRDUDE not responding'}\n            break\n    if not res:\n        res = {'message': 'Module {} not found'.format(serialnum)}\n    return res", "response": "Uploads a firmware to the specified module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures the decorated is only called if the request is linklocal. The host ip address should be in the X-Host-IP header (provided by nginx)", "response": "def require_linklocal(handler):\n    \"\"\" Ensure the decorated is only called if the request is linklocal.\n\n    The host ip address should be in the X-Host-IP header (provided by nginx)\n    \"\"\"\n    @functools.wraps(handler)\n    async def decorated(request: web.Request) -> web.Response:\n        ipaddr_str = request.headers.get('x-host-ip')\n        invalid_req_data = {\n            'error': 'bad-interface',\n            'message': f'The endpoint {request.url} can only be used from '\n            'local connections'\n        }\n        if not ipaddr_str:\n            return web.json_response(\n                data=invalid_req_data,\n                status=403)\n        try:\n            addr = ipaddress.ip_address(ipaddr_str)\n        except ValueError:\n            LOG.exception(f\"Couldn't parse host ip address {ipaddr_str}\")\n            raise\n\n        if not addr.is_link_local:\n            return web.json_response(data=invalid_req_data, status=403)\n\n        return await handler(request)\n    return decorated"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authorized_keys(mode='r'):\n    path = '/var/home/.ssh/authorized_keys'\n    if not os.path.exists(path):\n        os.makedirs(os.path.dirname(path))\n        open(path, 'w').close()\n    with open(path, mode) as ak:\n        yield ak", "response": "Open the authorized_keys file. Separate function for mocking.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_keys() -> List[Tuple[str, str]]:\n    with authorized_keys() as ak:\n        return [(hashlib.new('md5', line.encode()).hexdigest(),\n                 line)\n                for line in ak.read().split('\\n')\n                if line.strip()]", "response": "Return a list of md5s of all public keys in the authorized_keys file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the key whose md5 sum matches hashval.", "response": "def remove_by_hash(hashval: str):\n    \"\"\" Remove the key whose md5 sum matches hashval.\n\n    :raises: KeyError if the hashval wasn't found\n    \"\"\"\n    key_details = get_keys()\n    with authorized_keys('w') as ak:\n        for keyhash, key in key_details:\n            if keyhash != hashval:\n                ak.write(f'{key}\\n')\n                break\n        else:\n            raise KeyError(hashval)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def list_keys(request: web.Request) -> web.Response:\n    return web.json_response(\n        {'public_keys': [{'key_md5': details[0], 'key': details[1]}\n                         for details in get_keys()]},\n        status=200)", "response": "List keys in the authorized_keys file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def add(request: web.Request) -> web.Response:\n    body = await request.json()\n    if 'key' not in body or not isinstance(body['key'], str):\n        return web.json_response(\n            data={'error': 'no-key', 'message': 'No \"key\" element in body'},\n            status=400)\n    pubkey = body['key']\n    # Do some fairly minor sanitization; dropbear will ignore invalid keys but\n    # we still don\u2019t want to have a bunch of invalid data in there\n    alg = pubkey.split()[0]\n    # We don\u2019t allow dss so this has to be rsa or ecdsa and shouldn\u2019t start\n    # with restrictions\n    if alg != 'ssh-rsa' and not alg.startswith('ecdsa'):\n        LOG.warning(f\"weird keyfile uploaded: starts with {alg}\")\n        return web.json_response(\n            data={'error': 'bad-key',\n                  'message': f'Key starts with invalid algorithm {alg}'},\n            status=400)\n    if '\\n' in pubkey[:-1]:\n        LOG.warning(f\"Newlines in keyfile that shouldn't be there\")\n        return web.json_response(\n            data={'error': 'bad-key', 'message': f'Key has a newline'},\n            status=400)\n\n    if '\\n' == pubkey[-1]:\n        pubkey = pubkey[:-1]\n\n    # This is a more or less correct key we can write\n    hashval = hashlib.new('md5', pubkey.encode()).hexdigest()\n    if not key_present(hashval):\n        with authorized_keys('a') as ak:\n            ak.write(f'{pubkey}\\n')\n\n    return web.json_response(\n            data={'message': 'Added key {hashval}',\n                  'key_md5': hashval},\n            status=201)", "response": "Add a public key to the authorized_keys file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def remove(request: web.Request) -> web.Response:\n    requested_hash = request.match_info['key_md5']\n    new_keys: List[str] = []\n    found = False\n    for keyhash, key in get_keys():\n        if keyhash == requested_hash:\n            found = True\n        else:\n            new_keys.append(key)\n\n    if not found:\n        return web.json_response(\n            data={'error': 'invalid-key-hash',\n                  'message': f'No such key md5 {requested_hash}'},\n            status=404)\n\n    with authorized_keys('w') as ak:\n        ak.write('\\n'.join(new_keys) + '\\n')\n\n    return web.json_response(\n        data={\n            'message': f'Key {requested_hash} deleted. '\n            'Restart robot to take effect',\n            'restart_url': '/server/restart'},\n        status=200)", "response": "Remove a public key from authorized_keys"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning that sets the log levels and format strings. Checks for OT_API_LOG_LEVEL environment variable otherwise defaults to INFO.", "response": "def log_init():\n    \"\"\"\n    Function that sets log levels and format strings. Checks for the\n    OT_API_LOG_LEVEL environment variable otherwise defaults to DEBUG.\n    \"\"\"\n    fallback_log_level = 'INFO'\n    ot_log_level = hardware.config.log_level\n    if ot_log_level not in logging._nameToLevel:\n        log.info(\"OT Log Level {} not found. Defaulting to {}\".format(\n            ot_log_level, fallback_log_level))\n        ot_log_level = fallback_log_level\n\n    level_value = logging._nameToLevel[ot_log_level]\n\n    serial_log_filename = CONFIG['serial_log_file']\n    api_log_filename = CONFIG['api_log_file']\n\n    logging_config = dict(\n        version=1,\n        formatters={\n            'basic': {\n                'format':\n                '%(asctime)s %(name)s %(levelname)s [Line %(lineno)s] %(message)s'  # noqa: E501\n            }\n        },\n        handlers={\n            'debug': {\n                'class': 'logging.StreamHandler',\n                'formatter': 'basic',\n                'level': level_value\n            },\n            'serial': {\n                'class': 'logging.handlers.RotatingFileHandler',\n                'formatter': 'basic',\n                'filename': serial_log_filename,\n                'maxBytes': 5000000,\n                'level': logging.DEBUG,\n                'backupCount': 3\n            },\n            'api': {\n                'class': 'logging.handlers.RotatingFileHandler',\n                'formatter': 'basic',\n                'filename': api_log_filename,\n                'maxBytes': 1000000,\n                'level': logging.DEBUG,\n                'backupCount': 5\n            }\n\n        },\n        loggers={\n            '__main__': {\n                'handlers': ['debug', 'api'],\n                'level': logging.INFO\n            },\n            'opentrons.server': {\n                'handlers': ['debug', 'api'],\n                'level': level_value\n            },\n            'opentrons.api': {\n                'handlers': ['debug', 'api'],\n                'level': level_value\n            },\n            'opentrons.instruments': {\n                'handlers': ['debug', 'api'],\n                'level': level_value\n            },\n            'opentrons.config': {\n                'handlers': ['debug', 'api'],\n                'level': level_value\n            },\n            'opentrons.drivers.smoothie_drivers.driver_3_0': {\n                'handlers': ['debug', 'api'],\n                'level': level_value\n            },\n            'opentrons.drivers.serial_communication': {\n                'handlers': ['serial'],\n                'level': logging.DEBUG\n            },\n            'opentrons.drivers.thermocycler.driver': {\n                'handlers': ['serial'],\n                'level': logging.DEBUG\n            },\n            'opentrons.protocol_api': {\n                'handlers': ['api', 'debug'],\n                'level': level_value\n            },\n            'opentrons.hardware_control': {\n                'handlers': ['api', 'debug'],\n                'level': level_value\n            },\n            'opentrons.legacy_api.containers': {\n                'handlers': ['api'],\n                'level': level_value\n            }\n        }\n    )\n    dictConfig(logging_config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_rules_file():\n    import shutil\n    import subprocess\n\n    rules_file = os.path.join(\n        os.path.abspath(os.path.dirname(__file__)), '..',\n        'config', 'modules', '95-opentrons-modules.rules')\n\n    shutil.copy2(\n        rules_file,\n        '/data/user_storage/opentrons_data/95-opentrons-modules.rules')\n\n    res0 = subprocess.run('udevadm control --reload-rules',\n                          shell=True, stdout=subprocess.PIPE).stdout.decode()\n    if res0:\n        log.warning(res0.strip())\n\n    res1 = subprocess.run('udevadm trigger',\n                          shell=True, stdout=subprocess.PIPE).stdout.decode()\n    if res1:\n        log.warning(res1.strip())", "response": "Setup the rules file for Opentrons Modules to opentrons_data directory and trigger the new rules."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestarting the robot. Blocks while the restart lock is held.", "response": "async def restart(request: web.Request) -> web.Response:\n    \"\"\" Restart the robot.\n\n    Blocks while the restart lock is held.\n    \"\"\"\n    async with request.app[RESTART_LOCK_NAME]:\n        asyncio.get_event_loop().call_later(1, _do_restart)\n    return web.json_response({'message': 'Restarting in 1s'},\n                             status=200)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a function that returns a response that captures the version info of the current language.", "response": "def build_health_endpoint(\n        version_dict: Mapping[str, str])\\\n        -> Callable[[web.Request],\n                    Coroutine[None, None, web.Response]]:\n    \"\"\" Build a coroutine to serve /health that captures version info\n    \"\"\"\n    async def health(request: web.Request) -> web.Response:\n        return web.json_response(\n            {\n                'name': request.app[DEVICE_NAME_VARNAME],\n                'updateServerVersion': version_dict.get(\n                    'update_server_version', 'unknown'),\n                'serialNumber': get_serial(),\n                'apiServerVersion': version_dict.get(\n                    'opentrons_api_version', 'unknown'),\n                'smoothieVersion': 'unimplemented',\n                'systemVersion': version_dict.get(\n                    'buildroot_version', 'unknown'),\n                'capabilities': {'buildroot-update': '/server/update/begin',\n                                 'restart': '/server/restart'}\n            },\n            headers={'Access-Control-Allow-Origin': '*'}\n        )\n    return health"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a virtual environment and return the path to the virtual env it should contain a bin directory with the python and pip binaries that can be used to test install of a software package.", "response": "async def create_virtual_environment(loop=None):\n    \"\"\"\n    Create a virtual environment, and return the path to the virtual env\n    directory, which should contain a \"bin\" directory with the `python` and\n    `pip` binaries that can be used to a test install of a software package.\n\n    :return: the path to the virtual environment, its python, and its site pkgs\n    \"\"\"\n    tmp_dir = tempfile.mkdtemp()\n    venv_dir = os.path.join(tmp_dir, VENV_NAME)\n    proc1 = await asyncio.create_subprocess_shell(\n        'virtualenv {}'.format(venv_dir), loop=loop)\n    await proc1.communicate()\n    if sys.platform == 'win32':\n        python = os.path.join(venv_dir, 'Scripts', 'python.exe')\n    else:\n        python = os.path.join(venv_dir, 'bin', 'python')\n    venv_site_pkgs = install_dependencies(python)\n\n    log.info(\"Created virtual environment at {}\".format(venv_dir))\n\n    return venv_dir, python, venv_site_pkgs"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstalls the dependencies of the given python package into the new virtualenv.", "response": "def install_dependencies(python) -> str:\n    \"\"\"\n    Copy aiohttp and virtualenv install locations (and their transitive\n    dependencies in new virtualenv so that the update server can install\n    without access to full system site-packages or connection to the internet.\n    Full access to system site-packages causes the install inside the\n    virtualenv to fail quietly because it does not have permission to overwrite\n    a package by the same name and then it picks up the system version of\n    otupdate. Also, we have to do a copy rather than a symlink because a non-\n    admin Windows account does not have permissions to create symlinks.\n    \"\"\"\n    # Import all of the packages that need to be available in the virtualenv\n    # for the update server to boot, so we can locate them using their __file__\n    # attribute\n    import aiohttp\n    import virtualenv_support\n    import async_timeout\n    import chardet\n    import multidict\n    import yarl\n    import idna\n    import pip\n    import setuptools\n    import virtualenv\n\n    # Determine where the site-packages directory exists in the virtualenv\n    tmpdirname = python.split(VENV_NAME)[0]\n    paths_raw = sp.check_output(\n        '{} -c \"import sys; [print(p) for p in sys.path]\"'.format(python),\n        shell=True)\n    paths = paths_raw.decode().split()\n    venv_site_pkgs = list(\n        filter(\n            lambda x: tmpdirname in x and 'site-packages' in x, paths))[-1]\n\n    dependencies = [\n        ('aiohttp', aiohttp),\n        ('virtualenv_support', virtualenv_support),\n        ('async_timeout', async_timeout),\n        ('chardet', chardet),\n        ('multidict', multidict),\n        ('yarl', yarl),\n        ('idna', idna),\n        ('pip', pip),\n        ('setuptools', setuptools),\n        ('virtualenv.py', virtualenv)]\n\n    # Copy each dependency from is system-install location to the site-packages\n    # directory of the virtualenv\n    for dep_name, dep in dependencies:\n        src_dir = os.path.abspath(os.path.dirname(dep.__file__))\n        dst = os.path.join(venv_site_pkgs, dep_name)\n        if os.path.exists(dst):\n            log.debug('{} already exists--skipping'.format(dst))\n        else:\n            log.debug('Copying {} to {}'.format(dep_name, dst))\n            if dep_name.endswith('.py'):\n                shutil.copy2(os.path.join(src_dir, dep_name), dst)\n            else:\n                shutil.copytree(src_dir, dst)\n    return venv_site_pkgs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _start_server(python, port,\n                        venv_site_pkgs=None, cwd=None) -> sp.Popen:\n    \"\"\"\n    Starts an update server sandboxed in the virtual env, and attempts to read\n    the health endpoint with retries to determine when the server is available.\n    If the number of retries is exceeded, the returned server process will\n    already be terminated.\n\n    :return: the server process\n    \"\"\"\n    log.info(\"Starting sandboxed update server on port {}\".format(port))\n    if venv_site_pkgs:\n        python = 'PYTHONPATH={} {}'.format(venv_site_pkgs, python)\n    cmd = [python, '-m', 'otupdate', '--debug', '--test', '--port', str(port)]\n    log.debug('cmd: {}'.format(' '.join(cmd)))\n    proc = sp.Popen(' '.join(cmd), shell=True, cwd=cwd)\n    atexit.register(lambda: _stop_server(proc))\n\n    n_retries = 3\n    async with aiohttp.ClientSession() as session:\n        test_status, detail = await selftest.health_check(\n            session=session, port=port, retries=n_retries)\n    if test_status == 'failure':\n        log.debug(\n            \"Test server failed to start after {} retries. Stopping.\".format(\n                n_retries))\n        _stop_server(proc)\n    return proc", "response": "Starts an update server sandboxed in the virtual env."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstall an update server into a virtual environment and return a dict and the path to python in the virtual environment", "response": "async def install_sandboxed_update(filename, loop):\n    \"\"\"\n    Create a virtual environment and activate it, and then install an\n    update candidate (leaves virtual environment activated)\n\n    :return: a result dict and the path to python in the virtual environment\n    \"\"\"\n    log.debug(\"Creating virtual environment\")\n    venv_dir, python, venv_site_pkgs\\\n        = await create_virtual_environment(loop=loop)\n    log.debug(\"Installing update server into virtual environment\")\n    out, err, returncode = await _install(python, filename, loop)\n    if err or returncode != 0:\n        log.error(\"Install failed: {}\".format(err))\n        res = {'status': 'failure', 'message': err}\n    else:\n        log.debug(\"Install successful\")\n        res = {'status': 'success'}\n    return res, python, venv_site_pkgs, venv_dir"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def install_update(filename, loop):\n    log.info(\"Installing update server into system environment\")\n    log.debug('File {} exists? {}'.format(filename, os.path.exists(filename)))\n    out, err, returncode = await _install(sys.executable, filename, loop)\n    if returncode == 0:\n        msg = out\n    else:\n        msg = err\n    res = {'message': msg, 'filename': filename}\n    return res, returncode", "response": "Install the update into the system environment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef solve(expected: List[Tuple[float, float]],\n          actual: List[Tuple[float, float]]) -> np.ndarray:\n    \"\"\"\n    Takes two lists of 3 x-y points each, and calculates the matrix\n    representing the transformation from one space to the other.\n\n    The 3x3 matrix returned by this method represents the 2-D transformation\n    matrix from the actual point to the expected point.\n\n    Example:\n        If the expected points are:\n            [ (1, 1),\n              (2, 2),\n              (1, 2) ]\n        And the actual measured points are:\n            [ (1.1, 1.1),\n              (2.1, 2.1),\n              (1.1, 2.1) ]\n        (in other words, a shift of exaxtly +0.1 in both x and y)\n\n        Then the resulting transformation matrix T should be:\n            [ 1  0  -0.1 ]\n            [ 0  1  -0.1 ]\n            [ 0  0   1   ]\n\n        Then, if we take a 3x3 matrix B representing one of the measured points\n        on the deck:\n            [ 1  0  1.1 ]\n            [ 0  1  2.1 ]\n            [ 0  0  1   ]\n\n        The B*T will yeild the \"actual\" point:\n            [ 1  0  1 ]\n            [ 0  1  2 ]\n            [ 0  0  1 ]\n\n        The return value of this function is the transformation matrix T\n    \"\"\"\n    # Note: input list shape validation is handled by the type checker\n\n    # Turn expected and actual matricies into numpy ndarrays with the last row\n    # of [1 1 1] appended, and then take the dot product of the resulting\n    # actual matrix with the inverse of the resulting expected matrix.\n\n    # Shape of `expected` and `actual`:\n    # [ (x1, y1),\n    #   (x2, y2),\n    #   (x3, y3) ]\n    ex = np.array([\n            list(point) + [1]\n            for point in expected\n        ]).transpose()\n\n    ac = np.array([\n            list(point) + [1]\n            for point in actual\n        ]).transpose()\n    # Shape of `ex` and `ac`:\n    # [ x1 x2 x3 ]\n    # [ y1 y2 y3 ]\n    # [  1  1  1 ]\n\n    transform = np.dot(ac, inv(ex))\n    # `dot` in numpy is a misnomer. When both arguments are square, N-\n    # dimensional arrays, the return type is the result of performing matrix\n    # multiplication, rather than the dot-product (so the return here will be\n    # a 4x4 matrix)\n    return transform", "response": "This method solves the actual and expected matrix of a single language language."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a z component to the base 2 - D transform matrix.", "response": "def add_z(xy: np.ndarray, z: float) -> np.ndarray:\n    \"\"\"\n    Turn a 2-D transform matrix into a 3-D transform matrix (scale/shift only,\n    no rotation).\n\n    :param xy: A two-dimensional transform matrix (a 3x3 numpy ndarray) in the\n        following form:\n            [ 1  0  x ]\n            [ 0  1  y ]\n            [ 0  0  1 ]\n    :param z: a float for the z component\n    :return: a three-dimensional transformation matrix (a 4x4 numpy ndarray)\n        with x, y, and z from the function parameters, in the following form:\n            [ 1  0  0  x ]\n            [ 0  1  0  y ]\n            [ 0  0  1  z ]\n            [ 0  0  0  1 ]\n    \"\"\"\n    # First, insert a column of zeros as into the input matrix\n    interm = insert(xy, 2, [0, 0, 0], axis=1)\n    # Result:\n    # [ 1  0  0  x ]\n    # [ 0  1  0  y ]\n    # [ 0  0  0  1 ]\n\n    # Then, insert the z row to create a properly formed 3-D transform matrix:\n    xyz = insert(\n        interm,\n        2,\n        [0, 0, 1, z],\n        axis=0)\n    # Result:\n    # [ 1  0  0  x ]\n    # [ 0  1  0  y ]\n    # [ 0  0  1  z ]\n    # [ 0  0  0  1 ]\n\n    return xyz.round(11)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply_reverse(\n        t: Union[List[List[float]], np.ndarray],\n        pos: Tuple[float, float, float],\n        with_offsets=True) -> Tuple[float, float, float]:\n    \"\"\" Like apply_transform but inverts the transform first\n    \"\"\"\n    return apply_transform(inv(t), pos)", "response": "Like apply_transform but inverts the transform first\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reset():\n    if os.path.exists(database_path):\n        os.remove(database_path)\n    # Not an os.path.join because it is a suffix to the full filename\n    journal_path = database_path + '-journal'\n    if os.path.exists(journal_path):\n        os.remove(journal_path)", "response": "Unmount and remove the sqlite database"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwait and execute the restart.", "response": "def __wait_and_restart():\n    \"\"\" Delay and then execute the restart. Do not call directly. Instead, call\n    `do_restart()`.\n    \"\"\"\n    log.info('Restarting server')\n    sleep(1)\n    # We can use the default event loop here because this\n    # is actually running in a thread. We use aiohttp here because urllib is\n    # painful and we don\u2019t have `requests`.\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(_resin_supervisor_restart())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute a container restart by requesting it from the supervisor.", "response": "async def _resin_supervisor_restart():\n    \"\"\" Execute a container restart by requesting it from the supervisor.\n\n    Note that failures here are returned but most likely will not be\n    sent back to the caller, since this is run in a separate workthread.\n    If the system is not responding, look for these log messages.\n    \"\"\"\n    supervisor = os.environ.get('RESIN_SUPERVISOR_ADDRESS',\n                                'http://127.0.0.1:48484')\n    restart_url = supervisor + '/v1/restart'\n    api = os.environ.get('RESIN_SUPERVISOR_API_KEY', 'unknown')\n    app_id = os.environ.get('RESIN_APP_ID', 'unknown')\n    async with aiohttp.ClientSession() as session:\n        async with session.post(restart_url,\n                                params={'apikey': api},\n                                json={'appId': app_id,\n                                      'force': True}) as resp:\n            body = await resp.read()\n            if resp.status != 202:\n                log.error(\"Could not shut down: {}: {}\"\n                          .format(resp.status, body))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self, port: str = None,\n                options: Any = None):\n        \"\"\" Connect to the robot hardware.\n\n        This function is provided for backwards compatibility. In most cases\n        it need not be called.\n\n        Calls to this method should be replaced with calls to\n        :py:meth:`.ProtocolContext.connect` (notice the difference in\n        arguments) if necessary; however, since the context of protocols\n        executed by an OT2 is automatically connected to either the hardware or\n        a simulator (depending on whether the protocol is being simulated or\n        run) this should be unnecessary.\n\n        :param port: The port to connect to the smoothie board or the magic\n                     string ``\"Virtual Smoothie\"``, which will initialize and\n                     connect to a simulator\n        :param options: Ignored.\n        \"\"\"\n        self._hardware.connect(port)", "response": "Connect to the robot hardware."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _build_initializer(model, proper_name):\n        def initializer(\n                self,\n                mount: str,\n                trash_container: Labware = None,\n                tip_racks: List[Labware] = None,\n                aspirate_flow_rate: float = None,\n                dispense_flow_rate: float = None,\n                min_volume: float = None,\n                max_volume: float = None) -> InstrumentContext:\n            return AddInstrumentCtors._load_instr(self._ctx,\n                                                  model,\n                                                  mount)\n        initializer.__name__ = proper_name\n        initializer.__qualname__ = '.'.join([AddInstrumentCtors.__qualname__,\n                                             proper_name])\n        initializer.__doc__ = \\\n            \"\"\"Build a {} in a backwards-compatible way.\n\n            :param mount: The mount to load the instrument. One of\n                          `'left'` or `'right'`.\n            :param trash_container: If specified, a :py:class:`.Labware` to\n                                    use for trash.\n            :param tip_racks: If specified, a list of :py:class:`.Labware`\n                              containing tips.\n            :param aspirate_flow_rate: If specified, a flow rate (in uL/s)\n                                       to use when aspirating. By default,\n                                       the value from the pipette's\n                                       configuration.\n            :param dispense_flow_rate: If specified, a flow rate (in uL/s)\n                                       to use when dispensing. By default,\n                                       the value from the pipette's\n                                       configuration.\n            :param min_volume: The minimum volume that can be aspirated at\n                               once. By default, the pipette's minimum\n                               volume.\n            :param max_volume: The maximum volume that can be aspirated at\n                               once. By default, the pipette's maximum\n                               volume.\n\n            :returns: An :py:class:`.InstrumentContext`, which represents\n                      the newly-loaded pipette.\n            \"\"\".format(' '.join(proper_name.split('_')))\n        return initializer", "response": "Build an initializer function for a given pipette."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _load_instr(ctx,\n                    name: str,\n                    mount: str,\n                    *args, **kwargs) -> InstrumentContext:\n        \"\"\" Build an instrument in a backwards-compatible way.\n\n        You should almost certainly not be calling this function from a\n        protocol; if you want to create a pipette on a lower level, use\n        :py:meth:`.ProtocolContext.load_instrument` directly, and if you\n        want to create an instrument easily use one of the partials below.\n        \"\"\"\n        return ctx.load_instrument(name, Mount[mount.upper()])", "response": "Build an instrument from a backwards - compatible way."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self, container_name, slot, label=None, share=False):\n        if share:\n            raise NotImplementedError(\"Sharing not supported\")\n\n        try:\n            name = self.LW_TRANSLATION[container_name]\n        except KeyError:\n            if container_name in self.LW_NO_EQUIVALENT:\n                raise NotImplementedError(\"Labware {} is not supported\"\n                                          .format(container_name))\n            elif container_name in ('magdeck', 'tempdeck'):\n                raise NotImplementedError(\"Module load not yet implemented\")\n            else:\n                name = container_name\n\n        return self._ctx.load_labware_by_name(name, slot, label)", "response": "Load a piece of labware by specifying its name and position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dump_br_version(project):\n    normalized = get_version(project)\n    sha = subprocess.check_output(\n        ['git', 'rev-parse', 'HEAD'], cwd=HERE).strip()\n    branch = subprocess.check_output(\n        ['git', 'rev-parse', '--abbrev-ref', 'HEAD'], cwd=HERE).strip()\n    pref = br_version_prefixes[project]\n    return json.dumps({pref+'_version': normalized,\n                       pref+'_sha': sha,\n                       pref+'_branch': branch})", "response": "Dump an enhanced version json including the current branch and sha"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset flow rate in uL / mm to value obtained from command s params and protocol s default - values.", "response": "def _set_flow_rate(\n        pipette_name, pipette, command_type, params, default_values):\n    \"\"\"\n    Set flow rate in uL/mm, to value obtained from command's params,\n    or if unspecified in command params, then from protocol's \"default-values\".\n    \"\"\"\n    default_aspirate = default_values.get(\n        'aspirate-flow-rate', {}).get(pipette_name)\n\n    default_dispense = default_values.get(\n        'dispense-flow-rate', {}).get(pipette_name)\n\n    flow_rate_param = params.get('flow-rate')\n\n    if flow_rate_param is not None:\n        if command_type == 'aspirate':\n            pipette.flow_rate = {\n                'aspirate': flow_rate_param,\n                'dispense': default_dispense\n            }\n            return\n        if command_type == 'dispense':\n            pipette.flow_rate = {\n                'aspirate': default_aspirate,\n                'dispense': flow_rate_param\n            }\n            return\n\n    pipette.flow_rate = {\n        'aspirate': default_aspirate,\n        'dispense': default_dispense\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build(cls, builder, *args, build_loop=None, **kwargs):\n        loop = asyncio.new_event_loop()\n        kwargs['loop'] = loop\n        args = [arg for arg in args\n                if not isinstance(arg, asyncio.AbstractEventLoop)]\n        if asyncio.iscoroutinefunction(builder):\n            checked_loop = build_loop or asyncio.get_event_loop()\n            api = checked_loop.run_until_complete(builder(*args, **kwargs))\n        else:\n            api = builder(*args, **kwargs)\n        return cls(api, loop)", "response": "Build a hardware control API and initialize the adapter in one call\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconnects to hardware. :param port: The port to connect to. May be `None`, in which case the hardware will connect to the first serial port it sees with the device name `FT232R`; or port name compatible with `serial.Serial<https://pythonhosted.org/pyserial/pyserial_api.html#serial.Serial.__init__>`_. # noqa(E501) :param force: If `True`, connect even if a lockfile is established. See :py:meth:`.controller.Controller.__init__`. This should only ever be specified as `True` by the main software starting.", "response": "def connect(self, port: str = None, force: bool = False):\n        \"\"\" Connect to hardware.\n\n        :param port: The port to connect to. May be `None`, in which case the\n                     hardware will connect to the first serial port it sees\n                     with the device name `FT232R`; or port name compatible\n                     with `serial.Serial<https://pythonhosted.org/pyserial/pyserial_api.html#serial.Serial.__init__>`_.  # noqa(E501)\n        :param force: If `True`, connect even if a lockfile is established. See\n                      :py:meth:`.controller.Controller.__init__`. This should\n                      only ever be specified as `True` by the main software\n                      starting.\n        \"\"\"\n        old_api = object.__getattribute__(self, '_api')\n        loop = old_api._loop\n        new_api = loop.run_until_complete(API.build_hardware_controller(\n            loop=loop,\n            port=port,\n            config=copy.copy(old_api.config),\n            force=force))\n        old_api._loop.run_until_complete(new_api.cache_instruments())\n        setattr(self, '_api', new_api)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisconnecting from connected hardware.", "response": "def disconnect(self):\n        \"\"\" Disconnect from connected hardware. \"\"\"\n        old_api = object.__getattribute__(self, '_api')\n        new_api = API.build_hardware_simulator(\n            loop=old_api._loop,\n            config=copy.copy(old_api.config))\n        setattr(self, '_api', new_api)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_attached_pipettes(self):\n        api = object.__getattribute__(self, '_api')\n        instrs = {}\n        for mount, data in api.attached_instruments.items():\n            instrs[mount.name.lower()] = {\n                'model': data.get('name', None),\n                'id': data.get('pipette_id', None),\n                'mount_axis': Axis.by_mount(mount),\n                'plunger_axis': Axis.of_plunger(mount)\n            }\n            if data.get('name'):\n                instrs[mount.name.lower()]['tip_length'] \\\n                    = data.get('tip_length', None)\n\n        return instrs", "response": "Mimic the behavior of robot. get_attached_pipettes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unzip_update(filepath: str,\n                 progress_callback: Callable[[float], None],\n                 acceptable_files: Sequence[str],\n                 mandatory_files: Sequence[str],\n                 chunk_size: int = 1024) -> Tuple[Mapping[str, Optional[str]],\n                                                  Mapping[str, int]]:\n    \"\"\" Unzip an update file\n\n    The update file must contain\n\n    - a file called rootfs.ext4\n    - a file called rootfs.ext4.hash\n\n    It may contain\n\n    - a file called rootfs.ext4.hash.sig\n\n    These will all be unzipped (discarding their leading directories) to\n    the same file as the zipfile.\n\n    This function is blocking and takes a while. It calls ``progress_callback``\n    to indicate update progress with a number between 0 and 1 indicating\n    overall archive unzip progress.\n\n    :param filepath: The path zipfile to unzip. The contents will be in its\n                     directory\n    :param progress_callback: A callable taking a number between 0 and 1 that\n                              will be called periodically to check progress.\n                              This is for user display; it may not reach 1.0\n                              exactly.\n    :param acceptable_files: A list of files to unzip if found. Others will be\n                             ignored.\n    :param mandatory_files: A list of files to raise an error about if they're\n                            not in the zip. Should probably be a subset of\n                            ``acceptable_files``.\n    :param chunk_size: If specified, the size of the chunk to read and write.\n                       If not specified, will default to 1024\n    :return: Two dictionaries, the first mapping file names to paths and the\n             second mapping file names to sizes\n\n    :raises FileMissing: If a mandatory file is missing\n    \"\"\"\n    assert chunk_size\n    total_size = 0\n    written_size = 0\n    to_unzip: List[zipfile.ZipInfo] = []\n    file_paths: Dict[str, Optional[str]] = {fn: None\n                                            for fn in acceptable_files}\n    file_sizes: Dict[str, int] = {fn: 0 for fn in acceptable_files}\n    LOG.info(f\"Unzipping {filepath}\")\n    with zipfile.ZipFile(filepath, 'r') as zf:\n        files = zf.infolist()\n        remaining_filenames = [fn for fn in acceptable_files]\n        for fi in files:\n            if fi.filename in acceptable_files:\n                to_unzip.append(fi)\n                total_size += fi.file_size\n                remaining_filenames.remove(fi.filename)\n                LOG.debug(f\"Found {fi.filename} ({fi.file_size}B)\")\n            else:\n                LOG.debug(f\"Ignoring {fi.filename}\")\n\n        for name in remaining_filenames:\n            if name in mandatory_files:\n                raise FileMissing(f'File {name} missing from zip')\n\n        for fi in to_unzip:\n            uncomp_path = os.path.join(os.path.dirname(filepath), fi.filename)\n            with zf.open(fi) as zipped, open(uncomp_path, 'wb') as unzipped:\n                LOG.debug(f\"Beginning unzip of {fi.filename} to {uncomp_path}\")\n                while True:\n                    chunk = zipped.read(chunk_size)\n                    unzipped.write(chunk)\n                    written_size += len(chunk)\n                    progress_callback(written_size/total_size)\n                    if len(chunk) != chunk_size:\n                        break\n                file_paths[fi.filename] = uncomp_path\n                file_sizes[fi.filename] = fi.file_size\n                LOG.debug(f\"Unzipped {fi.filename} to {uncomp_path}\")\n    LOG.info(\n        f\"Unzipped {filepath}, results: \\n\\t\" + '\\n\\t'.join(\n            [f'{k}: {file_paths[k]} ({file_sizes[k]}B)'\n             for k in file_paths.keys()]))\n    return file_paths, file_sizes", "response": "Unzip an update file into a single dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhashes a file and returns the hash", "response": "def hash_file(path: str,\n              progress_callback: Callable[[float], None],\n              chunk_size: int = 1024,\n              file_size: int = None,\n              algo: str = 'sha256') -> bytes:\n    \"\"\"\n    Hash a file and return the hash, providing progress callbacks\n\n    :param path: The file to hash\n    :param progress_callback: The callback to call with progress between 0 and\n                              1. May not ever be precisely 1.0.\n    :param chunk_size: If specified, the size of the chunks to hash in one call\n                       If not specified, defaults to 1024\n    :param file_size: If specified, the size of the file to hash (used for\n                      progress callback generation). If not specified,\n                      calculated internally.\n    :param algo: The algorithm to use. Can be anything used by\n                 :py:mod:`hashlib`\n    :returns: The output has ascii hex\n    \"\"\"\n    hasher = hashlib.new(algo)\n    have_read = 0\n    if not chunk_size:\n        chunk_size = 1024\n    with open(path, 'rb') as to_hash:\n        if not file_size:\n            file_size = to_hash.seek(0, 2)\n            to_hash.seek(0)\n        while True:\n            chunk = to_hash.read(chunk_size)\n            hasher.update(chunk)\n            have_read += len(chunk)\n            progress_callback(have_read/file_size)\n            if len(chunk) != chunk_size:\n                break\n    return binascii.hexlify(hasher.digest())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nverifying the signature of a message file.", "response": "def verify_signature(message_path: str,\n                     sigfile_path: str,\n                     cert_path: str) -> None:\n    \"\"\"\n    Verify the signature (assumed, of the hash file)\n\n    It is assumed that the public key for the signature is in the keyring\n\n    :param message_path: The path to the message file to check\n    :param sigfile_path: The path to the signature to check\n    :param cert_path: The path to the certificate to check the signature with\n    :returns True: If the signature verifies\n    :raises SignatureMismatch: If the signature does not verify\n    \"\"\"\n    with tempfile.TemporaryDirectory() as pubkey_dir:\n        pubkey_contents = subprocess.check_output(\n            ['openssl', 'x509', '-in', cert_path,\n             '-pubkey', '-noout'])\n        pubkey_file = os.path.join(pubkey_dir, 'pubkey')\n        open(pubkey_file, 'wb').write(pubkey_contents)\n        try:\n            verification = subprocess.check_output(\n                ['openssl', 'dgst', '-sha256', '-verify', pubkey_file,\n                 '-signature', sigfile_path, message_path],\n                stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as cpe:\n            verification = cpe.output\n\n    if verification.strip() == b'Verified OK':\n        LOG.info(f\"Verification passed from cert {cert_path}\")\n    else:\n        LOG.error(\n            f\"Verification failed with cert {cert_path}: {verification}\")\n        raise SignatureMismatch(f'Signature check failed')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_update(filepath: str,\n                    progress_callback: Callable[[float], None],\n                    cert_path: Optional[str]):\n    \"\"\" Worker for validation. Call in an executor (so it can return things)\n\n    - Unzips filepath to its directory\n    - Hashes the rootfs inside\n    - If requested, checks the signature of the hash\n    :param filepath: The path to the update zip file\n    :param progress_callback: The function to call with progress between 0\n                              and 1.0. May never reach precisely 1.0, best\n                              only for user information\n    :param cert_path: Path to an x.509 certificate to check the signature\n                      against. If ``None``, signature checking is disabled\n    :returns str: Path to the rootfs file to update\n\n    Will also raise an exception if validation fails\n    \"\"\"\n\n    def zip_callback(progress):\n        progress_callback(progress/2.0)\n\n    required = [ROOTFS_NAME, ROOTFS_HASH_NAME]\n    if cert_path:\n        required.append(ROOTFS_SIG_NAME)\n    files, sizes = unzip_update(filepath, zip_callback,\n                                UPDATE_FILES,\n                                required)\n\n    def hash_callback(progress):\n        progress_callback(progress/2.0 + 0.5)\n    rootfs = files.get(ROOTFS_NAME)\n    assert rootfs\n    rootfs_hash = hash_file(rootfs,\n                            hash_callback,\n                            file_size=sizes[ROOTFS_NAME])\n    hashfile = files.get(ROOTFS_HASH_NAME)\n    assert hashfile\n    packaged_hash = open(hashfile, 'rb').read().strip()\n    if packaged_hash != rootfs_hash:\n        msg = f\"Hash mismatch: calculated {rootfs_hash} != \"\\\n            f\"packaged {packaged_hash}\"\n        LOG.error(msg)\n        raise HashMismatch(msg)\n\n    if cert_path:\n        sigfile = files.get(ROOTFS_SIG_NAME)\n        assert sigfile\n        verify_signature(hashfile, sigfile, cert_path)\n\n    return rootfs", "response": "Validate the update file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding the currently - unused root partition to write to.", "response": "def _find_unused_partition() -> RootPartitions:\n    \"\"\" Find the currently-unused root partition to write to \"\"\"\n    which = subprocess.check_output(['ot-unused-partition']).strip()\n    return {b'2': RootPartitions.TWO,\n            b'3': RootPartitions.THREE}[which]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites a file to another file with progress callbacks.", "response": "def write_file(infile: str,\n               outfile: str,\n               progress_callback: Callable[[float], None],\n               chunk_size: int = 1024,\n               file_size: int = None):\n    \"\"\" Write a file to another file with progress callbacks.\n\n    :param infile: The input filepath\n    :param outfile: The output filepath\n    :param progress_callback: The callback to call for progress\n    :param chunk_size: The size of file chunks to copy in between progress\n                       notifications\n    :param file_size: The total size of the update file (for generating\n                      progress percentage). If ``None``, generated with\n                      ``seek``/``tell``.\n    \"\"\"\n    total_written = 0\n    with open(infile, 'rb') as img, open(outfile, 'wb') as part:\n        if None is file_size:\n            file_size = img.seek(0, 2)\n            img.seek(0)\n            LOG.info(f'write_file: file size calculated as {file_size}B')\n        LOG.info(f'write_file: writing {infile} ({file_size}B)'\n                 f' to {outfile} in {chunk_size}B chunks')\n        while True:\n            chunk = img.read(chunk_size)\n            part.write(chunk)\n            total_written += len(chunk)\n            progress_callback(total_written / file_size)\n            if len(chunk) != chunk_size:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_update(rootfs_filepath: str,\n                 progress_callback: Callable[[float], None],\n                 chunk_size: int = 1024,\n                 file_size: int = None) -> RootPartitions:\n    \"\"\"\n    Write the new rootfs to the next root partition\n\n    - Figure out, from the system, the correct root partition to write to\n    - Write the rootfs at ``rootfs_filepath`` there, with progress\n\n    :param rootfs_filepath: The path to a checked rootfs.ext4\n    :param progress_callback: A callback to call periodically with progress\n                              between 0 and 1.0. May never reach precisely\n                              1.0, best only for user information.\n    :param chunk_size: The size of file chunks to copy in between progress\n                       notifications\n    :param file_size: The total size of the update file (for generating\n                      progress percentage). If ``None``, generated with\n                      ``seek``/``tell``.\n    :returns: The root partition that the rootfs image was written to, e.g.\n              ``RootPartitions.TWO`` or ``RootPartitions.THREE``.\n    \"\"\"\n    unused = _find_unused_partition()\n    part_path = unused.value.path\n    write_file(rootfs_filepath, part_path, progress_callback,\n               chunk_size, file_size)\n    return unused", "response": "Writes the new rootfs to the next root partition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nswitch the active boot partition using the switch script", "response": "def _switch_partition() -> RootPartitions:\n    \"\"\" Switch the active boot partition using the switch script \"\"\"\n    res = subprocess.check_output(['ot-switch-partitions'])\n    for line in res.split(b'\\n'):\n        matches = re.match(\n            b'Current boot partition: ([23]), setting to ([23])',\n            line)\n        if matches:\n            return {b'2': RootPartitions.TWO,\n                    b'3': RootPartitions.THREE}[matches.group(2)]\n    else:\n        raise RuntimeError(f'Bad output from ot-switch-partitions: {res}')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef commit_update():\n    unused = _find_unused_partition()\n    new = _switch_partition()\n    if new != unused:\n        msg = f\"Bad switch: switched to {new} when {unused} was unused\"\n        LOG.error(msg)\n        raise RuntimeError(msg)\n    else:\n        LOG.info(f'commit_update: committed to booting {new}')", "response": "Switch the target boot partition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nunpack a location into a tuple of Placeable and Vector objects.", "response": "def unpack_location(location):\n    \"\"\"\n    Returns (:Placeable:, :Vector:) tuple\n\n    If :location: is :Placeable: it will get converted to\n    (:Placeable:, :Vector: corresponding to the top)\n    \"\"\"\n    coordinates = None\n    placeable = None\n    if isinstance(location, Placeable):\n        placeable, coordinates = location.top()\n\n    elif isinstance(location, tuple):\n        placeable, coordinates = location\n\n    else:\n        raise ValueError(\n            'Location should be (Placeable, (x, y, z)) or Placeable'\n        )\n    return (placeable, Vector(coordinates))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of names from reference to self", "response": "def get_path(self, reference=None):\n        \"\"\"\n        Returns list of names from :reference: to :self:\n        If :reference: is *None* root is assumed\n        \"\"\"\n        return list(reversed([item.get_name()\n                              for item in self.get_trace(reference)\n                              if item.get_name() is not None]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an iterator of the trace items of the current object.", "response": "def get_trace(self, reference=None):\n        \"\"\"\n        Returns a generator of parents up to :reference:, including reference\n        If :reference: is *None* root is assumed\n        Closest ancestor goes first\n        \"\"\"\n        item = self\n        while item:\n            yield item\n            if item == reference:\n                return\n            item = item.parent\n\n        if reference is not None:\n            raise Exception(\n                'Reference {} is not in Ancestry'.format(reference))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef coordinates(self, reference=None):\n        coordinates = [i._coordinates for i in self.get_trace(reference)]\n        return functools.reduce(lambda a, b: a + b, coordinates)", "response": "Returns the list of coordinates of a : Placeable relative to the reference."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, child, name=None, coordinates=None):\n        if not name:\n            name = str(child)\n\n        if name in self.children_by_name:\n            raise RuntimeWarning(\n                'Child with name {} already in slot, use custom name'.format(\n                    name))\n\n        if coordinates:\n            child._coordinates = Vector(coordinates)\n        child.parent = self\n        self.children_by_name[name] = child\n        self.children_by_reference[child] = name", "response": "Adds a child to the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn parent deck of a Placeable", "response": "def get_deck(self):\n        \"\"\"\n        Returns parent :Deck: of a :Placeable:\n        \"\"\"\n        trace = self.get_trace()\n\n        # Find decks in trace, prepend with [None] in case nothing was found\n        res = [None] + [item for item in trace if isinstance(item, Deck)]\n\n        # Pop last (and hopefully only Deck) or None if there is no deck\n        return res.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the module that has at least one child.", "response": "def get_module(self):\n        \"\"\"\n        Returns the module placeable if present\n        \"\"\"\n        for md in SUPPORTED_MODULES:\n            maybe_module = self.get_child_by_name(md)\n            if maybe_module:\n                # No probability of a placeable having more than one module\n                return maybe_module\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve list of children within slice", "response": "def get_children_from_slice(self, s):\n        \"\"\"\n        Retrieves list of children within slice\n        \"\"\"\n        if isinstance(s.start, str):\n            s = slice(\n                self.get_index_from_name(s.start), s.stop, s.step)\n        if isinstance(s.stop, str):\n            s = slice(\n                s.start, self.get_index_from_name(s.stop), s.step)\n        return WellSeries(self.get_children_list()[s])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns all children of this instance recursively", "response": "def get_all_children(self):\n        \"\"\"\n        Returns all children recursively\n        \"\"\"\n        my_children = self.get_children_list()\n        children = []\n        children.extend(my_children)\n        for child in my_children:\n            children.extend(child.get_all_children())\n        return children"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting polar coordinates within a placeable into a Vector", "response": "def from_polar(self, r, theta, h):\n        \"\"\"\n        Converts polar coordiantes within a placeable into a :Vector:\n\n        The origin is assumed to be in the center of a Placeable\n\n        :r: is between -1.0 and 1.0, relative to max X\n        :h: is between -1.0 and 1.0, relative to max Z\n        \"\"\"\n        center = self.size() / 2.0\n        r = r * center['x']\n\n        return center + Vector(r * math.cos(theta),\n                               r * math.sin(theta),\n                               center['z'] * h)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting cartesian coordinates within a placeable into a Vector", "response": "def from_cartesian(self, x, y, z):\n        \"\"\"\n        Converts cartesian coordinates within a placeable into a :Vector:\n\n        The origin is assumed to be in the center of a Placeable\n\n        :x:, :y:, :z: is between -1.0 and 1.0, relative to max X, Y, Z\n        \"\"\"\n        center = self.size() / 2.0\n        return center + center * Vector(x, y, z)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a Vector of the center of the current object", "response": "def center(self, reference=None):\n        \"\"\"\n        Returns :Vector: of the center for a :Placeable: relative\n        to the :reference: :Placeable:\n\n        Uses self as a :reference: if *None* is given\n        \"\"\"\n        return self.from_center(x=0.0, y=0.0, z=0.0, reference=reference)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a tuple where the first element corresponds to the bottom of a loci.", "response": "def bottom(self, z=0, radius=0, degrees=0, reference=None):\n        \"\"\"\n        Returns (:Placeable, :Vector:) tuple where :Vector:\n        corresponds to the bottom of a :Placeable:\n\n        If :reference: :Placeable: is provided, returns\n        the :Vector: within :reference: coordinate system\n        \"\"\"\n        coordinates = self.from_center(\n            r=radius,\n            theta=(degrees / 180) * math.pi,\n            h=-1,\n            reference=reference)\n        return (self, coordinates + (0, 0, z))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a Vector object representing the center of the object.", "response": "def from_center(self, x=None, y=None, z=None, r=None,\n                    theta=None, h=None, reference=None):\n        \"\"\"\n        Accepts a set of (:x:, :y:, :z:) ratios for Cartesian or\n        (:r:, :theta:, :h:) rations/angle for Polar and returns\n        :Vector: using :reference: as origin\n        \"\"\"\n        coords_to_endpoint = None\n        if all([isinstance(i, numbers.Number) for i in (x, y, z)]):\n            coords_to_endpoint = self.from_cartesian(x, y, z)\n\n        if all([isinstance(i, numbers.Number) for i in (r, theta, h)]):\n            coords_to_endpoint = self.from_polar(r, theta, h)\n\n        coords_to_reference = Vector(0, 0, 0)\n        if reference:\n            coords_to_reference = self.coordinates(reference)\n\n        return coords_to_reference + coords_to_endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef containers(self) -> list:\n\n        all_containers: List = list()\n        for slot in self:\n            all_containers += slot.get_children_list()\n\n        for container in all_containers:\n            if getattr(container, 'stackable', False):\n                all_containers += container.get_children_list()\n\n        return all_containers", "response": "Returns all containers on a deck as a list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating and stores grid structure for the current object.", "response": "def calculate_grid(self):\n        \"\"\"\n        Calculates and stores grid structure\n        \"\"\"\n        if self.grid is None:\n            self.grid = self.get_wellseries(self.get_grid())\n\n        if self.grid_transposed is None:\n            self.grid_transposed = self.get_wellseries(\n                self.transpose(\n                    self.get_grid()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_grid(self):\n        columns = OrderedDict()\n\n        index_pattern = r'^([A-Za-z]+)([0-9]+)$'\n        for name in self.children_by_name:\n            match = re.match(index_pattern, name)\n            if match:\n                row, col = match.groups(0)\n                if col not in columns:\n                    columns[col] = OrderedDict()\n                columns[col][row] = (row, col)\n\n        return columns", "response": "Calculates the grid inferring row and column structure\n        from indexes. Currently only Letter + Number names are supported. Currently only Letter + Number names are supported."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntransposes the grid to allow for cols COOKIE", "response": "def transpose(self, rows):\n        \"\"\"\n        Transposes the grid to allow for cols\n        \"\"\"\n        res = OrderedDict()\n        for row, cols in rows.items():\n            for col, cell in cols.items():\n                if col not in res:\n                    res[col] = OrderedDict()\n                res[col][row] = cell\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the grid as a WellSeries of WellSeries", "response": "def get_wellseries(self, matrix):\n        \"\"\"\n        Returns the grid as a WellSeries of WellSeries\n        \"\"\"\n        res = OrderedDict()\n        for col, cells in matrix.items():\n            if col not in res:\n                res[col] = OrderedDict()\n            for row, cell in cells.items():\n                res[col][row] = self.children_by_name[\n                    ''.join(cell)\n                ]\n            res[col] = WellSeries(res[col], name=col)\n        return WellSeries(res)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wells(self, *args, **kwargs):\n\n        if len(args) and isinstance(args[0], list):\n            args = args[0]\n\n        new_wells = None\n        if not args and not kwargs:\n            new_wells = WellSeries(self.get_children_list())\n        elif len(args) > 1:\n            new_wells = WellSeries([self.well(n) for n in args])\n        elif 'x' in kwargs or 'y' in kwargs:\n            new_wells = self._parse_wells_x_y(*args, **kwargs)\n        else:\n            new_wells = self._parse_wells_to_and_length(*args, **kwargs)\n\n        if len(new_wells) == 1:\n            return new_wells[0]\n        return new_wells", "response": "Returns child Well or list of child Wells"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_string_value_from_substring(substring) -> str:\n    '''\n    Returns the ascii value in the expected string \"N:aa11bb22\", where \"N\" is\n    the key, and \"aa11bb22\" is string value to be returned\n    '''\n    try:\n        value = substring.split(':')[1]\n        return str(value)\n    except (ValueError, IndexError, TypeError, AttributeError):\n        log.exception('Unexpected arg to parse_string_value_from_substring:')\n        raise ParseError(\n            'Unexpected arg to parse_string_value_from_substring: {}'.format(\n                substring))", "response": "Parses a substring into a string value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_number_from_substring(substring) -> Optional[float]:\n    '''\n    Returns the number in the expected string \"N:12.3\", where \"N\" is the\n    key, and \"12.3\" is a floating point value\n\n    For the temp-deck or thermocycler's temperature response, one expected\n    input is something like \"T:none\", where \"none\" should return a None value\n    '''\n    try:\n        value = substring.split(':')[1]\n        if value.strip().lower() == 'none':\n            return None\n        return round(float(value), GCODE_ROUNDING_PRECISION)\n    except (ValueError, IndexError, TypeError, AttributeError):\n        log.exception('Unexpected argument to parse_number_from_substring:')\n        raise ParseError(\n            'Unexpected argument to parse_number_from_substring: {}'.format(\n                substring))", "response": "Parses a substring into a number in the expected string N : 12. 3."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_temperature_response(\n        temperature_string: str) -> Mapping[str, Optional[float]]:\n    '''\n    Example input: \"T:none C:25\"\n    '''\n    err_msg = 'Unexpected argument to parse_temperature_response: {}'.format(\n        temperature_string)\n    if not temperature_string or \\\n            not isinstance(temperature_string, str):\n        raise ParseError(err_msg)\n    parsed_values = temperature_string.strip().split(' ')\n    if len(parsed_values) < 2:\n        log.error(err_msg)\n        raise ParseError(err_msg)\n\n    data = {\n        parse_key_from_substring(s): parse_number_from_substring(s)\n        for s in parsed_values[:2]\n    }\n    if 'C' not in data or 'T' not in data:\n        raise ParseError(err_msg)\n    data = {\n        'current': data['C'],\n        'target': data['T']\n    }\n    return data", "response": "Parse the response from the get_temperature function."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the modules s device information response.", "response": "def parse_device_information(\n        device_info_string: str) -> Mapping[str, str]:\n    '''\n        Parse the modules's device information response.\n\n        Example response from temp-deck: \"serial:aa11 model:bb22 version:cc33\"\n    '''\n    error_msg = 'Unexpected argument to parse_device_information: {}'.format(\n        device_info_string)\n    if not device_info_string or \\\n            not isinstance(device_info_string, str):\n        raise ParseError(error_msg)\n    parsed_values = device_info_string.strip().split(' ')\n    if len(parsed_values) < 3:\n        log.error(error_msg)\n        raise ParseError(error_msg)\n    res = {\n        parse_key_from_substring(s): parse_string_value_from_substring(s)\n        for s in parsed_values[:3]\n    }\n    for key in ['model', 'version', 'serial']:\n        if key not in res:\n            raise ParseError(error_msg)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsimulates the Opentrons protocol from the given file.", "response": "def simulate(protocol_file,\n             propagate_logs=False,\n             log_level='warning') -> List[Mapping[str, Any]]:\n    \"\"\"\n    Simulate the protocol itself.\n\n    This is a one-stop function to simulate a protocol, whether python or json,\n    no matter the api version, from external (i.e. not bound up in other\n    internal server infrastructure) sources.\n\n    To simulate an opentrons protocol from other places, pass in a file like\n    object as protocol_file; this function either returns (if the simulation\n    has no problems) or raises an exception.\n\n    To call from the command line use either the autogenerated entrypoint\n    ``opentrons_simulate`` (``opentrons_simulate.exe``, on windows) or\n    ``python -m opentrons.simulate``.\n\n    The return value is the run log, a list of dicts that represent the\n    commands executed by the robot. Each dict has the following keys:\n\n        - ``level``: The depth at which this command is nested - if this an\n                     aspirate inside a mix inside a transfer, for instance,\n                     it would be 3.\n        - ``payload``: The command, its arguments, and how to format its text.\n                       For more specific details see\n                       :py:mod:`opentrons.commands`. To format a message from\n                       a payload do ``payload['text'].format(**payload)``.\n        - ``logs``: Any log messages that occurred during execution of this\n                    command, as a logging.LogRecord\n\n    :param file-like protocol_file: The protocol file to simulate.\n    :param propagate_logs: Whether this function should allow logs from the\n                           Opentrons stack to propagate up to the root handler.\n                           This can be useful if you're integrating this\n                           function in a larger application, but most logs that\n                           occur during protocol simulation are best associated\n                           with the actions in the protocol that cause them.\n    :type propagate_logs: bool\n    :param log_level: The level of logs to capture in the runlog\n    :type log_level: 'debug', 'info', 'warning', or 'error'\n    :returns List[Dict[str, Dict[str, Any]]]: A run log for user output.\n    \"\"\"\n    stack_logger = logging.getLogger('opentrons')\n    stack_logger.propagate = propagate_logs\n\n    contents = protocol_file.read()\n\n    if opentrons.config.feature_flags.use_protocol_api_v2():\n        try:\n            execute_args = {'protocol_json': json.loads(contents)}\n        except json.JSONDecodeError:\n            execute_args = {'protocol_code': contents}\n        context = opentrons.protocol_api.contexts.ProtocolContext()\n        context.home()\n        scraper = CommandScraper(stack_logger, log_level, context.broker)\n        execute_args.update({'simulate': True,\n                             'context': context})\n        opentrons.protocol_api.execute.run_protocol(**execute_args)\n    else:\n        try:\n            proto = json.loads(contents)\n        except json.JSONDecodeError:\n            proto = contents\n        opentrons.robot.disconnect()\n        scraper = CommandScraper(stack_logger, log_level,\n                                 opentrons.robot.broker)\n        if isinstance(proto, dict):\n            opentrons.protocols.execute_protocol(proto)\n        else:\n            exec(proto, {})\n    return scraper.commands"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting a runlog into a human - readable string", "response": "def format_runlog(runlog: List[Mapping[str, Any]]) -> str:\n    \"\"\"\n    Format a run log (return value of :py:meth:`simulate``) into a\n    human-readable string\n\n    :param runlog: The output of a call to :py:func:`simulate`\n    \"\"\"\n    to_ret = []\n    for command in runlog:\n        to_ret.append(\n            '\\t' * command['level']\n            + command['payload'].get('text', '').format(**command['payload']))\n        if command['logs']:\n            to_ret.append('\\t' * command['level'] + 'Logs from this command:')\n            to_ret.extend(\n                ['\\t' * command['level']\n                 + f'{l.levelname} ({l.module}): {l.msg}' % l.args\n                 for l in command['logs']])\n    return '\\n'.join(to_ret)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef commands(self) -> List[Mapping[str, Mapping[str, Any]]]:\n        return self._commands", "response": "The list of commands."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _command_callback(self, message):\n        payload = message['payload']\n        if message['$'] == 'before':\n            self._commands.append({'level': self._depth,\n                                   'payload': payload,\n                                   'logs': []})\n            self._depth += 1\n        else:\n            while not self._queue.empty():\n                self._commands[-1]['logs'].append(self._queue.get())\n            self._depth = max(self._depth-1, 0)", "response": "The callback for the command"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _version_less(version_a, version_b):\n    if version_a[0] > version_b[0]:\n        return False\n    elif version_a[0] < version_b[0]:\n        return True\n    else:\n        if version_a[1] > version_b[1]:\n            return False\n        elif version_a[1] < version_b[1]:\n            return True\n        else:\n            return version_a[2] < version_b[2]", "response": "Returns True if version_a < version_b False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the firmware of the specified file.", "response": "async def _update_firmware(filename, loop):\n    \"\"\"\n    Currently uses the robot singleton from the API server to connect to\n    Smoothie. Those calls should be separated out from the singleton so it can\n    be used directly without requiring a full initialization of the API robot.\n    \"\"\"\n    try:\n        from opentrons import robot\n    except ModuleNotFoundError:\n        res = \"Unable to find module `opentrons`--not updating firmware\"\n        rc = 1\n        log.error(res)\n    else:\n        # ensure there is a reference to the port\n        if not robot.is_connected():\n            robot.connect()\n\n        # get port name\n        port = str(robot._driver.port)\n        # set smoothieware into programming mode\n        robot._driver._smoothie_programming_mode()\n        # close the port so other application can access it\n        robot._driver._connection.close()\n\n        # run lpc21isp, THIS WILL TAKE AROUND 1 MINUTE TO COMPLETE\n        update_cmd = 'lpc21isp -wipe -donotstart {0} {1} {2} 12000'.format(\n            filename, port, robot.config.serial_speed)\n        proc = await asyncio.create_subprocess_shell(\n            update_cmd,\n            stdout=asyncio.subprocess.PIPE,\n            loop=loop)\n        rd = await proc.stdout.read()\n        res = rd.decode().strip()\n        await proc.communicate()\n        rc = proc.returncode\n\n        if rc == 0:\n            # re-open the port\n            robot._driver._connection.open()\n            # reset smoothieware\n            robot._driver._smoothie_reset()\n            # run setup gcodes\n            robot._driver._setup()\n\n    return res, rc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the API with the new data.", "response": "async def update_api(request: web.Request) -> web.Response:\n    \"\"\"\n    This handler accepts a POST request with Content-Type: multipart/form-data\n    and file fields in the body named \"whl\", \"serverlib\", and \"fw\". The \"whl\"\n    and \"serverlib\" files should be valid Python wheels to be installed (\"whl\"\n    is expected generally to be the API server wheel, and \"serverlib\" is\n    expected to be the ot2serverlib wheel. The \"fw\" file is expected to be a\n    Smoothie firmware hex file. The Python files are install using pip, and the\n    firmware file is flashed to the Smoothie board, then the files are deleted\n    and a success code is returned.\n    \"\"\"\n    log.debug('Update request received')\n    data = await request.post()\n    try:\n        res0, rc0 = await install_py(\n            sys.executable, data['whl'], request.loop)\n        reslist = [res0]\n        filename = os.path.basename(res0['filename'])\n        version_re_res = re.search(WHEEL_VERSION_RE, filename)\n        rcprov = 0\n        if not version_re_res:\n            log.warning(\"Wheel version regex didn't match {}: won't provision\"\n                        .format(filename))\n        elif rc0 == 0:\n            v_maj, v_min, v_pat\\\n                = (int(v) for v in version_re_res.group(1, 2, 3))\n            if not _version_less((v_maj, v_min, v_pat),\n                                 FIRST_PROVISIONED_VERSION):\n                resprov, rcprov = await _provision_container(\n                    sys.executable, request.loop)\n                reslist.append(resprov)\n        if 'serverlib' in data.keys():\n            res1, rc1 = await install_py(\n                sys.executable, data['serverlib'], request.loop)\n            reslist.append(res1)\n        else:\n            rc1 = 0\n        if 'fw' in data.keys():\n            res2, rc2 = await install_smoothie_firmware(\n                data['fw'], request.loop)\n            reslist.append(res2)\n        else:\n            rc2 = 0\n        res = {\n            'message': [r['message'] for r in reslist],\n            'filename': [r['filename'] for r in reslist]\n        }\n        returncode = rc0 + rc1 + rc2 + rcprov\n        if returncode == 0:\n            status = 200\n        else:\n            status = 400\n    except Exception as e:\n        res = {'message':  # type: ignore\n               'Exception {} raised by update of {}: {}'\n               .format(type(e), data, traceback.format_tb(e.__traceback__))}\n        status = 500\n    return web.json_response(res, status=status)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def get_attached_pipettes(request):\n    hw = hw_from_req(request)\n    if request.url.query.get('refresh') == 'true':\n        if ff.use_protocol_api_v2():\n            await hw.cache_instruments()\n        else:\n            hw.cache_instrument_models()\n    response = {}\n    for mount, data in hw.get_attached_pipettes().items():\n        response[mount] = {\n            'model': data['model'],\n            'mount_axis': str(data['mount_axis']).lower(),\n            'plunger_axis': str(data['plunger_axis']).lower(),\n            'id': data['id']\n        }\n        if 'tip_length' in data:\n            response[mount]['tip_length'] = data.get('tip_length', 0)\n    return web.json_response(response, status=200)", "response": "Get the pipettes attached to the pipette."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def get_attached_modules(request):\n    hw = hw_from_req(request)\n    if ff.use_protocol_api_v2():\n        hw_mods = await hw.discover_modules()\n        module_data = [\n            {\n                'name': mod.name(),\n                'displayName': mod.display_name(),\n                'port': mod.port,\n                'serial': mod.device_info.get('serial'),\n                'model': mod.device_info.get('model'),\n                'fwVersion': mod.device_info.get('version'),\n                **mod.live_data\n            }\n            for mod in hw_mods\n        ]\n    else:\n        hw.discover_modules()\n        hw_mods = hw.attached_modules.values()\n        module_data = [\n            {\n                'name': mod.name(),\n                'displayName': mod.display_name(),\n                'port': mod.port,\n                'serial': mod.device_info and mod.device_info.get('serial'),\n                'model': mod.device_info and mod.device_info.get('model'),\n                'fwVersion': mod.device_info\n                and mod.device_info.get('version'),\n                **mod.live_data\n            }\n            for mod in hw_mods\n        ]\n    return web.json_response(data={\"modules\": module_data},\n                             status=200)", "response": "Get the list of modules attached to the current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries a module by its serial number for its live data", "response": "async def get_module_data(request):\n    \"\"\"\n    Query a module (by its serial number) for its live data\n    \"\"\"\n    hw = hw_from_req(request)\n    requested_serial = request.match_info['serial']\n    res = None\n\n    if ff.use_protocol_api_v2():\n        hw_mods = await hw.discover_modules()\n    else:\n        hw_mods = hw.attached_modules.values()\n\n    for module in hw_mods:\n        is_serial_match = module.device_info.get('serial') == requested_serial\n        if is_serial_match and hasattr(module, 'live_data'):\n            res = module.live_data\n\n    if res:\n        return web.json_response(res, status=200)\n    else:\n        return web.json_response({\"message\": \"Module not found\"}, status=404)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def execute_module_command(request):\n    hw = hw_from_req(request)\n    requested_serial = request.match_info['serial']\n    data = await request.json()\n    command_type = data.get('command_type')\n    args = data.get('args')\n\n    if ff.use_protocol_api_v2():\n        hw_mods = await hw.discover_modules()\n    else:\n        hw_mods = hw.attached_modules.values()\n\n    if len(hw_mods) == 0:\n        return web.json_response({\"message\": \"No connected modules\"},\n                                 status=404)\n\n    matching_mod = next((mod for mod in hw_mods if\n                        mod.device_info.get('serial') == requested_serial),\n                        None)\n\n    if not matching_mod:\n        return web.json_response({\"message\": \"Specified module not found\"},\n                                 status=404)\n\n    if hasattr(matching_mod, command_type):\n        clean_args = args or []\n        method = getattr(matching_mod, command_type)\n        if asyncio.iscoroutinefunction(method):\n            val = await method(*clean_args)\n        else:\n            val = method(*clean_args)\n\n        return web.json_response(\n            {'message': 'Success', 'returnValue': val},\n            status=200)\n    else:\n        return web.json_response(\n            {'message': f'Module does not have command: {command_type}'},\n            status=400)", "response": "Execute a command on a given module by its serial number"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def get_engaged_axes(request):\n    hw = hw_from_req(request)\n    return web.json_response(\n        {str(k).lower(): {'enabled': v}\n         for k, v in hw.engaged_axes.items()})", "response": "Query driver for engaged state by axis."}
