{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_learning_objectives(self):\n        # This is pretty much identicial to the method in assessment.Item!\n        mgr = self._get_provider_manager('LEARNING')\n        lookup_session = mgr.get_objective_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_objective_bank_view()\n        return lookup_session.get_objectives_by_ids(self.get_learning_objective_ids())", "response": "This method also mirrors that in the Item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_learning_objectives(self):\n        # Implemented from template for osid.learning.Activity.get_assets_template\n        if not bool(self._my_map['learningObjectiveIds']):\n            raise errors.IllegalState('no learningObjectiveIds')\n        mgr = self._get_provider_manager('LEARNING')\n        if not mgr.supports_objective_lookup():\n            raise errors.OperationFailed('Learning does not support Objective lookup')\n\n        # What about the Proxy?\n        lookup_session = mgr.get_objective_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_objective_bank_view()\n        return lookup_session.get_objectives_by_ids(self.get_learning_objective_ids())", "response": "Gets the any Objectives corresponding to this item."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_question(self):\n        question_map = dict(self._my_map['question'])\n        question_map['learningObjectiveIds'] = self._my_map['learningObjectiveIds']\n        return Question(osid_object_map=question_map,\n                        runtime=self._runtime,\n                        proxy=self._proxy)", "response": "Gets the question.\n\n        return: (osid.assessment.Question) - the question\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_answers(self):\n        # Implemented from template for osid.repository.Asset.get_asset_contents_template\n        return AnswerList(\n            self._my_map['answers'],\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Gets the answers.\n\n        return: (osid.assessment.AnswerList) - the answers\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the metadata for learning objectives.", "response": "def get_learning_objectives_metadata(self):\n        \"\"\"Gets the metadata for learning objectives.\n\n        return: (osid.Metadata) - metadata for the learning objectives\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.get_assets_metadata_template\n        metadata = dict(self._mdata['learning_objectives'])\n        metadata.update({'existing_learning_objectives_values': self._my_map['learningObjectiveIds']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_learning_objectives(self, objective_ids):\n        # Implemented from template for osid.learning.ActivityForm.set_assets_template\n        if not isinstance(objective_ids, list):\n            raise errors.InvalidArgument()\n        if self.get_learning_objectives_metadata().is_read_only():\n            raise errors.NoAccess()\n        idstr_list = []\n        for object_id in objective_ids:\n            if not self._is_valid_id(object_id):\n                raise errors.InvalidArgument()\n            idstr_list.append(str(object_id))\n        self._my_map['learningObjectiveIds'] = idstr_list", "response": "Sets the learning objectives."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear_learning_objectives(self):\n        # Implemented from template for osid.learning.ActivityForm.clear_assets_template\n        if (self.get_learning_objectives_metadata().is_read_only() or\n                self.get_learning_objectives_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['learningObjectiveIds'] = self._learning_objectives_default", "response": "Clears the learning objectives."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_level_id(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['levelId']):\n            raise errors.IllegalState('this Assessment has no level')\n        else:\n            return Id(self._my_map['levelId'])", "response": "Gets the Id of a grade corresponding to the assessment difficulty."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_level(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['levelId']):\n            raise errors.IllegalState('this Assessment has no level')\n        mgr = self._get_provider_manager('GRADING')\n        if not mgr.supports_grade_lookup():\n            raise errors.OperationFailed('Grading does not support Grade lookup')\n        lookup_session = mgr.get_grade_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_gradebook_view()\n        osid_object = lookup_session.get_grade(self.get_level_id())\n        return osid_object", "response": "Gets the grade corresponding to the assessment difficulty."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the rubric. return: (osid.assessment.Assessment) - the assessment raise: IllegalState - ``has_rubric()`` is ``false`` raise: OperationFailed - unable to complete request *compliance: mandatory -- This method must be implemented.*", "response": "def get_rubric(self):\n        \"\"\"Gets the rubric.\n\n        return: (osid.assessment.Assessment) - the assessment\n        raise:  IllegalState - ``has_rubric()`` is ``false``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['rubricId']):\n            raise errors.IllegalState('this Assessment has no rubric')\n        mgr = self._get_provider_manager('ASSESSMENT')\n        if not mgr.supports_assessment_lookup():\n            raise errors.OperationFailed('Assessment does not support Assessment lookup')\n        lookup_session = mgr.get_assessment_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bank_view()\n        osid_object = lookup_session.get_assessment(self.get_rubric_id())\n        return osid_object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_next_assessment_part(self, assessment_part_id):\n        if not self.supports_child_ordering or not self.supports_simple_child_sequencing:\n            raise AttributeError()  # Only available through a record extension\n        if 'childIds' in self._my_map and str(assessment_part_id) in self._my_map['childIds']:\n            if self._my_map['childIds'][-1] != str(assessment_part_id):\n                return True\n            else:\n                return False\n        raise errors.NotFound('the Part with Id ' + str(assessment_part_id) + ' is not a child of this Part')", "response": "Returns True if there is a next assessment part in this assessment part."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_next_assessment_part_id(self, assessment_part_id=None):\n        if assessment_part_id is None:\n            part_id = self.get_id()\n        else:\n            part_id = assessment_part_id\n        return get_next_part_id(part_id,\n                                runtime=self._runtime,\n                                proxy=self._proxy,\n                                sequestered=True)[0]", "response": "This supports the basic simple sequence case. Can be overriden in a record for other cases."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_level_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['level'])\n        metadata.update({'existing_id_values': self._my_map['levelId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a grade level."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_level(self, grade_id):\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_level_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(grade_id):\n            raise errors.InvalidArgument()\n        self._my_map['levelId'] = str(grade_id)", "response": "Sets the level of difficulty expressed as a Grade."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_rubric_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['rubric'])\n        metadata.update({'existing_id_values': self._my_map['rubricId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a rubric assessment"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_rubric(self, assessment_id):\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_rubric_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(assessment_id):\n            raise errors.InvalidArgument()\n        self._my_map['rubricId'] = str(assessment_id)", "response": "Sets the rubric expressed as another assessment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear_rubric(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_rubric_metadata().is_read_only() or\n                self.get_rubric_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['rubricId'] = self._rubric_default", "response": "Clears the rubric.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the children IDs.", "response": "def set_children(self, child_ids):\n        \"\"\"Set the children IDs\"\"\"\n        if not self._supports_simple_sequencing():\n            raise errors.IllegalState()\n        self._my_map['childIds'] = [str(i) for i in child_ids]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef are_items_sequential(self):\n        if self._my_map['itemsSequential'] is None:\n            return self.get_assessment().are_items_sequential()\n        return bool(self._my_map['itemsSequential'])", "response": "Tests if the items or parts in this assessment are sequentially."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if the items or parts appear in a random order.", "response": "def are_items_shuffled(self):\n        \"\"\"Tests if the items or parts appear in a random order.\n\n        return: (boolean) - ``true`` if the items appear in a random\n                order, ``false`` otherwise\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._my_map['itemsShuffled'] is None:\n            return self.get_assessment().are_items_shuffled()\n        return bool(self._my_map['itemsShuffled'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_start_time(self):\n        # Implemented from template for osid.assessment.AssessmentOffered.get_start_time_template\n        if not bool(self._my_map['startTime']):\n            raise errors.IllegalState()\n        dt = self._my_map['startTime']\n        return DateTime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.microsecond)", "response": "Gets the start time for this assessment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_duration(self):\n        # Implemented from template for osid.assessment.AssessmentOffered.get_duration_template\n        if not bool(self._my_map['duration']):\n            raise errors.IllegalState()\n        return Duration(**self._my_map['duration'])", "response": "Gets the duration for this assessment."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the grade system Id for the score.", "response": "def get_score_system_id(self):\n        \"\"\"Gets the grade system ``Id`` for the score.\n\n        return: (osid.id.Id) - the grade system ``Id``\n        raise:  IllegalState - ``is_scored()`` is ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['scoreSystemId']):\n            raise errors.IllegalState('this AssessmentOffered has no score_system')\n        else:\n            return Id(self._my_map['scoreSystemId'])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_rubric(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['rubricId']):\n            raise errors.IllegalState('this AssessmentOffered has no rubric')\n        mgr = self._get_provider_manager('ASSESSMENT')\n        if not mgr.supports_assessment_offered_lookup():\n            raise errors.OperationFailed('Assessment does not support AssessmentOffered lookup')\n        lookup_session = mgr.get_assessment_offered_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bank_view()\n        osid_object = lookup_session.get_assessment_offered(self.get_rubric_id())\n        return osid_object", "response": "Gets the rubric.\n\n        return: (osid.assessment.AssessmentOffered) - the assessment\n                offered\n        raise:  IllegalState - ``has_rubric()`` is ``false``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_map(self, record_types=None, **kwargs):\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        self._my_map['levelId'] = self._level_default\n        self._my_map['startTime'] = self._start_time_default\n        self._my_map['gradeSystemId'] = self._grade_system_default\n        self._my_map['itemsShuffled'] = self._items_shuffled_default\n        self._my_map['scoreSystemId'] = self._score_system_default\n        self._my_map['deadline'] = self._deadline_default\n        self._my_map['assignedBankIds'] = [str(kwargs['bank_id'])]\n        self._my_map['duration'] = self._duration_default\n        self._my_map['assessmentId'] = str(kwargs['assessment_id'])\n        self._my_map['itemsSequential'] = self._items_sequential_default", "response": "Initialize the map of the assessment record"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the metadata for sequential operation.", "response": "def get_items_sequential_metadata(self):\n        \"\"\"Gets the metadata for sequential operation.\n\n        return: (osid.Metadata) - metadata for the sequential flag\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['items_sequential'])\n        metadata.update({'existing_boolean_values': self._my_map['itemsSequential']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_items_sequential(self, sequential):\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_items_sequential_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(sequential):\n            raise errors.InvalidArgument()\n        self._my_map['itemsSequential'] = sequential", "response": "Sets the items sequential flag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclear the items sequential flag.", "response": "def clear_items_sequential(self):\n        \"\"\"Clears the items sequential flag.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_items_sequential_metadata().is_read_only() or\n                self.get_items_sequential_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['itemsSequential'] = self._items_sequential_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_items_shuffled_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['items_shuffled'])\n        metadata.update({'existing_boolean_values': self._my_map['itemsShuffled']})\n        return Metadata(**metadata)", "response": "Gets the metadata for shuffling items."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_items_shuffled(self, shuffle):\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_items_shuffled_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(shuffle):\n            raise errors.InvalidArgument()\n        self._my_map['itemsShuffled'] = shuffle", "response": "Sets the shuffle flag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the shuffle flag.", "response": "def clear_items_shuffled(self):\n        \"\"\"Clears the shuffle flag.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_items_shuffled_metadata().is_read_only() or\n                self.get_items_shuffled_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['itemsShuffled'] = self._items_shuffled_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the metadata for the assessment start time.", "response": "def get_start_time_metadata(self):\n        \"\"\"Gets the metadata for the assessment start time.\n\n        return: (osid.Metadata) - metadata for the start time\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['start_time'])\n        metadata.update({'existing_date_time_values': self._my_map['startTime']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_start_time(self, start):\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.set_start_time_template\n        if self.get_start_time_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_date_time(\n                start,\n                self.get_start_time_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['startTime'] = start", "response": "Sets the assessment start time."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nclears the start time.", "response": "def clear_start_time(self):\n        \"\"\"Clears the start time.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.clear_start_time_template\n        if (self.get_start_time_metadata().is_read_only() or\n                self.get_start_time_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['startTime'] = self._start_time_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_deadline_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['deadline'])\n        metadata.update({'existing_date_time_values': self._my_map['deadline']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the assessment deadline"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the assessment end time.", "response": "def set_deadline(self, end):\n        \"\"\"Sets the assessment end time.\n\n        arg:    end (timestamp): assessment end time\n        raise:  InvalidArgument - ``end`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.set_start_time_template\n        if self.get_deadline_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_timestamp(\n                end,\n                self.get_deadline_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['deadline'] = end"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear the deadline. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_deadline(self):\n        \"\"\"Clears the deadline.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.clear_start_time_template\n        if (self.get_deadline_metadata().is_read_only() or\n                self.get_deadline_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['deadline'] = self._deadline_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_duration_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['duration'])\n        metadata.update({'existing_duration_values': self._my_map['duration']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the assessment duration"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the assessment duration.", "response": "def set_duration(self, duration):\n        \"\"\"Sets the assessment duration.\n\n        arg:    duration (osid.calendaring.Duration): assessment\n                duration\n        raise:  InvalidArgument - ``duration`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.set_duration_template\n        if self.get_duration_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_duration(\n                duration,\n                self.get_duration_metadata()):\n            raise errors.InvalidArgument()\n        map = dict()\n        map['days'] = duration.days\n        map['seconds'] = duration.seconds\n        map['microseconds'] = duration.microseconds\n        self._my_map['duration'] = map"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_duration(self):\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.clear_duration_template\n        if (self.get_duration_metadata().is_read_only() or\n                self.get_duration_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['duration'] = self._duration_default", "response": "Clears the duration.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_score_system_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['score_system'])\n        metadata.update({'existing_id_values': self._my_map['scoreSystemId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a score system"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_score_system(self, grade_system_id):\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_score_system_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(grade_system_id):\n            raise errors.InvalidArgument()\n        self._my_map['scoreSystemId'] = str(grade_system_id)", "response": "Sets the scoring system."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_score_system(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_score_system_metadata().is_read_only() or\n                self.get_score_system_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['scoreSystemId'] = self._score_system_default", "response": "Clears the score system."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_grade_system_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['grade_system'])\n        metadata.update({'existing_id_values': self._my_map['gradeSystemId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a grade system"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the grading system.", "response": "def set_grade_system(self, grade_system_id):\n        \"\"\"Sets the grading system.\n\n        arg:    grade_system_id (osid.id.Id): the grade system\n        raise:  InvalidArgument - ``grade_system_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_grade_system_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(grade_system_id):\n            raise errors.InvalidArgument()\n        self._my_map['gradeSystemId'] = str(grade_system_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclearing the grading system.", "response": "def clear_grade_system(self):\n        \"\"\"Clears the grading system.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_grade_system_metadata().is_read_only() or\n                self.get_grade_system_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['gradeSystemId'] = self._grade_system_default"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the Id of the AssessmentOffered.", "response": "def get_assessment_offered_id(self):\n        \"\"\"Gets the ``Id`` of the ``AssessmentOffered``.\n\n        return: (osid.id.Id) - the assessment offered ``Id``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['assessmentOfferedId']):\n            raise errors.IllegalState('assessment_offered empty')\n        return Id(self._my_map['assessmentOfferedId'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_offered(self):\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['assessmentOfferedId']):\n            raise errors.IllegalState('assessment_offered empty')\n        mgr = self._get_provider_manager('ASSESSMENT')\n        if not mgr.supports_assessment_offered_lookup():\n            raise errors.OperationFailed('Assessment does not support AssessmentOffered lookup')\n        lookup_session = mgr.get_assessment_offered_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bank_view()\n        return lookup_session.get_assessment_offered(self.get_assessment_offered_id())", "response": "Gets the ``AssessmentOffered``.\n\n        return: (osid.assessment.AssessmentOffered) - the assessment\n                offered\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_taker_id(self):\n        if self._my_map['takerId']:\n            return Id(self._my_map['takerId'])\n        else:\n            return Id(self._my_map['takingAgentId'])", "response": "Gets the Id of the resource who took or is taking this assessment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_started(self):\n        assessment_offered = self.get_assessment_offered()\n        if assessment_offered.has_start_time():\n            return DateTime.utcnow() >= assessment_offered.get_start_time()\n        else:\n            return True", "response": "Tests if this assessment has begun."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_actual_start_time(self):\n        if not self.has_started():\n            raise errors.IllegalState('this assessment has not yet started')\n        if self._my_map['actualStartTime'] is None:\n            raise errors.IllegalState('this assessment has not yet been started by the taker')\n        else:\n            start_time = self._my_map['actualStartTime']\n            return DateTime(year=start_time.year,\n                            month=start_time.month,\n                            day=start_time.day,\n                            hour=start_time.hour,\n                            minute=start_time.minute,\n                            second=start_time.second,\n                            microsecond=start_time.microsecond)", "response": "Gets the actual start time of this assessment."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntests if this assessment has ended.", "response": "def has_ended(self):\n        \"\"\"Tests if this assessment has ended.\n\n        return: (boolean) - ``true`` if the assessment has ended,\n                ``false`` otherwise\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        assessment_offered = self.get_assessment_offered()\n        now = DateTime.utcnow()\n        # There's got to be a better way to do this:\n        if self._my_map['completionTime'] is not None:\n            return True\n        elif assessment_offered.has_deadline() and assessment_offered.has_duration():\n            if self._my_map['actualStartTime'] is None:\n                return now >= assessment_offered.get_deadline()\n            else:\n                return (now >= assessment_offered.get_deadline() and\n                        now >= self._my_map['actualStartTime'] + assessment_offered.get_duration())\n        elif assessment_offered.has_deadline():\n            return now >= assessment_offered.get_deadline()\n        elif assessment_offered.has_duration() and self._my_map['actualStartTime'] is not None:\n            return now >= self._my_map['actualStartTime'] + assessment_offered.get_duration()\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the time of this assessment was completed.", "response": "def get_completion_time(self):\n        \"\"\"Gets the time of this assessment was completed.\n\n        return: (osid.calendaring.DateTime) - the end time\n        raise:  IllegalState - ``has_ended()`` is ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not self.has_ended():\n            raise errors.IllegalState('this assessment has not yet ended')\n        if not self._my_map['completionTime']:\n            raise errors.OperationFailed('someone forgot to set the completion time')\n        completion_time = self._my_map['completionTime']\n        return DateTime(year=completion_time.year,\n                        month=completion_time.month,\n                        day=completion_time.day,\n                        hour=completion_time.hour,\n                        minute=completion_time.minute,\n                        second=completion_time.second,\n                        microsecond=completion_time.microsecond)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_time_spent(self):\n        # Take another look at this. Not sure it's correct:\n        if not self.has_started or not self.has_ended():\n            raise errors.IllegalState()\n        if self._my_map['completionTime'] is not None:\n            return self.get_completion_time() - self.get_actual_start_time()\n        else:\n            raise errors.IllegalState()", "response": "Gets the total time spent taking this assessment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a score system Id for the assessment.", "response": "def get_score_system_id(self):\n        \"\"\"Gets a score system ``Id`` for the assessment.\n\n        return: (osid.id.Id) - the grade system\n        raise:  IllegalState - ``is_score()`` is ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['scoreSystemId']):\n            raise errors.IllegalState('this AssessmentTaken has no score_system')\n        mgr = self._get_provider_manager('ID')\n        if not mgr.supports_id_lookup():\n            raise errors.OperationFailed('Id does not support Id lookup')\n        lookup_session = mgr.get_id_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_no_catalog_view()\n        osid_object = lookup_session.get_id(self.get_score_system_id())\n        return osid_object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_score_system(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['scoreSystemId']):\n            raise errors.IllegalState('this AssessmentTaken has no score_system')\n        mgr = self._get_provider_manager('GRADING')\n        if not mgr.supports_grade_system_lookup():\n            raise errors.OperationFailed('Grading does not support GradeSystem lookup')\n        lookup_session = mgr.get_grade_system_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_gradebook_view()\n        osid_object = lookup_session.get_grade_system(self.get_score_system_id())\n        return osid_object", "response": "Gets a grade system for the score."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_rubric_id(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['rubricId']):\n            raise errors.IllegalState('this AssessmentTaken has no rubric')\n        else:\n            return Id(self._my_map['rubricId'])", "response": "Gets the Id of the rubric."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_rubric(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['rubricId']):\n            raise errors.IllegalState('this AssessmentTaken has no rubric')\n        mgr = self._get_provider_manager('ASSESSMENT')\n        if not mgr.supports_assessment_taken_lookup():\n            raise errors.OperationFailed('Assessment does not support AssessmentTaken lookup')\n        lookup_session = mgr.get_assessment_taken_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bank_view()\n        osid_object = lookup_session.get_assessment_taken(self.get_rubric_id())\n        return osid_object", "response": "Gets the rubric.\n\n        return: (osid.assessment.AssessmentTaken) - the assessment taken\n        raise:  IllegalState - ``has_rubric()`` is ``false``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the first section for this Taken s Assessment.", "response": "def _get_first_assessment_section(self):\n        \"\"\"Gets the first section for this Taken's Assessment.\"\"\"\n        if ('sections' not in self._my_map or not self._my_map['sections']):\n            # This is the first time for this Taken, so start assessment\n            # SHOULD THIS USE self._update_available_sections????\n            assessment_id = self.get_assessment_offered().get_assessment().get_id()\n            first_part_id = get_first_part_id_for_assessment(assessment_id, runtime=self._runtime, proxy=self._proxy)\n            first_section = self._create_section(first_part_id)\n            self._my_map['sections'] = [str(first_section.get_id())]\n            self._my_map['actualStartTime'] = DateTime.utcnow()\n            self._save()\n            return first_section\n        else:\n            return self._get_assessment_section(Id(self._my_map['sections'][0]))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_next_assessment_section(self, assessment_section_id):\n        if self._my_map['sections'][-1] == str(assessment_section_id):\n            # section_id represents the last seen section\n            section = self._get_assessment_section(assessment_section_id)\n            next_part_id, level = get_next_part_id(section._assessment_part_id,\n                                                   runtime=self._runtime,\n                                                   proxy=self._proxy,\n                                                   sequestered=True)  # Raises IllegalState\n            next_section = self._create_section(next_part_id)\n            self._my_map['sections'].append(str(next_section.get_id()))\n            self._save()\n            return next_section\n        else:\n            return self._get_assessment_section(\n                Id(self._my_map['sections'][self._my_map['sections'].index(str(assessment_section_id)) + 1]))", "response": "Gets the next section following section_id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_previous_assessment_section(self, assessment_section_id):\n        if self._my_map['sections'][0] == str(assessment_section_id):\n            raise errors.IllegalState('already at the first section')\n        else:\n            return self._get_assessment_section(\n                Id(self._my_map['sections'][self._my_map['sections'].index(str(assessment_section_id)) - 1]))", "response": "Gets the previous section before section_id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a SectionList of all Sections currently known to this AssessmentTaken", "response": "def _get_assessment_sections(self):\n        \"\"\"Gets a SectionList of all Sections currently known to this AssessmentTaken\"\"\"\n        section_list = []\n        for section_idstr in self._my_map['sections']:\n            section_list.append(self._get_assessment_section(Id(section_idstr)))\n        return AssessmentSectionList(section_list, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _save(self):\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        collection.save(self._my_map)", "response": "Saves the current state of this AssessmentTaken."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the map of the assessment assessment", "response": "def _init_map(self, record_types=None, **kwargs):\n        \"\"\"Initialize form map\"\"\"\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        self._my_map['assessmentOfferedId'] = str(kwargs['assessment_offered_id'])\n        self._my_map['takerId'] = self._taker_default\n        self._my_map['assignedBankIds'] = [str(kwargs['bank_id'])]\n        self._my_map['actualStartTime'] = None\n        self._my_map['gradeId'] = ''\n        self._my_map['completionTime'] = None\n        self._my_map['score'] = 0.0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_taker_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['taker'])\n        metadata.update({'existing_id_values': self._my_map['takerId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a resource to manually set which resource will be taking the assessment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the resource who will be taking this assessment.", "response": "def set_taker(self, resource_id):\n        \"\"\"Sets the resource who will be taking this assessment.\n\n        arg:    resource_id (osid.id.Id): the resource Id\n        raise:  InvalidArgument - ``resource_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_taker_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(resource_id):\n            raise errors.InvalidArgument()\n        self._my_map['takerId'] = str(resource_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclearing the resource. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_taker(self):\n        \"\"\"Clears the resource.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_taker_metadata().is_read_only() or\n                self.get_taker_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['takerId'] = self._taker_default"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_assessment_taken_id(self):\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['assessmentTakenId']):\n            raise errors.IllegalState('assessment_taken empty')\n        return Id(self._my_map['assessmentTakenId'])", "response": "Gets the Id of the AssessmentTaken."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the ``AssessmentTakeb``. return: (osid.assessment.AssessmentTaken) - the assessment taken raise: OperationFailed - unable to complete request *compliance: mandatory -- This method must be implemented.*", "response": "def get_assessment_taken(self):\n        \"\"\"Gets the ``AssessmentTakeb``.\n\n        return: (osid.assessment.AssessmentTaken) - the assessment taken\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['assessmentTakenId']):\n            raise errors.IllegalState('assessment_taken empty')\n        mgr = self._get_provider_manager('ASSESSMENT')\n        if not mgr.supports_assessment_taken_lookup():\n            raise errors.OperationFailed('Assessment does not support AssessmentTaken lookup')\n        lookup_session = mgr.get_assessment_taken_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bank_view()\n        return lookup_session.get_assessment_taken(self.get_assessment_taken_id())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the Bank at this node.", "response": "def get_bank(self):\n        \"\"\"Gets the ``Bank`` at this node.\n\n        return: (osid.assessment.Bank) - the bank represented by this\n                node\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._lookup_session is None:\n            mgr = get_provider_manager('ASSESSMENT', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_bank_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_bank(Id(self._my_map['id']))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_parent_bank_nodes(self):\n        parent_bank_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_bank_nodes.append(BankNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return BankNodeList(parent_bank_nodes)", "response": "Gets the parents of this bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndefault on - connect actions.", "response": "def on_connect(client):\n    \"\"\"Default on-connect actions.\"\"\"\n    client.nick(client.user.nick)\n    client.userinfo(client.user.username, client.user.realname)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndefault handling for incoming lines.", "response": "def on_line(client, line):\n    \"\"\"Default handling for incoming lines.\n\n    This handler will automatically manage the following IRC messages:\n\n      PING:\n        Responds with a PONG.\n      PRIVMSG:\n        Dispatches the PRIVMSG event.\n      NOTICE:\n        Dispatches the NOTICE event.\n      MOTDSTART:\n        Initializes MOTD receive buffer.\n      MOTD:\n        Appends a line to the MOTD receive buffer.\n      ENDOFMOTD:\n        Joins the contents of the MOTD receive buffer, assigns the result\n        to the .motd of the server, and dispatches the MOTD event.\n    \"\"\"\n    if line.startswith(\"PING\"):\n        client.send(\"PONG\" + line[4:])\n        return True\n\n    if line.startswith(\":\"):\n        actor, _, line = line[1:].partition(\" \")\n    else:\n        actor = None\n    command, _, args = line.partition(\" \")\n    command = NUMERIC_EVENTS.get(command, command)\n\n    parser = PARSERS.get(command, False)\n    if parser:\n        parser(client, command, actor, args)\n        return True\n    elif parser is False:\n        # Explicitly ignored message\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parser(*events):\n    def dec(func):\n        for event in events:\n            PARSERS[event] = func\n        return func\n    return dec", "response": "Decorator for convenience - adds a function as a parser for events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_msg(client, command, actor, args):\n    recipient, _, message = args.partition(' :')\n    chantypes = client.server.features.get(\"CHANTYPES\", \"#\")\n    if recipient[0] in chantypes:\n        recipient = client.server.get_channel(recipient) or recipient.lower()\n    else:\n        recipient = User(recipient)\n    client.dispatch_event(command, actor, recipient, message)", "response": "Parse a PRIVMSG or NOTICE and dispatch the corresponding event."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a JOIN and update the state of the channel and dispatch events.", "response": "def _parse_join(client, command, actor, args):\n    \"\"\"Parse a JOIN and update channel states, then dispatch events.\n\n    Note that two events are dispatched here:\n        - JOIN, because a user joined the channel\n        - MEMBERS, because the channel's members changed\n    \"\"\"\n    actor = User(actor)\n    channel = args.lstrip(' :').lower()\n    if actor.nick == client.user.nick:\n        client.server.add_channel(channel)\n        client.user.host = actor.host # now we know our host per the server\n    channel = client.server.get_channel(channel)\n    channel.add_user(actor)\n    client.dispatch_event(\"JOIN\", actor, channel)\n    if actor.nick != client.user.nick:\n        # If this is us joining, the namreply will trigger this instead\n        client.dispatch_event(\"MEMBERS\", channel)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_part(client, command, actor, args):\n    actor = User(actor)\n    channel, _, message = args.partition(' :')\n    channel = client.server.get_channel(channel)\n    channel.remove_user(actor)\n    if actor.nick == client.user.nick:\n        client.server.remove_channel(channel)\n    client.dispatch_event(\"PART\", actor, channel, message)\n    if actor.nick != client.user.nick:\n        client.dispatch_event(\"MEMBERS\", channel)", "response": "Parse a PART and update the state of the channel and dispatch events."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_quit(client, command, actor, args):\n    actor = User(actor)\n    _, _, message = args.partition(':')\n    client.dispatch_event(\"QUIT\", actor, message)\n    for chan in client.server.channels.itervalues():\n        if actor.nick in chan.members:\n            chan.remove_user(actor)\n            client.dispatch_event(\"MEMBERS\", chan)", "response": "Parse a QUIT and update channel states and dispatch events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_kick(client, command, actor, args):\n    actor = User(actor)\n    args, _, message = args.partition(' :')\n    channel, target = args.split()\n    channel = client.server.get_channel(channel)\n    channel.remove_user(target)\n    target = User(target)\n    if target.nick == client.user.nick:\n        client.server.remove_channel(channel)\n    client.dispatch_event(\"KICK\", actor, target, channel, message)\n    client.dispatch_event(\"MEMBERS\", channel)", "response": "Parse a KICK and update the state of the channel and dispatch events."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a TOPIC and update channel state then dispatch a TOPIC event.", "response": "def _parse_topic(client, command, actor, args):\n    \"\"\"Parse a TOPIC and update channel state, then dispatch a TOPIC event.\"\"\"\n    channel, _, topic = args.partition(\" :\")\n    channel = client.server.get_channel(channel)\n    channel.topic = topic or None\n    if actor:\n        actor = User(actor)\n    client.dispatch_event(\"TOPIC\", actor, channel, topic)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_welcome(client, command, actor, args):\n    _, _, hostmask = args.rpartition(' ')\n    client.user.update_from_hostmask(hostmask)\n    client.dispatch_event(\"WELCOME\", hostmask)", "response": "Parse a WELCOME and update user state."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses CREATED and update the Host object.", "response": "def _parse_created(client, command, actor, args):\n    \"\"\"Parse CREATED and update the Host object.\"\"\"\n    m = re.search(\"This server was created (.+)$\", args)\n    if m:\n        client.server.created = m.group(1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse MYINFO and update the Host object.", "response": "def _parse_myinfo(client, command, actor, args):\n    \"\"\"Parse MYINFO and update the Host object.\"\"\"\n    _, server, version, usermodes, channelmodes = args.split(None, 5)[:5]\n    s = client.server\n    s.host = server\n    s.version = version\n    s.user_modes = set(usermodes)\n    s.channel_modes = set(channelmodes)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_featurelist(client, command, actor, args):\n    # Strip off \":are supported by this server\"\n    args = args.rsplit(\":\", 1)[0]\n    # Strip off the nick; we know it's addressed to us.\n    _, _, args = args.partition(' ')\n\n    items = args.split()\n    for item in items:\n        feature, _, value = item.partition(\"=\")\n\n        # Convert integer values to actual integers for convenience\n        try:\n            value = int(value)\n        except (ValueError, TypeError):\n            pass\n\n        client.server.features[feature] = value", "response": "Parse FEATURELIST and update the Host object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing NAMREPLY and update a Channel object.", "response": "def _parse_namreply(client, command, actor, args):\n    \"\"\"Parse NAMREPLY and update a Channel object.\"\"\"\n    prefixes = client._get_prefixes()\n\n    channelinfo, _, useritems = args.partition(' :')\n    _, _, channel = channelinfo.rpartition(' ')  # channeltype channelname\n\n    c = client.server.get_channel(channel)\n    if not c:\n        _log.warning(\"Ignoring NAMREPLY for channel '%s' which we are not in.\",\n            channel)\n        return\n\n    # We bypass Channel.add_user() here because we just want to sync in any\n    # users we don't already have, regardless of if other users exist, and\n    # we don't want the warning spam.\n    for nick in useritems.split():\n        modes = set()\n        while nick[0] in prefixes:\n            modes.add(prefixes[nick[0]])\n            nick = nick[1:]\n        user = c.members.get(nick)\n        if not user:\n            user = c.members[nick] = User(nick)\n            _log.debug(\"Added user %s to channel %s\", user, channel)\n        user.modes |= modes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_endofnames(client, command, actor, args):\n    args = args.split(\" :\", 1)[0] # Strip off human-readable message\n    _, _, channel = args.rpartition(' ')\n    channel = client.server.get_channel(channel) or channel.lower()\n    client.dispatch_event('MEMBERS', channel)", "response": "Parse an ENDOFNAMES and dispatch a NAMES event for the channel."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_mode(client, command, actor, args):\n    chantypes = client.server.features.get(\"CHANTYPES\", \"#\")\n    channel, _, args = args.partition(\" \")\n    args = args.lstrip(\":\")\n\n    if channel[0] not in chantypes:\n        # Personal modes\n        for modes in args.split():\n            op, modes = modes[0], modes[1:]\n            for mode in modes:\n                if op == \"+\":\n                    client.user.modes.add(mode)\n                else:\n                    client.user.modes.discard(mode)\n                client.dispatch_event(\"MODE\", actor, client.user, op, mode, None)\n        return\n\n    # channel-specific modes\n    chan = client.server.get_channel(channel)\n\n    user_modes = set(client._get_prefixes().itervalues())\n\n    chanmodes = client._get_chanmodes()\n    list_modes, always_arg_modes, set_arg_modes, toggle_modes = chanmodes\n    argument_modes = list_modes | always_arg_modes | set_arg_modes\n\n    tokens = args.split()\n    while tokens:\n        modes, tokens = tokens[0], tokens[1:]\n        op, modes = modes[0], modes[1:]\n\n        for mode in modes:\n            argument = None\n            if mode in (user_modes | argument_modes):\n                argument, tokens = tokens[0], tokens[1:]\n\n            if mode in user_modes:\n                user = client.server.get_channel(channel).members[argument]\n                if op == \"+\":\n                    user.modes.add(mode)\n                else:\n                    user.modes.discard(mode)\n\n            if op == \"+\":\n                if mode in (always_arg_modes | set_arg_modes):\n                    chan.modes[mode] = argument\n                elif mode in toggle_modes:\n                    chan.modes[mode] = True\n            else:\n                if mode in (always_arg_modes | set_arg_modes | toggle_modes):\n                    if mode in chan.modes:\n                        del chan.modes[mode]\n\n            # list-type modes (bans+exceptions, invite masks) aren't stored,\n            # but do generate MODE events.\n            client.dispatch_event(\"MODE\", actor, chan, op, mode, argument)", "response": "Parse a mode changes update states and dispatch MODE events."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_whois(client, command, actor, args):\n    _, _, args = args.partition(\" \") # Strip off recipient, we know it\"s us\n    nick, _, args = args.partition(\" \")\n    if client.server._whois.get(\"nick\") != nick:\n        client.server._whois = {\"nick\": nick}\n    response = client.server._whois\n\n    if command == \"WHOISUSER\":\n        first, _, response[\"realname\"] = args.partition(\":\")\n        response[\"username\"], response[\"host\"] = first.split()[:2]\n        return\n\n    if command == \"WHOISISSERVER\":\n        response[\"server\"], _, response[\"serverinfo\"] = args.partition(\" :\")\n        return\n\n    if command == \"WHOISOPERATOR\":\n        response[\"oper\"] = True\n        return\n\n    if command == \"WHOISIDLE\":\n        response[\"idle\"], _, _ = args.partition(\" :\")\n        response[\"idle\"] = int(response[\"idle\"])\n        return\n\n    if command == \"WHOISCHANNELS\":\n        modes = \"\".join(client._get_prefixes())\n        print repr(modes)\n        channels = args.lstrip(\":\").split()\n        response[\"channels\"] = dict(\n            (chan.lstrip(modes), chan[0] if chan[0] in modes else \"\")\n            for chan in channels)\n        return\n\n    if command == \"WHOISACCOUNT\":\n        response[\"account\"], _, _ = args.partition(\" :\")\n        return\n\n    if command == \"WHOISBOT\":\n        response[\"bot\"] = True\n        return\n\n    if command == \"WHOISREGNICK\":\n        response[\"registered\"] = True\n        return\n\n    if command == \"ENDOFWHOIS\":\n        client.dispatch_event(\"WHOIS\", response)", "response": "Parse the content responses from a WHOIS query."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_nick(client, command, actor, args):\n    old_nick, _, _ = actor.partition('!')\n    new_nick = args\n\n    if old_nick == client.user.nick:\n        client.user.nick = new_nick\n\n    modified_channels = set()\n    for channel in client.server.channels.itervalues():\n        user = channel.members.get(old_nick)\n        if user:\n            user.nick = new_nick\n            channel.members[new_nick] = user\n            del channel.members[old_nick]\n            modified_channels.add(channel.name)\n\n    client.dispatch_event(\"NICK\", old_nick, new_nick)\n    for channel in modified_channels:\n        client.dispatch_event(\"MEMBERS\", channel)", "response": "Parse a NICK response and update state and dispatch events."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse an INVITE and dispatch an event.", "response": "def _parse_invite(client, command, actor, args):\n    \"\"\"Parse an INVITE and dispatch an event.\"\"\"\n    target, _, channel = args.rpartition(\" \")\n    client.dispatch_event(\"INVITE\", actor, target, channel.lower())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a NICKNAMEINUSE message and dispatch an event.", "response": "def _parse_nicknameinuse(client, command, actor, args):\n    \"\"\"Parse a NICKNAMEINUSE message and dispatch an event.\n\n    The parameter passed along with the event is the nickname\n    which is already in use.\n    \"\"\"\n    nick, _, _ = args.rpartition(\" \")\n    client.dispatch_event(\"NICKNAMEINUSE\", nick)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_user(self, user):\n        if not isinstance(user, User):\n            user = User(user)\n        if user.nick in self.members:\n            _log.warning(\"Ignoring request to add user '%s' to channel '%s' \"\n                         \"because that user is already in the member list.\",\n                         user, self.name)\n            return\n        self.members[user.nick] = user\n        _log.debug(\"Added '%s' to channel '%s'\", user, self.name)", "response": "Adds a user to the channel."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a handler for a particular event.", "response": "def add_handler(self, event, handler):\n        \"\"\"Adds a handler for a particular event.\n\n        Handlers are appended to the list, so a handler added earlier\n        will be called before a handler added later. If you wish to\n        insert a handler at another position, you should modify the\n        event_handlers property directly:\n\n            my_client.event_handlers['PRIVMSG'].insert(0, my_handler)\n        \"\"\"\n        if event not in self.event_handlers:\n            _log.info(\"Adding event handler for new event %s.\", event)\n            self.event_handlers[event] = [handler]\n        else:\n            self.event_handlers[event].append(handler)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndispatch an event. Returns a boolean indicating whether or not a handler is suppressed.", "response": "def dispatch_event(self, event, *args):\n        \"\"\"Dispatches an event.\n\n        Returns a boolean indicating whether or not a handler\n        suppressed further handling of the event (even the last).\n        \"\"\"\n        if event not in self.event_handlers:\n            _log.error(\"Dispatch requested for unknown event '%s'\", event)\n            return False\n        elif event != \"LINE\":\n            _log.debug(\"Dispatching event %s %r\", event, args)\n\n        try:\n            for handler in self.event_handlers[event]:\n                # (client, server, *args) : args are dependent on event\n                if handler(self, *args):\n                    # Returning a truthy value supresses further handlers\n                    # for this event.\n                    return True\n        except Exception as e:\n            _log.exception(\"Error while processing event '%s': %r\", event, e)\n\n        # Fall back to the RAWLINE event if LINE can't process it.\n        if event == \"LINE\":\n            return self.dispatch_event(\"RAWLINE\", *args)\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconnects to the server using the specified credentials.", "response": "def connect(self, nick, username=None, realname=None, password=None,\n                host=None, port=6667, ssl=None):\n        \"\"\"Connect to the server using the specified credentials.\n\n        Note: if host is specified here, both the host and port arguments\n        passed to Client.__init__ will be ignored.\n\n        If the 'ssl' argument is boolean true, will use SSL. If it is a\n        dictionary, will both use SSL and pass the contents as kwargs to\n        the ssl.wrap_socket() call.\n        \"\"\"\n        if host:\n            self.server = Host(host, port)\n        if self.server is None:\n            _log.error(\"Can't connect() without a host specified.\")\n            return\n        self.user = User(nick)\n        self.user.username = username or nick\n        self.user.realname = realname or username or nick\n\n        _log.info(\"Connecting to %s as %s ...\", self.server.host, nick)\n\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        if ssl and _ssl:\n            ssl_kwargs = ssl if isinstance(ssl, dict) else {}\n            self.socket = _ssl.wrap_socket(self.socket, **ssl_kwargs)\n        elif ssl:\n            _log.error(\"SSL requested but no SSL support available!\")\n            return\n\n        self.socket.connect((self.server.host, self.server.port))\n        self.connected = True\n\n        _log.info(\"Connected to %s.\", self.server.host)\n\n        # Allow an event handler to supply a password instead, if it wants\n        suppress_password = self.dispatch_event(\"PASSWORD\")\n\n        if password and not suppress_password:\n            # We bypass our own send() function here to avoid logging passwords\n            _log.info(\"Sending server password.\")\n            self.socket.send(\"PASS %s\\r\\n\" % password)\n            self.server.password = password\n\n        self.dispatch_event('CONNECTED')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\n        self._stop = False # Allow re-starting the event loop\n        while not self._stop:\n            try:\n                self._buffer += self.socket.recv(4096)\n            except socket.error:\n                raise\n\n            lines = self._buffer.split(\"\\n\")\n            self._buffer = lines.pop() # Last line may not have been fully read\n            for line in lines:\n                line = line.rstrip(\"\\r\")\n                _log.debug(\"%s --> %s\", self.server.host, line)\n                self.dispatch_event(\"LINE\", line)\n                self.dispatch_event(\"ACTIVITY\")", "response": "This method blocks indefinitely. It will block until the event loop is stopped."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a single raw message to the IRC server.", "response": "def send(self, *args):\n        \"\"\"Sends a single raw message to the IRC server.\n\n        Arguments are automatically joined by spaces. No newlines are allowed.\n        \"\"\"\n        msg = \" \".join(a.nick if isinstance(a, User) else str(a) for a in args)\n        if \"\\n\" in msg:\n            raise ValueError(\"Cannot send() a newline. Args: %s\" % repr(args))\n        _log.debug(\"%s <-- %s\", self.server.host, msg)\n        self.socket.send(msg + \"\\r\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the username and realname for this connection.", "response": "def userinfo(self, username, realname=None):\n        \"\"\"Set the username and realname for this connection.\n\n        Note: this should only be called once, on connect. (The default\n        on-connect routine calls this automatically.)\n        \"\"\"\n        realname = realname or username\n\n        _log.info(\"Requesting user info update: username=%s realname=%s\",\n            username, realname)\n\n        self.send(\"USER\", username, socket.getfqdn(), self.server.host,\n            \":%s\" % realname) # Realname should always be prefixed by a colon\n        self.user.username = username\n        self.user.realname = realname"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplies to a user in a given channel or PM.", "response": "def reply(self, incoming, user, message, prefix=None):\n        \"\"\"Replies to a user in a given channel or PM.\n\n        If the specified incoming is a user, simply sends a PM to user.\n        If the specified incoming is a channel, prefixes the message with the\n        user's nick and sends it to the channel.\n\n        This is specifically useful in creating responses to commands that can\n        be used in either a channel or in a PM, and responding to the person\n        who invoked the command.\n        \"\"\"\n        if not isinstance(user, User):\n            user = User(user)\n\n        if isinstance(incoming, User):\n            if prefix:\n                self.msg(user, \"%s: %s\" % (user.nick, message))\n            else:\n                self.msg(user, message)\n        else:\n            if prefix is not False:\n                self.msg(incoming, \"%s: %s\" % (user.nick, message))\n            else:\n                self.msg(incoming, message)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef join(self, target, key=None):\n        chantypes = self.server.features.get(\"CHANTYPES\", \"#\")\n        if not target or target[0] not in chantypes:\n            # Among other things, this prevents accidentally sending the\n            # \"JOIN 0\" command which actually removes you from all channels\n            _log.warning(\"Refusing to join channel that does not start \"\n                         \"with one of '%s': %s\", chantypes, target)\n            return False\n\n        if self.server.in_channel(target):\n            _log.warning(\"Ignoring request to join channel '%s' because we \"\n                         \"are already in that channel.\", target)\n            return False\n\n        _log.info(\"Joining channel %s ...\", target)\n        self.send(\"JOIN\", target, *([key] if key else []))\n        return True", "response": "Attempt to join a channel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nattempt to kick a user from a channel.", "response": "def kick(self, channel, nick, message=None):\n        \"\"\"Attempt to kick a user from a channel.\n\n        If a message is not provided, defaults to own nick.\n        \"\"\"\n        self.send(\"KICK\", channel, nick, \":%s\" % (message or self.user.nick))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of modes and sets the user privilege levels for a given channel.", "response": "def mode(self, channel, add='', remove=''):\n        \"\"\"Add and/or remove modes for a given channel.\n\n        The 'add' and 'remove' arguments may, if specified, be either\n        sequences or dictionaries. If a dictionary is specified, the\n        corresponding values will be passed as arguments (with expansion\n        if necessary - {'b': ['foo','bar']} will result in two bans:\n            MODE <channel> +bb foo bar\n\n        (Values for modes which do not take arguments are ignored.)\n        \"\"\"\n        if not self.server.in_channel(channel):\n            _log.warning(\"Ignoring request to set modes in channel '%s' \"\n                         \"because we are not in that channel.\", channel)\n            return\n\n        chanmodes = self._get_chanmodes()\n        list_modes, always_arg_modes, set_arg_modes, toggle_modes = chanmodes\n        # User privilege levels are not always included in channel modes list\n        always_arg_modes |= set(self._get_prefixes().itervalues())\n\n        def _arg_to_list(arg, argument_modes, toggle_modes):\n            if not isinstance(arg, dict):\n                modes = set(arg)\n                invalid_modes = modes - toggle_modes\n                if invalid_modes:\n                    _log.warning(\"Ignoring the mode(s) '%s' because they are \"\n                                 \"missing required arguments.\",\n                                 \"\".join(invalid_modes))\n                return modes & toggle_modes, []\n\n            # Okay, so arg is a dict\n            modes_with_args = []\n            modes_without_args = set()\n            for k,v in arg.iteritems():\n                if isinstance(v, str):\n                    v = [v]\n                if k in argument_modes:\n                    for val in v:\n                        modes_with_args.append((k,val))\n                elif k in toggle_modes:\n                    modes_without_args.add(k)\n                else:\n                    _log.warning(\"Ignoring request to set channel mode '%s' \"\n                                 \"because it is not a recognized mode.\", k)\n            return modes_without_args, modes_with_args\n\n        add_modes, add_modes_args = _arg_to_list(\n            add, list_modes | always_arg_modes | set_arg_modes, toggle_modes)\n        remove_modes, remove_modes_args = _arg_to_list(\n            remove, list_modes | always_arg_modes, set_arg_modes | toggle_modes)\n\n        max_arg = self.server.features.get(\"MODES\") or 3\n\n        def _send_modes(op, toggle_modes, arg_modes):\n            while toggle_modes or arg_modes:\n                modes = \"\".join(toggle_modes)\n                toggle_modes = \"\"\n                now_modes, arg_modes = arg_modes[:max_arg], arg_modes[max_arg:]\n                modes += \"\".join(mode for mode,arg in now_modes)\n                modes += \"\".join(\" %s\" % arg for mode,arg in now_modes)\n                self.send(\"MODE\", channel, \"%s%s\" % (op, modes))\n\n        _send_modes(\"+\", add_modes, add_modes_args)\n        _send_modes(\"-\", remove_modes, remove_modes_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle(self, event):\n        def dec(func):\n            self.add_handler(event, func)\n            return func\n        return dec", "response": "Decorator for adding a handler function for a particular event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_prefixes(self):\n        prefixes = {\n            \"@\": \"o\",\n            \"+\": \"v\",\n        }\n        feature_prefixes = self.server.features.get('PREFIX')\n        if feature_prefixes:\n            modes = feature_prefixes[1:len(feature_prefixes)//2]\n            symbols = feature_prefixes[len(feature_prefixes)//2+1:]\n            prefixes = dict(zip(symbols, modes))\n        return prefixes", "response": "Get the possible nick prefixes and associated modes for a client."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns default mdata map for Asset", "response": "def get_asset_mdata():\n    \"\"\"Return default mdata map for Asset\"\"\"\n    return {\n        'copyright_registration': {\n            'element_label': {\n                'text': 'copyright registration',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter no more than 256 characters.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [''],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 256,\n            'string_set': [],\n        },\n        'copyright': {\n            'element_label': {\n                'text': 'copyright',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter no more than 256 characters.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 256,\n            'string_set': [],\n        },\n        'title': {\n            'element_label': {\n                'text': 'title',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter no more than 256 characters.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 256,\n            'string_set': [],\n        },\n        'distribute_verbatim': {\n            'element_label': {\n                'text': 'distribute verbatim',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'created_date': {\n            'element_label': {\n                'text': 'created date',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid datetime object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_date_time_values': [None],\n            'syntax': 'DATETIME',\n            'date_time_set': [],\n        },\n        'distribute_alterations': {\n            'element_label': {\n                'text': 'distribute alterations',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'principal_credit_string': {\n            'element_label': {\n                'text': 'principal credit string',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter no more than 256 characters.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 256,\n            'string_set': [],\n        },\n        'published_date': {\n            'element_label': {\n                'text': 'published date',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid datetime object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_date_time_values': [None],\n            'syntax': 'DATETIME',\n            'date_time_set': [],\n        },\n        'source': {\n            'element_label': {\n                'text': 'source',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'provider_links': {\n            'element_label': {\n                'text': 'provider links',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id[] object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_id_values': [],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'public_domain': {\n            'element_label': {\n                'text': 'public domain',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'distribute_compositions': {\n            'element_label': {\n                'text': 'distribute compositions',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'composition': {\n            'element_label': {\n                'text': 'composition',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'published': {\n            'element_label': {\n                'text': 'published',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn default mdata map for AssetContent", "response": "def get_asset_content_mdata():\n    \"\"\"Return default mdata map for AssetContent\"\"\"\n    return {\n        'url': {\n            'element_label': {\n                'text': 'url',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter no more than 256 characters.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [''],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 256,\n            'string_set': [],\n        },\n        'data': {\n            'element_label': {\n                'text': 'data',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts a valid data input stream.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [''],\n            'syntax': 'OBJECT',\n            'object_types': [],\n            'object_set': [],\n        },\n        'accessibility_type': {\n            'element_label': {\n                'text': 'accessibility type',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.type.Type object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_type_values': ['NoneType%3ANONE%40dlkit.mit.edu'],\n            'syntax': 'TYPE',\n            'type_set': [],\n        },\n        'asset': {\n            'element_label': {\n                'text': 'asset',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning default mdata map for Composition", "response": "def get_composition_mdata():\n    \"\"\"Return default mdata map for Composition\"\"\"\n    return {\n        'children': {\n            'element_label': {\n                'text': 'children',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id[] object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_id_values': [],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _compute_raw_moments(self, n_counter, k_counter):\n\n        # The symbols for expectations are simply the first order raw moments.\n        \"\"\"\n        :param n_counter: a list of :class:`~means.core.descriptors.Moment`\\s representing central moments\n        :type n_counter: list[:class:`~means.core.descriptors.Moment`]\n        :param k_counter: a list of :class:`~means.core.descriptors.Moment`\\s representing raw moments\n        :type k_counter: list[:class:`~means.core.descriptors.Moment`]\n        :return: a vector of parametric expression for raw moments\n        \"\"\"\n        expectation_symbols = [pm.symbol for pm in k_counter if pm.order == 1]\n\n        n_species = len(expectation_symbols)\n\n        # The covariance expressed in terms of central moment symbols (typically, yxNs, where N is an integer)\n        covariance_matrix = sp.Matrix(n_species,n_species, lambda x,y: self._get_covariance_symbol(n_counter,x,y))\n\n        # Variances is the diagonal of covariance matrix\n        variance_symbols = [covariance_matrix[i, i] for i in range(n_species)]\n\n        # :math: '\\logVar(x_i) = 1 + \\frac { Var(x_i)}{ \\mathbb{E} (x_i)^2}'\n        log_variance_symbols = sp.Matrix([sp.log(sp.Integer(1) + v/(e ** sp.Integer(2))) for e,v\n                                          in zip(expectation_symbols, variance_symbols)])\n\n        # :math: '\\log\\mathbb{E} (x_i) = \\log(\\mathbb{E} (x_i) )+ \\frac {\\log (Var(x_i))}{2}'\n        log_expectation_symbols = sp.Matrix([sp.log(e) - lv/sp.Integer(2) for e,lv\n                                             in zip(expectation_symbols, log_variance_symbols)])\n\n        # Assign log variance symbols on the diagonal of size n_species by n_species\n        log_variance_mat = sp.Matrix(n_species,n_species, lambda x,y: log_variance_symbols[x] if x == y else 0)\n\n        # Assign log covariances and log variances in the matrix log_covariance matrix based on matrix indices\n        log_covariance_matrix = sp.Matrix(n_species,n_species, lambda x, y:\n                self._get_log_covariance(log_variance_mat, log_expectation_symbols, covariance_matrix, x, y))\n\n        # The n_vectors (e.g. [0,2,0]) of the central moments\n        pm_n_vecs = [sp.Matrix(pm.n_vector) for pm in n_counter if pm.order > 1]\n\n\n        out_mat = sp.Matrix([n.T * (log_covariance_matrix * n) / sp.Integer(2) + n.T * log_expectation_symbols for n in pm_n_vecs])\n        # return the exponential of all values\n\n        out_mat = out_mat.applyfunc(lambda x: sp.exp(x))\n        return out_mat", "response": "Compute the raw moments for the given set of central moments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npassing through to provider AssessmentPartSearchSession. get_assessment_parts_by_search", "response": "def get_assessment_parts_by_search(self, assessment_part_query, assessment_part_search):\n        \"\"\"Pass through to provider AssessmentPartSearchSession.get_assessment_parts_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_assessment_parts_by_search(assessment_part_query, assessment_part_search)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npass through to provider SequenceRuleSearchSession. get_sequence_rules_by_search", "response": "def get_sequence_rules_by_search(self, sequence_rule_query, sequence_rule_search):\n        \"\"\"Pass through to provider SequenceRuleSearchSession.get_sequence_rules_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_sequence_rules_by_search(sequence_rule_query, sequence_rule_search)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider SequenceRuleEnablerSearchSession. get_sequence_rule_enablers_by_search", "response": "def get_sequence_rule_enablers_by_search(self, sequence_rule_enabler_query, sequence_rule_enabler_search):\n        \"\"\"Pass through to provider SequenceRuleEnablerSearchSession.get_sequence_rule_enablers_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_sequence_rule_enablers_by_search(sequence_rule_enabler_query, sequence_rule_enabler_search)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef image_name(self):\n        if getattr(self, \"_image_name\", NotSpecified) is NotSpecified:\n            self._image_name = self.prefixed_image_name\n\n            if self.image_index:\n                self._image_name = \"{0}{1}\".format(self.image_index, self._image_name)\n\n            if \"EXTRA_IMAGE_NAME\" in os.environ:\n                self._image_name = \"{0}{1}\".format(self._image_name, os.environ[\"EXTRA_IMAGE_NAME\"])\n        return self._image_name", "response": "Returns the name of the image that is used for the container."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef container_name(self):\n        if getattr(self, \"_container_name\", NotSpecified) is NotSpecified:\n            self.container_name = \"{0}-{1}\".format(self.image_name.replace(\"/\", \"--\").replace(\":\", \"---\"), str(uuid.uuid1()).lower())\n        return self._container_name", "response": "Returns the name of the image that is used to create the container."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef container_id(self):\n        if getattr(self, \"_container_id\", None):\n            return self._container_id\n\n        try:\n            containers = self.harpoon.docker_api.containers(all=True)\n        except ValueError:\n            log.warning(\"Failed to get a list of active docker files\")\n            containers = []\n\n        self._container_id = None\n        for container in containers:\n            if any(self.name in container.get(\"Names\", []) for name in (self.container_name, \"/{0}\".format(self.container_name))):\n                self._container_id = container[\"Id\"]\n                break\n\n        return self._container_id", "response": "Find a container id based on the name of the container"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef formatted_command(self):\n        bash = self.bash\n        if bash not in (None, \"\", NotSpecified) and callable(bash):\n            bash = bash()\n        if bash not in (None, \"\", NotSpecified):\n            return \"{0} -c {1}\".format(self.resolved_shell, shlex_quote(bash))\n\n        command = self.command\n        if command not in (None, \"\", NotSpecified) and callable(command):\n            command = command()\n        if command not in (None, \"\", NotSpecified):\n            return command\n\n        return None", "response": "Returns the command to use for this command."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dependencies(self, images):\n        for dep in self.commands.dependent_images:\n            if not isinstance(dep, six.string_types):\n                yield dep.name\n\n        for image, _ in self.dependency_images():\n            yield image", "response": "Yield just the dependency images"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding the image names to do -- cache - from from", "response": "def cache_from_names(self):\n        \"\"\"Yield the image names to do --cache-from from\"\"\"\n        cache_from = self.cache_from()\n\n        if not cache_from or cache_from is NotSpecified:\n            return\n\n        if cache_from is True:\n            yield self.image_name\n            return\n\n        for thing in cache_from:\n            if not isinstance(thing, six.string_types):\n                yield thing.image_name\n            else:\n                yield thing"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nyielding the names of all images that are needed by this command.", "response": "def dependency_images(self, for_running=False):\n        \"\"\"\n        What images does this one require\n\n        Taking into account parent image, and those in link and volumes.share_with options\n        \"\"\"\n        candidates = []\n        detach = dict((candidate, not options.attached) for candidate, options in self.dependency_options.items())\n\n        for link in self.links:\n            if link.container:\n                candidates.append(link.container.name)\n\n        if not for_running:\n            for content, _ in self.commands.extra_context:\n                if type(content) is dict or (hasattr(content, \"is_dict\") and content.is_dict) and \"image\" in content:\n                    if not isinstance(content[\"image\"], six.string_types):\n                        candidates.append(content[\"image\"].name)\n\n        candidates.extend(list(self.shared_volume_containers()))\n\n        done = []\n        for candidate in candidates:\n            if candidate not in done:\n                done.append(candidate)\n                yield candidate, detach.get(candidate, True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_missing_env(self):\n        missing = []\n        for e in self.env:\n            if e.default_val is None and e.set_val is None:\n                if e.env_name not in os.environ:\n                    missing.append(e.env_name)\n\n        if missing:\n            raise BadOption(\"Some environment variables aren't in the current environment\", missing=missing)", "response": "Find any missing environment variables"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef display_line(self):\n        msg = [\"Image {0}\".format(self.name)]\n        if self.image_index:\n            msg.append(\"Pushes to {0}\".format(self.image_name))\n        return ' : '.join(msg)", "response": "A single line describing this image"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_and_run(self, images):\n        from harpoon.ship.builder import Builder\n        Builder().make_image(self, images)\n\n        try:\n            Runner().run_container(self, images)\n        except DockerAPIError as error:\n            raise BadImage(\"Failed to start the container\", error=error)", "response": "Make this image and run it"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_docker_file_to_tarfile(self, docker_file, tar):\n        with hp.a_temp_file() as dockerfile:\n            log.debug(\"Context: ./Dockerfile\")\n            dockerfile.write(\"\\n\".join(docker_file.docker_lines).encode('utf-8'))\n            dockerfile.seek(0)\n            tar.add(dockerfile.name, arcname=\"./Dockerfile\")", "response": "Add a Dockerfile to a tarfile"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_context(self, docker_file=None):\n        kwargs = {\"silent_build\": self.harpoon.silent_build, \"extra_context\": self.commands.extra_context}\n        if docker_file is None:\n            docker_file = self.docker_file\n        with ContextBuilder().make_context(self.context, **kwargs) as ctxt:\n            self.add_docker_file_to_tarfile(docker_file, ctxt.t)\n            yield ctxt", "response": "Create a context for this image"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield the lines to execute in a docker context that can be used to execute a container.", "response": "def conditions(self, start, last_attempt):\n        \"\"\"\n        Yield lines to execute in a docker context\n\n        All conditions must evaluate for the container to be considered ready\n        \"\"\"\n        if time.time() - start > self.timeout:\n            yield WaitCondition.Timedout\n            return\n\n        if last_attempt is not None and time.time() - last_attempt < self.wait_between_attempts:\n            yield WaitCondition.KeepWaiting\n            return\n\n        if self.greps is not NotSpecified:\n            for name, val in self.greps.items():\n                yield 'grep \"{0}\" \"{1}\"'.format(val, name)\n\n        if self.file_value is not NotSpecified:\n            for name, val in self.file_value.items():\n                command = 'diff <(echo {0}) <(cat {1})'.format(val, name)\n                if not self.harpoon.debug:\n                    command = \"{0} > /dev/null\".format(command)\n                yield command\n\n        if self.port_open is not NotSpecified:\n            for port in self.port_open:\n                yield 'nc -z 127.0.0.1 {0}'.format(port)\n\n        if self.curl_result is not NotSpecified:\n            for url, content in self.curl_result.items():\n                yield 'diff <(curl \"{0}\") <(echo {1})'.format(url, content)\n\n        if self.file_exists is not NotSpecified:\n            for path in self.file_exists:\n                yield 'cat {0} > /dev/null'.format(path)\n\n        if self.command not in (None, \"\", NotSpecified):\n            for command in self.command:\n                yield command"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the root git folder of the class.", "response": "def git_root(self):\n        \"\"\"\n        Find the root git folder\n        \"\"\"\n        if not getattr(self, \"_git_folder\", None):\n            root_folder = os.path.abspath(self.parent_dir)\n            while not os.path.exists(os.path.join(root_folder, '.git')):\n                if root_folder == '/':\n                    raise HarpoonError(\"Couldn't find a .git folder\", start_at=self.parent_dir)\n                root_folder = os.path.dirname(root_folder)\n            self._git_folder = root_folder\n        return self._git_folder"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pair(self):\n        if self.set_val is not None:\n            return self.env_name, self.set_val\n        elif self.default_val is not None:\n            return self.env_name, os.environ.get(self.env_name, self.default_val)\n        else:\n            return self.env_name, os.environ[self.env_name]", "response": "Get the name and value for this environment variable"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pair(self):\n        if self.ip is NotSpecified:\n            if self.ip is NotSpecified:\n                second = self.host_port\n            else:\n                second = (self.ip, )\n        else:\n            second = (self.ip, self.host_port)\n        return self.container_port.port_str, second", "response": "return the container_port and host_port for this instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_distance_function(distance):\n    # If we provided distance function ourselves, use it\n    if callable(distance):\n        return distance\n    try:\n        return _supported_distances_lookup()[distance]\n    except KeyError:\n        raise KeyError('Unsupported distance function {0!r}'.format(distance.lower()))", "response": "Returns the distance function from the string name provided\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the sum - of - squares distance between the simulated and observed trajectories.", "response": "def sum_of_squares(simulated_trajectories, observed_trajectories_lookup):\n    \"\"\"\n    Returns the sum-of-squares distance between the simulated_trajectories and observed_trajectories\n\n    :param simulated_trajectories: Simulated trajectories\n    :type simulated_trajectories: list[:class:`means.simulation.Trajectory`]\n    :param observed_trajectories_lookup: A dictionary of (trajectory.description: trajectory) of observed trajectories\n    :type observed_trajectories_lookup: dict\n    :return: the distance between simulated and observed trajectories\n    :rtype: float\n    \"\"\"\n    dist = 0\n    for simulated_trajectory in simulated_trajectories:\n        observed_trajectory = None\n        try:\n            observed_trajectory = observed_trajectories_lookup[simulated_trajectory.description]\n        except KeyError:\n            continue\n\n        deviations = observed_trajectory.values - simulated_trajectory.values\n        # Drop NaNs arising from missing datapoints\n        deviations = deviations[~np.isnan(deviations)]\n\n        dist += np.sum(np.square(deviations))\n\n    return dist"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the distance between the simulated and observed trajectories w. r. t. the assumed distribution", "response": "def _distribution_distance(simulated_trajectories, observed_trajectories_lookup, distribution):\n    \"\"\"\n    Returns the distance between the simulated and observed trajectory, w.r.t. the assumed distribution\n\n    :param simulated_trajectories: Simulated trajectories\n    :type simulated_trajectories: list[:class:`means.simulation.Trajectory`]\n    :param observed_trajectories_lookup: A dictionary of (trajectory.description: trajectory) of observed trajectories\n    :type observed_trajectories_lookup: dict\n    :param distribution: Distribution to use. See :func:`_eval_density` for the list of available distributions\n    :return:\n    \"\"\"\n\n    mean_variance_lookup = _compile_mean_variance_lookup(simulated_trajectories)\n\n    # get moment expansion result with current parameters\n    log_likelihood = 0\n\n    for trajectory in observed_trajectories_lookup.itervalues():\n        moment = trajectory.description\n        assert(isinstance(moment, Moment))\n        assert(moment.order == 1)\n\n        species = np.where(moment.n_vector == 1)[0][0]\n        mean_variance = mean_variance_lookup[species]\n        if (mean_variance.mean < 0).any() or (mean_variance.variance < 0).any():\n            return float('inf')\n\n        term = _eval_density(mean_variance.mean, mean_variance.variance, trajectory.values, distribution)\n        log_likelihood += term\n\n    dist = -log_likelihood\n    return dist"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _eval_density(means, variances,observed_values, distribution):\n    means = np.array(means, dtype=NP_FLOATING_POINT_PRECISION)\n    variances = np.array(variances, dtype=NP_FLOATING_POINT_PRECISION)\n    observed_values = np.array(observed_values, dtype=NP_FLOATING_POINT_PRECISION)\n\n    # Remove data about unobserved datapoints\n    means = means[~np.isnan(observed_values)]\n    variances = variances[~np.isnan(observed_values)]\n    observed_values = observed_values[~np.isnan(observed_values)]\n\n    # Remove data for when variance is zero as we cannot estimate distributions that way\n    non_zero_varianes = ~(variances == 0)\n    means = means[non_zero_varianes]\n    variances = variances[~(variances == 0)]\n    observed_values = observed_values[non_zero_varianes]\n\n    if distribution == 'gamma':\n        b = variances / means\n        a = means / b\n\n        log_observed_values = np.log(observed_values)\n        log_density = (a - 1.0) * log_observed_values - (observed_values / b) - a * np.log(b) - gammaln(a)\n    elif distribution == 'normal':\n        log_density = -(observed_values - means) ** 2 / (2 * variances) - np.log(np.sqrt(2 * np.pi * variances))\n\n    elif distribution == 'lognormal':\n        log_density = -(np.log(observed_values) - means) ** 2 / (2 * variances) - np.log(observed_values * np.sqrt(2 * np.pi * variances))\n    else:\n        raise ValueError('Unsupported distribution {0!r}'.format(distribution))\n\n    total_log_density = np.sum(log_density)\n    return total_log_density", "response": "Calculates gamma lognormal pdf given mean variance observed_values and distribution"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a SpigotAuthor object via their id or username.", "response": "def retrieve_author(id=None, username=None):\n    \"\"\"\n    Retrieve a SpigotAuthor via their id, or username.\n    :param id:\n    :param username:\n    :return:\n    \"\"\"\n\n    if id is None and username is None:\n        raise SpigotAuthorException(\"Unable to retrieve an Author without an Identifier\")\n\n    if id is None:\n        return SpigotAuthor.from_username(username)\n    else:\n        return SpigotAuthor.from_id(id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _escape_identifiers(self, item):\n        if self._escape_char == '':\n            return item\n\n        for field in self._reserved_identifiers:\n            if item.find('.%s' % field) != -1:\n                _str = \"%s%s\" % (self._escape_char, item.replace('.', '%s.' % self._escape_char))\n                # remove duplicates if the user already included the escape\n                return re.sub(r'[%s]+'%self._escape_char, self._escape_char, _str)\n\n        if item.find('.') != -1:\n            _str = \"%s%s%s\" % (self._escape_char, item.replace('.', '%s.%s'%(self._escape_char, self._escape_char)),\n            self._escape_char)\n        else:\n            _str = self._escape_char+item+self._escape_char\n        # remove duplicates if the user already included the escape\n        return re.sub(r'[%s]+'%self._escape_char, self._escape_char, _str)", "response": "This function escapes column and table names\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a node from the cache.", "response": "def get(self, uri):\n        \"\"\"\n        Return node for uri or None if not exists:\n            {uri: x, content: y}\n        \"\"\"\n        cache_key = self._build_cache_key(uri)\n        value = self._get(cache_key)\n        if value is not None:\n            return self._decode_node(uri, value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of all found nodes and their attributes.", "response": "def get_many(self, uris):\n        \"\"\"\n        Return request uri map of found nodes as dicts:\n            {requested_uri: {uri: x, content: y}}\n        \"\"\"\n        cache_keys = dict((self._build_cache_key(uri), uri) for uri in uris)\n        result = self._get_many(cache_keys)\n        nodes = {}\n        for cache_key in result:\n            uri = cache_keys[cache_key]\n            value = result[cache_key]\n            node = self._decode_node(uri, value)\n            if node:\n                nodes[uri] = node\n        return nodes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the content for uri.", "response": "def set(self, uri, content):\n        \"\"\"\n        Cache node content for uri.\n        No return.\n        \"\"\"\n        key, value = self._prepare_node(uri, content)\n        self._set(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the set of many entries in the cache.", "response": "def set_many(self, nodes):\n        \"\"\"\n        Takes nodes dict {uri: content, ...} as argument.\n        No return.\n        \"\"\"\n        data = self._prepare_nodes(nodes)\n        self._set_many(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove node uri from cache.", "response": "def delete(self, uri):\n        \"\"\"\n        Remove node uri from cache.\n        No return.\n        \"\"\"\n        cache_key = self._build_cache_key(uri)\n        self._delete(cache_key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves many nodes from cache. No return.", "response": "def delete_many(self, uris):\n        \"\"\"\n        Remove many nodes from cache.\n        No return.\n        \"\"\"\n        cache_keys = (self._build_cache_key(uri) for uri in uris)\n        self._delete_many(cache_keys)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds sha1 hex cache key to handle key length and whitespace to be compatible with Memcached", "response": "def _build_cache_key(self, uri):\n        \"\"\"\n        Build sha1 hex cache key to handle key length and whitespace to be compatible with Memcached\n        \"\"\"\n        key = uri.clone(ext=None, version=None)\n\n        if six.PY3:\n            key = key.encode('utf-8')\n\n        return sha1(key).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndispatching private update and create handlers is a private method that returns True if the node was created False otherwise.", "response": "def set(self, uri, content, **meta):\n        \"\"\"\n        Dispatches private update/create handlers\n        \"\"\"\n        try:\n            node = self._update(uri, content, **meta)\n            created = False\n        except NodeDoesNotExist:\n            node = self._create(uri, content, **meta)\n            created = True\n        return self._serialize(uri, node), created"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _serialize(self, uri, node):\n        meta = self._decode_meta(node['meta'], is_published=bool(node['is_published']))\n        return {\n            'uri': uri.clone(ext=node['plugin'], version=node['version']),\n            'content': node['content'],\n            'meta': meta\n        }", "response": "Serialize node result as dict\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _decode_meta(self, meta, **extra):\n        _meta = json.loads(meta) if meta else {}\n        _meta.update(extra)\n        return _meta", "response": "Decode and load underlying meta structure to dict and apply optional extra values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmerging new meta dict into encoded meta. Returns new meta dict.", "response": "def _merge_meta(self, encoded_meta, meta):\n        \"\"\"\n        Merge new meta dict into encoded meta. Returns new encoded meta.\n        \"\"\"\n        new_meta = None\n\n        if meta:\n            _meta = self._decode_meta(encoded_meta)\n            for key, value in six.iteritems(meta):\n                if value is None:\n                    _meta.pop(key, None)\n                else:\n                    _meta[key] = value\n            new_meta = self._encode_meta(_meta)\n\n        return new_meta"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_next_version(self, revisions):\n        versions = [0]\n        for v in revisions:\n            if v.isdigit():\n                versions.append(int(v))\n        return six.text_type(sorted(versions)[-1] + 1)", "response": "Calculates the next version number based on existing numeric ones."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_one_over_n_factorial(counter_entry):\n    # compute all factorials\n    factos = [sp.factorial(c) for c in counter_entry]\n    # multiply them\n    prod = product(factos)\n    # return the invert\n    return sp.Integer(1)/sp.S(prod)", "response": "r Calculates the one over n factorials of the given counter_entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the k - chose E", "response": "def make_k_chose_e(e_vec, k_vec):\n    \"\"\"\n    Computes the product :math:`{\\mathbf{n} \\choose \\mathbf{k}}`\n\n    :param e_vec: the vector e\n    :type e_vec: :class:`numpy.array`\n    :param k_vec: the vector k\n    :type k_vec: :class:`numpy.array`\n    :return: a scalar\n    \"\"\"\n    return product([sp.factorial(k) / (sp.factorial(e) * sp.factorial(k - e)) for e,k in zip(e_vec, k_vec)])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_transcript(self,tx_id):\n    txs = self.get_transcripts()\n    if tx_id not in [x.id for x in txs]:\n      return\n    tx = [x for x in txs if x.id==tx_id][0]\n    for n in [x for x in self.g.get_nodes()]:\n      if tx_id not in [y.id for y in n.payload]:\n        continue\n      n.payload.remove(tx)\n      if len(n.payload)==0:\n        self.g.remove_node(n)", "response": "Removes a transcript from the locus by its id\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_depth_per_transcript(self,mindepth=1):\n    bedarray = []\n    for tx in self.get_transcripts():\n      for ex in [x.range for x in tx.exons]: bedarray.append(ex)\n    cov = ranges_to_coverage(bedarray)\n    results = {}\n    for tx in self.get_transcripts():\n      tlen = tx.length #mapped length\n      bcov = []\n      for ex in [x.range for x in tx.exons]:     \n        excov = [[x.overlap_size(ex),x.payload] for x in cov]\n        for coved in [x for x in excov if x[0] > 0]:\n          bcov.append(coved)\n      total_base_coverage = sum([x[0]*x[1] for x in bcov])\n      average_coverage = float(total_base_coverage)/float(tlen)\n      minimum_bases_covered = sum([x[0] for x in bcov if x[1] >= mindepth])\n      fraction_covered_at_minimum = float(minimum_bases_covered)/float(tlen)\n      res = {'tx':tx,'average_coverage':average_coverage,'fraction_covered':fraction_covered_at_minimum,'mindepth':mindepth,'length_covered':minimum_bases_covered}\n      results[tx.id] = res\n      #print average_coverage\n      #print fraction_covered_at_minimum\n      #print tlen\n      #tcov = float(bcov)/float(tlen)\n      #print tcov\n    #for c in cov:\n    #  print c\n    return results", "response": "find the depth per transcript"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef range(self):\n    chrs = set([x.range.chr for x in self.get_transcripts()])\n    if len(chrs) != 1: return None\n    start = min([x.range.start for x in self.get_transcripts()])\n    end = max([x.range.end for x in self.get_transcripts()])\n    return GenomicRange(list(chrs)[0],start,end)", "response": "Return the range the transcript loci covers\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_transcripts(self):\n    txs = []\n    for pays in [x.payload for x in self.g.get_nodes()]:\n      for pay in pays:\n        txs.append(pay)\n    return txs", "response": "a list of the transcripts in the locus"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef partition_loci(self,verbose=False):\n    self.g.merge_cycles()\n    #sys.stderr.write(self.g.get_report()+\"\\n\")\n    gs = self.g.partition_graph(verbose=verbose)\n    tls = [] # makea list of transcript loci\n    for g in gs:\n      tl = TranscriptLoci()\n      tl.merge_rules = self.merge_rules\n      ns = g.get_nodes()\n      for n in [x.payload for x in ns]:\n        for tx in n:\n          tl.add_transcript(tx)\n      if len(tl.g.get_nodes()) > 0:\n        tls.append(tl)\n    #print '-----------------------' \n    #names = []\n    #for tl in tls:\n    #  for tx in tl.get_transcripts():\n    #    names.append(tx.get_gene_name())\n    #for name in sorted(names):\n    #  print name\n    #print '--------------------------'\n    return tls", "response": "break the locus up into unconnected loci"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a transcript to the locus", "response": "def add_transcript(self,tx):\n    \"\"\"Add a transcript to the locus\n\n    :param tx: transcript to add\n    :type tx: Transcript\n    \"\"\"\n    for y in [x.payload for x in self.g.get_nodes()]:\n      if tx.id in [z.id for z in y]:\n        sys.stderr.write(\"WARNING tx is already in graph\\n\")\n        return True\n    # transcript isn't part of graph yet\n    n = seqtools.graph.Node([tx])\n\n    other_nodes = self.g.get_nodes()\n    self.g.add_node(n)\n    # now we need to see if its connected anywhere\n    for n2 in other_nodes:\n     tx2s = n2.payload\n     for tx2 in tx2s:\n      # do exon overlap\n      er = self.merge_rules.get_exon_rules()\n      # if we are doing things by exon\n      if (self.merge_rules.get_use_single_exons() and (tx.get_exon_count() == 1 or tx2.get_exon_count() == 1)) or \\\n         (self.merge_rules.get_use_multi_exons() and (tx.get_exon_count() > 1 and tx2.get_exon_count() > 1)):\n        eo = tx.exon_overlap(tx2,multi_minover=er['multi_minover'],multi_endfrac=er['multi_endfrac'],multi_midfrac=er['multi_midfrac'],single_minover=er['single_minover'],single_frac=er['single_frac'])\n        if self.merge_rules.get_merge_type() == 'is_compatible':\n          if eo.is_compatible():\n            self.g.add_edge(seqtools.graph.Edge(n,n2),verbose=False)\n            self.g.add_edge(seqtools.graph.Edge(n2,n),verbose=False)\n        elif self.merge_rules.get_merge_type() == 'is_subset':\n          r = eo.is_subset()\n          if r == 2 or r == 1:\n            self.g.add_edge(seqtools.graph.Edge(n,n2),verbose=False)\n          if r == 3 or r == 1:\n            self.g.add_edge(seqtools.graph.Edge(n2,n),verbose=False)\n        elif self.merge_rules.get_merge_type() == 'is_full_overlap':\n          if eo.is_full_overlap():\n            self.g.add_edge(seqtools.graph.Edge(n,n2),verbose=False)\n            self.g.add_edge(seqtools.graph.Edge(n2,n),verbose=False)\n        elif self.merge_rules.get_merge_type() == 'is_any_overlap':\n          if eo.match_exon_count() > 0:\n            self.g.add_edge(seqtools.graph.Edge(n,n2),verbose=False)\n            self.g.add_edge(seqtools.graph.Edge(n2,n),verbose=False)        \n            \n      if self.merge_rules.get_use_junctions():\n        # do junction overlap\n        jo = tx.junction_overlap(tx2,self.merge_rules.get_juntol())\n        #print jo.match_junction_count()\n        if self.merge_rules.get_merge_type() == 'is_compatible':\n          if jo.is_compatible():\n            self.g.add_edge(seqtools.graph.Edge(n,n2),verbose=False)\n            self.g.add_edge(seqtools.graph.Edge(n2,n),verbose=False)\n        elif self.merge_rules.get_merge_type() == 'is_subset':\n          r = jo.is_subset()\n          if r == 2 or r == 1:\n            self.g.add_edge(seqtools.graph.Edge(n,n2),verbose=False)\n          if r == 3 or r == 1:\n            self.g.add_edge(Seqtools.graph.Edge(n2,n),verbose=False)\n        elif self.merge_rules.get_merge_type() == 'is_full_overlap':\n          if jo.is_full_overlap():\n            self.g.add_edge(seqtools.graph.Edge(n,n2),verbose=False)\n            self.g.add_edge(seqtools.graph.Edge(n2,n),verbose=False)\n        elif self.merge_rules.get_merge_type() == 'is_any_overlap':\n          if jo.match_junction_count() > 0:\n            self.g.add_edge(seqtools.graph.Edge(n,n2),verbose=False)\n            self.g.add_edge(seqtools.graph.Edge(n2,n),verbose=False)        \n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_transcript(self,exon_bounds='max'):\n    out = Transcript()\n    out.junctions = [x.get_junction() for x in self.junction_groups]\n    # check for single exon transcript\n    if len(out.junctions) == 0:\n      leftcoord = min([x.exons[0].range.start for x in self.transcripts])\n      rightcoord = max([x.exons[-1].range.end for x in self.transcripts])\n      e = Exon(GenomicRange(x.exons[0].range.chr,leftcoord,rightcoord))\n      e.set_is_leftmost()\n      e.set_is_rightmost()\n      out.exons.append(e)\n      return out\n    # get internal exons\n    self.exons = []\n    for i in range(0,len(self.junction_groups)-1):\n      j1 = self.junction_groups[i].get_junction()\n      j2 = self.junction_groups[i+1].get_junction()\n      e = Exon(GenomicRange(j1.right.chr,j1.right.end,j2.left.start))\n      e.set_left_junc(j1)\n      e.set_right_junc(j2)\n      #print str(i)+\" to \"+str(i+1)\n      out.exons.append(e)\n    # get left exon\n    left_exons = [y for y in [self.transcripts[e[0]].junctions[e[1]].get_left_exon() for e in self.junction_groups[0].evidence] if y]\n    if len(left_exons) == 0:\n      sys.stderr.write(\"ERROR no left exon\\n\")\n      sys.exit()\n    e_left = Exon(GenomicRange(out.junctions[0].left.chr,\\\n                               min([x.range.start for x in left_exons]),\n                               out.junctions[0].left.start))\n    e_left.set_right_junc(out.junctions[0])\n    out.exons.insert(0,e_left)\n    # get right exon\n    right_exons = [y for y in [self.transcripts[e[0]].junctions[e[1]].get_right_exon() for e in self.junction_groups[-1].evidence] if y]\n    if len(right_exons) == 0:\n      sys.stderr.write(\"ERROR no right exon\\n\")\n      sys.exit()\n    e_right = Exon(GenomicRange(out.junctions[-1].right.chr,\\\n                               out.junctions[-1].right.end,\\\n                               max([x.range.end for x in right_exons])))\n    e_right.set_left_junc(out.junctions[-1])\n    out.exons.append(e_right)\n    return out", "response": "Return a representative transcript object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading and extract file.", "response": "def download(url, filename):\n    \"\"\"download and extract file.\"\"\"\n    logger.info(\"Downloading %s\", url)\n    request = urllib2.Request(url)\n    request.add_header('User-Agent',\n                       'caelum/0.1 +https://github.com/nrcharles/caelum')\n    opener = urllib2.build_opener()\n    local_file = open(filename, 'w')\n    local_file.write(opener.open(request).read())\n    local_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload and extract file.", "response": "def download_extract(url):\n    \"\"\"download and extract file.\"\"\"\n    logger.info(\"Downloading %s\", url)\n    request = urllib2.Request(url)\n    request.add_header('User-Agent',\n                       'caelum/0.1 +https://github.com/nrcharles/caelum')\n    opener = urllib2.build_opener()\n    with tempfile.TemporaryFile(suffix='.zip', dir=env.WEATHER_DATA_PATH) \\\n            as local_file:\n        logger.debug('Saving to temporary file %s', local_file.name)\n        local_file.write(opener.open(request).read())\n        compressed_file = zipfile.ZipFile(local_file, 'r')\n        logger.debug('Extracting %s', compressed_file)\n        compressed_file.extractall(env.WEATHER_DATA_PATH)\n        local_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_noaa_line(line):\n    station = {}\n    station['station_name'] = line[7:51].strip()\n    station['station_code'] = line[0:6]\n    station['CC'] = line[55:57]\n    station['ELEV(m)'] = int(line[73:78])\n    station['LAT'] = _mlat(line[58:64])\n    station['LON'] = _mlon(line[65:71])\n    station['ST'] = line[52:54]\n    return station", "response": "Parse a line of NOAA station list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef closest_noaa(latitude, longitude):\n    with open(env.SRC_PATH + '/inswo-stns.txt') as index:\n        index.readline()  # header\n        index.readline()  # whitespace\n        min_dist = 9999\n        station_name = ''\n        station_name = ''\n        for line in index:\n            try:\n                i = parse_noaa_line(line)\n                new_dist = great_circle((latitude, longitude),\n                                        (float(i['LAT']),\n                                         float(i['LON']))).miles\n\n            except:\n                logger.error(line)\n                raise IOError('Inventory Issue')\n\n            if new_dist < min_dist:\n                min_dist = new_dist\n                station_name = i['station_name']\n                station_code = i['station_code']\n        index.close()\n        return station_code, station_name\n    raise KeyError('station not found')", "response": "Find closest station from the old list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding closest station from the new ( er ) list.", "response": "def closest_eere(latitude, longitude):\n    \"\"\"Find closest station from the new(er) list.\n\n    Warning: There may be some errors with smaller non US stations.\n\n    Args:\n        latitude (float)\n        longitude (float)\n\n    Returns:\n        tuple (station_code (str), station_name (str))\n\n    \"\"\"\n    with open(env.SRC_PATH + '/eere_meta.csv') as eere_meta:\n        stations = csv.DictReader(eere_meta)\n        d = 9999\n        station_code = ''\n        station_name = ''\n        for station in stations:\n            new_dist = great_circle((latitude, longitude),\n                                    (float(station['latitude']),\n                                     float(station['longitude']))).miles\n            if new_dist <= d:\n                d = new_dist\n                station_code = station['station_code']\n                station_name = station['weather_station']\n        return station_code, station_name\n    raise KeyError('station not found')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the information for a given station code.", "response": "def eere_station(station_code):\n    \"\"\"Station information.\n\n    Args:\n        station_code (str): station code.\n\n    Returns (dict): station information\n    \"\"\"\n    with open(env.SRC_PATH + '/eere_meta.csv') as eere_meta:\n        stations = csv.DictReader(eere_meta)\n        for station in stations:\n            if station['station_code'] == station_code:\n                return station\n    raise KeyError('station not found')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the log entries resulting from a search.", "response": "def get_log_entries(self):\n        \"\"\"Gets the log entry list resulting from a search.\n\n        return: (osid.logging.LogEntryList) - the log entry list\n        raise:  IllegalState - list already retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.LogEntryList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_logs(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.LogList(self._results, runtime=self._runtime)", "response": "Gets the log list resulting from a search."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_object(self, queryset=None):\n        if queryset is None:\n            queryset = self.get_queryset()\n\n        # Take a GET parameter instead of URLConf variable.\n        try:\n            pk = long(self.request.GET[self.pk_url_kwarg])\n        except (KeyError, ValueError):\n            raise Http404(\"Invalid Parameters\")\n        queryset = queryset.filter(pk=pk)\n\n        try:\n            # Get the single item from the filtered queryset\n            obj = queryset.get()\n        except ObjectDoesNotExist as e:\n            raise Http404(e)\n        return obj", "response": "Returns the object that the view is displaying."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init(cloud_url):\n    old_cloud_url = config[\"cloud_server\"][\"url\"]\n    if old_cloud_url and old_cloud_url != cloud_url:\n        raise click.ClickException(\n            'Server \"{}\" already selected. Call `openag cloud deinit` to '\n            'detach from that server before selecting a new one'.format(\n                old_cloud_url\n            )\n        )\n    parsed_url = urlparse(cloud_url)\n    if not parsed_url.scheme or not parsed_url.netloc or not parsed_url.port:\n        raise click.BadParameter(\"Invalid url\")\n    if config[\"local_server\"][\"url\"]:\n        utils.replicate_global_dbs(cloud_url=cloud_url)\n    config[\"cloud_server\"][\"url\"] = cloud_url", "response": "Initializes the n - item database for the given cloud server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow the URL of the current cloud server or throws an error", "response": "def show():\n    \"\"\"\n    Shows the URL of the current cloud server or throws an error if no cloud\n    server is selected\n    \"\"\"\n    utils.check_for_cloud_server()\n    click.echo(\"Using cloud server at \\\"{}\\\"\".format(\n        config[\"cloud_server\"][\"url\"]\n    ))\n    if config[\"cloud_server\"][\"username\"]:\n        click.echo(\n            \"Logged in as user \\\"{}\\\"\".format(config[\"cloud_server\"][\"username\"])\n        )\n    if config[\"cloud_server\"][\"farm_name\"]:\n        click.echo(\n            \"Using farm \\\"{}\\\"\".format(config[\"cloud_server\"][\"farm_name\"])\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef deinit(ctx):\n    utils.check_for_cloud_server()\n    if config[\"local_server\"][\"url\"]:\n        utils.cancel_global_db_replication()\n    if config[\"cloud_server\"][\"username\"]:\n        ctx.invoke(logout_user)\n    config[\"cloud_server\"][\"url\"] = None", "response": "Detach from the current cloud server"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef invoke(self, ns, request_name, params={}, simplify=False):\n        if self.auth_token == None:\n            raise AuthException('Unable to invoke zimbra method')\n\n        if util.empty(request_name):\n            raise ZimbraClientException('Invalid request')\n\n        return self.transport.invoke(ns,\n                                     request_name,\n                                     params,\n                                     self.auth_token,\n                                     simplify)", "response": "Invoke zimbra method using established authentication session."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef can_transfer(self):\n        # 1. The address needs to own the edition\n        chain = BlockchainSpider.chain(self._tree, self.edition_number)\n\n        if len(chain) == 0:\n            self.reason = 'The edition number {} does not exist in the blockchain'.format(self.edition_number)\n            return False\n\n        chain = BlockchainSpider.strip_loan(chain)\n        to_address = chain[-1]['to_address']\n        if to_address != self.address:\n            self.reason = 'Address {} does not own the edition number {}'.format(self.address, self.edition_number)\n            return False\n\n        return True", "response": "Returns True if the address can be transferred."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef can_unconsign(self):\n        chain = BlockchainSpider.chain(self._tree, self.edition_number)\n        if len(chain) == 0:\n            self.reason = 'Master edition not yet registered'\n            return False\n\n        chain = BlockchainSpider.strip_loan(chain)\n        action = chain[-1]['action']\n        piece_address = chain[-1]['piece_address']\n        edition_number = chain[-1]['edition_number']\n        to_address = chain[-1]['to_address']\n\n        if action != 'CONSIGN' or piece_address != self.piece_address or edition_number != self.edition_number or to_address != self.address:\n            self.reason = 'Edition number {} is not consigned to {}'.format(self.edition_number, self.address)\n            return False\n\n        return True", "response": "Returns True if the user can unconsign the edition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef can_register(self):\n        chain = BlockchainSpider.chain(self._tree, REGISTERED_PIECE_CODE)\n\n        # edition 0 should only have two transactions: REGISTER and EDITIONS\n        if len(chain) == 0:\n            self.reason = 'Master edition not yet registered'\n            return False\n\n        chain = BlockchainSpider.strip_loan(chain)\n        number_editions = chain[0]['number_editions']\n        if number_editions == 0:\n            self.reason = 'Number of editions not yet registered'\n            return False\n\n        if self.edition_number > number_editions:\n            self.reason = 'You can only register {} editions. You are trying to register edition {}'.format(number_editions, self.edition_number)\n            return False\n\n        if self.edition_number in self._tree:\n            self.reason = 'Edition number {} is already registered in the blockchain'. format(self.edition_number)\n            return False\n\n        return True", "response": "Returns True if the current edition can be registered."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef can_editions(self):\n        chain = BlockchainSpider.chain(self._tree, REGISTERED_PIECE_CODE)\n\n        if len(chain) == 0:\n            self.reason = 'Master edition not yet registered'\n            return False\n\n        number_editions = chain[0]['number_editions']\n        if number_editions != 0:\n            self.reason = 'Number of editions was already registered for this piece'\n            return False\n\n        return True", "response": "Returns True if the piece with address self. piece_address can be registered."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef relative_to_all(features, groups, bin_edges, weight_func,\n                    use_orig_distr,\n                    group_ids, num_groups,\n                    return_networkx_graph, out_weights_path):\n    \"\"\"\n    Computes the given function (aka weight or distance) between histogram from each of the groups to a \"grand histogram\" derived from all groups.\n\n    Parameters\n    ----------\n    features : ndarray or str\n        1d array of scalar values, either provided directly as a 1d numpy array,\n        or as a path to a file containing these values\n\n    groups : ndarray or str\n        Membership array of same length as `features`, each value specifying which group that particular node belongs to.\n        Input can be either provided directly as a 1d numpy array,or as a path to a file containing these values.\n\n        For example, if you have cortical thickness values for 1000 vertices (`features` is ndarray of length 1000),\n        belonging to 100 patches, the groups array (of length 1000) could  have numbers 1 to 100 (number of unique values)\n        specifying which element belongs to which cortical patch.\n\n        Grouping with numerical values (contiguous from 1 to num_patches) is strongly recommended for simplicity,\n        but this could also be a list of strings of length p, in which case a tuple is returned,\n        identifying which weight belongs to which pair of patches.\n\n    bin_edges : list or ndarray\n        Array of bin edges within which to compute the histogram in.\n\n    weight_func : callable\n        Function to compute the edge weight between groups/nodes.\n\n    use_orig_distr : bool, optional\n        When using a user-defined callable, this flag\n        1) allows skipping of pre-processing (trimming outliers) and histogram construction,\n        2) enables the application of arbitrary callable (user-defined) on the original distributions coming from the two groups/ROIs/nodes directly.\n\n        Example: ``diff_in_medians = lambda x, y: abs(np.median(x)-np.median(y))``\n\n        This option is valid only when weight_method is a valid callable,\n            which must take two inputs (possibly of different lengths) and return a single scalar.\n\n    group_ids : list\n        List of unique group ids to construct the nodes from (must all be present in the `groups` argument)\n\n    num_groups : int\n        Number of unique groups in the `group_ids`\n\n    return_networkx_graph : bool, optional\n        Specifies the need for a networkx graph populated with weights computed. Default: False.\n\n    out_weights_path : str, optional\n        Where to save the extracted weight matrix. If networkx output is returned, it would be saved in GraphML format.\n        Default: nothing saved unless instructed.\n\n    Returns\n    -------\n    distance_vector : ndarray\n        vector of distances between the grand histogram and the individual ROIs\n\n    Raises\n    ------\n    ValueError\n        If one or more of the arrays are empty.\n\n    \"\"\"\n\n    # notice the use of all features without regard to group membership\n    hist_whole = compute_histogram(features, bin_edges, use_orig_distr)\n\n    # to identify the central node capturing distribution from all roi's\n    whole_node = 'whole'\n\n    if return_networkx_graph:\n        graph = nx.Graph()\n        graph.add_nodes_from(group_ids)\n        graph.add_node(whole_node)\n    else:\n        edge_weights = np.full([num_groups, 1], np.nan)\n\n    for src in range(num_groups):\n        index_roi = groups == group_ids[src]\n        hist_roi = compute_histogram(features[index_roi], bin_edges, use_orig_distr)\n        edge_value = weight_func(hist_whole, hist_roi)\n        if return_networkx_graph:\n            graph.add_edge(group_ids[src], whole_node, weight=float(edge_value))\n        else:\n            edge_weights[src] = edge_value\n\n    if return_networkx_graph:\n        if out_weights_path is not None:\n            graph.write_graphml(out_weights_path)\n        return graph\n    else:\n        if out_weights_path is not None:\n            np.savetxt(out_weights_path, edge_weights, delimiter=',', fmt='%.9f')\n        return edge_weights", "response": "This function calculates the relative distance between a graph from a set of features and a set of groups."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_filter(self, filter_or_string, *args, **kwargs):\n        self.filters.append(build_filter(filter_or_string, *args, **kwargs))\n\n        return self", "response": "Appends a filter to the filter list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef and_filter(self, filter_or_string, *args, **kwargs):\n        and_filter = self.find_filter(And)\n\n        if and_filter is None:\n            and_filter = And()\n            self.filters.append(and_filter)\n\n        and_filter.add_filter(build_filter(\n            filter_or_string, *args, **kwargs))\n\n        return and_filter", "response": "Creates an and filter that applies the given filter_or_string to the current and_filter list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an or filter that will add the given filter_or_string to the current filter list.", "response": "def or_filter(self, filter_or_string, *args, **kwargs):\n        \"\"\"\n        Adds a list of :class:`~es_fluent.filters.core.Or` clauses, automatically\n        generating the an :class:`~es_fluent.filters.core.Or` filter if it does not\n        exist.\n        \"\"\"\n        or_filter = self.find_filter(Or)\n\n        if or_filter is None:\n            or_filter = Or()\n            self.filters.append(or_filter)\n\n        or_filter.add_filter(build_filter(\n            filter_or_string, *args, **kwargs\n        ))\n\n        return or_filter"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds or create a filter instance of the provided type.", "response": "def find_filter(self, filter_cls):\n        \"\"\"\n        Find or create a filter instance of the provided ``filter_cls``. If it\n        is found, use remaining arguments to augment the filter otherwise\n        create a new instance of the desired type and add it to the\n        current :class:`~es_fluent.builder.QueryBuilder` accordingly.\n        \"\"\"\n        for filter_instance in self.filters:\n            if isinstance(filter_instance, filter_cls):\n                return filter_instance\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_query(self):\n        query = {}\n        for filter_instance in self.filters:\n            if filter_instance.is_empty():\n                continue\n            filter_query = filter_instance.to_query()\n            query.update(filter_query)\n\n        return query", "response": "Converts the list of items in the list to an Elastic HTTP API query suitable for use in a query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn true iff self and other are allowed to have symbols that are found in other.", "response": "def match(self, other):\n        \"\"\"Returns true iff self (as a pattern) matches other (as a\n        configuration). Note that this is asymmetric: other is allowed\n        to have symbols that aren't found in self.\"\"\"\n\n        if len(self) != len(other):\n            raise ValueError()\n        for s1, s2 in zip(self, other):\n            i = s2.position - s1.position\n            if i < 0:\n                return False\n            n = len(s1)\n            while i+n > len(s2) and s1[n-1] == syntax.BLANK:\n                n -= 1\n            if s2.values[i:i+n] != s1.values[:n]:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_cell(self, s):\n\n        for t in self.transitions:\n            if len(t.lhs[s]) != 1:\n                return False\n            if len(t.rhs[s]) != 1:\n                return False\n            if t.lhs[s].position != 0:\n                return False\n            if t.rhs[s].position != 0:\n                return False\n        return True", "response": "Tests whether store s is a cell that uses exactly one\n        cell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_stack(self, s):\n        for t in self.transitions:\n            if t.lhs[s].position != 0:\n                return False\n            if t.rhs[s].position != 0:\n                return False\n        return True", "response": "Tests whether store s is a stack that never moves from\n        position 0."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting whether store s is read - only.", "response": "def has_readonly(self, s):\n        \"\"\"Tests whether store `s` is read-only.\"\"\"\n        for t in self.transitions:\n            if list(t.lhs[s]) != list(t.rhs[s]):\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests whether the machine is a finite automaton.", "response": "def is_finite(self):\n        \"\"\"Tests whether machine is a finite automaton.\"\"\"\n        return (self.num_stores == 2 and\n                self.state == 0 and self.has_cell(0) and\n                self.input == 1 and self.has_input(1))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_pushdown(self):\n        return (self.num_stores == 3 and\n                self.state == 0 and self.has_cell(0) and\n                self.input == 1 and self.has_input(1) and\n                self.has_stack(2))", "response": "Tests whether the machine is a pushdown automaton."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests whether the machine is deterministic.", "response": "def is_deterministic(self):\n        \"\"\"Tests whether machine is deterministic.\"\"\"\n        # naive quadratic algorithm\n        patterns = [t.lhs for t in self.transitions] + list(self.accept_configs)\n        for i, t1 in enumerate(patterns):\n            for t2 in patterns[:i]:\n                match = True\n                for in1, in2 in zip(t1, t2):\n                    i = max(-in1.position, -in2.position)\n                    while i+in1.position < len(in1) and i+in2.position < len(in2):\n                        x1 = in1.values[i+in1.position]\n                        x2 = in2.values[i+in2.position]\n                        if x1 != x2:\n                            match = False\n                        i += 1\n                if match:\n                    return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the Relationship specified by its Id.", "response": "def get_relationship(self, relationship_id):\n        \"\"\"Gets the ``Relationship`` specified by its ``Id``.\n\n        arg:    relationship_id (osid.id.Id): the ``Id`` of the\n                ``Relationship`` to retrieve\n        return: (osid.relationship.Relationship) - the returned\n                ``Relationship``\n        raise:  NotFound - no ``Relationship`` found with the given\n                ``Id``\n        raise:  NullArgument - ``relationship_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('relationship',\n                                         collection='Relationship',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(relationship_id, 'relationship').get_identifier())},\n                 **self._view_filter()))\n        return objects.Relationship(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a RelationshipList corresponding to the given IdList.", "response": "def get_relationships_by_ids(self, relationship_ids):\n        \"\"\"Gets a ``RelationshipList`` corresponding to the given ``IdList``.\n\n        arg:    relationship_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n        return: (osid.relationship.RelationshipList) - the returned\n                ``Relationship list``\n        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``relationship_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('relationship',\n                                         collection='Relationship',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in relationship_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'relationship').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.RelationshipList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_relationships_by_genus_type(self, relationship_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('relationship',\n                                         collection='Relationship',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(relationship_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.RelationshipList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a RelationshipList corresponding to the given relationship genus Type which does not include relationships of types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a RelationshipList effective during the entire given date range inclusive but not confined to the date range.", "response": "def get_relationships_on_date(self, from_, to):\n        \"\"\"Gets a ``RelationshipList`` effective during the entire given date range inclusive but not confined to the date range.\n\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n        return: (osid.relationship.RelationshipList) - the relationships\n        raise:  InvalidArgument - ``from is greater than to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_on_date\n        relationship_list = []\n        for relationship in self.get_relationships():\n            if overlap(from_, to, relationship.start_date, relationship.end_date):\n                relationship_list.append(relationship)\n        return objects.RelationshipList(relationship_list, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a RelationshipList corresponding to the given source.", "response": "def get_relationships_for_source(self, source_id):\n        \"\"\"Gets a ``RelationshipList`` corresponding to the given peer ``Id``.\n\n        arg:    source_id (osid.id.Id): a peer ``Id``\n        return: (osid.relationship.RelationshipList) - the relationships\n        raise:  NullArgument - ``source_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source\n        # NOTE: This implementation currently ignores plenary and effective views\n        collection = JSONClientValidated('relationship',\n                                         collection='Relationship',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'sourceId': str(source_id)},\n                 **self._view_filter())).sort('_sort_id', ASCENDING)\n        return objects.RelationshipList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_relationships_for_source_on_date(self, source_id, from_, to):\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source_on_date\n        relationship_list = []\n        for relationship in self.get_relationships_for_source(source_id):\n            if overlap(from_, to, relationship.start_date, relationship.end_date):\n                relationship_list.append(relationship)\n        return objects.RelationshipList(relationship_list, runtime=self._runtime)", "response": "Gets a list of Relationships corresponding to the given source_id and effective during the entire given date range inclusive but not confined to the date range inclusive but not confined to the date range inclusive."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_relationships_by_genus_type_for_source_on_date(self, source_id, relationship_genus_type, from_, to):\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_by_genus_type_for_source_on_date\n        relationship_list = []\n        for relationship in self.get_relationships_by_genus_type_for_source():\n            if overlap(from_, to, relationship.start_date, relationship.end_date):\n                relationship_list.append(relationship)\n        return objects.RelationshipList(relationship_list, runtime=self._runtime)", "response": "Gets a list of Relationships corresponding to a given source Id and relationship genus Type and effective during the entire given date range inclusive but not confined to the date range."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of Relationships corresponding to the given destination_id with a starting effective date in the given range inclusive.", "response": "def get_relationships_for_destination_on_date(self, destination_id, from_, to):\n        \"\"\"Gets a ``RelationshipList`` corresponding to the given peer ``Id`` with a starting effective date in the given range inclusive.\n\n        arg:    destination_id (osid.id.Id): a peer ``Id``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n        return: (osid.relationship.RelationshipList) - the relationships\n        raise:  InvalidArgument - ``from is greater than to``\n        raise:  NullArgument - ``destination_id, from`` ,or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_destination_on_date\n        relationship_list = []\n        for relationship in self.get_relationships_for_destination():\n            if overlap(from_, to, relationship.start_date, relationship.end_date):\n                relationship_list.append(relationship)\n        return objects.RelationshipList(relationship_list, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_relationships(self):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('relationship',\n                                         collection='Relationship',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.RelationshipList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets all Relationships in the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_relationships_by_query(self, relationship_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in relationship_query._query_terms:\n            if '$in' in relationship_query._query_terms[term] and '$nin' in relationship_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': relationship_query._query_terms[term]['$in']}},\n                             {term: {'$nin': relationship_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: relationship_query._query_terms[term]})\n        for term in relationship_query._keyword_terms:\n            or_list.append({term: relationship_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('relationship',\n                                             collection='Relationship',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.RelationshipList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of Relationships matching the given relationship query."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_relationship_form_for_create(self, source_id, destination_id, relationship_record_types):\n        # Implemented from template for\n        # osid.relationship.RelationshipAdminSession.get_relationship_form_for_create\n        # These really need to be in module imports:\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        from dlkit.abstract_osid.type.primitives import Type as ABCType\n        if not isinstance(source_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        if not isinstance(destination_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in relationship_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if relationship_record_types == []:\n            # WHY are we passing family_id = self._catalog_id below, seems redundant:\n            obj_form = objects.RelationshipForm(\n                family_id=self._catalog_id,\n                source_id=source_id,\n                destination_id=destination_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.RelationshipForm(\n                family_id=self._catalog_id,\n                record_types=relationship_record_types,\n                source_id=source_id,\n                destination_id=destination_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the relationship form for creating new relationships."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_relationship(self, relationship_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('relationship',\n                                         collection='Relationship',\n                                         runtime=self._runtime)\n        if not isinstance(relationship_form, ABCRelationshipForm):\n            raise errors.InvalidArgument('argument type is not an RelationshipForm')\n        if relationship_form.is_for_update():\n            raise errors.InvalidArgument('the RelationshipForm is for update only, not create')\n        try:\n            if self._forms[relationship_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('relationship_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('relationship_form did not originate from this session')\n        if not relationship_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(relationship_form._my_map)\n\n        self._forms[relationship_form.get_id().get_identifier()] = CREATED\n        result = objects.Relationship(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new Relationship."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_relationship(self, relationship_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('relationship',\n                                         collection='Relationship',\n                                         runtime=self._runtime)\n        if not isinstance(relationship_form, ABCRelationshipForm):\n            raise errors.InvalidArgument('argument type is not an RelationshipForm')\n        if not relationship_form.is_for_update():\n            raise errors.InvalidArgument('the RelationshipForm is for update only, not create')\n        try:\n            if self._forms[relationship_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('relationship_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('relationship_form did not originate from this session')\n        if not relationship_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(relationship_form._my_map)\n\n        self._forms[relationship_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Relationship(\n            osid_object_map=relationship_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Updates an existing relationship."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_relationship(self, relationship_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('relationship',\n                                         collection='Relationship',\n                                         runtime=self._runtime)\n        if not isinstance(relationship_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        relationship_map = collection.find_one(\n            dict({'_id': ObjectId(relationship_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.Relationship(osid_object_map=relationship_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(relationship_id.get_identifier())})", "response": "Deletes a ``Relationship``.\n\n        arg:    relationship_id (osid.id.Id): the ``Id`` of the\n                ``Relationship`` to remove\n        raise:  NotFound - ``relationship_id`` not found\n        raise:  NullArgument - ``relationship_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef alias_relationship(self, relationship_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=relationship_id, equivalent_id=alias_id)", "response": "Adds an Id to a Relationship."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if this user can create a single Family using the desired record types.", "response": "def can_create_family_with_record_types(self, family_record_types):\n        \"\"\"Tests if this user can create a single ``Family`` using the desired record types.\n\n        While ``RelationshipManager.getFamilyRecordTypes()`` can be used\n        to examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Family``.\n        Providing an empty array tests if a ``Family`` can be created\n        with no records.\n\n        arg:    family_record_types (osid.type.Type[]): array of family\n                record types\n        return: (boolean) - ``true`` if ``Family`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise\n        raise:  NullArgument - ``family_record_types is null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=family_record_types)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_family(self, family_form):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=family_form)\n        collection = JSONClientValidated('relationship',\n                                         collection='Family',\n                                         runtime=self._runtime)\n        if not isinstance(family_form, ABCFamilyForm):\n            raise errors.InvalidArgument('argument type is not an FamilyForm')\n        if not family_form.is_for_update():\n            raise errors.InvalidArgument('the FamilyForm is for update only, not create')\n        try:\n            if self._forms[family_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('family_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('family_form did not originate from this session')\n        if not family_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(family_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[family_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Family(osid_object_map=family_form._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Updates an existing family."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef alias_family(self, family_id, alias_id):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=family_id, alias_id=alias_id)\n        self._alias_id(primary_id=family_id, equivalent_id=alias_id)", "response": "Adds an Id to a Family for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_root_families(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return FamilyLookupSession(\n            self._proxy,\n            self._runtime).get_families_by_ids(list(self.get_root_family_ids()))", "response": "Gets the root families in the family hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if the Family has any parents.", "response": "def has_parent_families(self, family_id):\n        \"\"\"Tests if the ``Family`` has any parents.\n\n        arg:    family_id (osid.id.Id): the ``Id`` of a family\n        return: (boolean) - ``true`` if the family has parents,\n                ``false`` otherwise\n        raise:  NotFound - ``family_id`` is not found\n        raise:  NullArgument - ``family_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=family_id)\n        return self._hierarchy_session.has_parents(id_=family_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_parent_of_family(self, id_, family_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=family_id)\n        return self._hierarchy_session.is_parent(id_=family_id, parent_id=id_)", "response": "Tests if an Id is a direct parent of a family."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_parent_family_ids(self, family_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=family_id)\n        return self._hierarchy_session.get_parents(id_=family_id)", "response": "Gets the parent Ids of the given family."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the parent families of the given id.", "response": "def get_parent_families(self, family_id):\n        \"\"\"Gets the parent families of the given ``id``.\n\n        arg:    family_id (osid.id.Id): the ``Id`` of the ``Family`` to\n                query\n        return: (osid.relationship.FamilyList) - the parent families of\n                the ``id``\n        raise:  NotFound - a ``Family`` identified by ``Id is`` not\n                found\n        raise:  NullArgument - ``family_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=family_id)\n        return FamilyLookupSession(\n            self._proxy,\n            self._runtime).get_families_by_ids(\n                list(self.get_parent_family_ids(family_id)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntests if an Id is an ancestor of a family.", "response": "def is_ancestor_of_family(self, id_, family_id):\n        \"\"\"Tests if an ``Id`` is an ancestor of a family.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    family_id (osid.id.Id): the ``Id`` of a family\n        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``family_id,``  ``false`` otherwise\n        raise:  NotFound - ``family_id`` is not found\n        raise:  NullArgument - ``id`` or ``family_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=family_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=family_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_child_families(self, family_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=family_id)\n        return self._hierarchy_session.has_children(id_=family_id)", "response": "Tests if a family has any children."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if a family is a direct child of another.", "response": "def is_child_of_family(self, id_, family_id):\n        \"\"\"Tests if a family is a direct child of another.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    family_id (osid.id.Id): the ``Id`` of a family\n        return: (boolean) - ``true`` if the ``id`` is a child of\n                ``family_id,``  ``false`` otherwise\n        raise:  NotFound - ``family_id`` is not found\n        raise:  NullArgument - ``id`` or ``family_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=family_id)\n        return self._hierarchy_session.is_child(id_=family_id, child_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_child_family_ids(self, family_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=family_id)\n        return self._hierarchy_session.get_children(id_=family_id)", "response": "Gets the child Ids of the given family."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_child_families(self, family_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=family_id)\n        return FamilyLookupSession(\n            self._proxy,\n            self._runtime).get_families_by_ids(\n                list(self.get_child_family_ids(family_id)))", "response": "Gets the child families of the given id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_descendant_of_family(self, id_, family_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=family_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=family_id)", "response": "Tests if an Id is a descendant of a family."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_family_nodes(self, family_id, ancestor_levels, descendant_levels, include_siblings):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.FamilyNode(self.get_family_node_ids(\n            family_id=family_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a portion of the hierarchy for the given family."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a root family.", "response": "def add_root_family(self, family_id):\n        \"\"\"Adds a root family.\n\n        arg:    family_id (osid.id.Id): the ``Id`` of a family\n        raise:  AlreadyExists - ``family_id`` is already in hierarchy\n        raise:  NotFound - ``family_id`` not found\n        raise:  NullArgument - ``family_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=family_id)\n        return self._hierarchy_session.add_root(id_=family_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_root_family(self, family_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=family_id)\n        return self._hierarchy_session.remove_root(id_=family_id)", "response": "Removes a root family."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_child_family(self, family_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=family_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=family_id, child_id=child_id)", "response": "Adds a child to a family."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_child_family(self, family_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=family_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=family_id, child_id=child_id)", "response": "Removes a child from a family."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves all children from a family.", "response": "def remove_child_families(self, family_id):\n        \"\"\"Removes all children from a family.\n\n        arg:    family_id (osid.id.Id): the ``Id`` of a family\n        raise:  NotFound - ``family_id`` not in hierarchy\n        raise:  NullArgument - ``family_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalogs(catalog_id=family_id)\n        return self._hierarchy_session.remove_children(id_=family_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves environment variables and returns Python natives.", "response": "def env(key, default=None, required=False):\n    \"\"\"\n    Retrieves environment variables and returns Python natives. The (optional)\n    default will be returned if the environment variable does not exist.\n    \"\"\"\n    try:\n        value = os.environ[key]\n        return ast.literal_eval(value)\n    except (SyntaxError, ValueError):\n        return value\n    except KeyError:\n        if default or not required:\n            return default\n        raise ImproperlyConfigured(\n            \"Missing required environment variable '%s'\" % key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprepares incoming GeoJSON to be Elastic friendly.", "response": "def prepare_geojson(geojson):\n    \"\"\"\n    Modifies incoming GeoJSON to make it Elastic friendly. This means:\n\n        1. CW orientation of polygons.\n        2. Re-casting of Features and FeatureCollections to Geometry and\n           GeometryCollections.\n    \"\"\"\n    # TODO CW orientation.\n    geojson = deepcopy(geojson)\n\n    if geojson[\"type\"] == \"Feature\":\n        geojson = geojson[\"geometry\"]\n        if hasattr(geojson, 'properties'):\n            del geojson['properties']\n\n    if geojson[\"type\"] == \"FeatureCollection\":\n        geojson[\"type\"] = \"GeometryCollection\"\n        geojson[\"geometries\"] = [\n            feature[\"geometry\"] for feature in geojson[\"features\"]\n        ]\n        del geojson[\"features\"]\n\n    return geojson"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_query(self):\n        return {\n            \"geo_shape\": {\n                self.name: {\n                    \"indexed_shape\":  {\n                        \"index\": self.index_name,\n                        \"type\": self.doc_type,\n                        \"id\": self.shape_id,\n                        \"path\": self.path\n                    }\n                }\n            }\n        }", "response": "Returns a json - serializable representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the catalog at this node.", "response": "def get_catalog(self):\n        \"\"\"Gets the ``Catalog`` at this node.\n\n        return: (osid.cataloging.Catalog) - the catalog represented by\n                this node\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._lookup_session is None:\n            mgr = get_provider_manager('CATALOGING', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_catalog_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_catalog(Id(self._my_map['id']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_parent_catalog_nodes(self):\n        parent_catalog_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_catalog_nodes.append(CatalogNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return CatalogNodeList(parent_catalog_nodes)", "response": "Gets the parents of this catalog."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the next set of Parameters in this list which must be less than or equal to the return from available.", "response": "def get_next_parameters(self, n=None):\n        \"\"\"Gets the next set of ``Parameters`` in this list which must be less than or equal to the return from ``available()``.\n\n        arg:    n (cardinal): the number of ``Parameter`` elements\n                requested which must be less than or equal to\n                ``available()``\n        return: (osid.configuration.Parameter) - an array of\n                ``Parameter`` elements.The length of the array is less\n                than or equal to the number specified.\n        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceList.get_next_resources\n        if n > self.available():\n            # !!! This is not quite as specified (see method docs) !!!\n            raise IllegalState('not enough elements available in this list')\n        else:\n            next_list = []\n            x = 0\n            while x < n:\n                try:\n                    next_list.append(self.next())\n                except:  # Need to specify exceptions here\n                    raise OperationFailed()\n                x = x + 1\n            return next_list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef data_attrs(mapitem):\n    data_attrs = {}\n\n    try:\n        data_attrs['marker-detail-api-url'] = reverse('fluentcms-googlemaps-marker-detail')\n    except NoReverseMatch:\n        pass\n\n    data_attrs.update(mapitem.get_map_options())\n    return mark_safe(u''.join([\n        format_html(u' data-{0}=\"{1}\"', k.replace('_', '-'), _data_value(v))\n        for k, v in data_attrs.items()\n    ]))", "response": "Generate the data -... attributes for a mapitem."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OsidSession associated with the grade system query service.", "response": "def get_grade_system_query_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the grade system query service.\n\n        return: (osid.grading.GradeSystemQuerySession) - a\n                ``GradeSystemQuerySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_grade_system_query()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_system_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_grade_system_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeSystemQuerySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the grade system query service for the given gradebook.", "response": "def get_grade_system_query_session_for_gradebook(self, gradebook_id):\n        \"\"\"Gets the ``OsidSession`` associated with the grade system query service for the given gradebook.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of the gradebook\n        return: (osid.grading.GradeSystemQuerySession) - ``a\n                GradeSystemQuerySession``\n        raise:  NotFound - ``gradebook_id`` not found\n        raise:  NullArgument - ``gradebook_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_grade_system_query()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_system_query()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_grade_system_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradeSystemQuerySession(gradebook_id, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the grade system administration service.", "response": "def get_grade_system_admin_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the grade system administration service.\n\n        return: (osid.grading.GradeSystemAdminSession) - a\n                ``GradeSystemAdminSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_grade_system_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_system_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_grade_system_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeSystemAdminSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the grade entry query service.", "response": "def get_grade_entry_query_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the grade entry query service.\n\n        return: (osid.grading.GradeEntryQuerySession) - a\n                ``GradeEntryQuerySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_grade_entry_query()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_entry_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_grade_entry_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeEntryQuerySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_grade_entry_query_session_for_gradebook(self, gradebook_id):\n        if not self.supports_grade_entry_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradeEntryQuerySession(gradebook_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the grade entry query service for the given gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_grade_entry_admin_session(self):\n        if not self.supports_grade_entry_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeEntryAdminSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the grade entry administration service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the gradebook column administration service.", "response": "def get_gradebook_column_admin_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the gradebook column administration service.\n\n        return: (osid.grading.GradebookColumnAdminSession) - a\n                ``GradebookColumnAdminSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_gradebook_column_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_gradebook_column_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_gradebook_column_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookColumnAdminSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the OsidSession associated with the gradebook column admin service for the given gradebook.", "response": "def get_gradebook_column_admin_session_for_gradebook(self, gradebook_id):\n        \"\"\"Gets the ``OsidSession`` associated with the gradebook column admin service for the given gradebook.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of the gradebook\n        return: (osid.grading.GradebookColumnAdminSession) - ``a\n                GradebookColumnAdminSession``\n        raise:  NotFound - ``gradebook_id`` not found\n        raise:  NullArgument - ``gradebook_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_gradebook_column_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_gradebook_column_admin()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_gradebook_column_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradebookColumnAdminSession(gradebook_id, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the session for retrieving gradebook column to gradebook mappings.", "response": "def get_gradebook_column_gradebook_session(self):\n        \"\"\"Gets the session for retrieving gradebook column to gradebook mappings.\n\n        return: (osid.grading.GradebookColumnGradebookSession) - a\n                ``GradebookColumnGradebookSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_gradebook_column_gradebook()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_gradebook_column_gradebook()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_gradebook_column_gradebook():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookColumnGradebookSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the grade system lookup service.", "response": "def get_grade_system_lookup_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the grade system lookup service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradeSystemLookupSession) - a\n                ``GradeSystemLookupSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_grade_system_lookup()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_system_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_grade_system_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeSystemLookupSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the grade system lookup service for the given gradebook.", "response": "def get_grade_system_lookup_session_for_gradebook(self, gradebook_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the grade system lookup service for the given gradebook.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of the gradebook\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradeSystemLookupSession) - ``a\n                GradeSystemLookupSession``\n        raise:  NotFound - ``gradebook_id`` not found\n        raise:  NullArgument - ``gradebook_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_grade_system_lookup()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_system_lookup()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_grade_system_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradeSystemLookupSession(gradebook_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_grade_system_admin_session_for_gradebook(self, gradebook_id, proxy):\n        if not self.supports_grade_system_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradeSystemAdminSession(gradebook_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the grade system admin service for the given gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_grade_system_gradebook_session(self, proxy):\n        if not self.supports_grade_system_gradebook():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeSystemGradebookSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the grade system to gradebook mappings."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the session for assigning grade system to gradebook mappings.", "response": "def get_grade_system_gradebook_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning grade system to gradebook mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradeSystemGradebookSession) - a\n                ``GradeSystemGradebookAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_grade_system_gradebook_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_system_gradebook_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_grade_system_gradebook_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeSystemGradebookAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_grade_entry_lookup_session(self, proxy):\n        if not self.supports_grade_entry_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradeEntryLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the grade entry lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_grade_entry_lookup_session_for_gradebook(self, gradebook_id, proxy):\n        if not self.supports_grade_entry_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradeEntryLookupSession(gradebook_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the grade entry lookup service for the given gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OsidSession associated with the grade entry admin service for the given gradebook.", "response": "def get_grade_entry_admin_session_for_gradebook(self, gradebook_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the grade entry admin service for the given gradebook.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of the gradebook\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradeEntryAdminSession) - ``a\n                GradeEntryAdminSession``\n        raise:  NotFound - ``gradebook_id`` not found\n        raise:  NullArgument - ``gradebook_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_grade_entry_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_grade_entry_admin()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_grade_entry_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradeEntryAdminSession(gradebook_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_gradebook_column_lookup_session(self, proxy):\n        if not self.supports_gradebook_column_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookColumnLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the gradebook column lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gradebook_column_lookup_session_for_gradebook(self, gradebook_id, proxy):\n        if not self.supports_gradebook_column_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradebookColumnLookupSession(gradebook_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the gradebook column lookup service for the given gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the gradebook column query service.", "response": "def get_gradebook_column_query_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the gradebook column query service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradebookColumnQuerySession) - a\n                ``GradebookColumnQuerySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_gradebook_column_query()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_gradebook_column_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_gradebook_column_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookColumnQuerySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the OsidSession associated with the gradebook column query service for the given gradebook.", "response": "def get_gradebook_column_query_session_for_gradebook(self, gradebook_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the gradebook column query service for the given gradebook.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of the gradebook\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradebookColumnQuerySession) - a\n                ``GradebookColumnQuerySession``\n        raise:  NotFound - ``gradebook_id`` not found\n        raise:  NullArgument - ``gradebook_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_gradebook_column_query()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_gradebook_column_query()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_gradebook_column_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.GradebookColumnQuerySession(gradebook_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the session for assigning gradebook column to gradebook mappings.", "response": "def get_gradebook_column_gradebook_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning gradebook column to gradebook mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradebookColumnGradebookAssignmentSession)\n                - a ``GradebookColumnGradebookAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_gradebook_column_gradebook_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_gradebook_column_gradebook_assignment()`` is\n        ``true``.*\n\n        \"\"\"\n        if not self.supports_gradebook_column_gradebook_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookColumnGradebookAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the gradebook lookup service.", "response": "def get_gradebook_lookup_session(self, proxy):\n        \"\"\"Gets the OsidSession associated with the gradebook lookup service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.grading.GradebookLookupSession) - a\n                ``GradebookLookupSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_gradebook_lookup() is false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_gradebook_lookup()`` is true.*\n\n        \"\"\"\n        if not self.supports_gradebook_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookLookupSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gradebook_admin_session(self, proxy):\n        if not self.supports_gradebook_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the gradebook administration service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_gradebook_hierarchy_session(self, proxy):\n        if not self.supports_gradebook_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookHierarchySession(proxy=proxy, runtime=self._runtime)", "response": "Gets the session traversing gradebook hierarchies."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_gradebook_hierarchy_design_session(self, proxy):\n        if not self.supports_gradebook_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.GradebookHierarchyDesignSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the gradebook hierarchies designing session."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _set_hierarchy_view(self, session):\n        if self._hierarchy_view == COMPARATIVE:\n            try:\n                session.use_comparative_hierarchy_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_hierarchy_view()\n            except AttributeError:\n                pass", "response": "Sets the underlying hierarchy view to match current view"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _instantiate_session(self, method_name, proxy=None, *args, **kwargs):\n        if 'manager' in kwargs:\n            session_class = getattr(kwargs['manager'], method_name)\n            del kwargs['manager']\n        else:\n            session_class = getattr(self._provider_manager, method_name)\n        if proxy is None:\n            try:\n                return session_class(bank_id=self._catalog_id, *args, **kwargs)\n            except AttributeError:\n                return session_class(*args, **kwargs)\n        else:\n            try:\n                return session_class(bank_id=self._catalog_id, proxy=proxy, *args, **kwargs)\n            except AttributeError:\n                return session_class(proxy=proxy, *args, **kwargs)", "response": "Instantiates a provider session"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_comparative_hierarchy_view(self):\n        self._hierarchy_view = COMPARATIVE\n        # self._get_provider_session('hierarchy_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_hierarchy_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider HierarchyLookupSession. use_comparative_hierarchy_view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider HierarchyLookupSession. use_plenary_hierarchy_view", "response": "def use_plenary_hierarchy_view(self):\n        \"\"\"Pass through to provider HierarchyLookupSession.use_plenary_hierarchy_view\"\"\"\n        self._hierarchy_view = PLENARY\n        # self._get_provider_session('hierarchy_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_hierarchy_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_hierarchies_by_ids(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_by_ids\n        catalogs = self._get_provider_session('hierarchy_lookup_session').get_hierarchies_by_ids(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Hierarchy(self._provider_manager, cat, self._runtime, self._proxy))\n        return HierarchyList(cat_list)", "response": "Pass through to provider HierarchyLookupSession. get_hierarchies_by_ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npasses through to provider HierarchyLookupSession. get_hierarchies", "response": "def get_hierarchies(self):\n        \"\"\"Pass through to provider HierarchyLookupSession.get_hierarchies\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('hierarchy_lookup_session').get_hierarchies()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Hierarchy(self._provider_manager, cat, self._runtime, self._proxy))\n        return HierarchyList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_hierarchy(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.create_bin\n        return Hierarchy(\n            self._provider_manager,\n            self._get_provider_session('hierarchy_admin_session').create_hierarchy(*args, **kwargs),\n            self._runtime,\n            self._proxy)", "response": "Pass through to provider HierarchyAdminSession. create_hierarchy"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npasses through to provider HierarchyAdminSession. get_hierarchy_form_for_update", "response": "def get_hierarchy_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider HierarchyAdminSession.get_hierarchy_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'hierarchy_record_types' in kwargs:\n            return self.get_hierarchy_form_for_create(*args, **kwargs)\n        else:\n            return self.get_hierarchy_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_hierarchy(self, hierarchy_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if hierarchy_form.is_for_update():\n            return self.update_hierarchy(hierarchy_form, *args, **kwargs)\n        else:\n            return self.create_hierarchy(hierarchy_form, *args, **kwargs)", "response": "Pass through to provider HierarchyAdminSession. update_hierarchy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_hierarchy_view(self, session):\n        if self._hierarchy_view == FEDERATED:\n            try:\n                session.use_federated_hierarchy_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_hierarchy_view()\n            except AttributeError:\n                pass", "response": "Sets the underlying hierarchy view to match current view"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_object_view(self, session):\n        for obj_name in self._object_views:\n            if self._object_views[obj_name] == PLENARY:\n                try:\n                    getattr(session, 'use_plenary_' + obj_name + '_view')()\n                except AttributeError:\n                    pass\n            else:\n                try:\n                    getattr(session, 'use_comparative_' + obj_name + '_view')()\n                except AttributeError:\n                    pass", "response": "Sets the underlying object views to match current view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the underlying operable views to match current view", "response": "def _set_operable_view(self, session):\n        \"\"\"Sets the underlying operable views to match current view\"\"\"\n        for obj_name in self._operable_views:\n            if self._operable_views[obj_name] == ACTIVE:\n                try:\n                    getattr(session, 'use_active_' + obj_name + '_view')()\n                except AttributeError:\n                    pass\n            else:\n                try:\n                    getattr(session, 'use_any_status_' + obj_name + '_view')()\n                except AttributeError:\n                    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the underlying containable views to match current view", "response": "def _set_containable_view(self, session):\n        \"\"\"Sets the underlying containable views to match current view\"\"\"\n        for obj_name in self._containable_views:\n            if self._containable_views[obj_name] == SEQUESTERED:\n                try:\n                    getattr(session, 'use_sequestered_' + obj_name + '_view')()\n                except AttributeError:\n                    pass\n            else:\n                try:\n                    getattr(session, 'use_unsequestered_' + obj_name + '_view')()\n                except AttributeError:\n                    pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef host_context(func):\n    \"Sets the context of the setting to the current host\"\n    @wraps(func)\n    def decorator(*args, **kwargs):\n        hosts = get_hosts_settings()\n        with settings(**hosts[env.host]):\n            return func(*args, **kwargs)\n    return decorator", "response": "Sets the context of the setting to the current host"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches the latest code and merges up the specified commit.", "response": "def merge_commit(commit):\n    \"Fetches the latest code and merges up the specified commit.\"\n    with cd(env.path):\n        run('git fetch')\n        if '@' in commit:\n            branch, commit = commit.split('@')\n            run('git checkout {0}'.format(branch))\n        run('git merge {0}'.format(commit))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef migrate(app_name=None, revision=None):\n    \"Syncs and migrates the database using South.\"\n    cmd = ['python bin/manage.py syncdb --migrate']\n    if app_name:\n        cmd.append(app_name)\n        if revision:\n            cmd.append(revision)\n    verun(' '.join(cmd))", "response": "Syncs and migrates the database using South."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the PID for the wsgi process and sends a HUP signal.", "response": "def reload_wsgi():\n    \"Gets the PID for the wsgi process and sends a HUP signal.\"\n    pid = run('supervisorctl pid varify-{host}'.format(host=env.host))\n    try:\n        int(pid)\n        sudo('kill -HUP {0}'.format(pid))\n    except (TypeError, ValueError):\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset up the initial environment.", "response": "def setup():\n    \"Sets up the initial environment.\"\n    parent, project = os.path.split(env.path)\n\n    if not exists(parent):\n        run('mkdir -p {0}'.format(parent))\n        run('virtualenv {0}'.format(parent))\n\n    with cd(parent):\n        if not exists(project):\n            run('git clone {repo_url} {project}'.format(project=project, **env))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload the non - versioned local settings to the server.", "response": "def upload_settings():\n    \"Uploads the non-versioned local settings to the server.\"\n    local_path = os.path.join(curdir, 'settings/{0}.py'.format(env.host))\n    if os.path.exists(local_path):\n        remote_path = os.path.join(env.path, 'varify/conf/local_settings.py')\n        put(local_path, remote_path)\n    elif not confirm(yellow('No local settings found for host \"{0}\". Continue anyway?'.format(env.host))):\n        abort('No local settings found for host \"{0}\". Aborting.'.format(env.host))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(template_name, sender=None, to=None, cc=None, bcc=None, subject='mail',\n         attachments=(), html_template_name=None, context=None, headers=None,\n         reply_to=None):\n    \"\"\"\n    Render and send an email.  `template_name` is a plaintext template.\n\n    If `html_template_name` is passed then a multipart email will be sent using\n    `template_name` for the text part and `html_template_name` for the HTML part.\n    The context will include any `context` specified.\n\n    If no `sender` is specified then the `DEFAULT_FROM_EMAIL` or `SERVER_EMAIL`\n    setting will be used.\n\n    Extra email headers can be passed in to `headers` as a dictionary.\n    \"\"\"\n    to, cc, bcc, reply_to = map(listify, [to, cc, bcc, reply_to])\n\n    if sender is None:\n        sender = getattr(settings, 'DEFAULT_FROM_EMAIL', settings.SERVER_EMAIL)\n\n    attachment_list = [[a.name, a.read(), a.content_type] for a in attachments]\n\n    email_kwargs = {\n        'from_email': sender,\n        'to': to,\n        'cc': cc,\n        'bcc': bcc,\n        'subject': six.text_type(subject),\n        'attachments': attachment_list,\n        'reply_to': reply_to,\n        'headers': headers or {},\n    }\n\n    text_content = render_to_string(template_name, context)\n    email_kwargs['body'] = text_content\n\n    if html_template_name is None:\n        msg = EmailMessage(**email_kwargs)\n    else:\n        msg = EmailMultiAlternatives(**email_kwargs)\n        html_content = render_to_string(html_template_name, context)\n        msg.attach_alternative(html_content, 'text/html')\n\n    msg.send()", "response": "Render and send an email."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget account info. @param account: account to get info for @param params: parameters to retrieve @return: AccountInfo", "response": "def get_info(self, account, params={}):\n        \"\"\"\n        Gets account info.\n        @param account: account to get info for\n        @param params: parameters to retrieve\n        @return: AccountInfo\n        \"\"\"\n        res = self.invoke(zconstant.NS_ZIMBRA_ADMIN_URL,\n                          sconstant.GetInfoRequest,\n                          params)\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes metadata for source assessment taken id", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._source_assessment_taken_id_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'source_assessment_taken_id'),\n            'element_label': 'Source Assessment Taken ID that generated this one',\n            'instructions': 'accepts a valid OSID Id string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting node uri and content from backend", "response": "def materialize_node(self, node, uri, content, meta=None):\n        \"\"\"\n        Set node uri and content from backend\n        \"\"\"\n        node.uri = uri\n        node.content = content\n        node.meta = meta if meta is not None else {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking a tk. Canvas and a filepath loads image into canvas", "response": "def load_image(canvas, filepath, bounds=None):\n    \"\"\"Takes a tk.Canvas and a filepath, loads image into canvas\"\"\"\n\n    image_data = Image.open(filepath)\n    if bounds:\n        image_data.thumbnail(bounds, PIL.Image.ANTIALIAS)\n    canvas.image = ImageTk.PhotoImage(image_data)\n    canvas.create_image(0, 0, image=canvas.image, anchor=tk.NW)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_image(self, imagepath, width=None, height=None):\n\n        if width:\n            self.width = width\n            self.canvas[\"width\"] = width\n        if height:\n            self.height = height\n            self.canvas[\"height\"] = height\n\n        self.image = imagepath\n        size = (self.width, self.height)\n        load_image(self.canvas, self.image, bounds=size)\n        self.canvas.update_idletasks()", "response": "Loads new image into canvas updating size if needed."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a hierarchy traversal session for the hierarchy", "response": "def _get_hierarchy_session(self, hierarchy_id):\n        \"\"\"Returns a hierarchy traversal session for the hierarchy\"\"\"\n        hierarchy_mgr = self._get_provider_manager('HIERARCHY', local=True)\n        return hierarchy_mgr.get_hierarchy_traversal_session_for_hierarchy(\n            hierarchy_id,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if caching is enabled per configuration False otherwise.", "response": "def _caching_enabled(self):\n        \"\"\"Returns True if caching is enabled per configuration, false otherwise.\"\"\"\n        try:\n            config = self._runtime.get_configuration()\n            parameter_id = Id('parameter:useCachingForQualifierIds@json')\n            if config.get_value_by_parameter(parameter_id).get_boolean_value():\n                return True\n            else:\n                return False\n        except (AttributeError, KeyError, errors.NotFound):\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_parent_id_list(self, qualifier_id, hierarchy_id):\n        if self._caching_enabled():\n            key = 'parent_id_list_{0}'.format(str(qualifier_id))\n\n            # If configured to use memcache as the caching engine, use it.\n            # Otherwise default to diskcache\n            caching_engine = 'diskcache'\n\n            try:\n                config = self._runtime.get_configuration()\n                parameter_id = Id('parameter:cachingEngine@json')\n                caching_engine = config.get_value_by_parameter(parameter_id).get_string_value()\n            except (AttributeError, KeyError, errors.NotFound):\n                pass\n\n            if caching_engine == 'memcache':\n                import memcache\n                caching_host = '127.0.0.1:11211'\n                try:\n                    config = self._runtime.get_configuration()\n                    parameter_id = Id('parameter:cachingHostURI@json')\n                    caching_host = config.get_value_by_parameter(parameter_id).get_string_value()\n                except (AttributeError, KeyError, errors.NotFound):\n                    pass\n                mc = memcache.Client([caching_host], debug=0)\n                parent_id_list = mc.get(key)\n                if parent_id_list is None:\n                    parent_ids = self._get_hierarchy_session(hierarchy_id).get_parents(qualifier_id)\n                    parent_id_list = [str(parent_id) for parent_id in parent_ids]\n                    mc.set(key, parent_id_list)\n\n            elif caching_engine == 'diskcache':\n                import diskcache\n                with diskcache.Cache('/tmp/dlkit_cache') as cache:\n                    # A little bit non-DRY, since it's almost the same as for memcache above.\n                    # However, for diskcache.Cache, we have to call \".close()\" or use a\n                    #   ``with`` statement to safeguard calling \".close()\", so we keep this\n                    #   separate from the memcache implementation.\n                    parent_id_list = cache.get(key)\n                    if parent_id_list is None:\n                        parent_ids = self._get_hierarchy_session(hierarchy_id).get_parents(qualifier_id)\n                        parent_id_list = [str(parent_id) for parent_id in parent_ids]\n                        cache.set(key, parent_id_list)\n            else:\n                raise errors.NotFound('The {0} caching engine was not found.'.format(caching_engine))\n        else:\n            parent_ids = self._get_hierarchy_session(hierarchy_id).get_parents(qualifier_id)\n            parent_id_list = [str(parent_id) for parent_id in parent_ids]\n        return parent_id_list", "response": "Returns list of parent id strings for qualifier_id in hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_authorized(self, agent_id, function_id, qualifier_id):\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n\n        def is_parent_authorized(catalog_id):\n            \"\"\"Recursively checks parents for implicit authorizations\"\"\"\n            parent_id_list = self._get_parent_id_list(catalog_id, hierarchy_id)\n            if parent_id_list:\n                try:\n                    collection.find_one(\n                        {'agentId': str(agent_id),\n                         'functionId': str(function_id),\n                         'qualifierId': {'$in': parent_id_list}})\n                except errors.NotFound:\n                    for parent_id in parent_id_list:\n                        if is_parent_authorized(Id(parent_id)):\n                            return True\n                    return False\n                else:\n                    return True\n            else:\n                return False\n\n        # Check first for an explicit or 'ROOT' level implicit authorization:\n        try:\n            authority = qualifier_id.get_identifier_namespace().split('.')[0].upper()\n            identifier = qualifier_id.get_identifier_namespace().split('.')[1].upper()\n        except KeyError:\n            idstr_list = [str(qualifier_id)]\n            authority = identifier = None\n        else:\n            # handle aliased IDs\n            package_name = qualifier_id.get_identifier_namespace().split('.')[0]\n            qualifier_id = self._get_id(qualifier_id, package_name)\n\n            root_qualifier_id = Id(\n                authority=qualifier_id.get_authority(),\n                namespace=qualifier_id.get_identifier_namespace(),\n                identifier='ROOT')\n            idstr_list = [str(root_qualifier_id), str(qualifier_id)]\n        try:\n            collection.find_one(\n                {'agentId': str(agent_id),\n                 'functionId': str(function_id),\n                 'qualifierId': {'$in': idstr_list}})\n\n        # Otherwise check for implicit authorization through inheritance:\n        except errors.NotFound:\n            if authority and identifier:\n                hierarchy_id = Id(authority=authority,\n                                  namespace='CATALOG',\n                                  identifier=identifier)\n                return is_parent_authorized(qualifier_id)\n            else:\n                return False\n        else:\n            return True", "response": "Determines if the given agent is authorized for the given function and qualifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the Authorization specified by its Id.", "response": "def get_authorization(self, authorization_id):\n        \"\"\"Gets the ``Authorization`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Authorization`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to an ``Authorization`` and\n        retained for compatibility.\n\n        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization`` to retrieve\n        return: (osid.authorization.Authorization) - the returned\n                ``Authorization``\n        raise:  NotFound - no ``Authorization`` found with the given\n                ``Id``\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(authorization_id, 'authorization').get_identifier())},\n                 **self._view_filter()))\n        return objects.Authorization(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_authorizations_by_ids(self, authorization_ids):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in authorization_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'authorization').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.AuthorizationList(sorted_result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an AuthorizationList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets an authorization list corresponding to the given authorization genus Type which does not include authorizations of genus types derived from the specified Type.", "response": "def get_authorizations_by_genus_type(self, authorization_genus_type):\n        \"\"\"Gets an ``AuthorizationList`` corresponding to the given authorization genus ``Type`` which does not include authorizations of genus types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session.\n\n        arg:    authorization_genus_type (osid.type.Type): an\n                authorization genus type\n        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list\n        raise:  NullArgument - ``authorization_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(authorization_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AuthorizationList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an AuthorizationList effective during the entire given date range inclusive but not confined to the date range.", "response": "def get_authorizations_on_date(self, from_, to):\n        \"\"\"Gets an ``AuthorizationList`` effective during the entire given date range inclusive but not confined to the date range.\n\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list\n        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_on_date\n        authorization_list = []\n        for authorization in self.get_authorizations():\n            if overlap(from_, to, authorization.start_date, authorization.end_date):\n                authorization_list.append(authorization)\n        return objects.AuthorizationList(authorization_list, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_authorizations_for_function(self, function_id):\n        # Implemented from template for\n        # osid.learning.ActivityLookupSession.get_activities_for_objective_template\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'functionId': str(function_id)},\n                 **self._view_filter()))\n        return objects.AuthorizationList(result, runtime=self._runtime)", "response": "Gets a list of authorizations associated with a given function."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of authorizations related to a given resource and function.", "response": "def get_authorizations_for_resource_and_function(self, resource_id, function_id):\n        \"\"\"Gets a list of ``Authorizations`` associated with a given resource.\n\n        Authorizations related to the given resource, including those\n        related through an ``Agent,`` are returned. In plenary mode, the\n        returned list contains all known authorizations or an error\n        results. Otherwise, the returned list may contain only those\n        authorizations that are accessible through this session.\n\n        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    function_id (osid.id.Id): a function ``Id``\n        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``\n        raise:  NullArgument - ``resource_id`` or ``function_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_peers\n        # NOTE: This implementation currently ignores plenary and effective views\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'sourceId': str(resource_id),\n                  'destinationId': str(function_id)},\n                 **self._view_filter())).sort('_id', ASCENDING)\n        return objects.AuthorizationList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a list of authorizations related to a given agent and function.", "response": "def get_authorizations_for_agent_and_function(self, agent_id, function_id):\n        \"\"\"Gets a list of ``Authorizations`` associated with a given agent.\n\n        Authorizations related to the given resource, including those\n        related through an ``Agent,`` are returned. In plenary mode, the\n        returned list contains all known authorizations or an error\n        results. Otherwise, the returned list may contain only those\n        authorizations that are accessible through this session.\n\n        arg:    agent_id (osid.id.Id): an agent ``Id``\n        arg:    function_id (osid.id.Id): a function ``Id``\n        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``\n        raise:  NullArgument - ``agent_id`` or ``function_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'agentId': str(agent_id),\n                  'functionId': str(function_id)},\n                 **self._view_filter())).sort('_sort_id', ASCENDING)\n        return objects.AuthorizationList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_authorizations(self):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.AuthorizationList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of all authorizations for this resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of Authorizations matching the given query.", "response": "def get_authorizations_by_query(self, authorization_query):\n        \"\"\"Gets a list of ``Authorizations`` matching the given query.\n\n        arg:    authorization_query\n                (osid.authorization.AuthorizationQuery): the\n                authorization query\n        return: (osid.authorization.AuthorizationList) - the returned\n                ``AuthorizationList``\n        raise:  NullArgument - ``authorization_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``authorization_query`` is not of this\n                service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in authorization_query._query_terms:\n            if '$in' in authorization_query._query_terms[term] and '$nin' in authorization_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': authorization_query._query_terms[term]['$in']}},\n                             {term: {'$nin': authorization_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: authorization_query._query_terms[term]})\n        for term in authorization_query._keyword_terms:\n            or_list.append({term: authorization_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('authorization',\n                                             collection='Authorization',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.AuthorizationList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_authorization_form_for_create_for_agent(self, agent_id, function_id, qualifier_id, authorization_record_types):\n        if not isinstance(agent_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        if not isinstance(function_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        if not isinstance(qualifier_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in authorization_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if authorization_record_types == []:\n            # WHY are we passing vault_id = self._catalog_id below, seems redundant:\n            # We probably also don't need to send agent_id. The form can now get that from the proxy\n            obj_form = objects.AuthorizationForm(\n                vault_id=self._catalog_id,\n                agent_id=agent_id,\n                function_id=function_id,\n                qualifier_id=qualifier_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.AuthorizationForm(\n                vault_id=self._catalog_id,\n                record_types=authorization_record_types,\n                agent_id=agent_id,\n                function_id=function_id,\n                qualifier_id=qualifier_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the authorization form for creating new authorizations for the given agent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new explicit authorization.", "response": "def create_authorization(self, authorization_form):\n        \"\"\"Creates a new explicit ``Authorization``.\n\n        arg:    authorization_form\n                (osid.authorization.AuthorizationForm): the\n                authorization form\n        return: (osid.authorization.Authorization) - ``t`` he new\n                ``Authorization``\n        raise:  IllegalState - ``authorization_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``authorization_form`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``authorization_form`` did not originate\n                from this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # TODO: not using the create_resource template\n        # because want to prevent duplicate authorizations\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        if not isinstance(authorization_form, ABCAuthorizationForm):\n            raise errors.InvalidArgument('argument type is not an AuthorizationForm')\n        if authorization_form.is_for_update():\n            raise errors.InvalidArgument('the AuthorizationForm is for update only, not create')\n        try:\n            if self._forms[authorization_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('authorization_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('authorization_form did not originate from this session')\n        if not authorization_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n\n        # try to check first here\n        try:\n            osid_map = collection.find_one({\"agentId\": authorization_form._my_map['agentId'],\n                                            \"functionId\": authorization_form._my_map['functionId'],\n                                            \"qualifierId\": authorization_form._my_map['qualifierId'],\n                                            \"assignedVaultIds\": authorization_form._my_map['assignedVaultIds']})\n            osid_map['startDate'] = authorization_form._my_map['startDate']\n            osid_map['endDate'] = authorization_form._my_map['endDate']\n            collection.save(osid_map)\n        except errors.NotFound:\n            insert_result = collection.insert_one(authorization_form._my_map)\n\n            self._forms[authorization_form.get_id().get_identifier()] = CREATED\n            osid_map = collection.find_one({'_id': insert_result.inserted_id})\n        result = objects.Authorization(\n            osid_object_map=osid_map,\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate an existing authorization.", "response": "def update_authorization(self, authorization_form):\n        \"\"\"Updates an existing authorization.\n\n        arg:    authorization_form\n                (osid.authorization.AuthorizationForm): the\n                authorization ``Id``\n        raise:  IllegalState - ``authorization_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``authorization_form`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``authorization_form`` did not originate\n                from ``get_authorization_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        if not isinstance(authorization_form, ABCAuthorizationForm):\n            raise errors.InvalidArgument('argument type is not an AuthorizationForm')\n        if not authorization_form.is_for_update():\n            raise errors.InvalidArgument('the AuthorizationForm is for update only, not create')\n        try:\n            if self._forms[authorization_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('authorization_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('authorization_form did not originate from this session')\n        if not authorization_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(authorization_form._my_map)\n\n        self._forms[authorization_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Authorization(\n            osid_object_map=authorization_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the authorization identified by the given Id.", "response": "def delete_authorization(self, authorization_id):\n        \"\"\"Deletes the ``Authorization`` identified by the given ``Id``.\n\n        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization`` to delete\n        raise:  NotFound - an ``Authorization`` was not found identified\n                by the given ``Id``\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('authorization',\n                                         collection='Authorization',\n                                         runtime=self._runtime)\n        if not isinstance(authorization_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        authorization_map = collection.find_one(\n            dict({'_id': ObjectId(authorization_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.Authorization(osid_object_map=authorization_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(authorization_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef alias_authorization(self, authorization_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=authorization_id, equivalent_id=alias_id)", "response": "Adds an Id to an existing authorization for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef use_comparative_vault_view(self):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.use_comparative_bin_view\n        self._catalog_view = COMPARATIVE\n        if self._catalog_session is not None:\n            self._catalog_session.use_comparative_catalog_view()", "response": "Overrides the base lookup method to use the ComparativeVaultView"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_plenary_vault_view(self):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.use_plenary_bin_view\n        self._catalog_view = PLENARY\n        if self._catalog_session is not None:\n            self._catalog_session.use_plenary_catalog_view()", "response": "A complete view of the Authorization and Vault returns is desired."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the list of Authorization Id s associated with a Vault.", "response": "def get_authorization_ids_by_vault(self, vault_id):\n        \"\"\"Gets the list of ``Authorization``  ``Ids`` associated with a ``Vault``.\n\n        arg:    vault_id (osid.id.Id): ``Id`` of a ``Vault``\n        return: (osid.id.IdList) - list of related authorization ``Ids``\n        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for authorization in self.get_authorizations_by_vault(vault_id):\n            id_list.append(authorization.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_authorizations_by_vault(self, vault_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('AUTHORIZATION', local=True)\n        lookup_session = mgr.get_authorization_lookup_session_for_vault(vault_ids, proxy=self._proxy)\n        lookup_session.use_isolated_vault_view()\n        return lookup_session.get_authorizations()", "response": "Gets the list of Authorizations associated with a Vault."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_authorizations_ids_by_vault(self, vault_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for authorization in self.get_authorizations_by_vault(vault_ids):\n            id_list.append(authorization.get_id())\n        return IdList(id_list)", "response": "Gets the list of Authorization Ids corresponding to a list of Vault objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the list of vault Ids mapped to an Authorization.", "response": "def get_vault_ids_by_authorization(self, authorization_id):\n        \"\"\"Gets the list of ``Vault``  ``Ids`` mapped to an ``Authorization``.\n\n        arg:    authorization_id (osid.id.Id): ``Id`` of an\n                ``Authorization``\n        return: (osid.id.IdList) - list of vault ``Ids``\n        raise:  NotFound - ``authorization_id`` is not found\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('AUTHORIZATION', local=True)\n        lookup_session = mgr.get_authorization_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_vault_view()\n        authorization = lookup_session.get_authorization(authorization_id)\n        id_list = []\n        for idstr in authorization._my_map['assignedVaultIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of vault including and under the given vault node in which any authorization can be assigned.", "response": "def get_assignable_vault_ids(self, vault_id):\n        \"\"\"Gets a list of vault including and under the given vault node in which any authorization can be assigned.\n\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        return: (osid.id.IdList) - list of assignable vault ``Ids``\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.get_assignable_bin_ids\n        # This will likely be overridden by an authorization adapter\n        mgr = self._get_provider_manager('AUTHORIZATION', local=True)\n        lookup_session = mgr.get_vault_lookup_session(proxy=self._proxy)\n        vaults = lookup_session.get_vaults()\n        id_list = []\n        for vault in vaults:\n            id_list.append(vault.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an existing Authorization to a Vault.", "response": "def assign_authorization_to_vault(self, authorization_id, vault_id):\n        \"\"\"Adds an existing ``Authorization`` to a ``Vault``.\n\n        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization``\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        raise:  AlreadyExists - ``authorization_id`` is already assigned\n                to ``vault_id``\n        raise:  NotFound - ``authorization_id`` or ``vault_id`` not\n                found\n        raise:  NullArgument - ``authorization_id`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('AUTHORIZATION', local=True)\n        lookup_session = mgr.get_vault_lookup_session(proxy=self._proxy)\n        lookup_session.get_vault(vault_id)  # to raise NotFound\n        self._assign_object_to_catalog(authorization_id, vault_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving an Authorization from a Vault.", "response": "def unassign_authorization_from_vault(self, authorization_id, vault_id):\n        \"\"\"Removes an ``Authorization`` from a ``Vault``.\n\n        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization``\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        raise:  NotFound - ``authorization_id`` or ``vault_id`` not\n                found or ``authorization_id`` not assigned to\n                ``vault_id``\n        raise:  NullArgument - ``authorization_id`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('AUTHORIZATION', local=True)\n        lookup_session = mgr.get_vault_lookup_session(proxy=self._proxy)\n        lookup_session.get_vault(vault_id)  # to raise NotFound\n        self._unassign_object_from_catalog(authorization_id, vault_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reassign_authorization_to_vault(self, authorization_id, from_vault_id, to_vault_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.reassign_resource_to_bin\n        self.assign_authorization_to_vault(authorization_id, to_vault_id)\n        try:\n            self.unassign_authorization_from_vault(authorization_id, from_vault_id)\n        except:  # something went wrong, roll back assignment to to_vault_id\n            self.unassign_authorization_from_vault(authorization_id, to_vault_id)\n            raise", "response": "Moves an authorization from one Vault to another."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of Vaults of types derived from the given vault genus Type", "response": "def get_vaults_by_genus_type(self, vault_genus_type):\n        \"\"\"Gets a ``VaultList`` corresponding to the given vault genus ``Type`` which does not include vaults of types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known vaults or\n        an error results. Otherwise, the returned list may contain only\n        those vaults that are accessible through this session.\n\n        arg:    vault_genus_type (osid.type.Type): a vault genus type\n        return: (osid.authorization.VaultList) - the returned ``Vault``\n                list\n        raise:  NullArgument - ``vault_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('authorization',\n                                         collection='Vault',\n                                         runtime=self._runtime)\n        result = collection.find({'genusTypeId': {'$in': [str(vault_genus_type)]}}).sort('_id', DESCENDING)\n\n        return objects.VaultList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vaults_by_query(self, vault_query):\n        # Implemented from template for\n        # osid.resource.BinQuerySession.get_bins_by_query_template\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalogs_by_query(vault_query)\n        query_terms = dict(vault_query._query_terms)\n        collection = JSONClientValidated('authorization',\n                                         collection='Vault',\n                                         runtime=self._runtime)\n        result = collection.find(query_terms).sort('_id', DESCENDING)\n\n        return objects.VaultList(result, runtime=self._runtime)", "response": "Gets a list of Vault objects matching the given search."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef can_create_vault_with_record_types(self, vault_record_types):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=vault_record_types)\n        return True", "response": "Tests if this user can create a single Vault using the desired record types."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the vault form for creating new vaults.", "response": "def get_vault_form_for_create(self, vault_record_types):\n        \"\"\"Gets the vault form for creating new vaults.\n\n        A new form should be requested for each create transaction.\n\n        arg:    vault_record_types (osid.type.Type[]): array of vault\n                record types\n        return: (osid.authorization.VaultForm) - the vault form\n        raise:  NullArgument - ``vault_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form qith requested record\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.get_bin_form_for_create_template\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalog_form_for_create(catalog_record_types=vault_record_types)\n        for arg in vault_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if vault_record_types == []:\n            result = objects.VaultForm(\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)  # Probably don't need effective agent id now that we have proxy in form.\n        else:\n            result = objects.VaultForm(\n                record_types=vault_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)  # Probably don't need effective agent id now that we have proxy in form.\n        self._forms[result.get_id().get_identifier()] = not CREATED\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new Vault.", "response": "def create_vault(self, vault_form):\n        \"\"\"Creates a new ``Vault``.\n\n        arg:    vault_form (osid.authorization.VaultForm): the form for\n                this ``Vault``\n        return: (osid.authorization.Vault) - the new ``Vault``\n        raise:  IllegalState - ``vault_form`` already used in a create\n                transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``vault_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``vault_form`` did not originate from\n                ``get_vault_form_for_create()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.create_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.create_catalog(catalog_form=vault_form)\n        collection = JSONClientValidated('authorization',\n                                         collection='Vault',\n                                         runtime=self._runtime)\n        if not isinstance(vault_form, ABCVaultForm):\n            raise errors.InvalidArgument('argument type is not an VaultForm')\n        if vault_form.is_for_update():\n            raise errors.InvalidArgument('the VaultForm is for update only, not create')\n        try:\n            if self._forms[vault_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('vault_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('vault_form did not originate from this session')\n        if not vault_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(vault_form._my_map)\n\n        self._forms[vault_form.get_id().get_identifier()] = CREATED\n        result = objects.Vault(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vault_form_for_update(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalog_form_for_update(catalog_id=vault_id)\n        collection = JSONClientValidated('authorization',\n                                         collection='Vault',\n                                         runtime=self._runtime)\n        if not isinstance(vault_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        result = collection.find_one({'_id': ObjectId(vault_id.get_identifier())})\n\n        cat_form = objects.VaultForm(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)\n        self._forms[cat_form.get_id().get_identifier()] = not UPDATED\n\n        return cat_form", "response": "Gets the vault form for updating an existing vault."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_vault(self, vault_form):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=vault_form)\n        collection = JSONClientValidated('authorization',\n                                         collection='Vault',\n                                         runtime=self._runtime)\n        if not isinstance(vault_form, ABCVaultForm):\n            raise errors.InvalidArgument('argument type is not an VaultForm')\n        if not vault_form.is_for_update():\n            raise errors.InvalidArgument('the VaultForm is for update only, not create')\n        try:\n            if self._forms[vault_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('vault_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('vault_form did not originate from this session')\n        if not vault_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(vault_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[vault_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Vault(osid_object_map=vault_form._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Updates an existing vault."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_vault(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.delete_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.delete_catalog(catalog_id=vault_id)\n        collection = JSONClientValidated('authorization',\n                                         collection='Vault',\n                                         runtime=self._runtime)\n        if not isinstance(vault_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        for object_catalog in ['Authorization', 'Function', 'Qualifier', 'Vault']:\n            obj_collection = JSONClientValidated('authorization',\n                                                 collection=object_catalog,\n                                                 runtime=self._runtime)\n            if obj_collection.find({'assignedVaultIds': {'$in': [str(vault_id)]}}).count() != 0:\n                raise errors.IllegalState('catalog is not empty')\n        collection.delete_one({'_id': ObjectId(vault_id.get_identifier())})", "response": "Deletes a ``Vault``.\n\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault`` to\n                remove\n        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef alias_vault(self, vault_id, alias_id):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=vault_id, alias_id=alias_id)\n        self._alias_id(primary_id=vault_id, equivalent_id=alias_id)", "response": "Adds an Id to a Vault for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_root_vaults(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return VaultLookupSession(\n            self._proxy,\n            self._runtime).get_vaults_by_ids(list(self.get_root_vault_ids()))", "response": "Gets the root vaults in this vault hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_parent_vaults(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=vault_id)\n        return self._hierarchy_session.has_parents(id_=vault_id)", "response": "Tests if the Vault has any parents."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if an Id is a direct parent of a vault.", "response": "def is_parent_of_vault(self, id_, vault_id):\n        \"\"\"Tests if an ``Id`` is a direct parent of a vault.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``vault_id,``  ``false`` otherwise\n        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``id`` or ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=vault_id)\n        return self._hierarchy_session.is_parent(id_=vault_id, parent_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_parent_vault_ids(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=vault_id)\n        return self._hierarchy_session.get_parents(id_=vault_id)", "response": "Gets the parent Ids of the given vault."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_parent_vaults(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=vault_id)\n        return VaultLookupSession(\n            self._proxy,\n            self._runtime).get_vaults_by_ids(\n                list(self.get_parent_vault_ids(vault_id)))", "response": "Gets the parents of the given vault."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if an Id is an ancestor of a vault.", "response": "def is_ancestor_of_vault(self, id_, vault_id):\n        \"\"\"Tests if an ``Id`` is an ancestor of a vault.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``vault_id,``  ``false`` otherwise\n        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=vault_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=vault_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest if a vault has any children.", "response": "def has_child_vaults(self, vault_id):\n        \"\"\"Tests if a vault has any children.\n\n        arg:    vault_id (osid.id.Id): a ``vault_id``\n        return: (boolean) - ``true`` if the ``vault_id`` has children,\n                ``false`` otherwise\n        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=vault_id)\n        return self._hierarchy_session.has_children(id_=vault_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_child_of_vault(self, id_, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=vault_id)\n        return self._hierarchy_session.is_child(id_=vault_id, child_id=id_)", "response": "Tests if a vault is a direct child of another."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_child_vault_ids(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=vault_id)\n        return self._hierarchy_session.get_children(id_=vault_id)", "response": "Gets the child Ids of the given vault."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_child_vaults(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=vault_id)\n        return VaultLookupSession(\n            self._proxy,\n            self._runtime).get_vaults_by_ids(\n                list(self.get_child_vault_ids(vault_id)))", "response": "Gets the children of the given vault."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_descendant_of_vault(self, id_, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=vault_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=vault_id)", "response": "Tests if an Id is a descendant of a vault."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_vault_nodes(self, vault_id, ancestor_levels, descendant_levels, include_siblings):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.VaultNode(self.get_vault_node_ids(\n            vault_id=vault_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a portion of the hierarchy for the given vault."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a root vault.", "response": "def add_root_vault(self, vault_id):\n        \"\"\"Adds a root vault.\n\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        raise:  AlreadyExists - ``vault_id`` is already in hierarchy\n        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=vault_id)\n        return self._hierarchy_session.add_root(id_=vault_id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_root_vault(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=vault_id)\n        return self._hierarchy_session.remove_root(id_=vault_id)", "response": "Removes a root vault from this hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a child to a vault.", "response": "def add_child_vault(self, vault_id, child_id):\n        \"\"\"Adds a child to a vault.\n\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``vault_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``vault_id`` or ``child_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=vault_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=vault_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a child from a vault.", "response": "def remove_child_vault(self, vault_id, child_id):\n        \"\"\"Removes a child from a vault.\n\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        arg:    child_id (osid.id.Id): the ``Id`` of the child\n        raise:  NotFound - ``vault_id`` not parent of ``child_id``\n        raise:  NullArgument - ``vault_id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=vault_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=vault_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_child_vaults(self, vault_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalogs(catalog_id=vault_id)\n        return self._hierarchy_session.remove_children(id_=vault_id)", "response": "Removes all children from a vault."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the grade system specified by its Id.", "response": "def get_grade_system(self, grade_system_id):\n        \"\"\"Gets the ``GradeSystem`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``GradeSystem`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``GradeSystem`` and retained\n        for compatibility.\n\n        arg:    grade_system_id (osid.id.Id): ``Id`` of the\n                ``GradeSystem``\n        return: (osid.grading.GradeSystem) - the grade system\n        raise:  NotFound - ``grade_system_id`` not found\n        raise:  NullArgument - ``grade_system_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(grade_system_id, 'grading').get_identifier())},\n                 **self._view_filter()))\n        return objects.GradeSystem(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a GradeSystemList corresponding to the given IdList.", "response": "def get_grade_systems_by_ids(self, grade_system_ids):\n        \"\"\"Gets a ``GradeSystemList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the systems\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``GradeSystems`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set.\n\n        arg:    grade_system_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n        return: (osid.grading.GradeSystemList) - the returned\n                ``GradeSystem`` list\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``grade_system_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in grade_system_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'grading').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.GradeSystemList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_grade_systems_by_genus_type(self, grade_system_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(grade_system_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.GradeSystemList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a GradeSystemList corresponding to the given grade system genus Type which does not include systems of genus types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_grade_systems(self):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.GradeSystemList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets all grade systems in the current session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_grade_systems_by_query(self, grade_system_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in grade_system_query._query_terms:\n            if '$in' in grade_system_query._query_terms[term] and '$nin' in grade_system_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': grade_system_query._query_terms[term]['$in']}},\n                             {term: {'$nin': grade_system_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: grade_system_query._query_terms[term]})\n        for term in grade_system_query._keyword_terms:\n            or_list.append({term: grade_system_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('grading',\n                                             collection='GradeSystem',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.GradeSystemList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of grade system objects matching the given grade system query."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_grade_system_form_for_create(self, grade_system_record_types):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in grade_system_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if grade_system_record_types == []:\n            obj_form = objects.GradeSystemForm(\n                gradebook_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.GradeSystemForm(\n                gradebook_id=self._catalog_id,\n                record_types=grade_system_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the grade system form for creating new grade systems."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new grade system.", "response": "def create_grade_system(self, grade_system_form):\n        \"\"\"Creates a new ``GradeSystem``.\n\n        arg:    grade_system_form (osid.grading.GradeSystemForm): the\n                form for this ``GradeSystem``\n        return: (osid.grading.GradeSystem) - the new ``GradeSystem``\n        raise:  IllegalState - ``grade_system_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``grade_system_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``grade_system_form`` did not originate\n                from ``get_grade_system_form_for_create()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        if not isinstance(grade_system_form, ABCGradeSystemForm):\n            raise errors.InvalidArgument('argument type is not an GradeSystemForm')\n        if grade_system_form.is_for_update():\n            raise errors.InvalidArgument('the GradeSystemForm is for update only, not create')\n        try:\n            if self._forms[grade_system_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('grade_system_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('grade_system_form did not originate from this session')\n        if not grade_system_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(grade_system_form._my_map)\n\n        self._forms[grade_system_form.get_id().get_identifier()] = CREATED\n        result = objects.GradeSystem(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate an existing grade system.", "response": "def update_grade_system(self, grade_system_form):\n        \"\"\"Updates an existing grade system.\n\n        arg:    grade_system_form (osid.grading.GradeSystemForm): the\n                form containing the elements to be updated\n        raise:  IllegalState - ``grade_system_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``grade_system_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``grade_system_form`` did not originate\n                from ``get_grade_system_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        if not isinstance(grade_system_form, ABCGradeSystemForm):\n            raise errors.InvalidArgument('argument type is not an GradeSystemForm')\n        if not grade_system_form.is_for_update():\n            raise errors.InvalidArgument('the GradeSystemForm is for update only, not create')\n        try:\n            if self._forms[grade_system_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('grade_system_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('grade_system_form did not originate from this session')\n        if not grade_system_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(grade_system_form._my_map)\n\n        self._forms[grade_system_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.GradeSystem(\n            osid_object_map=grade_system_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete a grade system.", "response": "def delete_grade_system(self, grade_system_id):\n        \"\"\"Deletes a ``GradeSystem``.\n\n        arg:    grade_system_id (osid.id.Id): the ``Id`` of the\n                ``GradeSystem`` to remove\n        raise:  NotFound - ``grade_system_id`` not found\n        raise:  NullArgument - ``grade_system_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        if not isinstance(grade_system_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        grade_system_map = collection.find_one({'_id': ObjectId(grade_system_id.get_identifier())})\n\n        # check if has columns first\n        if self._has_columns(grade_system_id):\n            raise errors.InvalidArgument('Grade system being used by gradebook columns. ' +\n                                         'Cannot delete it.')\n\n        objects.GradeSystem(osid_object_map=grade_system_map,\n                            runtime=self._runtime,\n                            proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(grade_system_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an Id to a grade system.", "response": "def alias_grade_system(self, grade_system_id, alias_id):\n        \"\"\"Adds an ``Id`` to a ``GradeSystem`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``GradeSystem`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another grade system, it is\n        reassigned to the given grade system ``Id``.\n\n        arg:    grade_system_id (osid.id.Id): the ``Id`` of a\n                ``GradeSystem``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``grade_system_id`` not found\n        raise:  NullArgument - ``grade_system_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=grade_system_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_grade_form_for_create(self, grade_system_id, grade_record_types):\n        # Implemented from template for\n        # osid.learning.ActivityAdminSession.get_activity_form_for_create_template\n\n        if not isinstance(grade_system_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in grade_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if grade_record_types == []:\n            # WHY are we passing gradebook_id = self._catalog_id below, seems redundant:\n            obj_form = objects.GradeForm(\n                gradebook_id=self._catalog_id,\n                grade_system_id=grade_system_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.GradeForm(\n                gradebook_id=self._catalog_id,\n                record_types=grade_record_types,\n                grade_system_id=grade_system_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the grade form for creating new grades."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_grade(self, grade_form):\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.create_asset_content_template\n        from dlkit.abstract_osid.grading.objects import GradeForm as ABCGradeForm\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        if not isinstance(grade_form, ABCGradeForm):\n            raise errors.InvalidArgument('argument type is not an GradeForm')\n        if grade_form.is_for_update():\n            raise errors.InvalidArgument('the GradeForm is for update only, not create')\n        try:\n            if self._forms[grade_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('grade_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('grade_form did not originate from this session')\n        if not grade_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        grade_form._my_map['_id'] = ObjectId()\n        grade_system_id = Id(grade_form._my_map['gradeSystemId']).get_identifier()\n        grade_system = collection.find_one(\n            {'$and': [{'_id': ObjectId(grade_system_id)},\n                      {'assigned' + self._catalog_name + 'Ids': {'$in': [str(self._catalog_id)]}}]})\n        grade_system['grades'].append(grade_form._my_map)\n        result = collection.save(grade_system)\n\n        self._forms[grade_form.get_id().get_identifier()] = CREATED\n        from .objects import Grade\n        return Grade(\n            osid_object_map=grade_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Creates a new grade."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate an existing grade.", "response": "def update_grade(self, grade_form):\n        \"\"\"Updates an existing grade.\n\n        arg:    grade_form (osid.grading.GradeForm): the form containing\n                the elements to be updated\n        raise:  IllegalState - ``grade_form`` already used in an update\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``grade_id`` or ``grade_form`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``grade_form`` did not originate from\n                ``get_grade_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.update_asset_content_template\n        from dlkit.abstract_osid.grading.objects import GradeForm as ABCGradeForm\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        if not isinstance(grade_form, ABCGradeForm):\n            raise errors.InvalidArgument('argument type is not an GradeForm')\n        if not grade_form.is_for_update():\n            raise errors.InvalidArgument('the GradeForm is for update only, not create')\n        try:\n            if self._forms[grade_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('grade_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('grade_form did not originate from this session')\n        if not grade_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        grade_system_id = Id(grade_form._my_map['gradeSystemId']).get_identifier()\n        grade_system = collection.find_one(\n            {'$and': [{'_id': ObjectId(grade_system_id)},\n                      {'assigned' + self._catalog_name + 'Ids': {'$in': [str(self._catalog_id)]}}]})\n        index = 0\n        found = False\n        for i in grade_system['grades']:\n            if i['_id'] == ObjectId(grade_form._my_map['_id']):\n                grade_system['grades'].pop(index)\n                grade_system['grades'].insert(index, grade_form._my_map)\n                found = True\n                break\n            index += 1\n        if not found:\n            raise errors.NotFound()\n        try:\n            collection.save(grade_system)\n        except:  # what exceptions does mongodb save raise?\n            raise errors.OperationFailed()\n        self._forms[grade_form.get_id().get_identifier()] = UPDATED\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        from .objects import Grade\n\n        return Grade(\n            osid_object_map=grade_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete a ``Grade``. arg: grade_id (osid.id.Id): the ``Id`` of the ``Grade`` to remove raise: NotFound - ``grade_id`` not found raise: NullArgument - ``grade_id`` is ``null`` raise: OperationFailed - unable to complete request raise: PermissionDenied - authorization failure *compliance: mandatory -- This method must be implemented.*", "response": "def delete_grade(self, grade_id):\n        \"\"\"Deletes a ``Grade``.\n\n        arg:    grade_id (osid.id.Id): the ``Id`` of the ``Grade`` to\n                remove\n        raise:  NotFound - ``grade_id`` not found\n        raise:  NullArgument - ``grade_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.delete_asset_content_template\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        from .objects import Grade\n        collection = JSONClientValidated('grading',\n                                         collection='GradeSystem',\n                                         runtime=self._runtime)\n        if not isinstance(grade_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        grade_system = collection.find_one({'grades._id': ObjectId(grade_id.get_identifier())})\n\n        index = 0\n        found = False\n        for i in grade_system['grades']:\n            if i['_id'] == ObjectId(grade_id.get_identifier()):\n                grade_map = grade_system['grades'].pop(index)\n            index += 1\n            found = True\n        if not found:\n            raise errors.OperationFailed()\n        Grade(\n            osid_object_map=grade_map,\n            runtime=self._runtime,\n            proxy=self._proxy)._delete()\n        collection.save(grade_system)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_grade_system_ids_by_gradebook(self, gradebook_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for grade_system in self.get_grade_systems_by_gradebook(gradebook_id):\n            id_list.append(grade_system.get_id())\n        return IdList(id_list)", "response": "Gets the list of GradeSystem Ids associated with a Gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_grade_systems_by_gradebook(self, gradebook_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_grade_system_lookup_session_for_gradebook(gradebook_id, proxy=self._proxy)\n        lookup_session.use_isolated_gradebook_view()\n        return lookup_session.get_grade_systems()", "response": "Gets the list of grade systems associated with a Gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_grade_system_ids_by_gradebooks(self, gradebook_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for grade_system in self.get_grade_systems_by_gradebooks(gradebook_ids):\n            id_list.append(grade_system.get_id())\n        return IdList(id_list)", "response": "Gets the list of GradeSystem Ids corresponding to a list of Gradebooks."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the list of grade systems corresponding to a list of Gradebooks.", "response": "def get_grade_systems_by_gradebooks(self, gradebook_ids):\n        \"\"\"Gets the list of grade systems corresponding to a list of ``Gradebooks``.\n\n        arg:    gradebook_ids (osid.id.IdList): list of gradebook\n                ``Ids``\n        return: (osid.grading.GradeSystemList) - list of grade systems\n        raise:  NullArgument - ``gradebook_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        grade_system_list = []\n        for gradebook_id in gradebook_ids:\n            grade_system_list += list(\n                self.get_grade_systems_by_gradebook(gradebook_id))\n        return objects.GradeSystemList(grade_system_list)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_gradebook_ids_by_grade_system(self, grade_system_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_grade_system_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_gradebook_view()\n        grade_system = lookup_session.get_grade_system(grade_system_id)\n        id_list = []\n        for idstr in grade_system._my_map['assignedGradebookIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)", "response": "Gets the list of Gradebook Ids mapped to a GradeSystem."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gradebooks_by_grade_system(self, grade_system_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_lookup_session(proxy=self._proxy)\n        return lookup_session.get_gradebooks_by_ids(\n            self.get_gradebook_ids_by_grade_system(grade_system_id))", "response": "Gets the list of Gradebooks mapped to a GradeSystem."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list of gradebooks including and under the given gradebook node in which any grade system can be assigned.", "response": "def get_assignable_gradebook_ids(self, gradebook_id):\n        \"\"\"Gets a list of gradebooks including and under the given gradebook node in which any grade system can be assigned.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of the\n                ``Gradebook``\n        return: (osid.id.IdList) - list of assignable gradebook ``Ids``\n        raise:  NullArgument - ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.get_assignable_bin_ids\n        # This will likely be overridden by an authorization adapter\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_lookup_session(proxy=self._proxy)\n        gradebooks = lookup_session.get_gradebooks()\n        id_list = []\n        for gradebook in gradebooks:\n            id_list.append(gradebook.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an existing GradeSystem to a Gradebook.", "response": "def assign_grade_system_to_gradebook(self, grade_system_id, gradebook_id):\n        \"\"\"Adds an existing ``GradeSystem`` to a ``Gradebook``.\n\n        arg:    grade_system_id (osid.id.Id): the ``Id`` of the\n                ``GradeSystem``\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of the\n                ``Gradebook``\n        raise:  AlreadyExists - ``grade_system_id`` is already assigned\n                to ``gradebook_id``\n        raise:  NotFound - ``grade_system_id`` or ``gradebook_id`` not\n                found\n        raise:  NullArgument - ``grade_system_id`` or ``gradebook_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_lookup_session(proxy=self._proxy)\n        lookup_session.get_gradebook(gradebook_id)  # to raise NotFound\n        self._assign_object_to_catalog(grade_system_id, gradebook_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unassign_grade_system_from_gradebook(self, grade_system_id, gradebook_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_lookup_session(proxy=self._proxy)\n        lookup_session.get_gradebook(gradebook_id)  # to raise NotFound\n        self._unassign_object_from_catalog(grade_system_id, gradebook_id)", "response": "Removes a GradeSystem from a Gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the GradeEntry specified by its Id.", "response": "def get_grade_entry(self, grade_entry_id):\n        \"\"\"Gets the ``GradeEntry`` specified by its ``Id``.\n\n        arg:    grade_entry_id (osid.id.Id): ``Id`` of the\n                ``GradeEntry``\n        return: (osid.grading.GradeEntry) - the grade entry\n        raise:  NotFound - ``grade_entry_id`` not found\n        raise:  NullArgument - ``grade_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(grade_entry_id, 'grading').get_identifier())},\n                 **self._view_filter()))\n        return objects.GradeEntry(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_grade_entries_by_ids(self, grade_entry_ids):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in grade_entry_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'grading').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.GradeEntryList(sorted_result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a GradeEntryList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a GradeEntryList corresponding to the given grade entry genus Type which does not include grade entries of genus types derived from the specified Type.", "response": "def get_grade_entries_by_genus_type(self, grade_entry_genus_type):\n        \"\"\"Gets a ``GradeEntryList`` corresponding to the given grade entry genus ``Type`` which does not include grade entries of genus types derived from the specified ``Type``.\n\n        arg:    grade_entry_genus_type (osid.type.Type): a grade entry\n                genus type\n        return: (osid.grading.GradeEntryList) - the returned\n                ``GradeEntry`` list\n        raise:  NullArgument - ``grade_entry_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(grade_entry_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.GradeEntryList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_grade_entries_on_date(self, from_, to):\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_on_date\n        grade_entry_list = []\n        for grade_entry in self.get_grade_entries():\n            if overlap(from_, to, grade_entry.start_date, grade_entry.end_date):\n                grade_entry_list.append(grade_entry)\n        return objects.GradeEntryList(grade_entry_list, runtime=self._runtime)", "response": "Gets a GradeEntryList effective during the entire given date range inclusive but not confined to the date range."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_grade_entries_for_gradebook_column_on_date(self, gradebook_column_id, from_, to):\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source_on_date\n        grade_entry_list = []\n        for grade_entry in self.get_grade_entries_for_gradebook_column(gradebook_column_id):\n            if overlap(from_, to, grade_entry.start_date, grade_entry.end_date):\n                grade_entry_list.append(grade_entry)\n        return objects.GradeEntryList(grade_entry_list, runtime=self._runtime)", "response": "Gets a GradeEntryList for the given gradebook column and effective during the entire given date range inclusive but not confined to the date range."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a GradeEntryList for the gradebook column and resource.", "response": "def get_grade_entries_for_gradebook_column_and_resource(self, gradebook_column_id, resource_id):\n        \"\"\"Gets a ``GradeEntryList`` for the gradebook column and key resource.\n\n        arg:    gradebook_column_id (osid.id.Id): a gradebook column\n                ``Id``\n        arg:    resource_id (osid.id.Id): a key resource ``Id``\n        return: (osid.grading.GradeEntryList) - the returned\n                ``GradeEntry`` list\n        raise:  NullArgument - ``gradebook_column_id`` or\n                ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_peers\n        # NOTE: This implementation currently ignores plenary and effective views\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'gradebookColumnId': str(gradebook_column_id),\n                  'keyResourceId': str(resource_id)},\n                 **self._view_filter())).sort('_id', ASCENDING)\n        return objects.GradeEntryList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all grade entries.", "response": "def get_grade_entries(self):\n        \"\"\"Gets all grade entries.\n\n        return: (osid.grading.GradeEntryList) - a ``GradeEntryList``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.GradeEntryList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_grade_entries_by_query(self, grade_entry_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in grade_entry_query._query_terms:\n            if '$in' in grade_entry_query._query_terms[term] and '$nin' in grade_entry_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': grade_entry_query._query_terms[term]['$in']}},\n                             {term: {'$nin': grade_entry_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: grade_entry_query._query_terms[term]})\n        for term in grade_entry_query._keyword_terms:\n            or_list.append({term: grade_entry_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('grading',\n                                             collection='GradeEntry',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.GradeEntryList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of grade entries matching the given grade entry query."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_grade_entry_form_for_create(self, gradebook_column_id, resource_id, grade_entry_record_types):\n        if not isinstance(gradebook_column_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        if not isinstance(resource_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        # Add code for checking Id and getting gradebook_column enclosure\n        for arg in grade_entry_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if grade_entry_record_types == []:\n            # WHY are we passing gradebook_id = self._catalog_id below, seems redundant:\n            # Probably don't need effective agent id since form can now get that from proxy.\n            obj_form = objects.GradeEntryForm(\n                gradebook_id=self._catalog_id,\n                gradebook_column_id=gradebook_column_id,\n                resource_id=resource_id,\n                effective_agent_id=str(self.get_effective_agent_id()),\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.GradeEntryForm(\n                gradebook_id=self._catalog_id,\n                record_types=grade_entry_record_types,\n                gradebook_column_id=gradebook_column_id,\n                resource_id=resource_id,\n                effective_agent_id=str(self.get_effective_agent_id()),\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the grade entry form for creating new grade entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new grade entry.", "response": "def create_grade_entry(self, grade_entry_form):\n        \"\"\"Creates a new ``GradeEntry``.\n\n        arg:    grade_entry_form (osid.grading.GradeEntryForm): the form\n                for this ``GradeEntry``\n        return: (osid.grading.GradeEntry) - the new ``GradeEntry``\n        raise:  IllegalState - ``grade_entry_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``grade_entry_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``grade_entry_form`` did not originate\n                from ``get_grade_entry_form_for_create()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        if not isinstance(grade_entry_form, ABCGradeEntryForm):\n            raise errors.InvalidArgument('argument type is not an GradeEntryForm')\n        if grade_entry_form.is_for_update():\n            raise errors.InvalidArgument('the GradeEntryForm is for update only, not create')\n        try:\n            if self._forms[grade_entry_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('grade_entry_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('grade_entry_form did not originate from this session')\n        if not grade_entry_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(grade_entry_form._my_map)\n\n        self._forms[grade_entry_form.get_id().get_identifier()] = CREATED\n        result = objects.GradeEntry(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the grade entry form for updating an existing entry.", "response": "def get_grade_entry_form_for_update(self, grade_entry_id):\n        \"\"\"Gets the grade entry form for updating an existing entry.\n\n        A new grade entry form should be requested for each update\n        transaction.\n\n        arg:    grade_entry_id (osid.id.Id): the ``Id`` of the\n                ``GradeEntry``\n        return: (osid.grading.GradeEntryForm) - the grade entry form\n        raise:  NotFound - ``grade_entry_id`` is not found\n        raise:  NullArgument - ``grade_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        if not isinstance(grade_entry_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        if (grade_entry_id.get_identifier_namespace() != 'grading.GradeEntry' or\n                grade_entry_id.get_authority() != self._authority):\n            raise errors.InvalidArgument()\n        result = collection.find_one({'_id': ObjectId(grade_entry_id.get_identifier())})\n\n        obj_form = objects.GradeEntryForm(\n            osid_object_map=result,\n            effective_agent_id=str(self.get_effective_agent_id()),\n            runtime=self._runtime,\n            proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not UPDATED\n\n        return obj_form"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates an existing grade entry.", "response": "def update_grade_entry(self, grade_entry_form):\n        \"\"\"Updates an existing grade entry.\n\n        arg:    grade_entry_form (osid.grading.GradeEntryForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - ``grade_entry_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``grade_entry_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``grade_entry_form`` did not originate\n                from ``get_grade_entry_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        if not isinstance(grade_entry_form, ABCGradeEntryForm):\n            raise errors.InvalidArgument('argument type is not an GradeEntryForm')\n        if not grade_entry_form.is_for_update():\n            raise errors.InvalidArgument('the GradeEntryForm is for update only, not create')\n        try:\n            if self._forms[grade_entry_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('grade_entry_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('grade_entry_form did not originate from this session')\n        if not grade_entry_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(grade_entry_form._my_map)\n\n        self._forms[grade_entry_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.GradeEntry(\n            osid_object_map=grade_entry_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting the grade entry identified by the given Id.", "response": "def delete_grade_entry(self, grade_entry_id):\n        \"\"\"Deletes the ``GradeEntry`` identified by the given ``Id``.\n\n        arg:    grade_entry_id (osid.id.Id): the ``Id`` of the\n                ``GradeEntry`` to delete\n        raise:  NotFound - a ``GradeEntry`` was not found identified by\n                the given ``Id``\n        raise:  NullArgument - ``grade_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('grading',\n                                         collection='GradeEntry',\n                                         runtime=self._runtime)\n        if not isinstance(grade_entry_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        grade_entry_map = collection.find_one(\n            dict({'_id': ObjectId(grade_entry_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.GradeEntry(osid_object_map=grade_entry_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(grade_entry_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an Id to a grade entry in the hierarchy.", "response": "def alias_grade_entry(self, grade_entry_id, alias_id):\n        \"\"\"Adds an ``Id`` to a ``GradeEntry`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``GradeEntry`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another grade entry, it is\n        reassigned to the given grade entry ``Id``.\n\n        arg:    grade_entry_id (osid.id.Id): the ``Id`` of a\n                ``GradeEntry``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``grade_entry_id`` not found\n        raise:  NullArgument - ``grade_entry_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=grade_entry_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the GradebookColumn specified by its Id.", "response": "def get_gradebook_column(self, gradebook_column_id):\n        \"\"\"Gets the ``GradebookColumn`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``GradebookColumn`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``GradebookColumn`` and\n        retained for compatibility.\n\n        arg:    gradebook_column_id (osid.id.Id): ``Id`` of the\n                ``GradebookColumn``\n        return: (osid.grading.GradebookColumn) - the gradebook column\n        raise:  NotFound - ``gradebook_column_id`` not found\n        raise:  NullArgument - ``gradebook_column_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradebookColumn',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(gradebook_column_id, 'grading').get_identifier())},\n                 **self._view_filter()))\n        return objects.GradebookColumn(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_gradebook_columns_by_ids(self, gradebook_column_ids):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradebookColumn',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in gradebook_column_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'grading').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.GradebookColumnList(sorted_result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a GradebookColumnList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a list of gradebook columns corresponding to the given genus Type which does not include all gradebook columns of genus types derived from the specified Type.", "response": "def get_gradebook_columns_by_genus_type(self, gradebook_column_genus_type):\n        \"\"\"Gets a ``GradebookColumnList`` corresponding to the given gradebook column genus ``Type`` which does not include gradebook columns of genus types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known gradebook\n        columns or an error results. Otherwise, the returned list may\n        contain only those gradebook columns that are accessible through\n        this session.\n\n        arg:    gradebook_column_genus_type (osid.type.Type): a\n                gradebook column genus type\n        return: (osid.grading.GradebookColumnList) - the returned\n                ``GradebookColumn`` list\n        raise:  NullArgument - ``gradebook_column_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradebookColumn',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(gradebook_column_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.GradebookColumnList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all gradebook columns.", "response": "def get_gradebook_columns(self):\n        \"\"\"Gets all gradebook columns.\n\n        In plenary mode, the returned list contains all known gradebook\n        columns or an error results. Otherwise, the returned list may\n        contain only those gradebook columns that are accessible through\n        this session.\n\n        return: (osid.grading.GradebookColumnList) - a\n                ``GradebookColumn``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('grading',\n                                         collection='GradebookColumn',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.GradebookColumnList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the GradebookColumnSummary for summary results.", "response": "def get_gradebook_column_summary(self, gradebook_column_id):\n        \"\"\"Gets the ``GradebookColumnSummary`` for summary results.\n\n        arg:    gradebook_column_id (osid.id.Id): ``Id`` of the\n                ``GradebookColumn``\n        return: (osid.grading.GradebookColumnSummary) - the gradebook\n                column summary\n        raise:  NotFound - ``gradebook_column_id`` is not found\n        raise:  NullArgument - ``gradebook_column_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unimplemented - ``has_summary()`` is ``false``\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        gradebook_column = self.get_gradebook_column(gradebook_column_id)\n        summary_map = gradebook_column._my_map\n        summary_map['gradebookColumnId'] = str(gradebook_column.ident)\n        return GradebookColumnSummary(osid_object_map=summary_map,\n                                      runtime=self._runtime,\n                                      proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of gradebook columns matching the given query.", "response": "def get_gradebook_columns_by_query(self, gradebook_column_query):\n        \"\"\"Gets a list of gradebook columns matching the given query.\n\n        arg:    gradebook_column_query\n                (osid.grading.GradebookColumnQuery): the gradebook\n                column query\n        return: (osid.grading.GradebookColumnList) - the returned\n                ``GradebookColumnList``\n        raise:  NullArgument - ``gradebook_column_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``gradebook_column_query`` is not of this\n                service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in gradebook_column_query._query_terms:\n            if '$in' in gradebook_column_query._query_terms[term] and '$nin' in gradebook_column_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': gradebook_column_query._query_terms[term]['$in']}},\n                             {term: {'$nin': gradebook_column_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: gradebook_column_query._query_terms[term]})\n        for term in gradebook_column_query._keyword_terms:\n            or_list.append({term: gradebook_column_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('grading',\n                                             collection='GradebookColumn',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.GradebookColumnList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if this user can create a single gradebook column using the desired record types.", "response": "def can_create_gradebook_column_with_record_types(self, gradebook_column_record_types):\n        \"\"\"Tests if this user can create a single ``GradebookColumn`` using the desired record types.\n\n        While ``GradingManager.getGradebookColumnRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``GradebookColumn``. Providing an empty array tests if a\n        ``GradebookColumn`` can be created with no records.\n\n        arg:    gradebook_column_record_types (osid.type.Type[]): array\n                of gradebook column record types\n        return: (boolean) - ``true`` if ``GradebookColumn`` creation\n                using the specified record ``Types`` is supported,\n                ``false`` otherwise\n        raise:  NullArgument - ``gradebook_column_record_types`` is\n                ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=gradebook_column_record_types)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_gradebook_column_form_for_create(self, gradebook_column_record_types):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in gradebook_column_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if gradebook_column_record_types == []:\n            obj_form = objects.GradebookColumnForm(\n                gradebook_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.GradebookColumnForm(\n                gradebook_id=self._catalog_id,\n                record_types=gradebook_column_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the gradebook column form for creating new gradebook columns."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new GradebookColumn.", "response": "def create_gradebook_column(self, gradebook_column_form):\n        \"\"\"Creates a new ``GradebookColumn``.\n\n        arg:    gradebook_column_form\n                (osid.grading.GradebookColumnForm): the form for this\n                ``GradebookColumn``\n        return: (osid.grading.GradebookColumn) - the new\n                ``GradebookColumn``\n        raise:  IllegalState - ``gradebook_column_form`` already used in\n                a create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``gradebook_column_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``gradebook_column_form`` did not\n                originate from\n                ``get_gradebook_column_form_for_create()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('grading',\n                                         collection='GradebookColumn',\n                                         runtime=self._runtime)\n        if not isinstance(gradebook_column_form, ABCGradebookColumnForm):\n            raise errors.InvalidArgument('argument type is not an GradebookColumnForm')\n        if gradebook_column_form.is_for_update():\n            raise errors.InvalidArgument('the GradebookColumnForm is for update only, not create')\n        try:\n            if self._forms[gradebook_column_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('gradebook_column_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('gradebook_column_form did not originate from this session')\n        if not gradebook_column_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(gradebook_column_form._my_map)\n\n        self._forms[gradebook_column_form.get_id().get_identifier()] = CREATED\n        result = objects.GradebookColumn(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate an existing gradebook column.", "response": "def update_gradebook_column(self, gradebook_column_form):\n        \"\"\"Updates an existing gradebook column.\n\n        arg:    gradebook_column_form\n                (osid.grading.GradebookColumnForm): the form containing\n                the elements to be updated\n        raise:  IllegalState - ``gradebook_column_form`` already used in\n                an update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``gradebook_column_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``gradebook_column_form`` did not\n                originate from\n                ``get_gradebook_column_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('grading',\n                                         collection='GradebookColumn',\n                                         runtime=self._runtime)\n        if not isinstance(gradebook_column_form, ABCGradebookColumnForm):\n            raise errors.InvalidArgument('argument type is not an GradebookColumnForm')\n        if not gradebook_column_form.is_for_update():\n            raise errors.InvalidArgument('the GradebookColumnForm is for update only, not create')\n        try:\n            if self._forms[gradebook_column_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('gradebook_column_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('gradebook_column_form did not originate from this session')\n        if not gradebook_column_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n\n        # check that there are no entries, if updating the gradeSystemId\n        old_column = collection.find_one({\"_id\": gradebook_column_form._my_map['_id']})\n        if old_column['gradeSystemId'] != gradebook_column_form._my_map['gradeSystemId']:\n            if self._has_entries(gradebook_column_form.id_):\n                raise errors.IllegalState('Entries exist in this gradebook column. ' +\n                                          'Cannot change the grade system.')\n\n        collection.save(gradebook_column_form._my_map)\n\n        self._forms[gradebook_column_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.GradebookColumn(\n            osid_object_map=gradebook_column_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the Entry for the given gradebook column.", "response": "def delete_gradebook_column(self, gradebook_column_id):\n        \"\"\"Deletes the ``GradebookColumn`` identified by the given ``Id``.\n\n        arg:    gradebook_column_id (osid.id.Id): the ``Id`` of the\n                ``GradebookColumn`` to delete\n        raise:  NotFound - a ``GradebookColumn`` was not found\n                identified by the given ``Id``\n        raise:  NullArgument - ``gradebook_column_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not isinstance(gradebook_column_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n\n        # check that no entries already exist for this gradebook column\n        grading_manager = self._get_provider_manager('GRADING')\n        gels = grading_manager.get_grade_entry_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        gels.use_federated_gradebook_view()\n        entries = gels.get_grade_entries_for_gradebook_column(gradebook_column_id)\n        if self._has_entries(gradebook_column_id):\n            raise errors.IllegalState('Entries exist in this gradebook column. Cannot delete it.')\n\n        collection = JSONClientValidated('grading',\n                                         collection='GradebookColumn',\n                                         runtime=self._runtime)\n\n        gradebook_column_map = collection.find_one({'_id': ObjectId(gradebook_column_id.get_identifier())})\n\n        objects.GradebookColumn(osid_object_map=gradebook_column_map,\n                                runtime=self._runtime,\n                                proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(gradebook_column_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef alias_gradebook_column(self, gradebook_column_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=gradebook_column_id, equivalent_id=alias_id)", "response": "Adds an Id to a GradebookColumn."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the list of GradebookColumn Ids associated with a Gradebook.", "response": "def get_gradebook_column_ids_by_gradebook(self, gradebook_id):\n        \"\"\"Gets the list of ``GradebookColumn``  ``Ids`` associated with a ``Gradebook``.\n\n        arg:    gradebook_id (osid.id.Id): ``Id`` of the ``Gradebook``\n        return: (osid.id.IdList) - list of related gradebook column\n                ``Ids``\n        raise:  NotFound - ``gradebook_id`` is not found\n        raise:  NullArgument - ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for gradebook_column in self.get_gradebook_columns_by_gradebook(gradebook_id):\n            id_list.append(gradebook_column.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the list of gradebook columns associated with a Gradebook.", "response": "def get_gradebook_columns_by_gradebook(self, gradebook_id):\n        \"\"\"Gets the list of gradebook columns associated with a ``Gradebook``.\n\n        arg:    gradebook_id (osid.id.Id): ``Id`` of the ``Gradebook``\n        return: (osid.grading.GradebookColumnList) - list of related\n                gradebook columns\n        raise:  NotFound - ``gradebook_id`` is not found\n        raise:  NullArgument - ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_column_lookup_session_for_gradebook(gradebook_id, proxy=self._proxy)\n        lookup_session.use_isolated_gradebook_view()\n        return lookup_session.get_gradebook_columns()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gradebook_column_ids_by_gradebooks(self, gradebook_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for gradebook_column in self.get_gradebook_columns_by_gradebooks(gradebook_ids):\n            id_list.append(gradebook_column.get_id())\n        return IdList(id_list)", "response": "Gets the list of GradebookColumn Ids corresponding to a list of Gradebooks."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_gradebook_columns_by_gradebooks(self, gradebook_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        gradebook_column_list = []\n        for gradebook_id in gradebook_ids:\n            gradebook_column_list += list(\n                self.get_gradebook_columns_by_gradebook(gradebook_id))\n        return objects.GradebookColumnList(gradebook_column_list)", "response": "Gets the list of gradebook columns corresponding to a list of Gradebooks."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the list of Gradebook Ids mapped to a GradebookColumn.", "response": "def get_gradebook_ids_by_gradebook_column(self, gradebook_column_id):\n        \"\"\"Gets the list of ``Gradebook``  ``Ids`` mapped to a ``GradebookColumn``.\n\n        arg:    gradebook_column_id (osid.id.Id): ``Id`` of a\n                ``GradebookColumn``\n        return: (osid.id.IdList) - list of gradebook ``Ids``\n        raise:  NotFound - ``gradebook_column_id`` is not found\n        raise:  NullArgument - ``gradebook_column_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_column_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_gradebook_view()\n        gradebook_column = lookup_session.get_gradebook_column(gradebook_column_id)\n        id_list = []\n        for idstr in gradebook_column._my_map['assignedGradebookIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_gradebooks_by_gradebook_column(self, gradebook_column_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_lookup_session(proxy=self._proxy)\n        return lookup_session.get_gradebooks_by_ids(\n            self.get_gradebook_ids_by_gradebook_column(gradebook_column_id))", "response": "Gets the list of Gradebooks mapped to a GradebookColumn."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding an existing GradebookColumn to a Gradebook.", "response": "def assign_gradebook_column_to_gradebook(self, gradebook_column_id, gradebook_id):\n        \"\"\"Adds an existing ``GradebookColumn`` to a ``Gradebook``.\n\n        arg:    gradebook_column_id (osid.id.Id): the ``Id`` of the\n                ``GradebookColumn``\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of the\n                ``Gradebook``\n        raise:  AlreadyExists - ``gradebook_column_id`` is already\n                assigned to ``gradebook_id``\n        raise:  NotFound - ``gradebook_column_id`` or ``gradebook_id``\n                not found\n        raise:  NullArgument - ``gradebook_column_id`` or\n                ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_lookup_session(proxy=self._proxy)\n        lookup_session.get_gradebook(gradebook_id)  # to raise NotFound\n        self._assign_object_to_catalog(gradebook_column_id, gradebook_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unassign_gradebook_column_from_gradebook(self, gradebook_column_id, gradebook_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('GRADING', local=True)\n        lookup_session = mgr.get_gradebook_lookup_session(proxy=self._proxy)\n        lookup_session.get_gradebook(gradebook_id)  # to raise NotFound\n        self._unassign_object_from_catalog(gradebook_column_id, gradebook_id)", "response": "Removes a GradebookColumn from a Gradebook."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if this user can create a single Gradebook using the desired record types.", "response": "def can_create_gradebook_with_record_types(self, gradebook_record_types):\n        \"\"\"Tests if this user can create a single ``Gradebook`` using the desired record types.\n\n        While ``GradingManager.getGradebookRecordTypes()`` can be used\n        to examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Gradebook``.\n        Providing an empty array tests if a ``Gradebook`` can be created\n        with no records.\n\n        arg:    gradebook_record_types (osid.type.Type[]): array of\n                gradebook record types\n        return: (boolean) - ``true`` if ``Gradebook`` creation using the\n                specified ``Types`` is supported, ``false`` otherwise\n        raise:  NullArgument - ``gradebook_record_types`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=gradebook_record_types)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate an existing gradebook.", "response": "def update_gradebook(self, gradebook_form):\n        \"\"\"Updates an existing gradebook.\n\n        arg:    gradebook_form (osid.grading.GradebookForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - ``gradebook_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``gradebook_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``gradebook_form did not originate from\n                get_gradebook_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=gradebook_form)\n        collection = JSONClientValidated('grading',\n                                         collection='Gradebook',\n                                         runtime=self._runtime)\n        if not isinstance(gradebook_form, ABCGradebookForm):\n            raise errors.InvalidArgument('argument type is not an GradebookForm')\n        if not gradebook_form.is_for_update():\n            raise errors.InvalidArgument('the GradebookForm is for update only, not create')\n        try:\n            if self._forms[gradebook_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('gradebook_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('gradebook_form did not originate from this session')\n        if not gradebook_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(gradebook_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[gradebook_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Gradebook(osid_object_map=gradebook_form._my_map, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an Id to a Gradebook.", "response": "def alias_gradebook(self, gradebook_id, alias_id):\n        \"\"\"Adds an ``Id`` to a ``Gradebook`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``Gradebook`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id`` . If the alias is a pointer to another gradebook, it is\n        reassigned to the given gradebook ``Id``.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of a ``Gradebook``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``gradebook_id`` not found\n        raise:  NullArgument - ``gradebook_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=gradebook_id, alias_id=alias_id)\n        self._alias_id(primary_id=gradebook_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_root_gradebook_ids(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalog_ids()\n        return self._hierarchy_session.get_roots()", "response": "Gets the root gradebook Ids in this hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_root_gradebooks(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return GradebookLookupSession(\n            self._proxy,\n            self._runtime).get_gradebooks_by_ids(list(self.get_root_gradebook_ids()))", "response": "Gets the root gradebooks in this gradebook hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if the Gradebook has any parents.", "response": "def has_parent_gradebooks(self, gradebook_id):\n        \"\"\"Tests if the ``Gradebook`` has any parents.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of a gradebook\n        return: (boolean) - ``true`` if the gradebook has parents,\n                ``false`` otherwise\n        raise:  NotFound - ``gradebook_id`` is not found\n        raise:  NullArgument - ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=gradebook_id)\n        return self._hierarchy_session.has_parents(id_=gradebook_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if an Id is a direct parent of a gradebook.", "response": "def is_parent_of_gradebook(self, id_, gradebook_id):\n        \"\"\"Tests if an ``Id`` is a direct parent of a gradebook.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of a gradebook\n        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``gradebook_id,``  ``false`` otherwise\n        raise:  NotFound - ``gradebook_id`` is not found\n        raise:  NullArgument - ``id`` or ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=gradebook_id)\n        return self._hierarchy_session.is_parent(id_=gradebook_id, parent_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the parent Ids of the given gradebook.", "response": "def get_parent_gradebook_ids(self, gradebook_id):\n        \"\"\"Gets the parent ``Ids`` of the given gradebook.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of a gradebook\n        return: (osid.id.IdList) - the parent ``Ids`` of the gradebook\n        raise:  NotFound - ``gradebook_id`` is not found\n        raise:  NullArgument - ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=gradebook_id)\n        return self._hierarchy_session.get_parents(id_=gradebook_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parent_gradebooks(self, gradebook_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=gradebook_id)\n        return GradebookLookupSession(\n            self._proxy,\n            self._runtime).get_gradebooks_by_ids(\n                list(self.get_parent_gradebook_ids(gradebook_id)))", "response": "Gets the parents of the given gradebook."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_ancestor_of_gradebook(self, id_, gradebook_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=gradebook_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=gradebook_id)", "response": "Tests if an Id is an ancestor of a gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_child_gradebooks(self, gradebook_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=gradebook_id)\n        return self._hierarchy_session.has_children(id_=gradebook_id)", "response": "Tests if a gradebook has any children."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntesting if a gradebook is a direct child of another.", "response": "def is_child_of_gradebook(self, id_, gradebook_id):\n        \"\"\"Tests if a gradebook is a direct child of another.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of a gradebook\n        return: (boolean) - ``true`` if the ``id`` is a child of\n                ``gradebook_id,``  ``false`` otherwise\n        raise:  NotFound - ``gradebook_id`` is not found\n        raise:  NullArgument - ``id`` or ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=gradebook_id)\n        return self._hierarchy_session.is_child(id_=gradebook_id, child_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the child Ids of the given gradebook.", "response": "def get_child_gradebook_ids(self, gradebook_id):\n        \"\"\"Gets the child ``Ids`` of the given gradebook.\n\n        arg:    gradebook_id (osid.id.Id): the ``Id`` to query\n        return: (osid.id.IdList) - the children of the gradebook\n        raise:  NotFound - ``gradebook_id`` is not found\n        raise:  NullArgument - ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=gradebook_id)\n        return self._hierarchy_session.get_children(id_=gradebook_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_child_gradebooks(self, gradebook_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=gradebook_id)\n        return GradebookLookupSession(\n            self._proxy,\n            self._runtime).get_gradebooks_by_ids(\n                list(self.get_child_gradebook_ids(gradebook_id)))", "response": "Gets the children of the given gradebook."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntest if an Id is a descendant of a gradebook.", "response": "def is_descendant_of_gradebook(self, id_, gradebook_id):\n        \"\"\"Tests if an ``Id`` is a descendant of a gradebook.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    gradebook_id (osid.id.Id): the ``Id`` of a gradebook\n        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``gradebook_id,`` ``false`` otherwise\n        raise:  NotFound - ``gradebook_id`` is not found\n        raise:  NullArgument - ``id`` or ``gradebook_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` is not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=gradebook_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=gradebook_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gradebook_nodes(self, gradebook_id, ancestor_levels, descendant_levels, include_siblings):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.GradebookNode(self.get_gradebook_node_ids(\n            gradebook_id=gradebook_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a portion of the hierarchy for the given gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_root_gradebook(self, gradebook_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=gradebook_id)\n        return self._hierarchy_session.add_root(id_=gradebook_id)", "response": "Adds a root gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_root_gradebook(self, gradebook_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=gradebook_id)\n        return self._hierarchy_session.remove_root(id_=gradebook_id)", "response": "Removes a root gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_child_gradebook(self, gradebook_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=gradebook_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=gradebook_id, child_id=child_id)", "response": "Adds a child to a gradebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_child_gradebook(self, gradebook_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=gradebook_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=gradebook_id, child_id=child_id)", "response": "Removes a child from a gradebook."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_id(self):\n        waypoint_index = 0\n        if 'waypointIndex' in self.my_osid_object._my_map:\n            waypoint_index = self.my_osid_object._my_map['waypointIndex']\n        # NOTE that the order of the dict **must** match the order in generate_children()\n        #   when creating the child_part_id\n        #   1) level\n        #   2) objective_ids\n        #   3) parent_id\n        #   4) waypoint_index\n        magic_identifier = OrderedDict({\n            'level': self._level,\n            'objective_ids': self.my_osid_object._my_map['learningObjectiveIds'],\n        })\n        if self._magic_parent_id is not None:\n            magic_identifier['parent_id'] = str(self._magic_parent_id)\n        magic_identifier['waypoint_index'] = waypoint_index\n\n        identifier = quote('{0}?{1}'.format(str(self.my_osid_object._my_map['_id']),\n                                            json.dumps(magic_identifier)))\n        return Id(namespace='assessment_authoring.AssessmentPart',\n                  identifier=identifier,\n                  authority=MAGIC_PART_AUTHORITY)", "response": "override get_id to generate our magic id that encodes scaffolding information"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind an item for an objective", "response": "def load_item_for_objective(self):\n        \"\"\"if this is the first time for this magic part, find an LO linked item\"\"\"\n        mgr = self.my_osid_object._get_provider_manager('ASSESSMENT', local=True)\n        if self.my_osid_object._my_map['itemBankId']:\n            item_query_session = mgr.get_item_query_session_for_bank(Id(self.my_osid_object._my_map['itemBankId']),\n                                                                     proxy=self.my_osid_object._proxy)\n        else:\n            item_query_session = mgr.get_item_query_session(proxy=self.my_osid_object._proxy)\n        item_query_session.use_federated_bank_view()\n        item_query = item_query_session.get_item_query()\n        for objective_id_str in self.my_osid_object._my_map['learningObjectiveIds']:\n            item_query.match_learning_objective_id(Id(objective_id_str), True)\n        item_list = list(item_query_session.get_items_by_query(item_query))\n        # Let's query all takens and their children sections for questions, to\n        # remove seen ones\n        taking_agent_id = self._assessment_section._assessment_taken.taking_agent_id\n        atqs = mgr.get_assessment_taken_query_session(proxy=self.my_osid_object._proxy)\n        atqs.use_federated_bank_view()\n        querier = atqs.get_assessment_taken_query()\n        querier.match_taking_agent_id(taking_agent_id, match=True)\n        # let's seed this with the current section's questions\n        seen_items = [item_id for item_id in self._assessment_section._item_id_list]\n        taken_ids = [str(t.ident)\n                     for t in atqs.get_assessments_taken_by_query(querier)]\n        # Try to find the questions directly via Mongo query -- don't do\n        # for section in taken._get_assessment_sections():\n        #     seen_items += [question['itemId'] for question in section._my_map['questions']]\n        # because standing up all the sections is wasteful\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentSection',\n                                         runtime=self.my_osid_object._runtime)\n        results = collection.find({\"assessmentTakenId\": {\"$in\": taken_ids}})\n        for section in results:\n            if 'questions' in section:\n                seen_items += [question['itemId'] for question in section['questions']]\n        unseen_item_id = None\n        # need to randomly shuffle this item_list\n        shuffle(item_list)\n        for item in item_list:\n            if str(item.ident) not in seen_items:\n                unseen_item_id = item.get_id()\n                break\n        if unseen_item_id is not None:\n            self.my_osid_object._my_map['itemIds'] = [str(unseen_item_id)]\n        elif self.my_osid_object._my_map['allowRepeatItems']:\n            if len(item_list) > 0:\n                self.my_osid_object._my_map['itemIds'] = [str(item_list[0].ident)]\n            else:\n                self.my_osid_object._my_map['itemIds'] = []  # don't put '' here, it will break when it tries to find an item with id ''\n        else:\n            self.my_osid_object._my_map['itemIds'] = []"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_magic_children(self):\n        if self._child_parts is not None:  # generate_children has already been called\n            return bool(self._child_parts)\n        if self._assessment_section is not None:\n            if (self.my_osid_object._my_map['maxLevels'] is None or\n                    self.my_osid_object._my_map['maxLevels'] > self._level):\n                try:\n                    section = self._assessment_section\n                    item_id = self.get_my_item_id_from_section(section)\n                    if not section.is_correct(item_id) and section.get_confused_learning_objective_ids(item_id).available() > 0:\n                        return True\n                except IllegalState:\n                    pass\n        return False", "response": "checks if child parts are currently available for this part"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the ids for the child parts", "response": "def get_child_ids(self):\n        \"\"\"gets the ids for the child parts\"\"\"\n        if self.has_magic_children():\n            if self._child_parts is None:\n                self.generate_children()\n            child_ids = list()\n            for part in self._child_parts:\n                child_ids.append(part.get_id())\n            return IdList(child_ids,\n                          runtime=self.my_osid_object._runtime,\n                          proxy=self.my_osid_object._runtime)\n        raise IllegalState()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_children(self):\n        if self.has_magic_children():\n            if self._child_parts is None:\n                self.generate_children()\n            return self._child_parts\n        raise IllegalState()", "response": "return the current child parts of this assessment part"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets item ids associated with this assessment part", "response": "def get_item_ids(self):\n        \"\"\"get item ids associated with this assessment part\"\"\"\n        if self.has_item_ids():\n            return IdList(self.my_osid_object._my_map['itemIds'],\n                          runtime=self.my_osid_object._runtime,\n                          proxy=self.my_osid_object._proxy)\n        raise IllegalState()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nassuming that a scaffold objective id is available", "response": "def get_scaffold_objective_ids(self):\n        \"\"\"Assumes that a scaffold objective id is available\"\"\"\n        section = self._assessment_section\n        item_id = self.get_my_item_id_from_section(section)\n        return section.get_confused_learning_objective_ids(item_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the first item associated with this magic Part Id in the Section", "response": "def get_my_item_id_from_section(self, section):\n        \"\"\"returns the first item associated with this magic Part Id in the Section\"\"\"\n        for question_map in section._my_map['questions']:\n            if question_map['assessmentPartId'] == str(self.get_id()):\n                return section.get_question(question_map=question_map).get_id()\n        raise IllegalState('This Part currently has no Item in the Section')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nneed this because the JSONClientValidated cannot deal with the magic identifier", "response": "def delete(self):\n        \"\"\"need this because the JSONClientValidated cannot deal with the magic identifier\"\"\"\n        magic_identifier = unquote(self.get_id().identifier)\n        orig_identifier = magic_identifier.split('?')[0]\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self.my_osid_object._runtime)\n        collection.delete_one({'_id': ObjectId(orig_identifier)})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the assessment part", "response": "def get_assessment_part(self):\n        \"\"\"If there's an AssessmentSection ask it first for the part.\n\n        This will take advantage of the fact that the AssessmentSection may\n        have already cached the Part in question.\n\n        \"\"\"\n        if self._magic_parent_id is None:\n            assessment_part_id = Id(self.my_osid_object._my_map['assessmentPartId'])\n        else:\n            assessment_part_id = self._magic_parent_id\n        if self._assessment_section is not None:\n            return self._assessment_section._get_assessment_part(assessment_part_id)\n        # else:\n        apls = get_assessment_part_lookup_session(runtime=self.my_osid_object._runtime,\n                                                  proxy=self.my_osid_object._proxy,\n                                                  section=self._assessment_section)\n        apls.use_federated_bank_view()\n        apls.use_unsequestered_assessment_part_view()\n        return apls.get_assessment_part(assessment_part_id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_map(self):\n        # super(ScaffoldDownAssessmentPartFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['itemIds'] = \\\n            [str(self._item_ids_metadata['default_id_values'][0])]\n        self.my_osid_object_form._my_map['learningObjectiveIds'] = \\\n            [str(self._learning_objective_ids_metadata['default_id_values'][0])]\n        self.my_osid_object_form._my_map['maxLevels'] = \\\n            self._max_levels_metadata['default_cardinal_values'][0]\n        self.my_osid_object_form._my_map['maxWaypointItems'] = \\\n            self._max_waypoint_items_metadata['default_cardinal_values'][0]\n        self.my_osid_object_form._my_map['waypointQuota'] = \\\n            self._waypoint_quota_metadata['default_cardinal_values'][0]\n        self.my_osid_object_form._my_map['itemBankId'] = \\\n            self._item_bank_id_metadata['default_id_values'][0]\n        self.my_osid_object_form._my_map['allowRepeatItems'] = \\\n            bool(self._allow_repeat_items_metadata['default_boolean_values'][0])", "response": "Initialize the map with the default values for the item class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_item_ids_metadata(self):\n        metadata = dict(self._item_ids_metadata)\n        metadata.update({'existing_id_values': self.my_osid_object_form._my_map['itemIds']})\n        return Metadata(**metadata)", "response": "get the metadata for item"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_item_ids(self, item_ids):\n        '''the target Item\n\n        This can only be set if there is no learning objective set\n\n        '''\n        if self.get_item_ids_metadata().is_read_only():\n            raise NoAccess()\n        for item_id in item_ids:\n            if not self.my_osid_object_form._is_valid_id(item_id):\n                raise InvalidArgument()\n        if self.my_osid_object_form._my_map['learningObjectiveIds'][0]:\n            raise IllegalState()\n        self.my_osid_object_form._my_map['itemIds'] = [str(i) for i in item_ids]", "response": "set the item ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the metadata for learning objective", "response": "def get_learning_objective_ids_metadata(self):\n        \"\"\"get the metadata for learning objective\"\"\"\n        metadata = dict(self._learning_objective_ids_metadata)\n        metadata.update({'existing_id_values': self.my_osid_object_form._my_map['learningObjectiveIds'][0]})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the learning objective ids", "response": "def set_learning_objective_ids(self, learning_objective_ids):\n        \"\"\"the learning objective to find related items for\n\n        This can only be set if there are no items specifically set\n\n        \"\"\"\n        if self.get_learning_objective_ids_metadata().is_read_only():\n            raise NoAccess()\n        for learning_objective_id in learning_objective_ids:\n            if not self.my_osid_object_form._is_valid_id(learning_objective_id):\n                raise InvalidArgument()\n        if self.my_osid_object_form._my_map['itemIds'][0]:\n            raise IllegalState()\n        self.my_osid_object_form._my_map['learningObjectiveIds'] = [str(lo) for lo in learning_objective_ids]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the metadata for max levels", "response": "def get_max_levels_metadata(self):\n        \"\"\"get the metadata for max levels\"\"\"\n        metadata = dict(self._max_levels_metadata)\n        metadata.update({'existing_cardinal_values': self.my_osid_object_form._my_map['maxLevels']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_max_waypoint_items_metadata(self):\n        metadata = dict(self._max_waypoint_items_metadata)\n        metadata.update({'existing_cardinal_values': self.my_osid_object_form._my_map['maxWaypointItems']})\n        return Metadata(**metadata)", "response": "get the metadata for max waypoint items"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_max_waypoint_items(self, max_waypoint_items):\n        if self.get_max_waypoint_items_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_cardinal(max_waypoint_items,\n                                                           self.get_max_waypoint_items_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['maxWaypointItems'] = max_waypoint_items", "response": "This determines how many waypoint items should be seen for a scaffolded wrong answer"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_waypoint_quota_metadata(self):\n        metadata = dict(self._waypoint_quota_metadata)\n        metadata.update({'existing_cardinal_values': self.my_osid_object_form._my_map['waypointQuota']})\n        return Metadata(**metadata)", "response": "get the metadata for waypoint quota"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the waypoint quota", "response": "def set_waypoint_quota(self, waypoint_quota):\n        \"\"\"how many waypoint questions need to be answered correctly\"\"\"\n        if self.get_waypoint_quota_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_cardinal(waypoint_quota,\n                                                           self.get_waypoint_quota_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['waypointQuota'] = waypoint_quota"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the metadata for item bank", "response": "def get_item_bank_id_metadata(self):\n        \"\"\"get the metadata for item bank\"\"\"\n        metadata = dict(self._item_bank_id_metadata)\n        metadata.update({'existing_id_values': self.my_osid_object_form._my_map['itemBankId']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_item_bank_id(self, bank_id):\n        if self.get_item_bank_id_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_id(bank_id):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['itemBankId'] = str(bank_id)", "response": "set the assessment bank id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_allow_repeat_items_metadata(self):\n        metadata = dict(self._allow_repeat_items_metadata)\n        metadata.update({'existing_id_values': self.my_osid_object_form._my_map['allowRepeatItems']})\n        return Metadata(**metadata)", "response": "get the metadata for allow repeat items"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines if repeat items will be shown or will stop the scaffold iteration", "response": "def set_allow_repeat_items(self, allow_repeat_items):\n        \"\"\"determines if repeat items will be shown, or if the scaffold iteration will simply stop\"\"\"\n        if self.get_allow_repeat_items_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_boolean(allow_repeat_items):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['allowRepeatItems'] = allow_repeat_items"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset allow repeat itmes to default value", "response": "def clear_allow_repeat_items(self):\n        \"\"\"reset allow repeat itmes to default value\"\"\"\n        if (self.get_allow_repeat_items_metadata().is_read_only() or\n                self.get_allow_repeat_items_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['allowRepeatItems'] = \\\n            bool(self._allow_repeat_items_metadata['default_boolean_values'][0])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the ObjectiveBank associated with this session.", "response": "def get_objective_bank(self):\n        \"\"\"Gets the ObjectiveBank associated with this session.\n\n        return: (osid.learning.ObjectiveBank) - the ObjectiveBank\n                associated with this session\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        # This should probably be accomplished via a handcar call instead of OSID\n        url_path = construct_url('objective_banks',\n                                 bank_id=self._catalog_idstr)\n        return objects.ObjectiveBank(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if this user can perform Objective lookups.", "response": "def can_lookup_objectives(self):\n        \"\"\"Tests if this user can perform Objective lookups.\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a PermissionDenied. This is intended as\n        a hint to an application that may opt not to offer lookup\n        operations to unauthorized users.\n        return: (boolean) - false if lookup methods are not authorized,\n                true otherwise\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveHints']['canLookup']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the Objective specified by its Id.", "response": "def get_objective(self, objective_id=None):\n        \"\"\"Gets the Objective specified by its Id.\n        In plenary mode, the exact Id is found or a NotFound results.\n        Otherwise, the returned Objective may have a different Id than\n        requested, such as the case where a duplicate Id was assigned to\n        an Objective and retained for compatibility.\n        arg:    objectiveId (osid.id.Id): Id of the Objective\n        return: (osid.learning.Objective) - the objective\n        raise:  NotFound - objectiveId not found\n        raise:  NullArgument - objectiveId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method is must be implemented.\n\n        \"\"\"\n        if objective_id is None:\n            raise NullArgument()\n        url_path = construct_url('objectives', obj_id=objective_id)\n        return objects.Objective(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_objectives_by_ids(self, objective_ids=None):\n        if objective_ids is None:\n            raise NullArgument()\n\n        url_path = construct_url('objectives_by_ids',\n                                 obj_ids=objective_ids)\n        objectives = self._get_request(url_path)\n\n        # for i in objective_ids:\n        #     objective = None\n        #     url_path = construct_url('objectives',\n        #                              obj_id=i)\n        #     try:\n        #         objective = self._get_request(url_path)\n        #     except (NotFound, OperationFailed):\n        #         if self._objective_view == PLENARY:\n        #             raise\n        #         else:\n        #             pass\n        #     if objective:\n        #         if not (self._objective_view == COMPARATIVE and\n        #                 objective in objectives):\n        #             objectives.append(objective)\n        return objects.ObjectiveList(objectives)", "response": "Gets an ObjectiveList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets an ObjectiveList corresponding to the given objective genus Type which does not include objectives of genus types derived from the specified Type.", "response": "def get_objectives_by_genus_type(self, objective_genus_type=None):\n        \"\"\"Gets an ObjectiveList corresponding to the given objective genus\n        Type which does not include objectives of genus types derived\n        from the specified Type.\n        In plenary mode, the returned list contains all known objectives\n        or an error results. Otherwise, the returned list may contain\n        only those objectives that are accessible through this session.\n        arg:    objectiveGenusType (osid.type.Type): an objective genus\n                type\n        return: (osid.learning.ObjectiveList) - the returned Objective\n                list\n        raise:  NullArgument - objectiveGenusType is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_genus_type is None:\n            raise NullArgument()\n        url_path = construct_url('objectives_by_genus',\n                                 bank_id=self._catalog_idstr,\n                                 genus_type=str(objective_genus_type))\n        return objects.ObjectiveList(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_objectives_by_query(self, objective_query=None):\n        if objective_query is None:\n            raise NullArgument()\n        if 'ancestorObjectiveId' in objective_query._query_terms:\n            url_path = construct_url('objectives',\n                                     bank_id=self._objective_bank_id,\n                                     obj_id=objective_query._query_terms['ancestorObjectiveId'].split('=')[1])\n            url_path += '/children'\n        elif 'descendantObjectiveId' in objective_query._query_terms:\n            url_path = construct_url('objectives',\n                                     bank_id=self._objective_bank_id,\n                                     obj_id=objective_query._query_terms['descendantObjectiveId'].split('=')[1])\n            url_path += '/parents'\n        else:\n            url_path = construct_url('objectives', obj_id=None)\n\n        for term in objective_query._query_terms:\n            if term not in ['ancestorObjectiveId', 'descendantObjectiveId']:\n                url_path += '&{0}'.format(objective_query._query_terms[term])\n\n        url_path = url_path.replace('&', '?', 1)\n        return objects.ObjectiveList(self._get_request(url_path))", "response": "Gets a list of Objectives matching the given objective query."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _record_extension(self, objective_id, key, value):\n        record_bean = {\n            'value': value,\n            'displayName': self._text_bean(key),\n            'description': self._text_bean(key),\n            'displayLabel': self._text_bean(key),\n            'associatedId': str(objective_id)\n        }\n        return record_bean", "response": "To structure a record extension property bean\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntest if this user can create Objectives.", "response": "def can_create_objectives(self):\n        \"\"\"Tests if this user can create Objectives.\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating an Objective\n        will result in a PermissionDenied. This is intended as a hint\n        to an application that may opt not to offer create operations to\n        an unauthorized user.\n        return: (boolean) - false if Objective creation is not\n                authorized, true otherwise\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveHints']['canCreate']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_form_for_create(self, objective_record_types=None):\n        if objective_record_types is None:\n            pass  # Still need to deal with the record_types argument\n        objective_form = objects.ObjectiveForm()\n        self._forms[objective_form.get_id().get_identifier()] = not CREATED\n        return objective_form", "response": "Gets the objective form for creating new objectives."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_objective(self, objective_form=None):\n        if objective_form is None:\n            raise NullArgument()\n        if not isinstance(objective_form, abc_learning_objects.ObjectiveForm):\n            raise InvalidArgument('argument type is not an ObjectiveForm')\n        if objective_form.is_for_update():\n            raise InvalidArgument('form is for update only, not create')\n        try:\n            if self._forms[objective_form.get_id().get_identifier()] == CREATED:\n                raise IllegalState('form already used in a create transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not objective_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('objectives',\n                                 bank_id=self._catalog_idstr)\n        try:\n            result = self._post_request(url_path, objective_form._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[objective_form.get_id().get_identifier()] = CREATED\n        return objects.Objective(result)", "response": "Creates a new Objective."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objective_form_for_update(self, objective_id=None):\n        if objective_id is None:\n            raise NullArgument()\n        try:\n            url_path = construct_url('objectives',\n                                     bank_id=self._catalog_idstr,\n                                     obj_id=objective_id)\n            objective = objects.Objective(self._get_request(url_path))\n        except Exception:\n            raise\n        objective_form = objects.ObjectiveForm(objective._my_map)\n        self._forms[objective_form.get_id().get_identifier()] = not UPDATED\n        return objective_form", "response": "Gets the objective form for updating an existing objective."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if this user can delete Objectives.", "response": "def can_delete_objectives(self):\n        \"\"\"Tests if this user can delete Objectives.\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting an Objective\n        will result in a PermissionDenied. This is intended as a hint\n        to an application that may opt not to offer delete operations to\n        an unauthorized user.\n        return: (boolean) - false if Objective deletion is not\n                authorized, true otherwise\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveHints']['canDelete']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_objective(self, objective_id=None):\n        if objective_id is None:\n            raise NullArgument()\n        if not isinstance(objective_id, abc_id):\n            raise InvalidArgument('argument type is not an osid Id')\n\n        url_path = construct_url('objectives',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=objective_id)\n        result = self._delete_request(url_path)\n        return objects.Objective(result)", "response": "Deletes the Objective identified by the given Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntests if this user can perform hierarchy queries.", "response": "def can_access_objective_hierarchy(self):\n        \"\"\"Tests if this user can perform hierarchy queries.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a PermissionDenied. This is intended as a\n        hint to an an application that may not offer traversal functions\n        to unauthorized users.\n\n        return: (boolean) - false if hierarchy traversal methods are not\n                authorized, true otherwise\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveHierarchyHints']['canAccessHierarchy']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the root objective Ids in this hierarchy.", "response": "def get_root_objective_ids(self):\n        \"\"\"Gets the root objective Ids in this hierarchy.\n\n        return: (osid.id.IdList) - the root objective Ids\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        url_path = construct_url('rootids',\n                                 bank_id=self._catalog_idstr)\n        id_list = list()\n        for identifier in self._get_request(url_path)['ids']:\n            id_list.append(Id(idstr=identifier))\n        return id_objects.IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the root objectives in this objective hierarchy.", "response": "def get_root_objectives(self):\n        \"\"\"Gets the root objective in this objective hierarchy.\n\n        return: (osid.learning.ObjectiveList) - the root objective\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method is must be implemented.\n\n        \"\"\"\n        url_path = construct_url('roots',\n                                 bank_id=self._catalog_idstr)\n        return objects.ObjectiveList(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if an Id is a direct parent of an objective.", "response": "def is_parent_of_objective(self, id_=None, objective_id=None):\n        \"\"\"Tests if an Id is a direct parent of an objective.\n\n        arg:    id (osid.id.Id): an Id\n        arg:    objective_id (osid.id.Id): the Id of an objective\n        return: (boolean) - true if this id is a parent of objective_id,\n                false otherwise\n        raise:  NotFound - objective_id is not found\n        raise:  NullArgument - id or objective_id is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n        implementation notes: If id not found return false.\n\n        \"\"\"\n        if id_ is None or objective_id is None:\n            raise NullArgument()\n        return id_ in list(self.get_parent_objective_ids(objective_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntests if an objective is a direct child of another.", "response": "def is_child_of_objective(self, id_=None, objective_id=None):\n        \"\"\"Tests if an objective is a direct child of another.\n\n        arg:    id (osid.id.Id): an Id\n        arg:    objective_id (osid.id.Id): the Id of an objective\n        return: (boolean) - true if the id is a child of objective_id,\n                false otherwise\n        raise:  NotFound - objective_id is not found\n        raise:  NullArgument - id or objective_id is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n        implementation notes: If id not found return false.\n\n        \"\"\"\n        if id_ is None or objective_id is None:\n            raise NullArgument()\n        return id_ in list(self.get_child_objective_ids(objective_id))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the child Ids of the given objective.", "response": "def get_child_objective_ids(self, objective_id=None):\n        \"\"\"Gets the child Ids of the given objective.\n\n        arg:    objective_id (osid.id.Id): the Id to query\n        return: (osid.id.IdList) - the children of the objective\n        raise:  NotFound - objective_id is not found\n        raise:  NullArgument - objective_id is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_id is None:\n            raise NullArgument()\n        url_path = construct_url('childids',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=objective_id)\n        id_list = list()\n        for identifier in self._get_request(url_path)['ids']:\n            id_list.append(Id(idstr=identifier))\n        return id_objects.IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the children of the given objective.", "response": "def get_child_objectives(self, objective_id=None):\n        \"\"\"Gets the children of the given objective.\n\n        arg:    objective_id (osid.id.Id): the Id to query\n        return: (osid.learning.ObjectiveList) - the children of the\n                objective\n        raise:  NotFound - objective_id is not found\n        raise:  NullArgument - objective_id is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_id is None:\n            raise NullArgument()\n        url_path = construct_url('children',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=objective_id)\n        return objects.ObjectiveList(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objective_nodes(self,\n                            objective_id=None,\n                            ancestor_levels=None,\n                            descendant_levels=None,\n                            include_siblings=None):\n        \"\"\"Gets a portion of the hierarchy for the given objective.\n\n        arg:    objective_id (osid.id.Id): the Id to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): true to include the siblings\n                of the given node, false to omit the siblings\n        return: (osid.learning.ObjectiveNode) - an objective node\n        raise:  NotFound - objective_id not found\n        raise:  NullArgument - objective_id is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_id is None:\n            url_path = construct_url('roots',\n                                     bank_id=self._catalog_idstr,\n                                     descendents=descendant_levels)\n            return self._get_request(url_path)\n        else:\n            raise Unimplemented()", "response": "Gets the hierarchy of the objective nodes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef can_modify_objective_hierarchy(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveHierarchyHints']['canModifyHierarchy']", "response": "Tests if this user can modify the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a child to an objective.", "response": "def add_child_objective(self, objective_id=None, child_id=None):\n        \"\"\"Adds a child to an objective.\n\n        arg:    objective_id (osid.id.Id): the Id of an objective\n        arg:    child_id (osid.id.Id): the Id of the new child\n        raise:  AlreadyExists - objective_id is already a parent of\n                child_id\n        raise:  NotFound - objective_id or child_id not found\n        raise:  NullArgument - objective_id or child_id is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_id is None or child_id is None:\n            raise NullArgument()\n        ohs = ObjectiveHierarchySession(self._objective_bank_id,\n                                        runtime=self._runtime)\n        if ohs.is_child_of_objective(child_id, objective_id):\n            raise AlreadyExists()\n        ids_arg = {'ids': []}\n        for ident in ohs.get_child_objective_ids(objective_id):\n            ids_arg['ids'].append(str(ident))\n        ids_arg['ids'].append(str(child_id))\n\n        url_path = construct_url('childids',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=objective_id)\n        try:\n            result = self._put_request(url_path, ids_arg)\n        except Exception:\n            raise\n        id_list = list()\n        for identifier in result['ids']:\n            id_list.append(Id(idstr=identifier))\n        return id_objects.IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving all children from an objective.", "response": "def remove_child_objectives(self, objective_id=None):\n        \"\"\"Removes all children from an objective.\n\n        arg:    objective_id (osid.id.Id): the Id of an objective\n        raise:  NotFound - objective_id not found\n        raise:  NullArgument - objective_id is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_id is None:\n            raise NullArgument()\n        ols = ObjectiveLookupSession(self._objective_bank_id, runtime=self._runtime)\n        try:\n            ols.get_objective(objective_id)\n        except:\n            raise  # If no objective, get_objectives will raise NotFound\n        ids_arg = {'ids': []}\n        url_path = construct_url('childids',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=objective_id)\n        try:\n            result = self._put_request(url_path, ids_arg)\n        except Exception:\n            raise\n        id_list = list()\n        for identifier in result['ids']:\n            id_list.append(Id(idstr=identifier))\n        return id_objects.IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if this user can sequence objectives.", "response": "def can_sequence_objectives(self):\n        \"\"\"Tests if this user can sequence objectives.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known performing any update\n        will result in a PermissionDenied. This is intended as a hint to\n        an application that may opt not to offer these operations to an\n        unauthorized user.\n\n        return: (boolean) - false if sequencing objectives is not\n                authorized, true otherwise\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveHierarchyHints']['canModifyHierarchy']"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef move_objective_behind(self, parent_objective_id=None, reference_objective_id=None, objective_id=None):\n        # NOT YET TESTED:\n        if (parent_objective_id is None or\n                reference_objective_id is None or\n                objective_id is None):\n            raise NullArgument()\n        ohs = ObjectiveHierarchySession(self._objective_bank_id, runtime=self._runtime)\n        if (not ohs.is_child_of_objective(objective_id, parent_objective_id) or\n                not ohs.is_child_of_objective(reference_objective_id, parent_objective_id)):\n            raise NotFound('The parent objective identified is not the parent of one or both of the other objectives')\n        ids_arg = {'ids': []}\n        for ident in ohs.get_child_objective_ids(parent_objective_id):\n            ids_arg['ids'].append(str(ident))\n        if objective_id != reference_objective_id:\n            ids_arg['ids'].remove(str(objective_id))\n            index = ids_arg['ids'].index(str(reference_objective_id))\n            ids_arg['ids'].insert(index + 1, str(objective_id))\n\n        url_path = construct_url('childids',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=parent_objective_id)\n        try:\n            result = self._put_request(url_path, ids_arg)\n        except Exception:\n            raise\n\n        # The following is not required by the osid specification:\n        id_list = list()\n        for identifier in result['ids']:\n            id_list.append(Id(idstr=identifier))\n        return id_objects.IdList(id_list)", "response": "Moves an objective behind a refrence objective under the given parent."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if this user can perform Objective lookups.", "response": "def can_lookup_objective_prerequisites(self):\n        \"\"\"Tests if this user can perform Objective lookups.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a PermissionDenied. This is intended as a\n        hint to an application that may opt not to offer lookup\n        operations to unauthorized users.\n\n        return: (boolean) - false if lookup methods are not authorized,\n                true otherwise\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveRequisiteHints']['canLookup']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_all_requisite_objectives(self, objective_id=None):\n        # This should be re-implemented if and when handcar supports\n        # getting all requisites directly\n        requisites = list()\n        requisite_ids = list()\n        all_requisites = self._get_requisites_recursively(objective_id, requisites, requisite_ids)\n        return objects.ObjectiveList(all_requisites)", "response": "Gets a list of Objectives that are the requisites for the given Objective."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if an objective is required before proceeding with an Objective.", "response": "def is_objective_required(self, objective_id=None, required_objective_id=None):\n        \"\"\"Tests if an objective is required before proceeding with an\n        objective.\n\n        arg:    objective_id (osid.id.Id): Id of the dependent Objective\n        arg:    required_objective_id (osid.id.Id): Id of the required\n                Objective\n        return: (boolean) - true if objective_id depends on\n                required_objective_id, false otherwise\n        raise:  NotFound - objective_id not found\n        raise:  NullArgument - objective_id is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_id is None or required_objective_id is None:\n            raise NullArgument()\n        requisite_objective_ids = list()\n        for requisite in self.get_all_requisite_objectives(objective_id):\n            requisite_objective_ids.append(requisite.get_id())\n        return required_objective_id in requisite_objective_ids"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef can_assign_requisites(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveRequisiteHints']['canAssign']", "response": "Tests if this user can assign the given set of objective requisites."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a requirement dependency between two Objectives.", "response": "def assign_objective_requisite(self, objective_id=None, requisite_objective_id=None):\n        \"\"\"Creates a requirement dependency between two Objectives.\n\n        arg:    objective_id (osid.id.Id): the Id of the dependent\n                Objective\n        arg:    requisite_objective_id (osid.id.Id): the Id of the\n                required Objective\n        raise:  AlreadyExists - objective_id already mapped to\n                requisite_objective_id\n        raise:  NotFound - objective_id or requisite_objective_id not\n                found\n        raise:  NullArgument - objective_id or requisite_objective_id is\n                null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_id is None or requisite_objective_id is None:\n            raise NullArgument()\n        ors = ObjectiveRequisiteSession(self._objective_bank_id, runtime=self._runtime)\n        ids_arg = {'ids': []}\n        for objective in ors.get_requisite_objectives(objective_id):\n            if objective.get_id() == requisite_objective_id:\n                raise AlreadyExists()\n            ids_arg['ids'].append(str(objective.get_id()))\n        ids_arg['ids'].append(str(requisite_objective_id))\n\n        url_path = construct_url('requisiteids',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=objective_id)\n        try:\n            result = self._put_request(url_path, ids_arg)\n        except Exception:\n            raise\n        id_list = list()\n        for identifier in result['ids']:\n            id_list.append(Id(idstr=identifier))\n        return id_objects.IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef assign_objective_requisites(self, objective_id=None, requisite_objective_ids=None):\n        if objective_id is None or requisite_objective_ids is None:\n            raise NullArgument()\n        ors = ObjectiveRequisiteSession(self._objective_bank_id, runtime=self._runtime)\n        ids_arg = {'ids': [str(i) for i in requisite_objective_ids]}\n\n        url_path = construct_url('requisiteids',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=objective_id)\n        try:\n            result = self._put_request(url_path, ids_arg)\n        except Exception:\n            raise\n        id_list = list()\n        for identifier in result['ids']:\n            id_list.append(Id(idstr=identifier))\n        return id_objects.IdList(id_list)", "response": "Creates a requirement dependency between Objective + a list of objectives."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef can_lookup_activities(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['activityHints']['canLookup']", "response": "Tests if this user can perform Activity lookups."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_activity(self, activity_id=None):\n        if activity_id is None:\n            raise NullArgument()\n        url_path = construct_url('activities',\n                                 bank_id=self._catalog_idstr,\n                                 act_id=activity_id)\n        return objects.Activity(self._get_request(url_path))", "response": "Gets the Activity specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_activities_by_ids(self, activity_ids=None):\n        if activity_ids is None:\n            raise NullArgument()\n        activities = []\n        for i in activity_ids:\n            activity = None\n            url_path = construct_url('activities',\n                                     bank_id=self._catalog_idstr,\n                                     act_id=i)\n            try:\n                activity = self._get_request(url_path)\n            except (NotFound, OperationFailed):\n                if self._activity_view == PLENARY:\n                    raise\n                else:\n                    pass\n            if activity:\n                if not (self._activity_view == COMPARATIVE and\n                        activity in activities):\n                    activities.append(activity)\n        return objects.ActivityList(activities)", "response": "Gets an ActivityList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget an ActivityList corresponding to the given activity genusType Type which does not include activities of genus types derived from the specified Type.", "response": "def get_activities_by_genus_type(self, activity_genus_type=None):\n        \"\"\"Gets an ActivityList corresponding to the given activity genus\n        Type which does not include activities of genus types derived\n        from the specified Type.\n        In plenary mode, the returned list contains all known activities\n        or an error results. Otherwise, the returned list may contain\n        only those activities that are accessible through this session.\n        arg:    activityGenusType (osid.type.Type): an activity genus\n                type\n        return: (osid.learning.ActivityList) - the returned Activity\n                list\n        raise:  NullArgument - activityGenusType is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if activity_genus_type is None:\n            raise NullArgument()\n        url_path = construct_url('activities_by_genus',\n                                 bank_id=self._catalog_idstr,\n                                 genus_type=activity_genus_type.get_identifier())\n        return objects.ActivityList(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_activities_for_objective(self, objective_id=None):\n        if objective_id is None:\n            raise NullArgument()\n        # Should also check if objective_id exists?\n        url_path = construct_url('activities',\n                                 bank_id=self._catalog_idstr,\n                                 obj_id=objective_id)\n        return objects.ActivityList(self._get_request(url_path))", "response": "Gets the activities mapped to the given objective."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_activities_for_objectives(self, objective_ids=None):\n        if objective_ids is None:\n            raise NullArgument()\n        # Should also check if objective_id exists?\n        activities = []\n        for i in objective_ids:\n            acts = None\n            url_path = construct_url('activities',\n                                     bank_id=self._catalog_idstr,\n                                     obj_id=i)\n            try:\n                acts = json.loads(self._get_request(url_path))\n            except (NotFound, OperationFailed):\n                if self._activity_view == PLENARY:\n                    raise\n                else:\n                    pass\n            if acts:\n                activities += acts\n        return objects.ActivityList(activities)", "response": "Gets the activities for the given objectives."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_activities(self):\n        url_path = construct_url('activities',\n                                 bank_id=self._catalog_idstr)\n        return objects.ActivityList(self._get_request(url_path))", "response": "Gets all Activities. A list of Activities is returned."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_activities_by_query(self, activity_query=None):\n        url_path = construct_url('activities',\n                                 bank_id=self._catalog_idstr)\n        query_terms = [v for k, v in activity_query._query_terms.items()]\n        url_path += '?' + '&'.join(query_terms)\n        objects.ActivityList(self._get_request(url_path))", "response": "Gets a list of Activities matching the given activity query."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef can_create_activities(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['activityHints']['canCreate']", "response": "Tests if this user can create Activities. A return of true does not guarantee successful authorization."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_activity_form_for_create(self, objective_id=None, activity_record_types=None):\n        if objective_id is None:\n            raise NullArgument()\n        if activity_record_types is None:\n            pass  # Still need to deal with the record_types argument\n        activity_form = objects.ActivityForm(osid_object_map=None, objective_id=objective_id)\n        self._forms[activity_form.get_id().get_identifier()] = not CREATED\n        return activity_form", "response": "Gets the activity form for creating new activities."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef can_update_activities(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['activityHints']['canUpdate']", "response": "Tests if this user can update Activities. A return of true does not guarantee successful authorization."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the activity form for updating an existing activity.", "response": "def get_activity_form_for_update(self, activity_id=None):\n        \"\"\"Gets the activity form for updating an existing activity.\n        A new activity form should be requested for each update\n        transaction.\n        arg:    activityId (osid.id.Id): the Id of the Activity\n        return: (osid.learning.ActivityForm) - the activity form\n        raise:  NotFound - activityId is not found\n        raise:  NullArgument - activityId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if activity_id is None:\n            raise NullArgument()\n        try:\n            url_path = construct_url('activities',\n                                     bank_id=self._catalog_idstr,\n                                     act_id=activity_id)\n            activity = objects.Activity(self._get_request(url_path))\n        except Exception:\n            raise\n        activity_form = objects.ActivityForm(activity._my_map)\n        self._forms[activity_form.get_id().get_identifier()] = not UPDATED\n        return activity_form"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating an existing activity.", "response": "def update_activity(self, activity_form=None):\n        \"\"\"Updates an existing activity,.\n\n        arg:    activityForm (osid.learning.ActivityForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - activityForm already used in an update\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - activityForm is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - activityForm did not originate from\n                get_activity_form_for_update()\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if activity_form is None:\n            raise NullArgument()\n        if not isinstance(activity_form, abc_learning_objects.ActivityForm):\n            raise InvalidArgument('argument type is not an ActivityForm')\n        if not activity_form.is_for_update():\n            raise InvalidArgument('form is for create only, not update')\n        try:\n            if self._forms[activity_form.get_id().get_identifier()] == UPDATED:\n                raise IllegalState('form already used in an update transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not activity_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('activities',\n                                 bank_id=self._catalog_idstr)\n        try:\n            result = self._put_request(url_path, activity_form._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[activity_form.get_id().get_identifier()] = UPDATED\n        return objects.Activity(result)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef can_delete_activities(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['activityHints']['canDelete']", "response": "Tests if this user can delete Activities. A return of true does not guarantee successful authorization."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes the Activity identified by the given Id.", "response": "def delete_activity(self, activity_id=None):\n        \"\"\"Deletes the Activity identified by the given Id.\n\n        arg:    activityId (osid.id.Id): the Id of the Activity to\n                delete\n        raise:  NotFound - an Activity was not found identified by the\n                given Id\n        raise:  NullArgument - activityId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if activity_id is None:\n            raise NullArgument()\n        if not isinstance(activity_id, Id):\n            raise InvalidArgument('argument type is not an osid Id')\n\n        url_path = construct_url('activities',\n                                 bank_id=self._catalog_idstr,\n                                 act_id=activity_id)\n        result = self._delete_request(url_path)\n        return objects.Activity(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef can_lookup_objective_banks(self):\n        # need to use a default bank_id here...not ideal.\n        url_path = construct_url('authorization',\n                                 bank_id=self._default_bank_id)\n        return self._get_request(url_path)['objectiveBankHints']['canLookup']", "response": "Tests if this user can perform ObjectiveBank lookups."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_bank(self, objective_bank_id=None):\n        if objective_bank_id is None:\n            raise NullArgument()\n        url_path = construct_url('objective_banks',\n                                 bank_id=objective_bank_id)\n        return objects.ObjectiveBank(self._get_request(url_path))", "response": "Gets the ObjectiveBank specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a ObjectiveBankList corresponding to the given IdList.", "response": "def get_objective_banks_by_ids(self, objective_bank_ids=None):\n        \"\"\"Gets a ObjectiveBankList corresponding to the given IdList.\n        In plenary mode, the returned list contains all of the objective\n        banks specified in the Id list, in the order of the list,\n        including duplicates, or an error results if an Id in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ObjectiveBank objects may be omitted from the list\n        and may present the elements in any order including returning a\n        unique set.\n        arg:    objectiveBankIds (osid.id.IdList): the list of Ids to\n                retrieve\n        return: (osid.learning.ObjectiveBankList) - the returned\n                ObjectiveBank list\n        raise:  NotFound - an Id was not found\n        raise:  NullArgument - objectiveBankIds is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_bank_ids is None:\n            raise NullArgument()\n        banks = []\n        # The following runs really slow. Perhaps get all banks and then inspect result for ids\n        for i in objective_bank_ids:\n            bank = None\n            url_path = construct_url('objective_banks',\n                                     bank_id=i)\n            try:\n                bank = self._get_request(url_path)\n            except (NotFound, OperationFailed):\n                if self._objective_bank_view == PLENARY:\n                    raise\n                else:\n                    pass\n            if bank:\n                if not (self._objective_bank_view == COMPARATIVE and\n                        bank in banks):\n                    banks.append(bank)\n        return objects.ObjectiveBankList(banks)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a ObjectiveBankList corresponding to the given objective bank genus Type which does not include objective banks of types derived from the specified Type.", "response": "def get_objective_banks_by_genus_type(self, objective_bank_genus_type=None):\n        \"\"\"Gets a ObjectiveBankList corresponding to the given objective\n        bank genus Type which does not include objective banks of types\n        derived from the specified Type.\n        In plenary mode, the returned list contains all known objective\n        banks or an error results. Otherwise, the returned list may\n        contain only those objective banks that are accessible through\n        this session.\n        arg:    objectiveBankGenusType (osid.type.Type): an objective\n                bank genus type\n        return: (osid.learning.ObjectiveBankList) - the returned\n                ObjectiveBank list\n        raise:  NullArgument - objectiveBankGenusType is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_bank_genus_type is None:\n            raise NullArgument()\n        url_path = construct_url('objective_banks_by_genus',\n                                 genus_type=objective_bank_genus_type)\n        return objects.ObjectiveBankList(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the objective bank form for creating new objective banks.", "response": "def get_objective_bank_form_for_create(self, objective_bank_record_types=None):\n        \"\"\"Gets the objective bank form for creating new objective banks.\n        A new form should be requested for each create transaction.\n        arg:    objectiveBankRecordTypes (osid.type.Type): array of\n                objective bank record types\n        return: (osid.learning.ObjectiveBankForm) - the objective bank\n                form\n        raise:  NullArgument - objectiveBankRecordTypes is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types.\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if objective_bank_record_types is None:\n            pass  # Still need to deal with the record_types argument\n        objective_bank_form = objects.ObjectiveBankForm()\n        self._forms[objective_bank_form.get_id().get_identifier()] = not CREATED\n        return objective_bank_form"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_objective_bank(self, objective_bank_form=None):\n        if objective_bank_form is None:\n            raise NullArgument()\n        if not isinstance(objective_bank_form, abc_learning_objects.ObjectiveBankForm):\n            raise InvalidArgument('argument type is not an ObjectiveBankForm')\n        if objective_bank_form.is_for_update():\n            raise InvalidArgument('form is for update only, not create')\n\n        # Check for \"sandbox\" genus type.  Hardcoded for now:\n        #        if objective_bank_form._my_map['genusTypeId'] != 'mc3-objectivebank%3Amc3.learning.objectivebank.sandbox%40MIT-OEIT':\n        #            raise PermissionDenied('Handcar only supports creating \\'sandbox\\' type ObjectiveBanks')\n\n        try:\n            if self._forms[objective_bank_form.get_id().get_identifier()] == CREATED:\n                raise IllegalState('form already used in a create transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not objective_bank_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('objective_banks')\n        try:\n            result = self._post_request(url_path, objective_bank_form._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[objective_bank_form.get_id().get_identifier()] = CREATED\n        return objects.ObjectiveBank(result)", "response": "Creates a new ObjectiveBank."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest if this user can update ObjectiveBanks.", "response": "def can_update_objective_banks(self, objective_bank_id=None):  # This should not have objective_bank_id argument!\n        \"\"\"Tests if this user can update ObjectiveBanks.\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating an\n        ObjectiveBank will result in a PermissionDenied. This is\n        intended as a hint to an application that may not wish to offer\n        update operations to unauthorized users.\n        return: (boolean) - false if ObjectiveBank modification is not\n                authorized, true otherwise\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if not objective_bank_id:\n            url_path = construct_url('authorization')\n        else:\n            url_path = construct_url('authorization',\n                                     bank_id=str(objective_bank_id))\n        return self._get_request(url_path)['objectiveBankHints']['canUpdate']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_objective_bank_form_for_update(self, objective_bank_id=None):\n        if objective_bank_id is None:\n            raise NullArgument()\n        try:\n            url_path = construct_url('objective_banks',\n                                     bank_id=objective_bank_id)\n            objective_bank = objects.ObjectiveBank(self._get_request(url_path))\n        except Exception:\n            raise\n        objective_bank_form = objects.ObjectiveBankForm(objective_bank._my_map)\n        self._forms[objective_bank_form.get_id().get_identifier()] = not UPDATED\n        return objective_bank_form", "response": "Gets the objective bank form for updating an existing objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_bank_record_types(self):\n        try:\n            url_path = construct_url('objective_bank_types')\n            objective_bank_types = typeObjects.TypeList(self._get_request(url_path))\n        except Exception:\n            raise\n        return objective_bank_types", "response": "Gets the objective bank types available in Handcar."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_objective_bank(self, objective_bank_form=None):\n        if objective_bank_form is None:\n            raise NullArgument()\n        if not isinstance(objective_bank_form, abc_learning_objects.ObjectiveBankForm):\n            raise InvalidArgument('argument type is not an ObjectiveBankForm')\n        if not objective_bank_form.is_for_update():\n            raise InvalidArgument('form is for create only, not update')\n\n        # Check for \"sandbox\" genus type.  Hardcoded for now:\n        # if objective_bank_form._my_map['genusTypeId'] != 'mc3-objectivebank%3Amc3.learning.objectivebank.sandbox%40MIT-OEIT':\n        #    raise PermissionDenied('Handcar only supports updating \\'sandbox\\' type ObjectiveBanks')\n\n        try:\n            if self._forms[objective_bank_form.get_id().get_identifier()] == UPDATED:\n                raise IllegalState('form already used in an update transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not objective_bank_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('objective_banks')\n        try:\n            result = self._put_request(url_path, objective_bank_form._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[objective_bank_form.get_id().get_identifier()] = UPDATED\n        return objects.ObjectiveBank(result)", "response": "Updates an existing objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef can_delete_objective_banks(self, objective_bank_id=None):  # This should not have objective_bank_id argument!\n        if not objective_bank_id:\n            url_path = construct_url('authorization')\n        else:\n            url_path = construct_url('authorization',\n                                     bank_id=str(objective_bank_id))\n        return self._get_request(url_path)['objectiveBankHints']['canDelete']", "response": "Tests if this user can delete an objective banks."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_objective_bank(self, objective_bank_id=None):\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        if objective_bank_id is None:\n            raise NullArgument()\n        if not isinstance(objective_bank_id, ABCId):\n            raise InvalidArgument('argument type is not an osid Id')\n\n        # Check for \"sandbox\" genus type.  Hardcoded for now:\n        try:\n            objective_bank = ObjectiveBankLookupSession(proxy=self._proxy,\n                                                        runtime=self._runtime).get_objective_bank(objective_bank_id)\n        except Exception:\n            raise\n        # if objective_bank._my_map['genusTypeId'] != 'mc3-objectivebank%3Amc3.learning.objectivebank.sandbox%40MIT-OEIT':\n        #     raise PermissionDenied('Handcar only supports deleting \\'sandbox\\' type ObjectiveBanks')\n\n        url_path = construct_url('objective_banks',\n                                 bank_id=objective_bank_id)\n        result = self._delete_request(url_path)\n        return objects.ObjectiveBank(result)", "response": "Deletes an ObjectiveBank.\n\n        arg:    objectiveBankId (osid.id.Id): the Id of the\n                ObjectiveBank to remove\n        raise:  NotFound - objectiveBankId not found\n        raise:  NullArgument - objectiveBankId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the root objective bank Ids in this hierarchy.", "response": "def get_root_objective_bank_ids(self, alias):\n        \"\"\"Gets the root objective bank Ids in this hierarchy.\n\n        return: (osid.id.IdList) - the root objective bank Ids\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        url_path = self._urls.roots(alias)\n        return self._get_request(url_path)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_objective_bank_nodes(self,\n                                 objective_bank_id=None,\n                                 ancestor_levels=None,\n                                 descendant_levels=None,\n                                 include_siblings=None):\n        \"\"\"Gets a portion of the hierarchy for the given objective bank.\n\n        arg:    includeSiblings (boolean): true to include the siblings\n                of the given node, false to omit the siblings\n        return: (osid.learning.ObjectiveBankNode) - an objective bank\n                node\n        raise:  NotFound - objectiveBankId not found\n        raise:  NullArgument - objectiveBankId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if descendant_levels:\n            url_path = self._urls.nodes(alias=objective_bank_id, depth=descendant_levels)\n        else:\n            url_path = self._urls.nodes(alias=objective_bank_id)\n        return self._get_request(url_path)", "response": "Gets the portion of the hierarchy for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a bank hierarchy with the given alias and description.", "response": "def create_objective_bank_hierarchy(self, alias, desc, genus):\n        \"\"\"\n        Create a bank hierarchy with the given alias\n        :param alias:\n        :return:\n        \"\"\"\n        url_path = self._urls.hierarchy()\n        data = {\n            'id': re.sub(r'[ ]', '', alias.lower()),\n            'displayName': {\n                'text': alias\n            },\n            'description': {\n                'text': desc\n            },\n            'genusTypeId': str(genus)\n        }\n        return self._post_request(url_path, data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting this bank hierarchy.", "response": "def delete_objective_bank_hierarchy(self, alias):\n        \"\"\"\n        Delete this bank hierarchy\n        :param alias:\n        :return:\n        \"\"\"\n        url_path = self._urls.hierarchy(alias)\n        return self._delete_request(url_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the hierarchy associated with this session.", "response": "def get_objective_bank_hierarchy(self, alias):\n        \"\"\"Gets the hierarchy associated with this session.\n\n        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = self._urls.hierarchy(re.sub(r'[ ]', '', alias.lower()))\n        return self._get_request(url_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_root_objective_bank(self, alias=None, objective_bank_id=None):\n        url_path = self._urls.roots(alias=alias)\n        current_root_ids = self._get_request(url_path)['ids']\n        current_root_ids.append(str(objective_bank_id))\n        new_root_ids = {\n            'ids': current_root_ids\n        }\n        return self._put_request(url_path, new_root_ids)", "response": "Adds a root objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_root_objective_bank(self, alias=None, objective_bank_id=None):\n        url_path = self._urls.roots(alias=alias)\n        current_root_ids = self._get_request(url_path)['ids']\n        modified_list = []\n        for root_id in current_root_ids:\n            if root_id != str(objective_bank_id):\n                modified_list.append(root_id)\n        new_root_ids = {\n            'ids': modified_list\n        }\n        return self._put_request(url_path, new_root_ids)", "response": "Removes a root objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a child to an objective bank.", "response": "def add_child_objective_bank(self, objective_bank_id=None, parent_id=None, child_id=None):\n        \"\"\"Adds a child to an objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``objective_bank_id`` is already a\n                parent of ``child_id``\n        raise:  NotFound - ``objective_bank_id`` or ``child_id`` not\n                found\n        raise:  NullArgument - ``objective_bank_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = self._urls.children(alias=objective_bank_id, bank_id=parent_id)\n        current_children_ids = self._get_request(url_path)['ids']\n        current_children_ids.append(str(child_id))\n        new_children_ids = {\n            'ids': current_children_ids\n        }\n        return self._put_request(url_path, new_children_ids)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(args):\n  cmd = ['sort',args.reference,'--gpd','--tempdir',args.tempdir,'--threads',\n         str(args.threads),'-o',args.tempdir+'/ref.sorted.gpd']\n  sys.stderr.write(cmd+\"\\n\")\n  gpd_sort(cmd)\n  cmd = ['sort',args.gpd,'--gpd','--tempdir',args.tempdir,'--threads',\n         str(args.threads),'-o',args.tempdir+'/my.sorted.gpd']\n  sys.stderr.write(cmd+\"\\n\")\n  gpd_sort(cmd)\n  rstream = GPDStream(open(args.tempdir+'/ref.sorted.gpd'))\n  mstream = GPDStream(open(args.tempdir+'/my.sorted.gpd'))\n  stream = MultiLocusStream([rstream,mstream])\n  of = sys.stdout\n  if args.output != '-':\n    if args.output[-3:] == '.gz': of = gzip.open(args.output,'w')\n    else: of = open(args.output,'w')\n  for locus_rng in stream:\n    (rgpds, mgpds) = locus_rng.get_payload()\n    if len(mgpds) == 0: continue\n    sys.stderr.write(locus_rng.get_range_string()+\" \"+str(len(rgpds))+\" \"+str(len(mgpds))+\"     \\r\")\n    ref_juncs = {}\n    for ref in rgpds: ref_juncs[ref.get_junction_string()] = ref\n    annotated = []\n    unannotated = []\n    annotated = [ref_juncs[x.get_junction_string()] for x in mgpds if x.get_exon_count() > 1 and x.get_junction_string() in ref_juncs]\n    unannotated = [x for x in mgpds if x.get_exon_count() > 1 and x.get_junction_string() not in ref_juncs]\n    # now unannotated needs an annotation.\n    my_unannotated = [x for x in mgpds if x.get_exon_count() == 1]\n    single_reference = [x for x in rgpds if x.get_exon_count() == 1]\n    single_annotated = []\n    single_unannotated = []\n    #print len(single_reference)\n    #print len(single_unannotated)\n    for gpd in my_unannotated:\n      overs = sorted([x for x in single_reference if x.overlap_size(gpd) > 0],\\\n      key=lambda y: y.avg_mutual_coverage(gpd), reverse=True)\n      if len(overs) > 0:\n        single_annotated.append(overs[0])\n      else: single_unannotated.append(gpd)\n    # now annotated and single_annotated are done\n    unannotated += single_unannotated\n    # now single or multi we need to annotated unanotated\n    gene_annotated = []\n    no_annotation = []\n    for m in unannotated:\n      overs = sorted([x for x in rgpds if x.overlap_size(m) > 0],\\\n      key=lambda y: y.avg_mutual_coverage(m), reverse=True)\n      if len(overs) > 0:\n        gname = overs[0].value('gene_name')\n        f = overs[0].get_gpd_line().rstrip().split(\"\\t\")\n        f[0] = gname\n        f[1] = str(uuid.uuid4())\n        g = GPD(\"\\t\".join(f))\n        gene_annotated.append(g)\n      else: no_annotation.append(m)\n    finished = []\n    # now we need to annotate no_annotation\n    while len(no_annotation) > 0:\n      m = no_annotation.pop(0)\n      matched = False\n      for i in range(0,len(finished)):\n        if len([x for x in finished[i] if x.overlap_size(m) > 0]) > 0:\n          finished[i].append(m)\n          matched = True\n          break\n      if not matched:  finished.append([m])\n    # now finished has gene groups\n    original = []\n    for group in finished:\n      gname = str(uuid.uuid4())\n      for member in group:\n        tname = str(uuid.uuid4())\n        f = member.get_gpd_line().rstrip().split(\"\\t\")\n        f[0] = gname\n        f[1] = tname\n        g = GPD(\"\\t\".join(f))\n        original.append(g)\n    for gpd in original + annotated + single_annotated + gene_annotated:\n      of.write(gpd.get_gpd_line()+\"\\n\")\n  of.close()\n  sys.stderr.write(\"\\n\")\n  # Temporary working directory step 3 of 3 - Cleanup\n  if not args.specific_tempdir:\n    rmtree(args.tempdir)", "response": "main function of the genepreds"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _reExec(regex, string):\n    '''This returns [full match, group1, group2, ...], just like JS.'''\n    m = regex.search(string)\n    if not m: return None\n    return [m.group()] + list(m.groups())", "response": "This returns a list of groups that match the regex."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a string similar to JS s typeof.", "response": "def _jsTypeof(o):\n    '''Return a string similar to JS's typeof.'''\n    if o == None:\n        return 'object'\n    elif o == Undefined:\n        return 'undefined'\n    elif isinstance(o, bool):\n        return 'boolean'\n    if isinstance(o, int) or isinstance(o, float):\n        return 'number'\n    elif isinstance(o, list) or isinstance(o, dict):\n        return 'object'\n    elif isinstance(o, stringtype):\n        return 'string'\n    raise ValueError('Unknown type for object %s (%s)' % (o, type(o)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match(sel, obj, arr=None, bailout_fn=None):\n    '''Match a selector to an object, yielding the matched values.\n\n    Args:\n        sel: The JSONSelect selector to apply (a string)\n        obj: The object against which to apply the selector\n        arr: If sel contains ? characters, then the values in this array will\n             be safely interpolated into the selector.\n        bailout_fn: A callback which takes two parameters, |obj| and |matches|.\n             This will be called on every node in obj. If it returns True, the\n             search for matches will be aborted below that node. The |matches|\n             parameter indicates whether the node matched the selector. This is\n             intended to be used as a performance optimization.\n    '''\n    if arr:\n        sel = interpolate(sel, arr)\n    sel = parse(sel)[1]\n    return _forEach(sel, obj, bailout_fn=bailout_fn)", "response": "Match a selector to an object yielding the matched values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a display name for this service implementation.", "response": "def get_display_name(self):\n        \"\"\"Gets a display name for this service implementation.\n\n        return: (osid.locale.DisplayText) - a display name\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        return DisplayText({'text': profile.DISPLAYNAME,\n                            'languageTypeId': profile.LANGUAGETYPEID,\n                            'scriptTypeId': profile.SCRIPTTYPEID,\n                            'formatTypeId': profile.FORMATTYPEID})"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_description(self):\n        return DisplayText({'text': profile.DESCRIPTION,\n                            'languageTypeId': profile.LANGUAGETYPEID,\n                            'scriptTypeId': profile.SCRIPTTYPEID,\n                            'formatTypeId': profile.FORMATTYPEID})", "response": "Gets a description of this service implementation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_manager(self, osid=None, impl_class_name=None, version=None):\n        # This implementation assumes that all osid impls reside as seperate\n        # packages in the dlkit library, so that for instance the proxy manager for an\n        # OSID = 'osidpackage' in an implementation named 'impl_name' manager can\n        # be found in the python path for the module: dlkit.impl_name.osid.managers\n        # Also this implementation currently ignores the OSID specification version.\n        from importlib import import_module\n        try:\n            manager_module = import_module('dlkit.' + impl_class_name + '.' + osid.lower() + '.managers')\n        except ImportError:\n            raise NotFound()\n        try:\n            manager = getattr(manager_module, osid.title() + 'Manager')\n        except AttributeError:\n            raise Unsupported()\n        return manager", "response": "Finds loads and instantiates the OSID manager for the requested OSID."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind loads and instantiates a proxy manager for the requested OSID and returns it.", "response": "def get_proxy_manager(self, osid=None, implementation=None, version=None):\n        \"\"\"Finds, loads and instantiates providers of OSID managers.\n\n        Providers must conform to an ``OsidManager`` interface. The\n        interfaces are defined in the OSID enumeration. For all OSID\n        requests, an instance of ``OsidManager`` that implements the\n        ``OsidManager`` interface is returned. In bindings where\n        permitted, this can be safely cast into the requested manager.\n\n        arg:    osid (osid.OSID): represents the OSID\n        arg:    implementation (string): the name of the implementation\n        arg:    version (osid.installation.Version): the minimum\n                required OSID specification version\n        return: (osid.OsidProxyManager) - the manager of the service\n        raise:  ConfigurationError - an error in configuring the\n                implementation\n        raise:  NotFound - the implementation class was not found\n        raise:  NullArgument - ``implementation`` or ``version`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``implementation`` does not support the\n                requested OSID\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: After finding and instantiating the\n        requested ``OsidManager,`` providers must invoke\n        ``OsidManager.initialize(OsidRuntimeManager)`` where the\n        environment is an instance of the current environment that\n        includes the configuration for the service being initialized.\n        The ``OsidRuntimeManager`` passed may include information useful\n        for the configuration such as the identity of the service being\n        instantiated.\n\n        \"\"\"\n        # This implementation assumes that all osid impls reside as seperate\n        # packages in the dlkit library, so that for instance the proxy manager for an\n        # OSID = 'osidpackage' in an implementation named 'impl_name' manager can\n        # be found in the python path for the module: dlkit.impl_name.osid.managers\n        # Also this implementation currently ignores the OSID specification version.\n        try:\n            manager_module = import_module('dlkit.' + implementation + '.' + osid.lower() + '.managers')\n        except ImportError:\n            raise NotFound()\n        try:\n            proxy_manager = getattr(manager_module, osid.title() + 'ProxyManager')\n        except AttributeError:\n            raise Unsupported()\n        return proxy_manager"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider AgentSearchSession. get_agents_by_search", "response": "def get_agents_by_search(self, agent_query, agent_search):\n        \"\"\"Pass through to provider AgentSearchSession.get_agents_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_agents_by_search(agent_query, agent_search)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_type_data(name):\n    name = name.upper()\n    try:\n        return {\n            'authority': 'birdland.mit.edu',\n            'namespace': 'calendar format',\n            'identifier': name,\n            'domain': 'Calendar Format Types',\n            'display_name': JEFFS_CALENDAR_FORMAT_TYPES[name] + ' Calendar Format Type',\n            'display_label': JEFFS_CALENDAR_FORMAT_TYPES[name],\n            'description': ('The calendar format type for ' +\n                            JEFFS_CALENDAR_FORMAT_TYPES[name])\n        }\n    except KeyError:\n        raise NotFound('Calendar Format Type: ' + name)", "response": "Return dictionary representation of type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ffmpeg(*args, **kwargs):\n\n    ff = FFMPEG(*args, **kwargs)\n    ff.start(\n            stdin=kwargs.get(\"stdin\", None),\n            stdout=kwargs.get(\"stdout\", None),\n            stderr=kwargs.get(\"stderr\", subprocess.PIPE)\n        )\n\n    ff.wait(kwargs.get(\"progress_handler\", None))\n\n    if ff.return_code:\n        err = indent(ff.error_log)\n        logging.error(\"Problem occured during transcoding\\n\\n{}\\n\\n\".format(err))\n        return False\n    return True", "response": "Universal ffmpeg wrapper with progress and error handling"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a proxy. :param input: a proxy condition :type input: ``osid.proxy.ProxyCondition`` :return: a proxy :rtype: ``osid.proxy.Proxy`` :raise: ``NullArgument`` -- ``input`` is ``null`` :raise: ``OperationFailed`` -- unable to complete request :raise: ``PermissionDenied`` -- authorization failure :raise: ``Unsupported`` -- ``input`` is not of this service *compliance: mandatory -- This method is must be implemented.*", "response": "def get_proxy(self, input_):\n        \"\"\"Gets a proxy.\n\n        :param input: a proxy condition\n        :type input: ``osid.proxy.ProxyCondition``\n        :return: a proxy\n        :rtype: ``osid.proxy.Proxy``\n        :raise: ``NullArgument`` -- ``input`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``input`` is not of this service\n\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        if input_._http_request is not None:\n            authentication = DjangoAuthentication()\n            authentication.set_django_user(input_._http_request.user, input_._use_user_id)\n        elif input_._xblock_user is not None:\n            authentication = XBlockAuthentication()\n            authentication.set_xblock_user(input_._xblock_user)\n        else:\n            authentication = None\n\n        if authentication is not None:\n            effective_agent_id = authentication.get_agent_id()\n        else:\n            effective_agent_id = input_._effective_agent_id\n\n        if input_._locale is not None:\n            locale = input_._locale\n        else:\n            locale = None\n        return rules.Proxy(authentication=authentication,\n                           effective_agent_id=effective_agent_id,\n                           locale=locale)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize metadata for the nOfM question", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._n_of_m_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'nOfM'),\n            'element_label': 'nOfM',\n            'instructions': 'Student is expected to do N of M questions',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [-1],\n            'syntax': 'INTEGER',\n            'object_set': [],\n            'minimum_integer': None,\n            'maximum_integer': None,\n            'integer_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_n_of_m(self, value=None):\n        if value is None:\n            raise NullArgument()\n        if isinstance(value, bool):\n            # because True / False are also int types...\n            raise InvalidArgument('value must be integer')\n        if value is not None and not isinstance(value, int):\n            raise InvalidArgument('value must be integer')\n        if self.get_n_of_m_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_integer(value,\n                                                          self.get_n_of_m_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['nOfM'] = value", "response": "set the n of m"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclearing the n of m", "response": "def clear_n_of_m(self):\n        \"\"\"stub\"\"\"\n        if (self.get_n_of_m_metadata().is_read_only() or\n                self.get_n_of_m_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['nOfM'] = \\\n            int(self._n_of_m_metadata['default_object_values'][0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the user has unlock previous", "response": "def has_unlock_previous(self):\n        \"\"\"stub\"\"\"\n        if 'unlockPrevious' not in self.my_osid_object._my_map or \\\n                self.my_osid_object._my_map['unlockPrevious'] is None:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_metadata(self):\n        self._min_string_length = None\n        self._max_string_length = None\n        self._unlock_previous_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'unlock_previous'),\n            'element_label': 'unlock_previous',\n            'instructions': 'Indicator to UI on how to treat the previous button',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': ['always'],\n            'syntax': 'STRING',\n            'minimum_string_length': self._min_string_length,\n            'maximum_string_length': self._max_string_length,\n            'string_set': []\n        }", "response": "Initialize the metadata for the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_unlock_previous(self, unlock_previous):\n        if unlock_previous is None:\n            raise NullArgument('unlock_previous cannot be None')\n        if unlock_previous is not None and not utilities.is_string(unlock_previous):\n            raise InvalidArgument('unlock_previous must be a string')\n        self.my_osid_object_form._my_map['unlockPrevious'] = unlock_previous", "response": "use a string -- for now, ``always`` and ``never`` are the options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_xml(self, metric):\n        self._opener = urllib2.build_opener()\n        self._opener.addheaders = [('User-agent', self.user_agent)]\n\n        if metric:\n            url = self.base_url + '?w={0}&u=c'.format(self.woeid)\n        else:\n            url = self.base_url + '?w={0}'.format(self.woeid)\n\n        return etree.parse(\n            self._opener.open(url)\n        ).getroot()[0]", "response": "Returns the XML element of the RSS feed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_text(self, element_name, namespace=''):\n        try:\n            text = self._channel.find('.//' + namespace + element_name).text\n        except AttributeError:\n            raise Exception(\n                'Element, {0} not found in RSS feed'.format(element_name)\n            )\n\n        return text", "response": "Returns the text of the specified element in the specified namespace of the RSS feed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the attributes of the specified element_name in the specified namespace of the RSS feed.", "response": "def _parse_attributes(self, element_name, package_class, namespace=''):\n        \"\"\"\n        Returns an instance of the package_class instantiated with a\n        dictionary of the attributes from element_name in the specified\n        namespace of the RSS feed.\n        \"\"\"\n        return package_class(\n            self._channel.find(\n                './/{0}{1}'.format(namespace, element_name)\n            ).attrib\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_image(self):\n        image = {\n            'title': self._channel.find('./image/title').text,\n            'width': int(self._channel.find('./image/width').text),\n            'height': int(self._channel.find('./image/height').text),\n            'link': self._channel.find('./image/link').text,\n            'url': self._channel.find('./image/url').text\n        }\n\n        return Image(image)", "response": "Parses the image element and returns an instance of the image. Image class for the RSS feed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the last build date of the RSS feed as datetime. datetime object. Returned datetime is not time - zone aware.", "response": "def _parse_last_build_date(self):\n        \"\"\"\n        Returns the last build date of the RSS feed as datetime.datetime\n        object. Returned datetime is not time-zone aware\n        \"\"\"\n        date = self._channel.find('lastBuildDate').text\n        date = parser.parse(date, ignoretz=True)\n        return date"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef forward_tcp(self, host, port):\n\n        return self.transport.open_channel(\n            'direct-tcpip',\n            (host, port),\n            self.transport.getpeername()\n        )", "response": "Open a connection to host : port via an ssh tunnel."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsplitting a string into its component parts and return the host and port.", "response": "def _split_hostport(self, hostport, default_port=None):\n        \"\"\"Split a string in the format of '<host>:<port>' into it's component parts\n\n        default_port will be used if a port is not included in the string\n\n        Args:\n            str ('<host>' or '<host>:<port>'): A string to split into it's parts\n\n        Returns:\n            two item tuple: (host, port)\n\n        Raises:\n            ValueError: The string was in an invalid element\n        \"\"\"\n\n        try:\n            (host, port) = hostport.split(':', 1)\n        except ValueError:  # no colon in the string so make our own port\n            host = hostport\n\n            if default_port is None:\n                raise ValueError('No port found in hostport, and default_port not provided.')\n\n            port = default_port\n\n        try:\n            port = int(port)\n            if port < 1 or port > 65535:\n                raise ValueError()\n        except ValueError:\n            raise ValueError(\"{0} is not a valid TCP port\".format(port))\n\n        return (host, port)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _endpoint_to_target(self, endpoint):\n        parsed = urlparse.urlparse(endpoint)\n        scheme = parsed[0]\n        hostport = parsed[1]\n\n        if 'unix' in scheme:\n            return (None, None, unquote(hostport))\n\n        if scheme == 'https':\n            target_port = 443\n        else:\n            target_port = 80\n\n        (target_host, target_port) = self._split_hostport(hostport, default_port=target_port)\n        return (target_host, target_port, None)", "response": "Convert an endpoint into a host port or path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_proxy_info(self, _=None):\n        # parse the fleet endpoint url, to establish a tunnel to that host\n        (target_host, target_port, target_path) = self._endpoint_to_target(self._endpoint)\n\n        # implement the proxy_info interface from httplib which requires\n        # that we accept a scheme, and return a ProxyInfo object\n        # we do :P\n        # This is called once per request, so we keep this here\n        # so that we can keep one ssh connection open, and allocate\n        # new channels as needed per-request\n        sock = None\n\n        if target_path:\n            sock = self._ssh_tunnel.forward_unix(path=target_path)\n        else:\n            sock = self._ssh_tunnel.forward_tcp(target_host, port=target_port)\n\n        # Return a ProxyInfo class with this socket\n        return SSHTunnelProxyInfo(sock=sock)", "response": "Generate a ProxyInfo class from a connected SSH transport."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a single request to the fleet API endpoint and return the response.", "response": "def _single_request(self, method, *args, **kwargs):\n        \"\"\"Make a single request to the fleet API endpoint\n\n        Args:\n            method (str): A dot delimited string indicating the method to call.  Example: 'Machines.List'\n            *args: Passed directly to the method being called.\n            **kwargs: Passed directly to the method being called.\n\n        Returns:\n            dict: The response from the method called.\n\n        Raises:\n            fleet.v1.errors.APIError: Fleet returned a response code >= 400\n        \"\"\"\n\n        # The auto generated client binding require instantiating each object you want to call a method on\n        # For example to make a request to /machines for the list of machines you would do:\n        # self._service.Machines().List(**kwargs)\n        # This code iterates through the tokens in `method` and instantiates each object\n        # Passing the `*args` and `**kwargs` to the final method listed\n\n        # Start here\n        _method = self._service\n\n        # iterate over each token in the requested method\n        for item in method.split('.'):\n\n            # if it's the end of the line, pass our argument\n            if method.endswith(item):\n                _method = getattr(_method, item)(*args, **kwargs)\n            else:\n                # otherwise, just create an instance and move on\n                _method = getattr(_method, item)()\n\n        # Discovered endpoints look like r'$ENDPOINT/path/to/method' which isn't a valid URI\n        # Per the fleet API documentation:\n            # \"Note that this discovery document intentionally ships with an unusable rootUrl;\n            # clients must initialize this as appropriate.\"\n\n        # So we follow the documentation, and replace the token with our actual endpoint\n        _method.uri = _method.uri.replace('$ENDPOINT', self._endpoint)\n\n        # Execute the method and return it's output directly\n        try:\n            return _method.execute(http=self._http)\n        except googleapiclient.errors.HttpError as exc:\n            response = json.loads(exc.content.decode('utf-8'))['error']\n\n            raise APIError(code=response['code'], message=response['message'], http_error=exc)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _request(self, method, *args, **kwargs):\n\n        # This is set to False and not None so that the while loop below will execute at least once\n        next_page_token = False\n\n        while next_page_token is not None:\n            # If bool(next_page_token), then include it in the request\n            # We do this so we don't pass it in the initial request as we set it to False above\n            if next_page_token:\n                kwargs['nextPageToken'] = next_page_token\n\n            # Make the request\n            response = self._single_request(method, *args, **kwargs)\n\n            # If there is a token for another page in the response, capture it for the next loop iteration\n            # If not, we set it to None so that the loop will terminate\n            next_page_token = response.get('nextPageToken', None)\n\n            # Return the current response\n            yield response", "response": "Make a request to the API and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new Unit in the cluster", "response": "def create_unit(self, name, unit):\n        \"\"\"Create a new Unit in the cluster\n\n        Create and modify Unit entities to communicate to fleet the desired state of the cluster.\n        This simply declares what should be happening; the backend system still has to react to\n        the changes in this desired state. The actual state of the system is communicated with\n        UnitState entities.\n\n\n        Args:\n            name (str): The name of the unit to create\n            unit (Unit): The unit to submit to fleet\n\n        Returns:\n            Unit: The unit that was created\n\n        Raises:\n            fleet.v1.errors.APIError: Fleet returned a response code >= 400\n\n        \"\"\"\n\n        self._single_request('Units.Set', unitName=name, body={\n            'desiredState': unit.desiredState,\n            'options': unit.options\n        })\n\n        return self.get_unit(name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the desired state of a unit running in the cluster.", "response": "def set_unit_desired_state(self, unit, desired_state):\n        \"\"\"Update the desired state of a unit running in the cluster\n\n        Args:\n            unit (str, Unit): The Unit, or name of the unit to update\n\n            desired_state: State the user wishes the Unit to be in\n                          (\"inactive\", \"loaded\", or \"launched\")\n        Returns:\n            Unit: The unit that was updated\n\n        Raises:\n            fleet.v1.errors.APIError: Fleet returned a response code >= 400\n            ValueError: An invalid value was provided for ``desired_state``\n\n        \"\"\"\n\n        if desired_state not in self._STATES:\n            raise ValueError('state must be one of: {0}'.format(\n                self._STATES\n            ))\n\n        # if we are given an object, grab it's name property\n        # otherwise, convert to unicode\n        if isinstance(unit, Unit):\n            unit = unit.name\n        else:\n            unit = str(unit)\n\n        self._single_request('Units.Set', unitName=unit, body={\n            'desiredState': desired_state\n        })\n\n        return self.get_unit(unit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes a unit from the cluster", "response": "def destroy_unit(self, unit):\n        \"\"\"Delete a unit from the cluster\n\n        Args:\n            unit (str, Unit): The Unit, or name of the unit to delete\n\n        Returns:\n            True: The unit was deleted\n\n        Raises:\n            fleet.v1.errors.APIError: Fleet returned a response code >= 400\n\n        \"\"\"\n\n        # if we are given an object, grab it's name property\n        # otherwise, convert to unicode\n        if isinstance(unit, Unit):\n            unit = unit.name\n        else:\n            unit = str(unit)\n\n        self._single_request('Units.Delete', unitName=unit)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_units(self):\n        for page in self._request('Units.List'):\n            for unit in page.get('units', []):\n                yield Unit(client=self, data=unit)", "response": "Return the current list of the Units in the fleet cluster"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_unit(self, name):\n        return Unit(client=self, data=self._single_request('Units.Get', unitName=name))", "response": "Retreive a specifi unit from the fleet cluster by name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_unit_states(self, machine_id=None, unit_name=None):\n        for page in self._request('UnitState.List', machineID=machine_id, unitName=unit_name):\n            for state in page.get('states', []):\n                yield UnitState(data=state)", "response": "Return the current UnitState for the given machine and unit"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a list of machines in the fleet cluster", "response": "def list_machines(self):\n        \"\"\"Retrieve a list of machines in the fleet cluster\n\n        Yields:\n            Machine: The next machine in the cluster\n\n        Raises:\n            fleet.v1.errors.APIError: Fleet returned a response code >= 400\n\n        \"\"\"\n        # loop through each page of results\n        for page in self._request('Machines.List'):\n            # return each machine in the current page\n            for machine in page.get('machines', []):\n                yield Machine(data=machine)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting value from one base to another.", "response": "def convert(cls, value, from_base, to_base):\n        \"\"\"\n        Convert value from a base to a base.\n\n        :param value: the value to convert\n        :type value: sequence of int\n        :param int from_base: base of value\n        :param int to_base: base of result\n        :returns: the conversion result\n        :rtype: list of int\n        :raises ConvertError: if from_base is less than 2\n        :raises ConvertError: if to_base is less than 2\n        :raises ConvertError: if elements in value outside bounds\n\n        Preconditions:\n          * all integers in value must be no less than 0\n          * from_base, to_base must be at least 2\n\n        Complexity: O(len(value))\n        \"\"\"\n        return cls.convert_from_int(\n           cls.convert_to_int(value, from_base),\n           to_base\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the value to an integer.", "response": "def convert_to_int(value, from_base):\n        \"\"\"\n        Convert value to an int.\n\n        :param value: the value to convert\n        :type value: sequence of int\n        :param int from_base: base of value\n        :returns: the conversion result\n        :rtype: int\n        :raises ConvertError: if from_base is less than 2\n        :raises ConvertError: if elements in value outside bounds\n\n        Preconditions:\n          * all integers in value must be at least 0\n          * all integers in value must be less than from_base\n          * from_base must be at least 2\n\n        Complexity: O(len(value))\n        \"\"\"\n        if from_base < 2:\n            raise BasesValueError(\n               from_base,\n               \"from_base\",\n               \"must be greater than 2\"\n            )\n\n        if any(x < 0 or x >= from_base for x in value):\n            raise BasesValueError(\n               value,\n               \"value\",\n               \"elements must be at least 0 and less than %s\" % from_base\n            )\n        return reduce(lambda x, y: x * from_base + y, value, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_from_int(value, to_base):\n        if value < 0:\n            raise BasesValueError(value, \"value\", \"must be at least 0\")\n\n        if to_base < 2:\n            raise BasesValueError(to_base, \"to_base\", \"must be at least 2\")\n\n        result = []\n        while value != 0:\n            (value, rem) = divmod(value, to_base)\n            result.append(rem)\n        result.reverse()\n        return result", "response": "Converts an integer value to a base."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef carry_in(value, carry, base):\n        if base < 2:\n            raise BasesValueError(base, \"base\", \"must be at least 2\")\n\n        if any(x < 0 or x >= base for x in value):\n            raise BasesValueError(\n               value,\n               \"value\",\n               \"elements must be at least 0 and less than %s\" % base\n            )\n\n        if carry < 0 or carry >= base:\n            raise BasesValueError(\n               carry,\n               \"carry\",\n               \"carry must be less than %s\" % base\n            )\n\n        result = []\n        for val in reversed(value):\n            (carry, new_val) = divmod(val + carry, base)\n            result.append(new_val)\n\n        return (carry, list(reversed(result)))", "response": "Add a carry digit to a number represented by value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_key(self):\n        print(\"Creating key. Please input the following options:\")\n        name = input(\"Key name (optional): \")\n        print(\"To make this key more secure, you should restrict the IP addresses that can use it. \")\n        print(\"To use with all IPs, leave blank or use 0.0.0.0/0.\")\n        print(\"To use with a single IP, append '/32', such as 207.39.29.22/32. \")\n        print(\"See this reference on CIDR blocks: http://software77.net/cidr-101.html\")\n        cidr = input(\"CIDR (optional): \")\n        key = self._curl_bitmex(\"/apiKey\",\n                                postdict={\"name\": name, \"cidr\": cidr, \"enabled\": True})\n\n        print(\"Key created. Details:\\n\")\n        print(\"API Key:    \" + key[\"id\"])\n        print(\"Secret:     \" + key[\"secret\"])\n        print(\"\\nSafeguard your secret key! If somebody gets a hold of your API key and secret,\")\n        print(\"your account can be taken over completely.\")\n        print(\"\\nKey generation complete.\")", "response": "Create an API key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist your API Keys.", "response": "def list_keys(self):\n        \"\"\"List your API Keys.\"\"\"\n        keys = self._curl_bitmex(\"/apiKey/\")\n        print(json.dumps(keys, sort_keys=True, indent=4))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enable_key(self):\n        print(\"This command will enable a disabled key.\")\n        apiKeyID = input(\"API Key ID: \")\n        try:\n            key = self._curl_bitmex(\"/apiKey/enable\",\n                                    postdict={\"apiKeyID\": apiKeyID})\n            print(\"Key with ID %s enabled.\" % key[\"id\"])\n        except:\n            print(\"Unable to enable key, please try again.\")\n            self.enable_key()", "response": "Enable an existing API Key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisables an existing API Key.", "response": "def disable_key(self):\n        \"\"\"Disable an existing API Key.\"\"\"\n        print(\"This command will disable a enabled key.\")\n        apiKeyID = input(\"API Key ID: \")\n        try:\n            key = self._curl_bitmex(\"/apiKey/disable\",\n                                    postdict={\"apiKeyID\": apiKeyID})\n            print(\"Key with ID %s disabled.\" % key[\"id\"])\n        except:\n            print(\"Unable to disable key, please try again.\")\n            self.disable_key()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes an existing API Key.", "response": "def delete_key(self):\n        \"\"\"Delete an existing API Key.\"\"\"\n        print(\"This command will delete an API key.\")\n        apiKeyID = input(\"API Key ID: \")\n        try:\n            self._curl_bitmex(\"/apiKey/\",\n                              postdict={\"apiKeyID\": apiKeyID}, verb='DELETE')\n            print(\"Key with ID %s disabled.\" % apiKeyID)\n        except:\n            print(\"Unable to delete key, please try again.\")\n            self.delete_key()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the next Type in this list.", "response": "def get_next_type(self):\n        \"\"\"Gets the next Type in this list.\n\n        return: (osid.type.Type) - the next Type in this list. The\n                has_next() method should be used to test that a next\n                Type is available before calling this method.\n        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        try:\n            next_object = next(self)\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the data from a pre existing data file.", "response": "def load(self, filename=None, refresh=False):\n        \"\"\"\n        Try to load the data from a pre existing data file if it exists.\n        If the data file does not exist, refresh the data and save it in\n        the data file for future use.\n        The data file is a json file.\n\n        :param filename: The filename to save or fetch the data from.\n        :param refresh:  Whether to force refresh the data or not\n        \"\"\"\n        filename = filename or self.data_file()\n        dirname = os.path.dirname(filename)\n\n        if refresh is False:\n            try:\n                data = None\n                with open(filename) as fp:\n                    data = json.load(fp)\n                self.clear()\n                self.update(data)\n                return\n            except (ValueError, IOError):\n                # Refresh data if reading gave errors\n                pass\n\n        data = self.refresh()\n        self.clear()\n        self.update(data)\n\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        with open(filename, 'w') as fp:\n            json.dump(data, fp,\n                      sort_keys=True,\n                      indent=2,\n                      separators=(',', ': '))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the request using the _url and converts it into a BeautifulSoup object.", "response": "def request(self, *args, **kwargs):\n        \"\"\"\n        Gets the request using the `_url` and converts it into a\n        beautiful soup object.\n\n        :param args:            The args to pass on to `requests`.\n        :param kwargs:          The kwargs to pass on to `requests`.\n        \"\"\"\n        response = requests.request(*args, **kwargs)\n        return BeautifulSoup.BeautifulSoup(response.text, \"html.parser\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_closest(self, color):\n        # Find distance between colors and find name based on closest color\n        rgb = sRGBColor(*color)\n        lab = convert_color(rgb, LabColor, target_illuminant='D65')\n        min_diff = float(\"inf\")\n        min_name, min_color = \"\", ()\n        for known_name, known_color in self.items():\n            known_rgb = sRGBColor(*known_color)\n            known_lab = convert_color(known_rgb, LabColor,\n                                      target_illuminant='D65')\n            diff = delta_e_cie1976(lab, known_lab)\n            if min_diff > diff:\n                min_diff = diff\n                min_name = known_name\n                min_color = known_color\n        return min_name, min_color", "response": "Find the closest color in the system to the given rgb values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_asset_lookup_session(self):\n        if not self.supports_asset_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetLookupSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the asset lookup service."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_asset_lookup_session_for_repository(self, repository_id):\n        if not self.supports_asset_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssetLookupSession(repository_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the asset lookup service for the given repository."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_asset_query_session(self):\n        if not self.supports_asset_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetQuerySession(runtime=self._runtime)", "response": "Gets an asset query session."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an asset query session for the given repository.", "response": "def get_asset_query_session_for_repository(self, repository_id):\n        \"\"\"Gets an asset query session for the given repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        return: (osid.repository.AssetQuerySession) - an\n                ``AssetQuerySession``\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_query()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_query()`` and ``supports_visible_federation()``\n        are ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssetQuerySession(repository_id, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting an asset search session.", "response": "def get_asset_search_session(self):\n        \"\"\"Gets an asset search session.\n\n        return: (osid.repository.AssetSearchSession) - an\n                ``AssetSearchSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_search()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_search()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_search():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetSearchSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the notification session for notifications pertaining to asset changes.", "response": "def get_asset_notification_session(self, asset_receiver):\n        \"\"\"Gets the notification session for notifications pertaining to asset changes.\n\n        arg:    asset_receiver (osid.repository.AssetReceiver): the\n                notification callback\n        return: (osid.repository.AssetNotificationSession) - an\n                ``AssetNotificationSession``\n        raise:  NullArgument - ``asset_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_notification()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_notification()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_notification():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetNotificationSession(runtime=self._runtime, receiver=asset_receiver)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the asset notification session for the given repository.", "response": "def get_asset_notification_session_for_repository(self, asset_receiver, repository_id):\n        \"\"\"Gets the asset notification session for the given repository.\n\n        arg:    asset_receiver (osid.repository.AssetReceiver): the\n                notification callback\n        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        return: (osid.repository.AssetNotificationSession) - an\n                ``AssetNotificationSession``\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``asset_receiver`` or ``repository_id``\n                is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_notification()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_notfication()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_notification():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssetNotificationSession(repository_id, runtime=self._runtime, receiver=asset_receiver)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the session for retrieving asset to repository mappings.", "response": "def get_asset_repository_session(self):\n        \"\"\"Gets the session for retrieving asset to repository mappings.\n\n        return: (osid.repository.AssetRepositorySession) - an\n                ``AssetRepositorySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_repository()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_repository()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_repository():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetRepositorySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the session for assigning asset to repository mappings.", "response": "def get_asset_repository_assignment_session(self):\n        \"\"\"Gets the session for assigning asset to repository mappings.\n\n        return: (osid.repository.AssetRepositoryAssignmentSession) - an\n                ``AssetRepositoryAsignmentSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_asset_repository_assignment()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_repository_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_repository_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetRepositoryAssignmentSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_asset_composition_session(self):\n        if not self.supports_asset_composition():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetCompositionSession(runtime=self._runtime)", "response": "Gets the session for retrieving asset compositions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_composition_query_session(self):\n        if not self.supports_composition_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CompositionQuerySession(runtime=self._runtime)", "response": "Gets a composition query session."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_composition_query_session_for_repository(self, repository_id):\n        if not self.supports_composition_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.CompositionQuerySession(repository_id, runtime=self._runtime)", "response": "Gets a composition query session for the given repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_composition_search_session(self):\n        if not self.supports_composition_search():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CompositionSearchSession(runtime=self._runtime)", "response": "Gets a composition search session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_composition_search_session_for_repository(self, repository_id):\n        if not self.supports_composition_search():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.CompositionSearchSession(repository_id, runtime=self._runtime)", "response": "Gets a composition search session for the given repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a composition administration session for creating updating and deleting compositions.", "response": "def get_composition_admin_session(self):\n        \"\"\"Gets a composition administration session for creating, updating and deleting compositions.\n\n        return: (osid.repository.CompositionAdminSession) - a\n                ``CompositionAdminSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_composition_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_composition_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CompositionAdminSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the repository lookup session.", "response": "def get_repository_lookup_session(self):\n        \"\"\"Gets the repository lookup session.\n\n        return: (osid.repository.RepositoryLookupSession) - a\n                ``RepositoryLookupSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_lookup()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_repository_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_repository_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.RepositoryLookupSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the repository query session.", "response": "def get_repository_query_session(self):\n        \"\"\"Gets the repository query session.\n\n        return: (osid.repository.RepositoryQuerySession) - a\n                ``RepositoryQuerySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_query()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_repository_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_repository_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.RepositoryQuerySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the repository administrative session for creating updating and deleting repositories.", "response": "def get_repository_admin_session(self):\n        \"\"\"Gets the repository administrative session for creating, updating and deleteing repositories.\n\n        return: (osid.repository.RepositoryAdminSession) - a\n                ``RepositoryAdminSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_repository_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_repository_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.RepositoryAdminSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the repository hierarchy traversal session.", "response": "def get_repository_hierarchy_session(self):\n        \"\"\"Gets the repository hierarchy traversal session.\n\n        return: (osid.repository.RepositoryHierarchySession) - ``a\n                RepositoryHierarchySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_hierarchy()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_repository_hierarchy()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_repository_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.RepositoryHierarchySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_repository_hierarchy_design_session(self):\n        if not self.supports_repository_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.RepositoryHierarchyDesignSession(runtime=self._runtime)", "response": "Gets the repository hierarchy design session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_asset_search_session_for_repository(self, repository_id, proxy):\n        if not self.supports_asset_search():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssetSearchSession(repository_id, proxy, self._runtime)", "response": "Gets an asset search session for the given repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an asset administration session for creating updating and deleting assets.", "response": "def get_asset_admin_session(self, proxy):\n        \"\"\"Gets an asset administration session for creating, updating and deleting assets.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.repository.AssetAdminSession) - an\n                ``AssetAdminSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_admin()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetAdminSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an asset administration session for the given repository.", "response": "def get_asset_admin_session_for_repository(self, repository_id, proxy):\n        \"\"\"Gets an asset administration session for the given repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.repository.AssetAdminSession) - an\n                ``AssetAdminSession``\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_admin()`` and ``supports_visible_federation()``\n        are ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssetAdminSession(repository_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the session for creating asset compositions designing the specified asset.", "response": "def get_asset_composition_design_session(self, proxy):\n        \"\"\"Gets the session for creating asset compositions.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.repository.AssetCompositionDesignSession) - an\n                ``AssetCompositionDesignSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_composition_design()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_asset_composition_design()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_asset_composition_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssetCompositionDesignSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_composition_lookup_session(self, proxy):\n        if not self.supports_composition_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CompositionLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the composition lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the OsidSession associated with the composition lookup service for the given repository.", "response": "def get_composition_lookup_session_for_repository(self, repository_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the composition lookup service for the given repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.repository.CompositionLookupSession) - the new\n                ``CompositionLookupSession``\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_lookup()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_composition_lookup()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_composition_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.CompositionLookupSession(repository_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_composition_admin_session_for_repository(self, repository_id, proxy):\n        if not self.supports_composition_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.CompositionAdminSession(repository_id, proxy, self._runtime)", "response": "Gets a composiiton administrative session for the given repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the composition to repository mappings.", "response": "def get_composition_repository_session(self, proxy):\n        \"\"\"Gets the session for retrieving composition to repository mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.repository.CompositionRepositorySession) - a\n                ``CompositionRepositorySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_repository()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_composition_repository()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_composition_repository():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CompositionRepositorySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_composition_repository_assignment_session(self, proxy):\n        if not self.supports_composition_repository_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CompositionRepositoryAssignmentSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the session for assigning composition to repository mappings."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the assessment Id associated with this learning objective.", "response": "def get_assessment_id(self):\n        \"\"\"Gets the assessment ``Id`` associated with this learning objective.\n\n        return: (osid.id.Id) - the assessment ``Id``\n        raise:  IllegalState - ``has_assessment()`` is ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['assessmentId']):\n            raise errors.IllegalState('this Objective has no assessment')\n        else:\n            return Id(self._my_map['assessmentId'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_knowledge_category_id(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['knowledgeCategoryId']):\n            raise errors.IllegalState('this Objective has no knowledge_category')\n        else:\n            return Id(self._my_map['knowledgeCategoryId'])", "response": "Gets the grade Id associated with the knowledge dimension."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the grade Id associated with the cognitive process.", "response": "def get_cognitive_process_id(self):\n        \"\"\"Gets the grade ``Id`` associated with the cognitive process.\n\n        return: (osid.id.Id) - the grade ``Id``\n        raise:  IllegalState - ``has_cognitive_process()`` is ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['cognitiveProcessId']):\n            raise errors.IllegalState('this Objective has no cognitive_process')\n        else:\n            return Id(self._my_map['cognitiveProcessId'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_map(self, record_types=None, **kwargs):\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        self._my_map['assignedObjectiveBankIds'] = [str(kwargs['objective_bank_id'])]\n        self._my_map['cognitiveProcessId'] = self._cognitive_process_default\n        self._my_map['assessmentId'] = self._assessment_default\n        self._my_map['knowledgeCategoryId'] = self._knowledge_category_default", "response": "Initialize the map of the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['assessment'])\n        metadata.update({'existing_id_values': self._my_map['assessmentId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for an assessment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the assessment. assessment_id", "response": "def set_assessment(self, assessment_id):\n        \"\"\"Sets the assessment.\n\n        arg:    assessment_id (osid.id.Id): the new assessment\n        raise:  InvalidArgument - ``assessment_id`` is invalid\n        raise:  NoAccess - ``assessment_id`` cannot be modified\n        raise:  NullArgument - ``assessment_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_assessment_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(assessment_id):\n            raise errors.InvalidArgument()\n        self._my_map['assessmentId'] = str(assessment_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear_assessment(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_assessment_metadata().is_read_only() or\n                self.get_assessment_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['assessmentId'] = self._assessment_default", "response": "Clears the assessment.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_knowledge_category_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['knowledge_category'])\n        metadata.update({'existing_id_values': self._my_map['knowledgeCategoryId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a knowledge category"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the knowledge category.", "response": "def set_knowledge_category(self, grade_id):\n        \"\"\"Sets the knowledge category.\n\n        arg:    grade_id (osid.id.Id): the new knowledge category\n        raise:  InvalidArgument - ``grade_id`` is invalid\n        raise:  NoAccess - ``grade_id`` cannot be modified\n        raise:  NullArgument - ``grade_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_knowledge_category_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(grade_id):\n            raise errors.InvalidArgument()\n        self._my_map['knowledgeCategoryId'] = str(grade_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear_knowledge_category(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_knowledge_category_metadata().is_read_only() or\n                self.get_knowledge_category_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['knowledgeCategoryId'] = self._knowledge_category_default", "response": "Clears the knowledge category."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the metadata for a cognitive process", "response": "def get_cognitive_process_metadata(self):\n        \"\"\"Gets the metadata for a cognitive process.\n\n        return: (osid.Metadata) - metadata for the cognitive process\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['cognitive_process'])\n        metadata.update({'existing_id_values': self._my_map['cognitiveProcessId']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the cognitive process.", "response": "def set_cognitive_process(self, grade_id):\n        \"\"\"Sets the cognitive process.\n\n        arg:    grade_id (osid.id.Id): the new cognitive process\n        raise:  InvalidArgument - ``grade_id`` is invalid\n        raise:  NoAccess - ``grade_id`` cannot be modified\n        raise:  NullArgument - ``grade_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_cognitive_process_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(grade_id):\n            raise errors.InvalidArgument()\n        self._my_map['cognitiveProcessId'] = str(grade_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_cognitive_process(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_cognitive_process_metadata().is_read_only() or\n                self.get_cognitive_process_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['cognitiveProcessId'] = self._cognitive_process_default", "response": "Clears the cognitive process."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objective_id(self):\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['objectiveId']):\n            raise errors.IllegalState('objective empty')\n        return Id(self._my_map['objectiveId'])", "response": "Gets the Id of the objective that this activity is related to."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the related objective.", "response": "def get_objective(self):\n        \"\"\"Gets the related objective.\n\n        return: (osid.learning.Objective) - the related objective\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['objectiveId']):\n            raise errors.IllegalState('objective empty')\n        mgr = self._get_provider_manager('LEARNING')\n        if not mgr.supports_objective_lookup():\n            raise errors.OperationFailed('Learning does not support Objective lookup')\n        lookup_session = mgr.get_objective_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_objective_bank_view()\n        return lookup_session.get_objective(self.get_objective_id())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assets(self):\n        # Implemented from template for osid.learning.Activity.get_assets_template\n        if not bool(self._my_map['assetIds']):\n            raise errors.IllegalState('no assetIds')\n        mgr = self._get_provider_manager('REPOSITORY')\n        if not mgr.supports_asset_lookup():\n            raise errors.OperationFailed('Repository does not support Asset lookup')\n\n        # What about the Proxy?\n        lookup_session = mgr.get_asset_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_repository_view()\n        return lookup_session.get_assets_by_ids(self.get_asset_ids())", "response": "Gets any assets associated with this activity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_courses(self):\n        # Implemented from template for osid.learning.Activity.get_assets_template\n        if not bool(self._my_map['courseIds']):\n            raise errors.IllegalState('no courseIds')\n        mgr = self._get_provider_manager('COURSE')\n        if not mgr.supports_course_lookup():\n            raise errors.OperationFailed('Course does not support Course lookup')\n\n        # What about the Proxy?\n        lookup_session = mgr.get_course_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_no_catalog_view()\n        return lookup_session.get_courses_by_ids(self.get_course_ids())", "response": "Gets any courses associated with this activity."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets any assessments associated with this activity.", "response": "def get_assessments(self):\n        \"\"\"Gets any assessments associated with this activity.\n\n        return: (osid.assessment.AssessmentList) - list of assessments\n        raise:  IllegalState - ``is_assessment_based_activity()`` is\n                ``false``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_assets_template\n        if not bool(self._my_map['assessmentIds']):\n            raise errors.IllegalState('no assessmentIds')\n        mgr = self._get_provider_manager('ASSESSMENT')\n        if not mgr.supports_assessment_lookup():\n            raise errors.OperationFailed('Assessment does not support Assessment lookup')\n\n        # What about the Proxy?\n        lookup_session = mgr.get_assessment_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bank_view()\n        return lookup_session.get_assessments_by_ids(self.get_assessment_ids())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the map of the object", "response": "def _init_map(self, record_types=None, **kwargs):\n        \"\"\"Initialize form map\"\"\"\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        self._my_map['assignedObjectiveBankIds'] = [str(kwargs['objective_bank_id'])]\n        self._my_map['courseIds'] = self._courses_default\n        self._my_map['assessmentIds'] = self._assessments_default\n        self._my_map['objectiveId'] = str(kwargs['objective_id'])\n        self._my_map['assetIds'] = self._assets_default"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the metadata for the assets.", "response": "def get_assets_metadata(self):\n        \"\"\"Gets the metadata for the assets.\n\n        return: (osid.Metadata) - metadata for the assets\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.get_assets_metadata_template\n        metadata = dict(self._mdata['assets'])\n        metadata.update({'existing_assets_values': self._my_map['assetIds']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_assets(self, asset_ids):\n        # Implemented from template for osid.learning.ActivityForm.set_assets_template\n        if not isinstance(asset_ids, list):\n            raise errors.InvalidArgument()\n        if self.get_assets_metadata().is_read_only():\n            raise errors.NoAccess()\n        idstr_list = []\n        for object_id in asset_ids:\n            if not self._is_valid_id(object_id):\n                raise errors.InvalidArgument()\n            idstr_list.append(str(object_id))\n        self._my_map['assetIds'] = idstr_list", "response": "Sets the assets.\n\n        arg:    asset_ids (osid.id.Id[]): the asset ``Ids``\n        raise:  InvalidArgument - ``asset_ids`` is invalid\n        raise:  NullArgument - ``asset_ids`` is ``null``\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the assets. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_assets(self):\n        \"\"\"Clears the assets.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.clear_assets_template\n        if (self.get_assets_metadata().is_read_only() or\n                self.get_assets_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['assetIds'] = self._assets_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_courses_metadata(self):\n        # Implemented from template for osid.learning.ActivityForm.get_assets_metadata_template\n        metadata = dict(self._mdata['courses'])\n        metadata.update({'existing_courses_values': self._my_map['courseIds']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the courses."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_courses(self, course_ids):\n        # Implemented from template for osid.learning.ActivityForm.set_assets_template\n        if not isinstance(course_ids, list):\n            raise errors.InvalidArgument()\n        if self.get_courses_metadata().is_read_only():\n            raise errors.NoAccess()\n        idstr_list = []\n        for object_id in course_ids:\n            if not self._is_valid_id(object_id):\n                raise errors.InvalidArgument()\n            idstr_list.append(str(object_id))\n        self._my_map['courseIds'] = idstr_list", "response": "Sets the courses.\n        arg :    course_ids ( osid. id. Id[] ) the courses."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears the courses. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_courses(self):\n        \"\"\"Clears the courses.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.clear_assets_template\n        if (self.get_courses_metadata().is_read_only() or\n                self.get_courses_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['courseIds'] = self._courses_default"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the metadata for the assessments.", "response": "def get_assessments_metadata(self):\n        \"\"\"Gets the metadata for the assessments.\n\n        return: (osid.Metadata) - metadata for the assessments\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.get_assets_metadata_template\n        metadata = dict(self._mdata['assessments'])\n        metadata.update({'existing_assessments_values': self._my_map['assessmentIds']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_assessments(self, assessment_ids):\n        # Implemented from template for osid.learning.ActivityForm.set_assets_template\n        if not isinstance(assessment_ids, list):\n            raise errors.InvalidArgument()\n        if self.get_assessments_metadata().is_read_only():\n            raise errors.NoAccess()\n        idstr_list = []\n        for object_id in assessment_ids:\n            if not self._is_valid_id(object_id):\n                raise errors.InvalidArgument()\n            idstr_list.append(str(object_id))\n        self._my_map['assessmentIds'] = idstr_list", "response": "Sets the assessments.\n\n        arg:    assessment_ids (osid.id.Id[]): the assessment ``Ids``\n        raise:  InvalidArgument - ``assessment_ids`` is invalid\n        raise:  NullArgument - ``assessment_ids`` is ``null``\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclear the assessments. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_assessments(self):\n        \"\"\"Clears the assessments.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.ActivityForm.clear_assets_template\n        if (self.get_assessments_metadata().is_read_only() or\n                self.get_assessments_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['assessmentIds'] = self._assessments_default"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_completion_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['completion'])\n        metadata.update({'existing_decimal_values': self._my_map['completion']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the completion percentage."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_completion(self, completion):\n        # Implemented from template for osid.grading.GradeSystemForm.set_lowest_numeric_score\n        if self.get_completion_metadata().is_read_only():\n            raise errors.NoAccess()\n        try:\n            completion = float(completion)\n        except ValueError:\n            raise errors.InvalidArgument()\n        if not self._is_valid_decimal(completion, self.get_completion_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['completion'] = completion", "response": "Sets the completion percentage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_completion(self):\n        # Implemented from template for osid.grading.GradeSystemForm.clear_lowest_numeric_score\n        if (self.get_completion_metadata().is_read_only() or\n                self.get_completion_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['completion'] = self._completion_default", "response": "Clears the completion.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear_level(self):\n        if (self.get_level_metadata().is_read_only() or\n                self.get_level_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['levelId'] = self._level_default\n        self._my_map['level'] = self._level_default", "response": "Clears the level.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the ObjectiveBank at this node.", "response": "def get_objective_bank(self):\n        \"\"\"Gets the ``ObjectiveBank`` at this node.\n\n        return: (osid.learning.ObjectiveBank) - the objective bank\n                represented by this node\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._lookup_session is None:\n            mgr = get_provider_manager('LEARNING', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_objective_bank_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_objective_bank(Id(self._my_map['id']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the parents of this objective bank.", "response": "def get_parent_objective_bank_nodes(self):\n        \"\"\"Gets the parents of this objective bank.\n\n        return: (osid.learning.ObjectiveBankNodeList) - the parents of\n                the ``id``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        parent_objective_bank_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_objective_bank_nodes.append(ObjectiveBankNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return ObjectiveBankNodeList(parent_objective_bank_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider ObjectiveSearchSession. get_objectives_by_search", "response": "def get_objectives_by_search(self, objective_query, objective_search):\n        \"\"\"Pass through to provider ObjectiveSearchSession.get_objectives_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_objectives_by_search(objective_query, objective_search)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider ActivitySearchSession. get_activities_by_search", "response": "def get_activities_by_search(self, activity_query, activitiesearch):\n        \"\"\"Pass through to provider ActivitySearchSession.get_activities_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_activities_by_search(activity_query, activitiesearch)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_proficiencies_for_resource_on_date(self, resource_id, from_, to):\n        # Implemented from azosid template for -\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source_on_date_template\n        if self._can('lookup'):\n            return self._provider_session.get_proficiencies_for_resource_on_date(resource_id, from_, to)\n        self._check_lookup_conditions()  # raises PermissionDenied\n        query = self._query_session.get_proficiency_query()\n        query.match_source_id(resource_id, match=True)\n        query.match_date(from_, to, match=True)\n        return self._try_harder(query)", "response": "Pass through to provider ProficiencyLookupSession. get_proficiencies_for_resource_on_date"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npasses through to provider ProficiencySearchSession. get_proficiencies_by_search", "response": "def get_proficiencies_by_search(self, proficiency_query, proficiency_search):\n        \"\"\"Pass through to provider ProficiencySearchSession.get_proficiencies_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_proficiencies_by_search(proficiency_query, proficiency_search)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the edges for the histogram bins to keep it the same for all nodes.", "response": "def compute_bin_edges(features, num_bins, edge_range, trim_outliers, trim_percentile, use_orig_distr=False):\n    \"Compute the edges for the histogram bins to keep it the same for all nodes.\"\n\n    if use_orig_distr:\n        print('Using original distribution (without histogram) to compute edge weights!')\n        edges=None\n        return edges\n\n    if edge_range is None:\n        if trim_outliers:\n            # percentiles_to_keep = [ trim_percentile, 1.0-trim_percentile] # [0.05, 0.95]\n            edges_of_edges = np.array([np.percentile(features, trim_percentile),\n                                       np.percentile(features, 100 - trim_percentile)])\n        else:\n            edges_of_edges = np.array([np.min(features), np.max(features)])\n    else:\n        edges_of_edges = edge_range\n\n    # Edges computed using data from all nodes, in order to establish correspondence\n    edges = np.linspace(edges_of_edges[0], edges_of_edges[1], num=num_bins, endpoint=True)\n\n    return edges"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting the histogram-distance weighted adjacency matrix. Parameters ---------- features : ndarray or str 1d array of scalar values, either provided directly as a 1d numpy array, or as a path to a file containing these values groups : ndarray or str Membership array of same length as `features`, each value specifying which group that particular node belongs to. Input can be either provided directly as a 1d numpy array,or as a path to a file containing these values. For example, if you have cortical thickness values for 1000 vertices (`features` is ndarray of length 1000), belonging to 100 patches, the groups array (of length 1000) could have numbers 1 to 100 (number of unique values) specifying which element belongs to which cortical patch. Grouping with numerical values (contiguous from 1 to num_patches) is strongly recommended for simplicity, but this could also be a list of strings of length p, in which case a tuple is returned, identifying which weight belongs to which pair of patches. weight_method : string or callable, optional Type of distance (or metric) to compute between the pair of histograms. It can either be a string identifying one of the weights implemented below, or a valid callable. If a string, it must be one of the following methods: - 'chebyshev' - 'chebyshev_neg' - 'chi_square' - 'correlate' - 'correlate_1' - 'cosine' - 'cosine_1' - 'cosine_2' - 'cosine_alt' - 'euclidean' - 'fidelity_based' - 'histogram_intersection' - 'histogram_intersection_1' - 'jensen_shannon' - 'kullback_leibler' - 'manhattan' - 'minowski' - 'noelle_1' - 'noelle_2' - 'noelle_3' - 'noelle_4' - 'noelle_5' - 'relative_bin_deviation' - 'relative_deviation' Note only the following are *metrics*: - 'manhattan' - 'minowski' - 'euclidean' - 'noelle_2' - 'noelle_4' - 'noelle_5' The following are *semi- or quasi-metrics*: - 'kullback_leibler' - 'jensen_shannon' - 'chi_square' - 'chebyshev' - 'cosine_1' - 'chebyshev_neg' - 'correlate_1' - 'histogram_intersection_1' - 'relative_deviation' - 'relative_bin_deviation' - 'noelle_1' - 'noelle_3' The following are classified to be similarity functions: - 'histogram_intersection' - 'correlate' - 'cosine' - 'cosine_2' - 'cosine_alt' - 'fidelity_based' *Default* choice: 'minowski'. The method can also be one of the following identifying metrics that operate on the original data directly - e.g. difference in the medians coming from the distributions of the pair of ROIs. - 'diff_medians' - 'diff_means' - 'diff_medians_abs' - 'diff_means_abs' Please note this can lead to adjacency matrices that may not be symmetric e.g. difference metric on two scalars is not symmetric). In this case, be sure to use the flag: allow_non_symmetric=True If weight_method is a callable, it must two accept two arrays as input and return one scalar as output. Example: ``diff_in_skew = lambda x, y: abs(scipy.stats.skew(x)-scipy.stats.skew(y))`` NOTE: this method will be applied to histograms (not the original distribution of features from group/ROI). In order to apply this callable directly on the original distribution (without trimming and histogram binning), use ``use_original_distribution=True``. num_bins : scalar, optional Number of bins to use when computing histogram within each patch/group. Note: 1) Please ensure same number of bins are used across different subjects 2) histogram shape can vary widely with number of bins (esp with fewer bins in the range of 3-20), and hence the features extracted based on them vary also. 3) It is recommended to study the impact of this parameter on the final results of the experiment. This could also be optimized within an inner cross-validation loop if desired. edge_range : tuple or None The range of edges within which to bin the given values. This can be helpful to ensure correspondence across multiple invocations of hiwenet (for different subjects), in terms of range across all bins as well as individual bin edges. Default is to automatically compute from the given values. Accepted format: - tuple of finite values: (range_min, range_max) - None, triggering automatic calculation (default) Notes : when controlling the ``edge_range``, it is not possible trim the tails (e.g. using the parameters ``trim_outliers`` and ``trim_percentile``) for the current set of features using its own range. trim_outliers : bool, optional Whether to trim a small percentile of outliers at the edges of feature range, when features are expected to contain extreme outliers (like 0 or eps or Inf). This is important to avoid numerical problems and also to stabilize the weight estimates. trim_percentile : float Small value specifying the percentile of outliers to trim. Default: 5 (5%). Must be in open interval (0, 100). use_original_distribution : bool, optional When using a user-defined callable, this flag 1) allows skipping of pre-processing (trimming outliers) and histogram construction, 2) enables the application of arbitrary callable (user-defined) on the original distributions coming from the two groups/ROIs/nodes directly. Example: ``diff_in_medians = lambda x, y: abs(np.median(x)-np.median(y))`` This option is valid only when weight_method is a valid callable, which must take two inputs (possibly of different lengths) and return a single scalar. relative_to_all : bool Flag to instruct the computation of a grand histogram (distribution pooled from values in all ROIs), and compute distances (based on distance specified by ``weight_method``) by from each ROI to the grand mean. This would result in only N distances for N ROIs, instead of the usual N*(N-1) pair-wise distances. asymmetric : bool Flag to identify resulting adjacency matrix is expected to be non-symmetric. Note: this results in twice the computation time! Default: False , for histogram metrics implemented here are symmetric. return_networkx_graph : bool, optional Specifies the need for a networkx graph populated with weights computed. Default: False. out_weights_path : str, optional Where to save the extracted weight matrix. If networkx output is returned, it would be saved in GraphML format. Default: nothing saved unless instructed. Returns ------- edge_weights : ndarray numpy 2d array of pair-wise edge-weights (of size: num_groups x num_groups), wherein num_groups is determined by the total number of unique values in `groups`. **Note**: - Only the upper triangular matrix is filled as the distance between node i and j would be the same as j and i. - The edge weights from the upper triangular matrix can easily be obtained by .. code-block:: python weights_array = edge_weights[ np.triu_indices_from(edge_weights, 1) ]", "response": "def extract(features, groups,\n            weight_method=default_weight_method,\n            num_bins=default_num_bins,\n            edge_range=default_edge_range,\n            trim_outliers=default_trim_behaviour,\n            trim_percentile=default_trim_percentile,\n            use_original_distribution=False,\n            relative_to_all=False,\n            asymmetric=False,\n            return_networkx_graph=default_return_networkx_graph,\n            out_weights_path=default_out_weights_path):\n    \"\"\"\n    Extracts the histogram-distance weighted adjacency matrix.\n\n    Parameters\n    ----------\n    features : ndarray or str\n        1d array of scalar values, either provided directly as a 1d numpy array,\n        or as a path to a file containing these values\n\n    groups : ndarray or str\n        Membership array of same length as `features`, each value specifying which group that particular node belongs to.\n        Input can be either provided directly as a 1d numpy array,or as a path to a file containing these values.\n\n        For example, if you have cortical thickness values for 1000 vertices (`features` is ndarray of length 1000),\n        belonging to 100 patches, the groups array (of length 1000) could  have numbers 1 to 100 (number of unique values)\n        specifying which element belongs to which cortical patch.\n\n        Grouping with numerical values (contiguous from 1 to num_patches) is strongly recommended for simplicity,\n        but this could also be a list of strings of length p, in which case a tuple is returned,\n        identifying which weight belongs to which pair of patches.\n\n    weight_method : string or callable, optional\n        Type of distance (or metric) to compute between the pair of histograms.\n        It can either be a string identifying one of the weights implemented below, or a valid callable.\n\n        If a string, it must be one of the following methods:\n\n        - 'chebyshev'\n        - 'chebyshev_neg'\n        - 'chi_square'\n        - 'correlate'\n        - 'correlate_1'\n        - 'cosine'\n        - 'cosine_1'\n        - 'cosine_2'\n        - 'cosine_alt'\n        - 'euclidean'\n        - 'fidelity_based'\n        - 'histogram_intersection'\n        - 'histogram_intersection_1'\n        - 'jensen_shannon'\n        - 'kullback_leibler'\n        - 'manhattan'\n        - 'minowski'\n        - 'noelle_1'\n        - 'noelle_2'\n        - 'noelle_3'\n        - 'noelle_4'\n        - 'noelle_5'\n        - 'relative_bin_deviation'\n        - 'relative_deviation'\n\n        Note only the following are *metrics*:\n\n        - 'manhattan'\n        - 'minowski'\n        - 'euclidean'\n        - 'noelle_2'\n        - 'noelle_4'\n        - 'noelle_5'\n\n        The following are *semi- or quasi-metrics*:\n\n        - 'kullback_leibler'\n        - 'jensen_shannon'\n        - 'chi_square'\n        - 'chebyshev'\n        - 'cosine_1'\n        - 'chebyshev_neg'\n        - 'correlate_1'\n        - 'histogram_intersection_1'\n        - 'relative_deviation'\n        - 'relative_bin_deviation'\n        - 'noelle_1'\n        - 'noelle_3'\n\n        The following are  classified to be similarity functions:\n\n        - 'histogram_intersection'\n        - 'correlate'\n        - 'cosine'\n        - 'cosine_2'\n        - 'cosine_alt'\n        - 'fidelity_based'\n\n        *Default* choice: 'minowski'.\n\n        The method can also be one of the following identifying metrics that operate on the original data directly -\n         e.g. difference in the medians coming from the distributions of the pair of ROIs.\n\n         - 'diff_medians'\n         - 'diff_means'\n         - 'diff_medians_abs'\n         - 'diff_means_abs'\n\n         Please note this can lead to adjacency matrices that may not be symmetric\n            e.g. difference metric on two scalars is not symmetric).\n            In this case, be sure to use the flag: allow_non_symmetric=True\n\n        If weight_method is a callable, it must two accept two arrays as input and return one scalar as output.\n            Example: ``diff_in_skew = lambda x, y: abs(scipy.stats.skew(x)-scipy.stats.skew(y))``\n            NOTE: this method will be applied to histograms (not the original distribution of features from group/ROI).\n            In order to apply this callable directly on the original distribution (without trimming and histogram binning),\n            use ``use_original_distribution=True``.\n\n    num_bins : scalar, optional\n        Number of bins to use when computing histogram within each patch/group.\n\n        Note:\n\n        1) Please ensure same number of bins are used across different subjects\n        2) histogram shape can vary widely with number of bins (esp with fewer bins in the range of 3-20), and hence the features extracted based on them vary also.\n        3) It is recommended to study the impact of this parameter on the final results of the experiment.\n\n        This could also be optimized within an inner cross-validation loop if desired.\n\n    edge_range : tuple or None\n        The range of edges within which to bin the given values.\n        This can be helpful to ensure correspondence across multiple invocations of hiwenet (for different subjects),\n        in terms of range across all bins as well as individual bin edges.\n        Default is to automatically compute from the given values.\n\n        Accepted format:\n\n            - tuple of finite values: (range_min, range_max)\n            - None, triggering automatic calculation (default)\n\n        Notes : when controlling the ``edge_range``, it is not possible trim the tails (e.g. using the parameters\n        ``trim_outliers`` and ``trim_percentile``) for the current set of features using its own range.\n\n    trim_outliers : bool, optional\n        Whether to trim a small percentile of outliers at the edges of feature range,\n        when features are expected to contain extreme outliers (like 0 or eps or Inf).\n        This is important to avoid numerical problems and also to stabilize the weight estimates.\n\n    trim_percentile : float\n        Small value specifying the percentile of outliers to trim.\n        Default: 5 (5%). Must be in open interval (0, 100).\n\n    use_original_distribution : bool, optional\n        When using a user-defined callable, this flag\n        1) allows skipping of pre-processing (trimming outliers) and histogram construction,\n        2) enables the application of arbitrary callable (user-defined) on the original distributions coming from the two groups/ROIs/nodes directly.\n\n        Example: ``diff_in_medians = lambda x, y: abs(np.median(x)-np.median(y))``\n\n        This option is valid only when weight_method is a valid callable,\n            which must take two inputs (possibly of different lengths) and return a single scalar.\n\n    relative_to_all : bool\n        Flag to instruct the computation of a grand histogram (distribution pooled from values in all ROIs),\n        and compute distances (based on distance specified by ``weight_method``) by from each ROI to the grand mean.\n        This would result in only N distances for N ROIs, instead of the usual N*(N-1) pair-wise distances.\n\n    asymmetric : bool\n        Flag to identify resulting adjacency matrix is expected to be non-symmetric.\n        Note: this results in twice the computation time!\n        Default: False , for histogram metrics implemented here are symmetric.\n\n    return_networkx_graph : bool, optional\n        Specifies the need for a networkx graph populated with weights computed. Default: False.\n\n    out_weights_path : str, optional\n        Where to save the extracted weight matrix. If networkx output is returned, it would be saved in GraphML format.\n        Default: nothing saved unless instructed.\n\n    Returns\n    -------\n    edge_weights : ndarray\n        numpy 2d array of pair-wise edge-weights (of size: num_groups x num_groups),\n        wherein num_groups is determined by the total number of unique values in `groups`.\n\n        **Note**:\n\n        - Only the upper triangular matrix is filled as the distance between node i and j would be the same as j and i.\n        - The edge weights from the upper triangular matrix can easily be obtained by\n\n        .. code-block:: python\n\n            weights_array = edge_weights[ np.triu_indices_from(edge_weights, 1) ]\n\n    \"\"\"\n\n    # parameter check\n    features, groups, num_bins, edge_range, group_ids, num_groups, num_links = check_params(\n            features, groups, num_bins, edge_range, trim_outliers, trim_percentile)\n\n    weight_func, use_orig_distr, non_symmetric = check_weight_method(weight_method,\n                                                                     use_original_distribution, asymmetric)\n\n    # using the same bin edges for all nodes/groups to ensure correspondence\n    # NOTE: common bin edges is important for the disances to be any meaningful\n    edges = compute_bin_edges(features, num_bins, edge_range,\n                              trim_outliers, trim_percentile, use_orig_distr)\n\n    # handling special\n    if relative_to_all:\n        result = non_pairwise.relative_to_all(features, groups, edges, weight_func,\n                                              use_orig_distr, group_ids, num_groups,\n                                              return_networkx_graph, out_weights_path)\n    else:\n        result = pairwise_extract(features, groups, edges, weight_func, use_orig_distr,\n                                  group_ids, num_groups, num_links,\n                                  non_symmetric, return_networkx_graph, out_weights_path)\n\n    # this can be a networkx graph or numpy array depending on request\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncoring function to compute the pair-wise histogram distance between all ROIs. Parameters ---------- features groups edges weight_func use_orig_distr group_ids num_groups num_links non_symmetric return_networkx_graph out_weights_path Returns ------- result : object A networkx graph or numpy array depending on request", "response": "def pairwise_extract(features, groups, edges, weight_func, use_orig_distr,\n                     group_ids, num_groups, num_links,\n                     non_symmetric, return_networkx_graph, out_weights_path):\n    \"\"\"\n    Core function to compute the pair-wise histogram distance between all ROIs.\n\n    Parameters\n    ----------\n    features\n    groups\n    edges\n    weight_func\n    use_orig_distr\n    group_ids\n    num_groups\n    num_links\n    non_symmetric\n    return_networkx_graph\n    out_weights_path\n\n    Returns\n    -------\n    result : object\n        A networkx graph or numpy array depending on request\n\n    \"\"\"\n\n    # the following will execute only when the pair-wise computation is requested.\n    if return_networkx_graph:\n        graph = nx.DiGraph() if non_symmetric else nx.Graph()\n        graph.add_nodes_from(group_ids)\n    else:\n        edge_weights = np.full([num_groups, num_groups], np.nan)\n\n    exceptions_list = list()\n    for src in range(num_groups):\n        # primitive progress indicator\n        if np.mod(src + 1, 5) == 0.0:\n            sys.stdout.write('.')\n\n        index1 = groups == group_ids[src]\n        hist_one = compute_histogram(features[index1], edges, use_orig_distr)\n\n        if non_symmetric:\n            target_list = range(num_groups)\n        else:\n            # when symmetric, only upper tri matrix is computed/filled\n            target_list = range(src + 1, num_groups, 1)\n\n        for dest in target_list:\n            # skipping edge between self\n            if src == dest:\n                continue\n\n            index2 = groups == group_ids[dest]\n            hist_two = compute_histogram(features[index2], edges, use_orig_distr)\n\n            try:\n                edge_value = weight_func(hist_one, hist_two)\n                if return_networkx_graph:\n                    graph.add_edge(group_ids[src], group_ids[dest], weight=float(edge_value))\n                else:\n                    edge_weights[src, dest] = edge_value\n            except (RuntimeError, RuntimeWarning) as runexc:\n                # placeholder to ignore some runtime errors (such as medpy's logger issue)\n                print(runexc)\n            except BaseException as exc:\n                # numerical instabilities can cause trouble for histogram distance calculations\n                traceback.print_exc()\n                exceptions_list.append(str(exc))\n                logging.warning('Unable to compute edge weight between '\n                                ' {} and {}. Skipping it.'.format(group_ids[src], group_ids[dest]))\n\n    error_thresh = 0.05\n    if len(exceptions_list) >= error_thresh * num_links:\n        print('All exceptions encountered so far:\\n {}'.format('\\n'.join(exceptions_list)))\n        raise ValueError('Weights for atleast {:.2f}% of edges could not be computed.'.format(error_thresh * 100))\n\n    sys.stdout.write('\\n')\n\n    if return_networkx_graph:\n        if out_weights_path is not None:\n            graph.write_graphml(out_weights_path)\n        return graph\n    else:\n        if out_weights_path is not None:\n            np.savetxt(out_weights_path, edge_weights, delimiter=',', fmt='%.9f')\n        return edge_weights"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nidentifying unique nodes and groups in a given membership specification.", "response": "def identify_groups(groups):\n    \"\"\"\n    To compute number of unique elements in a given membership specification.\n\n    Parameters\n    ----------\n    groups : numpy 1d array of length p, each value specifying which group that particular node belongs to.\n        For examlpe, if you have a cortical thickness values for 1000 vertices belonging to 100 patches,\n        this array could  have numbers 1 to 100 specifying which vertex belongs to which cortical patch.\n        Although grouping with numerical values (contiguous from 1 to num_patches) is strongly recommended for simplicity,\n        this could also be a list of strings of length p.\n\n    Returns\n    -------\n    group_ids : numpy array of values identifying the unique groups specified\n    num_groups : scalar value denoting the number of unique groups specified\n\n    \"\"\"\n\n    group_ids = np.unique(groups)\n    num_groups = len(group_ids)\n\n    if num_groups < 2:\n        raise ValueError('There must be atleast two nodes or groups in data, for pair-wise edge-weight calculations.')\n\n    return group_ids, num_groups"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_param_ranges(num_bins, num_groups, num_values, trim_outliers, trim_percentile):\n\n    if num_bins < minimum_num_bins:\n        raise ValueError('Too few bins! The number of bins must be >= 5')\n\n    if num_values < num_groups:\n        raise ValueError('Insufficient number of values in features (< number of nodes), or invalid membership!')\n\n    if trim_outliers:\n        if trim_percentile < 0 or trim_percentile >= 100:\n            raise ValueError('percentile of tail values to trim must be in the semi-open interval [0,1).')\n    elif num_values < 2:\n        raise ValueError('too few features to compute minimum and maximum')\n\n    return", "response": "Ensuring the parameters are in valid ranges."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef type_cast_params(num_bins, edge_range_spec, features, groups):\n\n    if isinstance(num_bins, str):\n        # possible when called from CLI\n        num_bins = np.float(num_bins)\n\n    # rounding it to ensure it is int\n    num_bins = np.rint(num_bins)\n\n    if np.isnan(num_bins) or np.isinf(num_bins):\n        raise ValueError('Invalid value for number of bins! Choose a natural number >= {}'.format(minimum_num_bins))\n\n    if edge_range_spec is None:\n        edge_range = edge_range_spec\n    elif isinstance(edge_range_spec, collections.Sequence):\n        if len(edge_range_spec) != 2:\n            raise ValueError('edge_range must be a tuple of two values: (min, max)')\n        if edge_range_spec[0] >= edge_range_spec[1]:\n            raise ValueError('edge_range : min {} is not less than the max {} !'.format(edge_range_spec[0], edge_range_spec[1]))\n        if not np.all(np.isfinite(edge_range_spec)):\n            raise ValueError('Infinite or NaN values in edge range : {}'.format(edge_range_spec))\n\n        # converting it to tuple to make it immutable\n        edge_range = tuple(edge_range_spec)\n    else:\n        raise ValueError('Invalid edge range! Must be a tuple of two values (min, max)')\n\n    if not isinstance(features, np.ndarray):\n        features = np.array(features)\n\n    if not isinstance(groups, np.ndarray):\n        groups = np.array(groups)\n\n    return num_bins, edge_range, features, groups", "response": "Casts inputs to required types."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a sequence of histogram density values that sum to 1. 0", "response": "def make_random_histogram(length=100, num_bins=10):\n    \"Returns a sequence of histogram density values that sum to 1.0\"\n\n    hist, bin_edges = np.histogram(np.random.random(length),\n                                   bins=num_bins, density=True)\n\n    # to ensure they sum to 1.0\n    hist = hist / sum(hist)\n\n    if len(hist) < 2:\n        raise ValueError('Invalid histogram')\n\n    return hist"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_weight_method(weight_method_spec,\n                        use_orig_distr=False,\n                        allow_non_symmetric=False):\n    \"Check if weight_method is recognized and implemented, or ensure it is callable.\"\n\n    if not isinstance(use_orig_distr, bool):\n        raise TypeError('use_original_distribution flag must be boolean!')\n\n    if not isinstance(allow_non_symmetric, bool):\n        raise TypeError('allow_non_symmetric flag must be boolean')\n\n    if isinstance(weight_method_spec, str):\n        weight_method_spec = weight_method_spec.lower()\n\n        if weight_method_spec in list_medpy_histogram_metrics:\n            from medpy.metric import histogram as medpy_hist_metrics\n            weight_func = getattr(medpy_hist_metrics, weight_method_spec)\n            if use_orig_distr:\n                warnings.warn('use_original_distribution must be False when using builtin histogram metrics, '\n                                 'which expect histograms as input - setting it to False.', HiwenetWarning)\n                use_orig_distr = False\n\n        elif weight_method_spec in metrics_on_original_features:\n            weight_func = getattr(more_metrics, weight_method_spec)\n            if not use_orig_distr:\n                warnings.warn('use_original_distribution must be True when using builtin non-histogram metrics, '\n                              'which expect original feature values in ROI/node as input '\n                              '- setting it to True.', HiwenetWarning)\n                use_orig_distr = True\n\n            if weight_method_spec in symmetric_metrics_on_original_features:\n                print('Chosen metric is symmetric. Ignoring asymmetric=False flag.')\n                allow_non_symmetric=False\n\n        else:\n            raise NotImplementedError('Chosen histogram distance/metric not implemented or invalid.')\n\n    elif callable(weight_method_spec):\n        # ensure 1) takes two ndarrays\n        try:\n            dummy_weight = weight_method_spec(make_random_histogram(), make_random_histogram())\n        except:\n            raise TypeError('Error applying given callable on two input arrays.\\n'\n                            '{} must accept two arrays and return a single scalar value!')\n        else:\n            # and 2) returns only one number\n            if not np.isscalar(dummy_weight):\n                raise TypeError('Given callable does not return a single scalar as output.')\n\n        weight_func = weight_method_spec\n    else:\n        raise ValueError('Supplied method to compute edge weight is not recognized:\\n'\n                         'must be a string identifying one of the implemented methods\\n{}'\n                         '\\n or a valid callable that accepts that two arrays '\n                         'and returns 1 scalar.'.format(list_medpy_histogram_metrics))\n\n    return weight_func, use_orig_distr, allow_non_symmetric", "response": "Check if weight_method is recognized and implemented or ensure it is callable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_params(features_spec, groups_spec, num_bins, edge_range_spec, trim_outliers, trim_percentile):\n\n    if isinstance(features_spec, str) and isinstance(groups_spec, str):\n        features, groups = read_features_and_groups(features_spec, groups_spec)\n    else:\n        features, groups = features_spec, groups_spec\n\n    num_bins, edge_range, features, groups = type_cast_params(num_bins, edge_range_spec, features, groups)\n    num_values = len(features)\n\n    # memberships\n    group_ids, num_groups = identify_groups(groups)\n    num_links = np.int64(num_groups * (num_groups - 1) / 2.0)\n\n    check_param_ranges(num_bins, num_groups, num_values, trim_outliers, trim_percentile)\n\n    return features, groups, num_bins, edge_range, group_ids, num_groups, num_links", "response": "Necessary check on values ranges and types."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_cli():\n    \"Command line interface to hiwenet.\"\n\n    features_path, groups_path, weight_method, num_bins, edge_range, \\\n    trim_outliers, trim_percentile, return_networkx_graph, out_weights_path = parse_args()\n\n    # TODO add the possibility to process multiple combinations of parameters: diff subjects, diff metrics\n    # for features_path to be a file containing multiple subjects (one/line)\n    # -w could take multiple values kldiv,histint,\n    # each line: input_features_path,out_weights_path\n\n    features, groups = read_features_and_groups(features_path, groups_path)\n\n    extract(features, groups, weight_method=weight_method, num_bins=num_bins,\n            edge_range=edge_range, trim_outliers=trim_outliers, trim_percentile=trim_percentile,\n            return_networkx_graph=return_networkx_graph, out_weights_path=out_weights_path)", "response": "Command line interface to hiwenet."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreader for data and groups", "response": "def read_features_and_groups(features_path, groups_path):\n    \"Reader for data and groups\"\n\n    try:\n        if not pexists(features_path):\n            raise ValueError('non-existent features file')\n\n        if not pexists(groups_path):\n            raise ValueError('non-existent groups file')\n\n        if isinstance(features_path, str):\n            features = np.genfromtxt(features_path, dtype=float)\n        else:\n            raise ValueError('features input must be a file path ')\n\n        if isinstance(groups_path, str):\n            groups = np.genfromtxt(groups_path, dtype=str)\n        else:\n            raise ValueError('groups input must be a file path ')\n\n    except:\n        raise IOError('error reading the specified features and/or groups.')\n\n    if len(features) != len(groups):\n        raise ValueError(\"lengths of features and groups do not match!\")\n\n    return features, groups"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parser():\n    \"Specifies the arguments and defaults, and returns the parser.\"\n\n    parser = argparse.ArgumentParser(prog=\"hiwenet\")\n\n    parser.add_argument(\"-f\", \"--in_features_path\", action=\"store\", dest=\"in_features_path\",\n                        required=True,\n                        help=\"Abs. path to file containing features for a given subject\")\n\n    parser.add_argument(\"-g\", \"--groups_path\", action=\"store\", dest=\"groups_path\",\n                        required=True,\n                        help=\"path to a file containing element-wise membership into groups/nodes/patches.\")\n\n    parser.add_argument(\"-w\", \"--weight_method\", action=\"store\", dest=\"weight_method\",\n                        default=default_weight_method, required=False,\n                        help=\"Method used to estimate the weight between the pair of nodes. Default : {}\".format(\n                            default_weight_method))\n\n    parser.add_argument(\"-o\", \"--out_weights_path\", action=\"store\", dest=\"out_weights_path\",\n                        default=default_out_weights_path, required=False,\n                        help=\"Where to save the extracted weight matrix. If networkx output is returned, it would be saved in GraphML format. Default: nothing saved.\")\n\n    parser.add_argument(\"-n\", \"--num_bins\", action=\"store\", dest=\"num_bins\",\n                        default=default_num_bins, required=False,\n                        help=\"Number of bins used to construct the histogram. Default : {}\".format(default_num_bins))\n\n    parser.add_argument(\"-r\", \"--edge_range\", action=\"store\", dest=\"edge_range\",\n                        default=default_edge_range, required=False,\n                        nargs = 2,\n                        help=\"The range of edges (two finite values) within which to bin the given values e.g. --edge_range 1 6 \"\n                             \"This can be helpful to ensure correspondence across multiple invocations of hiwenet (for different subjects),\"\n                             \" in terms of range across all bins as well as individual bin edges. \"\n                             \"Default : {}, to automatically compute from the given values.\".format(default_edge_range))\n\n    parser.add_argument(\"-t\", \"--trim_outliers\", action=\"store\", dest=\"trim_outliers\",\n                        default=default_trim_behaviour, required=False,\n                        help=\"Boolean flag indicating whether to trim the extreme/outlying values. Default True.\")\n\n    parser.add_argument(\"-p\", \"--trim_percentile\", action=\"store\", dest=\"trim_percentile\",\n                        default=default_trim_percentile, required=False,\n                        help=\"Small value specifying the percentile of outliers to trim. \"\n                             \"Default: {0}%% , must be in open interval (0, 100).\".format(default_trim_percentile))\n\n    parser.add_argument(\"-x\", \"--return_networkx_graph\", action=\"store\", dest=\"return_networkx_graph\",\n                        default=default_return_networkx_graph, required=False,\n                        help=\"Boolean flag indicating whether to return a networkx graph populated with weights computed. Default: False\")\n\n    return parser", "response": "Specifies the arguments and defaults and returns the parser."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_args():\n\n    parser = get_parser()\n\n    if len(sys.argv) < 2:\n        parser.print_help()\n        warnings.warn('Too few arguments!', UserWarning)\n        parser.exit(1)\n\n    # parsing\n    try:\n        params = parser.parse_args()\n    except Exception as exc:\n        print(exc)\n        raise ValueError('Unable to parse command-line arguments.')\n\n    in_features_path = os.path.abspath(params.in_features_path)\n    if not os.path.exists(in_features_path):\n        raise IOError(\"Given features file doesn't exist.\")\n\n    groups_path = os.path.abspath(params.groups_path)\n    if not os.path.exists(groups_path):\n        raise IOError(\"Given groups file doesn't exist.\")\n\n    return in_features_path, groups_path, params.weight_method, params.num_bins, params.edge_range, \\\n           params.trim_outliers, params.trim_percentile, params.return_networkx_graph, params.out_weights_path", "response": "Parser and validator for the cmd line args."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize an OpenAg - based project.", "response": "def _init(board, project_dir):\n    \"\"\"\n    Initialize an OpenAg-based project.\n    Internal function we use for both init and flash commands.\n    \"\"\"\n    project_dir = os.path.abspath(project_dir)\n\n    # Initialize the platformio project\n    pio_config_path = os.path.join(project_dir, \"platformio.ini\")\n    if not os.path.isfile(pio_config_path):\n        click.echo(\"Initializing PlatformIO project\")\n        with open(\"/dev/null\", \"wb\") as null:\n            try:\n                init = subprocess.Popen(\n                    [\"platformio\", \"init\", \"-b\", board], stdin=subprocess.PIPE,\n                    stdout=null, cwd=project_dir\n                )\n                init.communicate(\"y\\n\")\n            except OSError as e:\n                raise RuntimeError(\"PlatformIO is not installed\")\n        if init.returncode != 0:\n            raise RuntimeError(\n                \"Failed to initialize PlatformIO project\"\n            )\n    click.echo(\"OpenAg firmware project initialized!\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate code for this project and run it.", "response": "def _run(\n    categories, param_file, project_dir, plugin, target,\n    status_update_interval\n):\n    \"\"\"\n    Generate code for this project and run it.\n    Internal function we use for both run and flash commands.\n    \"\"\"\n    project_dir = os.path.abspath(project_dir)\n\n    # Make sure the project has been initialized\n    pio_config = os.path.join(project_dir, \"platformio.ini\")\n    if not os.path.isfile(pio_config):\n        raise click.ClickException(\n            \"Not an OpenAg firmware project. To initialize a new project \"\n            \"please use the `openag firmware init` command\"\n        )\n\n    # @TODO in future we should pass in module config files as a thing\n    # separate from the param file.\n    name, ext = os.path.splitext(param_file.name)\n    if ext == \".json\":\n        params = json.load(param_file)\n    elif ext in (\".yaml\", \".yml\"):\n        params = yaml.load(param_file)\n    else:\n        raise ValueError(\"Param file must be YAML or JSON\")\n\n    firmware_type_params = params.get(FIRMWARE_MODULE_TYPE, [])\n    firmware_params = params.get(FIRMWARE_MODULE, [])\n\n    firmware_types = [\n        FirmwareModuleType(record)\n        for record in firmware_type_params\n    ]\n    firmware = [\n        FirmwareModule(record)\n        for record in firmware_params\n    ]\n\n    # Check for working modules in the lib folder\n    # Do this second so project-local values overwrite values from the server\n    lib_path = os.path.join(project_dir, \"lib\")\n    for dir_name in os.listdir(lib_path):\n        dir_path = os.path.join(lib_path, dir_name)\n        if not os.path.isdir(dir_path):\n            continue\n        config_path = os.path.join(dir_path, \"module.json\")\n        if os.path.isfile(config_path):\n            with open(config_path) as f:\n                click.echo(\n                    \"Parsing firmware module type \\\"{}\\\" from lib \"\n                    \"folder\".format(dir_name)\n                )\n                doc = json.load(f)\n                if not doc.get(\"_id\"):\n                    # Patch in id if id isn't present\n                    doc[\"_id\"] = parent_dirname(config_path)\n                firmware_types.append(FirmwareModuleType(doc))\n\n    if len(firmware) == 0:\n        click.echo(\"Warning: no modules specified for the project\")\n\n    module_types = index_by_id(firmware_types)\n    modules = index_by_id(firmware)\n    # Synthesize the module and module type dicts\n    modules = synthesize_firmware_module_info(modules, module_types)\n    # Update the module inputs and outputs using the categories\n    modules = prune_unspecified_categories(modules, categories)\n\n    # Generate src.ino\n    src_dir = os.path.join(project_dir, \"src\")\n    src_file_path = os.path.join(src_dir, \"src.ino\")\n    # Load the plugins\n    plugin_fns = (load_plugin(plugin_name) for plugin_name in plugin)\n    # Run modules through each plugin\n    plugins = [plugin_fn(modules) for plugin_fn in plugin_fns]\n\n    # Generate the code\n    codegen = CodeGen(\n        modules=modules, plugins=plugins,\n        status_update_interval=status_update_interval\n    )\n    pio_ids = (dep[\"id\"] for dep in codegen.all_pio_dependencies())\n    for _id in pio_ids:\n        subprocess.call([\"platformio\", \"lib\", \"install\", str(_id)])\n    lib_dir = os.path.join(project_dir, \"lib\")\n    for dep in codegen.all_git_dependencies():\n        url = dep[\"url\"]\n        branch = dep.get(\"branch\", \"master\")\n        dep_folder_name = make_dir_name_from_url(url)\n        dep_folder = os.path.join(lib_dir, dep_folder_name)\n        if os.path.isdir(dep_folder):\n            click.echo('Updating \"{}\"'.format(dep_folder_name))\n            subprocess.call(\n                [\"git\", \"checkout\", \"--quiet\", branch], cwd=dep_folder)\n            subprocess.call([\"git\", \"pull\"], cwd=dep_folder)\n        else:\n            click.echo('Downloading \"{}\"'.format(dep_folder_name))\n            subprocess.call(\n                [\"git\", \"clone\", \"-b\", branch, url, dep_folder], cwd=lib_dir)\n    with open(src_file_path, \"w+\") as f:\n        codegen.write_to(f)\n\n    # Compile the generated code\n    command = [\"platformio\", \"run\"]\n    if target:\n        command.append(\"-t\")\n        command.append(target)\n    env = os.environ.copy()\n    build_flags = []\n    for c in categories:\n        build_flags.append(\"-DOPENAG_CATEGORY_{}\".format(c.upper()))\n    env[\"PLATFORMIO_BUILD_FLAGS\"] = \" \".join(build_flags)\n    if subprocess.call(command, cwd=project_dir, env=env):\n        raise click.ClickException(\"Compilation failed\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating code for this project and run it", "response": "def run(\n    categories, param_file, project_dir, plugin, target,\n    status_update_interval\n):\n    \"\"\" Generate code for this project and run it \"\"\"\n    return _run(\n        categories, param_file, project_dir, plugin, target,\n        status_update_interval\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun a single instance of this module.", "response": "def run_module(\n    ctx, arguments, project_dir, board, **kwargs\n):\n    \"\"\"\n    Run a single instance of this module. [ARGUMENTS] specifies a list of\n    implementation-specific arguments to the module (for example, configuring\n    Arduino pin numbers for the module).\n\n    Example:\n\n    \\b\n    openag firmware run_module -t upload 4\n\n    This command fetches module definitions from CouchDB. CouchDB must be\n    running on port 5984 and the firmware_module_type database populated with\n    appropriate type records for this command to work. Loading the default\n    fixture from openag_brain will populate a default set of\n    firmware_module_type records.\n    \"\"\"\n    # Read the module config\n    here = os.path.abspath(project_dir)\n    module_json_path = os.path.join(here, \"module.json\")\n    try:\n        with open(module_json_path) as f:\n            doc = json.load(f)\n            if not doc.get(\"_id\"):\n                # Patch in id if not present\n                doc[\"_id\"] = parent_dirname(module_json_path)\n            module_type = FirmwareModuleType(doc)\n    except IOError:\n        raise click.ClickException(\"No module.json file found\")\n\n    # Create the build directory\n    build_path = os.path.join(here, \"_build\")\n    if not os.path.isdir(build_path):\n        os.mkdir(build_path)\n    kwargs[\"project_dir\"] = build_path\n\n    # Initialize an openag project in the build directory\n    ctx.invoke(init, board=board, **kwargs)\n\n    # Link the source files into the lib directory\n    lib_path = os.path.join(build_path, \"lib\")\n    module_path = os.path.join(lib_path, \"module\")\n    if not os.path.isdir(module_path):\n        os.mkdir(module_path)\n    for file_name in os.listdir(here):\n        file_path = os.path.join(here, file_name)\n        if not os.path.isfile(file_path) or file_name.startswith(\".\"):\n            continue\n        source = \"../../../{}\".format(file_name)\n        link_name = os.path.join(module_path, file_name)\n        if os.path.isfile(link_name):\n            os.remove(link_name)\n        os.symlink(source, link_name)\n\n    # Parse the arguments based on the module type\n    real_args = []\n    for i in range(len(arguments)):\n        if i >= len(module_type[\"arguments\"]):\n            raise click.ClickException(\n                \"Too many module arguments specified. (Got {}, expected \"\n                \"{})\".format(len(arguments), len(module_type[\"arguments\"]))\n            )\n        val = arguments[i]\n        arg_info = module_type[\"arguments\"][i]\n        if arg_info[\"type\"] == \"int\":\n            val = int(val)\n        elif arg_info[\"type\"] == \"float\":\n            val = float(val)\n        elif arg_info[\"type\"] == \"bool\":\n            if val.lower() == \"true\":\n                val = True\n            elif val.lower() == \"false\":\n                val = False\n            else:\n                raise click.BadParameter(\n                    \"Argument number {} should be a boolean value \"\n                    '(\"true\" or \"false\")'.format(i)\n                )\n        real_args.append(val)\n\n    # Write the modules.json file\n    modules = {\n        FIRMWARE_MODULE: [\n            FirmwareModule({\n                \"_id\": \"module_1\",\n                \"type\": \"module\",\n                \"arguments\": list(real_args)\n            })\n        ]\n    }\n    modules_file = os.path.join(build_path, \"modules.json\")\n    with open(modules_file, \"w\") as f:\n        json.dump(modules, f)\n    with open(modules_file, \"r\") as f:\n        kwargs[\"param_file\"] = f\n        # Run the project\n        ctx.invoke(run, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flash(\n    categories, param_file, project_dir, plugin, target,\n    status_update_interval, board\n):\n    \"\"\"\n    Flashes firmware to device (init + run).\n    Initializes a pio project and runs the result, flashing it to the device.\n    \"\"\"\n    _init(board, project_dir)\n    _run(\n        categories, param_file, project_dir, plugin, target,\n        status_update_interval\n    )\n    print \"Done\"", "response": "Flash the firmware to the device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a plugin from plugin directory.", "response": "def load_plugin(plugin_name):\n    \"\"\"\n    Given a plugin name, load plugin cls from plugin directory.\n    Will throw an exception if no plugin can be found.\n    \"\"\"\n    plugin_cls = plugin_map.get(plugin_name, None)\n    if not plugin_cls:\n        try:\n            plugin_module_name, plugin_cls_name = plugin_name.split(\":\")\n            plugin_module = import_module(plugin_module_name)\n            plugin_cls = getattr(plugin_module, plugin_cls_name)\n        except ValueError:\n            raise click.ClickException(\n                '\"{}\" is not a valid plugin path'.format(plugin_name)\n            )\n        except ImportError:\n            raise click.ClickException(\n                '\"{}\" does not name a Python module'.format(\n                    plugin_module_name\n                )\n            )\n        except AttributeError:\n            raise click.ClickException(\n                'Module \"{}\" does not contain the class \"{}\"'.format(\n                    plugin_module_name, plugin_cls_name\n                )\n            )\n    return plugin_cls"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lengths_offsets(value):\n    values = []\n    for item in value.split(','):\n        item = int(item)\n        values.append(item)\n    return values", "response": "Split the given comma separated value to multiple integer values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open_pysam_file(fname, ftype):\n    try:\n        if ftype == 'bam':\n            fpysam = pysam.AlignmentFile(fname, 'rb')\n        elif ftype == 'fasta':\n            fpysam = pysam.FastaFile(fname)\n        yield fpysam\n    except:\n        raise\n    else:\n        fpysam.close()", "response": "Open a pysam file with pysam"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_bam_valid(bam_file):\n    try:\n        f = pysam.AlignmentFile(bam_file)\n    except ValueError:\n        raise\n    except:\n        raise\n    else:\n        f.close()\n\n    return True", "response": "Check if bam file is valid. Raises a ValueError if bam file is not valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bam_has_index(bam_file):\n    has_index = None\n    with pysam.AlignmentFile(bam_file, 'rb') as bam_fileobj:\n        try:\n            bam_fileobj.fetch(bam_fileobj.references[0])\n        except ValueError as err:\n            if err.message == 'fetch called on bamfile without index':\n                bam_fileobj.close()\n                has_index = False\n        else:\n            has_index = True\n    return has_index", "response": "Check if bam file has an index. Returns True or False."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if a fasta file is valid. Raises a ValueError if the file is not valid.", "response": "def is_fasta_valid(fasta_file):\n    \"\"\"Check if fasta file is valid. Raises a ValueError if pysam cannot read the file.\n\n    #TODO: pysam  does not differentiate between BAM and SAM\n    \"\"\"\n    try:\n        f = pysam.FastaFile(fasta_file)\n    except IOError:\n        raise\n    else:\n        f.close()\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first FASTA sequence from the given FASTA file.", "response": "def get_first_transcript_name(fasta_file):\n    \"\"\"Return the first FASTA sequence from the given FASTA file.\n\n    Keyword arguments:\n    fasta_file -- FASTA format file of the transcriptome\n\n    \"\"\"\n    with open_pysam_file(fname=fasta_file, ftype='fasta') as f:\n        transcript_name = f.references[0]\n    return transcript_name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_fasta_record(fasta_file, transcript_name):\n    with open_pysam_file(fname=fasta_file, ftype='fasta') as f:\n        sequence = f.fetch(transcript_name)\n    return {transcript_name: sequence}", "response": "Return a single transcript from a valid fasta file as a record"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_fasta_records(fasta, transcripts):\n    records = {}\n    f = pysam.FastaFile(fasta)\n    for transcript in transcripts:\n        try:\n            sequence, length = f.fetch(transcript), f.get_reference_length(transcript)\n        except KeyError:\n            msg = 'Transcript \"{}\" does not exist in transcriptome FASTA file'.format(transcript)\n            log.error(msg)\n            raise ArgumentError(msg)\n        records[transcript] = {'sequence': sequence, 'length': length}\n    f.close()\n    return records", "response": "Return list of transcript records from the given FASTA file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_three_frame_orfs(sequence, starts=None, stops=None):\n    if not starts:\n        starts = ['ATG']\n\n    if not stops:\n        stops = ['TAG', 'TGA', 'TAA']\n\n    # Find ORFs in 3 frames\n    orfs = []\n    for frame in range(3):\n        start_codon = None\n        orf = ''\n        for position in range(frame, len(sequence), 3):\n            codon = sequence[position:position + 3]\n            if codon in starts:\n                # We have found a start already, so add codon to orf and\n                # continue. This is an internal MET\n                if start_codon is not None:\n                    orf += codon\n                    continue\n\n                # New orf start\n                start_codon = position\n                orf = codon\n            else:\n                # if sequence starts with ATG, start_codon will be 0\n                if start_codon is None:\n                    # We haven't found a start codon yet\n                    continue\n                orf += codon\n                if codon in stops:\n                    # orfs[start_codon + 1] = orf\n                    orfs.append({'start': start_codon + 1, 'stop': position + 3, 'sequence': orf})\n\n                    # Reset\n                    start_codon = None\n                    orf = ''\n    return orfs", "response": "Return a list of ORFs in three frames for the given sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding the longest ORF from the given list of ORFs.", "response": "def get_longest_orf(orfs):\n    \"\"\"Find longest ORF from the given list of ORFs.\"\"\"\n    sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]\n    return sorted_orf"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_ribo_counts(counts, orf_start=None, orf_stop=None):\n    filtered_counts = dict.copy(counts)\n    for position in counts:\n        if orf_start and orf_stop:\n            # if only upstream and downstream reads are required, check if\n            # current position is upstream or downstream of the ORF start/stop\n            # if not, remove from counts\n            if (position > orf_start and position < orf_stop):\n                filtered_counts.pop(position)\n        elif orf_start:\n            # check if current position is upstream of ORF start. if not, remove\n            if position >= orf_start:\n                filtered_counts.pop(position)\n        elif orf_stop:\n            # check if current position is downstream of ORF stop. If not,\n            # remove\n            if position <= orf_stop:\n                filtered_counts.pop(position)\n\n    # calculate total reads for this transcript\n    total_reads = sum(sum(item.values()) for item in filtered_counts.values())\n    return filtered_counts, total_reads", "response": "Filter read counts and return only upstream of orf_start or downstream of orf_stop."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the position and total number of reads in the ribo file that aligns the given read lengths and offsets.", "response": "def get_ribo_counts(ribo_fileobj, transcript_name, read_lengths, read_offsets):\n    \"\"\"For each mapped read of the given transcript in the BAM file\n    (pysam AlignmentFile object), return the position (+1) and the\n    corresponding frame (1, 2 or 3) to which it aligns.\n\n    Keyword arguments:\n    ribo_fileobj -- file object - BAM file opened using pysam AlignmentFile\n    transcript_name -- Name of transcript to get counts for\n    read_length (optional) -- If provided, get counts only for reads of this length.\n\n    \"\"\"\n    read_counts = {}\n    total_reads = 0\n    for record in ribo_fileobj.fetch(transcript_name):\n        query_length = record.query_length\n        position_ref = record.pos + 1\n        for index, read_length in enumerate(read_lengths):\n            position = position_ref  # reset position\n            if read_length == 0 or read_length == query_length:\n                # if an offset is specified, increment position by that offset.\n                position += read_offsets[index]\n            else:\n                # ignore other reads/lengths\n                continue\n            total_reads += 1\n            try:\n                read_counts[position]\n            except KeyError:\n                read_counts[position] = {1: 0, 2: 0, 3: 0}\n\n            # calculate the frame of the read from position\n            rem = position % 3\n            if rem == 0:\n                read_counts[position][3] += 1\n            else:\n                read_counts[position][rem] += 1\n\n    log.debug('Total read counts: {}'.format(total_reads))\n    log.debug('RiboSeq read counts for transcript: {0}\\n{1}'.format(transcript_name, read_counts))\n    return read_counts, total_reads"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks required arguments of both riboplot and ribocount.", "response": "def check_required_arguments(ribo_file, transcriptome_fasta, transcript_name=None):\n    \"\"\"Check required arguments of both riboplot and ribocount.\"\"\"\n    # Is this a valid BAM file? i.e., can pysam read it?\n    try:\n        is_bam_valid(ribo_file)\n    except ValueError:\n        log.error('The given RiboSeq BAM file is not valid')\n        raise\n\n    # Does the BAM file have an index? If not, create it.\n    if not bam_has_index(ribo_file):\n        log.info('Creating an index for the BAM file...')\n        create_bam_index(ribo_file)\n\n        if not bam_has_index(ribo_file):\n            msg = ('Could not create an index for this BAM file. Is this a valid BAM file '\n                   'and/or is the BAM file sorted by chromosomal coordinates?')\n            log.error(msg)\n            raise BamFileError(msg)\n\n    # Is FASTA file valid?\n    fasta_valid = False\n    try:\n        fasta_valid = is_fasta_valid(transcriptome_fasta)\n    except IOError:\n        log.error('Transcriptome FASTA file is not valid')\n        raise\n\n    if fasta_valid:\n        if transcript_name:\n            try:\n                get_fasta_records(transcriptome_fasta, [transcript_name])\n            except IOError:\n                log.error('Could not get FASTA sequence of \"{}\" from transcriptome FASTA file'.format(transcript_name))\n                raise\n        else:\n            # ribocount doesn't have a transcript option so we get the first\n            # sequence name from the fasta file\n            transcript_name = get_first_transcript_name(transcriptome_fasta)\n\n        # check if transcript also exists in BAM\n        with pysam.AlignmentFile(ribo_file, 'rb') as bam_file:\n            if transcript_name not in bam_file.references:\n                msg = 'Transcript \"{}\" does not exist in BAM file'.format(transcript_name)\n                log.error(msg)\n                raise ArgumentError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if bedtools is available and if the given RNA - Seq bam file is valid.", "response": "def check_rna_file(rna_file):\n    \"\"\"Check if bedtools is available and if the given RNA-Seq bam file is valid. \"\"\"\n    try:\n        subprocess.check_output(['bedtools', '--version'])\n    except OSError:\n        log.error('Could not find bedtools in PATH. bedtools is required '\n                  'for generating RNA coverage plot.')\n        raise\n    # Is this a valid BAM file? i.e., can pysam read it?\n    try:\n        is_bam_valid(rna_file)\n    except ValueError:\n        log.error('The given RNASeq BAM file is not valid')\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_read_lengths(ribo_file, read_lengths):\n    # check if there are any valid read lengths to check i.e., not equal to 0\n    valid_lengths = list(set(read_lengths))\n    # if read length is 0, all read lengths are requested so we skip further\n    # checks.\n    if len(valid_lengths) == 1 and valid_lengths[0] == 0:\n        return\n    for read_length in valid_lengths:\n        if read_length < 0:\n            msg = 'Read length must be a positive value'\n            log.error(msg)\n            raise ArgumentError(msg)", "response": "Check if read lengths are valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_read_offsets(read_offsets):\n    for read_offset in read_offsets:\n        if read_offset < 0:\n            msg = 'Read offset must be 0 or greater'\n            log.error(msg)\n            raise ArgumentError(msg)", "response": "Check if read offsets are valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_header(line):\n  if re.match('^@',line):\n    f = line.rstrip().split(\"\\t\")\n    if(len(f) > 9):\n      return False\n    return True\n  return False", "response": "true if we are in a header"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sort_header(header_text):\n  lines = header_text.rstrip().split(\"\\n\")\n  rlens = {}\n  for ln in lines:\n    m = re.match('@SQ\\tSN:(\\S+)\\tLN:(\\S+)',ln)\n    if m:\n      rlens[m.group(1)] = m.group(2)\n  output = ''\n  done_lens = False\n  for ln in lines:\n    if re.match('@SQ\\tSN:',ln):\n      if not done_lens:\n        done_lens = True\n        for chr in sorted(rlens.keys()):\n          output += \"@SQ\\tSN:\"+chr+\"\\tLN:\"+str(rlens[chr])+\"\\n\"\n    else:\n      output += ln.rstrip(\"\\n\")+\"\\n\"\n  return output", "response": "sort the chromosomes in a header text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the heavy alignment ranges calculation called on demand and then cached", "response": "def alignment_ranges(self):\n     \"\"\"Put the heavy alignment ranges calculation called on demand and then cached\"\"\"\n     if not self.is_aligned(): raise ValueError(\"you can't get alignment ranges from something that didn't align\")\n     if self._alignment_ranges: return self._alignment_ranges\n     self._alignment_ranges = self._get_alignment_ranges()\n     return self._alignment_ranges"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the length of the target sequence.", "response": "def target_sequence_length(self):\n    \"\"\" Get the length of the target sequence.  length of the entire chromosome\n\n    throws an error if there is no information available\n\n    :return: length\n    :rtype: int\n    \"\"\"\n    if not self.is_aligned():\n      raise ValueError(\"no length for reference when read is not not aligned\")\n    if self.entries.tlen: return self.entries.tlen #simplest is if tlen is set\n    if self.header:\n      if self.entries.rname in self.header.sequence_lengths:\n        return self.header.sequence_lengths[self.entries.rname]\n    elif self.reference:\n      return len(self.reference[self.entries.rname])\n    else:\n      raise ValueError(\"some reference needs to be set to go from psl to bam\\n\")\n    raise ValueError(\"No reference available\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query_sequence(self):\n    if not self.entries.seq: return None\n    if self.check_flag(0x10): return rc(self.entries.seq)\n    return self.entries.seq", "response": "Returns the sequence of the aligned portion of the sequence"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef query_quality(self):\n    if not self.entries.qual: return None\n    if self.entries.qual == '*': return None\n    if self.check_flag(0x10): return self.entries.qual[::-1]\n    return self.entries.qual", "response": "Returns the query quality of the sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the length of the sequence in the cigar array", "response": "def query_sequence_length(self):\n    \"\"\" does not include hard clipped\"\"\"\n    if self.entries.seq: return len(self.entries.seq)\n    if not self.entries.cigar:\n       raise ValueError('Cannot give a query length if no cigar and no query sequence are present')\n    return sum([x[0] for x in self.cigar_array if re.match('[MIS=X]',x[1])])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef original_query_sequence_length(self):\n    if not self.is_aligned() or not self.entries.cigar:\n      return self.query_sequence_length # take the naive approach\n    # we are here with something aligned so take more intelligent cigar apporach\n    return sum([x[0] for x in self.cigar_array if re.match('[HMIS=X]',x[1])])", "response": "Similar to get_query_sequence_length but also includes the hard clipped bases\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef target_range(self):\n    if not self.is_aligned(): return None\n    if self._target_range: return self._target_range # check cache\n    global _sam_cigar_target_add\n    tlen = sum([x[0] for x in self.cigar_array if _sam_cigar_target_add.match(x[1])])\n    self._target_range = GenomicRange(self.entries.rname,self.entries.pos,self.entries.pos+tlen-1)\n    return self._target_range", "response": "Get the range on the target strand\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cigar_array(self):\n     if self._cigar: return self._cigar\n     self._cigar = [CIGARDatum(int(m[0]),m[1]) for m in re.findall('([0-9]+)([MIDNSHP=X]+)',self.entries.cigar)]\n     return self._cigar", "response": "cache this one to speed things up a bit"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tags(self):\n     if self._tags: return self._tags\n     tags = {}\n     if not tags: return {}\n     for m in [[y.group(1),y.group(2),y.group(3)] for y in [re.match('([^:]{2,2}):([^:]):(.+)$',x) for x in self.entries.optional_fields.split(\"\\t\")]]:\n        if m[1] == 'i': m[2] = int(m[2])\n        elif m[1] == 'f': m[2] = float(m[2])\n        tags[m[0]] = TAGDatum(m[1],m[2])\n     self._tags = tags\n     return self._tags", "response": "Access the auxillary data here"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef eq_central_moments(n_counter, k_counter, dmu_over_dt, species, propensities, stoichiometry_matrix, max_order):\n    central_moments = []\n\n\n    # Loops through required combinations of moments (n1,...,nd)\n    # (does not include 0th order central moment as this is 1,\n    # or 1st order central moment as this is 0\n\n    # copy dmu_mat matrix as a list of rows vectors (1/species)\n    dmu_mat = [sp.Matrix(l).T for l in dmu_over_dt.tolist()]\n\n    d_beta_over_dt_calculator = DBetaOverDtCalculator(propensities,n_counter,stoichiometry_matrix, species)\n\n    for n_iter in n_counter:\n        # skip zeroth moment\n        if n_iter.order == 0 or n_iter.order > max_order:\n            continue\n\n        n_vec = n_iter.n_vector\n\n        # Find all moments in k_counter that are lower than the current n_iter\n        k_lower = [k for k in k_counter if n_iter >= k]\n\n        taylor_exp_mat = []\n\n        for k_iter in k_lower:\n            k_vec = k_iter.n_vector\n\n            # (n k) binomial term in equation 9\n            n_choose_k = make_k_chose_e(k_vec, n_vec)\n\n            # (-1)^(n-k) term in equation 9\n            minus_one_pow_n_minus_k = product([sp.Integer(-1) ** (n - m) for (n,m)\n                                               in zip(n_vec, k_vec)])\n\n            # Calculate alpha, dalpha_over_dt terms in equation 9\n            alpha = product([s ** (n - k) for s, n, k in zip(species, n_vec, k_vec)])\n            # eq 10 {(n - k) mu_i^(-1)} corresponds to {(n - k)/s}. s is symbol for mean of a species\n\n            # multiplies by alpha an the ith row of dmu_mat and sum it to get dalpha_over_dt\n            # eq 10 {(n - k) mu_i^(-1)} corresponds to {(n - k)/s}\n            dalpha_over_dt = sympy_sum_list([((n - k) / s) * alpha * mu_row for s, n, k, mu_row\n                                             in zip(species, n_vec, k_vec, dmu_mat)])\n\n            # e_counter contains elements of k_counter lower than the current k_iter\n            e_counter = [k for k in k_counter if k_iter >= k and k.order > 0]\n\n            dbeta_over_dt = d_beta_over_dt_calculator.get(k_iter.n_vector, e_counter)\n\n            # Calculate beta, dbeta_over_dt terms in equation 9\n            if len(e_counter) == 0:\n                beta = 1\n            else:\n                beta = k_iter.symbol\n\n            taylor_exp_mat.append(n_choose_k * minus_one_pow_n_minus_k * (alpha * dbeta_over_dt + beta * dalpha_over_dt))\n\n        # Taylorexp is a matrix which has an entry equal to\n        # the `n_choose_k * minus_one_pow_n_minus_k * (AdB/dt + beta dA/dt)` term in equation 9  for each k1,..,kd\n        # These are summed over to give the Taylor Expansion for each n1,..,nd combination in equation 9\n        central_moments.append(sum_of_cols(sp.Matrix(taylor_exp_mat)))\n\n    return sp.Matrix(central_moments)", "response": "r Function used to calculate the terms required for use in equations giving the time dependence of central moments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef authenticate(self):\n        if self.apiKey:\n            return\n        loginResponse = self._curl_bitmex(\n            api=\"user/login\",\n            postdict={'email': self.login, 'password': self.password, 'token': self.otpToken})\n        self.token = loginResponse['id']\n        self.session.headers.update({'access-token': self.token})", "response": "Set BitMEX authentication information."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef authentication_required(function):\n        def wrapped(self, *args, **kwargs):\n            if not (self.token or self.apiKey):\n                msg = \"You must be authenticated to use this method\"\n                raise AuthenticationError(msg)\n            else:\n                return function(self, *args, **kwargs)\n        return wrapped", "response": "Decorator for methods that require auth."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget open orders via HTTP. Used on close to ensure we catch them all.", "response": "def open_orders(self, symbol=None):\n        \"\"\"Get open orders via HTTP. Used on close to ensure we catch them all.\"\"\"\n        api = \"order\"\n        query = {'ordStatus.isTerminated': False }\n        if symbol != None:\n            query['symbol'] =symbol\n        orders = self._curl_bitmex(\n            api=api,\n            query={'filter': json.dumps(query)},\n            verb=\"GET\"\n        )\n        return orders"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cancel(self, orderID):\n        api = \"order\"\n        postdict = {\n            'orderID': orderID,\n        }\n        return self._curl_bitmex(api=api, postdict=postdict, verb=\"DELETE\")", "response": "Cancel an existing order."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a request to BitMEX Servers.", "response": "def _curl_bitmex(self, api, query=None, postdict=None, timeout=3, verb=None):\n        \"\"\"Send a request to BitMEX Servers.\"\"\"\n        # Handle URL\n        url = self.base_url + api\n\n        # Default to POST if data is attached, GET otherwise\n        if not verb:\n            verb = 'POST' if postdict else 'GET'\n\n        # Auth: Use Access Token by default, API Key/Secret if provided\n        auth = AccessTokenAuth(self.token)\n        if self.apiKey:\n            auth = APIKeyAuthWithExpires(self.apiKey, self.apiSecret)\n\n        # Make the request\n        try:\n#            url = \"http://httpbin.org/post\"\n            req = requests.Request(verb, url, data=postdict, auth=auth, params=query)\n            prepped = self.session.prepare_request(req)\n            response = self.session.send(prepped, timeout=timeout)\n            # Make non-200s throw\n            response.raise_for_status()\n\n        except requests.exceptions.HTTPError as e:\n            # 401 - Auth error. Re-auth and re-run this request.\n            if response.status_code == 401:\n                if self.token is None:\n                    self.logger.error(\"Login information or API Key incorrect, please check and restart.\")\n                    self.logger.error(\"Error: \" + response.text)\n                    if postdict:\n                        self.logger.error(postdict)\n                self.logger.warning(\"Token expired, reauthenticating...\")\n                sleep(1)\n                self.authenticate()\n                return self._curl_bitmex(api, query, postdict, timeout, verb)\n\n            # 404, can be thrown if order canceled does not exist.\n            elif response.status_code == 404:\n                if verb == 'DELETE':\n                    self.logger.error(\"Order not found: %s\" % postdict['orderID'])\n                    return\n                self.logger.error(\"Unable to contact the BitMEX API (404). \" +\n                                  \"Request: %s \\n %s\" % (url, json.dumps(postdict)))\n            # 429, ratelimit\n            elif response.status_code == 429:\n                self.logger.error(\"Ratelimited on current request. Sleeping, then trying again. Try fewer \" +\n                                  \"order pairs or contact support@bitmex.com to raise your limits. \" +\n                                  \"Request: %s \\n %s\" % (url, json.dumps(postdict)))\n                sleep(1)\n                return self._curl_bitmex(api, query, postdict, timeout, verb)\n\n            # 503 - BitMEX temporary downtime, likely due to a deploy. Try again\n            elif response.status_code == 503:\n                self.logger.warning(\"Unable to contact the BitMEX API (503), retrying. \" +\n                                    \"Request: %s \\n %s\" % (url, json.dumps(postdict)))\n                sleep(1)\n                return self._curl_bitmex(api, query, postdict, timeout, verb)\n            # Unknown Error\n            else:\n                self.logger.error(\"Unhandled Error: %s: %s %s\" % (e, response.text, json.dumps(response.json(), indent=4)))\n                self.logger.error(\"Endpoint was: %s %s\" % (verb, api))\n        except requests.exceptions.Timeout as e:\n            # Timeout, re-run this request\n            self.logger.warning(\"Timed out, retrying...\")\n            return self._curl_bitmex(api, query, postdict, timeout, verb)\n\n        except requests.exceptions.ConnectionError as e:\n            self.logger.warning(\"Unable to contact the BitMEX API (ConnectionError). Please check the URL. Retrying. \" +\n                                \"Request: %s \\n %s\" % (url, json.dumps(postdict)))\n            sleep(1)\n            return self._curl_bitmex(api, query, postdict, timeout, verb)\n\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndecorates the `form_valid` method in a Create/Update class to create new values if necessary. .. warning:: Make sure that this decorator **only** decorates the ``form_valid()`` method and **only** this one.", "response": "def allow_create(function):\n    \"\"\"\n    Decorate the `form_valid` method in a Create/Update class to create new\n    values if necessary.\n\n    .. warning::\n\n        Make sure that this decorator **only** decorates the ``form_valid()``\n        method and **only** this one.\n\n    \"\"\"\n    @wraps(function)\n    def _wrapped_func(*args, **kwargs):\n        form = args[0]\n        # If this argument is not a form, there are a lot of chances that\n        # you didn't decorate the right method.\n        # This decorator is only to be used decorating \"form_valid()\"\n        if isinstance(form, (Form, ModelForm)):\n            # If the form is not valid, don't try to create new values\n            if not form.is_valid():\n                return function(*args, **kwargs)\n\n            for k, field in form.fields.items():\n                if getattr(field, 'create', False) \\\n                        and getattr(field, '_new_values', None):\n                    new_values = field.create_new_values()\n                    # update the field value\n                    form.cleaned_data[k] = form.cleaned_data[k] | new_values\n\n        return function(*args, **kwargs)\n    return _wrapped_func"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a handler function for an event.", "response": "def add_handler(self, event, handler):\n        \"\"\"Adds a handler function for an event.\n\n        Note: Only one handler function is allowed per event on the module\n        level (different modules can provide handlers for the same event).\n        This is because ordering of handler functions is not guaranteed to\n        be preserved at the module level.\n\n        Also note that it's probably easier and more succint to use the\n        decorator form of this e.g. @Module.handle('EVENT')\n        \"\"\"\n        if event in self.event_handlers:\n            raise ValueError(\"Cannot register handler for '%s' twice.\" % event)\n        self.event_handlers[event] = handler"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(self, reloading=False):\n        for event in self.event_handlers:\n            self.controller.listen(event)", "response": "Called when the module is loaded."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handle_event(self, event, client, args):\n        handler = self.event_handlers.get(event)\n        if handler:\n            return handler(client, *args)", "response": "Dispatch an event to its handler."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntriggering a new event that will be dispatched to all modules.", "response": "def trigger_event(self, event, client, args, force_dispatch=False):\n        \"\"\"Trigger a new event that will be dispatched to all modules.\"\"\"\n        self.controller.process_event(event, client, args, force_dispatch=force_dispatch)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef listen(self, event):\n        if event in self.registered:\n            # Already listening to this event\n            return\n        def handler(client, *args):\n            return self.process_event(event, client, args)\n        self.client.add_handler(event, handler)\n        self.registered.add(event)\n        _log.debug(\"Controller is now listening for '%s' events\", event)", "response": "Request that the Controller listen for and dispatch an event."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self):\n        if not self.config and self.config_path is not None:\n            self.load_config()\n        self.running = True\n        self.process_event(\"STARTUP\", self.client, ())", "response": "Starts listening for events from the Client and acting upon them."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing an incoming event.", "response": "def process_event(self, event, client, args, force_dispatch=False):\n        \"\"\"Process an incoming event.\n\n        Offers it to each module according to self.module_ordering,\n        continuing to the next unless the module inhibits propagation.\n\n        Returns True if a module inhibited propagation, otherwise False.\n        \"\"\"\n        if not self.running:\n            _log.debug(\"Ignoring '%s' event - controller not running.\", event)\n            return\n\n        # We keep a copy of the state of loaded modules before this event,\n        # and restore it when we're done. This lets us handle events that\n        # result in other events being dispatched in a graceful manner.\n        old_loaded = self.loaded_on_this_event\n        self.loaded_on_this_event = set(old_loaded or []) if not force_dispatch else set()\n\n        try:\n            _log.debug(\"Controller is dispatching '%s' event\", event)\n            for module_name in self.module_ordering:\n                if module_name in self.loaded_on_this_event and not force_dispatch:\n                    _log.debug(\"Not dispatching %s to '%s' because it was just \"\n                               \"loaded (%r).\", event, module_name,\n                               self.loaded_on_this_event)\n                    continue\n                module = self.loaded_modules[module_name]\n                if module.handle_event(event, client, args):\n                    return True\n        finally:\n            self.loaded_on_this_event = old_loaded"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_config(self, config_path=None):\n        if config_path is None:\n            config_path = self.config_path\n        else:\n            self.config_path = config_path\n\n        config = ConfigParser.SafeConfigParser(self.DEFAULT_SUBSTITUTIONS,\n                                               allow_no_value=True)\n        # Avoid the configparser automatically lowercasing keys\n        config.optionxform = str\n        self.initialize_config(config)\n        try:\n            with open(config_path) as f:\n                config.readfp(f)\n        except (IOError, ConfigParser.Error):\n            _log.exception(\"Ignoring config from %s due to error.\", config_path)\n            return False\n\n        self.config = config\n        self.reload_modules()\n        return True", "response": "Load the configuration from the specified path or self. config_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the configuration to the specified path or self. config_path", "response": "def save_config(self, config_path=None):\n        \"\"\"Save configuration to the specified path, or self.config_path\"\"\"\n        if config_path is None:\n            config_path = self.config_path\n        else:\n            self.config_path = config_path\n\n        with open(config_path, 'w') as f:\n            self.config.write(f)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reload_modules(self):\n        old_modules = set(self.loaded_modules)\n        for module in self.loaded_modules.itervalues():\n            module.stop(reloading=True)\n\n        self.loaded_modules = {}\n        self.module_ordering = []\n\n        try:\n            modules_to_load = sorted(self.config.items(\"modules\"),\n                                     key=lambda x:int(x[1]))\n        except (TypeError,ValueError):\n            _log.exception(\"Unable to load modules due to invalid priority.\")\n            return False\n\n        modules_success = []\n        modules_failure = []\n\n        for module_name,_ in modules_to_load:\n            if self.load_module(module_name):\n                modules_success.append(module_name)\n            else:\n                modules_failure.append(module_name)\n\n        if modules_success:\n            _log.info(\"Loaded the following modules: %s\", modules_success)\n        if modules_failure:\n            _log.error(\"These modules failed to load: %s\", modules_failure)\n\n        for module_name in self.module_ordering:\n            module = self.loaded_modules[module_name]\n            module.start(reloading=(module_name in old_modules))\n\n        self.process_event(\"STARTUP\", self.client, (), force_dispatch=True)\n\n        return not modules_failure", "response": "Reloads all of the modules in the config file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reload_module(self, module_name):\n        module = self.loaded_modules.get(module_name)\n        if module:\n            module.stop(reloading=True)\n        else:\n            _log.info(\"Reload loading new module module '%s'\",\n                         module_name)\n        success = self.load_module(module_name)\n        if success:\n            _log.info(\"Successfully (re)loaded module '%s'.\", module_name)\n        elif module:\n            _log.error(\"Unable to reload module '%s', reusing existing.\",\n                       module_name)\n        else:\n            _log.error(\"Failed to load module '%s'.\", module_name)\n            return False\n        self.loaded_modules[module_name].start(reloading=True)\n        return success", "response": "Reloads the specified module."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_module(self, module_name):\n        if module_name in self.currently_loading:\n            _log.warning(\"Ignoring request to load module '%s' because it \"\n                         \"is already currently being loaded.\", module_name)\n            return False\n\n        try: # ensure that currently_loading gets reset no matter what\n            self.currently_loading.add(module_name)\n            if self.loaded_on_this_event is not None:\n                self.loaded_on_this_event.add(module_name)\n\n            # Force the module to actually be reloaded\n            try:\n                _temp = reload(importlib.import_module(module_name))\n            except ImportError:\n                _log.error(\"Unable to load module '%s' - module not found.\",\n                           module_name)\n                return False\n            except SyntaxError:\n                _log.exception(\"Unable to load module '%s' - syntax error(s).\",\n                           module_name)\n                return False\n\n            if not hasattr(_temp, \"module\"):\n                _log.error(\"Unable to load module '%s' - no 'module' member.\",\n                           module_name)\n                return False\n\n            module = _temp.module\n            if not issubclass(module, Module):\n                _log.error(\"Unable to load module '%s' - it's 'module' member \"\n                           \"is not a kitnirc.modular.Module.\", module_name)\n                return False\n\n            self.loaded_modules[module_name] = module(self)\n            if module_name not in self.module_ordering:\n                self.module_ordering.append(module_name)\n            return True\n\n        finally:\n            self.currently_loading.discard(module_name)", "response": "Attempts to load the specified module and returns True if the module was successfully loaded False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unload_module(self, module_name):\n        module = self.loaded_modules.get(module_name)\n        if not module:\n            _log.warning(\"Ignoring request to unload non-existant module '%s'\",\n                         module_name)\n            return False\n\n        module.stop(reloading=False)\n        del self.loaded_modules[module_name]\n        self.module_ordering.remove(module_name)\n        return True", "response": "Unload the specified module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_url(url, fully_qualified=False):\n    # Retrieve the schema.\n    try:\n        schema, remaining = url.split(':', 1)\n    except ValueError:\n        if fully_qualified:\n            msg = 'URL has no schema: {}'.format(url)\n            raise ValueError(msg.encode('utf-8'))\n        schema = 'cs'\n        remaining = url\n    if schema not in ('cs', 'local'):\n        msg = 'URL has invalid schema: {}'.format(schema)\n        raise ValueError(msg.encode('utf-8'))\n    # Retrieve and validate the optional user.\n    parts = remaining.split('/')\n    part = parts.pop(0)\n    user = ''\n    if part.startswith('~'):\n        user = part[1:]\n        if not valid_user(user):\n            msg = 'URL has invalid user name: {}'.format(user)\n            raise ValueError(msg.encode('utf-8'))\n        if schema == 'local':\n            msg = 'local entity URL with user name: {}'.format(url)\n            raise ValueError(msg.encode('utf-8'))\n        if not parts:\n            msg = 'URL has invalid form: {}'.format(url)\n            raise ValueError(msg.encode('utf-8'))\n        part = parts.pop(0)\n    # Retrieve and validate the series.\n    series = ''\n    if parts:\n        series = part\n        if not valid_series(series):\n            msg = 'URL has invalid series: {}'.format(series)\n            raise ValueError(msg.encode('utf-8'))\n        part = parts.pop(0)\n    elif fully_qualified:\n        msg = 'URL has invalid form: {}'.format(url)\n        raise ValueError(msg.encode('utf-8'))\n    # Retrieve and validate name and revision.\n    if parts:\n        msg = 'URL has invalid form: {}'.format(url)\n        raise ValueError(msg.encode('utf-8'))\n    try:\n        name, revision = part.rsplit('-', 1)\n    except ValueError:\n        if fully_qualified:\n            msg = 'URL has no revision: {}'.format(url)\n            raise ValueError(msg.encode('utf-8'))\n        name, revision = part, None\n    if revision is not None:\n        try:\n            revision = int(revision)\n        except ValueError:\n            if fully_qualified:\n                msg = 'URL has invalid revision: {}'.format(revision)\n                raise ValueError(msg.encode('utf-8'))\n            name, revision = name + '-' + revision, None\n    if not valid_name(name):\n        msg = 'URL has invalid name: {}'.format(name)\n        raise ValueError(msg.encode('utf-8'))\n    return schema, user, series, name, revision", "response": "Parse the given charm or bundle URL into a tuple containing the entity reference fragments schema user series name and revision."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tasks_spec(self, available_actions, default_action=\"run\"):\n        return dictof(\n              self.task_name_spec\n            , create_spec(task_objs.Task, validators.deprecated_key(\"spec\", \"Use ``action`` and ``options`` instead (note that ``action`` defaults to run)\")\n                , action = defaulted(string_choice_spec(available_actions, \"No such task\"), default_action)\n                , options = dictionary_spec()\n                , overrides = dictionary_spec()\n                , description = string_spec()\n                )\n            )", "response": "Returns a dictionary of tasks for a particular image"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef authentications_spec(self):\n        return container_spec(authentication_objs.Authentication\n              , dictof(string_spec(), set_options(\n                  reading = optional_spec(authentication_spec())\n                , writing = optional_spec(authentication_spec())\n                )\n              )\n            )", "response": "Spec for a group of authentication options"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef image_spec(self):\n        from harpoon.option_spec import image_specs as specs\n        from harpoon.option_spec import image_objs\n        class persistence_shell_spec(Spec):\n            \"\"\"Make the persistence shell default to the shell on the image\"\"\"\n            def normalise(self, meta, val):\n                shell = defaulted(string_spec(), \"/bin/bash\").normalise(meta, meta.everything[[\"images\", meta.key_names()[\"_key_name_2\"]]].get(\"shell\", NotSpecified))\n                shell = defaulted(formatted(string_spec(), formatter=MergedOptionStringFormatter), shell).normalise(meta, val)\n                return shell\n\n        return create_spec(image_objs.Image\n            , validators.deprecated_key(\"persistence\", \"The persistence feature has been removed\")\n            , validators.deprecated_key(\"squash_after\", \"The squash feature has been removed\")\n            , validators.deprecated_key(\"squash_before_push\", \"The squash feature has been removed\")\n\n            # Changed how volumes_from works\n            , validators.deprecated_key(\"volumes_from\", \"Use ``volumes.share_with``\")\n\n            # Deprecated link\n            , validators.deprecated_key(\"link\", \"Use ``links``\")\n\n            # Harpoon options\n            , harpoon = any_spec()\n\n            # default the name to the key of the image\n            , tag = optional_spec(formatted(string_spec(), formatter=MergedOptionStringFormatter))\n            , name = formatted(defaulted(string_spec(), \"{_key_name_1}\"), formatter=MergedOptionStringFormatter)\n            , key_name = formatted(overridden(\"{_key_name_1}\"), formatter=MergedOptionStringFormatter)\n            , image_name = optional_spec(string_spec())\n            , image_index = formatted(defaulted(string_spec(), \"\"), formatter=MergedOptionStringFormatter)\n            , container_name = optional_spec(string_spec())\n            , image_name_prefix = defaulted(string_spec(), \"\")\n\n            , no_tty_option = defaulted(formatted(boolean(), formatter=MergedOptionStringFormatter), False)\n\n            , user = defaulted(string_spec(), None)\n            , configuration = any_spec()\n\n            , vars = dictionary_spec()\n            , assume_role = optional_spec(formatted(string_spec(), formatter=MergedOptionStringFormatter))\n            , deleteable_image = defaulted(boolean(), False)\n\n            , authentication = self.authentications_spec\n\n            # The spec itself\n            , shell = defaulted(formatted(string_spec(), formatter=MergedOptionStringFormatter), \"/bin/bash\")\n            , bash = delayed(optional_spec(formatted(string_spec(), formatter=MergedOptionStringFormatter)))\n            , command = delayed(optional_spec(formatted(string_spec(), formatter=MergedOptionStringFormatter)))\n            , commands = required(container_spec(Commands, listof(command_spec())))\n            , cache_from = delayed(or_spec(boolean(), listof(formatted(string_spec(), formatter=MergedOptionStringFormatter))))\n            , cleanup_intermediate_images = defaulted(boolean(), True)\n\n            , links = listof(specs.link_spec(), expect=image_objs.Link)\n\n            , context = self.context_spec\n            , wait_condition = optional_spec(self.wait_condition_spec)\n\n            , lxc_conf = defaulted(filename_spec(), None)\n\n            , volumes = create_spec(image_objs.Volumes\n                , mount = listof(specs.mount_spec(), expect=image_objs.Mount)\n                , share_with = listof(formatted(string_spec(), MergedOptionStringFormatter, expected_type=image_objs.Image))\n                )\n\n            , dependency_options = dictof(specs.image_name_spec()\n                , create_spec(image_objs.DependencyOptions\n                  , attached = defaulted(boolean(), False)\n                  , wait_condition = optional_spec(self.wait_condition_spec)\n                  )\n                )\n\n            , env = listof(specs.env_spec(), expect=image_objs.Environment)\n            , ports = listof(specs.port_spec(), expect=image_objs.Port)\n            , ulimits = defaulted(listof(dictionary_spec()), None)\n            , log_config = defaulted(listof(dictionary_spec()), None)\n            , security_opt = defaulted(listof(string_spec()), None)\n            , read_only_rootfs = defaulted(boolean(), False)\n\n            , other_options = create_spec(other_options\n                , start = dictionary_spec()\n                , build = dictionary_spec()\n                , create = dictionary_spec()\n                , host_config = dictionary_spec()\n                )\n\n            , network = create_spec(image_objs.Network\n                , dns = defaulted(listof(string_spec()), None)\n                , mode = defaulted(string_spec(), None)\n                , hostname = defaulted(string_spec(), None)\n                , domainname = defaulted(string_spec(), None)\n                , disabled = defaulted(boolean(), False)\n                , dns_search = defaulted(listof(string_spec()), None)\n                , extra_hosts = listof(string_spec())\n                , network_mode = defaulted(string_spec(), None)\n                , publish_all_ports = defaulted(boolean(), False)\n                )\n\n            , cpu = create_spec(image_objs.Cpu\n                , cap_add = defaulted(listof(string_spec()), None)\n                , cpuset_cpus = defaulted(string_spec(), None)\n                , cpuset_mems = defaulted(string_spec(), None)\n                , cap_drop = defaulted(listof(string_spec()), None)\n                , mem_limit = defaulted(integer_spec(), 0)\n                , cpu_shares = defaulted(integer_spec(), None)\n                , memswap_limit = defaulted(integer_spec(), 0)\n                )\n\n            , devices = defaulted(listof(dictionary_spec()), None)\n            , privileged = defaulted(boolean(), False)\n            , restart_policy = defaulted(string_spec(), None)\n            )", "response": "Spec for each image in the cluster"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef harpoon_spec(self):\n        formatted_string = formatted(string_spec(), MergedOptionStringFormatter, expected_type=six.string_types)\n        formatted_boolean = formatted(boolean(), MergedOptionStringFormatter, expected_type=bool)\n\n        return create_spec(Harpoon\n            , config = optional_spec(file_spec())\n\n            , tag = optional_spec(string_spec())\n            , extra = defaulted(formatted_string, \"\")\n            , debug = defaulted(boolean(), False)\n            , addons = dictof(string_spec(), listof(string_spec()))\n            , artifact = optional_spec(formatted_string)\n            , extra_files = listof(string_spec())\n            , chosen_task = defaulted(formatted_string, \"list_tasks\")\n            , chosen_image = defaulted(formatted_string, \"\")\n\n            , flat = defaulted(formatted_boolean, False)\n            , no_cleanup = defaulted(formatted_boolean, False)\n            , interactive = defaulted(formatted_boolean, True)\n            , silent_build = defaulted(formatted_boolean, False)\n            , keep_replaced = defaulted(formatted_boolean, False)\n            , ignore_missing = defaulted(formatted_boolean, False)\n            , no_intervention = defaulted(formatted_boolean, False)\n            , intervene_afterwards = defaulted(formatted_boolean, False)\n\n            , do_push = defaulted(formatted_boolean, False)\n            , only_pushable = defaulted(formatted_boolean, False)\n            , docker_context = any_spec()\n            , docker_context_maker = any_spec()\n\n            , stdout = defaulted(any_spec(), sys.stdout)\n            , tty_stdin = defaulted(any_spec(), None)\n            , tty_stdout = defaulted(any_spec(), lambda: sys.stdout)\n            , tty_stderr = defaulted(any_spec(), lambda: sys.stderr)\n            )", "response": "Spec for harpoon options"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind and returns first applied URI of this node that has a namespace.", "response": "def namespace_uri(self):\n        \"\"\"\n        Finds and returns first applied URI of this node that has a namespace.\n\n        :return str: uri\n        \"\"\"\n        try:\n            return next(\n                iter(filter(lambda uri: URI(uri).namespace, self._uri))\n            )\n        except StopIteration:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the map for this record", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(EdXDragAndDropQuestionFormRecord, self)._init_map()\n        QuestionTextFormRecord._init_map(self)\n        QuestionFilesFormRecord._init_map(self)\n        self.my_osid_object_form._my_map['text']['text'] = ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the metadata for this record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(EdXDragAndDropQuestionFormRecord, self)._init_metadata()\n        QuestionTextFormRecord._init_metadata(self)\n        QuestionFilesFormRecord._init_metadata(self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall these all manually because non - cooperative", "response": "def _init_map(self):\n        \"\"\"call these all manually because non-cooperative\"\"\"\n        DecimalAnswerFormRecord._init_map(self)\n        DecimalValuesFormRecord._init_map(self)\n        TextAnswerFormRecord._init_map(self)\n        TextsFormRecord._init_map(self)\n        super(edXNumericResponseAnswerFormRecord, self)._init_map()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the metadata for this answer form record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        DecimalAnswerFormRecord._init_metadata(self)\n        DecimalValuesFormRecord._init_metadata(self)\n        TextAnswerFormRecord._init_metadata(self)\n        TextsFormRecord._init_metadata(self)\n        super(edXNumericResponseAnswerFormRecord, self)._init_metadata()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_tolerance_value(self, tolerance):\n        # include index because could be multiple response / tolerance pairs\n        if not isinstance(tolerance, float):\n            raise InvalidArgument('tolerance value must be a decimal')\n        self.add_decimal_value(tolerance, 'tolerance')", "response": "set the tolerance value for the resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhook for pre - dispatching the request.", "response": "def pre_dispatch(self, request, path_args):\n        \"\"\"\n        Pre dispatch hook\n        \"\"\"\n        secret_key = self.get_secret_key(request, path_args)\n        if not secret_key:\n            raise PermissionDenied('Signature not valid.')\n\n        try:\n            signing.verify_url_path(request.path, request.GET, secret_key)\n        except SigningError as ex:\n            raise PermissionDenied(str(ex))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_catalogs(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.CatalogList(self._results, runtime=self._runtime)", "response": "Gets the catalog list resulting from the search."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_authorization_session(self):\n        if not self.supports_authorization():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AuthorizationSession(runtime=self._runtime)", "response": "Gets an authorization session which is responsible for performing authorization checks for the specified service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_authorization_session_for_vault(self, vault_id):\n        if not self.supports_authorization():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AuthorizationSession(vault_id, runtime=self._runtime)", "response": "Gets an authorization session which is responsible for performing authorization checks for the given vault."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_authorization_lookup_session(self):\n        if not self.supports_authorization_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AuthorizationLookupSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the authorization lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_authorization_query_session(self):\n        if not self.supports_authorization_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AuthorizationQuerySession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the authorization query service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_authorization_query_session_for_vault(self, vault_id):\n        if not self.supports_authorization_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AuthorizationQuerySession(vault_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the authorization query service for the given vault."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_authorization_admin_session(self):\n        if not self.supports_authorization_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AuthorizationAdminSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the authorization administration service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_authorization_admin_session_for_vault(self, vault_id):\n        if not self.supports_authorization_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AuthorizationAdminSession(vault_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the authorization admin service for the given vault."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the session for retrieving authorization to vault mappings.", "response": "def get_authorization_vault_session(self):\n        \"\"\"Gets the session for retrieving authorization to vault mappings.\n\n        return: (osid.authorization.AuthorizationVaultSession) - an\n                ``AuthorizationVaultSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_vault()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_authorization_vault()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_authorization_vault():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AuthorizationVaultSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the session for assigning authorizations to vault mappings.", "response": "def get_authorization_vault_assignment_session(self):\n        \"\"\"Gets the session for assigning authorizations to vault mappings.\n\n        return: (osid.authorization.AuthorizationVaultAssignmentSession)\n                - a ``AuthorizationVaultAssignmentSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_authorization_vault_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_authorization_vault_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_authorization_vault_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AuthorizationVaultAssignmentSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vault_lookup_session(self):\n        if not self.supports_vault_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.VaultLookupSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the vault lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vault_admin_session(self):\n        if not self.supports_vault_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.VaultAdminSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the vault administration service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the session traversing vault hierarchies.", "response": "def get_vault_hierarchy_session(self):\n        \"\"\"Gets the session traversing vault hierarchies.\n\n        return: (osid.authorization.VaultHierarchySession) - a\n                ``VaultHierarchySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_hierarchy() is false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_vault_hierarchy()`` is true.*\n\n        \"\"\"\n        if not self.supports_vault_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.VaultHierarchySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the session designing vault hierarchies.", "response": "def get_vault_hierarchy_design_session(self):\n        \"\"\"Gets the session designing vault hierarchies.\n\n        return: (osid.authorization.VaultHierarchyDesignSession) - a\n                ``VaultHierarchyDesignSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_hierarchy_design() is\n                false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_vault_hierarchy_design()`` is true.*\n\n        \"\"\"\n        if not self.supports_vault_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.VaultHierarchyDesignSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_authorization_lookup_session_for_vault(self, vault_id, proxy):\n        if not self.supports_authorization_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AuthorizationLookupSession(vault_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the authorization lookup service for the given vault."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vault_query_session(self, proxy):\n        if not self.supports_vault_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.VaultQuerySession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the vault query service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate html code with QR - code and QR - code", "response": "def _qr_code(self, instance):\n        \"\"\"\n        return generate html code with \"otpauth://...\" link and QR-code\n        \"\"\"\n        request = self.request # FIXME\n        try:\n            user = instance.user\n        except ObjectDoesNotExist:\n            return _(\"Please save first!\")\n\n        current_site = get_current_site(request)\n        username = user.username\n        secret = six.text_type(base64.b32encode(instance.bin_key), encoding=\"ASCII\")\n\n        key_uri = (\n            \"otpauth://totp/secure-login:%(site_name)s-%(username)s?secret=%(secret)s&issuer=%(issuer)s\"\n        ) % {\n            \"site_name\": urlquote(current_site.name),\n            \"username\": urlquote(username),\n            \"secret\": secret,\n            \"issuer\": urlquote(username),\n        }\n        context = {\"key_uri\": key_uri}\n        return render_to_string(\"secure_js_login/qr_info.html\", context)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qr_code(self, instance):\n        try:\n            return self._qr_code(instance)\n        except Exception as err:\n            if settings.DEBUG:\n                import traceback\n                return \"<pre>%s</pre>\" % traceback.format_exc()", "response": "Display picture of QR - code from used secret\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tokens(self, instance):\n        if not instance.pk:\n            # e.g.: Use will create a new TOTP entry\n            return \"-\"\n\n        totp = TOTP(instance.bin_key, instance.step, instance.t0, instance.digits)\n\n        tokens = []\n        for offset in range(-instance.tolerance, instance.tolerance + 1):\n            totp.drift = instance.drift + offset\n            tokens.append(totp.token())\n\n        return \" \".join([\"%s\" % token for token in tokens])", "response": "Return a string of the current acceptable TOTP tokens for the current instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns HTML from MediaWiki markup", "response": "def parse(text, showToc=True):\n\t\"\"\"Returns HTML from MediaWiki markup\"\"\"\n\tp = Parser(show_toc=showToc)\n\treturn p.parse(text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a str object to a unicode object.", "response": "def to_unicode(text, charset=None):\n\t\"\"\"Convert a `str` object to an `unicode` object.\n\n\tIf `charset` is given, we simply assume that encoding for the text,\n\tbut we'll use the \"replace\" mode so that the decoding will always\n\tsucceed.\n\tIf `charset` is ''not'' specified, we'll make some guesses, first\n\ttrying the UTF-8 encoding, then trying the locale preferred encoding,\n\tin \"replace\" mode. This differs from the `unicode` builtin, which\n\tby default uses the locale preferred encoding, in 'strict' mode,\n\tand is therefore prompt to raise `UnicodeDecodeError`s.\n\n\tBecause of the \"replace\" mode, the original content might be altered.\n\tIf this is not what is wanted, one could map the original byte content\n\tby using an encoding which maps each byte of the input to an unicode\n\tcharacter, e.g. by doing `unicode(text, 'iso-8859-1')`.\n\t\"\"\"\n\tif not isinstance(text, str):\n\t\tif isinstance(text, Exception):\n\t\t\t# two possibilities for storing unicode strings in exception data:\n\t\t\ttry:\n\t\t\t\t# custom __str__ method on the exception (e.g. PermissionError)\n\t\t\t\treturn unicode(text)\n\t\t\texcept UnicodeError:\n\t\t\t\t# unicode arguments given to the exception (e.g. parse_date)\n\t\t\t\treturn ' '.join([to_unicode(arg) for arg in text.args])\n\t\treturn unicode(text)\n\tif charset:\n\t\treturn unicode(text, charset, 'replace')\n\telse:\n\t\ttry:\n\t\t\treturn unicode(text, 'utf-8')\n\t\texcept UnicodeError:\n\t\t\treturn unicode(text, locale.getpreferredencoding(), 'replace')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef str2url(str):\n\ttry:\n\t\tstr = str.encode('utf-8')\n\texcept:\n\t\tpass\n\tmfrom\t= \"\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\"\n\tto\t\t= \"AAAAAAECEEEEIIIIDNOOOOOOUUUUYSaaaaaaaceeeeiiii\"\n\tmfrom\t+= \"\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff\u0100\u0101\u0102\u0103\u0104\u0105\u0106\u0107\u0108\u0109\u010a\u010b\u010c\u010d\u010e\u010f\u0110\u0111\u0112\u0113\u0114\u0115\u0116\u0117\u0118\u0119\u011a\u011b\u011c\u011d\u011e\u011f\u0120\u0121\u0122\u0123\"\n\tto\t\t+= \"noooooouuuuyyaaaaaaccccccccddddeeeeeeeeeegggggggg\"\n\tmfrom\t+= \"\u0124\u0125\u0126\u0127\u0128\u0129\u012a\u012b\u012c\u012d\u012e\u012f\u0130\u0131\u0134\u0135\u0136\u0137\u0138\u0139\u013a\u013b\u013c\u013d\u013e\u013f\u0140\u0141\u0142\u0143\u0144\u0145\u0146\u0147\u0148\u0149\u014a\u014b\u014c\u014d\u014e\u014f\u0150\u0151\u0152\u0153\u0154\u0155\u0156\u0157\u0158\u0159\"\n\tto\t\t+= \"hhhhiiiiiiiiiijjkkkllllllllllnnnnnnnnnoooooooorrrrrr\"\n\tmfrom\t+= \"\u015a\u015b\u015c\u015d\u015e\u015f\u0160\u0161\u0162\u0163\u0164\u0165\u0166\u0167\u0168\u0169\u016a\u016b\u016c\u016d\u016e\u016f\u0170\u0171\u0172\u0173\u0174\u0175\u0176\u0177\u0178\u0179\u017a\u017b\u017c\u017d\u017e\u017f\u0180\u0182\u0183\u0184\u0185\u0187\u0188\u0189\u018a\u0190\u0191\u0192\u0193\u0194\"\n\tto\t\t+= \"ssssssssttttttuuuuuuuuuuuuwwyyyzzzzzzfbbbbbccddeffgv\"\n\tmfrom\t+= \"\u0196\u0197\u0198\u0199\u019a\u019d\u019e\u019f\u01a0\u01a4\u01a6\u01ab\u01ac\u01ad\u01ae\u01af\u01b0\u01b1\u01b2\u01b3\u01b4\u01b5\u01b6\u01cd\u01ce\u01cf\u01d0\u01d1\u01d2\u01d3\u01d4\u01d5\u01d6\u01d7\u01d8\u01d9\u01da\u01db\u01dc\u01dd\u01de\u01df\u01e0\u01e1\u01e2\u01e3\u01e4\u01e5\u01e6\u01e7\u01e8\u01e9\"\n\tto\t\t+= \"likklnnoopettttuuuuyyzzaaiioouuuuuuuuuueaaaaeeggggkk\"\n\tmfrom\t+= \"\u01ea\u01eb\u01ec\u01ed\u01f0\u01f4\u01f5\u01f7\u01f8\u01f9\u01fa\u01fb\u01fc\u01fd\u01fe\u01ff\u0200\u0201\u0202\u0203\u0204\u0205\u0206\u0207\u0208\u0209\u020a\u020b\u020c\u020d\u020e\u020f\u0210\u0211\u0212\u0213\u0214\u0215\u0216\u0217\u0218\u0219\u021a\u021b\u021e\u021f\u0224\u0225\u0226\u0227\u0228\u0229\"\n\tto\t\t+= \"oooojggpnnaaeeooaaaaeeeeiiiioooorrrruuuusstthhzzaaee\"\n\tmfrom\t+= \"\u022a\u022b\u022c\u022d\u022e\u022f\u0230\u0231\u0232\u0233\u1e00\u1e01\u1e02\u1e03\u1e04\u1e05\u1e06\u1e07\u1e08\u1e09\u1e0a\u1e0b\u1e0c\u1e0d\u1e0e\u1e0f\u1e10\u1e11\u1e12\u1e13\u1e14\u1e15\u1e16\u1e17\u1e18\u1e19\u1e1a\u1e1b\u1e1c\u1e1d\u1e1e\u1e1f\u1e20\u1e21\u1e22\u1e23\u1e24\u1e25\u1e26\u1e27\u1e28\u1e29\u1e2a\u1e2b\"\n\tto\t\t+= \"ooooooooyyaabbbbbbccddddddddddeeeeeeeeeeffgghhhhhhhhhh\"\n\tmfrom\t+= \"\u1e2c\u1e2d\u1e2e\u1e2f\u1e30\u1e31\u1e32\u1e33\u1e34\u1e35\u1e36\u1e37\u1e38\u1e39\u1e3a\u1e3b\u1e3c\u1e3d\u1e3e\u1e3f\u1e40\u1e41\u1e42\u1e43\u1e44\u1e45\u1e46\u1e47\u1e48\u1e49\u1e4a\u1e4b\u1e4c\u1e4d\u1e4e\u1e4f\u1e50\u1e51\u1e52\u1e53\u1e54\u1e55\u1e56\u1e57\u1e58\u1e59\u1e5a\u1e5b\u1e5c\u1e5d\u1e5e\u1e5f\"\n\tto\t\t+= \"iiiikkkkkkllllllllmmmmmmnnnnnnnnoooooooopppprrrrrrrr\"\n\tmfrom\t+= \"\u1e60\u1e61\u1e62\u1e63\u1e64\u1e65\u1e66\u1e67\u1e68\u1e69\u1e6a\u1e6b\u1e6c\u1e6d\u1e6e\u1e6f\u1e70\u1e71\u1e72\u1e73\u1e74\u1e75\u1e76\u1e77\u1e78\u1e79\u1e7a\u1e7b\u1e7c\u1e7d\u1e7e\u1e7f\u1e80\u1e81\u1e82\u1e83\u1e84\u1e85\u1e86\u1e87\u1e88\u1e89\u1e8a\u1e8b\u1e8c\u1e8d\u1e8e\u1e8f\u1e90\u1e91\u1e92\u1e93\u1e94\u1e95\"\n\tto\t\t+= \"ssssssssssttttttttuuuuuuuuuuvvvvwwwwwwwwwwxxxxxyzzzzzz\"\n\tmfrom\t+= \"\u1e96\u1e97\u1e98\u1e99\u1e9a\u1e9b\u1ea0\u1ea1\u1ea2\u1ea3\u1ea4\u1ea5\u1ea6\u1ea7\u1ea8\u1ea9\u1eaa\u1eab\u1eac\u1ead\u1eae\u1eaf\u1eb0\u1eb1\u1eb2\u1eb3\u1eb4\u1eb5\u1eb6\u1eb7\u1eb8\u1eb9\u1eba\u1ebb\u1ebc\u1ebd\u1ebe\u1ebf\u1ec0\u1ec1\u1ec2\u1ec3\u1ec4\u1ec5\u1ec6\u1ec7\u1ec8\u1ec9\u1eca\u1ecb\"\n\tto\t\t+= \"htwyafaaaaaaaaaaaaaaaaaaaaaaaaeeeeeeeeeeeeeeeeiiii\"\n\tmfrom\t+= \"\u1ecc\u1ecd\u1ece\u1ecf\u1ed0\u1ed1\u1ed2\u1ed3\u1ed4\u1ed5\u1ed6\u1ed7\u1ed8\u1ed9\u1eda\u1edb\u1edc\u1edd\u1ede\u1edf\u1ee0\u1ee1\u1ee2\u1ee3\u1ee4\u1ee5\u1ee6\u1ee7\u1ee8\u1ee9\u1eea\u1eeb\u1eec\u1eed\u1eee\u1eef\u1ef0\u1ef1\u1ef2\u1ef3\u1ef4\u1ef5\u1ef6\u1ef7\u1ef8\u1ef9\"\n\tto\t\t+= \"oooooooooooooooooooooooouuuuuuuuuuuuuuyyyyyyyy\"\n\tfor i in zip(mfrom, to):\n\t\tstr = str.replace(*i)\n\treturn str", "response": "This function takes a UTF - 8 string and replaces all characters with the equivalent in 7 - bit ASCII string and returns a plain ASCII string usable in URLs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove bad tags into HTML identities", "response": "def removeHtmlTags(self, text):\n\t\t\"\"\"convert bad tags into HTML identities\"\"\"\n\t\tsb = []\n\t\ttext = self.removeHtmlComments(text)\n\t\tbits = text.split(u'<')\n\t\tsb.append(bits.pop(0))\n\t\ttagstack = []\n\t\ttablestack = tagstack\n\t\tfor x in bits:\n\t\t\tm = _tagPattern.match(x)\n\t\t\tif not m:\n\t\t\t\tcontinue\n\t\t\tslash, t, params, brace, rest = m.groups()\n\t\t\tt = t.lower()\n\t\t\tbadtag = False\n\t\t\tif t in _htmlelements:\n\t\t\t\t# Check our stack\n\t\t\t\tif slash:\n\t\t\t\t\t# Closing a tag...\n\t\t\t\t\tif t in _htmlsingleonly or len(tagstack) == 0:\n\t\t\t\t\t\tbadtag = True\n\t\t\t\t\telse:\n\t\t\t\t\t\tot = tagstack.pop()\n\t\t\t\t\t\tif ot != t:\n\t\t\t\t\t\t\tif ot in _htmlsingleallowed:\n\t\t\t\t\t\t\t\t# Pop all elements with an optional close tag\n\t\t\t\t\t\t\t\t# and see if we find a match below them\n\t\t\t\t\t\t\t\toptstack = []\n\t\t\t\t\t\t\t\toptstack.append(ot)\n\t\t\t\t\t\t\t\twhile True:\n\t\t\t\t\t\t\t\t\tif len(tagstack) == 0:\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\tot = tagstack.pop()\n\t\t\t\t\t\t\t\t\tif ot == t or ot not in _htmlsingleallowed:\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\toptstack.append(ot)\n\t\t\t\t\t\t\t\tif t != ot:\n\t\t\t\t\t\t\t\t\t# No match. Push the optinal elements back again\n\t\t\t\t\t\t\t\t\tbadtag = True\n\t\t\t\t\t\t\t\t\ttagstack += reversed(optstack)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\ttagstack.append(ot)\n\t\t\t\t\t\t\t\t# <li> can be nested in <ul> or <ol>, skip those cases:\n\t\t\t\t\t\t\t\tif ot not in _htmllist and t in _listtags:\n\t\t\t\t\t\t\t\t\tbadtag = True\n\t\t\t\t\t\telif t == u'table':\n\t\t\t\t\t\t\tif len(tablestack) == 0:\n\t\t\t\t\t\t\t\tbagtag = True\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\ttagstack = tablestack.pop()\n\t\t\t\t\tnewparams = u''\n\t\t\t\telse:\n\t\t\t\t\t# Keep track for later\n\t\t\t\t\tif t in _tabletags and u'table' not in tagstack:\n\t\t\t\t\t\tbadtag = True\n\t\t\t\t\telif t in tagstack and t not in _htmlnest:\n\t\t\t\t\t\tbadtag = True\n\t\t\t\t\t# Is it a self-closed htmlpair? (bug 5487)\n\t\t\t\t\telif brace == u'/>' and t in _htmlpairs:\n\t\t\t\t\t\tbadTag = True\n\t\t\t\t\telif t in _htmlsingleonly:\n\t\t\t\t\t\t# Hack to force empty tag for uncloseable elements\n\t\t\t\t\t\tbrace = u'/>'\n\t\t\t\t\telif t in _htmlsingle:\n\t\t\t\t\t\t# Hack to not close $htmlsingle tags\n\t\t\t\t\t\tbrace = None\n\t\t\t\t\telse:\n\t\t\t\t\t\tif t == u'table':\n\t\t\t\t\t\t\ttablestack.append(tagstack)\n\t\t\t\t\t\t\ttagstack = []\n\t\t\t\t\t\ttagstack.append(t)\n\t\t\t\t\tnewparams = self.fixTagAttributes(params, t)\n\t\t\t\tif not badtag:\n\t\t\t\t\trest = rest.replace(u'>', u'&gt;')\n\t\t\t\t\tif brace == u'/>':\n\t\t\t\t\t\tclose = u' /'\n\t\t\t\t\telse:\n\t\t\t\t\t\tclose = u''\n\t\t\t\t\tsb.append(u'<')\n\t\t\t\t\tsb.append(slash)\n\t\t\t\t\tsb.append(t)\n\t\t\t\t\tsb.append(newparams)\n\t\t\t\t\tsb.append(close)\n\t\t\t\t\tsb.append(u'>')\n\t\t\t\t\tsb.append(rest)\n\t\t\t\t\tcontinue\n\t\t\tsb.append(u'&lt;')\n\t\t\tsb.append(x.replace(u'>', u'&gt;'))\n\n\t\t# Close off any remaining tags\n\t\twhile tagstack:\n\t\t\tt = tagstack.pop()\n\t\t\tsb.append(u'</')\n\t\t\tsb.append(t)\n\t\t\tsb.append(u'>\\n')\n\t\t\tif t == u'table':\n\t\t\t\tif not tablestack:\n\t\t\t\t\tbreak\n\t\t\t\ttagstack = tablestack.pop()\n\n\t\treturn u''.join(sb)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove html comments from given text", "response": "def removeHtmlComments(self, text):\n\t\t\"\"\"remove <!-- text --> comments from given text\"\"\"\n\t\tsb = []\n\t\tstart = text.find(u'<!--')\n\t\tlast = 0\n\t\twhile start != -1:\n\t\t\tend = text.find(u'-->', start)\n\t\t\tif end == -1:\n\t\t\t\tbreak\n\t\t\tend += 3\n\n\t\t\tspaceStart = max(0, start-1)\n\t\t\tspaceEnd = end\n\t\t\twhile text[spaceStart] == u' ' and spaceStart > 0:\n\t\t\t\tspaceStart -= 1\n\t\t\twhile text[spaceEnd] == u' ':\n\t\t\t\tspaceEnd += 1\n\n\t\t\tif text[spaceStart] == u'\\n' and text[spaceEnd] == u'\\n':\n\t\t\t\tsb.append(text[last:spaceStart])\n\t\t\t\tsb.append(u'\\n')\n\t\t\t\tlast = spaceEnd+1\n\t\t\telse:\n\t\t\t\tsb.append(text[last:spaceStart+1])\n\t\t\t\tlast = spaceEnd\n\n\t\t\tstart = text.find(u'<!--', end)\n\t\tsb.append(text[last:])\n\t\treturn u''.join(sb)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract all occurrences of HTML - style comments and the given tags and parameters from the given text.", "response": "def extractTagsAndParams(self, elements, text, matches):\n\t\t\"\"\"\n\t\tReplaces all occurrences of HTML-style comments and the given tags\n\t\tin the text with a random marker and returns teh next text. The output\n\t\tparameter $matches will be an associative array filled with data in\n\t\tthe form:\n\t\t  'UNIQ-xxxxx' => array(\n\t\t  'element',\n\t\t  'tag content',\n\t\t  array( 'param' => 'x' ),\n\t\t  '<element param=\"x\">tag content</element>' ) )\n\t\t\"\"\"\n\t\tstripped = u''\n\n\t\ttaglist = u'|'.join(elements)\n\t\tif taglist not in _startRegexHash:\n\t\t\t_startRegexHash[taglist] = re.compile(ur\"<(\" + taglist + ur\")(\\s+[^>]*?|\\s*?)(/?>)|<(!--)\", re.UNICODE | re.IGNORECASE)\n\t\tstart = _startRegexHash[taglist]\n\n\t\twhile text != u'':\n\t\t\tp = start.split(text, 1)\n\t\t\tstripped += p[0]\n\t\t\tif len(p) == 1:\n\t\t\t\tbreak\n\t\t\telif p[4]:\n\t\t\t\t# comment\n\t\t\t\telement = p[4]\n\t\t\t\tattributes = u''\n\t\t\t\tclose = u''\n\t\t\telse:\n\t\t\t\telement = p[1]\n\t\t\t\tattributes = p[2]\n\t\t\t\tclose = p[3]\n\t\t\tinside = p[5]\n\n\t\t\tglobal _extractTagsAndParams_n\n\t\t\tmarker = self.uniq_prefix + u'-' + element + u'-' + (u\"%08X\" % _extractTagsAndParams_n) + u'-QINU'\n\t\t\t_extractTagsAndParams_n += 1\n\t\t\tstripped += marker\n\n\t\t\tif close == u'/>':\n\t\t\t\t# empty element tag, <tag />\n\t\t\t\tcontent = None\n\t\t\t\ttext = inside\n\t\t\t\ttail = None\n\t\t\telse:\n\t\t\t\tif element == u'!--':\n\t\t\t\t\tend = _endCommentPat\n\t\t\t\telse:\n\t\t\t\t\tif element not in _endRegexHash:\n\t\t\t\t\t\t_endRegexHash[element] = re.compile(ur'(</' + element + ur'\\s*>)', re.UNICODE | re.IGNORECASE)\n\t\t\t\t\tend = _endRegexHash[element]\n\t\t\t\tq = end.split(inside, 1)\n\t\t\t\tcontent = q[0]\n\t\t\t\tif len(q) < 3:\n\t\t\t\t\t# no end tag\n\t\t\t\t\ttail = ''\n\t\t\t\t\ttext = ''\n\t\t\t\telse:\n\t\t\t\t\ttail = q[1]\n\t\t\t\t\ttext = q[2]\n\n\t\t\tmatches[marker] = (\n\t\t\t\telement,\n\t\t\t\tcontent,\n\t\t\t\tself.decodeTagAttributes(attributes),\n\t\t\t\tu\"<\" + element + attributes + close + content + tail\n\t\t\t)\n\t\treturn stripped"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncleaning up special characters only run once next - to - last before doBlockLevels", "response": "def fixtags(self, text):\n\t\t\"\"\"Clean up special characters, only run once, next-to-last before doBlockLevels\"\"\"\n\t\t# french spaces, last one Guillemet-left\n\t\t# only if there is something before the space\n\t\ttext = _guillemetLeftPat.sub(ur'\\1&nbsp;\\2', text)\n\t\t# french spaces, Guillemet-right\n\t\ttext = _guillemetRightPat.sub(ur'\\1&nbsp;', text)\n\t\treturn text"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef closeParagraph(self, mLastSection):\n\t\tresult = u''\n\t\tif mLastSection != u'':\n\t\t\tresult = u'</' + mLastSection + u'>\\n'\n\n\t\treturn result", "response": "Used by doBlockLevels to close a paragraph."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getCommon(self, st1, st2):\n\t\tfl = len(st1)\n\t\tshorter = len(st2)\n\t\tif fl < shorter:\n\t\t\tshorter = fl\n\n\t\ti = 0\n\t\twhile i < shorter:\n\t\t\tif st1[i] != st2[i]:\n\t\t\t\tbreak\n\t\t\ti += 1\n\t\treturn i", "response": "getCommon - returns the length of the longest common substring of two strings"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef openList(self, char, mLastSection):\n\t\tresult = self.closeParagraph(mLastSection)\n\n\t\tmDTopen = False\n\t\tif char == u'*':\n\t\t\tresult += u'<ul><li>'\n\t\telif char == u'#':\n\t\t\tresult += u'<ol><li>'\n\t\telif char == u':':\n\t\t\tresult += u'<dl><dd>'\n\t\telif char == u';':\n\t\t\tresult += u'<dl><dt>'\n\t\t\tmDTopen = True\n\t\telse:\n\t\t\tresult += u'<!-- ERR 1 -->'\n\n\t\treturn result, mDTopen", "response": "This method opens the list element appropriate to the prefix character passed into it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_valid_package_module_name(name):\n    if \".\" in name:\n        for part in name.split(\".\"):\n            if not is_valid_package_module_name(part):\n                return False\n    elif len(name):\n        if name[0] not in _first_letter_for_valid_name:\n            return False\n\n        if len(set(name).difference(_char_set_for_valid_name)):\n            return False\n    else:\n        return False\n    return True", "response": "Test whether the given name is a valid package or module name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the variables self. _scalers and self. _intensity_scalers as given by self. scalers.", "response": "def _set_scalers(self):\n        \"\"\"\n        Set the variables self._scalers as given by self.scalers,\n        if self.scalers is None, then a default value is used.\n        \"\"\"\n\n        # Set default value for rep_scalers if None\n        if self.rep_scalers is None:\n            # Draw self-repellent numbers from domain\n            domain = [0.8, 1, 1.2]\n            gen = RepellentGenerator(domain)\n            self._rep_scalers = list(gen.yield_from_domain(self.duration))\n        else:\n            if len(self.rep_scalers) != self.duration:\n                raise ProgramError(\n                    'Length of `rep_scalers` must match program duration.')\n            self._rep_scalers = self.rep_scalers\n\n        # Set default value for intensity_scalers if None\n        if self.intensity_scalers is None:\n            # Draw self-repellent numbers from domain\n            domain = [0.95, 1, 1.05]\n            gen = RepellentGenerator(domain)\n            self._intensity_scalers = list(gen.yield_from_domain(self.duration))\n        else:\n            if len(self.intensity_scalers) != self.duration:\n                raise ProgramError(\n                    'Length of `intensity_scalers` must match program duration.')\n            self._intensity_scalers = self.intensity_scalers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the sensible base values for the current training program.", "response": "def _validate(self):\n        \"\"\"\n        The purpose of this method is to verify that the user has set sensible\n        values for the training program before rendering. The user will still\n        be able to render, but error messages will be printed. This method:\n            \n            * Validates that the average intensity is in the range [65, 85].\n            * Validates that the number of repetitions is in the range [15, 45].\n            * Validates that 'reps_to_intensity_func' maps to [0, 100].\n            * Validates that 'reps_to_intensity_func' is a decreasing function.\n            * Validates that the exercises do not grow more than 2.5% per week.\n            \n        Apart from these sanity checks, the user is on his own.\n        \"\"\"\n        # Validate the intensity\n        if max([s * self.intensity for s in self._intensity_scalers]) > 85:\n            warnings.warn('\\nWARNING: Average intensity is > 85.')\n\n        if min([s * self.intensity for s in self._intensity_scalers]) < 65:\n            warnings.warn('\\nWARNING: Average intensity is < 65.')\n\n        # Validate the repetitions\n        if max([s * self.reps_per_exercise for s in self._rep_scalers]) > 45:\n            warnings.warn('\\nWARNING: Number of repetitions > 45.')\n\n        if min([s * self.reps_per_exercise for s in self._rep_scalers]) < 15:\n            warnings.warn('\\nWARNING: Number of repetitions < 15.')\n\n        # Validate the 'reps_to_intensity_func'\n        for x1, x2 in zip(range(1, 20), range(2, 21)):\n            y1 = self.reps_to_intensity_func(x1)\n            y2 = self.reps_to_intensity_func(x2)\n            if y1 < y2:\n                warnings.warn(\"\\n'reps_to_intensity_func' is not decreasing.\")\n\n        if any(self.reps_to_intensity_func(x) > 100 for x in range(1, 20)):\n            warnings.warn(\"\\n'reps_to_intensity_func' maps to > 100.\")\n\n        if any(self.reps_to_intensity_func(x) < 0 for x in range(1, 20)):\n            warnings.warn(\"\\n'reps_to_intensity_func' maps to < 0.\")\n\n        # Validate the exercises\n        for day in self.days:\n            for dynamic_ex in day.dynamic_exercises:\n                start, end = dynamic_ex.start_weight, dynamic_ex.final_weight\n                percentage_growth = (end / start) ** (1 / self.duration)\n                percentage_growth = dynamic_ex.weekly_growth(self.duration)\n                if percentage_growth > 4:\n                    msg = '\\n\"{}\" grows with {}% each week.'.format(\n                        dynamic_ex.name, percentage_growth)\n                    warnings.warn(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd one or several days to the program.", "response": "def add_days(self, *days):\n        \"\"\"Add one or several days to the program.\n    \n        Parameters\n        ----------\n        *days\n            Unpacked tuple containing\n            :py:class:`streprogen.Day` instances.\n    \n    \n        Examples\n        -------\n        >>> program = Program('My training program')\n        >>> day1, day2 = Day(), Day()\n        >>> program.add_days(day1, day2)\n        \"\"\"\n        for day in list(days):\n            self.days.append(day)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef repstring_penalty(reps, intensities, desired_reps, desired_intensity,\n                          minimum_rep):\n        \"\"\"Penalty function which calculates how \"bad\" a set of\n        reps and intensities is, compared to the desired repetitions,\n        the desired intensity level and the minimum repetitions.\n        Advanced users may substitute this function for their own version.\n    \n        Parameters\n        ----------\n        reps\n            A list of repetitions (sorted), e.g. [8, 6, 5, 2].\n        intensities\n            A list of intensities corresponding to the repetitions,\n            e.g. [64.7, 72.3, 76.25, 88.7].\n        desired_reps\n            Desired number of repetitions in total, e.g. 25.\n        desired_intensity\n            The desired average intensity, e.g. 75.\n        minimum_rep\n            The minimum repetition which is allowed, e.g. 2.\n    \n    \n        Returns\n        -------\n        float\n            A penalty, a positive real number.\n    \n    \n        Examples\n        -------\n        >>> desired_reps = 25\n        >>> desired_intensity = 75\n        >>> minimum_rep = 1\n        >>> high = Program().repstring_penalty([8, 8, 8], [60, 60, 60], \n        ...                              desired_reps, desired_intensity, \n        ...                              minimum_rep)\n        >>> low = Program().repstring_penalty([8, 6, 5, 4, 2], [64, 72, 75, 80, 88], \n        ...                              desired_reps, desired_intensity, \n        ...                              minimum_rep)\n        >>> high > low\n        True\n        \"\"\"\n        # Punish when the mean intensity is far from the desired one\n        desired = desired_intensity\n        error1 = abs(statistics.mean(intensities) - desired)\n\n        # Punish when the repetitions are far from the desired amount\n        error2 = abs(sum(reps) - desired_reps)\n\n        # Punish when the spread of repetitions is large\n        error3 = spread(reps)\n\n        # Punish deviation from the minimum reptition\n        error4 = abs(min(reps) - minimum_rep)\n\n        # Take a linear combination and return\n        return sum([2 * error1, 0.5 * error2, 2.5 * error3, 0.5 * error4])", "response": "This function calculates the penalty of a set of repetitions and intensities for a particular set of repetitions and intensity level."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrendering a single dynamic exercise.", "response": "def _render_dynamic(self, dynamic_exercise, min_rep,\n                        desired_reps, desired_intensity, validate):\n        \"\"\"\n        Render a single dynamic exercise.\n        This is done for each exercise every week.\n        \"\"\"\n\n        # --------------------------------\n        # Generate possible repstring and calculate penalties\n        # --------------------------------\n        repstrings = []\n        for k in range(self.TIMES_TO_RENDER):\n\n            # If going to minimum, add the minimum repetition to the reps\n            if self.go_to_min:\n                reps = generate_reps(min_rep,\n                                     dynamic_exercise.max_reps,\n                                     desired_reps - min_rep,\n                                     [min_rep])\n            else:\n                reps = generate_reps(min_rep,\n                                     dynamic_exercise.max_reps,\n                                     desired_reps)\n\n            # Calculate the penalty\n            intensities = list(map(self.reps_to_intensity_func, reps))\n\n            pargs = reps, intensities, desired_reps, desired_intensity, min_rep\n            penalty_value = self.repstring_penalty(*pargs)\n\n            repstrings.append((penalty_value, reps, intensities))\n\n        # --------------------------------\n        # Find the best generated repstring and verify it\n        # --------------------------------\n        best_repstring = min(repstrings)\n        (penalty_value, reps, intensities) = best_repstring\n\n        # Perform a sanity check:\n        # If repetitions are too high, a low average intensity cannot be attained\n        if desired_intensity > self.reps_to_intensity_func(min_rep) and validate:\n            msg = \"\"\"\nWARNING: The exercise '{}' is restricted to repetitions in the range [{}, {}],\nbut the desired average intensity for this week is {}. Reaching this intensity\nis not attainable since it corresponds to repetitions lower than {}.\nSOLUTION: Either (1) allow lower repetitions, (2) change the desired intensity\nor (3) ignore this message. The software will do it's best to remedy this.\n\"\"\".format(dynamic_exercise.name, dynamic_exercise.max_reps, min_rep,\n           desired_intensity, min_rep)\n            warnings.warn(msg)\n\n        # Perform a sanity check:\n        # If repetitions are too low, a high average intensity cannot be attained\n        if desired_intensity < self.reps_to_intensity_func(\n                dynamic_exercise.max_reps) and validate:\n            msg = \"\"\"\nWARNING: The exercise '{}' is restricted to repetitions in the range [{}, {}],\nbut the desired average intensity for this week is {}. Reaching this intensity\nis not attainable since it corresponds to repetitions higher than {}.\nSOLUTION: Either (1) allow higher repetitions, (2) change the desired intensity\nor (3) ignore this message. The software will do it's best to remedy this.\n\"\"\".format(dynamic_exercise.name, dynamic_exercise.max_reps, min_rep,\n           desired_intensity, dynamic_exercise.max_reps)\n            warnings.warn(msg)\n\n        return {'reps': reps, 'intensities': intensities}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _initialize_render_dictionary(self):\n\n        self._rendered = dict()\n\n        # Iterate over all weeks\n        for week in range(1, self.duration + 1):\n            self._rendered[week] = dict()\n\n            # Iterate over all days\n            for day in self.days:\n                self._rendered[week][day] = dict()\n\n                # Iterate over all main exercises\n                for dynamic_ex in day.dynamic_exercises:\n                    self._rendered[week][day][dynamic_ex] = dict()", "response": "Initialize a dictionary for rendered values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_min_reps(self):\n\n        min_percent = self.minimum_percentile\n        # --------------------------------\n        # If the mode is weekly, set minimum reps on a weekly basis\n        # --------------------------------\n        if self._min_reps_consistency == 'weekly':\n\n            # Set up generator. Only one is needed\n            exercise = self.days[0].dynamic_exercises[0]\n            margs = exercise.min_reps, exercise.max_reps, min_percent\n            low, high = min_between(*margs)\n            generator = RepellentGenerator(list(range(low, high + 1)))\n\n            # Use generator to populate the dictionary with minimum values\n            for week in range(1, self.duration + 1):\n                min_rep_week = generator.generate_one()\n                for day in self.days:\n                    for d_ex in day.dynamic_exercises:\n                        self._rendered[week][day][d_ex]['minimum'] = min_rep_week\n\n        # --------------------------------\n        # If the mode is daily, set minimum reps on a daily basis\n        # --------------------------------\n        if self._min_reps_consistency == 'daily':\n\n            # Set up generators. One is needed for each day\n            generators = dict()\n            for day in self.days:\n                exercise = day.dynamic_exercises[0]\n                margs = exercise.min_reps, exercise.max_reps, min_percent\n                low, high = min_between(*margs)\n                generator = RepellentGenerator(list(range(low, high + 1)))\n                generators[day] = generator\n\n            # Use generators to populate the dictionary with minimum values\n            for week in range(1, self.duration + 1):\n                for day in self.days:\n                    min_rep_day = generators[day].generate_one()\n                    for d_ex in day.dynamic_exercises:\n                        self._rendered[week][day][d_ex]['minimum'] = min_rep_day\n\n        # --------------------------------\n        # If the mode is by exercise, set minimum reps on an exercise basis\n        # --------------------------------           \n        if self._min_reps_consistency == 'exercise':\n\n            # Set up generators. One is needed for each exercise\n            generators = dict()\n            for day in self.days:\n                for d_ex in day.dynamic_exercises:\n                    margs = d_ex.min_reps, d_ex.max_reps, min_percent\n                    low, high = min_between(*margs)\n                    generator = RepellentGenerator(list(range(low, high + 1)))\n                    generators[d_ex] = generator\n\n            # Use generators to populate the dictionary with minimum values\n            for week in range(1, self.duration + 1):\n                for day in self.days:\n                    for d_ex in day.dynamic_exercises:\n                        min_rep_ex = generators[d_ex].generate_one()\n                        self._rendered[week][day][d_ex]['minimum'] = min_rep_ex", "response": "Populate the _rendered dictionary with entries corresponding\n        to the minimum number of reps to go to for each exercise and for the entire duration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _yield_week_day_dynamic(self):\n        # Iterate over all weeks\n        for week in range(1, self.duration + 1):\n            # Iterate over all days\n            for day in self.days:\n                # Iterate over all main exercises\n                for dynamic_ex in day.dynamic_exercises:\n                    yield (week, day, dynamic_ex)", "response": "Yields the week day and exercises that are dynamic."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _yield_week_day(self, enumeration=False):\n        if enumeration:\n            # Iterate over all weeks\n            for week in range(1, self.duration + 1):\n                # Iterate over all days\n                for day_index, day in enumerate(self.days):\n                    yield (week, day_index, day)\n        else:\n            # Iterate over all weeks\n            for week in range(1, self.duration + 1):\n                # Iterate over all days\n                for day in self.days:\n                    yield (week, day)", "response": "Yields the week day of the current state of the entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nyield the exercises in the program.", "response": "def _yield_exercises(self):\n        \"\"\"A helper function to reduce the number of nested loops.\n        \n\n        Yields\n        -------\n        (dynamic_ex) or (static_ex)\n            Yields the exercises in the program.\n\n        \"\"\"\n        for day in self.days:\n            for dynamic_ex in day.dynamic_exercises:\n                yield dynamic_ex\n            for static_ex in day.static_exercises:\n                yield static_ex"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenders the training program to produce the new training dictionary.", "response": "def render(self, validate=True):\n        \"\"\"Render the training program to perform the calculations.\n        The program can be rendered several times to produce new\n        information given the same input parameters.\n    \n        Parameters\n        ----------\n        validate\n            Boolean that indicates whether or not to run a validation\n            heurestic on the program before rendering. The validation\n            will warn the user if inputs seem unreasonable.\n\n        \"\"\"\n\n        # --------------------------------\n        # Prepare for rendering the dynamic exercises\n        # --------------------------------\n\n        # Set the minimum repetitions consistency mode,\n        # which is either 'weekly', 'daily' or 'exercise'\n        self._autoset_min_reps_consistency()\n\n        # Initialize the structure of the _rendered dictionary\n        self._initialize_render_dictionary()\n\n        # Set the day names\n        for i, day in enumerate(self.days):\n            day.name = prioritized_not_None(day.name, 'Day {}'.format(i + 1))\n\n        # Set the minimum reps per week in the render dictionary\n        self._set_min_reps()\n\n        # Set the scalers\n        self._set_scalers()\n\n        # Validate the program if the user wishes to validate\n        if validate:\n            self._validate()\n\n        # --------------------------------\n        # Render the dynamic exercises\n        # --------------------------------\n\n        for (week, day, dyn_ex) in self._yield_week_day_dynamic():\n\n            # The minimum repeition to work up to\n            min_rep = self._rendered[week][day][dyn_ex]['minimum']\n\n            # The desired repetitions to work up to\n            local_r, global_r = dyn_ex.reps, self.reps_per_exercise\n            total_reps = prioritized_not_None(local_r, global_r)\n            desired_reps = total_reps * self._rep_scalers[week - 1]\n            self._rendered[week][day][dyn_ex]['desired_reps'] = int(\n                desired_reps)\n\n            # The desired intensity to work up to\n            local_i, global_i = dyn_ex.intensity, self.intensity\n            intensity_unscaled = prioritized_not_None(local_i, global_i)\n            scale_factor = self._intensity_scalers[week - 1]\n            desired_intensity = intensity_unscaled * scale_factor\n            self._rendered[week][day][dyn_ex]['desired_intensity'] = int(desired_intensity)\n\n            # A dictionary is returned with keys 'reps' and 'intensities'\n            render_args = dyn_ex, min_rep, desired_reps, desired_intensity, validate\n            out = self._render_dynamic(*render_args)\n\n            # Calculate the 1RM at this point in time\n            start_w, final_w = dyn_ex.start_weight, dyn_ex.final_weight\n            args = (week, start_w, final_w, 1, self.duration)\n            weight = self.progression_func(*args)\n\n            # Define a function to prettify the weights\n            def pretty_weight(weight, i, round_function):\n                weight = round_function(weight * i / 100)\n                if weight % 1 == 0:\n                    return int(weight)\n                return weight\n\n            # Use the local rounding function if available,\n            # if not use the global rounding function\n            round_func = prioritized_not_None(dyn_ex.round, self.round)\n\n            # Create pretty strings\n            tuple_generator = zip(out['intensities'], out['reps'])\n            pretty_gen = ((str(r), str(pretty_weight(weight, i, round_func)) +\n                           self.units) for (i, r) in tuple_generator)\n            joined_gen = (self.REP_SET_SEP.join(list(k)) for k in pretty_gen)\n\n            out['strings'] = list(joined_gen)\n\n            # The _rendered dictionary has keys\n            # ['minimum', 'desired_reps', 'desired_intensity'].\n            # Update with the ['intensities', 'reps', 'strings'] keys\n            self._rendered[week][day][dyn_ex].update(out)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset up the jinja2 environment.", "response": "def _set_jinja2_enviroment(self):\n        \"\"\"\n        Set up the jinja2 environment.\n        \"\"\"\n\n        template_loader = FileSystemLoader(searchpath=self.TEMPLATE_DIR)\n\n        env = Environment(loader=template_loader, trim_blocks=True,\n                          lstrip_blocks=True)\n        env.globals.update(chunker=chunker, enumerate=enumerate, str = str)\n\n        # Add filters to the environment\n        round2digits = functools.partial(round_to_nearest, nearest=0.1)\n        env.filters['round2digits'] = round2digits\n        env.filters['mean'] = statistics.mean\n\n        self.jinja2_environment = env"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_html(self, table_width=5):\n\n        env = self.jinja2_environment\n        template = env.get_template(self.TEMPLATE_NAMES['html'])\n        return template.render(program=self, table_width=table_width)", "response": "Write the program information to HTML code which can be saved and brought to the gym."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting the program information to text.", "response": "def to_txt(self, verbose=False):\n        \"\"\"Write the program information to text,\n        which can be printed in a terminal.\n\n        Parameters\n        ----------\n        verbose\n            If True, more information is shown.\n\n        Returns\n        -------\n        string\n            Program as text.\n        \"\"\"\n        # Get information related to formatting\n        exercises = list(self._yield_exercises())\n        max_ex_name = 0\n        if len(exercises) != 0:\n            max_ex_name = max(len(ex.name) for ex in exercises)\n\n        # If rendered, find the length of the longest '6 x 75kg'-type string\n        max_ex_scheme = 0\n        if self._rendered:\n            for (week, day, dynamic_ex) in self._yield_week_day_dynamic():\n                lengths = [len(s) for s in\n                           self._rendered[week][day][dynamic_ex]['strings']]\n                max_ex_scheme = max(max_ex_scheme, max(lengths))\n\n\n        env = self.jinja2_environment\n        template = env.get_template(self.TEMPLATE_NAMES['txt'])\n        return template.render(program=self, max_ex_name=max_ex_name,\n                               max_ex_scheme=max_ex_scheme, verbose=verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the program information to a. tex file.", "response": "def to_tex(self, text_size='large', table_width=5, clear_pages = False):\n        \"\"\"\n        Write the program information to a .tex file, which can be\n        rendered to .pdf running pdflatex. The program can then be\n        printed and brought to the gym.\n\n        Parameters\n        ----------\n        text_size\n            The tex text size, e.g. '\\small', 'normalsize', 'large', 'Large'\n            or 'LARGE'.\n\n        table_width\n            The table with of the .tex code.\n\n        Returns\n        -------\n        string\n            Program as tex.\n        \"\"\"\n\n        # If rendered, find the length of the longest '6 x 75kg'-type string\n        max_ex_scheme = 0\n        if self._rendered:\n            for (week, day, dynamic_ex) in self._yield_week_day_dynamic():\n                lengths = [len(s) for s in\n                           self._rendered[week][day][dynamic_ex]['strings']]\n                max_ex_scheme = max(max_ex_scheme, max(lengths))\n\n\n        env = self.jinja2_environment\n        template = env.get_template(self.TEMPLATE_NAMES['tex'])\n\n        return template.render(program=self, text_size=text_size,\n                               table_width=table_width, clear_pages = clear_pages)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the program mode to weekly daily or excise if possible.", "response": "def _autoset_min_reps_consistency(self):\n        \"\"\"\n        Sets the program mode to 'weekly', 'daily' or 'exercise'\n        by automatically iterating over all exercises.\n        \"\"\"\n\n        # -------------------------------------------\n        # Set automatically by investigating program\n        # -------------------------------------------\n\n        # Check whether the mode is WEEKLY\n        min_reps, max_reps = [], []\n        for day in self.days:\n            for dynamic_ex in day.dynamic_exercises:\n                min_reps.append(dynamic_ex.min_reps)\n                max_reps.append(dynamic_ex.max_reps)\n        if all_equal(min_reps) and all_equal(max_reps):\n            self._min_reps_consistency = 'weekly'\n            return None\n\n        # Check if mode is DAILY\n        for day in self.days:\n            min_reps, max_reps = [], []\n            for dynamic_ex in day.dynamic_exercises:\n                min_reps.append(dynamic_ex.min_reps)\n                max_reps.append(dynamic_ex.max_reps)\n            if not all_equal(min_reps) or not all_equal(max_reps):\n                self._min_reps_consistency = 'exercise'\n                return None\n        self._min_reps_consistency = 'daily'\n\n        # -------------------------------------------\n        # Respect user wishes if possible\n        # -------------------------------------------\n\n        # Set the minimum consistency mode of the program\n        if self.min_reps_consistency is not None:\n\n            # Make sure the user defined consistency mode is\n            # never more broad than what is allowed by inputs\n            if (self._min_reps_consistency == 'exercise' and\n                        self.min_reps_consistency != 'exercise'):\n                raise ProgramError(\"Error with 'min_reps_consistency'.\")\n\n            if (self._min_reps_consistency == 'daily' and\n                        self.min_reps_consistency == 'weekly'):\n                raise ProgramError(\"Error with 'min_reps_consistency'.\")\n\n            self._min_reps_consistency = self.min_reps_consistency"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_match(self, match_key, match_value):\n        if match_key is None:\n            raise errors.NullArgument()\n        self._query_terms[match_key] = str(match_key) + '=' + str(match_value)", "response": "Adds a match key and value to the query terms dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_records(self, record_type_idstrs):\n        for record_type_idstr in record_type_idstrs:\n            try:\n                self._init_record(record_type_idstr)\n            except (ImportError, KeyError):\n                pass", "response": "Loads query records from the given record type idstrs."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize a query record", "response": "def _init_record(self, record_type_idstr):\n        \"\"\"Initializes a query record\"\"\"\n        record_type_data = self._all_supported_record_type_data_sets[Id(record_type_idstr).get_identifier()]\n        module = importlib.import_module(record_type_data['module_path'])\n        record = getattr(module, record_type_data['query_record_class_name'])\n        self._records[record_type_idstr] = record(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match_display_name(self, display_name=None, string_match_type=None, match=None):\n        self._match_display_text('displayName', display_name, string_match_type, match)", "response": "Adds a display name to match."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a description name to match.", "response": "def match_description(self, description=None, string_match_type=None, match=None):\n        \"\"\"Adds a description name to match.\n\n        Multiple description matches can be added to perform a boolean\n        ``OR`` among them.\n\n        arg:    description (string): description to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n        raise:  InvalidArgument - ``description`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``description`` or ``string_match_type``\n                is ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._match_display_text('description', description, string_match_type, match)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the underlying book view to match current view", "response": "def _set_book_view(self, session):\n        \"\"\"Sets the underlying book view to match current view\"\"\"\n        if self._book_view == COMPARATIVE:\n            try:\n                session.use_comparative_book_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_book_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider CommentBookSession. use_comparative_book_view", "response": "def use_comparative_book_view(self):\n        \"\"\"Pass through to provider CommentBookSession.use_comparative_book_view\"\"\"\n        self._book_view = COMPARATIVE\n        # self._get_provider_session('comment_book_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_book_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef use_plenary_book_view(self):\n        self._book_view = PLENARY\n        # self._get_provider_session('comment_book_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_book_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider CommentBookSession. use_plenary_book_view"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_books_by_comment(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        catalogs = self._get_provider_session('comment_book_session').get_books_by_comment(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Book(self._provider_manager, cat, self._runtime, self._proxy))\n        return BookList(cat_list)", "response": "Pass through to provider CommentBookSession. get_books_by_comment"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider BookLookupSession. get_books", "response": "def get_books(self):\n        \"\"\"Pass through to provider BookLookupSession.get_books\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('book_lookup_session').get_books()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Book(self._provider_manager, cat, self._runtime, self._proxy))\n        return BookList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider BookAdminSession. create_book", "response": "def create_book(self, *args, **kwargs):\n        \"\"\"Pass through to provider BookAdminSession.create_book\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.create_bin\n        return Book(\n            self._provider_manager,\n            self._get_provider_session('book_admin_session').create_book(*args, **kwargs),\n            self._runtime,\n            self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_book_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'book_record_types' in kwargs:\n            return self.get_book_form_for_create(*args, **kwargs)\n        else:\n            return self.get_book_form_for_update(*args, **kwargs)", "response": "Pass through to provider BookAdminSession. get_book_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider BookAdminSession. update_book", "response": "def save_book(self, book_form, *args, **kwargs):\n        \"\"\"Pass through to provider BookAdminSession.update_book\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if book_form.is_for_update():\n            return self.update_book(book_form, *args, **kwargs)\n        else:\n            return self.create_book(book_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the underlying book view to match current view", "response": "def _set_book_view(self, session):\n        \"\"\"Sets the underlying book view to match current view\"\"\"\n        if self._book_view == FEDERATED:\n            try:\n                session.use_federated_book_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_book_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_comparative_comment_view(self):\n        self._object_views['comment'] = COMPARATIVE\n        # self._get_provider_session('comment_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_comment_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider CommentLookupSession. use_comparative_comment_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider CommentLookupSession. use_plenary_comment_view", "response": "def use_plenary_comment_view(self):\n        \"\"\"Pass through to provider CommentLookupSession.use_plenary_comment_view\"\"\"\n        self._object_views['comment'] = PLENARY\n        # self._get_provider_session('comment_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_comment_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider CommentLookupSession. use_federated_book_view", "response": "def use_federated_book_view(self):\n        \"\"\"Pass through to provider CommentLookupSession.use_federated_book_view\"\"\"\n        self._book_view = FEDERATED\n        # self._get_provider_session('comment_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_federated_book_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npasses through to provider CommentLookupSession. use_isolated_book_view", "response": "def use_isolated_book_view(self):\n        \"\"\"Pass through to provider CommentLookupSession.use_isolated_book_view\"\"\"\n        self._book_view = ISOLATED\n        # self._get_provider_session('comment_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_isolated_book_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_comment_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'comment_record_types' in kwargs:\n            return self.get_comment_form_for_create(*args, **kwargs)\n        else:\n            return self.get_comment_form_for_update(*args, **kwargs)", "response": "Pass through to provider CommentAdminSession. get_comment_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_comment(self, comment_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if comment_form.is_for_update():\n            return self.update_comment(comment_form, *args, **kwargs)\n        else:\n            return self.create_comment(comment_form, *args, **kwargs)", "response": "Pass through to provider CommentAdminSession. update_comment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the Objective specified by its Id.", "response": "def get_objective(self, objective_id):\n        \"\"\"Gets the ``Objective`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Objective`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to an ``Objective`` and retained\n        for compatibility.\n\n        arg:    objective_id (osid.id.Id): ``Id`` of the ``Objective``\n        return: (osid.learning.Objective) - the objective\n        raise:  NotFound - ``objective_id`` not found\n        raise:  NullArgument - ``objective_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(objective_id, 'learning').get_identifier())},\n                 **self._view_filter()))\n        return objects.Objective(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget an ObjectiveList corresponding to the given IdList.", "response": "def get_objectives_by_ids(self, objective_ids):\n        \"\"\"Gets an ``ObjectiveList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the\n        objectives specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Objectives`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set.\n\n        arg:    objective_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n        return: (osid.learning.ObjectiveList) - the returned\n                ``Objective`` list\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``objective_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in objective_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'learning').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.ObjectiveList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objectives_by_genus_type(self, objective_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(objective_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.ObjectiveList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an ObjectiveList corresponding to the given objective genus Type which does not include objectives of genus types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all Objectives in the current session.", "response": "def get_objectives(self):\n        \"\"\"Gets all ``Objectives``.\n\n        In plenary mode, the returned list contains all known objectives\n        or an error results. Otherwise, the returned list may contain\n        only those objectives that are accessible through this session.\n\n        return: (osid.learning.ObjectiveList) - an ``ObjectiveList``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.ObjectiveList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_objectives_by_query(self, objective_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in objective_query._query_terms:\n            if '$in' in objective_query._query_terms[term] and '$nin' in objective_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': objective_query._query_terms[term]['$in']}},\n                             {term: {'$nin': objective_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: objective_query._query_terms[term]})\n        for term in objective_query._keyword_terms:\n            or_list.append({term: objective_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('learning',\n                                             collection='Objective',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.ObjectiveList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of Objectives matching the given objective query."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objective_form_for_create(self, objective_record_types):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in objective_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if objective_record_types == []:\n            obj_form = objects.ObjectiveForm(\n                objective_bank_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.ObjectiveForm(\n                objective_bank_id=self._catalog_id,\n                record_types=objective_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the objective form for creating new objectives."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_objective(self, objective_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        if not isinstance(objective_form, ABCObjectiveForm):\n            raise errors.InvalidArgument('argument type is not an ObjectiveForm')\n        if objective_form.is_for_update():\n            raise errors.InvalidArgument('the ObjectiveForm is for update only, not create')\n        try:\n            if self._forms[objective_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('objective_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('objective_form did not originate from this session')\n        if not objective_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(objective_form._my_map)\n\n        self._forms[objective_form.get_id().get_identifier()] = CREATED\n        result = objects.Objective(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new Objective."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_objective_form_for_update(self, objective_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update_template\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        if not isinstance(objective_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        if (objective_id.get_identifier_namespace() != 'learning.Objective' or\n                objective_id.get_authority() != self._authority):\n            raise errors.InvalidArgument()\n        result = collection.find_one({'_id': ObjectId(objective_id.get_identifier())})\n\n        obj_form = objects.ObjectiveForm(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not UPDATED\n\n        return obj_form", "response": "Gets the objective form for updating an existing objective."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate an existing objective.", "response": "def update_objective(self, objective_form):\n        \"\"\"Updates an existing objective.\n\n        arg:    objective_form (osid.learning.ObjectiveForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - ``objective_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``objective_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``objective_form`` did not originate from\n                ``get_objective_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        if not isinstance(objective_form, ABCObjectiveForm):\n            raise errors.InvalidArgument('argument type is not an ObjectiveForm')\n        if not objective_form.is_for_update():\n            raise errors.InvalidArgument('the ObjectiveForm is for update only, not create')\n        try:\n            if self._forms[objective_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('objective_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('objective_form did not originate from this session')\n        if not objective_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(objective_form._my_map)\n\n        self._forms[objective_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Objective(\n            osid_object_map=objective_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_objective(self, objective_id):\n        # Implemented from template for\n        # osid.learning.ObjectiveAdminSession.delete_objective_template\n\n        if not isinstance(objective_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        if collection.find({'objectiveId': str(objective_id)}).count() != 0:\n            raise errors.IllegalState('there are still Activitys associated with this Objective')\n\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        collection.delete_one({'_id': ObjectId(objective_id.get_identifier())})", "response": "Deletes the Objective identified by the given Id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef alias_objective(self, objective_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=objective_id, equivalent_id=alias_id)", "response": "Adds an Id to an Objective for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_root_objectives(self):\n        # Implemented from template for\n        # osid.ontology.SubjectHierarchySession.get_root_subjects_template\n        root_ids = self._hierarchy_session.get_roots()\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'_id': {'$in': [ObjectId(root_id.get_identifier()) for root_id in root_ids]}},\n                 **self._view_filter()))\n        return objects.ObjectiveList(\n            result,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Gets the root objective in this objective hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_child_objectives(self, objective_id):\n        # Implemented from template for\n        # osid.ontology.SubjectHierarchySession.get_child_subjects_template\n        if self._hierarchy_session.has_children(objective_id):\n            child_ids = self._hierarchy_session.get_children(objective_id)\n            collection = JSONClientValidated('learning',\n                                             collection='Objective',\n                                             runtime=self._runtime)\n            result = collection.find(\n                dict({'_id': {'$in': [ObjectId(child_id.get_identifier()) for child_id in child_ids]}},\n                     **self._view_filter()))\n            return objects.ObjectiveList(\n                result,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        raise errors.IllegalState('no children')", "response": "Gets the children of the given objective."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_child_objective(self, objective_id, child_id):\n        # Implemented from template for\n        # osid.ontology.SubjectHierarchyDesignSession.add_child_subject_template\n        return self._hierarchy_session.add_child(id_=objective_id, child_id=child_id)", "response": "Adds a child to an objective."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_child_objective(self, objective_id, child_id):\n        # Implemented from template for\n        # osid.ontology.SubjectHierarchyDesignSession.remove_child_subject_template\n        return self._hierarchy_session.remove_child(id_=objective_id, child_id=child_id)", "response": "Removes a child from an objective."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_ids_by_objective_bank(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for objective in self.get_objectives_by_objective_bank(objective_bank_id):\n            id_list.append(objective.get_id())\n        return IdList(id_list)", "response": "Gets the list of Objective Ids associated with an ObjectiveBank."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_objectives_by_objective_bank(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_lookup_session_for_objective_bank(objective_bank_id, proxy=self._proxy)\n        lookup_session.use_isolated_objective_bank_view()\n        return lookup_session.get_objectives()", "response": "Gets the list of Objectives associated with an ObjectiveBank."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the list of Objective Ids corresponding to a list of ObjectiveBanks.", "response": "def get_objective_ids_by_objective_banks(self, objective_bank_ids):\n        \"\"\"Gets the list of ``Objective Ids`` corresponding to a list of ``ObjectiveBanks``.\n\n        arg:    objective_bank_ids (osid.id.IdList): list of objective\n                bank ``Ids``\n        return: (osid.id.IdList) - list of objective ``Ids``\n        raise:  NullArgument - ``objective_bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for objective in self.get_objectives_by_objective_banks(objective_bank_ids):\n            id_list.append(objective.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the list of Objectives corresponding to a list of ObjectiveBanks.", "response": "def get_objectives_by_objective_banks(self, objective_bank_ids):\n        \"\"\"Gets the list of ``Objectives`` corresponding to a list of ``ObjectiveBanks``.\n\n        arg:    objective_bank_ids (osid.id.IdList): list of objective\n                bank ``Ids``\n        return: (osid.learning.ObjectiveList) - list of objectives\n        raise:  NullArgument - ``objective_bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        objective_list = []\n        for objective_bank_id in objective_bank_ids:\n            objective_list += list(\n                self.get_objectives_by_objective_bank(objective_bank_id))\n        return objects.ObjectiveList(objective_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_bank_ids_by_objective(self, objective_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_objective_bank_view()\n        objective = lookup_session.get_objective(objective_id)\n        id_list = []\n        for idstr in objective._my_map['assignedObjectiveBankIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)", "response": "Gets the list of ObjectiveBank Ids mapped to an Objective."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the list of ObjectiveBanks mapped to an Objective.", "response": "def get_objective_banks_by_objective(self, objective_id):\n        \"\"\"Gets the list of ``ObjectiveBanks`` mapped to an ``Objective``.\n\n        arg:    objective_id (osid.id.Id): ``Id`` of an ``Objective``\n        return: (osid.learning.ObjectiveBankList) - list of objective\n                banks\n        raise:  NotFound - ``objective_id`` is not found\n        raise:  NullArgument - ``objective_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        return lookup_session.get_objective_banks_by_ids(\n            self.get_objective_bank_ids_by_objective(objective_id))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_assignable_objective_bank_ids(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.get_assignable_bin_ids\n        # This will likely be overridden by an authorization adapter\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        objective_banks = lookup_session.get_objective_banks()\n        id_list = []\n        for objective_bank in objective_banks:\n            id_list.append(objective_bank.get_id())\n        return IdList(id_list)", "response": "Gets a list of objective banks including and under the given objective bank node in which any objective can be assigned."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assign_objective_to_objective_bank(self, objective_id, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_objective_bank(objective_bank_id)  # to raise NotFound\n        self._assign_object_to_catalog(objective_id, objective_bank_id)", "response": "Adds an existing Objective to an ObjectiveBank."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove an Objective from an ObjectiveBank.", "response": "def unassign_objective_from_objective_bank(self, objective_id, objective_bank_id):\n        \"\"\"Removes an ``Objective`` from an ``ObjectiveBank``.\n\n        arg:    objective_id (osid.id.Id): the ``Id`` of the\n                ``Objective``\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                ``ObjectiveBank``\n        raise:  NotFound - ``objective_id`` or ``objective_bank_id`` not\n                found or ``objective_id`` not mapped to\n                ``objective_bank_id``\n        raise:  NullArgument - ``objective_id`` or ``objective_bank_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_objective_bank(objective_bank_id)  # to raise NotFound\n        self._unassign_object_from_catalog(objective_id, objective_bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reassign_proficiency_to_objective_bank(self, objective_id, from_objective_bank_id, to_objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.reassign_resource_to_bin\n        self.assign_objective_to_objective_bank(objective_id, to_objective_bank_id)\n        try:\n            self.unassign_objective_from_objective_bank(objective_id, from_objective_bank_id)\n        except:  # something went wrong, roll back assignment to to_objective_bank_id\n            self.unassign_objective_from_objective_bank(objective_id, to_objective_bank_id)\n            raise", "response": "Moves an Objective from one ObjectiveBank to another."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_requisite_objectives(self, objective_id):\n        # Implemented from template for\n        # osid.learning.ObjectiveRequisiteSession.get_requisite_objectives_template\n        # NOTE: This implementation currently ignores plenary view\n        requisite_type = Type(**Relationship().get_type_data('OBJECTIVE.REQUISITE'))\n        relm = self._get_provider_manager('RELATIONSHIP')\n        rls = relm.get_relationship_lookup_session(proxy=self._proxy)\n        rls.use_federated_family_view()\n        requisite_relationships = rls.get_relationships_by_genus_type_for_source(objective_id,\n                                                                                 requisite_type)\n        destination_ids = [ObjectId(r.get_destination_id().identifier)\n                           for r in requisite_relationships]\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        result = collection.find({'_id': {'$in': destination_ids}})\n        return objects.ObjectiveList(result, runtime=self._runtime)", "response": "Gets a list of Objectives that are the immediate requisites for the given Objective."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of Objectives that require the given Objective.", "response": "def get_dependent_objectives(self, objective_id):\n        \"\"\"Gets a list of ``Objectives`` that require the given ``Objective``.\n\n        In plenary mode, the returned list contains all of the immediate\n        requisites, or an error results if an Objective is not found or\n        inaccessible. Otherwise, inaccessible ``Objectives`` may be\n        omitted from the list and may present the elements in any order\n        including returning a unique set.\n\n        arg:    objective_id (osid.id.Id): ``Id`` of the ``Objective``\n        return: (osid.learning.ObjectiveList) - the returned\n                ``Objective`` list\n        raise:  NotFound - ``objective_id`` not found\n        raise:  NullArgument - ``objective_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.learning.ObjectiveRequisiteSession.get_dependent_objectives_template\n        # NOTE: This implementation currently ignores plenary view\n        requisite_type = Type(**Relationship().get_type_data('OBJECTIVE.REQUISITE'))\n        relm = self._get_provider_manager('RELATIONSHIP')\n        rls = relm.get_relationship_lookup_session(proxy=self._proxy)\n        rls.use_federated_family_view()\n        requisite_relationships = rls.get_relationships_by_genus_type_for_destination(objective_id,\n                                                                                      requisite_type)\n        source_ids = [ObjectId(r.get_source_id().identifier)\n                      for r in requisite_relationships]\n        collection = JSONClientValidated('learning',\n                                         collection='Objective',\n                                         runtime=self._runtime)\n        result = collection.find({'_id': {'$in': source_ids}})\n        return objects.ObjectiveList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a requirement dependency between two Objectives.", "response": "def assign_objective_requisite(self, objective_id, requisite_objective_id):\n        \"\"\"Creates a requirement dependency between two ``Objectives``.\n\n        arg:    objective_id (osid.id.Id): the ``Id`` of the dependent\n                ``Objective``\n        arg:    requisite_objective_id (osid.id.Id): the ``Id`` of the\n                required ``Objective``\n        raise:  AlreadyExists - ``objective_id`` already mapped to\n                ``requisite_objective_id``\n        raise:  NotFound - ``objective_id`` or\n                ``requisite_objective_id`` not found\n        raise:  NullArgument - ``objective_id`` or\n                ``requisite_objective_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        requisite_type = Type(**Relationship().get_type_data('OBJECTIVE.REQUISITE'))\n\n        ras = self._get_provider_manager(\n            'RELATIONSHIP').get_relationship_admin_session_for_family(\n            self.get_objective_bank_id(), proxy=self._proxy)\n        rfc = ras.get_relationship_form_for_create(objective_id, requisite_objective_id, [])\n        rfc.set_display_name('Objective Requisite')\n        rfc.set_description('An Objective Requisite created by the ObjectiveRequisiteAssignmentSession')\n        rfc.set_genus_type(requisite_type)\n        ras.create_relationship(rfc)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove an Objective requisite from an Objective.", "response": "def unassign_objective_requisite(self, objective_id, requisite_objective_id):\n        \"\"\"Removes an ``Objective`` requisite from an ``Objective``.\n\n        arg:    objective_id (osid.id.Id): the ``Id`` of the\n                ``Objective``\n        arg:    requisite_objective_id (osid.id.Id): the ``Id`` of the\n                required ``Objective``\n        raise:  NotFound - ``objective_id`` or\n                ``requisite_objective_id`` not found or ``objective_id``\n                not mapped to ``requisite_objective_id``\n        raise:  NullArgument - ``objective_id`` or\n                ``requisite_objective_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        requisite_type = Type(**Relationship().get_type_data('OBJECTIVE.REQUISITE'))\n        rls = self._get_provider_manager(\n            'RELATIONSHIP').get_relationship_lookup_session_for_family(\n            self.get_objective_bank_id(), proxy=self._proxy)\n        ras = self._get_provider_manager(\n            'RELATIONSHIP').get_relationship_admin_session_for_family(\n            self.get_objective_bank_id(), proxy=self._proxy)\n        rls.use_federated_family_view()\n        relationships = rls.get_relationships_by_genus_type_for_source(objective_id, requisite_type)\n        if relationships.available() == 0:\n            raise errors.IllegalState('no Objective found')\n        for relationship in relationships:\n            if str(relationship.get_destination_id()) == str(requisite_objective_id):\n                ras.delete_relationship(relationship.ident)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_activity(self, activity_id):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(activity_id, 'learning').get_identifier())},\n                 **self._view_filter()))\n        return objects.Activity(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the Activity specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets an ActivityList corresponding to the given IdList.", "response": "def get_activities_by_ids(self, activity_ids):\n        \"\"\"Gets an ``ActivityList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the\n        activities specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Activities`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set.\n\n        arg:    activity_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n        return: (osid.learning.ActivityList) - the returned ``Activity``\n                list\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``activity_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in activity_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'learning').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.ActivityList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget an activity list corresponding to the given activity genus Type which does not include activities of genus types derived from the specified Type.", "response": "def get_activities_by_genus_type(self, activity_genus_type):\n        \"\"\"Gets an ``ActivityList`` corresponding to the given activity genus ``Type`` which does not include activities of genus types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known activities\n        or an error results. Otherwise, the returned list may contain\n        only those activities that are accessible through this session.\n\n        arg:    activity_genus_type (osid.type.Type): an activity genus\n                type\n        return: (osid.learning.ActivityList) - the returned ``Activity``\n                list\n        raise:  NullArgument - ``activity_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(activity_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.ActivityList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_activities_for_objective(self, objective_id):\n        # Implemented from template for\n        # osid.learning.ActivityLookupSession.get_activities_for_objective_template\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'objectiveId': str(objective_id)},\n                 **self._view_filter()))\n        return objects.ActivityList(result, runtime=self._runtime)", "response": "Gets the activities mapped to an objective."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all Activities in this session.", "response": "def get_activities(self):\n        \"\"\"Gets all ``Activities``.\n\n        In plenary mode, the returned list contains all known activites\n        or an error results. Otherwise, the returned list may contain\n        only those activities that are accessible through this session.\n\n        return: (osid.learning.ActivityList) - a ``ActivityList``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.ActivityList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a list of Activities matching the given activity query.", "response": "def get_activities_by_query(self, activity_query):\n        \"\"\"Gets a list of ``Activities`` matching the given activity query.\n\n        arg:    activity_query (osid.learning.ActivityQuery): the\n                activity query\n        return: (osid.learning.ActivityList) - the returned\n                ``ActivityList``\n        raise:  NullArgument - ``activity_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``activity_query`` is not of this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in activity_query._query_terms:\n            if '$in' in activity_query._query_terms[term] and '$nin' in activity_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': activity_query._query_terms[term]['$in']}},\n                             {term: {'$nin': activity_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: activity_query._query_terms[term]})\n        for term in activity_query._keyword_terms:\n            or_list.append({term: activity_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('learning',\n                                             collection='Activity',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.ActivityList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_activity_form_for_create(self, objective_id, activity_record_types):\n        # Implemented from template for\n        # osid.learning.ActivityAdminSession.get_activity_form_for_create_template\n\n        if not isinstance(objective_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in activity_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if activity_record_types == []:\n            # WHY are we passing objective_bank_id = self._catalog_id below, seems redundant:\n            obj_form = objects.ActivityForm(\n                objective_bank_id=self._catalog_id,\n                objective_id=objective_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.ActivityForm(\n                objective_bank_id=self._catalog_id,\n                record_types=activity_record_types,\n                objective_id=objective_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the activity form for creating new activities."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_activity(self, activity_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        if not isinstance(activity_form, ABCActivityForm):\n            raise errors.InvalidArgument('argument type is not an ActivityForm')\n        if activity_form.is_for_update():\n            raise errors.InvalidArgument('the ActivityForm is for update only, not create')\n        try:\n            if self._forms[activity_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('activity_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('activity_form did not originate from this session')\n        if not activity_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(activity_form._my_map)\n\n        self._forms[activity_form.get_id().get_identifier()] = CREATED\n        result = objects.Activity(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new activity."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_activity(self, activity_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        if not isinstance(activity_form, ABCActivityForm):\n            raise errors.InvalidArgument('argument type is not an ActivityForm')\n        if not activity_form.is_for_update():\n            raise errors.InvalidArgument('the ActivityForm is for update only, not create')\n        try:\n            if self._forms[activity_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('activity_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('activity_form did not originate from this session')\n        if not activity_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(activity_form._my_map)\n\n        self._forms[activity_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Activity(\n            osid_object_map=activity_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Updates an existing activity."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_activity(self, activity_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('learning',\n                                         collection='Activity',\n                                         runtime=self._runtime)\n        if not isinstance(activity_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        activity_map = collection.find_one(\n            dict({'_id': ObjectId(activity_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.Activity(osid_object_map=activity_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(activity_id.get_identifier())})", "response": "Deletes the activity identified by the given Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef alias_activity(self, activity_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=activity_id, equivalent_id=alias_id)", "response": "Adds an Id to an activity in the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_activity_ids_by_objective_bank(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for activity in self.get_activities_by_objective_bank(objective_bank_id):\n            id_list.append(activity.get_id())\n        return IdList(id_list)", "response": "Gets the list of Activity Id s associated with an ObjectiveBank."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_activities_by_objective_bank(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_activity_lookup_session_for_objective_bank(objective_bank_id, proxy=self._proxy)\n        lookup_session.use_isolated_objective_bank_view()\n        return lookup_session.get_activities()", "response": "Gets the list of Activities associated with an ObjectiveBank."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_activity_ids_by_objective_banks(self, objective_bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for activity in self.get_activities_by_objective_banks(objective_bank_ids):\n            id_list.append(activity.get_id())\n        return IdList(id_list)", "response": "Gets the list of Activity Ids corresponding to a list of ObjectiveBanks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_activities_by_objective_banks(self, objective_bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        activity_list = []\n        for objective_bank_id in objective_bank_ids:\n            activity_list += list(\n                self.get_activities_by_objective_bank(objective_bank_id))\n        return objects.ActivityList(activity_list)", "response": "Gets the list of Activities corresponding to a list of ObjectiveBanks."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the list of ObjectiveBank Ids mapped to an Activity.", "response": "def get_objective_bank_ids_by_activity(self, activity_id):\n        \"\"\"Gets the list of ``ObjectiveBank Ids`` mapped to a ``Activity``.\n\n        arg:    activity_id (osid.id.Id): ``Id`` of a ``Activity``\n        return: (osid.id.IdList) - list of objective bank ``Ids``\n        raise:  NotFound - ``activity_id`` is not found\n        raise:  NullArgument - ``activity_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_activity_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_objective_bank_view()\n        activity = lookup_session.get_activity(activity_id)\n        id_list = []\n        for idstr in activity._my_map['assignedObjectiveBankIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_objective_banks_by_activity(self, activity_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        return lookup_session.get_objective_banks_by_ids(\n            self.get_objective_bank_ids_by_activity(activity_id))", "response": "Gets the list of ObjectiveBanks mapped to an Activity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assign_activity_to_objective_bank(self, activity_id, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_objective_bank(objective_bank_id)  # to raise NotFound\n        self._assign_object_to_catalog(activity_id, objective_bank_id)", "response": "Adds an existing Activity to an ObjectiveBank."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove an Activity from an ObjectiveBank.", "response": "def unassign_activity_from_objective_bank(self, activity_id, objective_bank_id):\n        \"\"\"Removes a ``Activity`` from a ``ObjectiveBank``.\n\n        arg:    activity_id (osid.id.Id): the ``Id`` of the ``Activity``\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                ``ObjectiveBank``\n        raise:  NotFound - ``activity_id`` or ``objective_bank_id`` not\n                found or ``activity_id`` not mapped to\n                ``objective_bank_id``\n        raise:  NullArgument - ``activity_id`` or ``objective_bank_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_objective_bank(objective_bank_id)  # to raise NotFound\n        self._unassign_object_from_catalog(activity_id, objective_bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reassign_activity_to_objective_bank(self, activity_id, from_objective_bank_id, to_objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.reassign_resource_to_bin\n        self.assign_activity_to_objective_bank(activity_id, to_objective_bank_id)\n        try:\n            self.unassign_activity_from_objective_bank(activity_id, from_objective_bank_id)\n        except:  # something went wrong, roll back assignment to to_objective_bank_id\n            self.unassign_activity_from_objective_bank(activity_id, to_objective_bank_id)\n            raise", "response": "Moves an Activity from one ObjectiveBank to another."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_proficiency(self, proficiency_id):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(proficiency_id, 'learning').get_identifier())},\n                 **self._view_filter()))\n        return objects.Proficiency(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the Proficiency specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_proficiencies_by_ids(self, proficiency_ids):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in proficiency_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'learning').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.ProficiencyList(sorted_result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a ProficiencyList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a list of Proficiencies corresponding to the given proficiency genus Type which does not include proficiencies of types derived from the specified Type.", "response": "def get_proficiencies_by_genus_type(self, proficiency_genus_type):\n        \"\"\"Gets a ``ProficiencyList`` corresponding to the given proficiency genus ``Type`` which does not include proficiencies of types derived from the specified ``Type``.\n\n        arg:    proficiency_genus_type (osid.type.Type): a proficiency\n                genus type\n        return: (osid.learning.ProficiencyList) - the returned\n                ``Proficiency`` list\n        raise:  NullArgument - ``proficiency_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(proficiency_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.ProficiencyList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_proficiencies_on_date(self, from_, to):\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_on_date\n        proficiency_list = []\n        for proficiency in self.get_proficiencies():\n            if overlap(from_, to, proficiency.start_date, proficiency.end_date):\n                proficiency_list.append(proficiency)\n        return objects.ProficiencyList(proficiency_list, runtime=self._runtime)", "response": "Gets a list of all proficiencies effecyive during the entire given date range inclusive but not confined to the date range."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_proficiencies_for_objective_on_date(self, objective_id, from_, to):\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_destination_on_date\n        proficiency_list = []\n        for proficiency in self.get_proficiencies_for_objective():\n            if overlap(from_, to, proficiency.start_date, proficiency.end_date):\n                proficiency_list.append(proficiency)\n        return objects.ProficiencyList(proficiency_list, runtime=self._runtime)", "response": "Gets a list of Proficiency objects relating to the given objective effective during the entire given date range inclusive but not confined to the date range."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_proficiencies_for_objectives(self, objective_ids):\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_destination\n        # NOTE: This implementation currently ignores plenary and effective views\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'objectiveId': str(objective_ids)},\n                 **self._view_filter())).sort('_id', ASCENDING)\n        return objects.ProficiencyList(result, runtime=self._runtime)", "response": "Gets a ProficiencyList relating to the given objectives."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a list of Proficiency objects relating to the given resource effective during the entire given date range inclusive but not confined to the date range.", "response": "def get_proficiencies_for_resource_on_date(self, resource_id, from_, to):\n        \"\"\"Gets a ``ProficiencyList`` relating to the given resource effective during the entire given date range inclusive but not confined to the date range.\n\n        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n        return: (osid.learning.ProficiencyList) - the returned\n                ``Proficiency`` list\n        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``resource_id, from`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source_on_date\n        proficiency_list = []\n        for proficiency in self.get_proficiencies_for_resource(resource_id):\n            if overlap(from_, to, proficiency.start_date, proficiency.end_date):\n                proficiency_list.append(proficiency)\n        return objects.ProficiencyList(proficiency_list, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a list of Proficiencies relating to the given proficiency genus type relating to a resource effective during the entire given date range inclusive but not confined to the date range.", "response": "def get_proficiencies_by_genus_type_for_resource_on_date(self, resource_id, proficiency_genus_type, from_, to):\n        \"\"\"Gets a ``ProficiencyList`` of the given proficiency genus type relating to the given resource effective during the entire given date range inclusive but not confined to the date range.\n\n        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    proficiency_genus_type (osid.type.Type): a proficiency\n                genus type\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n        return: (osid.learning.ProficiencyList) - the returned\n                ``Proficiency`` list\n        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``resource_id, proficiency_genus_type,\n                from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_by_genus_type_for_source_on_date\n        proficiency_list = []\n        for proficiency in self.get_proficiencies_by_genus_type_for_resource():\n            if overlap(from_, to, proficiency.start_date, proficiency.end_date):\n                proficiency_list.append(proficiency)\n        return objects.ProficiencyList(proficiency_list, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_proficiencies_for_resources(self, resource_ids):\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source\n        # NOTE: This implementation currently ignores plenary and effective views\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'resourceId': str(resource_ids)},\n                 **self._view_filter())).sort('_sort_id', ASCENDING)\n        return objects.ProficiencyList(result, runtime=self._runtime)", "response": "Gets a ProficiencyList relating to the given resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a ProficiencyList relating to the given objective and resource.", "response": "def get_proficiencies_for_objective_and_resource(self, objective_id, resource_id):\n        \"\"\"Gets a ``ProficiencyList`` relating to the given objective and resource ````.\n\n        arg:    objective_id (osid.id.Id): an objective ``Id``\n        arg:    resource_id (osid.id.Id): a resource ``Id``\n        return: (osid.learning.ProficiencyList) - the returned\n                ``Proficiency`` list\n        raise:  NullArgument - ``objective_id`` or ``resource_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_peers\n        # NOTE: This implementation currently ignores plenary and effective views\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'resourceId': str(objective_id),\n                  'objectiveId': str(resource_id)},\n                 **self._view_filter())).sort('_id', ASCENDING)\n        return objects.ProficiencyList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all ``Proficiencies``. return: (osid.learning.ProficiencyList) - a list of ``Proficiencies`` raise: OperationFailed - unable to complete request raise: PermissionDenied - authorization failure *compliance: mandatory -- This method must be implemented.*", "response": "def get_proficiencies(self):\n        \"\"\"Gets all ``Proficiencies``.\n\n        return: (osid.learning.ProficiencyList) - a list of\n                ``Proficiencies``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.ProficiencyList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_proficiencies_by_query(self, proficiency_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in proficiency_query._query_terms:\n            if '$in' in proficiency_query._query_terms[term] and '$nin' in proficiency_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': proficiency_query._query_terms[term]['$in']}},\n                             {term: {'$nin': proficiency_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: proficiency_query._query_terms[term]})\n        for term in proficiency_query._keyword_terms:\n            or_list.append({term: proficiency_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('learning',\n                                             collection='Proficiency',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.ProficiencyList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of Proficiencies matching the given proficiency query."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_proficiency_form_for_create(self, objective_id, resource_id, proficiency_record_types):\n        # Implemented from template for\n        # osid.relationship.RelationshipAdminSession.get_relationship_form_for_create\n        # These really need to be in module imports:\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        from dlkit.abstract_osid.type.primitives import Type as ABCType\n        if not isinstance(objective_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        if not isinstance(resource_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in proficiency_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if proficiency_record_types == []:\n            # WHY are we passing objective_bank_id = self._catalog_id below, seems redundant:\n            obj_form = objects.ProficiencyForm(\n                objective_bank_id=self._catalog_id,\n                objective_id=objective_id,\n                resource_id=resource_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.ProficiencyForm(\n                objective_bank_id=self._catalog_id,\n                record_types=proficiency_record_types,\n                objective_id=objective_id,\n                resource_id=resource_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the proficiency form for creating new proficiencies."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_proficiency(self, proficiency_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        if not isinstance(proficiency_form, ABCProficiencyForm):\n            raise errors.InvalidArgument('argument type is not an ProficiencyForm')\n        if proficiency_form.is_for_update():\n            raise errors.InvalidArgument('the ProficiencyForm is for update only, not create')\n        try:\n            if self._forms[proficiency_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('proficiency_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('proficiency_form did not originate from this session')\n        if not proficiency_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(proficiency_form._my_map)\n\n        self._forms[proficiency_form.get_id().get_identifier()] = CREATED\n        result = objects.Proficiency(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new Proficiency."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates an existing proficiency.", "response": "def update_proficiency(self, proficiency_form):\n        \"\"\"Updates an existing proficiency.\n\n        arg:    proficiency_form (osid.learning.ProficiencyForm): the\n                form containing the elements to be updated\n        raise:  IllegalState - ``proficiency_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``proficiency_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``proficiency_form`` did not originate\n                from ``get_proficiency_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        if not isinstance(proficiency_form, ABCProficiencyForm):\n            raise errors.InvalidArgument('argument type is not an ProficiencyForm')\n        if not proficiency_form.is_for_update():\n            raise errors.InvalidArgument('the ProficiencyForm is for update only, not create')\n        try:\n            if self._forms[proficiency_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('proficiency_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('proficiency_form did not originate from this session')\n        if not proficiency_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(proficiency_form._my_map)\n\n        self._forms[proficiency_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Proficiency(\n            osid_object_map=proficiency_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete a ``Proficiency``. arg: proficiency_id (osid.id.Id): the ``Id`` of the ``Proficiency`` to remove raise: NotFound - ``proficiency_id`` not found raise: NullArgument - ``proficiency_id`` is ``null`` raise: OperationFailed - unable to complete request raise: PermissionDenied - authorization failure *compliance: mandatory -- This method must be implemented.*", "response": "def delete_proficiency(self, proficiency_id):\n        \"\"\"Deletes a ``Proficiency``.\n\n        arg:    proficiency_id (osid.id.Id): the ``Id`` of the\n                ``Proficiency`` to remove\n        raise:  NotFound - ``proficiency_id`` not found\n        raise:  NullArgument - ``proficiency_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('learning',\n                                         collection='Proficiency',\n                                         runtime=self._runtime)\n        if not isinstance(proficiency_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        proficiency_map = collection.find_one(\n            dict({'_id': ObjectId(proficiency_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.Proficiency(osid_object_map=proficiency_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(proficiency_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an Id to a Profile.", "response": "def alias_proficiency(self, proficiency_id, alias_id):\n        \"\"\"Adds an ``Id`` to a ``Proficiency`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``Proficiency`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another proficiency, it is\n        reassigned to the given proficiency ``Id``.\n\n        arg:    proficiency_id (osid.id.Id): the ``Id`` of a\n                ``Proficiency``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``proficiency_id`` not found\n        raise:  NullArgument - ``proficiency_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=proficiency_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assign_proficiency_to_objective_bank(self, proficiency_id, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_objective_bank(objective_bank_id)  # to raise NotFound\n        self._assign_object_to_catalog(proficiency_id, objective_bank_id)", "response": "Adds an existing Proficiency to an ObjectiveBank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a Proficiency from an ObjectiveBank.", "response": "def unassign_proficiency_from_objective_bank(self, proficiency_id, objective_bank_id):\n        \"\"\"Removes a ``Proficiency`` from a ``ObjectiveBank``.\n\n        arg:    proficiency_id (osid.id.Id): the ``Id`` of the\n                ``Proficiency``\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                ``ObjectiveBank``\n        raise:  NotFound - ``proficiency_id`` or ``objective_bank_id``\n                not found or ``proficiency_id`` not mapped to\n                ``objective_bank_id``\n        raise:  NullArgument - ``proficiency_id`` or\n                ``objective_bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('LEARNING', local=True)\n        lookup_session = mgr.get_objective_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_objective_bank(objective_bank_id)  # to raise NotFound\n        self._unassign_object_from_catalog(proficiency_id, objective_bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmoving a Proficiency from one ObjectiveBank to another ObjectiveBank.", "response": "def reassign_proficiency_to_objective_bank(self, proficiency_id, from_objective_bank_id, to_objective_bank_id):\n        \"\"\"Moves a ``Proficiency`` from one ``ObjectiveBank`` to another.\n\n        Mappings to other ``ObjectiveBanks`` are unaffected.\n\n        arg:    proficiency_id (osid.id.Id): the ``Id`` of the\n                ``Proficiency``\n        arg:    from_objective_bank_id (osid.id.Id): the ``Id`` of the\n                current ``ObjectiveBank``\n        arg:    to_objective_bank_id (osid.id.Id): the ``Id`` of the\n                destination ``ObjectiveBank``\n        raise:  NotFound - ``proficiency_id, from_objective_bank_id,``\n                or ``to_objective_bank_id`` not found or\n                ``proficiency_id`` not mapped to\n                ``from_objective_bank_id``\n        raise:  NullArgument - ``proficiency_id,\n                from_objective_bank_id,`` or ``to_objective_bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.reassign_resource_to_bin\n        self.assign_proficiency_to_objective_bank(proficiency_id, to_objective_bank_id)\n        try:\n            self.unassign_proficiency_from_objective_bank(proficiency_id, from_objective_bank_id)\n        except:  # something went wrong, roll back assignment to to_objective_bank_id\n            self.unassign_proficiency_from_objective_bank(proficiency_id, to_objective_bank_id)\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all objective banks in the current session.", "response": "def get_objective_banks(self):\n        \"\"\"Gets all ``ObjectiveBanks``.\n\n        In plenary mode, the returned list contains all known objective\n        banks or an error results. Otherwise, the returned list may\n        contain only those objective banks that are accessible through\n        this session.\n\n        return: (osid.learning.ObjectiveBankList) - a\n                ``ObjectiveBankList``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinLookupSession.get_bins_template\n        # NOTE: This implementation currently ignores plenary view\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalogs()\n        collection = JSONClientValidated('learning',\n                                         collection='ObjectiveBank',\n                                         runtime=self._runtime)\n        result = collection.find().sort('_id', DESCENDING)\n\n        return objects.ObjectiveBankList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef can_create_objective_bank_with_record_types(self, objective_bank_record_types):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=objective_bank_record_types)\n        return True", "response": "Tests if this user can create an ObjectiveBank using the desired record types."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates an existing objective bank.", "response": "def update_objective_bank(self, objective_bank_form):\n        \"\"\"Updates an existing objective bank.\n\n        arg:    objective_bank_form (osid.learning.ObjectiveBankForm):\n                the form containing the elements to be updated\n        raise:  IllegalState - ``objective_bank_form`` already used in\n                an update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``objective_bank_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``objective_bank_form did not originate\n                from get_objective_bank_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=objective_bank_form)\n        collection = JSONClientValidated('learning',\n                                         collection='ObjectiveBank',\n                                         runtime=self._runtime)\n        if not isinstance(objective_bank_form, ABCObjectiveBankForm):\n            raise errors.InvalidArgument('argument type is not an ObjectiveBankForm')\n        if not objective_bank_form.is_for_update():\n            raise errors.InvalidArgument('the ObjectiveBankForm is for update only, not create')\n        try:\n            if self._forms[objective_bank_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('objective_bank_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('objective_bank_form did not originate from this session')\n        if not objective_bank_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(objective_bank_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[objective_bank_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.ObjectiveBank(osid_object_map=objective_bank_form._my_map, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds an Id to an ObjectiveBank for the purpose of creating compatibility.", "response": "def alias_objective_bank(self, objective_bank_id, alias_id):\n        \"\"\"Adds an ``Id`` to an ``ObjectiveBank`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``ObjectiveBank`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another objective bank, it\n        is reassigned to the given objective bank ``Id``.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                ``ObjectiveBank``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``objective_bank_id`` not found\n        raise:  NullArgument - ``objective_bank_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=objective_bank_id, alias_id=alias_id)\n        self._alias_id(primary_id=objective_bank_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_root_objective_banks(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return ObjectiveBankLookupSession(\n            self._proxy,\n            self._runtime).get_objective_banks_by_ids(list(self.get_root_objective_bank_ids()))", "response": "Gets the root objective banks in this objective bank hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if the ObjectiveBank has any parents.", "response": "def has_parent_objective_banks(self, objective_bank_id):\n        \"\"\"Tests if the ``ObjectiveBank`` has any parents.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        return: (boolean) - ``true`` if the objective bank has parents,\n                ``false`` otherwise\n        raise:  NotFound - ``objective_bank_id`` is not found\n        raise:  NullArgument - ``objective_bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=objective_bank_id)\n        return self._hierarchy_session.has_parents(id_=objective_bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest if an Id is a direct parent of an objective bank.", "response": "def is_parent_of_objective_bank(self, id_, objective_bank_id):\n        \"\"\"Tests if an ``Id`` is a direct parent of an objective bank.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``objective_bank_id,``  ``false`` otherwise\n        raise:  NotFound - ``objective_bank_id`` is not found\n        raise:  NullArgument - ``id`` or ``objective_bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=objective_bank_id)\n        return self._hierarchy_session.is_parent(id_=objective_bank_id, parent_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parent_objective_bank_ids(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=objective_bank_id)\n        return self._hierarchy_session.get_parents(id_=objective_bank_id)", "response": "Gets the parent Ids of the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_parent_objective_banks(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=objective_bank_id)\n        return ObjectiveBankLookupSession(\n            self._proxy,\n            self._runtime).get_objective_banks_by_ids(\n                list(self.get_parent_objective_bank_ids(objective_bank_id)))", "response": "Gets the parents of the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntest if an Id is an ancestor of an objective bank.", "response": "def is_ancestor_of_objective_bank(self, id_, objective_bank_id):\n        \"\"\"Tests if an ``Id`` is an ancestor of an objective bank.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``objective_bank_id,`` ``false`` otherwise\n        raise:  NotFound - ``objective_bank_id`` is not found\n        raise:  NullArgument - ``id`` or ``objective_bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=objective_bank_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=objective_bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_child_objective_banks(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=objective_bank_id)\n        return self._hierarchy_session.has_children(id_=objective_bank_id)", "response": "Tests if an objective bank has any children."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if an objective bank is a direct child of another.", "response": "def is_child_of_objective_bank(self, id_, objective_bank_id):\n        \"\"\"Tests if an objective bank is a direct child of another.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        return: (boolean) - ``true`` if the ``id`` is a child of\n                ``objective_bank_id,``  ``false`` otherwise\n        raise:  NotFound - ``objective_bank_id`` is not found\n        raise:  NullArgument - ``id`` or ``objective_bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=objective_bank_id)\n        return self._hierarchy_session.is_child(id_=objective_bank_id, child_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_child_objective_bank_ids(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=objective_bank_id)\n        return self._hierarchy_session.get_children(id_=objective_bank_id)", "response": "Gets the child Ids of the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the children of the given objective bank.", "response": "def get_child_objective_banks(self, objective_bank_id):\n        \"\"\"Gets the children of the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` to query\n        return: (osid.learning.ObjectiveBankList) - the children of the\n                objective bank\n        raise:  NotFound - ``objective_bank_id`` is not found\n        raise:  NullArgument - ``objective_bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=objective_bank_id)\n        return ObjectiveBankLookupSession(\n            self._proxy,\n            self._runtime).get_objective_banks_by_ids(\n                list(self.get_child_objective_bank_ids(objective_bank_id)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if an Id is a descendant of an objective bank.", "response": "def is_descendant_of_objective_bank(self, id_, objective_bank_id):\n        \"\"\"Tests if an ``Id`` is a descendant of an objective bank.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``objective_bank_id,`` ``false`` otherwise\n        raise:  NotFound - ``objective_bank_id`` is not found\n        raise:  NullArgument - ``id`` or ``objective_bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` is not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=objective_bank_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=objective_bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_objective_bank_nodes(self, objective_bank_id, ancestor_levels, descendant_levels, include_siblings):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.ObjectiveBankNode(self.get_objective_bank_node_ids(\n            objective_bank_id=objective_bank_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the objective bank nodes for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_root_objective_bank(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=objective_bank_id)\n        return self._hierarchy_session.add_root(id_=objective_bank_id)", "response": "Adds a root objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_root_objective_bank(self, objective_bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=objective_bank_id)\n        return self._hierarchy_session.remove_root(id_=objective_bank_id)", "response": "Removes a root objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a child to an objective bank.", "response": "def add_child_objective_bank(self, objective_bank_id, child_id):\n        \"\"\"Adds a child to an objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``objective_bank_id`` is already a\n                parent of ``child_id``\n        raise:  NotFound - ``objective_bank_id`` or ``child_id`` not\n                found\n        raise:  NullArgument - ``objective_bank_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=objective_bank_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=objective_bank_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a child from an objective bank.", "response": "def remove_child_objective_bank(self, objective_bank_id, child_id):\n        \"\"\"Removes a child from an objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        arg:    child_id (osid.id.Id): the ``Id`` of the child\n        raise:  NotFound - ``objective_bank_id`` not a parent of\n                ``child_id``\n        raise:  NullArgument - ``objective_bank_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=objective_bank_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=objective_bank_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove all children from an objective bank.", "response": "def remove_child_objective_banks(self, objective_bank_id):\n        \"\"\"Removes all children from an objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of an\n                objective bank\n        raise:  NotFound - ``objective_bank_id`` not in hierarchy\n        raise:  NullArgument - ``objective_bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalogs(catalog_id=objective_bank_id)\n        return self._hierarchy_session.remove_children(id_=objective_bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_ignored(mod_or_pkg, ignored_package):\n    ignored_pattern = list()\n    for pkg_fullname in ignored_package:\n        if pkg_fullname.endswith(\".py\"):\n            pkg_fullname = pkg_fullname[:-3]\n            ignored_pattern.append(pkg_fullname)\n        else:\n            ignored_pattern.append(pkg_fullname)\n\n    for pattern in ignored_pattern:\n        if mod_or_pkg.fullname.startswith(pattern):\n            return True\n    return False", "response": "Test if this module or package is included in generate\n    API reference document."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating the package. rst text content.", "response": "def generate_package_content(self, package):\n        \"\"\"Generate package.rst text content.\n\n        ::\n\n            {{ package_name }}\n            ==================\n\n            .. automodule:: {{ package_name }}\n                :members:\n\n            sub packages and modules\n            ------------------------\n\n            .. toctree::\n               :maxdepth: 1\n\n                {{ sub_package_name1 }} <{{ sub_package_name1 }}/__init__>\n                {{ sub_package_name2 }} <{{ sub_package_name2 }}/__init__>\n                {{ sub_module_name1}} <{{ sub_module_name1}}>\n                {{ sub_module_name2}} <{{ sub_module_name2}}>\n\n        \"\"\"\n        if isinstance(package, Package):\n            return package.render(ignored_package=self.ignored_package)\n        else:  # pragma: no cover\n            raise Exception(\"%r is not a Package object\" % package)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_module_content(self, module):\n        if isinstance(module, Module):\n            return module.render()\n        else:  # pragma: no cover\n            raise Exception(\"%r is not a Module object\" % module)", "response": "Generate the module. rst text content."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open(self, fname, mode='rb'):\n        self.close()\n        self.fp = open(fname, mode)\n        self.fname = fname", "response": "Open a backup file and set the file name to fname."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(self):\n        self.fp.seek(0)\n        magic = self.fp.readline()\n        assert magic == b'ANDROID BACKUP\\n'\n        self.version = int(self.fp.readline().strip())\n        self.compression = CompressionType(int(self.fp.readline().strip()))\n        self.encryption = EncryptionType(self.fp.readline().strip().decode())\n        self.__data_start = self.fp.tell()", "response": "Parses a backup file header. Will be done automatically if the with statement\n        used together with the with statement\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencoding the given masterkey string with utf - 8", "response": "def encode_utf8(mk):\n        \"\"\"\n        (Double-)encodes the given string (masterkey) with utf-8\n\n        Tries to behave like the Java implementation\n        \"\"\"\n        utf8mk = mk.decode('raw_unicode_escape')\n        utf8mk = list(utf8mk)\n        to_char = chr\n        if sys.version_info[0] < 3:\n            to_char = unichr\n        for i in range(len(utf8mk)):\n            c = ord(utf8mk[i])\n            # fix java encoding (add 0xFF00 to non ascii chars)\n            if 0x7f < c < 0x100:\n                c += 0xff00\n                utf8mk[i] = to_char(c)\n        return ''.join(utf8mk).encode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _encrypt(self, dec, password=None):\n        if AES is None:\n            raise ImportError(\"PyCrypto required\")\n\n        if password is None:\n            password = self.password\n\n        if password is None:\n            raise ValueError(\n                \"Password need to be provided to create encrypted archives\")\n\n        # generate the different encryption parts (non-secure!)\n        master_key = Random.get_random_bytes(32)\n        master_salt = Random.get_random_bytes(64)\n        user_salt = Random.get_random_bytes(64)\n        master_iv = Random.get_random_bytes(16)\n        user_iv = Random.get_random_bytes(16)\n        rounds = 10000\n\n        # create the PKCS#7 padding\n        l = len(dec)\n        pad = 16 - (l % 16)\n        dec += bytes([pad] * pad)\n\n        # encrypt the data\n        cipher = AES.new(master_key, IV=master_iv, mode=AES.MODE_CBC)\n        enc = cipher.encrypt(dec)\n\n        # generate the master key checksum\n        master_ck = PBKDF2(self.encode_utf8(master_key),\n                           master_salt, dkLen=256//8, count=rounds)\n\n        # generate the user key from the given password\n        user_key = PBKDF2(password,\n                          user_salt, dkLen=256//8, count=rounds)\n\n        # encrypt the master key and iv\n        master_dec = b\"\\x10\" + master_iv + b\"\\x20\" + master_key + b\"\\x20\" + master_ck\n        l = len(master_dec)\n        pad = 16 - (l % 16)\n        master_dec += bytes([pad] * pad)\n        cipher = AES.new(user_key, IV=user_iv, mode=AES.MODE_CBC)\n        master_enc = cipher.encrypt(master_dec)\n\n        # put everything together\n        enc = binascii.b2a_hex(user_salt).upper() + b\"\\n\" + \\\n                binascii.b2a_hex(master_salt).upper() + b\"\\n\" + \\\n                str(rounds).encode() + b\"\\n\" + \\\n                binascii.b2a_hex(user_iv).upper() + b\"\\n\" + \\\n                binascii.b2a_hex(master_enc).upper() + b\"\\n\" + enc\n\n        return enc", "response": "Internal encryption function for the object holding the object s data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _decompress(self, fp):\n        decompressor = zlib.decompressobj()\n        if self.stream:\n            return Proxy(decompressor.decompress, fp)\n        else:\n            out = io.BytesIO(decompressor.decompress(fp.read()))\n            out.write(decompressor.flush())\n            out.seek(0)\n            return out", "response": "Internal function for decompressing a backup file with the DEFLATE algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the data from the file - like object and returns a tarfile. TarFile object.", "response": "def read_data(self, password=None):\n        \"\"\"\n        Helper function which decrypts and decompresses the data if necessary\n        and returns a tarfile.TarFile to interact with\n        \"\"\"\n        fp = self.fp\n        fp.seek(self.__data_start)\n\n        if self.is_encrypted():\n            fp = self._decrypt(fp, password=password)\n\n        if self.compression == CompressionType.ZLIB:\n            fp = self._decompress(fp)\n\n        if self.stream:\n            mode = 'r|*'\n        else:\n            mode = 'r:*'\n        tar = tarfile.open(fileobj=fp, mode=mode)\n        return tar"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unpack(self, target_dir=None, password=None, pickle_fname=None):\n\n        if target_dir is None:\n           target_dir = os.path.basename(self.fname) + '_unpacked'\n        if pickle_fname is None:\n            pickle_fname = os.path.basename(self.fname) + '.pickle'\n        if not os.path.exists(target_dir):\n            os.mkdir(target_dir)\n\n        tar = self.read_data(password)\n        members = tar.getmembers()\n\n        # reopen stream (TarFile is not able to seek)\n        tar = self.read_data(password)\n\n        tar.extractall(path=target_dir, members=members)\n\n        with open(pickle_fname, 'wb') as fp:\n            pickle.dump(members, fp)", "response": "Unpacks a backup file into a target directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_display_name(self, display_name):\n        if self.get_display_name_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_string(display_name,\n                                     self.get_display_name_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['displayName']['text'] = display_name", "response": "Sets the display name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears the display name.", "response": "def clear_display_name(self):\n        \"\"\"Clears the display name.\n\n        raise:  NoAccess - ``display_name`` cannot be modified\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_display_name_metadata().is_read_only() or\n                self.get_display_name_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['displayName'] = self._display_name_metadata['default_string_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_display_label(self, display_label):\n        if self.get_display_label_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_string(display_label,\n                                     self.get_display_label_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['displayLabel']['text'] = display_label", "response": "Set a new display label."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_display_label(self):\n        if (self.get_display_label_metadata().is_read_only() or\n                self.get_display_label_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['displayLabel'] = self._display_label_metadata['default_string_values'][0]", "response": "Clears the display label."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_description(self, description):\n        if self.get_description_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_string(description,\n                                     self.get_description_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['description']['text'] = description", "response": "Sets a description.\n\n        arg:    description (string): the new description\n        raise:  InvalidArgument - ``description`` is invalid\n        raise:  NoAccess - ``description`` cannot be modified\n        raise:  NullArgument - ``description`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nclears the description. raise: NoAccess - ``description`` cannot be modified *compliance: mandatory -- This method must be implemented.*", "response": "def clear_description(self):\n        \"\"\"Clears the description.\n\n        raise:  NoAccess - ``description`` cannot be modified\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_domain_metadata().is_read_only() or\n                self.get_domain_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['domain'] = self._domain_metadata['default_string_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_domain(self, domain):\n        if self.get_domain_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_string(domain,\n                                     self.get_domain_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['domain']['text'] = domain", "response": "Sets a domain.\n\n        arg:    domain (string): the new domain\n        raise:  InvalidArgument - ``domain`` is invalid\n        raise:  NoAccess - ``domain`` cannot be modified\n        raise:  NullArgument - ``domain`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_next_relationship(self):\n        try:\n            next_object = next(self)\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_object", "response": "Gets the next Relationship in this list."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the next set of Relationships in this list.", "response": "def get_next_relationships(self, n=None):\n        \"\"\"Gets the next set of ``Relationships`` elements in this list.\n\n        The specified amount must be less than or equal to the return\n        from ``available()``.\n\n        arg:    n (cardinal): the number of ``Relationship`` elements\n                requested which must be less than or equal to\n                ``available()``\n        return: (osid.relationship.Relationship) - an array of\n                ``Relationship`` elements.The length of the array is\n                less than or equal to the number specified.\n        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if n > self.available():\n            # !!! This is not quite as specified (see method docs) !!!\n            raise IllegalState('not enough elements available in this list')\n        else:\n            next_list = []\n            x = 0\n            while x < n:\n                try:\n                    next_list.append(next(self))\n                except Exception:  # Need to specify exceptions here!\n                    raise  # OperationFailed()\n                x = x + 1\n            return next_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_next_family(self):\n        try:\n            next_object = next(self)\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_object", "response": "Gets the next Family in this list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_laminaprop(laminaprop=None, rho=None):\n    matlam = MatLamina()\n\n    #laminaProp = (e1, e2, nu12, g12, g13, g23, e3, nu13, nu23)\n    if laminaprop == None:\n        error('laminaprop must be a tuple in the following format:\\n\\t'\n              +'(e1, e2, nu12, g12, g13, g23, e3, nu13, nu23)')\n    if len(laminaprop) == 3: #ISOTROPIC\n        e = laminaprop[0]\n        nu = laminaprop[2]\n        g = e/(2*(1+nu))\n        laminaprop = (e, e, nu, g, g, g, e, nu, nu)\n    nu12 = laminaprop[2]\n\n    if len(laminaprop) < 9:\n        e2 = laminaprop[1]\n        laminaprop = tuple(list(laminaprop)[:6] + [e2, nu12, nu12])\n    matlam.e1 = laminaprop[0]\n    matlam.e2 = laminaprop[1]\n    matlam.e3 = laminaprop[6]\n    matlam.nu12 = laminaprop[2]\n    matlam.nu13 = laminaprop[7]\n    matlam.nu23 = laminaprop[8]\n    matlam.nu21 = matlam.nu12 * matlam.e2 / matlam.e1\n    matlam.nu31 = matlam.nu13 * matlam.e3 / matlam.e1\n    matlam.nu32 = matlam.nu23 * matlam.e3 / matlam.e2\n    matlam.g12 = laminaprop[3]\n    matlam.g13 = laminaprop[4]\n    matlam.g23 = laminaprop[5]\n    matlam.rho = rho\n\n    matlam.rebuild()\n\n    return matlam", "response": "Reads a new MatLamina object based on a list of laminaprop entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a users s animelist scores from MAL.", "response": "def myanimelist(username):\n    \"\"\"\n    Retrieve a users' animelist scores from MAL.\n\n    Only anime scored > 0 will be returned, and all\n    PTW entries are ignored, even if they are scored.\n\n    :param str username: MAL username\n    :return: `id`, `score` pairs\n    :rtype: list\n    \"\"\"\n    params = {\n        \"u\": username,\n        \"status\": \"all\",\n        \"type\": \"anime\"\n    }\n\n    resp = requests.request(\"GET\", ENDPOINT_URLS.MYANIMELIST, params=params)\n\n    # Check if MAL's hitting you with a 429 and raise an exception if so.\n    if resp.status_code == 429:  # pragma: no cover\n        raise MALRateLimitExceededError(\"MAL rate limit exceeded\")\n\n    resp = bs4.BeautifulSoup(resp.content, \"xml\")\n\n    all_anime = resp.find_all(\"anime\")\n\n    # Check if there's actually any anime being returned to us.\n    # If not, user probably doesn't exist.\n    # MAL should do a better job of highlighting this, but eh.\n    if not len(all_anime):\n        raise InvalidUsernameError(\"User `{}` does not exist\"\n                                   .format(username))\n\n    scores = []\n\n    for anime in all_anime:\n        # See if anime is on their PTW and move on if so.\n        # This makes sure rated anime that the user hasn't\n        # seen does not get added to `scores`.\n        # Why do people even do this?\n        # PTW == status \"6\"\n        if anime.my_status.string == \"6\":\n            continue\n\n        id = anime.series_animedb_id.string\n        id = int(id)\n\n        score = anime.my_score.string\n        # Might need changing if MAL allows float scores.\n        score = int(score)\n\n        if score > 0:\n            scores.append({\"id\": id, \"score\": score})\n\n    # Check if there's actually anything in scores.\n    # If not, user probably doesn't have any rated anime.\n    if not len(scores):\n        raise NoAffinityError(\"User `{}` hasn't rated any anime\"\n                              .format(username))\n\n    return scores"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating signature from pre - parsed URL.", "response": "def _generate_signature(url_path, secret_key, query_args, digest=None, encoder=None):\n    # type: (str, bytes, Dict[str, str], Callable, Callable) -> str\n    \"\"\"\n    Generate signature from pre-parsed URL.\n    \"\"\"\n    digest = digest or DEFAULT_DIGEST\n    encoder = encoder or DEFAULT_ENCODER\n    msg = \"%s?%s\" % (url_path, '&'.join('%s=%s' % i for i in query_args.sorteditems(multi=True)))\n    if _compat.text_type:\n        msg = msg.encode('UTF8')\n    signature = hmac.new(secret_key, msg, digestmod=digest).digest()\n    if _compat.PY2:\n        return encoder(signature).rstrip('=')  # Strip padding\n    else:\n        return encoder(signature).decode().rstrip('=')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsign a URL (excluding the domain and scheme). :param url: URL to sign :param secret_key: Secret key :param expire_in: Expiry time. :param digest: Specify the digest function to use; default is sha256 from hashlib :return: Signed URL", "response": "def sign_url_path(url, secret_key, expire_in=None, digest=None):\n    # type: (str, bytes, int, Callable) -> str\n    \"\"\"\n    Sign a URL (excluding the domain and scheme).\n\n    :param url: URL to sign\n    :param secret_key: Secret key\n    :param expire_in: Expiry time.\n    :param digest: Specify the digest function to use; default is sha256 from hashlib\n    :return: Signed URL\n\n    \"\"\"\n    result = urlparse(url)\n    query_args = MultiValueDict(parse_qs(result.query))\n    query_args['_'] = token()\n    if expire_in is not None:\n        query_args['expires'] = int(time() + expire_in)\n    query_args['signature'] = _generate_signature(result.path, secret_key, query_args, digest)\n    return \"%s?%s\" % (result.path, urlencode(list(query_args.sorteditems(True))))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nverify a URL path is correctly signed.", "response": "def verify_url_path(url_path, query_args, secret_key, salt_arg='_', max_expiry=None, digest=None):\n    # type: (str, Dict[str, str], bytes, str, int, Callable) -> bool\n    \"\"\"\n    Verify a URL path is correctly signed.\n\n    :param url_path: URL path\n    :param secret_key: Signing key\n    :param query_args: Arguments that make up the query string\n    :param salt_arg: Argument required for salt (set to None to disable)\n    :param max_expiry: Maximum length of time an expiry value can be for (set to None to disable)\n    :param digest: Specify the digest function to use; default is sha256 from hashlib\n    :rtype: bool\n    :raises: URLError\n\n    \"\"\"\n    try:\n        supplied_signature = query_args.pop('signature')\n    except KeyError:\n        raise SigningError(\"Signature missing.\")\n\n    if salt_arg is not None and salt_arg not in query_args:\n        raise SigningError(\"No salt used.\")\n\n    if max_expiry is not None and 'expires' not in query_args:\n        raise SigningError(\"Expiry time is required.\")\n\n    # Validate signature\n    signature = _generate_signature(url_path, secret_key, query_args, digest)\n    if not hmac.compare_digest(signature, supplied_signature):\n        raise SigningError('Signature not valid.')\n\n    # Check expiry\n    try:\n        expiry_time = int(query_args.pop('expires'))\n    except KeyError:\n        pass  # URL doesn't have an expire time\n    except ValueError:\n        raise SigningError(\"Invalid expiry value.\")\n    else:\n        expiry_delta = expiry_time - time()\n        if expiry_delta < 0:\n            raise SigningError(\"Signature has expired.\")\n        if max_expiry and expiry_delta > max_expiry:\n            raise SigningError(\"Expiry time out of range.\")\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef verify_url(url, secret_key, **kwargs):\n    result = urlparse(url)\n    query_args = MultiValueDict(parse_qs(result.query))\n    return verify_url_path(result.path, query_args, secret_key, **kwargs)", "response": "Verifies a signed URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a display text dictionary map.", "response": "def _unfold_map(self, display_text_map):\n        \"\"\"Parses a display text dictionary map.\"\"\"\n        from ..type.primitives import Type\n        lt_identifier = Id(display_text_map['languageTypeId']).get_identifier()\n        st_identifier = Id(display_text_map['scriptTypeId']).get_identifier()\n        ft_identifier = Id(display_text_map['formatTypeId']).get_identifier()\n        try:\n            self._language_type = Type(**language_types.get_type_data(lt_identifier))\n        except AttributeError:\n            raise NotFound('Language Type: ' + lt_identifier)  # or move on to another source\n        try:\n            self._script_type = Type(**script_types.get_type_data(st_identifier))\n        except AttributeError:\n            raise NotFound('Script Type: ' + st_identifier)  # or move on to another source\n        try:\n            self._format_type = Type(**format_types.get_type_data(ft_identifier))\n        except AttributeError:\n            raise NotFound('Format Type: ' + ft_identifier)  # or move on to another source\n        self._text = display_text_map['text']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef choice(self,arr):\n    ind = self.randint(0,len(arr)-1)\n    return arr[ind]", "response": "Uniform random selection of a member of a list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a random nucleotide change. uniform random. will never return itself", "response": "def different_random_nt(self,nt):\n    global nts\n    \"\"\"generate a random nucleotide change. uniform random.  will never return itself\n\n    :param nt: current nucleotide\n    :type nt: char\n    :return: new nucleotide\n    :rtype: char\n    \"\"\"\n    return self._random.choice([x for x in nts if x != nt.upper()])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_weighted_random_index(self,weights):\n    tot = float(sum([float(x) for x in weights]))\n    fracarray = [weights[0]]\n    for w in weights[1:]:\n      prev = fracarray[-1]\n      fracarray.append(w+prev)\n    #print fracarray\n    rnum = self._random.random()*tot\n    #print rnum\n    #sys.exit()\n    for i in range(len(weights)):\n      if rnum < fracarray[i]: return i\n    sys.stderr.write(\"Warning unexpected no random\\n\")", "response": "Returns an index of an array based on the weights\n      "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake an id in the format of UUID4 but keep in mind this could be trely random and can generate same id if same seed", "response": "def uuid4(self):\n    \"\"\"Make an id in the format of UUID4, but keep in mind this could very well be pseudorandom, and if it is you'll not be truely random, and can regenerate same id if same seed\"\"\"\n    return ''.join([hexchars[self.randint(0,15)] for x in range(0,8)]) + '-' +\\\n           ''.join([hexchars[self.randint(0,15)] for x in range(0,4)]) + '-' +\\\n           '4'+''.join([hexchars[self.randint(0,15)] for x in range(0,3)]) + '-' +\\\n           uuid4special[self.randint(0,3)]+''.join([hexchars[self.randint(0,15)] for x in range(0,3)]) + '-' +\\\n           ''.join([hexchars[self.randint(0,15)] for x in range(0,12)])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider AssetSearchSession. get_assets_by_search", "response": "def get_assets_by_search(self, asset_query, asset_search):\n        \"\"\"Pass through to provider AssetSearchSession.get_assets_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_assets_by_search(asset_query, asset_search)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_compositions_by_search(self, composition_query, composition_search):\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_compositions_by_search(composition_query, composition_search)", "response": "Pass through to provider CompositionSearchSession. get_compositions_by_search"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_next_types(self, n=None):\n        if n > self.available():\n            # !!! This is not quite as specified (see method docs) !!!\n            raise IllegalState('not enough elements available in this list')\n        else:\n            next_list = []\n            i = 0\n            while i < n:\n                try:\n                    next_list.append(next(self))\n                except:  # Need to specify exceptions here\n                    raise OperationFailed()\n                i += 1\n            return next_list", "response": "Gets the next set of types in this list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting a 16bit audio stream from a file.", "response": "def extract_wav(datafile, target=None):\n    \"\"\" Get LPCM 16bit audio stream from mediafile.\n    \n        If `target` is a directory, create a .wav with the same basename as the input.\n        If target is empty, write to the directory of the source file. Otherwise, use it \n        directly as the target filename.\n    \"\"\"\n    if datafile.endswith(\".wav\"):\n        return datafile\n\n    target = target or os.path.dirname(datafile) \n    if os.path.isdir(target):\n        target = os.path.join(target, os.path.splitext(os.path.basename(datafile))[0] + \".wav\")\n\n    if datafile.endswith(\".flac\"):\n        cmd = [config.CMD_FLAC, \"--silent\", \"--decode\", \"--force\", \"-o\", target, datafile]\n    else:\n        cmd = [config.CMD_FFMPEG, \"-v\", \"0\", \"-y\", \"-i\", datafile, \"-acodec\", \"pcm_s16le\", \"-ac\", \"2\", target]\n    subprocess.check_call(cmd, stdout=open(os.devnull, \"wb\"), stderr=subprocess.STDOUT)\n\n    return target"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_wav(mediafile):\n    if mediafile.endswith(\".wav\"):\n        yield mediafile\n    else:\n        wavfile = tempfile.mktemp(__name__) + \".wav\"\n        try:\n            extract_wav(mediafile, wavfile)\n            yield wavfile\n        finally:\n            if os.path.exists(wavfile):\n                os.remove(wavfile)", "response": "Context manager that creates a temporary WAV file from the given media file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_comment_mdata():\n    return {\n        'text': {\n            'element_label': {\n                'text': 'text',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter no more than 256 characters.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 256,\n            'string_set': [],\n        },\n        'reference': {\n            'element_label': {\n                'text': 'reference',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'rating': {\n            'element_label': {\n                'text': 'rating',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Comment"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef b64_hmac_md5(key, data):\n    bdigest = base64.b64encode(hmac.new(key, data, _md5).digest()).strip().decode(\"utf-8\")\n    return re.sub('=+$', '', bdigest)", "response": "Returns base64 - encoded HMAC - MD5 for key and data with trailing = stripped."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_domain(host):\n    host = re.sub('https?://', '', host)\n    host = re.match('([^/]+)', host).groups()[0]\n    domain = '.'.join(host.split('.')[-2:])\n    if domain in _domains:\n        domain = '.'.join(host.split('.')[-3:])\n    return domain", "response": "Returns the domain name of the given host."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate(password, uri):\n    realm = extract_domain(uri)\n    if password.startswith(_password_prefix):\n        password = password[len(_password_prefix):]\n\n    password_hash = b64_hmac_md5(password.encode(\"utf-8\"), realm.encode(\"utf-8\"))\n    size = len(password) + len(_password_prefix)\n    nonalphanumeric = len(re.findall(r'\\W', password)) != 0\n\n    return apply_constraints(password_hash, size, nonalphanumeric)", "response": "generate the pwdhash password for master password and uri or domain name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfiddles with the password a bit after hashing it so that it will get through most website filters. We require one upper and lower case, one digit, and we look at the user's password to determine if there should be at least one alphanumeric or not.", "response": "def apply_constraints(phash, size, nonalphanumeric):\n    \"\"\"\n    Fiddle with the password a bit after hashing it so that it will\n    get through most website filters. We require one upper and lower\n    case, one digit, and we look at the user's password to determine\n    if there should be at least one alphanumeric or not.\n    \"\"\"\n    starting_size = max(0, size - 4)\n    result = phash[:starting_size]\n\n    extras = itertools.chain((ord(ch) for ch in phash[starting_size:]),\n                             itertools.repeat(0))\n    extra_chars = (chr(ch) for ch in extras)\n    nonword = re.compile(r'\\W')\n\n    def next_between(start, end):\n        interval = ord(end) - ord(start) + 1\n        offset = next(extras) % interval\n        return chr(ord(start) + offset)\n\n    for elt, repl in (\n        (re.compile('[A-Z]'), lambda: next_between('A', 'Z')),\n        (re.compile('[a-z]'), lambda: next_between('a', 'z')),\n        (re.compile('[0-9]'), lambda: next_between('0', '9'))):\n        if len(elt.findall(result)) != 0:\n            result += next(extra_chars)\n        else:\n            result += repl()\n\n    if len(nonword.findall(result)) != 0 and nonalphanumeric:\n        result += next(extra_chars)\n    else:\n        result += '+'\n\n    while len(nonword.findall(result)) != 0 and not nonalphanumeric:\n        result = nonword.sub(next_between('A', 'Z'), result, 1)\n\n    amount = next(extras) % len(result)\n    result = result[amount:] + result[0:amount]\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef title(self):\n        if self._title is None:\n            self._title = self.get_title()\n        return self._title", "response": "Return the title of the message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_title(self):\n        header_bar_char_list = \"=-~+*#^\"\n\n        cursor_previous_line = None\n        for cursor_line in textfile.readlines(self.rst_path, strip=\"both\"):\n            for header_bar_char in header_bar_char_list:\n                if cursor_line.startswith(header_bar_char):\n                    flag_full_bar_char = cursor_line == header_bar_char * len(cursor_line)\n                    flag_line_length_greather_than_1 = len(cursor_line) >= 1\n                    flag_previous_line_not_empty = bool(cursor_previous_line)\n                    if flag_full_bar_char \\\n                            and flag_line_length_greather_than_1 \\\n                            and flag_previous_line_not_empty:\n                        return cursor_previous_line.strip()\n            cursor_previous_line = cursor_line\n\n        msg = \"Warning, this document doesn't have any %s header!\" % header_bar_char_list\n        return None", "response": "Get title line from. rst file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all valid ArticleFolders sitting inside of the article folder.", "response": "def sub_article_folders(self):\n        \"\"\"\n        Returns all valid ArticleFolder sitting inside of\n        :attr:`ArticleFolder.dir_path`.\n        \"\"\"\n        l = list()\n        for p in Path.sort_by_fname(\n                Path(self.dir_path).select_dir(recursive=False)\n        ):\n            af = ArticleFolder(dir_path=p.abspath)\n            try:\n                if af.title is not None:\n                    l.append(af)\n            except:\n                pass\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates toctree directive text.", "response": "def toc_directive(self, maxdepth=1):\n        \"\"\"\n        Generate toctree directive text.\n\n        :param table_of_content_header:\n        :param header_bar_char:\n        :param header_line_length:\n        :param maxdepth:\n        :return:\n        \"\"\"\n        articles_directive_content = TC.toc.render(\n            maxdepth=maxdepth,\n            article_list=self.sub_article_folders,\n        )\n        return articles_directive_content"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fly(cls,\n            conf_path,\n            docname,\n            source,\n            maxdepth=1):  # pragma: no cover\n        \"\"\"\n        Generate toctree directive for rst file.\n\n        :param conf_path: conf.py file absolute path\n        :param docname: the rst file relpath from conf.py directory.\n        :param source: rst content.\n        :param maxdepth: int, max toc tree depth.\n        \"\"\"\n        msg = (\"``.. articles::`` directive is going to be deprecated. \"\n               \"use ``.. autodoctree`` instead.\")\n        warnings.warn(msg, FutureWarning)\n\n        directive_pattern = \".. articles::\"\n        if directive_pattern not in source:\n            return source\n\n        af = ArticleFolder(\n            dir_path=Path(Path(conf_path).parent, docname).parent.abspath)\n        toc_directive = af.toc_directive(maxdepth)\n\n        lines = list()\n        for line in source.split(\"\\n\"):\n            if directive_pattern in line.strip():\n                if line.strip().startswith(directive_pattern):\n                    line = line.replace(directive_pattern, toc_directive, 1)\n                    lines.append(line)\n                    continue\n            lines.append(line)\n        return \"\\n\".join(lines)", "response": "Generate toctree directive for rst file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assessment_data(self, queryset, total_count, user_id):\n\n        # We need to convert the usernames to strings here because the JSON\n        # encoder will choke when serializing this data if the usernames are\n        # unicode as they are when we get them back from the distinct call.\n        users = [{'username': str(username), 'email': email}\n                 for username, email\n                 in queryset.values_list('user__username', 'user__email')\n                            .distinct()]\n\n        count = queryset.count()\n        is_user_call = queryset.filter(user=user_id).exists()\n\n        return {\n            'count': count,\n            'percentage': count / float(total_count) * 100.0,\n            'is_user_call': is_user_call,\n            'users': users,\n        }", "response": "Calculates and sets the following data for the assessment class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef static(request):\n    \"Shorthand static URLs. In debug mode, the JavaScript is not minified.\"\n    static_url = settings.STATIC_URL\n    prefix = 'src' if settings.DEBUG else 'min'\n    return {\n        'CSS_URL': os.path.join(static_url, 'stylesheets/css'),\n        'IMAGES_URL': os.path.join(static_url, 'images'),\n        'JAVASCRIPT_URL': os.path.join(static_url, 'js', prefix),\n    }", "response": "Shorthand static URLs. In debug mode the JavaScript is not minified."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the Id of the Agent identified in this authentication credential.", "response": "def get_agent_id(self):\n        \"\"\"Gets the ``Id`` of the ``Agent`` identified in this authentication credential.\n\n        return: (osid.id.Id) - the ``Agent Id``\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: The Agent should be determined at the\n        time this credential is created.\n\n        \"\"\"\n        if self._django_user is not None:\n            return Id(identifier=self._django_user.get_username(),\n                      namespace='osid.agent.Agent',\n                      authority='MIT-OEIT')\n        else:\n            return Id(identifier='MC3GUE$T@MIT.EDU',\n                      namespace='osid.agent.Agent',\n                      authority='MIT-OEIT')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the parent assessment.", "response": "def get_assessment_part(self):\n        \"\"\"Gets the parent assessment.\n\n        return: (osid.assessment.authoring.AssessmentPart) - the parent\n                assessment part\n        raise:  IllegalState - ``has_parent_part()`` is ``false``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not self.has_parent_part():\n            raise errors.IllegalState('no parent part')\n        lookup_session = self._get_assessment_part_lookup_session()\n        return lookup_session.get_assessment_part(self.get_assessment_part_id())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting any child assessment parts.", "response": "def get_child_assessment_parts(self):\n        \"\"\"Gets any child assessment parts.\n\n        return: (osid.assessment.authoring.AssessmentPartList) - the\n                child assessment parts\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not self.has_children():\n            raise errors.IllegalState('no children assessment parts')\n        # only returned unsequestered children?\n        lookup_session = self._get_assessment_part_lookup_session()\n        lookup_session.use_sequestered_assessment_part_view()\n        return lookup_session.get_assessment_parts_by_ids(self.get_child_ids())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the items in this assessment part.", "response": "def get_items(self):\n        \"\"\"This is out of spec, but required for adaptive assessment parts?\"\"\"\n        ils = get_item_lookup_session(runtime=self._runtime, proxy=self._proxy)\n        ils.use_federated_bank_view()\n        items = []\n        if self.has_items():\n            for idstr in self._my_map['itemIds']:\n                items.append(ils.get_item(Id(idstr)))\n        return ItemList(items, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_item_ids(self):\n        item_ids = []\n        if self.has_items():\n            for idstr in self._my_map['itemIds']:\n                item_ids.append(idstr)\n        return IdList(item_ids)", "response": "Returns a list of item ids that are available for this assessment part."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_assessment_part_lookup_session(self):\n        section = getattr(self, '_assessment_section', None)\n        session = get_assessment_part_lookup_session(self._runtime,\n                                                     self._proxy,\n                                                     section)\n        session.use_unsequestered_assessment_part_view()\n        session.use_federated_bank_view()\n        return session", "response": "get the assessment part lookup session"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_metadata(self, **kwargs):\n        osid_objects.OsidContainableForm._init_metadata(self)\n        osid_objects.OsidOperableForm._init_metadata(self)\n        osid_objects.OsidObjectForm._init_metadata(self, **kwargs)\n        if 'assessment_part_id' not in kwargs:\n            # Only \"Section\" Parts are allowed directly under Assessments\n            self._mdata['sequestered']['is_read_only'] = True\n            self._mdata['sequestered']['is_required'] = True\n            self._mdata['sequestered']['default_boolean_values'] = [False]\n        else:\n            if 'mdata' in kwargs:\n                self._mdata['sequestered'] = kwargs['mdata']['sequestered']\n        self._assessment_part_default = self._mdata['assessment_part']['default_id_values'][0]\n        self._assessment_default = self._mdata['assessment']['default_id_values'][0]\n        self._weight_default = self._mdata['weight']['default_cardinal_values'][0]\n        self._allocated_time_default = self._mdata['allocated_time']['default_duration_values'][0]\n        self._items_sequential_default = None\n        self._items_shuffled_default = None\n        self._mdata['children'] = {\n            'element_label': 'Children',\n            'instructions': 'accepts an IdList',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }", "response": "Initialize the metadata for the assessment part and object form."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the map of the assessment assessment", "response": "def _init_map(self, record_types=None, **kwargs):\n        \"\"\"Initialize form map\"\"\"\n        osid_objects.OsidContainableForm._init_map(self)\n        osid_objects.OsidOperableForm._init_map(self)\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        if 'assessment_part_id' in kwargs:\n            self._my_map['assessmentPartId'] = str(kwargs['assessment_part_id'])\n            if 'mdata' in kwargs:\n                self._my_map['sequestered'] = kwargs['mdata']['sequestered']['default_boolean_values'][0]\n        else:\n            self._my_map['assessmentPartId'] = self._assessment_part_default\n            self._my_map['sequestered'] = False  # Parts under Assessments must be \"Sections\"\n        if 'assessment_id' in kwargs:\n            self._my_map['assessmentId'] = str(kwargs['assessment_id'])\n        else:\n            self._my_map['assessmentId'] = self._assessment_default\n        self._my_map['assignedBankIds'] = [str(kwargs['bank_id'])]\n        self._my_map['allocatedTime'] = self._allocated_time_default\n        self._my_map['itemsSequential'] = self._items_sequential_default\n        self._my_map['itemsShuffled'] = self._items_shuffled_default\n        self._my_map['weight'] = self._weight_default\n        if self._supports_simple_sequencing():\n            self._my_map['childIds'] = []"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the metadata for the weight.", "response": "def get_weight_metadata(self):\n        \"\"\"Gets the metadata for the weight.\n\n        return: (osid.Metadata) - metadata for the weight\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['weight'])\n        metadata.update({'existing_cardinal_values': self._my_map['weight']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the metadata for the allocated time.", "response": "def get_allocated_time_metadata(self):\n        \"\"\"Gets the metadata for the allocated time.\n\n        return: (osid.Metadata) - metadata for the allocated time\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['allocated_time'])\n        metadata.update({'existing_duration_values': self._my_map['allocatedTime']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the allocated time.", "response": "def set_allocated_time(self, time):\n        \"\"\"Sets the allocated time.\n\n        arg:    time (osid.calendaring.Duration): the allocated time\n        raise:  InvalidArgument - ``time`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.set_duration_template\n        if self.get_allocated_time_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_duration(\n                time,\n                self.get_allocated_time_metadata()):\n            raise errors.InvalidArgument()\n        map = dict()\n        map['days'] = time.days\n        map['seconds'] = time.seconds\n        map['microseconds'] = time.microseconds\n        self._my_map['allocatedTime'] = map"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_allocated_time(self):\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.clear_duration_template\n        if (self.get_allocated_time_metadata().is_read_only() or\n                self.get_allocated_time_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['allocatedTime'] = self._allocated_time_default", "response": "Clears the allocated time."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessment_part_id(self):\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['assessmentPartId']):\n            raise errors.IllegalState('assessment_part empty')\n        return Id(self._my_map['assessmentPartId'])", "response": "Gets the assessment part Id to which this rule belongs."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the assessment part to which this rule belongs.", "response": "def get_assessment_part(self):\n        \"\"\"Gets the assessment part to which this rule belongs.\n\n        return: (osid.assessment.authoring.AssessmentPart) - an\n                assessment part\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['assessmentPartId']):\n            raise errors.IllegalState('assessment_part empty')\n        mgr = self._get_provider_manager('ASSESSMENT_AUTHORING')\n        if not mgr.supports_assessment_part_lookup():\n            raise errors.OperationFailed('Assessment_Authoring does not support AssessmentPart lookup')\n        lookup_session = mgr.get_assessment_part_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bank_view()\n        return lookup_session.get_assessment_part(self.get_assessment_part_id())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the map of assessment part record types", "response": "def _init_map(self, record_types=None, **kwargs):\n        \"\"\"Initialize form map\"\"\"\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        self._my_map['nextAssessmentPartId'] = str(kwargs['next_assessment_part_id'])\n        self._my_map['cumulative'] = self._cumulative_default\n        self._my_map['minimumScore'] = self._minimum_score_default\n        self._my_map['maximumScore'] = self._maximum_score_default\n        self._my_map['assessmentPartId'] = str(kwargs['assessment_part_id'])\n        self._my_map['assignedBankIds'] = [str(kwargs['bank_id'])]\n        self._my_map['appliedAssessmentPartIds'] = []"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the metadata for the minimum score.", "response": "def get_minimum_score_metadata(self):\n        \"\"\"Gets the metadata for the minimum score.\n\n        return: (osid.Metadata) - metadata for the minimum score\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['minimum_score'])\n        metadata.update({'existing_cardinal_values': self._my_map['minimumScore']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the metadata for the maximum score.", "response": "def get_maximum_score_metadata(self):\n        \"\"\"Gets the metadata for the maximum score.\n\n        return: (osid.Metadata) - metadata for the maximum score\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['maximum_score'])\n        metadata.update({'existing_cardinal_values': self._my_map['maximumScore']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_cumulative_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['cumulative'])\n        metadata.update({'existing_boolean_values': self._my_map['cumulative']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the cumulative flag."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies this rule to all previous assessment parts.", "response": "def set_cumulative(self, cumulative):\n        \"\"\"Applies this rule to all previous assessment parts.\n\n        arg:    cumulative (boolean): ``true`` to apply to all previous\n                assessment parts. ``false`` to apply to the immediate\n                previous assessment part\n        raise:  InvalidArgument - ``cumulative`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_cumulative_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(cumulative):\n            raise errors.InvalidArgument()\n        self._my_map['cumulative'] = cumulative"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_type(self, namespace=None, identifier=None, authority=None):\n        from . import types\n        from ..osid.osid_errors import NotFound, NullArgument\n        if namespace is None or identifier is None or authority is None:\n            raise NullArgument()\n        type_identifier = namespace + '%3A' + identifier + '%40' + authority\n        url_path = '/handcar/services/learning/types/' + type_identifier\n        try:\n            result = self._get_request(url_path)\n        except NotFound:\n            result = None\n            for t in types.TYPES:\n                if t['id'] == type_identifier:\n                    result = t\n            if result is None:\n                raise NotFound()\n        return Type(result)", "response": "Gets a Type by its string representation which is a combination of the authority and identifier."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_type(self, type_=None):\n        # This seems silly :)\n        return bool(self.get_type(namespace=type_.get_namespace(),\n                                  identifier=type_.get_identifier(),\n                                  authority=type_.get_authority()))", "response": "Tests if the given Type is known."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_types(self):\n        from . import types\n        url_path = '/handcar/services/learning/types/'\n        type_list = self._get_request(url_path)\n        type_list += types.TYPES\n        return objects.TypeList(type_list)", "response": "Gets all the known Types."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_display_name(self):\n        return DisplayText(text=self.id_.get_identifier(),\n                           language_type=DEFAULT_LANGUAGE_TYPE,\n                           script_type=DEFAULT_SCRIPT_TYPE,\n                           format_type=DEFAULT_FORMAT_TYPE,)", "response": "Creates a display name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_description(self):\n        return DisplayText(text='Agent representing ' + str(self.id_),\n                           language_type=DEFAULT_LANGUAGE_TYPE,\n                           script_type=DEFAULT_SCRIPT_TYPE,\n                           format_type=DEFAULT_FORMAT_TYPE,)", "response": "Creates a description of the current locale"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if value is empty.", "response": "def empty(val):\n    \"\"\"\n    Checks if value is empty.\n    All unknown data types considered as empty values.\n    @return: bool\n    \"\"\"\n    if val == None:\n        return True\n\n    if isinstance(val,str) and len(val) > 0:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef release():\n    sh(\"paver bdist_egg\")\n\n    # Check that source distribution can be built and is complete\n    print\n    print \"~\" * 78\n    print \"TESTING SOURCE BUILD\"\n    sh(\n        \"{ cd dist/ && unzip -q %s-%s.zip && cd %s-%s/\"\n        \"  && /usr/bin/python setup.py sdist >/dev/null\"\n        \"  && if { unzip -ql ../%s-%s.zip; unzip -ql dist/%s-%s.zip; }\"\n        \"        | cut -b26- | sort | uniq -c| egrep -v '^ +2 +' ; then\"\n        \"       echo '^^^ Difference in file lists! ^^^'; false;\"\n        \"    else true; fi; } 2>&1\"\n        % tuple([project[\"name\"], version] * 4)\n    )\n    path(\"dist/%s-%s\" % (project[\"name\"], version)).rmtree()\n    print \"~\" * 78\n\n    print\n    print \"Created\", \" \".join([str(i) for i in path(\"dist\").listdir()])\n    print \"Use 'paver sdist bdist_egg upload' to upload to PyPI\"\n    print \"Use 'paver dist_docs' to prepare an API documentation upload\"", "response": "Check release before upload to PyPI"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns pylint and return a new base base", "response": "def lint():\n    \"\"\" Report pylint results.\n    \"\"\"\n    from pylint import lint as linter\n\n    # report according to file extension\n    reporters = {\n        \".html\": linter.HTMLReporter,\n        \".log\": linter.ParseableTextReporter,\n        \".txt\": linter.TextReporter,\n    }\n\n    lint_build_dir = path(\"build/lint\")\n    lint_build_dir.exists() or lint_build_dir.makedirs()\n\n    argv = []\n    rcfile = options.lint.get(\"rcfile\")\n    if not rcfile and path(\"pylint.cfg\").exists():\n        rcfile = \"pylint.cfg\"\n    if rcfile:\n        argv += [\"--rcfile\", os.path.abspath(rcfile)]\n    if options.lint.get(\"msg_only\", False):\n        argv += [\"-rn\"]\n    argv += [\n        \"--import-graph\", (lint_build_dir / \"imports.dot\").abspath(),\n    ]\n    argv += toplevel_packages()\n\n    sys.stderr.write(\"Running %s::pylint '%s'\\n\" % (sys.argv[0], \"' '\".join(argv)))\n    outfile = options.lint.get(\"output\", None)\n    if outfile:\n        outfile = os.path.abspath(outfile)\n\n    try:\n        with pushd(\"src\" if path(\"src\").exists() else \".\"):\n            if outfile:\n                reporterClass = reporters.get(path(outfile).ext, linter.TextReporter)\n                sys.stderr.write(\"Writing output to %r\\n\" % (str(outfile),))\n                linter.Run(argv, reporter=reporterClass(open(outfile, \"w\")))\n            else:\n                linter.Run(argv)\n    except SystemExit, exc:\n        if not exc.code:\n            sys.stderr.write(\"paver::lint - No problems found.\\n\")\n        elif exc.code & 32:\n            # usage error (internal error in this code)\n            sys.stderr.write(\"paver::lint - Usage error, bad arguments %r?!\\n\" % (argv,))\n            raise\n        else:\n            bits = {\n                1: \"fatal\",\n                2: \"error\",\n                4: \"warning\",\n                8: \"refactor\",\n                16: \"convention\",\n            }\n            sys.stderr.write(\"paver::lint - Some %s message(s) issued.\\n\" % (\n                \", \".join([text for bit, text in bits.items() if exc.code & bit])\n            ))\n            if exc.code & 3:\n                sys.stderr.write(\"paver::lint - Exiting due to fatal / error message.\\n\")\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting the multiprocessing job.", "response": "def start(self):\n        \"\"\"Indicate that we are performing work in a thread.\n\n        :returns: multiprocessing job object\n        \"\"\"\n\n        if self.run is True:\n            self.job = multiprocessing.Process(target=self.indicator)\n            self.job.start()\n            return self.job"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stop(self):\n\n        if self.run is True and all([self.job, self.job.is_alive()]):\n            print('Done.')\n            self.job.terminate()", "response": "Stop the indicator process."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves all CSS comment blocks.", "response": "def remove_comments(css):\n    \"\"\"Remove all CSS comment blocks.\"\"\"\n\n    iemac = False\n    preserve = False\n    comment_start = css.find(\"/*\")\n    while comment_start >= 0:\n        # Preserve comments that look like `/*!...*/`.\n        # Slicing is used to make sure we don\"t get an IndexError.\n        preserve = css[comment_start + 2:comment_start + 3] == \"!\"\n\n        comment_end = css.find(\"*/\", comment_start + 2)\n        if comment_end < 0:\n            if not preserve:\n                css = css[:comment_start]\n                break\n        elif comment_end >= (comment_start + 2):\n            if css[comment_end - 1] == \"\\\\\":\n                # This is an IE Mac-specific comment; leave this one and the\n                # following one alone.\n                comment_start = comment_end + 2\n                iemac = True\n            elif iemac:\n                comment_start = comment_end + 2\n                iemac = False\n            elif not preserve:\n                css = css[:comment_start] + css[comment_end + 2:]\n            else:\n                comment_start = comment_end + 2\n        comment_start = css.find(\"/*\", comment_start)\n\n    return css"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove unnecessary whitespace characters.", "response": "def remove_unnecessary_whitespace(css):\n    \"\"\"Remove unnecessary whitespace characters.\"\"\"\n\n    def pseudoclasscolon(css):\n\n        \"\"\"\n        Prevents 'p :link' from becoming 'p:link'.\n\n        Translates 'p :link' into 'p ___PSEUDOCLASSCOLON___link'; this is\n        translated back again later.\n        \"\"\"\n\n        regex = re.compile(r\"(^|\\})(([^\\{\\:])+\\:)+([^\\{]*\\{)\")\n        match = regex.search(css)\n        while match:\n            css = ''.join([\n                css[:match.start()],\n                match.group().replace(\":\", \"___PSEUDOCLASSCOLON___\"),\n                css[match.end():]])\n            match = regex.search(css)\n        return css\n\n    css = pseudoclasscolon(css)\n    # Remove spaces from before things.\n    css = re.sub(r\"\\s+([!{};:>+\\(\\)\\],])\", r\"\\1\", css)\n\n    # If there is a `@charset`, then only allow one, and move to the beginning.\n    css = re.sub(r\"^(.*)(@charset \\\"[^\\\"]*\\\";)\", r\"\\2\\1\", css)\n    css = re.sub(r\"^(\\s*@charset [^;]+;\\s*)+\", r\"\\1\", css)\n\n    # Put the space back in for a few cases, such as `@media screen` and\n    # `(-webkit-min-device-pixel-ratio:0)`.\n    css = re.sub(r\"\\band\\(\", \"and (\", css)\n\n    # Put the colons back.\n    css = css.replace('___PSEUDOCLASSCOLON___', ':')\n\n    # Remove spaces from after things.\n    css = re.sub(r\"([!{}:;>+\\(\\[,])\\s+\", r\"\\1\", css)\n\n    return css"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts rgb to hex.", "response": "def normalize_rgb_colors_to_hex(css):\n    \"\"\"Convert `rgb(51,102,153)` to `#336699`.\"\"\"\n\n    regex = re.compile(r\"rgb\\s*\\(\\s*([0-9,\\s]+)\\s*\\)\")\n    match = regex.search(css)\n    while match:\n        colors = [s.strip() for s in match.group(1).split(\",\")]\n        hexcolor = '#%.2x%.2x%.2x' % tuple(map(int, colors))\n        css = css.replace(match.group(), hexcolor)\n        match = regex.search(css)\n    return css"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncondense a CSS string to have a multidimensional zero.", "response": "def condense_multidimensional_zeros(css):\n    \"\"\"Replace `:0 0 0 0;`, `:0 0 0;` etc. with `:0;`.\"\"\"\n\n    css = css.replace(\":0 0 0 0;\", \":0;\")\n    css = css.replace(\":0 0 0;\", \":0;\")\n    css = css.replace(\":0 0;\", \":0;\")\n\n    # Revert `background-position:0;` to the valid `background-position:0 0;`.\n    css = css.replace(\"background-position:0;\", \"background-position:0 0;\")\n\n    return css"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef condense_hex_colors(css):\n\n    regex = re.compile(r\"([^\\\"'=\\s])(\\s*)#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\")\n    match = regex.search(css)\n    while match:\n        first = match.group(3) + match.group(5) + match.group(7)\n        second = match.group(4) + match.group(6) + match.group(8)\n        if first.lower() == second.lower():\n            css = css.replace(match.group(), match.group(1) + match.group(2) + '#' + first)\n            match = regex.search(css, match.end() - 3)\n        else:\n            match = regex.search(css, match.end())\n    return css", "response": "Shorten colors from AABBCC to ABC where possible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping the lines of the given CSS to an approximate length.", "response": "def wrap_css_lines(css, line_length):\n    \"\"\"Wrap the lines of the given CSS to an approximate length.\"\"\"\n\n    lines = []\n    line_start = 0\n    for i, char in enumerate(css):\n        # It's safe to break after `}` characters.\n        if char == '}' and (i - line_start >= line_length):\n            lines.append(css[line_start:i + 1])\n            line_start = i + 1\n\n    if line_start < len(css):\n        lines.append(css[line_start:])\n    return '\\n'.join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns default mdata map for LogEntry", "response": "def get_log_entry_mdata():\n    \"\"\"Return default mdata map for LogEntry\"\"\"\n    return {\n        'priority': {\n            'element_label': {\n                'text': 'priority',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.type.Type object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_type_values': ['NoneType%3ANONE%40dlkit.mit.edu'],\n            'syntax': 'TYPE',\n            'type_set': [],\n        },\n        'timestamp': {\n            'element_label': {\n                'text': 'timestamp',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid datetime object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_date_time_values': [MIN_DATETIME],\n            'syntax': 'DATETIME',\n            'date_time_set': []\n        },\n        'agent': {\n            'element_label': {\n                'text': 'agent',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_changeset(args):\n    # Parse the arguments.\n    parser = argparse.ArgumentParser(description=get_changeset.__doc__)\n    parser.add_argument(\n        'infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin,\n        help='path to the bundle YAML file')\n    parser.add_argument(\n        '--version', action='version', version='%(prog)s {}'.format(version))\n    options = parser.parse_args(args)\n\n    # Parse the provided YAML file.\n    try:\n        bundle = yaml.safe_load(options.infile)\n    except Exception:\n        return 'error: the provided bundle is not a valid YAML'\n\n    # Validate the bundle object.\n    errors = validation.validate(bundle)\n    if errors:\n        return '\\n'.join(errors)\n\n    # Dump the changeset to stdout.\n    print('[')\n    for num, change in enumerate(changeset.parse(bundle)):\n        if num:\n            print(',')\n        print(json.dumps(change))\n    print(']')", "response": "Dump the changeset objects as JSON reading the provided bundle YAML file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds the items from STATS QUEUE and enqueue them to the queues.", "response": "def build_items(self):\n        \"\"\"\n        get the items from STATS QUEUE\n        calculate self.stats\n        make new items from self.stats\n        put the new items for ITEM QUEUE\n        \"\"\"\n        while not self.stats_queue.empty():\n            item = self.stats_queue.get()\n            self.calculate(item)\n\n        for key, value in self.stats.iteritems():\n            if 'blackbird.queue.length' == key:\n                value = self.queue.qsize()\n            item = BlackbirdStatisticsItem(\n                key=key,\n                value=value,\n                host=self.options['hostname']\n            )\n            if self.enqueue(item=item, queue=self.queue):\n                self.logger.debug(\n                    'Inserted {0} to the queue.'.format(item.data)\n                )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if a module is valid.", "response": "def check(module):\n  global passed, failed\n  '''\n  apply pylint to the file specified if it is a *.py file\n  '''\n  module_name = module.rsplit('/', 1)[1]\n  if module[-3:] == \".py\" and module_name not in IGNORED_FILES:\n    print (\"CHECKING \", module)\n    pout = os.popen('pylint %s'% module, 'r')\n    for line in pout:\n      if \"Your code has been rated at\" in line:\n        print (\"PASSED pylint inspection: \" + line)\n        passed += 1\n        return True\n      if \"-error\" in line:\n        print (\"FAILED pylint inspection: \" + line)\n        failed += 1\n        errors.append(\"FILE: \" + module)\n        errors.append(\"FAILED pylint inspection: \" + line)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelegate to the root_filter and generate an anatomy_cache_key field filter.", "response": "def and_filter(self, filter_or_string, *args, **kwargs):\n        \"\"\"\n        Convenience method to delegate to the root_filter to generate an\n        :class:`~es_fluent.filters.core.And` clause.\n\n        :return: :class:`~es_fluent.builder.QueryBuilder`\n        \"\"\"\n        self.root_filter.and_filter(filter_or_string, *args, **kwargs)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef or_filter(self, filter_or_string, *args, **kwargs):\n        self.root_filter.or_filter(filter_or_string, *args, **kwargs)\n        return self", "response": "A convenience method to delegate to the root_filter method to generate an or clause."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_filter(self, filter_or_string, *args, **kwargs):\n        self.root_filter.add_filter(filter_or_string, *args, **kwargs)\n        return self", "response": "Adds a filter to the query builder s filters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the sort criteria affecting field_name.", "response": "def remove_sort(self, field_name):\n        \"\"\"\n        Clears sorting criteria affecting ``field_name``.\n        \"\"\"\n        self.sorts = [dict(field=value) for field, value in self.sorts if field\n                      is not field_name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef matchPrefix(text):\n    basekeys = []\n    if not text[0].isdigit():\n        if ord(text[0].lower()) in range(ord('a'), ord('z') + 1):\n            basekeys = ['dt:date:eng1', 'dt:date:date_eng1x', 'dt:date:eng3', 'dt:date:date_eng2_lc', 'dt:date:date_eng2',\n                        'dt:date:date_eng2_short', 'dt:date:date_eng3',\n                        'dt:date:weekday_eng', 'dt:date:weekday_eng_lc', 'dt:date:weekday_eng_wshort',\n                        'dt:date:weekday_eng_iso',\n                        'dt:date:weekday_short_eng_iso',\n                        'dt:date:fr_base_article', 'dt:date:fr_base_lc_article', 'dt:date:weekday_eng_mshort_wshort', ]\n            basekeys += ['dt:date:pt_base', 'dt:date:pt_base_lc', 'dt:date:pt_base_article',\n                         'dt:date:pt_base_lc_article']\n            basekeys += ['dt:date:es_base', 'dt:date:es_base_lc', 'dt:date:es_base_article',\n                         'dt:date:es_base_lc_article', 'dt:date:es_rare_1', 'dt:date:es_rare_2']\n            basekeys += ['dt:date:it_base', 'dt:date:it_base_lc', 'dt:date:it_base_article',\n                         'dt:date:it_base_lc_article', 'dt:date:it_rare_1', 'dt:date:it_rare_2']\n        else:\n            basekeys = ['dt:date:weekday_rus', 'dt:date:weekday_rus_lc1', 'dt:date:rare_5', 'dt:date:rare_6', ]\n    else:\n        if text[1] == '.' or text[2] == '.':\n            basekeys = ['dt:date:date_2', 'dt:date:date_4', 'dt:date:date_rus3', 'dt:date:date_4_point',\n                        'dt:date:date_eng1', 'dt:date:noyear_1',\n                        'dt:date:rare_2', 'dt:date:rare_3', ]\n            basekeys += ['dt:date:de_base', 'dt:date:de_base_lc']\n        elif text[1] == ',' or text[2] == ',':\n            basekeys = ['dt:date:date_rus', ]\n        elif text[1] == '/' or text[2] == '/':\n            basekeys = ['dt:date:date_1', 'dt:date:date_9', \"dt:date:date_8\", 'dt:date:date_usa', 'dt:date:date_usa_1',\n                        'dt:date:rare_1']\n        elif text[1] == '-' or text[2] == '-':\n            basekeys = ['dt:date:date_iso8601', 'dt:date:date_iso8601_short']\n        elif text[4] == '-':\n            basekeys = ['dt:date:date_iso8601', 'dt:date:date_9']\n        elif text[4] == '.':\n            basekeys = ['dt:date:date_10']\n        else:\n            basekeys = ['dt:date:date_3', 'dt:date:date_5', 'dt:date:date_6', 'dt:date:date_7', 'dt:date:date_rus',\n                        'dt:date:date_rus2', 'dt:date:date_rus_lc1',\n                        'dt:date:date_rus_lc2', 'dt:date:date_eng1', 'dt:date:date_eng1_short',\n                        'dt:date:date_eng1_lc', 'dt:date:date_eng1xx']\n            # I have to add others date keys since sometimes spaces used in date inside\n            basekeys += ['dt:date:date_1', 'dt:date:date_9', \"dt:date:date_8\", 'dt:date:date_usa', 'dt:date:date_usa_1',\n                         'dt:date:rare_1',\n                         'dt:date:rare_2', 'dt:date:rare_3', 'dt:date:rare_4', 'dt:date:date_5', 'dt:date:fr_base',\n                         'dt:date:fr_base_lc']\n            # Adding portugal dates\n            basekeys += ['dt:date:pt_base_article', 'dt:date:pt_base_lc_article', 'dt:date:pt_base',\n                         'dt:date:pt_base_lc']\n            # Adding german dates\n            basekeys += ['dt:date:de_base', 'dt:date:de_base_lc']\n            # Adding bulgarian dates\n            basekeys += ['dt:date:bg_base', 'dt:date:bg_base_lc']\n            # Adding spanish dates\n            basekeys += ['dt:date:es_base', 'dt:date:es_base_lc', 'dt:date:es_base_article',\n                         'dt:date:es_base_lc_article']\n            basekeys += ['dt:date:it_base', 'dt:date:it_base_lc', 'dt:date:it_base_article',\n                         'dt:date:it_base_lc_article']\n    #        print('Basekeys', basekeys, 'for', text)\n    return basekeys", "response": "This function matches the prefix of a given text with the algorithm in the order they appear."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the catalog hierarchy id", "response": "def _get_catalog_hierarchy_id(self, catalog_id, proxy, runtime):\n        \"\"\"Gets the catalog hierarchy\"\"\"\n        seed_str = convert_catalog_id_to_object_id_string(catalog_id)\n        ident = Id(authority=self._authority,\n                   namespace='hierarchy.Hierarchy',\n                   identifier=seed_str)\n        return HierarchyLookupSession(proxy, runtime).get_hierarchy(ident).get_id()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_catalog_hierarchy(self, catalog_id, proxy, runtime):\n        seed_str = convert_catalog_id_to_object_id_string(catalog_id)\n        has = HierarchyAdminSession(proxy, runtime)\n        hfc = has.get_hierarchy_form_for_create([])\n        hfc.set_display_name(catalog_id.get_identifier().title() + ' Hierarchy')\n        hfc.set_description(\n            'Hierarchy for ' + catalog_id.get_authority().title() +\n            ' ' + catalog_id.get_identifier().title())\n        hfc.set_genus_type(Type(authority='DLKIT',\n                                namespace='hierarchy.Hierarchy',\n                                identifier=catalog_id.get_identifier().lower()))\n        # This next tricks require serious inside knowledge:\n        hfc._my_map['_id'] = ObjectId(seed_str)\n        hierarchy = has.create_hierarchy(hfc)\n        return hierarchy.get_id()", "response": "Creates a catalog hierarchy"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the relationship type", "response": "def _set_relationship_type(self, type_identifier, display_name=None, display_label=None, description=None, domain='Relationship'):\n        \"\"\"Sets the relationship type\"\"\"\n        if display_name is None:\n            display_name = type_identifier\n        if display_label is None:\n            display_label = display_name\n        if description is None:\n            description = 'Relationship Type for ' + display_name\n        self._relationship_type = Type(authority='DLKIT',\n                                       namespace='relationship.Relationship',\n                                       identifier=type_identifier,\n                                       display_name=display_name,\n                                       display_label=display_label,\n                                       description=description,\n                                       domain=domain)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_roots(self):\n        id_list = []\n        for r in self._rls.get_relationships_by_genus_type_for_source(self._phantom_root_id, self._relationship_type):\n            id_list.append(r.get_destination_id())\n        return IdList(id_list)", "response": "Gets the root nodes of this hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if an Id is a direct parent of another.", "response": "def is_parent(self, id_, parent_id):\n        \"\"\"Tests if an ``Id`` is a direct parent of another.\n\n        arg:    id (osid.id.Id): the ``Id`` to query\n        arg:    parent_id (osid.id.Id): the ``Id`` of a parent\n        return: (boolean) - ``true`` if this ``parent_id`` is a parent\n                of ``id,``  ``false`` otherwise\n        raise:  NotFound - ``id`` is not found\n        raise:  NullArgument - ``id`` or ``parent_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``parent_id`` not found return\n        ``false``.\n\n        \"\"\"\n        return bool(self._rls.get_relationships_by_genus_type_for_peers(\n            parent_id,\n            id_,\n            self._relationship_type).available())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the parents of the given id.", "response": "def get_parents(self, id_):\n        \"\"\"Gets the parents of the given ``id``.\n\n        arg:    id (osid.id.Id): the ``Id`` to query\n        return: (osid.id.IdList) - the parents of the ``id``\n        raise:  NotFound - ``id`` is not found\n        raise:  NullArgument - ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        id_list = []\n        for r in self._rls.get_relationships_by_genus_type_for_destination(id_, self._relationship_type):\n            ident = r.get_source_id()\n            if ident != self._phantom_root_id:\n                id_list.append(ident)\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if a node is a direct child of another.", "response": "def is_child(self, id_, child_id):\n        \"\"\"Tests if a node is a direct child of another.\n\n        arg:    id (osid.id.Id): the ``Id`` to query\n        arg:    child_id (osid.id.Id): the ``Id`` of a child\n        return: (boolean) - ``true`` if this ``child_id`` is a child of\n                the ``Id,``  ``false`` otherwise\n        raise:  NotFound - ``id`` is not found\n        raise:  NullArgument - ``id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``child_id`` not found return\n        ``false``.\n\n        \"\"\"\n        return bool(self._rls.get_relationships_by_genus_type_for_peers(\n            id_,\n            child_id,\n            self._relationship_type).available())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_children(self, id_):\n        id_list = []\n        for r in self._rls.get_relationships_by_genus_type_for_source(id_, self._relationship_type):\n            id_list.append(r.get_destination_id())\n        return IdList(id_list)", "response": "Gets the children of the given Id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_nodes(self, id_, ancestor_levels=10, descendant_levels=10, include_siblings=False):\n        # This impl ignores include_siblings, assumes false\n        include_siblings = bool(include_siblings)\n        parent_node_list = []\n        child_node_list = []\n        if ancestor_levels != 0:\n            for parent_id in self.get_parents(id_):\n                parent_node_list.append(self.get_nodes(parent_id, ancestor_levels - 1, 0))\n        if descendant_levels != 0:\n            for child_id in self.get_children(id_):\n                child_node_list.append(self.get_nodes(child_id, 0, descendant_levels - 1))\n        return objects.Node({'type': 'OsidNode',\n                             'id': str(id_),\n                             'childNodes': child_node_list,\n                             'parentNodes': parent_node_list,\n                             'root': not self.has_parents(id_),\n                             'leaf': not self.has_children(id_),\n                             'sequestered': False})", "response": "Gets a portion of the hierarchy for the given Id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_root(self, id_):\n        if (bool(self._rls.get_relationships_by_genus_type_for_source(id_, self._relationship_type).available()) or\n                bool(self._rls.get_relationships_by_genus_type_for_destination(id_, self._relationship_type).available())):\n            raise errors.AlreadyExists()\n        self._assign_as_root(id_)", "response": "Adds a root node."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a child to a node.", "response": "def add_child(self, id_, child_id):\n        \"\"\"Adds a child to a ``Id``.\n\n        arg:    id (osid.id.Id): the ``Id`` of the node\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``child_id`` is already a child of\n                ``id``\n        raise:  NotFound - ``id`` or ``child_id`` not found\n        raise:  NullArgument - ``id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if bool(self._rls.get_relationships_by_genus_type_for_peers(id_, child_id, self._relationship_type).available()):\n            raise errors.AlreadyExists()\n        rfc = self._ras.get_relationship_form_for_create(id_, child_id, [])\n        rfc.set_display_name(str(id_) + ' to ' + str(child_id) + ' Parent-Child Relationship')\n        rfc.set_description(self._relationship_type.get_display_name().get_text() + ' relationship for parent: ' + str(id_) + ' and child: ' + str(child_id))\n        rfc.set_genus_type(self._relationship_type)\n        self._ras.create_relationship(rfc)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_root(self, id_):\n        result = self._rls.get_relationships_by_genus_type_for_peers(self._phantom_root_id, id_, self._relationship_type)\n        if not bool(result.available()):\n            raise errors.NotFound()\n        self._ras.delete_relationship(result.get_next_relationship().get_id())\n        self._adopt_orphans(id_)", "response": "Removes a root node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_child(self, id_, child_id):\n        result = self._rls.get_relationships_by_genus_type_for_peers(id_, child_id, self._relationship_type)\n        if not bool(result.available()):\n            raise errors.NotFound()\n        self._ras.delete_relationship(result.get_next_relationship().get_id())", "response": "Removes a child from an Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_children(self, id_):\n        results = self._rls.get_relationships_by_genus_type_for_source(id_, self._relationship_type)\n        if results.available() == 0:\n            raise errors.NotFound()\n        for r in results:\n            self._ras.delete_relationship(r.get_id())", "response": "Removes all childrenfrom an Id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _adopt_orphans(self, negligent_parent_id):\n        for child_id in self._hts.get_children(negligent_parent_id):\n            self.remove_child(negligent_parent_id, child_id)\n            if not self._hts.has_parents(child_id):\n                self._assign_as_root(child_id)", "response": "Clean up orphaned children and assign them as root."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nassigning an id_ a root object in the hierarchy", "response": "def _assign_as_root(self, id_):\n        \"\"\"Assign an id_ a root object in the hierarchy\"\"\"\n        rfc = self._ras.get_relationship_form_for_create(self._phantom_root_id, id_, [])\n        rfc.set_display_name('Implicit Root to ' + str(id_) + ' Parent-Child Relationship')\n        rfc.set_description(self._relationship_type.get_display_name().get_text() + ' relationship for implicit root and child: ' + str(id_))\n        rfc.set_genus_type(self._relationship_type)\n        self._ras.create_relationship(rfc)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef can_create_hierarchy_with_record_types(self, hierarchy_record_types):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=hierarchy_record_types)\n        return True", "response": "Tests if this user can create a single Hierarchy using the desired record types."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_hierarchy(self, hierarchy_form):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=hierarchy_form)\n        collection = JSONClientValidated('hierarchy',\n                                         collection='Hierarchy',\n                                         runtime=self._runtime)\n        if not isinstance(hierarchy_form, ABCHierarchyForm):\n            raise errors.InvalidArgument('argument type is not an HierarchyForm')\n        if not hierarchy_form.is_for_update():\n            raise errors.InvalidArgument('the HierarchyForm is for update only, not create')\n        try:\n            if self._forms[hierarchy_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('hierarchy_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('hierarchy_form did not originate from this session')\n        if not hierarchy_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(hierarchy_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[hierarchy_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Hierarchy(osid_object_map=hierarchy_form._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Updates an existing hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting a ``Hierarchy``. arg: hierarchy_id (osid.id.Id): the ``Id`` of the ``Hierarchy`` to remove raise: NotFound - ``hierarchy_id`` not found raise: NullArgument - ``hierarchy_id`` is ``null`` raise: OperationFailed - unable to complete request raise: PermissionDenied - authorization failure *compliance: mandatory -- This method must be implemented.*", "response": "def delete_hierarchy(self, hierarchy_id):\n        \"\"\"Deletes a ``Hierarchy``.\n\n        arg:    hierarchy_id (osid.id.Id): the ``Id`` of the\n                ``Hierarchy`` to remove\n        raise:  NotFound - ``hierarchy_id`` not found\n        raise:  NullArgument - ``hierarchy_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('hierarchy',\n                                         collection='Hierarchy',\n                                         runtime=self._runtime)\n        if not isinstance(hierarchy_id, ABCId):\n            return InvalidArgument('the argument is not a valid OSID Id')\n\n        # Should we delete the underlying Relationship Family here???\n\n        collection.delete_one({'_id': ObjectId(hierarchy_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an Id to an existing hierarchy.", "response": "def alias_hierarchy(self, hierarchy_id, alias_id):\n        \"\"\"Adds an ``Id`` to a ``Hierarchy`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``Hierarchy`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another vault it is\n        reassigned to the given vault ``Id``.\n\n        arg:    hierarchy_id (osid.id.Id): the ``Id`` of an\n                ``Hierarchy``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``hierarchy_id`` not found\n        raise:  NullArgument - ``hierarchy_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=hierarchy_id, alias_id=alias_id)\n        self._alias_id(primary_id=hierarchy_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the underlying bank view to match current view", "response": "def _set_bank_view(self, session):\n        \"\"\"Sets the underlying bank view to match current view\"\"\"\n        if self._bank_view == COMPARATIVE:\n            try:\n                session.use_comparative_bank_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_bank_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef use_plenary_bank_view(self):\n        self._bank_view = PLENARY\n        # self._get_provider_session('item_bank_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_bank_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider ItemBankSession. use_plenary_bank_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_banks_by_item(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        catalogs = self._get_provider_session('item_bank_session').get_banks_by_item(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Bank(self._provider_manager, cat, self._runtime, self._proxy))\n        return BankList(cat_list)", "response": "Pass through to provider ItemBankSession. get_banks_by_item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_bank(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bin\n        return Bank(\n            self._provider_manager,\n            self._get_provider_session('bank_lookup_session').get_bank(*args, **kwargs),\n            self._runtime,\n            self._proxy)", "response": "Pass through to provider BankLookupSession. get_bank"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider BankLookupSession. get_banks", "response": "def get_banks(self):\n        \"\"\"Pass through to provider BankLookupSession.get_banks\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('bank_lookup_session').get_banks()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Bank(self._provider_manager, cat, self._runtime, self._proxy))\n        return BankList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npasses through to provider BankAdminSession. get_bank_form_for_update", "response": "def get_bank_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider BankAdminSession.get_bank_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'bank_record_types' in kwargs:\n            return self.get_bank_form_for_create(*args, **kwargs)\n        else:\n            return self.get_bank_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_bank(self, bank_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if bank_form.is_for_update():\n            return self.update_bank(bank_form, *args, **kwargs)\n        else:\n            return self.create_bank(bank_form, *args, **kwargs)", "response": "Pass through to provider BankAdminSession. update_bank"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef use_comparative_assessment_part_bank_view(self):\n        self._bank_view = COMPARATIVE\n        # self._get_provider_session('assessment_part_bank_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_bank_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssessmentPartBankSession. use_comparative_assessment_part_bank_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the underlying bank view to match current view", "response": "def _set_bank_view(self, session):\n        \"\"\"Sets the underlying bank view to match current view\"\"\"\n        if self._bank_view == FEDERATED:\n            try:\n                session.use_federated_bank_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_bank_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_sub_package_provider_session(self, sub_package, session_name, proxy=None):\n        agent_key = self._get_agent_key()\n        if session_name in self._provider_sessions[agent_key]:\n            return self._provider_sessions[agent_key][session_name]\n        else:\n            manager = self._get_sub_package_provider_manager(sub_package)\n            session = self._instantiate_session('get_' + session_name + '_for_bank',\n                                                proxy=self._proxy,\n                                                manager=manager)\n            self._set_bank_view(session)\n            self._set_object_view(session)\n            self._set_operable_view(session)\n            self._set_containable_view(session)\n            if self._session_management != DISABLED:\n                self._provider_sessions[agent_key][session_name] = session\n            return session", "response": "Gets the session from a sub - package."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef use_comparative_item_view(self):\n        self._object_views['item'] = COMPARATIVE\n        # self._get_provider_session('item_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_item_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider ItemLookupSession. use_comparative_item_view"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npasses through to provider ItemLookupSession. use_plenary_item_view", "response": "def use_plenary_item_view(self):\n        \"\"\"Pass through to provider ItemLookupSession.use_plenary_item_view\"\"\"\n        self._object_views['item'] = PLENARY\n        # self._get_provider_session('item_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_item_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npassing through to provider ItemLookupSession. use_federated_bank_view", "response": "def use_federated_bank_view(self):\n        \"\"\"Pass through to provider ItemLookupSession.use_federated_bank_view\"\"\"\n        self._bank_view = FEDERATED\n        # self._get_provider_session('item_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_federated_bank_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider ItemLookupSession. use_isolated_bank_view", "response": "def use_isolated_bank_view(self):\n        \"\"\"Pass through to provider ItemLookupSession.use_isolated_bank_view\"\"\"\n        self._bank_view = ISOLATED\n        # self._get_provider_session('item_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_isolated_bank_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass through to provider ItemAdminSession. get_item_form_for_update", "response": "def get_item_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider ItemAdminSession.get_item_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'item_record_types' in kwargs:\n            return self.get_item_form_for_create(*args, **kwargs)\n        else:\n            return self.get_item_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_item(self, item_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if item_form.is_for_update():\n            return self.update_item(item_form, *args, **kwargs)\n        else:\n            return self.create_item(item_form, *args, **kwargs)", "response": "Pass through to provider ItemAdminSession. update_item"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider AssessmentLookupSession. use_comparative_assessment_view", "response": "def use_comparative_assessment_view(self):\n        \"\"\"Pass through to provider AssessmentLookupSession.use_comparative_assessment_view\"\"\"\n        self._object_views['assessment'] = COMPARATIVE\n        # self._get_provider_session('assessment_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_assessment_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider AssessmentLookupSession. use_plenary_assessment_view", "response": "def use_plenary_assessment_view(self):\n        \"\"\"Pass through to provider AssessmentLookupSession.use_plenary_assessment_view\"\"\"\n        self._object_views['assessment'] = PLENARY\n        # self._get_provider_session('assessment_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_assessment_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessment_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'assessment_record_types' in kwargs:\n            return self.get_assessment_form_for_create(*args, **kwargs)\n        else:\n            return self.get_assessment_form_for_update(*args, **kwargs)", "response": "Pass through to provider AssessmentAdminSession. get_assessment_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider AssessmentAdminSession. update_assessment", "response": "def save_assessment(self, assessment_form, *args, **kwargs):\n        \"\"\"Pass through to provider AssessmentAdminSession.update_assessment\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if assessment_form.is_for_update():\n            return self.update_assessment(assessment_form, *args, **kwargs)\n        else:\n            return self.create_assessment(assessment_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider methods.", "response": "def add_item(self, *args, **kwargs):\n        \"\"\"Pass through to provider methods.\"\"\"\n        try:\n            self._get_provider_session('assessment_basic_authoring_session').add_item(*args, **kwargs)\n        except InvalidArgument:\n            self._get_sub_package_provider_session(\n                'assessment_authoring', 'assessment_part_item_design_session').add_item(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_item(self, *args, **kwargs):\n        try:\n            self._get_provider_session('assessment_basic_authoring_session').remove_item(*args, **kwargs)\n        except InvalidArgument:\n            self._get_sub_package_provider_session(\n                'assessment_authoring', 'assessment_part_item_design_session').remove_item(*args, **kwargs)", "response": "Pass through to provider methods."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider methods.", "response": "def order_items(self, *args, **kwargs):\n        \"\"\"Pass through to provider methods.\"\"\"\n        try:\n            self._get_provider_session('assessment_basic_authoring_session').order_items(*args, **kwargs)\n        except InvalidArgument:\n            self._get_sub_package_provider_session(\n                'assessment_authoring', 'assessment_part_item_design_session').order_items(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef use_comparative_assessment_offered_view(self):\n        self._object_views['assessment_offered'] = COMPARATIVE\n        # self._get_provider_session('assessment_offered_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_assessment_offered_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssessmentOfferedLookupSession. use_comparative_assessment_offered_view"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass through to provider AssessmentOfferedLookupSession. use_plenary_assessment_offered_view", "response": "def use_plenary_assessment_offered_view(self):\n        \"\"\"Pass through to provider AssessmentOfferedLookupSession.use_plenary_assessment_offered_view\"\"\"\n        self._object_views['assessment_offered'] = PLENARY\n        # self._get_provider_session('assessment_offered_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_assessment_offered_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assessment_offered_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'assessment_offered_record_types' in kwargs:\n            return self.get_assessment_offered_form_for_create(*args, **kwargs)\n        else:\n            return self.get_assessment_offered_form_for_update(*args, **kwargs)", "response": "Pass through to provider AssessmentOfferedAdminSession. get_assessment_offered_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_assessment_offered(self, assessment_offered_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if assessment_offered_form.is_for_update():\n            return self.update_assessment_offered(assessment_offered_form, *args, **kwargs)\n        else:\n            return self.create_assessment_offered(assessment_offered_form, *args, **kwargs)", "response": "Pass through to provider AssessmentOfferedAdminSession. update_assessment_offered"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npass through to provider AssessmentTakenLookupSession. use_comparative_assessment_taken_view", "response": "def use_comparative_assessment_taken_view(self):\n        \"\"\"Pass through to provider AssessmentTakenLookupSession.use_comparative_assessment_taken_view\"\"\"\n        self._object_views['assessment_taken'] = COMPARATIVE\n        # self._get_provider_session('assessment_taken_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_assessment_taken_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider AssessmentTakenLookupSession. use_plenary_assessment_taken_view", "response": "def use_plenary_assessment_taken_view(self):\n        \"\"\"Pass through to provider AssessmentTakenLookupSession.use_plenary_assessment_taken_view\"\"\"\n        self._object_views['assessment_taken'] = PLENARY\n        # self._get_provider_session('assessment_taken_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_assessment_taken_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assessment_taken_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'assessment_taken_record_types' in kwargs:\n            return self.get_assessment_taken_form_for_create(*args, **kwargs)\n        else:\n            return self.get_assessment_taken_form_for_update(*args, **kwargs)", "response": "Pass through to provider AssessmentTakenAdminSession. get_assessment_taken_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_assessment_taken(self, assessment_taken_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if assessment_taken_form.is_for_update():\n            return self.update_assessment_taken(assessment_taken_form, *args, **kwargs)\n        else:\n            return self.create_assessment_taken(assessment_taken_form, *args, **kwargs)", "response": "Pass through to provider AssessmentTakenAdminSession. update_assessment_taken"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider AssessmentPartLookupSession. use_comparative_assessment_part_view", "response": "def use_comparative_assessment_part_view(self):\n        \"\"\"Pass through to provider AssessmentPartLookupSession.use_comparative_assessment_part_view\"\"\"\n        self._object_views['assessment_part'] = COMPARATIVE\n        # self._get_provider_session('assessment_part_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_assessment_part_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npass through to provider AssessmentPartLookupSession. use_plenary_assessment_part_view", "response": "def use_plenary_assessment_part_view(self):\n        \"\"\"Pass through to provider AssessmentPartLookupSession.use_plenary_assessment_part_view\"\"\"\n        self._object_views['assessment_part'] = PLENARY\n        # self._get_provider_session('assessment_part_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_assessment_part_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef use_active_assessment_part_view(self):\n        self._operable_views['assessment_part'] = ACTIVE\n        # self._get_provider_session('assessment_part_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_active_assessment_part_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssessmentPartLookupSession. use_active_assessment_part_view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider AssessmentPartLookupSession. use_any_status_assessment_part_view", "response": "def use_any_status_assessment_part_view(self):\n        \"\"\"Pass through to provider AssessmentPartLookupSession.use_any_status_assessment_part_view\"\"\"\n        self._operable_views['assessment_part'] = ANY_STATUS\n        # self._get_provider_session('assessment_part_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_any_status_assessment_part_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef use_sequestered_assessment_part_view(self):\n        # Does this need to be re-implemented to match the other non-sub-package view setters?\n        self._containable_views['assessment_part'] = SEQUESTERED\n        self._get_sub_package_provider_session('assessment_authoring',\n                                               'assessment_part_lookup_session')\n        for session in self._provider_sessions:\n            for provider_session_name, provider_session in self._provider_sessions[session].items():\n                try:\n                    provider_session.use_sequestered_assessment_part_view()\n                except AttributeError:\n                    pass", "response": "Pass through to provider AssessmentPartLookupSession. use_sequestered_assessment_part_view"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_unsequestered_assessment_part_view(self):\n        # Does this need to be re-implemented to match the other non-sub-package view setters?\n        self._containable_views['assessment_part'] = UNSEQUESTERED\n        self._get_sub_package_provider_session('assessment_authoring',\n                                               'assessment_part_lookup_session')\n        for session in self._provider_sessions:\n            for provider_session_name, provider_session in self._provider_sessions[session].items():\n                try:\n                    provider_session.use_unsequestered_assessment_part_view()\n                except AttributeError:\n                    pass", "response": "Pass through to provider AssessmentPartLookupSession. use_unsequestered_assessment_part_view"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assessment_part_form(self, *args, **kwargs):\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'assessment_part_record_types' in kwargs:\n            return self.get_assessment_part_form_for_create(*args, **kwargs)\n        else:\n            return self.get_assessment_part_form_for_update(*args, **kwargs)", "response": "Pass through to provider AssessmentPartAdminSession. get_assessment_part_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_assessment_part(self, assessment_part_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if assessment_part_form.is_for_update():\n            return self.update_assessment_part(assessment_part_form, *args, **kwargs)\n        else:\n            return self.create_assessment_part(assessment_part_form, *args, **kwargs)", "response": "Pass through to provider AssessmentPartAdminSession. update_assessment_part"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_comparative_asseessment_part_item_view(self):\n        self._object_views['asseessment_part_item'] = COMPARATIVE\n        # self._get_provider_session('assessment_part_item_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_asseessment_part_item_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssessmentPartItemSession. use_comparative_asseessment_part_item_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use_plenary_assessment_part_item_view(self):\n        self._object_views['assessment_part_item'] = PLENARY\n        # self._get_provider_session('assessment_part_item_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_assessment_part_item_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssessmentPartItemSession. use_plenary_assessment_part_item_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use_comparative_sequence_rule_view(self):\n        self._object_views['sequence_rule'] = COMPARATIVE\n        # self._get_provider_session('sequence_rule_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_sequence_rule_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider SequenceRuleLookupSession. use_comparative_sequence_rule_view"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef use_plenary_sequence_rule_view(self):\n        self._object_views['sequence_rule'] = PLENARY\n        # self._get_provider_session('sequence_rule_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_sequence_rule_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider SequenceRuleLookupSession. use_plenary_sequence_rule_view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider SequenceRuleLookupSession. use_active_sequence_rule_view", "response": "def use_active_sequence_rule_view(self):\n        \"\"\"Pass through to provider SequenceRuleLookupSession.use_active_sequence_rule_view\"\"\"\n        self._operable_views['sequence_rule'] = ACTIVE\n        # self._get_provider_session('sequence_rule_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_active_sequence_rule_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use_any_status_sequence_rule_view(self):\n        self._operable_views['sequence_rule'] = ANY_STATUS\n        # self._get_provider_session('sequence_rule_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_any_status_sequence_rule_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider SequenceRuleLookupSession. use_any_status_sequence_rule_view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npassing through to provider SequenceRuleAdminSession. update_sequence_rule", "response": "def save_sequence_rule(self, sequence_rule_form, *args, **kwargs):\n        \"\"\"Pass through to provider SequenceRuleAdminSession.update_sequence_rule\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if sequence_rule_form.is_for_update():\n            return self.update_sequence_rule(sequence_rule_form, *args, **kwargs)\n        else:\n            return self.create_sequence_rule(sequence_rule_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef use_comparative_sequence_rule_enabler_view(self):\n        self._object_views['sequence_rule_enabler'] = COMPARATIVE\n        # self._get_provider_session('sequence_rule_enabler_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_sequence_rule_enabler_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider SequenceRuleEnablerLookupSession. use_comparative_sequence_rule_enabler_view"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef use_plenary_sequence_rule_enabler_view(self):\n        self._object_views['sequence_rule_enabler'] = PLENARY\n        # self._get_provider_session('sequence_rule_enabler_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_sequence_rule_enabler_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider SequenceRuleEnablerLookupSession. use_plenary_sequence_rule_enabler_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use_active_sequence_rule_enabler_view(self):\n        self._operable_views['sequence_rule_enabler'] = ACTIVE\n        # self._get_provider_session('sequence_rule_enabler_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_active_sequence_rule_enabler_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider SequenceRuleEnablerLookupSession. use_active_sequence_rule_enabler_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider SequenceRuleEnablerLookupSession. use_any_status_sequence_rule_enabler_view", "response": "def use_any_status_sequence_rule_enabler_view(self):\n        \"\"\"Pass through to provider SequenceRuleEnablerLookupSession.use_any_status_sequence_rule_enabler_view\"\"\"\n        self._operable_views['sequence_rule_enabler'] = ANY_STATUS\n        # self._get_provider_session('sequence_rule_enabler_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_any_status_sequence_rule_enabler_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider SequenceRuleEnablerAdminSession. get_sequence_rule_enabler_form_for_update", "response": "def get_sequence_rule_enabler_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider SequenceRuleEnablerAdminSession.get_sequence_rule_enabler_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'sequence_rule_enabler_record_types' in kwargs:\n            return self.get_sequence_rule_enabler_form_for_create(*args, **kwargs)\n        else:\n            return self.get_sequence_rule_enabler_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npasses through to provider SequenceRuleEnablerAdminSession. update_sequence_rule_enabler", "response": "def save_sequence_rule_enabler(self, sequence_rule_enabler_form, *args, **kwargs):\n        \"\"\"Pass through to provider SequenceRuleEnablerAdminSession.update_sequence_rule_enabler\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if sequence_rule_enabler_form.is_for_update():\n            return self.update_sequence_rule_enabler(sequence_rule_enabler_form, *args, **kwargs)\n        else:\n            return self.create_sequence_rule_enabler(sequence_rule_enabler_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npass through to provider SequenceRuleEnablerRuleLookupSession. use_comparative_sequence_rule_enabler_rule_view", "response": "def use_comparative_sequence_rule_enabler_rule_view(self):\n        \"\"\"Pass through to provider SequenceRuleEnablerRuleLookupSession.use_comparative_sequence_rule_enabler_rule_view\"\"\"\n        self._object_views['sequence_rule_enabler_rule'] = COMPARATIVE\n        # self._get_provider_session('sequence_rule_enabler_rule_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_sequence_rule_enabler_rule_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider SequenceRuleEnablerRuleLookupSession. use_plenary_sequence_rule_enabler_rule_view", "response": "def use_plenary_sequence_rule_enabler_rule_view(self):\n        \"\"\"Pass through to provider SequenceRuleEnablerRuleLookupSession.use_plenary_sequence_rule_enabler_rule_view\"\"\"\n        self._object_views['sequence_rule_enabler_rule'] = PLENARY\n        # self._get_provider_session('sequence_rule_enabler_rule_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_sequence_rule_enabler_rule_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_map(self):\n        self.my_osid_object_form._my_map['confusedLearningObjectiveIds'] = \\\n            self._confused_learning_objectives_metadata['default_list_values'][0]\n        self.my_osid_object_form._my_map['feedback'] = \\\n            self._feedback_metadata['default_string_values'][0]", "response": "Initialize the map with the default values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the metadata for the object.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._min_string_length = None\n        self._max_string_length = None\n        self._confused_learning_objectives_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'confusedLearningObjectiveIds'),\n            'element_label': 'Confused Learning Objectives',\n            'instructions': 'List of IDs',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_list_values': [[]],\n            'syntax': 'LIST'\n        }\n        self._feedback_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'feedback'),\n            'element_label': 'Feedback',\n            'instructions': 'enter a feedback string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': self._min_string_length,\n            'maximum_string_length': self._max_string_length,\n            'string_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_metadata(self):\n        self._confused_learning_objectives_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'confusedLearningObjectiveIds'),\n            'element_label': 'Confused Learning Objectives',\n            'instructions': 'List of IDs',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_list_values': [[]],\n            'syntax': 'LIST'\n        }\n        self._feedbacks_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'feedbacks'),\n            'element_label': 'Feedbacks',\n            'instructions': 'Enter as many text feedback strings as you wish',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }", "response": "Initialize metadata for the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _extract_params_from_i0(only_variable_parameters, parameters_with_variability, initial_conditions_with_variability):\n\n    complete_params = []\n    counter = 0\n    for param, is_variable in parameters_with_variability:\n        # If param not variable, add it from param list\n        if not is_variable:\n            complete_params.append(param)\n        else:\n            # Otherwise add it from variable parameters list\n            complete_params.append(only_variable_parameters[counter])\n            counter += 1\n\n    complete_initial_conditions = []\n    for initial_condition, is_variable in initial_conditions_with_variability:\n        if not is_variable:\n            complete_initial_conditions.append(initial_condition)\n        else:\n            complete_initial_conditions.append(only_variable_parameters[counter])\n            counter += 1\n\n    return complete_params, complete_initial_conditions", "response": "This function extracts the parameters and initial conditions from the i0 list of variables that we want to be used during that interaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef infer(self, number_of_processes=1, *args, **kwargs):\n        if number_of_processes == 1:\n            results = map(lambda x: x.infer(*args, **kwargs), self._inference_objects)\n        else:\n            inference_objects = self._inference_objects\n            results = raw_results_in_parallel(self._inference_objects, number_of_processes, *args,\n                                              **kwargs)\n            results = [inference._result_from_raw_result(raw_result)\n                       for inference, raw_result in zip(inference_objects, results)]\n\n\n        results = sorted(results, key=lambda x: x.distance_at_minimum)\n\n        return InferenceResultsCollection(results)", "response": "Infer the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates the values_with_variability and constraints for the internal list of the internal list of the resource entries.", "response": "def _generate_values_with_variability_and_constraints(self, symbols, starting_values, variable_parameters):\n        \"\"\"\n        Generates the `values_with_variability` formatted list\n        from the provided symbols, starting values and variable parameters\n\n        :param symbols: The symbols defining each of the values in the starting values list\n        :param starting_values: the actual starting values\n        :param variable_parameters: a dictionary/set/list of variables that are variable\n                                    if dictionary provided, the contents should be `symbol: range` where range is\n                                    a tuple ``(min_val, max_val)`` of allowed parameter values or ``None`` for no limit.\n                                    if set/list provided, the ranges will be assumed to be ``None`` for each of\n                                    the parameters\n        :type variable_parameters: dict|iterable\n        :return:\n        \"\"\"\n        values_with_variability = []\n        constraints = []\n\n        if not isinstance(variable_parameters, dict):\n            # Convert non/dict representations to Dict with nones\n            variable_parameters = {p: None for p in variable_parameters}\n\n        for parameter, parameter_value in zip(symbols, starting_values):\n            try:\n                constraint = variable_parameters[parameter]\n                variable = True\n            except KeyError:\n                try:\n                    constraint = variable_parameters[str(parameter)]\n                    variable = True\n                except KeyError:\n                    constraint = None\n                    variable = False\n\n            values_with_variability.append((parameter_value, variable))\n            if variable:\n                constraints.append(constraint)\n\n        return values_with_variability, constraints"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tmybasename(usaf):\n    url_file = open(env.SRC_PATH + '/tmy3.csv')\n    for line in url_file.readlines():\n        if line.find(usaf) is not -1:\n            return line.rstrip().partition(',')[0]", "response": "Basename for USAF base."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalize_date(tmy_date, year):\n    month = tmy_date.month\n    day = tmy_date.day - 1\n    hour = tmy_date.hour\n    # hack to get around 24:00 notation\n    if month is 1 and day is 0 and hour is 0:\n        year = year + 1\n    return datetime.datetime(year, month, 1) + \\\n        datetime.timedelta(days=day, hours=hour, minutes=0)", "response": "change TMY3 date to an arbitrary year."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntotal annual insolation, defaults to GHI.", "response": "def total(usaf, field='GHI (W/m^2)'):\n    \"\"\"total annual insolation, defaults to GHI.\"\"\"\n    running_total = 0\n    usafdata = data(usaf)\n    for record in usafdata:\n        running_total += float(record[field])\n    return running_total/1000."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a proxy session which is responsible for acquiring authentication credentials on behalf of a service client.", "response": "def get_proxy_session(self):\n        \"\"\"Gets a ``ProxySession`` which is responsible for acquiring authentication credentials on behalf of a service client.\n\n        return: (osid.proxy.ProxySession) - a proxy session for this\n                service\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_proxy()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_proxy()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_proxy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ProxySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the internal state of the object.", "response": "def initialize(self, runtime=None):\n        \"\"\"Initializes this manager.\n        A manager is initialized once at the time of creation.\n        arg:    runtime (osid.OsidRuntimeManager): the runtime\n                environment\n        raise:  CONFIGURATION_ERROR - an error with implementation\n                configuration\n        raise:  ILLEGAL_STATE - this manager has already been\n                initialized by the OsidRuntime\n        raise:  NullArgument - runtime is null\n        raise:  OperationFailed - unable to complete request\n        compliance: mandatory - This method must be implemented.\n        implementation notes: In addition to loading its runtime\n        configuration an implementation may create shared resources such\n        as connection pools to be shared among all sessions of this\n        service and released when this manager is closed. Providers must\n        thread-protect any data stored in the manager.  To maximize\n        interoperability, providers should not honor a second call to\n        initialize() and must set an ILLEGAL_STATE error.\n\n        \"\"\"\n        if self._runtime is not None:\n            raise IllegalState()\n        self._runtime = runtime\n        config = runtime.get_configuration()\n        parameter_id = Id('parameter:hostName@dlkit_service')\n        host = config.get_value_by_parameter(parameter_id).get_string_value()\n        if host is not None:\n            self._host = host\n        parameter_id = Id('parameter:appKey@dlkit_service')\n        app_key = config.get_value_by_parameter(parameter_id).get_string_value()\n        if app_key is not None:\n            self._app_key = app_key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True iff the grammar is context - free.", "response": "def is_contextfree(self):\n        \"\"\"Returns True iff the grammar is context-free.\"\"\"\n        for lhs, rhs in self.rules:\n            if len(lhs) != 1:\n                return False\n            if lhs[0] not in self.nonterminals:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_useless(self):\n        if not self.is_contextfree():\n            raise ValueError(\"grammar must be context-free\")\n        by_lhs = collections.defaultdict(list)\n        by_rhs = collections.defaultdict(list)\n        for [lhs], rhs in self.rules:\n            by_lhs[lhs].append((lhs, rhs))\n            for y in rhs:\n                if y in self.nonterminals:\n                    by_rhs[y].append((lhs, rhs))\n            \n        agenda = collections.deque([self.start])\n        reachable = set()\n        while len(agenda) > 0:\n            x = agenda.popleft()\n            if x in reachable: continue\n            reachable.add(x)\n            for _, rhs in by_lhs[x]:\n                for y in rhs:\n                    if y in by_lhs:\n                        agenda.append(y)\n\n        agenda = collections.deque()\n        productive = set()\n        for [lhs], rhs in self.rules:\n            if all(y not in self.nonterminals for y in rhs):\n                agenda.append(lhs)\n        while len(agenda) > 0:\n            y = agenda.popleft()\n            if y in productive: continue\n            productive.add(y)\n            for lhs, rhs in by_rhs[y]:\n                if all(y not in self.nonterminals or y in productive for y in rhs):\n                    agenda.append(lhs)\n\n        g = Grammar()\n        g.set_start(self.start)\n\n        for [lhs], rhs in self.rules:\n            if (lhs in reachable & productive and\n                all(y not in self.nonterminals or y in reachable & productive for y in rhs)):\n                g.add_rule([lhs], rhs)\n        return g", "response": "Returns a new grammar containing just useful rules."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\r\n        max_order = self.__max_order\r\n        stoichiometry_matrix = self.model.stoichiometry_matrix\r\n        propensities = self.model.propensities\r\n        species = self.model.species\r\n        # compute n_counter and k_counter; the \"n\" and \"k\" vectors in equations, respectively.\r\n        n_counter, k_counter = generate_n_and_k_counters(max_order, species)\r\n        # dmu_over_dt has row per species and one col per element of n_counter (eq. 6)\r\n        dmu_over_dt = generate_dmu_over_dt(species, propensities, n_counter, stoichiometry_matrix)\r\n        # Calculate expressions to use in central moments equations (eq. 9)\r\n        central_moments_exprs = eq_central_moments(n_counter, k_counter, dmu_over_dt, species, propensities, stoichiometry_matrix, max_order)\r\n        # Expresses central moments in terms of raw moments (and central moments) (eq. 8)\r\n        central_from_raw_exprs = raw_to_central(n_counter, species, k_counter)\r\n        # Substitute raw moment, in central_moments, with expressions depending only on central moments\r\n        central_moments_exprs = self._substitute_raw_with_central(central_moments_exprs, central_from_raw_exprs, n_counter, k_counter)\r\n        # Get final right hand side expressions for each moment in a vector\r\n        mfk = self._generate_mass_fluctuation_kinetics(central_moments_exprs, dmu_over_dt, n_counter)\r\n        # Applies moment expansion closure, that is replaces last order central moments by parametric expressions\r\n        mfk = self.closure.close(mfk, central_from_raw_exprs, n_counter, k_counter)\r\n        # These are the left hand sign symbols referring to the mfk\r\n        prob_lhs = self._generate_problem_left_hand_side(n_counter, k_counter)\r\n        # Finally, we build the problem\r\n        out_problem = ODEProblem(\"MEA\", prob_lhs, mfk, sp.Matrix(self.model.parameters))\r\n        return out_problem", "response": "Returns an instance of an ODE problem which can be further used in inference and simulation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _generate_problem_left_hand_side(self, n_counter, k_counter):\r\n\r\n        # concatenate the symbols for first order raw moments (means)\r\n        prob_moments_over_dt = [k for k in k_counter if k.order == 1]\r\n        # and the higher order central moments (variances, covariances,...)\r\n        prob_moments_over_dt += [n for n in n_counter if self.__max_order >= n.order > 1]\r\n\r\n\r\n        return prob_moments_over_dt", "response": "Generate the left hand side of the ODEs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _generate_mass_fluctuation_kinetics(self, central_moments, dmu_over_dt, n_counter):\r\n\r\n        # symbols for central moments\r\n        central_moments_symbols = sp.Matrix([n.symbol for n in n_counter])\r\n\r\n        # rhs for the first order raw moment\r\n        mfk = [e for e in dmu_over_dt * central_moments_symbols]\r\n        # rhs for the higher order raw moments\r\n        mfk += [(sp.Matrix(cm).T * central_moments_symbols)[0] for cm in central_moments.tolist()]\r\n\r\n        mfk = sp.Matrix(mfk)\r\n\r\n        return mfk", "response": "Generate the MFKs for the Mass Fluctuation Kinetics."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexpress central moments in terms of raw moments (and other central moments). Based on equation 8 in the paper: .. math:: \\mathbf{M_{x^n}} = \\sum_{k_1=0}^{n_1} ... \\sum_{k_d=0}^{n_d} \\mathbf{{n \\choose k}} (-1)^{\\mathbf{n-k}} \\mu^{\\mathbf{n-k}} \\langle \\mathbf{x^k} \\\\rangle The term :math:`\\mu^{\\mathbf{n-k}}`, so called alpha term is expressed with respect to `species` values that are equivalent to :math:`\\mu_i` in the paper. The last term, the beta term, :math:`\\langle \\mathbf{x^n} \\\\rangle` is simply obtained from k_counter as it contains the symbols for raw moments. :param n_counter: a list of :class:`~means.core.descriptors.Moment`\\s representing central moments :type n_counter: list[:class:`~means.core.descriptors.Moment`] :param species: the symbols for species means :param k_counter: a list of :class:`~means.core.descriptors.Moment`\\s representing raw moments :type k_counter: list[:class:`~means.core.descriptors.Moment`] :return: a vector of central moments expressed in terms of raw moment", "response": "def raw_to_central(n_counter, species, k_counter):\n    \"\"\"\n    Expresses central moments in terms of raw moments (and other central moments).\n    Based on equation 8 in the paper:\n\n    .. math::\n         \\mathbf{M_{x^n}} = \\sum_{k_1=0}^{n_1} ... \\sum_{k_d=0}^{n_d} \\mathbf{{n \\choose k}} (-1)^{\\mathbf{n-k}} \\mu^{\\mathbf{n-k}} \\langle \\mathbf{x^k} \\\\rangle\n\n\n    The term :math:`\\mu^{\\mathbf{n-k}}`, so called alpha term is expressed with respect to `species` values that\n    are equivalent to :math:`\\mu_i` in the paper.\n\n    The last term, the beta term, :math:`\\langle \\mathbf{x^n} \\\\rangle` is simply obtained\n    from k_counter as it contains the symbols for raw moments.\n\n    :param n_counter: a list of :class:`~means.core.descriptors.Moment`\\s representing central moments\n    :type n_counter: list[:class:`~means.core.descriptors.Moment`]\n\n    :param species: the symbols for species means\n\n    :param k_counter: a list of :class:`~means.core.descriptors.Moment`\\s representing raw moments\n    :type k_counter: list[:class:`~means.core.descriptors.Moment`]\n\n\n    :return: a vector of central moments expressed in terms of raw moment\n    \"\"\"\n    # create empty output\n    central_in_terms_of_raw = []\n    # This loop loops through the ::math::`[n_1, ..., n_d]` vectors of the sums in the beginning of the equation\n    # i.e. :math:`\\sum_{k1=0}^n_1 ... \\sum_{kd=0}^n_d` part of the equation.\n    # Note, this is not the sum over k's in that equation, or at least I think its not\n    for n_iter in n_counter:  #loop through all n1,...,nd combinations\n        # nothing to do for 0th order central moment\n        if n_iter.order == 0:\n            continue\n        # n_vec is the vector ::math::`[n_1, ... n_d]` in equation 8\n        n_vec = n_iter.n_vector\n        # k_lower contains the elements of `k_counter` that are lower than or equal to the current n_vec\n        # This generates the list of possible k values to satisfy ns in the equation.\n        # `k_vec` iterators bellow are the vector ::math::`[k_1, ..., k_d]`\n        k_lower = [k for k in k_counter if n_iter >= k]\n        # (n k) binomial term in equation 9\n        n_choose_k_vec = [make_k_chose_e(k_vec.n_vector, n_vec) for k_vec in k_lower]\n        # (-1)^(n-k) term in equation 9\n        minus_one_pow_n_min_k_vec = [_make_min_one_pow_n_minus_k(n_vec, k_vec.n_vector)  for k_vec in k_lower ]\n        # alpha term in equation 9\n        alpha_vec = [_make_alpha(n_vec, k_vec.n_vector, species) for k_vec in k_lower]\n        # beta term in equation 9\n        beta_vec = [k_vec.symbol for k_vec in k_lower]\n        # let us multiply all terms\n        product = [(n * m * a * b) for (n, m, a, b) in zip(n_choose_k_vec, minus_one_pow_n_min_k_vec, alpha_vec, beta_vec)]\n        # and store the product\n        central_in_terms_of_raw.append(sum(product))\n    return sp.Matrix(central_in_terms_of_raw)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_string(self, key):\n        if key not in self.all_options:\n            kwargs = {}\n            if len(self.chain) > 1:\n                kwargs['source'] = Meta(self.all_options, self.chain[-2]).source\n            raise BadOptionFormat(\"Can't find key in options\", key=key, chain=self.chain, **kwargs)\n\n        # Make sure we special case the \"content\" option\n        if type(key) is str and key.startswith(\"content.\"):\n            return self.no_format(self.all_options[\"content\"][key[8:]])\n        if type(key) is list and len(key) is 2 and key[0] == \"content\":\n            return self.no_format(self.all_options[key])\n\n        return super(MergedOptionStringFormatter, self).get_string(key)", "response": "Get a string from all_options"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef special_format_field(self, obj, format_spec):\n        if format_spec == \"env\":\n            return \"${{{0}}}\".format(obj)\n        elif format_spec == \"from_env\":\n            if obj not in os.environ:\n                raise NoSuchEnvironmentVariable(wanted=obj)\n            return os.environ[obj]", "response": "Return the value of a special format field."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_arguments(self, args):\n        update_dict = {\n            'arguments': vars(args)\n        }\n        for section in self.config.keys():\n            self.config[section].update(update_dict)", "response": "Add command line arguments to each section in config."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create_threads(self):\n\n        creator = JobCreator(\n            self.config,\n            self.observers.jobs,\n            self.logger\n        )\n        self.jobs = creator.job_factory()", "response": "This method creates jobs instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating concrete jobs. The concrete jobs is following dictionary. jobs = { 'PLUGINNAME-build_items': { 'method': FUNCTION_OBJECT, 'interval': INTERVAL_TIME , } ... } If ConcreteJob instance has \"build_discovery_items\", \"build_discovery_items\" method is added to jobs. warn: looped method is deprecated in 0.4.0. You should implemente \"build_items\" instead of \"looped_method\". In most cases you need only to change the method name.", "response": "def job_factory(self):\n        \"\"\"\n        Create concrete jobs. The concrete jobs is following dictionary.\n        jobs = {\n            'PLUGINNAME-build_items': {\n                'method': FUNCTION_OBJECT,\n                'interval': INTERVAL_TIME ,\n            }\n            ...\n        }\n        If ConcreteJob instance has \"build_discovery_items\",\n        \"build_discovery_items\" method is added to jobs.\n\n        warn: looped method is deprecated in 0.4.0.\n        You should implemente \"build_items\" instead of \"looped_method\".\n        In most cases you need only to change the method name.\n        \"\"\"\n\n        jobs = dict()\n\n        for section, options in self.config.items():\n\n            if section == 'global':\n                continue\n\n            # Since validate in utils/configread, does not occur here Error\n            # In the other sections are global,\n            # that there is a \"module\" option is collateral.\n            plugin_name = options['module']\n            job_kls = self.plugins[plugin_name]\n\n            if hasattr(job_kls, '__init__'):\n                job_argspec = inspect.getargspec(job_kls.__init__)\n\n                if 'stats_queue' in job_argspec.args:\n                    job_obj = job_kls(\n                        options=options,\n                        queue=self.queue,\n                        stats_queue=self.stats_queue,\n                        logger=self.logger\n                    )\n\n                else:\n                    job_obj = job_kls(\n                        options=options,\n                        queue=self.queue,\n                        logger=self.logger\n                    )\n\n            # Deprecated!!\n            if hasattr(job_obj, 'looped_method'):\n                self.logger.warn(\n                    ('{0}\\'s \"looped_method\" is deprecated.'\n                     'Pleases change method name to \"build_items\"'\n                     ''.format(plugin_name))\n                )\n                name = '-'.join([section, 'looped_method'])\n                interval = 60\n                if 'interval' in options:\n                    interval = options['interval']\n                elif 'interval' in self.config['global']:\n                    interval = self.config['global']['interval']\n\n                jobs[name] = {\n                    'method': job_obj.looped_method,\n                    'interval': interval,\n                }\n\n            if hasattr(job_obj, 'build_items'):\n                name = '-'.join([section, 'build_items'])\n                interval = 60\n                if 'interval' in options:\n                    interval = options['interval']\n                elif 'interval' in self.config['global']:\n                    interval = self.config['global']['interval']\n\n                jobs[name] = {\n                    'method': job_obj.build_items,\n                    'interval': interval,\n                }\n\n                self.logger.info(\n                    'load plugin {0} (interval {1})'\n                    ''.format(plugin_name, interval)\n                )\n\n            if hasattr(job_obj, 'build_discovery_items'):\n                name = '-'.join([section, 'build_discovery_items'])\n                lld_interval = 600\n                if 'lld_interval' in options:\n                    lld_interval = options['lld_interval']\n                elif 'lld_interval' in self.config['global']:\n                    lld_interval = self.config['global']['lld_interval']\n\n                jobs[name] = {\n                    'method': job_obj.build_discovery_items,\n                    'interval': lld_interval,\n                }\n\n                self.logger.info(\n                    'load plugin {0} (lld_interval {1})'\n                    ''.format(plugin_name, lld_interval)\n                )\n\n        return jobs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_proxy_session(self):\n        if not self.supports_proxy():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise  # OperationFailed()\n        try:\n            session = sessions.ProxySession()\n        except AttributeError:\n            raise  # OperationFailed()\n        return session", "response": "Returns a proxy session which is responsible for acquiring authentication credentials on behalf of a service client."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_grade_systems_by_search(self, grade_system_query, grade_system_search):\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_grade_systems_by_search(grade_system_query, grade_system_search)", "response": "Pass through to provider GradeSystemSearchSession. get_grade_systems_by_search"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_grade_entries_by_search(self, grade_entry_query, grade_entry_search):\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_grade_entries_by_search(grade_entry_query, grade_entry_search)", "response": "Pass through to provider GradeEntrySearchSession. get_grade_entries_by_search"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider GradebookColumnSearchSession. get_gradebook_columns_by_search", "response": "def get_gradebook_columns_by_search(self, gradebook_column_query, gradebook_column_search):\n        \"\"\"Pass through to provider GradebookColumnSearchSession.get_gradebook_columns_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_gradebook_columns_by_search(gradebook_column_query, gradebook_column_search)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nassigns the query sequence.", "response": "def set_query_sequence(self,seq):\n    \"\"\"Assign the query sequence.\n    \n    :param seq: sequence of the query\n    :type seq: string\n\n    \"\"\"\n    self._options = self._options.replace(query_sequence = seq)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef target_range(self):\n    a = self.alignment_ranges\n    return GenomicRange(a[0][0].chr,a[0][0].start,a[-1][0].end)", "response": "Get the range covered on the target and reference strand of the sequence"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef actual_query_range(self):\n    a = self.alignment_ranges\n    #return GenomicRange(a[0][1].chr,a[0][1].start,a[-1][1].end,self.get_strand())\n    if self.get_strand() == '+':\n      return GenomicRange(a[0][1].chr,a[0][1].start,a[-1][1].end,self.get_strand())\n    #must be - strand\n    return GenomicRange(a[0][1].chr,self.query_sequence_length-a[-1][1].end+1,self.query_sequence_length-a[0][1].start+1,dir=self.strand)", "response": "This is the actual query range for the positive strand\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_reference(self,ref):\n    self._options = self._options._replace(reference = ref)", "response": "Set the reference sequence\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_alignment_strings(self,min_intron_size=68):\n    qseq = self.query_sequence\n    if not qseq:\n      sys.exit(\"ERROR: Query sequence must be accessable to get alignment strings\\n\")\n      sys.exit()\n    ref = self._options.reference\n    qual = self.query_quality\n    if not qual: \n      qual = 'I'*len(qseq) # for a placeholder quality\n    if self.strand == '-': \n      qseq = rc(qseq)\n      qual = qual[::-1]\n    tarr = []\n    qarr = []\n    yarr = []\n    tdone = ''\n    qdone = ''\n    ydone = '' #query quality\n    for i in range(len(self.alignment_ranges)):\n      [t,q] = self.alignment_ranges[i]\n      textra = ''\n      qextra = ''\n      yextra = ''\n      if i >= 1:\n        dift = t.start-self.alignment_ranges[i-1][0].end-1\n        difq = q.start-self.alignment_ranges[i-1][1].end-1\n        if dift < min_intron_size:\n          if dift > 0:\n            textra = str(ref[t.chr][t.start-dift-1:t.start-1]).upper()\n            qextra = '-'*dift\n            yextra = '\\0'*dift\n          elif difq > 0:\n            textra = '-'*difq\n            qextra = qseq[q.start-difq-1:q.start-1].upper()\n            yextra = qual[q.start-difq-1:q.start-1]\n        else:\n          tarr.append(tdone)\n          qarr.append(qdone)\n          yarr.append(ydone)\n          tdone = ''\n          qdone = ''\n          ydone = ''\n      tdone += textra+str(ref[t.chr][t.start-1:t.end]).upper()\n      qdone += qextra+qseq[q.start-1:q.end].upper()\n      ydone += yextra+qual[q.start-1:q.end]\n    if len(tdone) > 0: \n      tarr.append(tdone)\n      qarr.append(qdone)\n      yarr.append(ydone)\n    if self.query_quality == '*': yarr = [x.replace('I',' ') for x in yarr]\n    #query, target, query_quality\n    return [qarr,tarr,yarr]", "response": "Process the alignment to get the alignment strings for each exon."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_alignment(self,chunk_size=40,min_intron_size=68):\n    has_qual = True\n    if not self.query_quality: has_qual = False\n    trantab = maketrans('01',' *')\n    [qstrs,tstrs,ystrs] = self.get_alignment_strings(min_intron_size=min_intron_size)\n    print 'Alignment for Q: '+str(self.alignment_ranges[0][1].chr)\n    for i in range(len(qstrs)):\n      print 'Exon '+str(i+1)\n      #+' T: '+self._alignment_ranges[i][0].get_range_string()+' Q: '+str(self._alignment_ranges[i][1].start)+'-'+str(self._alignment_ranges[i][1].end)\n      mm = ''.join([str(int(qstrs[i][j]!=tstrs[i][j] and qstrs[i][j]!='-' and tstrs[i][j]!='-' and tstrs[i][j]!='N')) for j in range(len(qstrs[i]))]).translate(trantab)\n      t =  tstrs[i] #target\n      q = qstrs[i]  #query\n      s = ystrs[i] #quality\n      for y in [[mm[x:x+chunk_size],t[x:x+chunk_size],q[x:x+chunk_size],s[x:x+chunk_size]] for x in range(0,len(mm),chunk_size)]:\n        print '  '+y[0]\n        print 'T '+y[1]\n        print 'Q '+y[2]\n        if has_qual: print 'Y '+y[3]        \n        print ''", "response": "Print the nice looking alignment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_PSL(self,min_intron_size=68):\n    from seqtools.format.psl import PSL\n    matches = sum([x[0].length for x in self.alignment_ranges]) # 1. Matches - Number of matching bases that aren't repeats\n    stats = AlignmentStats(matches,0,0,0,0,0,0,0)\n    sub = self.query_sequence\n    ref = self._options.reference\n    if ref and sub:\n      stats = self._analyze_alignment(min_intron_size=min_intron_size)\n    strand = self.strand # 9. strand \n    qName = self.alignment_ranges[0][1].chr # 10. qName - Query sequence name\n    qSize = self.query_sequence_length\n    qStart = self.alignment_ranges[0][1].start-1\n    qEnd = self.alignment_ranges[-1][1].end\n    tName = self.alignment_ranges[0][0].chr\n    tSize = self.target_sequence_length\n    tStart = self.alignment_ranges[0][0].start-1\n    tEnd = self.alignment_ranges[-1][0].end\n    blockCount = len(self.alignment_ranges)\n    blockSizes = ','.join([str(x[0].length) for x in self.alignment_ranges])+','\n    qStarts = ','.join([str(x[1].start-1) for x in self.alignment_ranges])+','\n    tStarts = ','.join([str(x[0].start-1) for x in self.alignment_ranges])+','\n\n    psl_string = str(stats.matches)+\"\\t\"+\\\n    str(stats.misMatches)+\"\\t\"+\\\n    str(stats.repMatches)+\"\\t\"+\\\n    str(stats.nCount)+\"\\t\"+\\\n    str(stats.qNumInsert)+\"\\t\"+\\\n    str(stats.qBaseInsert)+\"\\t\"+\\\n    str(stats.tNumInsert)+\"\\t\"+\\\n    str(stats.tBaseInsert)+\"\\t\"+\\\n    strand+\"\\t\"+\\\n    qName+\"\\t\"+\\\n    str(qSize)+\"\\t\"+\\\n    str(qStart)+\"\\t\"+\\\n    str(qEnd)+\"\\t\"+\\\n    tName+\"\\t\"+\\\n    str(tSize)+\"\\t\"+\\\n    str(tStart)+\"\\t\"+\\\n    str(tEnd)+\"\\t\"+\\\n    str(blockCount)+\"\\t\"+\\\n    blockSizes+\"\\t\"+\\\n    qStarts+\"\\t\"+\\\n    tStarts\n    return PSL(psl_string,PSL.Options(query_sequence=self.query_sequence,reference=self._options.reference,query_quality=self.query_quality))", "response": "Return a PSL representation of the alignment."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_SAM(self,min_intron_size=68):\n    from seqtools.format.sam import SAM\n    #ar is target then query\n    qname = self.alignment_ranges[0][1].chr\n    flag = 0\n    if self.strand == '-': flag = 16\n    rname = self.alignment_ranges[0][0].chr\n    pos = self.alignment_ranges[0][0].start\n    mapq = 255\n    cigar = self.construct_cigar(min_intron_size)\n    rnext = '*'\n    pnext = 0\n    tlen = 0 # possible to set if we have a reference\n    if self._options.reference:\n       if rname in self._options.reference: \n          tlen = len(self._options.reference[rname])\n    seq = self.query_sequence\n    if not seq: seq = '*'\n    qual = self.query_quality\n    if not qual: qual = '*'\n    #seq = '*'\n    #qual = '*'\n    if self.strand == '-':\n      seq = rc(seq)\n      qual = qual[::-1]\n    ln = qname + \"\\t\" + str(flag) + \"\\t\" + rname + \"\\t\" + \\\n         str(pos) + \"\\t\" + str(mapq) + \"\\t\" + cigar + \"\\t\" + \\\n         rnext + \"\\t\" + str(pnext) + \"\\t\" + str(tlen) + \"\\t\" + \\\n         seq + \"\\t\" + qual\n    return SAM(ln,reference=self._reference)", "response": "Returns a SAM object representation of the alignment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a CIGAR string from the alignment.", "response": "def construct_cigar(self,min_intron_size=68):\n    \"\"\"Create a CIGAR string from the alignment\n\n    :returns: CIGAR string\n    :rtype: string\n\n    \"\"\"\n\n    # goes target query\n    ar = self.alignment_ranges\n    cig = ''\n    if ar[0][1].start > 1: # soft clipped\n      cig += str(ar[0][1].start-1)+'S'\n    for i in range(len(ar)):\n      exlen = ar[i][0].length\n      cig += str(exlen)+'M'\n      if i < len(ar)-1:\n        # we can look at distances\n        dt = ar[i+1][0].start-ar[i][0].end-1\n        dq = ar[i+1][1].start-ar[i][1].end-1\n        if dq > 0: cig += str(dq)+'I'\n        if dt >= min_intron_size:\n          cig += str(dt)+'N'\n        elif dt > 0: cig += str(dt)+'D'\n        elif dq <= 0:\n          sys.stderr.write(\"ERROR cant form alignment\\n\")\n          sys.exit()\n\n    if ar[-1][1].end < self.query_sequence_length: # soft clipped\n      cig += str(self.query_sequence_length-ar[-1][1].end)+'S'\n    return cig"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_target_transcript(self,min_intron=1):\n    if min_intron < 1: \n      sys.stderr.write(\"ERROR minimum intron should be 1 base or longer\\n\")\n      sys.exit()\n    #tx = Transcript()\n    rngs = [self.alignment_ranges[0][0].copy()]\n    #rngs[0].set_direction(None)\n    for i in range(len(self.alignment_ranges)-1):\n      dist = self.alignment_ranges[i+1][0].start - rngs[-1].end-1\n      #print 'dist '+str(dist)\n      if dist >= min_intron:\n        rngs.append(self.alignment_ranges[i+1][0].copy())\n        #rngs[-1].set_direction(None)\n      else:\n        rngs[-1].end = self.alignment_ranges[i+1][0].end\n    tx = Transcript(rngs,options=Transcript.Options(\n         direction=self.strand,\n         name = self.alignment_ranges[0][1].chr,\n         gene_name = self.alignment_ranges[0][1].chr\n                                                  ))\n    #tx.set_exons_and_junctions_from_ranges(rngs)\n    #tx.set_range()\n    #tx.set_strand(self.get_strand())\n    #tx.set_transcript_name(self.get_alignment_ranges()[0][1].chr)\n    #tx.set_gene_name(self.get_alignment_ranges()[0][1].chr)\n    return tx", "response": "Returns the mapping of to the target transcript"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match_resource_id(self, resource_id, match):\n        if not isinstance(resource_id, Id):\n            raise errors.InvalidArgument()\n        self._add_match('resourceId', str(resource_id), match)", "response": "Sets the resource Id for this query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the objective Id for this query.", "response": "def match_objective_id(self, objective_id, match):\n        \"\"\"Sets the objective ``Id`` for this query.\n\n        arg:    objective_id (osid.id.Id): an objective ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n        raise:  NullArgument - ``objective_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not isinstance(objective_id, Id):\n            raise errors.InvalidArgument()\n        self._add_match('objectiveId', str(objective_id), match)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_completion(self, start, end, match):\n        try:\n            start = float(start)\n        except ValueError:\n            raise errors.InvalidArgument('Invalid start value')\n        try:\n            end = float(end)\n        except ValueError:\n            raise errors.InvalidArgument('Invalid end value')\n        if match:\n            if end < start:\n                raise errors.InvalidArgument('end value must be >= start value when match = True')\n            self._query_terms['completion'] = {\n                '$gte': start,\n                '$lte': end\n            }\n        else:\n            raise errors.InvalidArgument('match = False not currently supported')", "response": "Sets the completion for this query to match completion percentages between the given start and end inclusive."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef match_level_id(self, grade_id, match):\n        if not isinstance(grade_id, Id):\n            raise errors.InvalidArgument()\n        self._add_match('levelId', str(grade_id), match)", "response": "Sets the level grade Id for this query."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy(self):\n    return type(self)(self.chr,\n                      self.start+self._start_offset,\n                      self.end,\n                      self.payload,\n                      self.dir)", "response": "Create a new copy of selfe. Does not do a deep copy for payload\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_bed_array(self):\n    arr = [self.chr,self.start-1,self.end]\n    if self.dir:\n      arr.append(self.dir)\n    return arr", "response": "Return a basic three meber bed array representation of this range"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef equals(self,gr):\n    if self.chr == gr.chr and self.start == gr.start and self.end == gr.end:\n      return True\n    return False", "response": "check for equality. does not consider direction\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_range_string(self):\n    return self.chr+\":\"+str(self.start)+\"-\"+str(self.end)", "response": "get the range string represetation. similar to the default input for UCSC genome"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest for adjacency. :param rng2: :param use_direction: false by default :param type: GenomicRange :param type: use_direction", "response": "def adjacent(self,rng2):\n    \"\"\" Test for adjacency.  \n\n    :param rng2:\n    :param use_direction: false by default\n    :param type: GenomicRange\n    :param type: use_direction\n    \"\"\"\n    if self.chr != rng2.chr: return False\n    if self.direction != rng2.direction and use_direction: return False\n    if self.end == rng2.start-1:  return True\n    if self.start-1 == rng2.end: return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the genomic range overlaps with this one", "response": "def overlaps(self,in_genomic_range,padding=0):\n    \"\"\"do the ranges overlap?\n\n    :param in_genomic_range: range to compare to\n    :param padding: add to the ends this many (default 0)\n    :type in_genomic_range: GenomicRange\n    :type padding: int\n\n    :return: True if they overlap\n    :rtype: bool\n\n    \"\"\"\n    if padding > 0:\n      in_genomic_range = GenomicRange(in_genomic_range.chr,max([1,in_genomic_range.start-padding]),in_genomic_range.end+padding)\n    if self.chr != in_genomic_range.chr:\n      return False\n    if self.end < in_genomic_range.start:\n      return False\n    if in_genomic_range.end < self.start:\n      return False\n    if self.start > in_genomic_range.end:\n      return False\n    if in_genomic_range.start > self.end:\n      return False\n    if self.start <= in_genomic_range.start and self.end >= in_genomic_range.start:\n      return True\n    if self.start <= in_genomic_range.end and self.end >= in_genomic_range.end:\n      return True\n    if self.start >= in_genomic_range.start and self.end <= in_genomic_range.end:\n      return True\n    if self.start <= in_genomic_range.start and self.end >= in_genomic_range.end:\n      return True\n    if in_genomic_range.start <= self.start and in_genomic_range.end >= self.start:\n      return True\n    if in_genomic_range.start <= self.end and in_genomic_range.end >= self.end:\n      return True\n    sys.stderr.write(\"overlaps: unprogrammed error\\n\")\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge(self,range2): \n    if self.chr != range2.chr:\n      return None\n    o = type(self)(self.chr,min(self.start,range2.start)+self._start_offset,max(self.end,range2.end),self.payload,self.dir)\n    return o", "response": "merge this GenomicRange with another GenomicRange"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef intersect(self,range2):\n    if not self.overlaps(range2): return None\n    return type(self)(self.chr,max(self.start,range2.start)+self._start_offset,min(self.end,range2.end),self.payload,self.dir)", "response": "Return the chunk they overlap as a range."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cmp(self,range2,overlap_size=0):\n    if self.overlaps(range2,padding=overlap_size): return 0\n    if self.chr < range2.chr: return -1\n    elif self.chr > range2.chr: return 1\n    elif self.end < range2.start: return -1\n    elif self.start > range2.end: return 1\n    sys.stderr.write(\"ERROR: cmp function unexpcted state\\n\")\n    sys.exit()\n    return 0", "response": "the comparitor for ranges\n    "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef subtract(self,range2):\n    outranges = []\n    if self.chr != range2.chr:\n      outranges.append(self.copy())\n      return outranges\n    if not self.overlaps(range2):\n      outranges.append(self.copy())\n      return outranges\n    if range2.start <= self.start and range2.end >= self.end:\n      return outranges #delete all\n    if range2.start > self.start: #left side\n      nrng = type(self)(self.chr,self.start+self._start_offset,range2.start-1,self.payload,self.dir)\n      outranges.append(nrng)\n    if range2.end < self.end: #right side\n      #ugly addon to make it work for either 0 or 1 index start\n      nrng = type(self)(self.chr,range2.end+1+self._start_offset,self.end,self.payload,self.dir)\n      outranges.append(nrng)\n    return outranges", "response": "Take another range and keep options from self\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the relationship list resulting from a search.", "response": "def get_relationships(self):\n        \"\"\"Gets the relationship list resulting from a search.\n\n        return: (osid.relationship.RelationshipList) - the relationship\n                list\n        raise:  IllegalState - list already retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.RelationshipList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_families(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.FamilyList(self._results, runtime=self._runtime)", "response": "Gets the family list resulting from a search."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef log_analyzer(path):\n    with handle(MalformedLogEntryError,\n                  lambda (c):\n                      invoke_restart('use_value',\n                                     MalformedLogEntry(c.text))):\n        for filename in find_all_logs(path):\n            analyze_log(filename)", "response": "This procedure replaces every line which can t be parsed\n    with special object MalformedLogEntry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_analyzer2(path):\n    with handle(MalformedLogEntryError,\n                  lambda (c):\n                      invoke_restart('reparse',\n                                     'ERROR: ' + c.text)):\n        for filename in find_all_logs(path):\n            analyze_log(filename)", "response": "This procedure considers every line which can t be parsed\n    as a line with ERROR level."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init(db_url, api_url):\n    old_db_url = config[\"local_server\"][\"url\"]\n    if old_db_url and old_db_url != db_url:\n        raise click.ClickException(\n            \"Local database \\\"{}\\\" already initialized. Switching local \"\n            \"databases is not currently supported\".format(old_db_url)\n        )\n\n    db_config = generate_config(api_url)\n    server = Server(db_url)\n\n    # Configure the CouchDB instance itself\n    config_items = []\n    for section, values in db_config.items():\n        for param, value in values.items():\n            config_items.append((section, param, value))\n    with click.progressbar(\n        config_items, label=\"Applying CouchDB configuration\",\n        length=len(config_items)\n    ) as _config_items:\n        for section, param, value in _config_items:\n            url = urljoin(server.resource.url, \"_config\", section, param)\n            try:\n                current_val = server.resource.session.request(\n                    \"GET\", url\n                )[2].read().strip()\n            except ResourceNotFound:\n                current_val = None\n            desired_val = '\"{}\"'.format(value.replace('\"', '\\\\\"'))\n            if current_val != desired_val:\n                status = server.resource.session.request(\n                    \"PUT\", url, body=desired_val\n                )[0]\n                # Unless there is some delay  between requests, CouchDB gets\n                # sad for some reason\n                if status != 200:\n                    click.ClickException(\n                        'Failed to set configuration parameter \"{}\": {}'.format(\n                            param, res.content\n                        )\n                    )\n                time.sleep(1)\n\n    # Create all dbs on the server\n    with click.progressbar(\n        all_dbs, label=\"Creating databases\", length=len(all_dbs)\n    ) as _dbs:\n        for db_name in _dbs:\n            server.get_or_create(db_name)\n\n    # Push design documents\n    click.echo(\"Pushing design documents\")\n    design_path = os.path.dirname(_design.__file__)\n    server.push_design_documents(design_path)\n\n    # Set up replication\n    if config[\"cloud_server\"][\"url\"]:\n        click.echo(\"Setting up replication with cloud server\")\n        utils.replicate_global_dbs(local_url=db_url)\n        if config[\"cloud_server\"][\"farm_name\"]:\n            utils.replicate_per_farm_dbs(local_url=db_url)\n\n    config[\"local_server\"][\"url\"] = db_url", "response": "Initialize the database server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear():\n    utils.check_for_local_server()\n    click.confirm(\n        \"Are you sure you want to do this? It will delete all of your data\",\n        abort=True\n    )\n    server = Server(config[\"local_server\"][\"url\"])\n    for db_name in all_dbs:\n        del server[db_name]", "response": "Clear all data on the local server. Useful for debugging purposed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npopulate the database from a JSON file.", "response": "def load_fixture(fixture_file):\n    \"\"\"\n    Populate the database from a JSON file. Reads the JSON file FIXTURE_FILE\n    and uses it to populate the database. Fuxture files should consist of a\n    dictionary mapping database names to arrays of objects to store in those\n    databases.\n    \"\"\"\n    utils.check_for_local_server()\n    local_url = config[\"local_server\"][\"url\"]\n    server = Server(local_url)\n    fixture = json.load(fixture_file)\n    for db_name, _items in fixture.items():\n        db = server[db_name]\n        with click.progressbar(\n            _items, label=db_name, length=len(_items)\n        ) as items:\n            for item in items:\n                item_id = item[\"_id\"]\n                if item_id in db:\n                    old_item = db[item_id]\n                    item[\"_rev\"] = old_item[\"_rev\"]\n                    if item == old_item:\n                        continue\n                db[item_id] = item"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload all of the firmware_module_type records and update them using the module. json files from the repositories.", "response": "def update_module_types():\n    \"\"\"\n    Download the repositories for all of the firmware_module_type records and\n    update them using the `module.json` files from the repositories themselves.\n    Currently only works for git repositories.\n    \"\"\"\n    local_url = config[\"local_server\"][\"url\"]\n    server = Server(local_url)\n    db = server[FIRMWARE_MODULE_TYPE]\n    temp_folder = mkdtemp()\n    for _id in db:\n        if _id.startswith(\"_\"):\n            continue\n        obj = db[_id]\n        new_obj = update_record(FirmwareModuleType(obj), temp_folder)\n        new_obj[\"_rev\"] = obj[\"_rev\"]\n        if new_obj != obj:\n            db[_id] = new_obj\n    rmtree(temp_folder)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef strip_comments(code):\r\n    '''Returns the headers with comments removed.\r\n    '''\r\n    single_comment = compile('//.*')  # single line comment\r\n    multi_comment = compile('/\\\\*\\\\*.*?\\\\*/', re.DOTALL)  # multiline comment\r\n    code = sub(single_comment, '', code)\r\n    code = sub(multi_comment, '', code)\r\n    return '\\n'.join([c for c in code.splitlines() if c.strip()])", "response": "Returns the headers with comments removed."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a string containing a function prototype and returns a : attr : FunctionSpec instance from the input.", "response": "def parse_prototype(prototype):\r\n    '''Returns a :attr:`FunctionSpec` instance from the input.\r\n    '''\r\n    val = ' '.join(prototype.splitlines())\r\n    f = match(func_pat, val)  # match the whole function\r\n    if f is None:\r\n        raise Exception('Cannot parse function prototype \"{}\"'.format(val))\r\n    ftp, pointer, name, arg = [v.strip() for v in f.groups()]\r\n\r\n    args = []\r\n    if arg.strip():  # split each arg into type, zero or more *, and name\r\n        for item in split(arg_split_pat, arg):\r\n            m = match(variable_pat, item.strip())\r\n            if m is None:\r\n                raise Exception('Cannot parse function prototype \"{}\"'.format(val))\r\n\r\n            tp, star, nm, count = [v.strip() if v else '' for v in m.groups()]\r\n            args.append(VariableSpec(tp, star, nm, count))\r\n\r\n    return FunctionSpec('FLYCAPTURE2_C_API', ftp, pointer, name, args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a StructSpec instance from the input.", "response": "def parse_struct(type_name, body, name):\r\n    '''Returns a :attr:`StructSpec` instance from the input.\r\n    '''\r\n    type_name, name = type_name.strip(), name.strip()\r\n    lines = [l.strip() for l in body.splitlines() if l.strip()]\r\n    members = []\r\n\r\n    for line in lines:\r\n        m = match(variable_pat, line)\r\n        if m is None:\r\n            raise Exception('Cannot parse \"{}\" for \"{}\"'.format(line, name))\r\n\r\n        tp, star, nm, count = [v.strip() if v else '' for v in m.groups()]\r\n        members.append(VariableSpec(tp, star, nm, count))\r\n    return StructSpec(type_name, [n.strip() for n in name.split(',')], members)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a EnumSpec instance from the input.", "response": "def parse_enum(type_name, body, name):\r\n    '''Returns a :attr:`EnumSpec` instance from the input.\r\n    '''\r\n    type_name, name = type_name.strip(), name.strip()\r\n    lines = [l.strip(' ,') for l in body.splitlines() if l.strip(', ')]\r\n    members = []\r\n\r\n    for line in lines:\r\n        vals = [v.strip() for v in line.split('=')]\r\n        if len(vals) == 1:\r\n            members.append(EnumMemberSpec(vals[0], ''))\r\n        else:\r\n            members.append(EnumMemberSpec(*vals))\r\n\r\n    return EnumSpec(type_name, [n.strip() for n in name.split(',')], members)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the header of a single c header file.", "response": "def parse_header(filename):\r\n    '''Returns a list of :attr:`VariableSpec`, :attr:`FunctionSpec`,\r\n    :attr:`StructSpec`, :attr:`EnumSpec`, :attr:`EnumMemberSpec`, and\r\n    :attr:`TypeDef` instances representing the c header file.\r\n    '''\r\n    with open(filename, 'rb') as fh:\r\n        content = '\\n'.join(fh.read().splitlines())\r\n\r\n    content = sub('\\t', ' ', content)\r\n    content = strip_comments(content)\r\n\r\n    # first get the functions\r\n    content = split(func_pat_short, content)\r\n\r\n    for i, s in enumerate(content):\r\n        if i % 2 and content[i].strip():  # matched a prototype\r\n            try:\r\n                content[i] = parse_prototype(content[i])\r\n            except Exception as e:\r\n                traceback.print_exc()\r\n\r\n    # now process structs\r\n    res = []\r\n    for i, item in enumerate(content):\r\n        if not isinstance(item, str):  # if it's already a func etc. skip it\r\n            res.append(item)\r\n            continue\r\n\r\n        items = split(struct_pat, item)\r\n        j = 0\r\n        while j < len(items):\r\n            if not j % 5:\r\n                res.append(items[j])\r\n                j += 1\r\n            else:\r\n                if items[j].strip() == 'enum':\r\n                    res.append(parse_enum(*items[j + 1: j + 4]))\r\n                else:\r\n                    res.append(parse_struct(*items[j + 1: j + 4]))\r\n                j += 4\r\n\r\n    # now do remaining simple typedefs\r\n    content = res\r\n    res = []\r\n    for i, item in enumerate(content):\r\n        if not isinstance(item, str):  # if it's already processed skip it\r\n            res.append(item)\r\n            continue\r\n\r\n        items = split(typedef_pat, item)\r\n        for j, item in enumerate(items):\r\n            res.append(TypeDef(item.strip()) if j % 2 else item)\r\n\r\n    content = [c for c in res if not isinstance(c, str) or c.strip()]\r\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a cython enum from a EnumSpec instance.", "response": "def format_enum(enum_def):\r\n    '''Returns a cython enum from a :attr:`EnumSpec` instance.\r\n    '''\r\n    text = []\r\n    text.append('cdef enum {}:'.format(enum_def.tp_name))\r\n    for member in enum_def.values:\r\n        if member.value:\r\n            text.append('{}{} = {}'.format(tab, *member))\r\n        else:\r\n            text.append('{}{}'.format(tab, member.name))\r\n\r\n    for name in enum_def.names:\r\n        text.append('ctypedef {} {}'.format(enum_def.tp_name, name))\r\n\r\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a cython function from a : attr : FunctionSpec instance.", "response": "def format_function(function):\r\n    '''Returns a cython function from a :attr:`FunctionSpec` instance.\r\n    '''\r\n    args = [format_variable(arg) for arg in function.args]\r\n    return ['{}{} {}({})'.format(\r\n        function.type, function.pointer, function.name, ', '.join(args))]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_struct(struct_def):\r\n    '''Returns a cython struct from a :attr:`StructSpec` instance.\r\n    '''\r\n    text = []\r\n    text.append('cdef struct {}:'.format(struct_def.tp_name))\r\n    text.extend(\r\n        ['{}{}'.format(tab, format_variable(var))\r\n         for var in struct_def.members]\r\n    )\r\n\r\n    for name in struct_def.names:\r\n        text.append('ctypedef {} {}'.format(struct_def.tp_name, name))\r\n\r\n    return text", "response": "Returns a cython struct from a StructSpec instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a cython pxi file from the output of parse_header.", "response": "def dump_cython(content, name, ofile):\r\n    '''Generates a cython pxi file from the output of :func:`parse_header`.\r\n    '''\r\n    with open(ofile, 'wb') as fh:\r\n        fh.write('cdef extern from \"{}\":\\n'.format(name))\r\n        for item in content:\r\n            if isinstance(item, FunctionSpec):\r\n                code = format_function(item)\r\n            elif isinstance(item, StructSpec):\r\n                code = format_struct(item)\r\n            elif isinstance(item, EnumSpec):\r\n                code = format_enum(item)\r\n            elif isinstance(item, TypeDef):\r\n                code = format_typedef(item)\r\n            else:\r\n                fh.write('>>>>>>>>\\n{}\\n<<<<<<<<'.format(item))\r\n                code = []\r\n\r\n            fh.write('{}\\n\\n'.format('\\n'.join(['{}{}'.format(tab, c)\r\n                                                for c in code])))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking a geometry string returns a map of parameters.", "response": "def parse_geometry(geometry):\n    \"\"\"Takes a geometry string, returns map of parameters.\"\"\"\n\n    m = re.match(\"(\\d+)x(\\d+)([-+]\\d+)([-+]\\d+)\", geometry)\n    if not m:\n        raise ValueError(\"failed to parse geometry string\")\n    return map(int, m.groups())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef buttons(self, master):\n\n        subframe = tk.Frame(master)\n        subframe.pack(side=tk.RIGHT)\n\n        ttk.Button(\n            subframe,\n            text=\"OK\",\n            width=10,\n            command=self.ok,\n            default=tk.ACTIVE\n        ).pack(side=tk.LEFT, padx=5, pady=5)\n\n        ttk.Button(\n            subframe,\n            text=\"Cancel\",\n            width=10,\n            command=self.cancel,\n            default=tk.ACTIVE\n        ).pack(side=tk.LEFT, padx=5, pady=5)\n\n        self.bind(\"<Return>\", self.ok)\n        self.bind(\"<Escape>\", self.cancel)", "response": "Adds OK and Cancel buttons to standard button frame."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions called when OK - button is clicked.", "response": "def ok(self, event=None):\n        \"\"\"Function called when OK-button is clicked.\n\n        This method calls check_input(), and if that returns ok it calls\n        execute(), and then destroys the dialog.\n        \"\"\"\n\n        if not self.check_input():\n            self.initial_focus.focus_set()\n            return\n\n        self.withdraw()\n        self.update_idletasks()\n\n        try:\n            self.execute()\n        finally:\n            self.cancel()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction called when Cancel - button clicked. This method returns focus to parent and destroys the dialog.", "response": "def cancel(self, event=None):\n        \"\"\"Function called when Cancel-button clicked.\n\n        This method returns focus to parent, and destroys the dialog.\n        \"\"\"\n\n        if self.parent != None:\n            self.parent.focus_set()\n\n        self.destroy()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset a payload for this object", "response": "def set_payload(self,val):\n    \"\"\"Set a payload for this object\n\n    :param val: payload to be stored\n    :type val: Anything that can be put in a list\n    \"\"\"\n    self._options = self._options._replace(payload = val)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef avg_mutual_coverage(self,gpd):\n    ov = self.overlap_size(gpd)\n    if ov == 0: return 0\n    xfrac = float(ov) / float(self.get_length())\n    yfrac = float(ov) / float(gpd.get_length())\n    return sqrt(xfrac*yfrac)", "response": "get the coverage fraction of each transcript then return the geometric mean"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the number of overlapping base pairs between two transcripts", "response": "def overlap_size(self,tx2):\n    \"\"\"Return the number of overlapping base pairs between two transcripts\n\n    :param tx2: Another transcript\n    :type tx2: Transcript\n    :return: overlap size in base pairs\n    :rtype: int\n    \"\"\"\n    total = 0\n    for e1 in self.exons:\n      for e2 in tx2.exons:\n        total += e1.overlap_size(e2)\n    return total"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef overlaps(self,tx2):\n    total = 0\n    for e1 in self.exons:\n      for e2 in tx2.exons:\n        if e1.overlap_size(e2) > 0: return True\n    return False", "response": "Return True if the two TCs are overlapping."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nslices the mapping by the target coordinate", "response": "def slice_target(self,chr,start,end):\n     \"\"\"Slice the mapping by the target coordinate\n        \n        First coordinate is 0-indexed start\n        Second coordinate is 1-indexed finish\n\n     \"\"\"\n     # create a range that we are going to intersect with\n     trng = Bed(chr,start,end)\n     nrngs = []\n     for r in self._rngs:\n        i = r.intersect(trng)\n        if not i: continue\n        nrngs.append(i)\n     if len(nrngs) == 0: return None\n     return MappingGeneric(nrngs,self._options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef slice_sequence(self,start,end):\n     #find the sequence length\n     l = self.length\n     indexstart = start\n     indexend = end\n     ns = []\n     tot = 0\n     for r in self._rngs:\n        tot += r.length\n        n = r.copy()\n        if indexstart > r.length:  \n           indexstart-=r.length\n           continue\n        n.start = n.start+indexstart\n        if tot > end: \n           diff = tot-end\n           n.end -= diff\n           tot = end\n        indexstart = 0\n        ns.append(n)\n        if tot == end: break\n     if len(ns)==0: return None\n     return MappingGeneric(ns,self._options)", "response": "Slice the mapping by the position in the sequence\n        \n    "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the sequence of the sequence in the reference sequence", "response": "def sequence(self):\n    \"\"\"A strcutre is defined so get,\n    if the sequence is not already there, get the sequence from the reference\n\n    Always is returned on the positive strand for the MappingGeneric\n\n    :param ref_dict: reference dictionary (only necessary if sequence has not been set already)\n    :type ref_dict: dict()\n    \"\"\"\n    if not self._options.ref:\n      raise ValueError(\"ERROR: sequence is not defined and reference is undefined\")\n    #chr = self.range.chr\n    return self.get_sequence(self._options.ref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_sequence(self,ref):\n    strand = '+'\n    if not self._options.direction:\n      sys.stderr.write(\"WARNING: no strand information for the transcript\\n\")\n    if self._options.direction: strand = self._options.direction\n    seq = ''\n    for e in [x.range for x in self.exons]:\n      seq += str(ref[e.chr][e.start-1:e.end])\n    if strand == '-':  seq = rc(seq)\n    return Sequence(seq.upper())", "response": "get a sequence given a reference"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_junctions_string(self):\n    self._initialize()\n    return ';'.join([x.get_range_string() for x in self.junctions])", "response": "Returns a string representation of the junctions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef junction_overlap(self,tx,tolerance=0):\n    self._initialize()\n    return JunctionOverlap(self,tx,tolerance)", "response": "Calculate the junction overlap between two transcripts\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef smooth_gaps(self,min_intron):\n    rngs = [self._rngs[0].copy()]\n    for i in range(len(self._rngs)-1):\n      dist = -1\n      if self._rngs[i+1].chr == rngs[-1].chr:\n        dist = self._rngs[i+1].start - rngs[-1].end-1\n      if dist >= min_intron or dist < 0:\n        rngs.append(self._rngs[i+1].copy())\n      else:\n        rngs[-1].end = self._rngs[i+1].end\n    return type(self)(rngs,self._options)", "response": "smooth_gaps returns a new mapping with small gaps"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_type_data(name):\n    name = name.upper()\n    if name in CELESTIAL_TIME_TYPES:\n        namespace = 'time'\n        domain = 'Celestial Time Systems'\n        time_name = CELESTIAL_TIME_TYPES[name]\n    elif name in EARTH_TIME_TYPES:\n        namespace = 'time'\n        domain = 'Earth Time Systems'\n        time_name = EARTH_TIME_TYPES[name]\n    elif name in SUPER_FUN_TIME_TYPES:\n        namespace = 'time'\n        domain = 'Alternative Time Systems'\n        time_name = SUPER_FUN_TIME_TYPES[name]\n    else:\n        raise NotFound('Time Type: ' + name)\n\n    return {\n        'authority': 'okapia.net',\n        'namespace': namespace,\n        'identifier': name,\n        'domain': domain,\n        'display_name': time_name + ' Time Type',\n        'display_label': time_name,\n        'description': ('The time type for ' + time_name + ' time.')\n    }", "response": "Return dictionary representation of type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef supports_coordinate_type(self, coordinate_type=None):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not coordinate_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``COORDINATE``']:\n            raise IllegalState('put more meaninful message here')\n        return coordinate_type in self.get_coordinate_types", "response": "Tests if the given coordinate type is supported."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef supports_currency_type(self, currency_type=None):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not currency_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``CURRENCY``']:\n            raise IllegalState('put more meaninful message here')\n        return currency_type in self.get_currency_types", "response": "Tests if the given currency type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if the given calendar type is supported.", "response": "def supports_calendar_type(self, calendar_type=None):\n        \"\"\"Tests if the given calendar type is supported.\n\n        arg:    calendar_type (osid.type.Type): a calendar Type\n        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise\n        raise:  IllegalState - syntax is not a ``DATETIME`` or\n                ``DURATION``\n        raise:  NullArgument - ``calendar_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not calendar_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``DATETIME``', '``DURATION``']:\n            raise IllegalState('put more meaninful message here')\n        return calendar_type in self.get_calendar_types"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef supports_time_type(self, time_type=None):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not time_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``DATETIME,', 'DURATION,``', '``TIME``']:\n            raise IllegalState('put more meaninful message here')\n        return time_type in self.get_time_types", "response": "Tests if the given time type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef supports_heading_type(self, heading_type=None):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not heading_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``HEADING``']:\n            raise IllegalState('put more meaninful message here')\n        return heading_type in self.get_heading_types", "response": "Tests if the given heading type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if the given object type is supported.", "response": "def supports_object_type(self, object_type=None):\n        \"\"\"Tests if the given object type is supported.\n\n        arg:    object_type (osid.type.Type): an object Type\n        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise\n        raise:  IllegalState - syntax is not an ``OBJECT``\n        raise:  NullArgument - ``object_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not object_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``OBJECT``']:\n            raise IllegalState('put more meaninful message here')\n        return object_type in self.get_object_types"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if the given spatial unit record type is supported.", "response": "def supports_spatial_unit_record_type(self, spatial_unit_record_type=None):\n        \"\"\"Tests if the given spatial unit record type is supported.\n\n        arg:    spatial_unit_record_type (osid.type.Type): a spatial\n                unit record Type\n        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise\n        raise:  IllegalState - syntax is not an ``SPATIALUNIT``\n        raise:  NullArgument - ``spatial_unit_record_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not spatial_unit_record_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``SPATIALUNIT``']:\n            raise IllegalState('put more meaninful message here')\n        return spatial_unit_record_type in self.get_spatial_unit_record_types"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef supports_string_match_type(self, string_match_type=None):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not string_match_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``STRING``']:\n            raise IllegalState('put more meaninful message here')\n        return string_match_type in self.get_string_match_types", "response": "Tests if the given string match type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef supports_version_type(self, version_type=None):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        from .osid_errors import IllegalState, NullArgument\n        if not version_type:\n            raise NullArgument('no input Type provided')\n        if self._kwargs['syntax'] not in ['``VERSION``']:\n            raise IllegalState('put more meaninful message here')\n        return version_type in self.get_version_types", "response": "Tests if the given version type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef aggregate_registry_timers():\n    import itertools\n\n    timers = sorted(shared_registry.values(), key=lambda t: t.desc)\n    aggregate_timers = []\n    for k, g in itertools.groupby(timers, key=lambda t: t.desc):\n        group = list(g)\n        num_calls = len(group)\n        total_elapsed_ms = sum(t.elapsed_time_ms for t in group)\n        first_start_time = min(t.start_time for t in group)\n        # We'll use the first start time as a sort key.\n        aggregate_timers.append(\n            (first_start_time, (k, total_elapsed_ms, num_calls)))\n\n    aggregate_timers.sort()\n    return zip(*aggregate_timers)[1]", "response": "Returns a list of aggregate timing information for registered timers."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the model from a SBML file.", "response": "def read_sbml(filename):\n    \"\"\"\n    Read the model from a SBML file.\n\n    :param filename: SBML filename to read the model from\n    :return: A tuple, consisting of :class:`~means.core.model.Model` instance,\n             set of parameter values, and set of initial conditions variables.\n    \"\"\"\n    import libsbml\n\n    if not os.path.exists(filename):\n        raise IOError('File {0!r} does not exist'.format(filename))\n\n    reader = libsbml.SBMLReader()\n    document = reader.readSBML(filename)\n\n    sbml_model = document.getModel()\n    if not sbml_model:\n        raise ValueError('Cannot parse SBML model from {0!r}'.format(filename))\n\n    species = sympy.symbols([s.getId() for s in sbml_model.getListOfSpecies()])\n    initial_conditions = [s.getInitialConcentration() for s in sbml_model.getListOfSpecies()]\n    compartments = sympy.symbols([s.getId() for s in sbml_model.getListOfCompartments()])\n    compartment_sizes = [s.getSize() for s in sbml_model.getListOfCompartments()]\n\n    reactions = map(_parse_reaction, sbml_model.getListOfReactions())\n\n    # getListOfParameters is an attribute of the model for SBML Level 1&2\n    parameters_with_values = [(sympy.Symbol(p.getId()), p.getValue())\n                              for p in sbml_model.getListOfParameters()]\n    parameter_values = dict(parameters_with_values)\n    parameters = map(lambda x: x[0], parameters_with_values)\n    if not parameters:\n        track_local_parameters = True\n        parameters = set()\n        parameter_values = {}\n    else:\n        track_local_parameters = False\n\n\n    stoichiometry_matrix = np.zeros((len(species), len(reactions)), dtype=int)\n    propensities = []\n    for reaction_index, reaction in enumerate(reactions):\n        if track_local_parameters:\n            for param, value in reaction.parameters:\n                parameters.add(param)\n                parameter_values[param] = value\n        reactants = reaction.reactants\n        products = reaction.products\n        propensities.append(reaction.propensity)\n        for species_index, species_id in enumerate(species):\n            net_stoichiometry = products.get(species_id, 0) - reactants.get(species_id, 0)\n            stoichiometry_matrix[species_index, reaction_index] = net_stoichiometry\n\n\n    if track_local_parameters:\n        # sympy does not allow sorting its parameter lists by default,\n        # explicitly tell to sort by str representation\n        sorted_parameters = sorted(parameters, key=str)\n    else:\n        sorted_parameters = parameters\n\n    parameter_values_list = [parameter_values[p] for p in sorted_parameters]\n\n    # We need to concatenate compartment names and parameters as in our framework we cannot differentiate the two\n    compartments_and_parameters = compartments + sorted_parameters\n    parameter_values_list = compartment_sizes + parameter_values_list\n\n    model = Model(species, compartments_and_parameters, propensities, stoichiometry_matrix)\n\n    return model, parameter_values_list, initial_conditions"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count(procfile):\n\n        state_tcp = {\n            '01': 'ESTABLISHED',\n            '02': 'SYN_SENT',\n            '03': 'SYN_RECV',\n            '04': 'FIN_WAIT1',\n            '05': 'FIN_WAIT2',\n            '06': 'TIME_WAIT',\n            '07': 'CLOSE',\n            '08': 'CLOSE_WAIT',\n            '09': 'LAST_ACK',\n            '0A': 'LISTEN',\n            '0B': 'CLOSING',\n        }\n\n        protocol = os.path.basename(procfile.name)\n\n        state = []\n        stats = {}\n\n        # read procfile. e.g: /proc/net/tcp -> ['0A', '0A', '06', '01', '0A']\n        for line in procfile.readlines():\n            state.append(line.split()[3])\n\n        for state_type, state_name in state_tcp.items():\n            key = 'linux.net.{proto}[{state}]'.format(proto=protocol,\n                                                      state=state_name\n                                                      )\n            value = state.count(state_type)\n            stats[key] = value\n\n        procfile.close()\n        return stats", "response": "Take arguments as intermediate data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the map of items to be used by the form.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        ItemTextsFormRecord._init_map(self)\n        ItemFilesFormRecord._init_map(self)\n        super(ItemTextsAndFilesMixin, self)._init_map()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the metadata for the item text and file records.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        ItemTextsFormRecord._init_metadata(self)\n        ItemFilesFormRecord._init_metadata(self)\n        super(ItemTextsAndFilesMixin, self)._init_metadata()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_map(self):\n        QuestionTextFormRecord._init_map(self)\n        QuestionFilesFormRecord._init_map(self)\n        super(QuestionTextAndFilesMixin, self)._init_map()", "response": "Initialize the map of fields that are used by the QuestionTextAndFilesFormRecord."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the metadata for this record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        QuestionTextFormRecord._init_metadata(self)\n        QuestionFilesFormRecord._init_metadata(self)\n        super(QuestionTextAndFilesMixin, self)._init_metadata()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the map of the fields that are used by the QuestionTextsAndFilesMixin.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        QuestionTextsFormRecord._init_map(self)\n        QuestionFilesFormRecord._init_map(self)\n        super(QuestionTextsAndFilesMixin, self)._init_map()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_metadata(self):\n        QuestionTextsFormRecord._init_metadata(self)\n        QuestionFilesFormRecord._init_metadata(self)\n        super(QuestionTextsAndFilesMixin, self)._init_metadata()", "response": "Initialize the metadata for this record."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the map of the record.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(TextAnswerFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['minStringLength'] = \\\n            self._min_string_length_metadata['default_cardinal_values'][0]\n        self.my_osid_object_form._my_map['maxStringLength'] = \\\n            self._max_string_length_metadata['default_cardinal_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the metadata for the record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(TextAnswerFormRecord, self)._init_metadata()\n        self._min_string_length_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'min-string-length'),\n            'element_label': 'min string length',\n            'instructions': 'enter minimum string length',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_cardinal_values': [self._min_string_length],\n            'syntax': 'CARDINAL',\n            'minimum_cardinal': None,\n            'maximum_cardinal': None,\n            'cardinal_set': []\n        }\n        self._max_string_length_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'max-string-length'),\n            'element_label': 'max string length',\n            'instructions': 'enter maximum string length',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_cardinal_values': [self._max_string_length],\n            'syntax': 'CARDINAL',\n            'minimum_cardinal': None,\n            'maximum_cardinal': None,\n            'cardinal_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear min string length", "response": "def clear_min_string_length(self):\n        \"\"\"stub\"\"\"\n        if (self.get_min_string_length_metadata().is_read_only() or\n                self.get_min_string_length_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['minStringLength'] = \\\n            self.get_min_string_length_metadata().get_default_cardinal_values()[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear_max_string_length(self):\n        if (self.get_max_string_length_metadata().is_read_only() or\n                self.get_max_string_length_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['maxStringLength'] = \\\n            self.get_max_string_length_metadata().get_default_cardinal_values()[0]", "response": "clear max string length"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_map(self):\n        super(TextsAnswerFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['minStringLength'] = \\\n            self._min_string_length_metadata['default_cardinal_values'][0]\n        self.my_osid_object_form._my_map['maxStringLength'] = \\\n            self._max_string_length_metadata['default_cardinal_values'][0]", "response": "Initialize the map of the record."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the minimum string length for this object", "response": "def set_min_string_length(self, length=None):\n        \"\"\"stub\"\"\"\n        if self.get_min_string_length_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_cardinal(\n                length,\n                self.get_min_string_length_metadata()):\n            raise InvalidArgument()\n        if self.my_osid_object_form.max_string_length is not None and \\\n                length > self.my_osid_object_form.max_string_length - 1:\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['minStringLength'] = length\n        self._min_string_length = length"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the max length of the string", "response": "def set_max_string_length(self, length=None):\n        \"\"\"stub\"\"\"\n        if self.get_max_string_length_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_cardinal(\n                length,\n                self.get_max_string_length_metadata()):\n            raise InvalidArgument()\n        if self.my_osid_object_form.min_string_length is not None and \\\n                length < self.my_osid_object_form.min_string_length + 1:\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['maxStringLength'] = length\n        self._max_string_length = length"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _init_map(self):\n        TextAnswerFormRecord._init_map(self)\n        FilesAnswerFormRecord._init_map(self)\n        super(AnswerTextAndFilesMixin, self)._init_map()", "response": "Initialize the map of items to be used by the answer text and files."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the metadata for the AnswerTextAndFilesRecord.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        TextAnswerFormRecord._init_metadata(self)\n        FilesAnswerFormRecord._init_metadata(self)\n        super(AnswerTextAndFilesMixin, self)._init_metadata()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_response_correct(self, response):\n        for answer in self.my_osid_object.get_answers():\n            if self._is_match(response, answer):\n                return True\n        return False", "response": "returns True if response evaluates to an Item Answer that is 100 percent correct"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_exercises(self, *exercises):\n        for exercise in list(exercises):\n            if isinstance(exercise, DynamicExercise):\n                self.dynamic_exercises.append(exercise)\n\n            if isinstance(exercise, StaticExercise):\n                self.static_exercises.append(exercise)", "response": "Add the exercises to the day."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parseSOAP(xml_str, rules = None):\n    try:\n        from cStringIO import StringIO\n    except ImportError:\n        from StringIO import StringIO\n\n    parser = xml.sax.make_parser()\n    t = ZimbraSOAPParser(rules = rules)\n    parser.setContentHandler(t)\n    e = xml.sax.handler.ErrorHandler()\n    parser.setErrorHandler(e)\n\n    inpsrc = xml.sax.xmlreader.InputSource()\n    inpsrc.setByteStream(StringIO(xml_str))\n\n    # turn on namespace mangeling\n    parser.setFeature(xml.sax.handler.feature_namespaces,1)\n\n    try:\n        parser.parse(inpsrc)\n    except xml.sax.SAXParseException, e:\n        parser._parser = None\n        raise e\n\n    return t", "response": "Replacement for SOAPpy. _parseSOAP method to spoof SOAPParser.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild url opener initializing proxy.", "response": "def build_opener(self):\n        \"\"\"\n        Builds url opener, initializing proxy.\n        @return: OpenerDirector\n        \"\"\"\n        http_handler = urllib2.HTTPHandler() # debuglevel=self.transport.debug\n\n        if util.empty(self.transport.proxy_url):\n            return urllib2.build_opener(http_handler)\n\n        proxy_handler = urllib2.ProxyHandler(\n            {self.transport.proxy_url[:4]: self.transport.proxy_url})\n\n        return urllib2.build_opener(http_handler, proxy_handler)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing exception based on soap error response.", "response": "def init_soap_exception(self, exc):\n        \"\"\"\n        Initializes exception based on soap error response.\n        @param exc: URLError\n        @return: SoapException\n        \"\"\"\n        if not isinstance(exc, urllib2.HTTPError):\n            return SoapException(unicode(exc), exc)\n\n        if isinstance(exc, urllib2.HTTPError):\n            try:\n                data = exc.read()\n                self.log.debug(data)\n\n                t = SOAPpy.Parser.parseSOAP(data)\n                message = '%s:%s' % (t.Fault.faultcode, t.Fault.faultstring)\n                e = SoapException(message, exc)\n                e.code = t.Fault.detail.Error.Code\n                e.trace = t.Fault.detail.Error.Trace\n                return e\n            except:\n                return SoapException(unicode(exc), exc)\n\n        return SoapException(exc.reason, exc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes metadata for the first angle projection", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._first_angle_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'first_angle'),\n            'element_label': 'First Angle',\n            'instructions': 'set boolean, is this a first angle projection',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [False],\n            'syntax': 'BOOLEAN',\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the first angle projection", "response": "def set_first_angle_projection(self, value=None):\n        \"\"\"stub\"\"\"\n        if value is None:\n            raise NullArgument()\n        if self.get_first_angle_projection_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_boolean(value):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['firstAngle'] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears first angle projection", "response": "def clear_first_angle_projection(self):\n        \"\"\"stub\"\"\"\n        if (self.get_first_angle_projection_metadata().is_read_only() or\n                self.get_first_angle_projection_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['firstAngle'] = \\\n            self._first_angle_metadata['default_boolean_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_metadata(self):\n        super(BaseOrthoQuestionFormRecord, self)._init_metadata()\n        self._ortho_view_set_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'ortho_view_set'),\n            'element_label': 'Orthographic View Set',\n            'instructions': '',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [''],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }", "response": "Initialize the metadata for the Orthographic View Set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_ortho_view_set(self, front_view, side_view, top_view):\n        if (not isinstance(front_view, DataInputStream) or\n                not isinstance(top_view, DataInputStream) or\n                not isinstance(side_view, DataInputStream)):\n            raise InvalidArgument('views must be osid.transport.DataInputStream objects')\n        self.add_file(front_view,\n                      label='frontView',\n                      asset_type=OV_ASSET_TYPE,\n                      asset_content_type=OV_ASSET_CONTENT_TYPE)\n        self.add_file(side_view,\n                      label='sideView',\n                      asset_type=OV_ASSET_TYPE,\n                      asset_content_type=OV_ASSET_CONTENT_TYPE)\n        self.add_file(top_view,\n                      label='topView',\n                      asset_type=OV_ASSET_TYPE,\n                      asset_content_type=OV_ASSET_CONTENT_TYPE)", "response": "set the ortho view set"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear_ortho_view_set(self):\n        if (self.get_ortho_view_set_metadata().is_read_only() or\n                self.get_ortho_view_set_metadata().is_required()):\n            raise NoAccess()\n        self.clear_file('frontView')\n        self.clear_file('sideView')\n        self.clear_file('topView')", "response": "clear the ortho view set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_ovs_view(self, asset_data, view_name):\n        if not isinstance(asset_data, DataInputStream):\n            raise InvalidArgument('view file must be an ' +\n                                  'osid.transport.DataInputStream object')\n        if view_name not in ['frontView', 'sideView', 'topView']:\n            raise InvalidArgument('View name must be frontView, sideView, or topView.')\n        self.clear_file(view_name)\n        self.add_file(asset_data,\n                      label=view_name,\n                      asset_type=OV_ASSET_TYPE,\n                      asset_content_type=OV_ASSET_CONTENT_TYPE)", "response": "Set the OVS view of the asset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_metadata(self):\n        super(LabelOrthoFacesAnswerFormRecord, self)._init_metadata()\n        self._face_values_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'face_values'),\n            'element_label': 'Orthographic Face Values',\n            'instructions': '',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }", "response": "Initialize metadata for the Orthographic Face Values field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_face_values(self, front_face_value, side_face_value, top_face_value):\n        if front_face_value is None or side_face_value is None or top_face_value is None:\n            raise NullArgument()\n        self.add_integer_value(value=int(front_face_value), label='frontFaceValue')\n        self.add_integer_value(value=int(side_face_value), label='sideFaceValue')\n        self.add_integer_value(value=int(top_face_value), label='topFaceValue')", "response": "set the front side and top face values for the class"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears the face values for the current locale.", "response": "def clear_face_values(self):\n        \"\"\"stub\"\"\"\n        if (self.get_face_values_metadata().is_read_only() or\n                self.get_face_values_metadata().is_required()):\n            raise NoAccess()\n        self.clear_integer_value('frontFaceValue')\n        self.clear_integer_value('sideFaceValue')\n        self.clear_integer_value('topFaceValue')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_metadata(self):\n        super(EulerRotationAnswerFormRecord, self)._init_metadata()\n        self._euler_rotation_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'angle_values'),\n            'element_label': 'Euler Angle Values',\n            'instructions': 'Provide X, Y, and Z euler angle rotation values',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }", "response": "Initialize metadata for euler angle rotation answer form record."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset x y and z angles for euler angle", "response": "def set_euler_angle_values(self, x_angle, y_angle, z_angle):\n        \"\"\"stub\"\"\"\n        if x_angle is None or y_angle is None or z_angle is None:\n            raise NullArgument()\n        self.add_integer_value(value=x_angle, label='xAngle')\n        self.add_integer_value(value=y_angle, label='yAngle')\n        self.add_integer_value(value=z_angle, label='zAngle')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear angle values from metadata", "response": "def clear_angle_values(self):\n        \"\"\"stub\"\"\"\n        if (self.get_euler_rotation_values_metadata().is_read_only() or\n                self.get_euler_rotation_values_metadata().is_required()):\n            raise NoAccess()\n        self.clear_integer_value('xAngle')\n        self.clear_integer_value('yAngle')\n        self.clear_integer_value('zAngle')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_type_data(name):\n    try:\n        return {\n            'authority': 'birdland.mit.edu',\n            'namespace': 'Genus Types',\n            'identifier': name,\n            'domain': 'Generic Types',\n            'display_name': OBJECTIVE_TYPES[name] + ' Genus Type',\n            'display_label': OBJECTIVE_TYPES[name],\n            'description': ('The ' + OBJECTIVE_TYPES[name] +\n                            ' Genus Type.')\n        }\n    except IndexError:\n        raise NotFound('Objective Genus Type: ' + name)", "response": "Return dictionary representation of type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the underlying gradebook view to match current view", "response": "def _set_gradebook_view(self, session):\n        \"\"\"Sets the underlying gradebook view to match current view\"\"\"\n        if self._gradebook_view == COMPARATIVE:\n            try:\n                session.use_comparative_gradebook_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_gradebook_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_provider_session(self, session_name, proxy=None):\n        agent_key = self._get_agent_key(proxy)\n        if session_name in self._provider_sessions[agent_key]:\n            return self._provider_sessions[agent_key][session_name]\n        else:\n            session = self._instantiate_session('get_' + session_name, self._proxy)\n            self._set_gradebook_view(session)\n            if self._session_management != DISABLED:\n                self._provider_sessions[agent_key][session_name] = session\n            return session", "response": "Gets the session for the provider"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npassing through to provider GradeSystemGradebookSession. use_comparative_gradebook_view", "response": "def use_comparative_gradebook_view(self):\n        \"\"\"Pass through to provider GradeSystemGradebookSession.use_comparative_gradebook_view\"\"\"\n        self._gradebook_view = COMPARATIVE\n        # self._get_provider_session('grade_system_gradebook_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_gradebook_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider GradeSystemGradebookSession. use_plenary_gradebook_view", "response": "def use_plenary_gradebook_view(self):\n        \"\"\"Pass through to provider GradeSystemGradebookSession.use_plenary_gradebook_view\"\"\"\n        self._gradebook_view = PLENARY\n        # self._get_provider_session('grade_system_gradebook_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_gradebook_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npassing through to provider GradebookLookupSession. get_gradebooks_by_parent_genus_type", "response": "def get_gradebooks_by_parent_genus_type(self, *args, **kwargs):\n        \"\"\"Pass through to provider GradebookLookupSession.get_gradebooks_by_parent_genus_type\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_by_parent_genus_type\n        catalogs = self._get_provider_session('gradebook_lookup_session').get_gradebooks_by_parent_genus_type(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Gradebook(self._provider_manager, cat, self._runtime, self._proxy))\n        return GradebookList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_gradebooks(self):\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('gradebook_lookup_session').get_gradebooks()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Gradebook(self._provider_manager, cat, self._runtime, self._proxy))\n        return GradebookList(cat_list)", "response": "Pass through to provider GradebookLookupSession. get_gradebooks"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider GradebookAdminSession. get_gradebook_form_for_update", "response": "def get_gradebook_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider GradebookAdminSession.get_gradebook_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'gradebook_record_types' in kwargs:\n            return self.get_gradebook_form_for_create(*args, **kwargs)\n        else:\n            return self.get_gradebook_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_gradebook(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        # OSID spec does not require returning updated catalog\n        return Gradebook(\n            self._provider_manager,\n            self._get_provider_session('gradebook_admin_session').update_gradebook(*args, **kwargs),\n            self._runtime,\n            self._proxy)", "response": "Pass through to provider GradebookAdminSession. update_gradebook"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider GradebookAdminSession. update_gradebook", "response": "def save_gradebook(self, gradebook_form, *args, **kwargs):\n        \"\"\"Pass through to provider GradebookAdminSession.update_gradebook\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if gradebook_form.is_for_update():\n            return self.update_gradebook(gradebook_form, *args, **kwargs)\n        else:\n            return self.create_gradebook(gradebook_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the underlying gradebook view to match current view", "response": "def _set_gradebook_view(self, session):\n        \"\"\"Sets the underlying gradebook view to match current view\"\"\"\n        if self._gradebook_view == FEDERATED:\n            try:\n                session.use_federated_gradebook_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_gradebook_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef use_comparative_grade_system_view(self):\n        self._object_views['grade_system'] = COMPARATIVE\n        # self._get_provider_session('grade_system_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_grade_system_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider GradeSystemLookupSession. use_comparative_grade_system_view"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef use_plenary_grade_system_view(self):\n        self._object_views['grade_system'] = PLENARY\n        # self._get_provider_session('grade_system_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_grade_system_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider GradeSystemLookupSession. use_plenary_grade_system_view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npassing through to provider GradeSystemLookupSession. use_federated_gradebook_view", "response": "def use_federated_gradebook_view(self):\n        \"\"\"Pass through to provider GradeSystemLookupSession.use_federated_gradebook_view\"\"\"\n        self._gradebook_view = FEDERATED\n        # self._get_provider_session('grade_system_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_federated_gradebook_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npasses through to provider GradeSystemLookupSession. use_isolated_gradebook_view", "response": "def use_isolated_gradebook_view(self):\n        \"\"\"Pass through to provider GradeSystemLookupSession.use_isolated_gradebook_view\"\"\"\n        self._gradebook_view = ISOLATED\n        # self._get_provider_session('grade_system_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_isolated_gradebook_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_grade_system_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'grade_system_record_types' in kwargs:\n            return self.get_grade_system_form_for_create(*args, **kwargs)\n        else:\n            return self.get_grade_system_form_for_update(*args, **kwargs)", "response": "Pass through to provider GradeSystemAdminSession. get_grade_system_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_grade_system(self, grade_system_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if grade_system_form.is_for_update():\n            return self.update_grade_system(grade_system_form, *args, **kwargs)\n        else:\n            return self.create_grade_system(grade_system_form, *args, **kwargs)", "response": "Pass through to provider GradeSystemAdminSession. update_grade_system"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass through to provider GradeEntryLookupSession. use_comparative_grade_entry_view", "response": "def use_comparative_grade_entry_view(self):\n        \"\"\"Pass through to provider GradeEntryLookupSession.use_comparative_grade_entry_view\"\"\"\n        self._object_views['grade_entry'] = COMPARATIVE\n        # self._get_provider_session('grade_entry_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_grade_entry_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npasses through to provider GradeEntryLookupSession. use_plenary_grade_entry_view", "response": "def use_plenary_grade_entry_view(self):\n        \"\"\"Pass through to provider GradeEntryLookupSession.use_plenary_grade_entry_view\"\"\"\n        self._object_views['grade_entry'] = PLENARY\n        # self._get_provider_session('grade_entry_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_grade_entry_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_grade_entry_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'grade_entry_record_types' in kwargs:\n            return self.get_grade_entry_form_for_create(*args, **kwargs)\n        else:\n            return self.get_grade_entry_form_for_update(*args, **kwargs)", "response": "Pass through to provider GradeEntryAdminSession. get_grade_entry_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npass through to provider GradeEntryAdminSession. update_grade_entry", "response": "def save_grade_entry(self, grade_entry_form, *args, **kwargs):\n        \"\"\"Pass through to provider GradeEntryAdminSession.update_grade_entry\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if grade_entry_form.is_for_update():\n            return self.update_grade_entry(grade_entry_form, *args, **kwargs)\n        else:\n            return self.create_grade_entry(grade_entry_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use_comparative_gradebook_column_view(self):\n        self._object_views['gradebook_column'] = COMPARATIVE\n        # self._get_provider_session('gradebook_column_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_gradebook_column_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider GradebookColumnLookupSession. use_comparative_gradebook_column_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider GradebookColumnLookupSession. use_plenary_gradebook_column_view", "response": "def use_plenary_gradebook_column_view(self):\n        \"\"\"Pass through to provider GradebookColumnLookupSession.use_plenary_gradebook_column_view\"\"\"\n        self._object_views['gradebook_column'] = PLENARY\n        # self._get_provider_session('gradebook_column_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_gradebook_column_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_gradebook_column_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'gradebook_column_record_types' in kwargs:\n            return self.get_gradebook_column_form_for_create(*args, **kwargs)\n        else:\n            return self.get_gradebook_column_form_for_update(*args, **kwargs)", "response": "Pass through to provider GradebookColumnAdminSession. get_gradebook_column_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider GradebookColumnAdminSession. update_gradebook_column", "response": "def save_gradebook_column(self, gradebook_column_form, *args, **kwargs):\n        \"\"\"Pass through to provider GradebookColumnAdminSession.update_gradebook_column\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if gradebook_column_form.is_for_update():\n            return self.update_gradebook_column(gradebook_column_form, *args, **kwargs)\n        else:\n            return self.create_gradebook_column(gradebook_column_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef memoize(f):\n    @wraps(f)\n    def w(*args, **kw):\n        memoize.mem[f] = v = f(*args, **kw)\n        return v\n    return w", "response": "Cache value returned by the function f."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef project2module(project):\n    # Name unification in accordance with PEP 426.\n    project = project.lower().replace(\"-\", \"_\")\n    if project.startswith(\"python_\"):\n        # Remove conventional \"python-\" prefix.\n        project = project[7:]\n    return project", "response": "Convert project name into a module name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling visitor - used for finding setup() call.", "response": "def visit_Call(self, node):\n        \"\"\"Call visitor - used for finding setup() call.\"\"\"\n        self.generic_visit(node)\n\n        # Setup() is a keywords-only function.\n        if node.args:\n            return\n\n        keywords = set()\n        for k in node.keywords:\n            if k.arg is not None:\n                keywords.add(k.arg)\n            # Simple case for dictionary expansion for Python >= 3.5.\n            if k.arg is None and isinstance(k.value, ast.Dict):\n                keywords.update(x.s for x in k.value.keys)\n        # Simple case for dictionary expansion for Python <= 3.4.\n        if getattr(node, 'kwargs', ()) and isinstance(node.kwargs, ast.Dict):\n            keywords.update(x.s for x in node.kwargs.keys)\n\n        # The bare minimum number of arguments seems to be around five, which\n        # includes author, name, version, module/package and something extra.\n        if len(keywords) < 5:\n            return\n\n        score = sum(\n            self.attributes.get(x, 0)\n            for x in keywords\n        ) / len(keywords)\n\n        if score < 0.5:\n            LOG.debug(\n                \"Scoring for setup%r below 0.5: %.2f\",\n                tuple(keywords),\n                score)\n            return\n\n        # Redirect call to our setup() tap function.\n        node.func = ast.Name(id='__f8r_setup', ctx=node.func.ctx)\n        self.redirected = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_options(cls, manager):\n        kw = {}\n        if flake8.__version__ >= '3.0.0':\n            kw['parse_from_config'] = True\n        manager.add_option(\n            \"--known-modules\",\n            action='store',\n            default=\"\",\n            help=(\n                \"User defined mapping between a project name and a list of\"\n                \" provided modules. For example: ``--known-modules=project:\"\n                \"[Project],extra-project:[extras,utilities]``.\"\n            ),\n            **kw\n        )", "response": "Register plug - in specific options."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_options(cls, options):\n        cls.known_modules = {\n            project2module(k): v.split(\",\")\n            for k, v in [\n                x.split(\":[\")\n                for x in re.split(r\"],?\", options.known_modules)[:-1]\n            ]\n        }", "response": "Parse plug - in specific options."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getUserInfoError(sAccessToken):\n    import urllib.request, urllib.parse, urllib.error\n    payload = urllib.parse.urlencode({'access_token': sAccessToken})\n    c = http.client.HTTPSConnection('796.com')\n    c.request(\"GET\", \"/v1/user/get_info?\"+payload)\n    r = c.getresponse()\n    data = r.read()\n    jsonDict = json.loads(data.decode('utf-8'));\n    print(jsonDict)", "response": "Get user info from the API"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_html(self):\n\n        return '<a href=\"{0}\"><img height=\"{1}\" width=\"{2}\" src=\"{3}\" alt=\"{4}\"></a>'.format(\n            self.link, self.height, self.width, self.url, self.title)", "response": "Returns the image of the Yahoo RSS feed as an html string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ffprobe(input_file, verbose=False):\n    if isinstance(input_file, FileObject):\n        exists = input_file.exists\n        path = input_file.path\n    elif type(input_file) in string_types:\n        exists = os.path.exists(input_file)\n        path = input_file\n    else:\n        raise TypeError(\"input_path must be of string or FileObject type\")\n    if not exists:\n        logging.error(\"ffprobe: file does not exist ({})\".format(input_file))\n        return False\n    cmd = [\n            \"ffprobe\",\n            \"-show_format\",\n            \"-show_streams\",\n            \"-print_format\", \"json\",\n            path\n        ]\n    FNULL = open(os.devnull, \"w\")\n    if verbose:\n        logging.debug(\"Executing {}\".format(\" \".join(cmd)))\n    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    res = decode_if_py3(proc.stdout.read())\n    proc.wait()\n    if proc.returncode:\n        if verbose:\n            logging.error(\"Unable to read media file {}\\n\\n{}\\n\\n\".format(input_file, indent(proc.stderr.read())))\n        else:\n            logging.warning(\"Unable to read media file {}\".format(input_file))\n        return False\n    return json.loads(res)", "response": "Runs ffprobe on file and returns python dict with result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef class_check_para(**kw):\n    try:\n        def decorator(f):\n            def new_f(*args):\n                if \"accepts\" in kw:\n                    assert len(args) == len(kw[\"accepts\"]) + 1\n                    arg_types = tuple(map(type, args[1:]))\n                    if arg_types != kw[\"accepts\"]:\n                        msg = decorator_info(f.__name__, kw[\"accepts\"],\n                                             arg_types, 0)\n                        print('TypeWarning: ', msg)\n                        raise TypeError(msg)\n                result = f(*args)\n                if \"returns\" in kw:\n                    res_type = type(result)\n                    if res_type != kw[\"returns\"]:\n                        msg = decorator_info(f.__name__, (kw[\"returns\"],),\n                                             (res_type,), 1)\n                        print('TypeWarning: ', msg)\n                        raise TypeError(msg)\n                return result\n\n            new_f.__name__ = f.__name__\n            return new_f\n\n        return decorator\n    except KeyError as ke:\n        raise KeyError(ke.message + \"is not a valid keyword argument\")\n    except TypeError as te:\n        raise TypeError(te.message)", "response": "class_check_para - decorator for class_check_accept and class_check_return"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pay_loan(self, loan_name):\n        loan_payments = {\n            'student': 600,\n            'car': 200\n        }\n        payment_amount = loan_payments[loan_name]\n        self.withdraw(payment_amount)", "response": "additional when step for loan payments"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef withdraw(self, amount):\n        if amount > self.balance:\n            raise ValueError('Insufficient Funds')\n        super().withdraw(amount)", "response": "Extends withdraw method to make sure enough funds are in the account then call super method to call withdraw from superclass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compute_closed_central_moments(self, central_from_raw_exprs, n_counter, k_counter):\n\n        closed_raw_moments = self._compute_raw_moments(n_counter, k_counter)\n        assert(len(central_from_raw_exprs) == len(closed_raw_moments))\n        # raw moment lef hand side symbol\n        raw_symbols = [raw.symbol for raw in k_counter if raw.order > 1]\n\n        # we want to replace raw moments symbols with closed raw moment expressions (in terms of variances/means)\n        substitution_pairs = zip(raw_symbols, closed_raw_moments)\n        # so we can obtain expression of central moments in terms of low order raw moments\n        closed_central_moments = substitute_all(central_from_raw_exprs, substitution_pairs)\n        return closed_central_moments", "response": "r Computes parametric expressions for all central moments in terms of mean variance covariances and variance variance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_mixed_moments_to_zero(self, closed_central_moments, n_counter):\n\n        positive_n_counter = [n for n in n_counter if n.order > 1]\n        if self.is_multivariate:\n            return closed_central_moments\n        else:\n            return [0 if n.is_mixed else ccm for n,ccm in zip(positive_n_counter, closed_central_moments)]", "response": "r Sets the cross - terms to 0."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_tgf(filename):\n    g = Graph()\n    with open(filename) as file:\n        states = {}\n\n        # Nodes\n        for line in file:\n            line = line.strip()\n            if line == \"\": \n                continue\n            elif line == \"#\":\n                break\n            i, q = line.split(None, 1)\n            q, attrs = syntax.string_to_state(q)\n            states[i] = q\n            g.add_node(q, attrs)\n\n        # Edges\n        for line in file:\n            line = line.strip()\n            if line == \"\": \n                continue\n            i, j, t = line.split(None, 2)\n            q, r = states[i], states[j]\n            t = syntax.string_to_transition(t)\n            g.add_edge(q, r, {'label':t})\n\n    return from_graph(g)", "response": "Reads a file in Trivial Graph Format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef only_path(self):\n        start = [v for v in self.nodes if self.nodes[v].get('start', False)]\n        if len(start) != 1: \n            raise ValueError(\"graph does not have exactly one start node\")\n\n        path = []\n        [v] = start\n        while True:\n            path.append(v)\n            u = v\n            vs = self.edges.get(u, ())\n            if len(vs) == 0:\n                break\n            elif len(vs) > 1:\n                raise ValueError(\"graph does not have exactly one path\")\n            [v] = vs\n\n        return path", "response": "Finds the only path from the start node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_catalog(self, proxy=None, runtime=None):\n        self._init_proxy_and_runtime(proxy, runtime)\n        osid_name = self._session_namespace.split('.')[0]\n        try:\n            config = self._runtime.get_configuration()\n            parameter_id = Id('parameter:' + osid_name + 'CatalogingProviderImpl@mongo')\n            provider_impl = config.get_value_by_parameter(parameter_id).get_string_value()\n            self._cataloging_manager = self._runtime.get_manager('CATALOGING', provider_impl)  # need to add version argument\n        except (AttributeError, KeyError, errors.NotFound):\n            pass", "response": "Initialize this session as an OsidCatalog based session."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing this session an OsidObject based session.", "response": "def _init_object(self, catalog_id, proxy, runtime, db_name, cat_name, cat_class):\n        \"\"\"Initialize this session an OsidObject based session.\"\"\"\n        self._catalog_identifier = None\n        self._init_proxy_and_runtime(proxy, runtime)\n\n        uses_cataloging = False\n        if catalog_id is not None and catalog_id.get_identifier() != PHANTOM_ROOT_IDENTIFIER:\n            self._catalog_identifier = catalog_id.get_identifier()\n\n            config = self._runtime.get_configuration()\n            parameter_id = Id('parameter:' + db_name + 'CatalogingProviderImpl@mongo')\n\n            try:\n                provider_impl = config.get_value_by_parameter(parameter_id).get_string_value()\n            except (AttributeError, KeyError, errors.NotFound):\n                collection = JSONClientValidated(db_name,\n                                                 collection=cat_name,\n                                                 runtime=self._runtime)\n                try:\n                    self._my_catalog_map = collection.find_one({'_id': ObjectId(self._catalog_identifier)})\n                except errors.NotFound:\n                    if catalog_id.get_identifier_namespace() != db_name + '.' + cat_name:\n                        self._my_catalog_map = self._create_orchestrated_cat(catalog_id, db_name, cat_name)\n                    else:\n                        raise errors.NotFound('could not find catalog identifier ' + catalog_id.get_identifier() + cat_name)\n            else:\n                uses_cataloging = True\n                cataloging_manager = self._runtime.get_manager('CATALOGING',\n                                                               provider_impl)  # need to add version argument\n                lookup_session = cataloging_manager.get_catalog_lookup_session()\n                # self._my_catalog_map = lookup_session.get_catalog(catalog_id)._my_map\n                # self._catalog = Catalog(osid_object_map=self._my_catalog_map, runtime=self._runtime,\n                #                         proxy=self._proxy)\n                self._catalog = lookup_session.get_catalog(catalog_id)\n        else:\n            self._catalog_identifier = PHANTOM_ROOT_IDENTIFIER\n            self._my_catalog_map = make_catalog_map(cat_name, identifier=self._catalog_identifier)\n\n        if not uses_cataloging:\n            self._catalog = cat_class(osid_object_map=self._my_catalog_map, runtime=self._runtime, proxy=self._proxy)\n\n        self._catalog._authority = self._authority  # there should be a better way...\n        self._catalog_id = self._catalog.get_id()\n        self._forms = dict()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_phantom_root_catalog(self, cat_name, cat_class):\n        catalog_map = make_catalog_map(cat_name, identifier=PHANTOM_ROOT_IDENTIFIER)\n        return cat_class(osid_object_map=catalog_map, runtime=self._runtime, proxy=self._proxy)", "response": "Get s the catalog id corresponding to the root of all implementation catalogs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a catalog in the current service orchestrated with a foreign service Id.", "response": "def _create_orchestrated_cat(self, foreign_catalog_id, db_name, cat_name):\n        \"\"\"Creates a catalog in the current service orchestrated with a foreign service Id.\"\"\"\n        if (foreign_catalog_id.identifier_namespace == db_name + '.' + cat_name and\n                foreign_catalog_id.authority == self._authority):\n            raise errors.NotFound()  # This is not a foreign catalog\n        foreign_service_name = foreign_catalog_id.get_identifier_namespace().split('.')[0]\n        # foreign_cat_name = inflection.underscore(foreign_catalog_id.namespace.split('.')[1])\n        # catalog_name = foreign_cat_name.lower()\n        catalog_name = camel_to_under(foreign_catalog_id.namespace.split('.')[1])\n        manager = self._get_provider_manager(foreign_service_name.upper())\n        lookup_session = getattr(manager, 'get_{0}_lookup_session'.format(catalog_name))(proxy=self._proxy)\n        getattr(lookup_session, 'get_{0}'.format(catalog_name))(foreign_catalog_id)  # Raises NotFound\n        collection = JSONClientValidated(db_name,\n                                         collection=cat_name,\n                                         runtime=self._runtime)\n        foreign_identifier = ObjectId(foreign_catalog_id.get_identifier())\n        default_text = 'Orchestrated ' + foreign_service_name\n        catalog_map = make_catalog_map(cat_name, identifier=foreign_identifier, default_text=default_text)\n        collection.insert_one(catalog_map)\n        alias_id = Id(identifier=foreign_catalog_id.identifier,\n                      namespace=db_name + '.' + cat_name,\n                      authority=self._authority)\n        try:\n            admin_session = getattr(manager, 'get_{0}_admin_session'.format(catalog_name))(proxy=self._proxy)\n            getattr(admin_session, 'alias_{0}'.format(catalog_name))(foreign_catalog_id, alias_id)\n        except (errors.Unimplemented, AttributeError):\n            pass\n        return catalog_map"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the primary id given an alias table.", "response": "def _get_id(self, id_, pkg_name):\n        \"\"\"\n        Returns the primary id given an alias.\n\n        If the id provided is not in the alias table, it will simply be\n        returned as is.\n\n        Only looks within the Id Alias namespace for the session package\n\n        \"\"\"\n        collection = JSONClientValidated('id',\n                                         collection=pkg_name + 'Ids',\n                                         runtime=self._runtime)\n        try:\n            result = collection.find_one({'aliasIds': {'$in': [str(id_)]}})\n        except errors.NotFound:\n            return id_\n        else:\n            return Id(result['_id'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the given equivalent_id as an alias for primary_id if possible", "response": "def _alias_id(self, primary_id, equivalent_id):\n        \"\"\"Adds the given equivalent_id as an alias for primary_id if possible\"\"\"\n        pkg_name = primary_id.get_identifier_namespace().split('.')[0]\n        obj_name = primary_id.get_identifier_namespace().split('.')[1]\n        collection = JSONClientValidated(pkg_name,\n                                         collection=obj_name,\n                                         runtime=self._runtime)\n        collection.find_one({'_id': ObjectId(primary_id.get_identifier())})  # to raise NotFound\n        collection = JSONClientValidated('id',\n                                         collection=pkg_name + 'Ids',\n                                         runtime=self._runtime)\n        try:\n            result = collection.find_one({'aliasIds': {'$in': [str(equivalent_id)]}})\n        except errors.NotFound:\n            pass\n        else:\n            result['aliasIds'].remove(str(equivalent_id))\n            collection.save(result)\n        try:\n            id_map = collection.find_one({'_id': str(primary_id)})\n        except errors.NotFound:\n            collection.insert_one({'_id': str(primary_id), 'aliasIds': [str(equivalent_id)]})\n        else:\n            id_map['aliasIds'].append(str(equivalent_id))\n            collection.save(id_map)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the proper list of catalog idstrs based on catalog view", "response": "def _get_catalog_idstrs(self):\n        \"\"\"Returns the proper list of catalog idstrs based on catalog view\"\"\"\n        if self._catalog_view == ISOLATED:\n            return [str(self._catalog_id)]\n        else:\n            return self._get_descendent_cat_idstrs(self._catalog_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_descendent_cat_idstrs(self, cat_id, hierarchy_session=None):\n        def get_descendent_ids(h_session):\n            idstr_list = [str(cat_id)]\n            if h_session is None:\n                pkg_name = cat_id.get_identifier_namespace().split('.')[0]\n                cat_name = cat_id.get_identifier_namespace().split('.')[1]\n                try:\n                    mgr = self._get_provider_manager('HIERARCHY')\n                    h_session = mgr.get_hierarchy_traversal_session_for_hierarchy(\n                        Id(authority=pkg_name.upper(),\n                           namespace='CATALOG',\n                           identifier=cat_name.upper()),\n                        proxy=self._proxy)\n                except (errors.OperationFailed, errors.Unsupported):\n                    return idstr_list  # there is no hierarchy\n            if h_session.has_children(cat_id):\n                for child_id in h_session.get_children(cat_id):\n                    idstr_list += self._get_descendent_cat_idstrs(child_id, h_session)\n            return list(set(idstr_list))\n\n        use_caching = False\n        try:\n            config = self._runtime.get_configuration()\n            parameter_id = Id('parameter:useCachingForQualifierIds@json')\n            if config.get_value_by_parameter(parameter_id).get_boolean_value():\n                use_caching = True\n            else:\n                pass\n        except (AttributeError, KeyError, errors.NotFound):\n            pass\n        if use_caching:\n            key = 'descendent-catalog-ids-{0}'.format(str(cat_id))\n\n            # If configured to use memcache as the caching engine, use it.\n            # Otherwise default to diskcache\n            caching_engine = 'diskcache'\n\n            try:\n                config = self._runtime.get_configuration()\n                parameter_id = Id('parameter:cachingEngine@json')\n                caching_engine = config.get_value_by_parameter(parameter_id).get_string_value()\n            except (AttributeError, KeyError, errors.NotFound):\n                pass\n\n            if caching_engine == 'memcache':\n                import memcache\n                caching_host = '127.0.0.1:11211'\n                try:\n                    config = self._runtime.get_configuration()\n                    parameter_id = Id('parameter:cachingHostURI@json')\n                    caching_host = config.get_value_by_parameter(parameter_id).get_string_value()\n                except (AttributeError, KeyError, errors.NotFound):\n                    pass\n\n                mc = memcache.Client([caching_host], debug=0)\n\n                catalog_ids = mc.get(key)\n                if catalog_ids is None:\n                    catalog_ids = get_descendent_ids(hierarchy_session)\n                    mc.set(key, catalog_ids)\n            elif caching_engine == 'diskcache':\n                import diskcache\n                with diskcache.Cache('/tmp/dlkit_cache') as cache:\n                    # A little bit non-DRY, since it's almost the same as for memcache above.\n                    # However, for diskcache.Cache, we have to call \".close()\" or use a\n                    #   ``with`` statement to safeguard calling \".close()\", so we keep this\n                    #   separate from the memcache implementation.\n                    catalog_ids = cache.get(key)\n                    if catalog_ids is None:\n                        catalog_ids = get_descendent_ids(hierarchy_session)\n                        cache.set(key, catalog_ids)\n            else:\n                raise errors.NotFound('The {0} caching engine was not found.'.format(caching_engine))\n        else:\n            catalog_ids = get_descendent_ids(hierarchy_session)\n        return catalog_ids", "response": "Recursively returns a list of all descendent catalog ids inclusive"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the mongodb relationship filter for effective views", "response": "def _effective_view_filter(self):\n        \"\"\"Returns the mongodb relationship filter for effective views\"\"\"\n        if self._effective_view == EFFECTIVE:\n            now = datetime.datetime.utcnow()\n            return {'startDate': {'$$lte': now}, 'endDate': {'$$gte': now}}\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the mongodb catalog filter for isolated or federated views.", "response": "def _view_filter(self):\n        \"\"\"\n        Returns the mongodb catalog filter for isolated or federated views.\n\n        This also searches across all underlying catalogs in federated\n        catalog views. Real authz for controlling access to underlying\n        catalogs will need to be managed in an adapter above the\n        pay grade of this implementation.\n\n        \"\"\"\n        if self._is_phantom_root_federated():\n            return {}\n        idstr_list = self._get_catalog_idstrs()\n        return {'assigned' + self._catalog_name + 'Ids': {'$in': idstr_list}}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef walk(self):\n        yield (\n            self,\n            self.parent,\n            list(self.sub_packages.values()),\n            list(self.sub_modules.values()),\n        )\n\n        for pkg in self.sub_packages.values():\n            for things in pkg.walk():\n                yield things", "response": "A generator that walks through all sub packages and sub modules and returns a list of all the objects that are in the order they were added."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _tree_view_builder(self, indent=0, is_root=True):\n\n        def pad_text(indent):\n            return \"    \" * indent + \"|-- \"\n\n        lines = list()\n\n        if is_root:\n            lines.append(SP_DIR)\n\n        lines.append(\n            \"%s%s (%s)\" % (pad_text(indent), self.shortname, self.fullname)\n        )\n\n        indent += 1\n\n        # sub packages\n        for pkg in self.sub_packages.values():\n            lines.append(pkg._tree_view_builder(indent=indent, is_root=False))\n\n        # __init__.py\n        lines.append(\n            \"%s%s (%s)\" % (\n                pad_text(indent), \"__init__.py\", self.fullname,\n            )\n        )\n\n        # sub modules\n        for mod in self.sub_modules.values():\n            lines.append(\n                \"%s%s (%s)\" % (\n                    pad_text(indent), mod.shortname + \".py\", mod.fullname,\n                )\n            )\n\n        return \"\\n\".join(lines)", "response": "Build a text to represent the package structure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_object_map(self):\n        obj_map = self._payload.get_object_map()\n        obj_map['assetContents'] = []\n        for asset_content in self.get_asset_contents():\n            obj_map['assetContents'].append(asset_content.object_map)\n        return obj_map", "response": "get the object map for this asset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_data(self):\n        # read the file from self.get_url()\n        # return the file object to be streamed?\n        url = self._payload.get_url()\n        file_handle = codecs.open(url, 'r', encoding='utf-8')\n        try:\n            file_handle.read()\n        except UnicodeDecodeError:\n            file_handle.close()\n            # non-Unicode file, like an image\n            file_handle = open(url, 'rb')\n        file_handle.seek(0)\n        return file_handle", "response": "Gets the asset content data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_url(self):\n        # construct the URL from runtime's FILESYSTEM location param\n        # plus what we know about the location of repository / assetContents\n        # have to get repositoryId from the asset?\n        # return self._payload.get_url()\n        url = '/repository/repositories/{0}/assets/{1}/contents/{2}/stream'.format(self._my_map['assignedRepositoryIds'][0],\n                                                                                   str(self.get_asset_id()),\n                                                                                   str(self.get_id()))\n\n        if 'url_hostname' in self._config_map:\n            url_hostname = self._config_map['url_hostname']\n            return '{0}{1}'.format(url_hostname, url)\n\n        return url", "response": "Gets the URL associated with this content for web - based retrieval."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_object_map(self):\n        obj_map = self._payload.get_object_map()\n        obj_map.update({'url': self.get_url()})\n        # obj_map['recordTypeIds'].append(str(FILESYSTEM_ASSET_CONTENT_RECORD_TYPE))\n        return obj_map", "response": "stub Get the object map for this asset."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the content data.", "response": "def set_data(self, data=None):\n        \"\"\"Sets the content data.\n\n        arg:    data (osid.transport.DataInputStream): the content data\n        raise:  InvalidArgument - ``data`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``data`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        def has_secondary_storage():\n            return 'secondary_data_store_path' in self._config_map\n\n        extension = data.name.split('.')[-1]\n        data_store_path = self._config_map['data_store_path']\n        if has_secondary_storage():\n            secondary_data_store_path = self._config_map['secondary_data_store_path']\n\n        if '_id' in self._my_map:\n            filename = self._my_map['_id']\n            # remove any old file that is set\n            if str(self._my_map['_id']) not in self._my_map['url']:\n                os.remove(self._my_map['url'])\n\n                if has_secondary_storage():\n                    old_path = '{0}/repository/AssetContent'.format(data_store_path)\n                    secondary_file_location = self._my_map['url'].replace(old_path,\n                                                                          secondary_data_store_path)\n                    os.remove(secondary_file_location)\n        else:\n            filename = ObjectId()\n\n        filesystem_location = '{0}/repository/AssetContent/'.format(data_store_path)\n\n        if not os.path.isdir(filesystem_location):\n            os.makedirs(filesystem_location)\n\n        file_location = '{0}{1}.{2}'.format(filesystem_location,\n                                            str(filename),\n                                            extension)\n\n        data.seek(0)\n\n        with open(file_location, 'wb') as file_handle:\n            file_handle.write(data.read())\n\n        # this URL should be a filesystem path...relative\n        # to the setting in runtime\n        self._payload.set_url(file_location)\n\n        # if set, also make a backup copy in the secondary_data_store_path\n        if has_secondary_storage():\n            data.seek(0)\n\n            if not os.path.isdir(secondary_data_store_path):\n                os.makedirs(secondary_data_store_path)\n\n            file_location = '{0}/{1}.{2}'.format(secondary_data_store_path,\n                                                 str(filename),\n                                                 extension)\n            with open(file_location, 'wb') as file_handle:\n                file_handle.write(data.read())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear_data(self):\n        # Removes the item from filesystem and resets URL to ''\n        url = self.get_url()\n        # try to clear from payload first, in case that fails we won't mess with AWS\n        self._payload.clear_url()\n        os.remove(url)", "response": "Removes the content data from the filesystem and resets the URL to empty"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun an automaton automatically selecting a search method.", "response": "def run(m, w, trace=False, steps=1000, show_stack=3):\n    \"\"\"Runs an automaton, automatically selecting a search method.\"\"\"\n\n    # Check to see whether run_pda can handle it.\n    is_pda = True\n    stack = None\n    if not m.oneway:\n        is_pda = False\n    for s in range(m.num_stores):\n        if s == m.input:\n            pass\n        elif m.has_cell(s): # anything with finite number of configs would do\n            pass\n        elif m.has_stack(s):\n            if stack is None:\n                stack = s\n            else:\n                is_pda = False\n        else:\n            is_pda = False\n\n    if is_pda and stack is not None:\n        if trace: print(\"using modified Lang algorithm\")\n        return run_pda(m, w, stack=stack, trace=trace, show_stack=show_stack)\n    else:\n        if trace: print(\"using breadth-first search\")\n        return run_bfs(m, w, trace=trace, steps=steps)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns an automaton using breadth - first search.", "response": "def run_bfs(m, w, trace=False, steps=1000):\n    \"\"\"Runs an automaton using breadth-first search.\"\"\"\n    from .machines import Store, Configuration, Transition\n\n    agenda = collections.deque()\n    chart = {}\n\n    # Initial configuration\n    config = list(m.start_config)\n    w = Store(w)\n    config[m.input] = w\n    config = Configuration(config)\n\n    chart[config] = 0\n    agenda.append(config)\n    run = graphs.Graph()\n    run.attrs['rankdir'] = 'LR'\n    run.add_node(config, {'start': True})\n\n    while len(agenda) > 0:\n        tconfig = agenda.popleft()\n\n        if trace: print(\"trigger: {}\".format(tconfig))\n\n        for aconfig in m.accept_configs:\n            if aconfig.match(tconfig):\n                run.add_node(tconfig, {'accept': True})\n\n        if chart[tconfig] == steps:\n            if trace: print(\"maximum number of steps reached\")\n            run.add_node(tconfig, {'incomplete': True})\n            continue\n\n        for rule in m.transitions:\n            if trace: print(\"rule: {}\".format(rule))\n            if rule.match(tconfig):\n                nconfig = rule.apply(tconfig)\n\n                if nconfig in chart:\n                    assert chart[nconfig] <= chart[tconfig]+1\n                    if trace: print(\"merge: {}\".format(nconfig))\n                else:\n                    chart[nconfig] = chart[tconfig]+1\n                    if trace: print(\"add: {}\".format(nconfig))\n                    agenda.append(nconfig)\n                run.add_edge(tconfig, nconfig)\n\n    # If input tape is one-way, then rank all nodes by input position\n    if m.oneway:\n        for q in run.nodes:\n            ql = list(q)\n            run.nodes[q]['rank'] = ql.pop(m.input)\n            run.nodes[q]['label'] = Configuration(ql)\n        for i in range(len(w)+1):\n            r = 'rank{}'.format(i)\n            run.add_node(r, {'rank' : Store(w[i:]), 'style' : 'invisible'})\n            if i > 0:\n                run.add_edge(rprev, r, {'color': 'white', 'label' : w[i-1]})\n            rprev = r\n\n    return run"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_pda(m, w, stack=2, trace=False, show_stack=3):\n\n    \"\"\"The items are pairs of configurations (parent, child), where\n\n       - parent is None and child's stack has no elided items\n       - child has one more elided item than parent\n\n    The inference rules are:\n\n    Axiom:\n    \n    ------------------\n    [None => q0, 0, &]\n    \n    Push:\n    \n    [q, i, yz => r, j, xy']\n    -----------------------\n    [r, j, xy' => r, j, x]\n    \n    Pop:\n    \n    [q, i, yz => r, j, xy'] [r, j, xy' => s, k, &]\n    ----------------------------------------------\n                 [q, i, yz => s, k, y']\n\n    Apply: applies a transition to child\n\n    \"\"\"\n\n    from .machines import Store, Configuration, Transition\n\n    agenda = collections.deque()\n    chart = set()\n    index_left = collections.defaultdict(set)\n    index_right = collections.defaultdict(set)\n    backpointers = collections.defaultdict(set)\n    run = graphs.Graph()\n    run.attrs['rankdir'] = 'LR'\n\n    # which position the state, input and stack are in\n    if not m.has_stack(stack):\n        raise ValueError(\"store %s must be a stack\" % stack)\n\n    # how much of the stack is not elided\n    show_stack = max(show_stack, \n                     max(len(t.lhs[stack]) for t in m.transitions), \n                     max(len(c[stack]) for c in m.accept_configs))\n\n    # Axiom\n    config = list(m.start_config)\n    w = Store(w)\n    config[m.input] = w\n    config = Configuration(config)\n\n    # draw input symbols\n    for i in range(len(w)+1):\n        r = 'rank{}'.format(i)\n        run.add_node(r, {'rank' : Store(w[i:]), 'style' : 'invisible'})\n        if i > 0:\n            run.add_edge(rprev, r, {'color': 'white', 'label' : w[i-1]})\n        rprev = r\n\n    def get_node(parent, child):\n        if parent is not None:\n            # In the run graph, we don't show the parent,\n            # but if there is one, add a ...\n            child = list(child)\n            child[stack] = Store(child[stack].values + [\"...\"], child[stack].position)\n        return Configuration(child)\n\n    def add_node(parent, child, attrs=None):\n        node = get_node(parent, child)\n        attrs = {} if attrs is None else dict(attrs)\n        label = list(node)\n        attrs['rank'] = label.pop(m.input)\n        attrs['label'] = Configuration(label)\n        run.add_node(node, attrs)\n\n    agenda.append((None, config))\n    add_node(None, config, {'start': True})\n\n    def add(parent, child):\n        if (parent, child) in chart:\n            if trace: print(\"merge: {} => {}\".format(parent, child))\n        else:\n            chart.add((parent, child))\n            if trace: print(\"add: {} => {}\".format(parent, child))\n            agenda.append((parent, child))\n\n    while len(agenda) > 0:\n        parent, child = agenda.popleft()\n        if trace: print(\"trigger: {} => {}\".format(parent, child))\n\n        for aconfig in m.accept_configs:\n            if aconfig.match(child) and (parent is None or len(child[stack]) == show_stack):\n                add_node(parent, child, {'accept': True})\n\n        # The stack shows too many items (push)\n        if len(child[stack]) > show_stack:\n            grandchild = child.deepcopy()\n            del grandchild[stack].values[-1]\n            add(child, grandchild)\n            index_right[child].add(parent)\n            for ant in backpointers[get_node(parent, child)]:\n                backpointers[get_node(child, grandchild)].add(ant)\n\n            # This item can also be the left antecedent of the Pop rule\n            for grandchild in index_left[child]:\n                grandchild = grandchild.deepcopy()\n                grandchild[stack].values.append(child[stack][-1])\n                add(parent, grandchild)\n                for ant in backpointers[get_node(parent, child)]:\n                    backpointers[get_node(parent, grandchild)].add(ant)\n\n        # The stack shows too few items (pop)\n        elif parent is not None and len(child[stack]) < show_stack:\n            aunt = child.deepcopy()\n            if len(parent[stack]) == 0:\n                assert False\n            else:\n                aunt[stack].values.append(parent[stack][-1])\n            index_left[parent].add(child)\n\n            for grandparent in index_right[parent]:\n                add(grandparent, aunt)\n\n            for ant in backpointers[get_node(parent, child)]:\n                backpointers[get_node(grandparent, aunt)].add(ant)\n\n        # The stack is just right\n        else:\n            add_node(parent, child)\n            for transition in m.transitions:\n                if transition.match(child):\n                    sister = transition.apply(child)\n                    add(parent, sister)\n                    backpointers[get_node(parent, sister)].add(get_node(parent, child))\n\n    # Add run edges only between configurations whose stack is\n    # just right\n    for config2 in run.nodes:\n        for config1 in backpointers[config2]:\n            run.add_edge(config1, config2)\n\n    return run", "response": "Runs a nondeterministic pushdown automaton using the cubic\n    algorithm of Bernard Lang andDeterministic techniques for efficient \n    non - deterministic parsers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _append_zeros(self, initial_conditions, number_of_equations):\n\n        if len(initial_conditions) < number_of_equations:\n            initial_conditions = np.concatenate((initial_conditions,\n                                                 [0.0] * (self.problem.number_of_equations - len(initial_conditions))))\n        return initial_conditions", "response": "Append zeros to the list of initial conditions if not all intial conditions specified."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsimulates the system for each of the timepoints.", "response": "def simulate_system(self, parameters, initial_conditions, timepoints):\n        \"\"\"\n        Simulates the system for each of the timepoints, starting at initial_constants and initial_values values\n\n        :param parameters: list of the initial values for the constants in the model.\n                                  Must be in the same order as in the model\n        :param initial_conditions: List of the initial values for the equations in the problem. Must be in the same order as\n                               these equations occur.\n                               If not all values specified, the remaining ones will be assumed to be 0.\n        :param timepoints: A list of time points to simulate the system for\n        :return: a list of :class:`~means.simulation.Trajectory` objects,\n                 one for each of the equations in the problem\n        :rtype: list[:class:`~means.simulation.Trajectory`]\n        \"\"\"\n\n        initial_conditions = self._append_zeros(initial_conditions, self.problem.number_of_equations)\n        solver = self._initialise_solver(initial_conditions, parameters, timepoints)\n        trajectories = solver.simulate(timepoints)\n\n        return TrajectoryCollection(trajectories)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef simulate_system(self, parameters, initial_conditions, timepoints):\n        return super(SimulationWithSensitivities, self).simulate_system(parameters, initial_conditions, timepoints)", "response": "Simulates the system for each of the timepoints starting at initial_constants and initial_values values\n                                 "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(self, **kwargs):\n\n        pty_stdin, pty_stdout, pty_stderr = self.sockets()\n        pumps = []\n\n        if pty_stdin and self.interactive:\n            pumps.append(io.Pump(io.Stream(self.stdin), pty_stdin, wait_for_output=False))\n\n        if pty_stdout:\n            pumps.append(io.Pump(pty_stdout, io.Stream(self.stdout), propagate_close=False))\n\n        if pty_stderr:\n            pumps.append(io.Pump(pty_stderr, io.Stream(self.stderr), propagate_close=False))\n\n        if not self.container_info()['State']['Running']:\n            self.client.start(self.container, **kwargs)\n\n        flags = [p.set_blocking(False) for p in pumps]\n\n        try:\n            with WINCHHandler(self):\n                self._hijack_tty(pumps)\n        finally:\n            if flags:\n                for (pump, flag) in zip(pumps, flags):\n                    io.set_blocking(pump, flag)", "response": "Present the PTY of the container inside the current process.\n\n        This will take over the current process' TTY until the container's PTY\n        is closed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef israw(self):\n\n        if self.raw is None:\n            info = self.container_info()\n            self.raw = self.stdout.isatty() and info['Config']['Tty']\n\n        return self.raw", "response": "Returns True if the PTY should operate in raw mode False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resize(self, size=None):\n\n        if not self.israw():\n            return\n\n        size = size or tty.size(self.stdout)\n\n        if size is not None:\n            rows, cols = size\n            try:\n                self.client.resize(self.container, height=rows, width=cols)\n            except IOError: # Container already exited\n                pass", "response": "Resize the container s PTY."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'birdland.mit.edu',\n            'namespace': 'currency format',\n            'identifier': name,\n            'domain': 'Currency Format Types',\n            'display_name': JEFFS_CURRENCY_FORMAT_TYPES[name] + ' Currency Format Type',\n            'display_label': JEFFS_CURRENCY_FORMAT_TYPES[name],\n            'description': ('The format type for the ' +\n                            JEFFS_CURRENCY_FORMAT_TYPES[name] + ' currency')\n        }\n    except KeyError:\n        raise NotFound('Currency Format Type: ' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_tf_idf(file_names=['./../test/testdata'],prev_file_path=None, dump_path=None):\n    '''Function to create a TF-IDF list of dictionaries for a corpus of docs.\n    If you opt for dumping the data, you can provide a file_path with .tfidfpkl extension(standard made for better understanding)\n    and also re-generate a new tfidf list which overrides over an old one by mentioning its path.\n\n    @Args:\n    --\n    file_names :      paths of files to be processed on, these files are created using twitter_streaming module.\n    prev_file_path :  path of old .tfidfpkl file, if available. (default=None)\n    dump_path :       directory-path where to dump generated lists.(default=None)\n\n    @returns:\n    --\n    df :     a dict of unique words in corpus,with their document frequency as values.\n    tf_idf : the generated tf-idf list of dictionaries for mentioned docs.\n    '''\n    tf_idf = [] # will hold a dict of word_count for every doc(line in a doc in this case)\n    df = defaultdict(int)\n    # this statement is useful for altering existant tf-idf file and adding new docs in itself.(## memory is now the biggest issue)\n    if prev_file_path:\n        print(TAG,'modifying over exising file.. @',prev_file_path)\n        df,tf_idf = pickle.load(open(prev_file_path,'rb'))\n        prev_doc_count = len(df)\n        prev_corpus_length = len(tf_idf)\n\n    for f in file_names:\n        # never use 'rb' for textual data, it creates something like,  {b'line-inside-the-doc'}\n        with open(f,'r') as file1:\n            #create word_count dict for all docs\n            for line in file1:\n                wdict = defaultdict(int)\n                #find the amount of doc a word is in\n                for word in set(line.split()):\n                    df[word] +=1\n                #find the count of all words in every doc\n                for word in line.split():\n                    wdict[word] += 1\n                tf_idf.append(wdict)\n\n    #calculating final TF-IDF values  for all words in all docs(line is a doc in this case)\n    for doc in tf_idf:\n        for key in doc:\n            true_idf = math.log(len(tf_idf)/df[key])\n            true_tf = doc[key]/float(len(doc))\n            doc[key] = true_tf * true_idf\n\n    print(TAG,'Total number of unique words in corpus',len(df),'( '+paint('++'+str(len(df)-prev_doc_count),'g')+' )' if prev_file_path else '')\n    print(TAG,'Total number of docs in corpus:',len(tf_idf),'( '+paint('++'+str(len(tf_idf)-prev_corpus_length),'g')+' )' if prev_file_path else '')\n    \n    # dump if a dir-path is given\n    if dump_path:\n        if dump_path[-8:] == 'tfidfpkl': \n            pickle.dump((df,tf_idf),open(dump_path,'wb'),protocol=pickle.HIGHEST_PROTOCOL)\n            print(TAG,'Dumping TF-IDF vars @',dump_path)\n    return df,tf_idf", "response": "Function to create a TF - IDF list of dictionaries for a corpus of docs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_knn(tf_idf,input_word,k=WIN,rand_on=True):\n    '''func that find k nearest neighbors of a spcified word from a given file of tf-idf values of words for list of docs.\n    @Args:\n    --\n    tfidf_file_name : File name for the .tfidfpkl file to be used for searching.\n    input_word : word for which process need to be done.\n    k : amount of nearest neighbors to yield.(default=cf.nn_window)\n\n    @yields:\n    word : kth Nearnest Neighbor of the provided input_word for specified file.(generator yield)\n    '''\n    \n    #find docs that have input_word and gather their content\n    word_bag = {}\n    for doc in tf_idf:\n        contains_flag = False\n        #print(doc)\n        if input_word in doc.keys():\n            #this code will only generate unique words and their tf_idf values, overwritten when already available..\n            word_bag.update(doc)    \n    #sort the available list of words from docs according to their tf_idf values.\n    word_bag = sorted(word_bag.items(), key=operator.itemgetter(1))\n    #reverse the order as to get words with large TF-IDF values(descending order)\n    word_bag.reverse()\n    for element in word_bag[:k]:\n        #condition where the word_bag throws the same word as input...(highly likely, hence ignored)\n        if element[0] == input_word or (bool(random.getrandbits(1)) and rand_on): \n            continue # randomly select if current word will get yielded or to continue to next word.\n        #creating a generator structure for better efficiency of code.\n        yield element[0]", "response": "function that finds k nearest neighbors of a spcified word from a given file of tf - idf values of words for a given input word."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets data from API as instance of ResponseModel.", "response": "def get(self, mac):\n        \"\"\"Get data from API as instance of ResponseModel.\n\n            Keyword arguments:\n            mac -- MAC address or OUI for searching\n        \"\"\"\n\n        data = {\n            self._FORMAT_F: 'json',\n            self._SEARCH_F: mac\n        }\n\n        response = self.__decode_str(self.__call_api(self.__url, data), 'utf-8')\n\n        if len(response) > 0:\n            return self.__parse(response)\n        raise EmptyResponseException()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting data from API as string.", "response": "def get_raw_data(self, mac, response_format='json'):\n        \"\"\"Get data from API as string.\n\n            Keyword arguments:\n            mac -- MAC address or OUI for searching\n            response_format -- supported types you can see on the https://macaddress.io\n        \"\"\"\n\n        data = {\n            self._FORMAT_F: response_format,\n            self._SEARCH_F: mac\n        }\n\n        response = self.__decode_str(self.__call_api(self.__url, data), 'utf-8')\n\n        if len(response) > 0:\n            return response\n        raise EmptyResponseException()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_vendor(self, mac):\n\n        data = {\n            self._SEARCH_F: mac,\n            self._FORMAT_F: self._VERBOSE_T\n        }\n\n        response = self.__decode_str(self.__call_api(self.__url, data), 'utf-8')\n\n        return response", "response": "Get vendor company name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_provenance_parent(self):\n        if self.has_provenance():\n            collection = JSONClientValidated('assessment',\n                                             collection='Item',\n                                             runtime=self.my_osid_object._runtime)\n            result = collection.find_one(\n                {'_id': ObjectId(Id(self.get_provenance_id()).get_identifier())})\n            return Item(osid_object_map=result,\n                        runtime=self.my_osid_object._runtime,\n                        proxy=self.my_osid_object._proxy)\n        raise IllegalState(\"Item has no provenance parent.\")", "response": "get the parent of the item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_provenance_children(self):\n        if self.has_provenance_children():\n            collection = JSONClientValidated('assessment',\n                                             collection='Item',\n                                             runtime=self.my_osid_object._runtime)\n            try:\n                result = collection.find(\n                    {'provenanceId': self.my_osid_object.object_map['id']})\n                if result.count() == 0:\n                    raise KeyError\n            except KeyError:\n                # For deprecated mecqbank data\n                result = collection.find(\n                    {'provenanceItemId': self.my_osid_object.object_map['id']})\n            return ItemList(result,\n                            runtime=self.my_osid_object._runtime,\n                            proxy=self.my_osid_object._proxy)\n        raise IllegalState('No provenance children.')", "response": "get the children of this assessment"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_metadata(self):\n        self._min_string_length = None\n        self._max_string_length = None\n        self._solution_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'solution'),\n            'element_label': 'Solution',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': self._min_string_length,\n            'maximum_string_length': self._max_string_length,\n            'string_set': []\n        }", "response": "Initialize the metadata for the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef children(self, alias, bank_id):\n        return self._root + self._safe_alias(alias) + '/child/ids/' + str(bank_id)", "response": "Returns the URL for getting or setting child relationships for the specified bank_id."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the URL for the bank hierarchy itself", "response": "def hierarchy(self, alias=None):\n        \"\"\"\n        return the URL for the bank hierarchy itself\n        :param alias:\n        :return:\n        \"\"\"\n        if alias:\n            return self._root + self._safe_alias(alias)\n        else:\n            return self._root"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the URL for getting or setting parent relationships for the specified bank_id.", "response": "def parents(self, alias, bank_id):\n        \"\"\"\n        URL for getting or setting parent relationships for the specified bank\n        :param alias:\n        :param bank_id:\n        :return:\n        \"\"\"\n        return self._root + self._safe_alias(alias) + '/parent/ids/' + bank_id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_command(self, command, shell=True, env=None, execute='/bin/bash',\n                    return_code=None):\n        \"\"\"Run a shell command.\n\n        The options available:\n\n            * ``shell`` to be enabled or disabled, which provides the ability\n              to execute arbitrary stings or not. if disabled commands must be\n              in the format of a ``list``\n\n            * ``env`` is an environment override and or manipulation setting\n              which sets environment variables within the locally executed\n              shell.\n\n            * ``execute`` changes the interpreter which is executing the\n              command(s).\n\n            * ``return_code`` defines the return code that the command must\n              have in order to ensure success. This can be a list of return\n              codes if multiple return codes are acceptable.\n\n        :param command: ``str``\n        :param shell: ``bol``\n        :param env: ``dict``\n        :param execute: ``str``\n        :param return_code: ``int``\n        \"\"\"\n        self.log.info('Command: [ %s ]', command)\n\n        if env is None:\n            env = os.environ\n\n        if self.debug is False:\n            stdout = open(os.devnull, 'wb')\n        else:\n            stdout = subprocess.PIPE\n\n        if return_code is None:\n            return_code = [0]\n\n        stderr = subprocess.PIPE\n        process = subprocess.Popen(\n            command,\n            stdout=stdout,\n            stderr=stderr,\n            executable=execute,\n            env=env,\n            shell=shell\n        )\n\n        output, error = process.communicate()\n\n        if process.returncode not in return_code:\n            self.log.debug('Command Output: %s, Error Msg: %s', output, error)\n            return error, False\n        else:\n            self.log.debug('Command Output: %s', output)\n            return output, True", "response": "Run a command in a specific shell."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mkdir_p(self, path):\n        try:\n            if not os.path.isdir(path):\n                os.makedirs(path)\n                self.log.info('Created Directory [ %s ]', path)\n        except OSError as exc:\n            if exc.errno == errno.EEXIST and os.path.isdir(path):\n                pass\n            else:\n                raise OSError(\n                    'The provided path can not be created into a directory.'\n                )", "response": "Python implementation of mkdir - p <path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite a file. This is useful when writing a file that will fit within memory.", "response": "def write_file(self, filename, content):\n        \"\"\"Write a file.\n\n        This is useful when writing a file that will fit within memory\n\n        :param filename: ``str``\n        :param content: ``str``\n        \"\"\"\n        with open(filename, 'wb') as f:\n            self.log.debug(content)\n            f.write(content)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_file_lines(self, filename, contents):\n        with open(filename, 'wb') as f:\n            self.log.debug(contents)\n            f.writelines(contents)", "response": "Write a file.\n\n        This is useful when writing a file that may not fit within memory.\n\n        :param filename: ``str``\n        :param contents: ``list``"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef md5_checker(self, md5sum, local_file=None, file_object=None):\n        def calc_hash():\n            \"\"\"Read the hash.\n\n            :return data_hash.read():\n            \"\"\"\n            return file_object.read(128 * md5.block_size)\n\n        if (local_file and os.path.isfile(local_file)) is True or file_object:\n            md5 = hashlib.md5()\n\n            if not file_object:\n                file_object = open(local_file, 'rb')\n\n            for chk in iter(calc_hash, b''):\n                if isinstance(chk, bytes):\n                    md5.update(chk)\n                else:\n                    md5.update(chk.encode('utf-8'))\n            else:\n                if not file_object:\n                    file_object.close()\n\n            lmd5sum = md5.hexdigest()\n            msg = 'Hash comparison'\n            try:\n                if md5sum != lmd5sum:\n                    msg = (\n                        '%s - CheckSumm Mis-Match \"%s\" != \"%s\" for [ %s ]' % (\n                            msg, md5sum, lmd5sum, local_file\n                        )\n                    )\n                    raise cloudlib.MD5CheckMismatch(msg)\n                else:\n                    msg = '%s - CheckSumm verified for [ %s ]' % (\n                        msg, local_file\n                    )\n                    return True\n            finally:\n                self.log.debug(msg)", "response": "Return True if the local file and the provided md5sum are equal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_signature(secret, verb, url, nonce, data):\n    # Parse the url so we can remove the base and extract just the path.\n    parsedURL = urllib.parse.urlparse(url)\n    path = parsedURL.path\n    if parsedURL.query:\n        path = path + '?' + parsedURL.query\n\n    # print \"Computing HMAC: %s\" % verb + path + str(nonce) + data\n    message = bytes(verb + path + str(nonce) + data, 'utf-8')\n\n    signature = hmac.new(secret.encode('utf-8'),\n                         message,\n                         digestmod=hashlib.sha256).hexdigest()\n    return signature", "response": "Generate a request signature compatible with BitMEX."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a ticker object. Generated from quote and trade.", "response": "def get_ticker(self):\n        '''Return a ticker object. Generated from quote and trade.'''\n        lastQuote = self.data['quote'][-1]\n        lastTrade = self.data['trade'][-1]\n        ticker = {\n            \"last\": lastTrade['price'],\n            \"buy\": lastQuote['bidPrice'],\n            \"sell\": lastQuote['askPrice'],\n            \"mid\": (float(lastQuote['bidPrice'] or 0) + float(lastQuote['askPrice'] or 0)) / 2\n        }\n\n        # The instrument has a tickSize. Use it to round values.\n        instrument = self.data['instrument'][0]\n        return {k: round(float(v or 0), instrument['tickLog']) for k, v in list(ticker.items())}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconnects to the websocket in a thread.", "response": "def __connect(self, wsURL, symbol):\n        '''Connect to the websocket in a thread.'''\n        self.logger.debug(\"Starting thread\")\n\n        self.ws = websocket.WebSocketApp(wsURL,\n                                         on_message=self.__on_message,\n                                         on_close=self.__on_close,\n                                         on_open=self.__on_open,\n                                         on_error=self.__on_error,\n                                         # We can login using email/pass or API key\n                                         header=self.__get_auth())\n\n        self.wst = threading.Thread(target=lambda: self.ws.run_forever())\n        self.wst.daemon = True\n        self.wst.start()\n        self.logger.debug(\"Started thread\")\n\n        # Wait for connect before continuing\n        conn_timeout = 5\n        while not self.ws.sock or not self.ws.sock.connected and conn_timeout:\n            sleep(1)\n            conn_timeout -= 1\n        if not conn_timeout:\n            self.logger.error(\"Couldn't connect to WS! Exiting.\")\n            self.exit()\n            sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __get_auth(self):\n        '''Return auth headers. Will use API Keys if present in settings.'''\n        if self.api_key == None and self.login == None:\n            self.logger.error(\"No authentication provided! Unable to connect.\")\n            sys.exit(1)\n\n        if self.api_key == None:\n            self.logger.info(\"Authenticating with email/password.\")\n            return [\n                \"email: \" + self.login,\n                \"password: \" + self.password\n            ]\n        else:\n            self.logger.info(\"Authenticating with API Key.\")\n            # To auth to the WS using an API key, we generate a signature of a nonce and\n            # the WS API endpoint.\n            nonce = generate_nonce()\n            return [\n                \"api-nonce: \" + str(nonce),\n                \"api-signature: \" + generate_signature(self.api_secret, 'GET', '/realtime', nonce, ''),\n                \"api-key:\" + self.api_key\n            ]", "response": "Return auth headers. Will use API Keys if present in settings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __push_symbol(self, symbol):\n        '''Ask the websocket for a symbol push. Gets instrument, orderBook, quote, and trade'''\n        self.__send_command(\"getSymbol\", symbol)\n        while not {'instrument', 'trade', 'orderBook25'} <= set(self.data):\n            sleep(0.1)", "response": "Ask the websocket for a symbol push. Gets instrument orderBook quote and trade"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __send_command(self, command, args=[]):\n        '''Send a raw command.'''\n        self.ws.send(json.dumps({\"op\": command, \"args\": args}))", "response": "Send a raw command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __on_message(self, ws, message):\n        '''Handler for parsing WS messages.'''\n        message = json.loads(message)\n        self.logger.debug(json.dumps(message))\n\n        table = message['table'] if 'table' in message else None\n        action = message['action'] if 'action' in message else None\n        try:\n            if 'subscribe' in message:\n                self.logger.debug(\"Subscribed to %s.\" % message['subscribe'])\n            elif action:\n\n                if table not in self.data:\n                    self.data[table] = []\n\n                # There are four possible actions from the WS:\n                # 'partial' - full table image\n                # 'insert'  - new row\n                # 'update'  - update row\n                # 'delete'  - delete row\n                if action == 'partial':\n                    self.logger.debug(\"%s: partial\" % table)\n                    self.data[table] += message['data']\n                    # Keys are communicated on partials to let you know how to uniquely identify\n                    # an item. We use it for updates.\n                    self.keys[table] = message['keys']\n                elif action == 'insert':\n                    self.logger.debug('%s: inserting %s' % (table, message['data']))\n                    self.data[table] += message['data']\n                elif action == 'update':\n                    self.logger.debug('%s: updating %s' % (table, message['data']))\n                    # Locate the item in the collection and update it.\n                    for updateData in message['data']:\n                        item = findItemByKeys(self.keys[table], self.data[table], updateData)\n                        if not item:\n                            return  # No item found to update. Could happen before push\n                        item.update(updateData)\n                        # Remove cancelled / filled orders\n                        if table == 'order' and item['leavesQty'] <= 0:\n                            self.data[table].remove(item)\n                elif action == 'delete':\n                    self.logger.debug('%s: deleting %s' % (table, message['data']))\n                    # Locate the item in the collection and remove it.\n                    for deleteData in message['data']:\n                        item = findItemByKeys(self.keys[table], self.data[table], deleteData)\n                        self.data[table].remove(item)\n                else:\n                    raise Exception(\"Unknown action: %s\" % action)\n        except:\n            self.logger.error(traceback.format_exc())", "response": "Handler for parsing WS messages."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_user_details(self, response):\n\n        account = response['account']\n        metadata = json.loads(account.get('json_metadata') or '{}')\n        account['json_metadata'] = metadata\n\n        return {\n            'id': account['id'],\n            'username': account['name'],\n            'name': metadata.get(\"profile\", {}).get('name', ''),\n            'account': account,\n        }", "response": "Return user details from GitHub account"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef user_data(self, access_token, *args, **kwargs):\n\n        return self.get_json(self.USER_INFO_URL, method=\"POST\", headers=self._get_headers(access_token))", "response": "Loads user data from service"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authenticate_admin(self, transport, account_name, password):\n        Authenticator.authenticate_admin(self, transport, account_name, password)\n\n        auth_token = AuthToken()\n        auth_token.account_name = account_name\n\n        params = {sconstant.E_NAME: account_name,\n                  sconstant.E_PASSWORD: password}\n\n        self.log.debug('Authenticating admin %s' % account_name)\n        try:\n            res = transport.invoke(zconstant.NS_ZIMBRA_ADMIN_URL,\n                                   sconstant.AuthRequest,\n                                   params,\n                                   auth_token)\n        except SoapException as exc:\n            raise AuthException(unicode(exc), exc)\n\n        auth_token.token = res.authToken\n        auth_token.session_id = res.sessionId\n\n        self.log.info('Authenticated admin %s, session id %s'\n                      % (account_name, auth_token.session_id))\n\n        return auth_token", "response": "Authenticates administrator using username and password."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef authenticate(self, transport, account_name, password=None):\n        Authenticator.authenticate(self, transport, account_name, password)\n\n        if password == None:\n            return self.pre_auth(transport, account_name)\n        else:\n            return self.auth(transport, account_name, password)", "response": "Authenticates account using soap method."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nauthenticates using username and password.", "response": "def auth(self, transport, account_name, password):\n        \"\"\"\n        Authenticates using username and password.\n        \"\"\"\n        auth_token = AuthToken()\n        auth_token.account_name = account_name\n\n        attrs = {sconstant.A_BY: sconstant.V_NAME}\n        account = SOAPpy.Types.stringType(data=account_name, attrs=attrs)\n\n        params = {sconstant.E_ACCOUNT: account,\n                  sconstant.E_PASSWORD: password}\n\n        self.log.debug('Authenticating account %s' % account_name)\n        try:\n            res = transport.invoke(zconstant.NS_ZIMBRA_ACC_URL,\n                                   sconstant.AuthRequest,\n                                   params,\n                                   auth_token)\n        except SoapException as exc:\n            raise AuthException(unicode(exc), exc)\n\n        auth_token.token = res.authToken\n        \n        if hasattr(res, 'sessionId'):\n            auth_token.session_id = res.sessionId\n\n        self.log.info('Authenticated account %s, session id %s'\n                      % (account_name, auth_token.session_id))\n\n        return auth_token"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pre_auth(self, transport, account_name):\n        auth_token = AuthToken()\n        auth_token.account_name = account_name\n\n        domain = util.get_domain(account_name)\n        if domain == None:\n            raise AuthException('Invalid auth token account')\n\n        if domain in self.domains:\n            domain_key = self.domains[domain]\n        else:\n            domain_key = None\n\n        if domain_key == None:\n            raise AuthException('Invalid domain key for domain %s' % domain)\n\n        self.log.debug('Initialized domain key for account %s'\n                      % account_name)\n\n        expires = 0\n        timestamp = int(time() * 1000)\n        pak = hmac.new(domain_key, '%s|%s|%s|%s' %\n                       (account_name, sconstant.E_NAME, expires, timestamp),\n                       hashlib.sha1).hexdigest()\n\n        attrs = {sconstant.A_BY: sconstant.V_NAME}\n        account = SOAPpy.Types.stringType(data=account_name, attrs=attrs)\n\n        attrs = {sconstant.A_TIMESTAMP: timestamp, sconstant.A_EXPIRES: expires}\n        preauth = SOAPpy.Types.stringType(data=pak,\n                                          name=sconstant.E_PREAUTH,\n                                          attrs=attrs)\n\n        params = {sconstant.E_ACCOUNT: account,\n                  sconstant.E_PREAUTH: preauth}\n\n        self.log.debug('Authenticating account %s using domain key'\n                       % account_name)\n        try:\n            res = transport.invoke(zconstant.NS_ZIMBRA_ACC_URL,\n                                   sconstant.AuthRequest,\n                                   params,\n                                   auth_token)\n        except SoapException as exc:\n            raise AuthException(unicode(exc), exc)\n\n        auth_token.token = res.authToken\n        auth_token.session_id = res.sessionId\n\n        self.log.info('Authenticated account %s, session id %s'\n                      % (account_name, auth_token.session_id))\n\n        return auth_token", "response": "Authenticates using username and domain key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning true if the preview is set for this record type", "response": "def has_preview(self):\n        \"\"\"stub\"\"\"\n        # I had to add the following check because file record types don't seem to be implemented\n        # correctly for raw edx Question objects\n        if ('fileIds' not in self.my_osid_object._my_map or\n                'preview' not in self.my_osid_object._my_map['fileIds'] or\n                self.my_osid_object._my_map['fileIds']['preview'] is None):\n            return False\n        return bool(self.my_osid_object._my_map['fileIds']['preview'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the preview metadata.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(PDFPreviewFormRecord, self)._init_metadata()\n        self._preview_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'file'),\n            'element_label': 'File',\n            'instructions': 'accepts an Asset Id',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a preview file to the cache", "response": "def add_preview(self, preview_data, file_name):\n        \"\"\"stub\"\"\"\n        label = 'preview'\n        asset_type = PDF_PREVIEW_ASSET_TYPE\n        asset_content_type = PDF_ASSET_CONTENT_GENUS_TYPE\n        self.add_file(preview_data,\n                      label=label,\n                      asset_type=asset_type,\n                      asset_content_type=asset_content_type,\n                      asset_name=file_name,\n                      asset_description='A PDF file with rendered LaTeX.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_preview(self):\n        try:\n            rm = self.my_osid_object._get_provider_manager('REPOSITORY')\n        except AttributeError:\n            rm = self.my_osid_object_form._get_provider_manager('REPOSITORY')\n        try:\n            aas = rm.get_asset_admin_session_for_repository(\n                Id(self.my_osid_object._my_map['assignedBankIds'][0]))\n        except AttributeError:\n            # for update forms\n            aas = rm.get_asset_admin_session_for_repository(\n                Id(self.my_osid_object_form._my_map['assignedBankIds'][0]))\n        if 'preview' not in self.my_osid_object_form._my_map['fileIds']:\n            raise NotFound()\n        aas.delete_asset(\n            Id(self.my_osid_object_form._my_map['fileIds']['preview']['assetId']))\n        del self.my_osid_object_form._my_map['fileIds']['preview']", "response": "clear preview of the current object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the map for the difficulty item.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(SimpleDifficultyItemFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['texts']['difficulty'] = \\\n            self._difficulty_metadata['default_string_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_metadata(self):\n        super(SimpleDifficultyItemFormRecord, self)._init_metadata()\n        self._min_string_length = None\n        self._max_string_length = None\n        self._difficulty_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'text'),\n            'element_label': 'Text',\n            'instructions': 'enter a text string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': self._min_string_length,\n            'maximum_string_length': self._max_string_length,\n            'string_set': []\n        }", "response": "Initialize metadata for the difficulty item form record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the difficulty of the resource", "response": "def set_difficulty(self, difficulty):\n        \"\"\"stub\"\"\"\n        if not is_string(difficulty):\n            raise InvalidArgument('difficulty value must be a string')\n        if difficulty.lower() not in ['low', 'medium', 'hard']:\n            raise InvalidArgument('difficulty value must be low, medium, or hard')\n        self.my_osid_object_form._my_map['texts']['difficulty']['text'] = difficulty"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the map for the source item.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(SourceItemFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['texts']['source'] = \\\n            self._source_metadata['default_string_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_metadata(self):\n        super(SourceItemFormRecord, self)._init_metadata()\n        self._min_string_length = None\n        self._max_string_length = None\n        self._source_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'text'),\n            'element_label': 'Text',\n            'instructions': 'enter a text string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': self._min_string_length,\n            'maximum_string_length': self._max_string_length,\n            'string_set': []\n        }", "response": "Initialize the metadata for the source item form record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the source of the assessment", "response": "def set_source(self, source):\n        \"\"\"stub\"\"\"\n        if not is_string(source):\n            raise InvalidArgument('source value must be a string')\n        self.my_osid_object_form._my_map['texts']['source']['text'] = source"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_published(self):\n        if 'published' not in self.my_osid_object._my_map:\n            return False\n        return bool(self.my_osid_object._my_map['published'])", "response": "is_published - Returns True if the entry is published False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the metadata for the published item", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._published_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'published'),\n            'element_label': 'Published',\n            'instructions': 'flags if item is published or not',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_published_values': [False],\n            'syntax': 'BOOLEAN',\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_published(self, value=None):\n        if value is None:\n            raise NullArgument()\n        if self.get_published_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_boolean(value):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['published'] = value", "response": "set the published flag"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _init_map(self):\n        SimpleDifficultyItemFormRecord._init_map(self)\n        SourceItemFormRecord._init_map(self)\n        PDFPreviewFormRecord._init_map(self)\n        PublishedFormRecord._init_map(self)\n        ProvenanceFormRecord._init_map(self)\n        super(MecQBankBaseMixin, self)._init_map()", "response": "Initialize the map of items to be used by the MecQBank base class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_metadata(self):\n        SimpleDifficultyItemFormRecord._init_metadata(self)\n        SourceItemFormRecord._init_metadata(self)\n        PDFPreviewFormRecord._init_metadata(self)\n        PublishedFormRecord._init_metadata(self)\n        ProvenanceFormRecord._init_metadata(self)\n        super(MecQBankBaseMixin, self)._init_metadata()", "response": "Initialize the metadata for this MecQBankBase."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self):\n        tokens = []\n        for name, spec in ((\"Harpoon\", HarpoonSpec().harpoon_spec), (\"Image\", HarpoonSpec().image_spec)):\n            section = nodes.section()\n            section['names'].append(name)\n            section['ids'].append(name)\n\n            header = nodes.title()\n            header += nodes.Text(name)\n            section.append(header)\n\n            section.extend(self.nodes_for_spec(spec))\n            tokens.append(section)\n\n        return tokens", "response": "For each file in noseOfYeti / specs output nodes to represent each spec file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nodes_for_spec(self, spec):\n        tokens = []\n        if isinstance(spec, sb.create_spec):\n            container = nodes.container(classes=[\"option_spec_option shortline blue-back\"])\n            creates = spec.kls\n            for name, option in sorted(spec.kwargs.items(), key=lambda x: len(x[0])):\n                para = nodes.paragraph(classes=[\"option monospaced\"])\n                para += nodes.Text(\"{0} = \".format(name))\n                self.nodes_for_signature(option, para)\n\n                fields = {}\n                if creates and hasattr(creates, 'fields') and isinstance(creates.fields, dict):\n                    for key, val in creates.fields.items():\n                        if isinstance(key, tuple):\n                            fields[key[0]] = val\n                        else:\n                            fields[key] = val\n\n                txt = fields.get(name) or \"No description\"\n                viewlist = ViewList()\n                for line in dedent(txt).split('\\n'):\n                    viewlist.append(line, name)\n                desc = nodes.section(classes=[\"description monospaced\"])\n                self.state.nested_parse(viewlist, self.content_offset, desc)\n\n                container += para\n                container += desc\n                container.extend(self.nodes_for_spec(option))\n            tokens.append(container)\n        elif isinstance(spec, sb.optional_spec):\n            tokens.extend(self.nodes_for_spec(spec.spec))\n        elif isinstance(spec, sb.container_spec):\n            tokens.extend(self.nodes_for_spec(spec.spec))\n        elif isinstance(spec, sb.dictof):\n            tokens.extend(self.nodes_for_spec(spec.value_spec))\n\n        return tokens", "response": "Determines nodes for an input_algorithms spec"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_log_entry_admin_session_for_log(self, log_id):\n        if not self.supports_log_entry_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.LogEntryAdminSession(log_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the log entry administrative service for the given log."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the logging service.", "response": "def get_logging_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the logging service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.logging.LoggingSession) - a ``LoggingSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_logging()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_logging()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_logging():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LoggingSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the OsidSession associated with the logging service for the given log.", "response": "def get_logging_session_for_log(self, log_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the logging service for the given log.\n\n        arg:    log_id (osid.id.Id): the ``Id`` of the ``Log``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.logging.LoggingSession) - a ``LoggingSession``\n        raise:  NotFound - no ``Log`` found by the given ``Id``\n        raise:  NullArgument - ``log_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_logging()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_logging()`` and ``supports_visible_federation()`` are\n        ``true``*\n\n        \"\"\"\n        if not self.supports_logging():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.LoggingSession(log_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_log_entry_lookup_session(self, proxy):\n        if not self.supports_log_entry_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogEntryLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the logging reading service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_log_entry_lookup_session_for_log(self, log_id, proxy):\n        if not self.supports_log_entry_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.LogEntryLookupSession(log_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the log reading service for the given log."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_log_entry_query_session(self, proxy):\n        if not self.supports_log_entry_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogEntryQuerySession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the logging entry query service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_log_entry_query_session_for_log(self, log_id, proxy):\n        if not self.supports_log_entry_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.LogEntryQuerySession(log_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the log entry query service for the given log."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_log_entry_admin_session(self, proxy):\n        if not self.supports_log_entry_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogEntryAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the logging entry administrative service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_log_entry_log_session(self, proxy):\n        if not self.supports_log_entry_log():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogEntryLogSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the log entry to log mappings."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OsidSession associated with the log entry assignment service.", "response": "def get_log_entry_log_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning log entry to log mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.logging.LogEntryLogAssignmentSession) - a\n                ``LogEntryLogAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_log_entry_log_assignment()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_log_entry_log_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_log_entry_log_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogEntryLogAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the log lookup service.", "response": "def get_log_lookup_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the log lookup service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.logging.LogLookupSession) - a ``LogLookupSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_log_lookup()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_log_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_log_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogLookupSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_log_admin_session(self, proxy):\n        if not self.supports_log_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the log administrative service."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the log hierarchy service.", "response": "def get_log_hierarchy_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the log hierarchy service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.logging.LogHierarchySession) - a\n                ``LogHierarchySession`` for logs\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_log_hierarchy()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_log_hierarchy()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_log_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogHierarchySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_log_hierarchy_design_session(self, proxy):\n        if not self.supports_log_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.LogHierarchyDesignSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the log hierarchy design service."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an option argument to an instantiated parser.", "response": "def _add_opt_argument(self, opt_args, arg_parser):\n        \"\"\"Add an argument to an instantiated parser.\n\n        :param opt_args: ``dict``\n        :param arg_parser: ``object``\n        \"\"\"\n        option_args = opt_args.copy()\n\n        groups = option_args.pop('groups', None)\n        if groups:\n            self._add_group(\n                parser=arg_parser,\n                groups=groups,\n                option_args=option_args\n            )\n\n        exclusive_args = option_args.pop('mutually_exclusive', None)\n        if exclusive_args:\n            self._add_mutually_exclusive_group(\n                parser=arg_parser,\n                groups=exclusive_args,\n                option_args=option_args\n            )\n\n        for k, v in option_args.items():\n            self._add_arg(parser=arg_parser, value_dict=v)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting a container inside the current process.", "response": "def start(client, container, interactive=True, stdout=None, stderr=None, stdin=None, **kwargs):\n    \"\"\"\n    Present the PTY of the container inside the current process.\n\n    This is just a wrapper for PseudoTerminal(client, container).start()\n    \"\"\"\n\n    PseudoTerminal(client, container, interactive=interactive, stdout=stdout, stderr=stderr, stdin=stdin).start(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xml_import(self,\n                   filepath=None,\n                   xml_content=None,\n                   markings=None,\n                   identifier_ns_uri=None,\n                   initialize_importer=True,\n                   **kwargs):\n        \"\"\"\n        Import an OpenIOC indicator xml (root element 'ioc') from file <filepath> or\n        from a string <xml_content>\n\n        You can provide:\n\n        - a list of markings with which all generated Information Objects\n           will be associated (e.g., in order to provide provenance function)\n\n        - The uri of a namespace of the identifiers for the generated information objects.\n          This namespace identifiers the 'owner' of the object. For example, if importing\n          IOCs published by Mandiant (e.g., as part of the APT1 report), chose an namespace\n          such  as 'mandiant.com' or similar (and be consistent about it, when importing\n          other stuff published by Mandiant).\n\n        The kwargs are not read -- they are present to allow the use of the\n        DingoImportCommand class for easy definition of commandline import commands\n        (the class passes all command line arguments to the xml_import function, so\n        without the **kwargs parameter, an error would occur.\n        \"\"\"\n\n\n        if initialize_importer:\n            # Clear state in case xml_import is used several times, but keep namespace info\n            self.__init__()\n\n        # Initialize  default arguments\n\n        # '[]' would be mutable, so we initialize here\n        if not markings:\n            markings = []\n\n        # Initializing here allows us to also get the default namespace when\n        # explicitly passing 'None' as parameter.\n\n        if identifier_ns_uri:\n            self.identifier_ns_uri = identifier_ns_uri\n\n        # Use the generic XML import customized for  OpenIOC import\n        # to turn XML into DingoObjDicts\n\n        import_result =  MantisImporter.xml_import(xml_fname=filepath,\n                                                   xml_content=xml_content,\n                                                   ns_mapping=self.namespace_dict,\n                                                   embedded_predicate=self.openioc_embedding_pred,\n                                                   id_and_revision_extractor=self.id_and_revision_extractor,\n                                                   transformer=self.transformer,\n                                                   keep_attrs_in_created_reference=False,\n                                                   )\n\n\n        # The MANTIS/DINGOS xml importer returns then the following structure::\n        #\n        #\n        #    {'id_and_rev_info': Id and revision info of top-level element of the form\n        #        {'id': ... , 'timestamp': ...}\n        #    'elt_name': Element name of top-level element\n        #    'dict_repr': Dictionary representation of XML, minus the embedded objects -- for\n        #                 those, an 'idref' reference has been generated\n        #    'embedded_objects': List of embedded objects, as dictionary\n        #                       {\"id_and_revision_info\": id and revision info of extracted object,\n        #                        \"elt_name\": Element name,\n        #                        \"dict_repr\" :  dictionary representation of XML of embedded object\n        #                       }\n        #    'unprocessed' : List of unprocessed embedded objects (as libxml2 Node object)\n        #                    (e.g. for handover to other importer\n        #    'file_content': Content of imported file (or, if content was passed instead of a file name,\n        #                                                                                         the original content)}\n\n\n        id_and_rev_info = import_result['id_and_rev_info']\n        elt_name = import_result['elt_name']\n        elt_dict = import_result['dict_repr']\n\n        embedded_objects = import_result['embedded_objects']\n\n        default_ns = self.namespace_dict.get(elt_dict.get('@@ns',None),'http://schemas.mandiant.com/unknown/ioc')\n\n        # Export family information.\n        family_info_dict = search_by_re_list(self.RE_LIST_NS_TYPE_FROM_NS_URL,default_ns)\n        if family_info_dict:\n            self.iobject_family_name=\"%s.mandiant.com\" % family_info_dict['family']\n            self.iobject_family_revision_name=family_info_dict['revision']\n\n\n        # Initialize stack with import_results.\n\n        # First, the result from the top-level import\n        pending_stack = deque()\n\n        pending_stack.append((id_and_rev_info, elt_name,elt_dict))\n\n        # Then the embedded objects\n        while embedded_objects:\n            embedded_object = embedded_objects.pop()\n            id_and_rev_info = embedded_object['id_and_rev_info']\n            elt_name = embedded_object['elt_name']\n            elt_dict = embedded_object['dict_repr']\n            pending_stack.append((id_and_rev_info,elt_name,elt_dict))\n\n        if id_and_rev_info['timestamp']:\n            ts = id_and_rev_info['timestamp']\n        else:\n            ts = self.create_timestamp\n\n        while pending_stack:\n            (id_and_rev_info, elt_name, elt_dict) = pending_stack.pop()\n\n            # Call the importer that turns DingoObjDicts into Information Objects in the database\n            iobject_type_name = elt_name\n            iobject_type_namespace_uri = self.namespace_dict.get(elt_dict.get('@@ns',None),DINGOS_GENERIC_FAMILY_NAME)\n\n            MantisImporter.create_iobject(iobject_family_name = self.iobject_family_name,\n                                          iobject_family_revision_name= self.iobject_family_revision_name,\n                                          iobject_type_name=iobject_type_name,\n                                          iobject_type_namespace_uri=iobject_type_namespace_uri,\n                                          iobject_type_revision_name= '',\n                                          iobject_data=elt_dict,\n                                          uid=id_and_rev_info['id'],\n                                          identifier_ns_uri= self.identifier_ns_uri,\n                                          timestamp = ts,\n                                          create_timestamp = self.create_timestamp,\n                                          markings=markings,\n                                          config_hooks = {'special_ft_handler' : self.fact_handler_list(),\n                                                          'datatype_extractor' : self.datatype_extractor,\n                                                          'attr_ignore_predicate' : self.attr_ignore_predicate},\n                                          namespace_dict=self.namespace_dict,\n                                          )", "response": "This function imports an OpenIOC indicator XML from file <filepath > or xml_content."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef id_and_revision_extractor(self,xml_elt):\n\n        result = {'id':None,\n                  'timestamp': None}\n\n        attributes = extract_attributes(xml_elt,prefix_key_char='@')\n\n        # Extract identifier:\n        if '@id' in attributes:\n            result['id']=attributes['@id']\n\n        # Extract time-stamp\n\n        if '@last-modified' in attributes:\n            naive = parse_datetime(attributes['@last-modified'].strip())\n            if naive:\n                # Make sure that information regarding the timezone is\n                # included in the time stamp. If it is not, we chose\n                # utc as default timezone: if we assume that the same\n                # producer of OpenIOC data always uses the same timezone\n                # for filling in the 'last-modified' attribute, then\n                # this serves the main purpose of time stamps for our\n                # means: we can find out the latest revision of a\n                # given piece of data.\n                if not timezone.is_aware(naive):\n                    aware = timezone.make_aware(naive,timezone.utc)\n                else:\n                    aware = naive\n                result['timestamp']= aware\n\n        return result", "response": "Function for determing an identifier and where applicable a revision and or timestamp for extracted embedded content ; id_and_revision_extractor is called to extract the identifier and timestamp of the embedded content."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef openioc_embedding_pred(self,parent, child, ns_mapping):\n\n        # For openIOC, we extract the Indicator-Item elements,\n        # since those correspond to observables.\n\n        child_attributes = extract_attributes(child,prefix_key_char='')\n\n\n        if ('id' in child_attributes and child.name == 'IndicatorItem'):\n\n            # The embedding predicate is supposed to not only return\n            # 'True' or 'False', but in case there is an embedding,\n            # it should also contain information regarding the type of\n            # object that is embedded. This is used, for example, to\n            # create the DataType  information for the embedding element\n            # (it is a reference to an object of type X).\n\n            # In OpenIOC, The IndicatorItems have the following form::\n            #\n            #      <IndicatorItem id=\"b9ef2559-cc59-4463-81d9-52800545e16e\" condition=\"contains\">\n            #          <Context document=\"FileItem\" search=\"FileItem/PEInfo/Sections/Section/Name\" type=\"mir\"/>\n            #          <Content type=\"string\">.stub</Content>\n            #      </IndicatorItem>\n            #\n            # We take the 'document' attribute of the 'Context' element as object type\n            # of the embedded object (as we shall see below, upon import, we rewrite\n            # the IndicatorItem such that it corresponds to the 'fact_term = value' structure\n            # used for STIX/CybOX data.\n\n            grandchild = child.children\n            type_info = None\n\n            while grandchild is not None:\n                if grandchild.name == 'Context':\n                    context_attributes = extract_attributes(grandchild,prefix_key_char='')\n                    if 'document' in context_attributes:\n                        type_info = context_attributes['document']\n                    break\n                grandchild = grandchild.next\n\n            if type_info:\n                return type_info\n            else:\n                return True\n        else:\n            return False", "response": "Predicate for recognizing inlined content in an XML object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reference_handler(self,iobject, fact, attr_info, add_fact_kargs):\n\n        (namespace_uri,uid) = (self.identifier_ns_uri,attr_info['idref'])\n\n\n        # We are always able to extract the timestamp from the referencing node, because for OpenIOC,\n        # all references are created by DINGO's generic import, and the import writes the timestamp\n        # information into the created reference.\n\n        timestamp = attr_info['@timestamp']\n\n        # The following either retrieves an already existing object of given ID and timestamp\n        # or creates a placeholder object.\n\n        (target_mantis_obj, existed) = MantisImporter.create_iobject(\n            uid=uid,\n            identifier_ns_uri=namespace_uri,\n            timestamp=timestamp)\n\n        logger.debug(\"Creation of Placeholder for %s %s returned %s\" % (namespace_uri,uid,existed))\n\n        # What remains to be done is to write the reference to the created placeholder object\n\n        add_fact_kargs['value_iobject_id'] = Identifier.objects.get(uid=uid,namespace__uri=namespace_uri)\n\n        # Handlers have to return 'True', otherwise the fact will not be created.\n\n        return True", "response": "This function creates a reference to a fact."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef synthesize_firmware_module_info(modules, module_types):\n    res = {}\n    for mod_id, mod_info in modules.items():\n        mod_info = dict(mod_info)\n        mod_type = module_types[mod_info[\"type\"]]\n        # Directly copy any fields only defined on the type\n        if \"repository\" in mod_type:\n            mod_info[\"repository\"] = mod_type[\"repository\"]\n        mod_info[\"header_file\"] = mod_type[\"header_file\"]\n        mod_info[\"class_name\"] = mod_type[\"class_name\"]\n        if \"dependencies\" in mod_type:\n            mod_info[\"dependencies\"] = mod_type[\"dependencies\"]\n        if \"status_codes\" in mod_type:\n            mod_info[\"status_codes\"] = mod_type[\"status_codes\"]\n        # Update the arguments\n        mod_info[\"arguments\"] = process_args(\n            mod_id, mod_info.get(\"arguments\", []), \n            mod_type.get(\"arguments\", [])\n        )\n        # Update the categories\n        if not \"categories\" in mod_info:\n            mod_info[\"categories\"] = mod_type.get(\n                \"categories\", all_categories\n            )\n        # Update the inputs\n        mod_inputs = mod_info.get(\"inputs\", {})\n        for input_name, type_input_info in mod_type.get(\"inputs\", {}).items():\n            mod_input_info = dict(type_input_info)\n            mod_input_info.update(mod_inputs.get(input_name, {}))\n            mod_input_info[\"variable\"] = mod_input_info.get(\n                \"variable\", input_name\n            )\n            mod_input_info[\"categories\"] = mod_input_info.get(\n                \"categories\", [ACTUATORS]\n            )\n            mod_inputs[input_name] = mod_input_info\n        mod_info[\"inputs\"] = mod_inputs\n        # Update the outputs\n        mod_outputs = mod_info.get(\"outputs\", {})\n        for output_name, type_output_info in mod_type.get(\"outputs\", {}).items():\n            mod_output_info = dict(type_output_info)\n            mod_output_info.update(mod_outputs.get(output_name, {}))\n            mod_output_info[\"variable\"] = mod_output_info.get(\n                \"variable\", output_name\n            )\n            mod_output_info[\"categories\"] = mod_output_info.get(\n                \"categories\", [SENSORS]\n            )\n            mod_outputs[output_name] = mod_output_info\n        mod_info[\"outputs\"] = mod_outputs\n        res[mod_id] = mod_info\n    return res", "response": "Synthesizes the firmware module information for a single node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_args(mod_id, args, type_args):\n    res = list(args)\n    if len(args) > len(type_args):\n        raise ValueError(\n            'Too many arguments specified for module \"{}\" (Got {}, expected '\n            '{})'.format(mod_id, len(args), len(type_args))\n        )\n    for i in range(len(args), len(type_args)):\n        arg_info = type_args[i]\n        if \"default\" in arg_info:\n            args.append(arg_info[\"default\"])\n        else:\n            raise ValueError(\n                'Not enough module arguments supplied for module \"{}\" (Got '\n                '{}, expecting {})'.format(\n                    mod_id, len(args), len(type_args)\n                )\n            )\n    return args", "response": "Takes as input a list of arguments defined on a module and the information\n    about the required arguments defined on the corresponding module type and returns a list of the required arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake as input a dictionary of parameters defined on a module and the type_params dictionary that contains the required parameters of the module.", "response": "def process_params(mod_id, params, type_params):\n    \"\"\"\n    Takes as input a dictionary of parameters defined on a module and the\n    information about the required parameters defined on the corresponding\n    module type. Validatates that are required parameters were supplied and\n    fills any missing parameters with their default values from the module\n    type. Returns a nested dictionary of the same format as the `type_params`\n    but with an additional key `value` on each inner dictionary that gives the\n    value of that parameter for this specific module\n    \"\"\"\n    res = {}\n    for param_name, param_info in type_params.items():\n        val = params.get(param_name, param_info.get(\"default\", None))\n        # Check against explicit None (param could be explicitly False)\n        if val is not None:\n            param_res = dict(param_info)\n            param_res[\"value\"] = val\n            res[param_name] = param_res\n        elif type_params.get(\"required\", False):\n            raise ValueError(\n                'Required parameter \"{}\" is not defined for module '\n                '\"{}\"'.format(param_name, mod_id)\n            )\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dedupe_by(things, key=None):\n    if not key:\n        key = hash\n    index = {key(thing): thing for thing in things}\n    return index.values()", "response": "Given an iterator of things and a key generation function returns a new iterator of the deduped things."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_dir_name_from_url(url):\n    url_path = urlparse(url).path\n    head, tail = os.path.split(url_path)\n    # If tail happens to be empty as in case `/foo/`, use foo.\n    # If we are looking at a valid but ugly path such as\n    # `/foo/.git`, use the \"foo\" not the \".git\".\n    if len(tail) is 0 or tail[0] is \".\":\n        head, tail = os.path.split(head)\n    dir_name, ext = os.path.splitext(tail)\n    return dir_name", "response": "This function attempts to emulate something like Git s humanish directory naming for clone. It s probably not a perfect facimile but it s close."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a string representing a variable return a new string that is safe for C ++ codegen.", "response": "def safe_cpp_var(s):\n    \"\"\"\n    Given a string representing a variable, return a new string that is safe\n    for C++ codegen. If string is already safe, will leave it alone.\n    \"\"\"\n    s = str(s)\n    # Remove non-word, non-space characters\n    s = re.sub(r\"[^\\w\\s]\", '', s)\n    # Replace spaces with _\n    s = re.sub(r\"\\s+\", '_', s)\n    # Prefix with underscore if what is left is a reserved word\n    s = \"_\" + s if s in CPP_KEYWORDS or s[0].isdigit() else s\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nnormalise a stringified Boolean to a proper Python Boolean.", "response": "def booleanise(b):\n    \"\"\"Normalise a 'stringified' Boolean to a proper Python Boolean.\n\n    ElasticSearch has a habit of returning \"true\" and \"false\" in its \n    JSON responses when it should be returning `true` and `false`.  If \n    `b` looks like a stringified Boolean true, return True.  If `b` \n    looks like a stringified Boolean false, return False.\n\n    If we don't know what `b` is supposed to represent, return it back \n    to the caller.\n\n    \"\"\"\n    s = str(b)\n    if s.lower() == \"true\":\n        return True\n    if s.lower() == \"false\":\n        return False\n\n    return b"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreduce a large number of bytes down to a humanised SI equivalent and return the result as a string with trailing unit abbreviation.", "response": "def fmt_bytes(bytes, precision=2):\n    \"\"\"Reduce a large number of `bytes` down to a humanised SI \n    equivalent and return the result as a string with trailing unit \n    abbreviation.\n\n    \"\"\"\n    UNITS = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB']\n\n    if bytes == 0:\n        return '0 bytes'\n\n    log = math.floor(math.log(bytes, 1000))\n\n    return \"%.*f %s\" % (precision,\n                       bytes / math.pow(1000, log),\n                       UNITS[int(log)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary showing the position of the translog. disable_flush", "response": "def get_index_translog_disable_flush(self):\n        \"\"\"Return a dictionary showing the position of the \n        'translog.disable_flush' knob for each index in the cluster.\n\n        The dictionary will look like this:\n\n            {\n                \"index1\": True,      # Autoflushing DISABLED\n                \"index2\": False,     # Autoflushing ENABLED\n                \"index3\": \"unknown\", # Using default setting (probably enabled)\n                ...\n            }\n\n        \"\"\"\n        disabled = {}\n        settings = self.get('/_settings')\n        setting_getters = [\n            lambda s: s['index.translog.disable_flush'],\n            lambda s: s['index']['translog']['disable_flush']]\n        for idx in settings:\n            idx_settings = settings[idx]['settings']\n            for getter in setting_getters:\n                try:\n                    disabled[idx] = booleanise(getter(idx_settings))\n                except KeyError as e:\n                    pass\n            if not idx in disabled:\n                disabled[idx] = 'unknown'\n        return disabled"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a simplified one - word answer to the question whether automatic shard allocator has been disabled for this cluster?", "response": "def allocator_disabled(self):\n        \"\"\"Return a simplified one-word answer to the question, 'Has the \n        automatic shard allocator been disabled for this cluster?'\n\n        The answer will be one of \"disabled\" (yes), \"enabled\" (no), or \n        \"unknown\".\n\n        \"\"\"\n        state = \"unknown\"\n        setting_getters = [\n            lambda s: s['cluster.routing.allocation.disable_allocation'],\n            lambda s: s['cluster']['routing']['allocation']['disable_allocation']]\n        settings = self.get('/_cluster/settings')\n        for i in ['persistent', 'transient']:\n            for getter in setting_getters:\n                try:\n                    v = booleanise(getter(settings[i]))\n                    if v == True:\n                        state = \"disabled\"\n                    elif v == False:\n                        state = \"enabled\"\n                except KeyError:\n                    pass\n        return state"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a simplified one - word answer to the question Has automatic transaction log flushing been disabled on all indexes in the cluster?", "response": "def flushing_disabled(self):\n        \"\"\"Return a simplified one-word answer to the question, 'Has \n        automatic transaction log flushing been disabled on all indexes in \n        the cluster?'\n\n        The answer will be one of \"disabled\" (yes, on all), \"enabled\" (no, \n        on all), \"some\" (yes, only on some), or \"unknown\".\n\n        \"\"\"\n        states = self.get_index_translog_disable_flush().values()\n        if not states:\n            return \"unknown\"\n        if all(s == True for s in states):\n            return \"disabled\"\n        if all(s == False for s in states):\n            return \"enabled\"\n        if any(s == False for s in states):\n            return \"some\"\n        return \"unknown\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of tuples where each tuple contains the i - th element from each of the argument sequences.", "response": "def nontruncating_zip(*seqs):\n        \"\"\"Return a list of tuples, where each tuple contains the i-th \n        element from each of the argument sequences.\n\n        The returned list is as long as the longest argument sequence.  \n        Shorter argument sequences will be represented in the output as \n        None padding elements:\n\n            nontruncating_zip([1, 2, 3], ['a', 'b'])\n            -> [(1, 'a'), (2, 'b'), (3, None)]\n\n        \"\"\"\n        n_seqs = len(seqs)\n\n        tups = []\n        idx = 0\n        while True:\n            empties = 0\n            tup = []\n            for seq in seqs:\n                try:\n                    tup.append(seq[idx])\n                except IndexError:\n                    empties += 1\n                    tup.append(None)\n            if empties == n_seqs:\n                break\n            tup = tuple(tup)\n            tups.append(tup)\n            idx += 1\n\n        return tups"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert datetime objects to dictionaries for storage", "response": "def clean_up_datetime(obj_map):\n    \"\"\"convert datetime objects to dictionaries for storage\"\"\"\n    clean_map = {}\n    for key, value in obj_map.items():\n        if isinstance(value, datetime.datetime):\n            clean_map[key] = {\n                'year': value.year,\n                'month': value.month,\n                'day': value.day,\n                'hour': value.hour,\n                'minute': value.minute,\n                'second': value.second,\n                'microsecond': value.microsecond,\n                'tzinfo': value.tzinfo\n            }\n        elif isinstance(value, dict):\n            clean_map[key] = clean_up_datetime(value)\n        elif isinstance(value, list):\n            if key not in clean_map:\n                clean_map[key] = []\n            if len(value) > 0:\n                for index, list_value in enumerate(value):\n                    if isinstance(list_value, dict):\n                        clean_map[key].append(clean_up_datetime(list_value))\n                    else:\n                        clean_map[key].append(list_value)\n            else:\n                clean_map[key] = value\n        else:\n            clean_map[key] = value\n    return clean_map"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert dictionary representations of datetime to datetime obj", "response": "def convert_dict_to_datetime(obj_map):\n    \"\"\"converts dictionary representations of datetime back to datetime obj\"\"\"\n    converted_map = {}\n    for key, value in obj_map.items():\n        if isinstance(value, dict) and 'tzinfo' in value.keys():\n            converted_map[key] = datetime.datetime(**value)\n        elif isinstance(value, dict):\n            converted_map[key] = convert_dict_to_datetime(value)\n        elif isinstance(value, list):\n            updated_list = []\n            for internal_item in value:\n                if isinstance(internal_item, dict):\n                    updated_list.append(convert_dict_to_datetime(internal_item))\n                else:\n                    updated_list.append(internal_item)\n            converted_map[key] = updated_list\n        else:\n            converted_map[key] = value\n    return converted_map"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert_ids_to_object_ids(obj_map):\n    converted_map = {}\n    for key, value in obj_map.items():\n        if key == '_id':\n            # hacky, but using alias sends back the whole ID string, like\n            #   assessment.Item%3A5758326b4a40452d6eee1fa1%40ODL.MIT.EDU\n            # so we have to preserve it\n            try:\n                converted_map[key] = ObjectId(value)\n            except InvalidId:\n                converted_map[key] = value\n        elif isinstance(value, dict):\n            converted_map[key] = convert_ids_to_object_ids(value)\n        elif isinstance(value, list):\n            new_list = []\n            for internal_item in value:\n                if isinstance(internal_item, dict):\n                    new_list.append(convert_ids_to_object_ids(internal_item))\n                else:\n                    new_list.append(internal_item)\n            converted_map[key] = new_list\n        else:\n            converted_map[key] = value\n    return converted_map", "response": "converts string representations of _id back to ObjectId obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fix_reserved_word(word, is_module=False):\n    if is_module:\n        if word == 'logging':\n            word = 'logging_'  # Still deciding this\n    else:\n        if keyword.iskeyword(word):\n            word += '_'\n        elif word in ['id', 'type', 'str', 'max', 'input', 'license', 'copyright', 'credits', 'help']:\n            word += '_'\n    return word", "response": "Fixes reserved words in the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_provider_manager(osid, runtime=None, proxy=None, local=False):\n    if runtime is not None:\n        if local:\n            parameter_id = Id('parameter:localImpl@json')\n        else:\n            parameter_id = Id('parameter:' + osid.lower() + 'ProviderImpl@json')\n        try:\n            # Try to get the manager from the runtime, if available:\n            config = runtime.get_configuration()\n            impl_name = config.get_value_by_parameter(parameter_id).get_string_value()\n            if proxy is None:\n                return runtime.get_manager(osid, impl_name)\n            else:\n                return runtime.get_proxy_manager(osid, impl_name)\n        except (AttributeError, KeyError, NotFound):\n            pass\n    # Try to return a Manager directly from this implementation, or raise OperationFailed:\n    try:\n        if proxy is None:\n            mgr_str = 'Manager'\n        else:\n            mgr_str = 'ProxyManager'\n        module = import_module(\n            'dlkit.json_.' + fix_reserved_word(osid.lower(), is_module=True) + '.managers')\n        manager_name = ''.join((osid.title()).split('_')) + mgr_str\n        manager = getattr(module, manager_name)()\n    except (ImportError, AttributeError):\n        raise OperationFailed()\n    if runtime is not None:\n        manager.initialize(runtime)\n    return manager", "response": "Gets the most appropriate provider manager based on the config."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a record registry given an entry and runtime", "response": "def get_registry(entry, runtime):\n    \"\"\"Returns a record registry given an entry and runtime\"\"\"\n    try:\n        records_location_param_id = Id('parameter:recordsRegistry@mongo')\n        registry = runtime.get_configuration().get_value_by_parameter(\n            records_location_param_id).get_string_value()\n        return import_module(registry).__dict__.get(entry, {})\n    except (ImportError, AttributeError, KeyError, NotFound):\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_authenticated_with_proxy(proxy):\n    if proxy is None:\n        return False\n    elif proxy.has_authentication():\n        return proxy.get_authentication().is_valid()\n    else:\n        return False", "response": "Checks whether a user is authenticated with a Proxy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a Proxy returns the Id of the effective Agent", "response": "def get_effective_agent_id_with_proxy(proxy):\n    \"\"\"Given a Proxy, returns the Id of the effective Agent\"\"\"\n    if is_authenticated_with_proxy(proxy):\n        if proxy.has_effective_agent():\n            return proxy.get_effective_agent_id()\n        else:\n            return proxy.get_authentication().get_agent_id()\n    else:\n        return Id(\n            identifier='MC3GUE$T@MIT.EDU',\n            namespace='authentication.Agent',\n            authority='MIT-ODL')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the Locale object for a given Proxy", "response": "def get_locale_with_proxy(proxy):\n    \"\"\"Given a Proxy, returns the Locale\n\n    This assumes that instantiating a dlkit.mongo.locale.objects.Locale\n    without constructor arguments wlll return the default Locale.\n\n    \"\"\"\n    from .locale.objects import Locale\n    if proxy is not None:\n            locale = proxy.get_locale()\n            if locale is not None:\n                return locale\n    return Locale()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_catalog_id_to_object_id_string(catalog_id):\n\n    if not isinstance(catalog_id, Id):\n        raise TypeError('input needs to be an Id')\n    seed_str = catalog_id.get_identifier() + catalog_id.get_authority() + '000000000000'\n    try:\n        seed_str = str.encode(seed_str[:12])\n    except TypeError:\n        # sometimes unicode is returned, in which case Python 2 can't handle it\n        seed_str = seed_str[:12]\n    seed_str = binascii.hexlify(seed_str)\n    try:\n        # python 3\n        seed_str = str(seed_str, 'utf8')\n    except TypeError:\n        # python 2\n        seed_str = str(seed_str)\n    return seed_str", "response": "Convert a catalogId into an object id string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new container with the specified options.", "response": "def create(name, config_file=None, template=None, backing_store=None, template_options=None):\r\n    '''\r\n    Create a new container\r\n    raises ContainerAlreadyExists exception if the container name is reserved already.\r\n    \r\n    :param template_options: Options passed to the specified template\r\n    :type template_options: list or None\r\n    \r\n    '''\r\n    if exists(name):\r\n        raise ContainerAlreadyExists(\"The Container %s is already created!\" % name)\r\n    cmd = 'lxc-create -n %s' % name\r\n\r\n    if config_file:\r\n        cmd += ' -f %s' % config_file\r\n    if template:\r\n        cmd += ' -t %s' % template\r\n    if backing_store:\r\n        cmd += ' -B %s' % backing_store\r\n    if template_options:\r\n        cmd += '-- %s' % template_options\r\n\r\n    if subprocess.check_call('%s >> /dev/null' % cmd, shell=True) == 0:\r\n        if not exists(name):\r\n            _logger.critical(\"The Container %s doesn't seem to be created! (options: %s)\", name, cmd[3:])\r\n            raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n\r\n        _logger.info(\"Container %s has been created with options %s\", name, cmd[3:])\r\n        return 0\r\n    else:\r\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dict of all available log files.", "response": "def all_as_dict():\r\n    '''\r\n    returns a dict {'Running': ['cont1', 'cont2'], \r\n                    'Stopped': ['cont3', 'cont4']\r\n                    }\r\n                    \r\n    '''\r\n    cmd = ['lxc-list']\r\n    out = subprocess.check_output(cmd).splitlines()\r\n    stopped = []\r\n    running = []\r\n    frozen = []\r\n    current = None\r\n    for c in out:\r\n        c = c.strip()\r\n        if c == 'RUNNING':\r\n            current = running\r\n            continue\r\n        if c == 'STOPPED':\r\n            current = stopped\r\n            continue\r\n        if c == 'FROZEN':\r\n            current = frozen\r\n            continue\r\n        if not len(c):\r\n            continue\r\n        current.append(c)\r\n    return {'Running': running,\r\n            'Stopped': stopped,\r\n            'Frozen': frozen}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all the containers in the system", "response": "def all_as_list():\r\n    '''\r\n    returns a list of all defined containers\r\n    '''\r\n    as_dict = all_as_dict()\r\n    containers = as_dict['Running'] + as_dict['Frozen'] + as_dict['Stopped'] \r\n    containers_list = []\r\n    for i in containers:\r\n        i = i.replace(' (auto)', '')\r\n        containers_list.append(i)\r\n    return containers_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts a container in daemon mode", "response": "def start(name, config_file=None):\r\n    '''\r\n    starts a container in daemon mode\r\n    '''\r\n    if not exists(name):\r\n        raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n    if name in running():\r\n        raise ContainerAlreadyRunning('The container %s is already started!' % name)\r\n    cmd = ['lxc-start', '-n', name, '-d']\r\n    if config_file:\r\n        cmd += ['-f', config_file]\r\n    subprocess.check_call(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a kill signal to process 1 of the container name", "response": "def kill(name, signal):\r\n    '''\r\n    sends a kill signal to process 1 of ths container <name>\r\n    :param signal: numeric signal\r\n    '''\r\n    if not exists(name):\r\n        raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n    cmd = ['lxc-kill', '--name=%s' % name, signal]\r\n    subprocess.check_call(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef destroy(name):\r\n    '''\r\n    removes a container [stops a container if it's running and]\r\n    raises ContainerNotExists exception if the specified name is not created\r\n    '''\r\n    if not exists(name):\r\n        raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n    cmd = ['lxc-destroy', '-f', '-n', name]\r\n    subprocess.check_call(cmd)", "response": "removes a container [stops a container if it's running and]\r\n    raises ContainerNotExists exception if the specified name is not created"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmonitoring actions on the specified container.", "response": "def monitor(name, callback):\r\n    '''\r\n    monitors actions on the specified container,\r\n    callback is a function to be called on \r\n    '''\r\n    global _monitor \r\n    if not exists(name):\r\n        raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n    if _monitor:\r\n        if _monitor.is_monitored(name):\r\n            raise Exception(\"You are already monitoring this container (%s)\" % name)\r\n    else:\r\n        _monitor = _LXCMonitor()\r\n        logging.info(\"Starting LXC Monitor\")\r\n        _monitor.start()\r\n        def kill_handler(sg, fr):\r\n            stop_monitor()\r\n        signal.signal(signal.SIGTERM, kill_handler)\r\n        signal.signal(signal.SIGINT, kill_handler)\r\n    _monitor.add_monitor(name, callback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef freeze(name):\r\n    '''\r\n    freezes the container\r\n    '''\r\n    if not exists(name):\r\n        raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n    cmd = ['lxc-freeze', '-n', name]\r\n    subprocess.check_call(cmd)", "response": "Freeze the specified container"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unfreeze(name):\r\n    '''\r\n    unfreezes the container\r\n    '''\r\n    if not exists(name):\r\n        raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n    cmd = ['lxc-unfreeze', '-n', name]\r\n    subprocess.check_call(cmd)", "response": "Unfreezes the container with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef info(name):\r\n    '''\r\n    returns info dict about the specified container\r\n    '''\r\n    if not exists(name):\r\n        raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n    cmd = ['lxc-info', '-n', name]\r\n    out = subprocess.check_output(cmd).splitlines()\r\n    info = {}\r\n    for line in out:\r\n        k, v = line.split()\r\n        info[k] = v\r\n    return info", "response": "Returns info dict about the specified container"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the output of lxc - checkconfig", "response": "def checkconfig():\r\n    '''\r\n    returns the output of lxc-checkconfig\r\n    '''\r\n    cmd = ['lxc-checkconfig']\r\n    return subprocess.check_output(cmd).replace('[1;32m', '').replace('[1;33m', '').replace('[0;39m', '').replace('[1;32m', '').replace(' \u001b', '').split('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting the callback function with no parameters when the container reaches the specified state", "response": "def notify(name, states, callback):\r\n    '''\r\n    executes the callback function with no parameters when the container reaches the specified state or states\r\n    states can be or-ed or and-ed\r\n        notify('test', 'STOPPED', letmeknow)\r\n        \r\n        notify('test', 'STOPPED|RUNNING', letmeknow)\r\n    '''\r\n    if not exists(name):\r\n        raise ContainerNotExists(\"The container (%s) does not exist!\" % name)\r\n\r\n    cmd = ['lxc-wait', '-n', name, '-s', states]\r\n    def th():\r\n        subprocess.check_call(cmd)\r\n        callback()\r\n    _logger.info(\"Waiting on states %s for container %s\", states, name)\r\n    threading.Thread(target=th).start()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_grade_mdata():\n    return {\n        'output_score': {\n            'element_label': {\n                'text': 'output score',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a decimal value.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': [],\n        },\n        'grade_system': {\n            'element_label': {\n                'text': 'grade system',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'input_score_end_range': {\n            'element_label': {\n                'text': 'input score end range',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a decimal value.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': [],\n        },\n        'input_score_start_range': {\n            'element_label': {\n                'text': 'input score start range',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a decimal value.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': [],\n        },\n    }", "response": "Return default mdata map for Grade"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn default mdata map for GradeSystem", "response": "def get_grade_system_mdata():\n    \"\"\"Return default mdata map for GradeSystem\"\"\"\n    return {\n        'numeric_score_increment': {\n            'element_label': {\n                'text': 'numeric score increment',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a decimal value.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': [],\n        },\n        'lowest_numeric_score': {\n            'element_label': {\n                'text': 'lowest numeric score',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a decimal value.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': [],\n        },\n        'based_on_grades': {\n            'element_label': {\n                'text': 'based on grades',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'highest_numeric_score': {\n            'element_label': {\n                'text': 'highest numeric score',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a decimal value.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn default mdata map for GradeEntry", "response": "def get_grade_entry_mdata():\n    \"\"\"Return default mdata map for GradeEntry\"\"\"\n    return {\n        'resource': {\n            'element_label': {\n                'text': 'resource',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'grade': {\n            'element_label': {\n                'text': 'grade',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'ignored_for_calculations': {\n            'element_label': {\n                'text': 'ignored for calculations',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'score': {\n            'element_label': {\n                'text': 'score',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a decimal value.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_decimal_values': [None],\n            'syntax': 'DECIMAL',\n            'decimal_scale': None,\n            'minimum_decimal': None,\n            'maximum_decimal': None,\n            'decimal_set': [],\n        },\n        'gradebook_column': {\n            'element_label': {\n                'text': 'gradebook column',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_gradebook_column_mdata():\n    return {\n        'grade_system': {\n            'element_label': {\n                'text': 'grade system',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for GradebookColumn"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gradebook_column_summary_mdata():\n    return {\n        'gradebook_column': {\n            'element_label': {\n                'text': 'gradebook column',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for GradebookColumnSummary"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding die to Roll.", "response": "def add_die(self, die, count=1):\n        '''Add ``Die`` to Roll.\n        :param die: Die instance\n        :param count: number of times die is rolled\n        '''\n        for x in range(count):\n            self._dice.append(die)\n        self._odds = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_die(self, die):\n        '''Remove ``Die`` (first matching) from Roll.\n        :param die: Die instance\n        '''\n        if die in self._dice:\n            self._dice.remove(die)", "response": "Removes die from Roll. _dice."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef roll(self, count=0, func=sum):\n        '''Roll some dice!\n        :param count: [0] Return list of sums\n        :param func: [sum] Apply func to list of individual die rolls func([])\n        :return: A single sum or list of ``count`` sums\n        '''\n        if count:\n            return [func([die.roll() for die in self._dice]) for x in range(0, count)]\n        else:\n            return func([die.roll() for die in self._dice])", "response": "Roll some dice!\n        :param count: [0] Return list of sums\n        :param func: [sum] Apply func to list of individual die rolls func([])\n        :return: A single sum or list of ``count`` sums"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over number dice rolls.", "response": "def x_rolls(self, number, count=0, func=sum):\n        '''Iterator of number dice rolls.\n        :param count: [0] Return list of ``count`` sums\n        :param func: [sum] Apply func to list of individual die rolls func([])\n        '''\n        for x in range(number):\n            yield self.roll(count, func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iter(self, count=0, func=sum):\n        '''Iterator of infinite dice rolls.\n        :param count: [0] Return list of ``count`` sums\n        :param func: [sum] Apply func to list of individual die rolls func([])\n        '''\n        while True:\n            yield self.roll(count, func)", "response": "Iterate over the dice rolls."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the absolute probability of all posible rolls.", "response": "def _calc_odds(self):\n        '''Calculates the absolute probability of all posible rolls.'''\n        def recur(val, h, dice, combinations):\n            for pip in dice[0]:\n                tot = val + pip\n                if len(dice) > 1:\n                    combinations = recur(tot, h, dice[1:], combinations)\n                else:\n                    combinations += 1\n                    h[tot] = h.get(tot, 0) + 1\n            return combinations\n        if self.summable:\n            start = 0\n        else:\n            start = ''\n        h = dict()\n        funky = [d.values for d in self._dice]\n        # count of possible results of rolling dice\n        combinations = recur(start, h, funky, 0.0)\n        self._odds = [(roll, h[roll], h[roll] / combinations) for roll in h.keys()]\n        self._odds.sort()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef roll(self, count=0):\n        '''Roll some dice!\n        :param count: [0] Return list of sums\n        :return: A single sum or list of ``count`` sums\n        '''\n        return super(FuncRoll, self).roll(count, self._func)", "response": "Roll some dice!\n        :param count: [0] Return list of sums\n        :return: A single sum or list of ``count`` sums"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef x_rolls(self, number, count=0):\n        '''Iterator of number dice rolls.\n        :param count: [0] Return list of ``count`` sums\n        '''\n        for x in range(number):\n            yield super(FuncRoll, self).roll(count, self._func)", "response": "Iterator of number dice rolls."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter(self, count=0):\n        '''Iterator of infinite dice rolls.\n        :param count: [0] Return list of ``count`` sums\n        '''\n        while True:\n            yield super(FuncRoll, self).roll(count, self._func)", "response": "Iterate over infinite dice rolls."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_resource(self, resource_id):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(resource_id, 'resource').get_identifier())},\n                 **self._view_filter()))\n        return objects.Resource(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the Resource specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a list of resources corresponding to the given IdList.", "response": "def get_resources_by_ids(self, resource_ids):\n        \"\"\"Gets a ``ResourceList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the resources\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Resources`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set.\n\n        arg:    resource_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n        return: (osid.resource.ResourceList) - the returned ``Resource``\n                list\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``resource_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in resource_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'resource').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.ResourceList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_resources_by_genus_type(self, resource_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(resource_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.ResourceList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a ResourceList corresponding to the given resource genus Type which does not include resources of types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all Resources in the resource lookup session.", "response": "def get_resources(self):\n        \"\"\"Gets all ``Resources``.\n\n        In plenary mode, the returned list contains all known resources\n        or an error results. Otherwise, the returned list may contain\n        only those resources that are accessible through this session.\n\n        return: (osid.resource.ResourceList) - a list of ``Resources``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.ResourceList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a list of Resources matching the given resource query.", "response": "def get_resources_by_query(self, resource_query):\n        \"\"\"Gets a list of ``Resources`` matching the given resource query.\n\n        arg:    resource_query (osid.resource.ResourceQuery): the\n                resource query\n        return: (osid.resource.ResourceList) - the returned\n                ``ResourceList``\n        raise:  NullArgument - ``resource_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``resource_query`` is not of this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in resource_query._query_terms:\n            if '$in' in resource_query._query_terms[term] and '$nin' in resource_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': resource_query._query_terms[term]['$in']}},\n                             {term: {'$nin': resource_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: resource_query._query_terms[term]})\n        for term in resource_query._keyword_terms:\n            or_list.append({term: resource_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('resource',\n                                             collection='Resource',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.ResourceList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the search results matching the given search query.", "response": "def get_resources_by_search(self, resource_query, resource_search):\n        \"\"\"Gets the search results matching the given search query using the given search.\n\n        arg:    resource_query (osid.resource.ResourceQuery): the\n                resource query\n        arg:    resource_search (osid.resource.ResourceSearch): the\n                resource search\n        return: (osid.resource.ResourceSearchResults) - the resource\n                search results\n        raise:  NullArgument - ``resource_query`` or ``resource_search``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``resource_query`` or ``resource_search``\n                is not of this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        # Copied from osid.resource.ResourceQuerySession.get_resources_by_query_template\n        and_list = list()\n        or_list = list()\n        for term in resource_query._query_terms:\n            and_list.append({term: resource_query._query_terms[term]})\n        for term in resource_query._keyword_terms:\n            or_list.append({term: resource_query._keyword_terms[term]})\n        if resource_search._id_list is not None:\n            identifiers = [ObjectId(i.identifier) for i in resource_search._id_list]\n            and_list.append({'_id': {'$in': identifiers}})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        if resource_search.start is not None and resource_search.end is not None:\n            result = collection.find(query_terms)[resource_search.start:resource_search.end]\n        else:\n            result = collection.find(query_terms)\n        return searches.ResourceSearchResults(result, dict(resource_query._query_terms), runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the resource form for creating new resources.", "response": "def get_resource_form_for_create(self, resource_record_types):\n        \"\"\"Gets the resource form for creating new resources.\n\n        A new form should be requested for each create transaction.\n\n        arg:    resource_record_types (osid.type.Type[]): array of\n                resource record types\n        return: (osid.resource.ResourceForm) - the resource form\n        raise:  NullArgument - ``resource_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form with requested record\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in resource_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if resource_record_types == []:\n            obj_form = objects.ResourceForm(\n                bin_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.ResourceForm(\n                bin_id=self._catalog_id,\n                record_types=resource_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new resource.", "response": "def create_resource(self, resource_form):\n        \"\"\"Creates a new ``Resource``.\n\n        arg:    resource_form (osid.resource.ResourceForm): the form for\n                this ``Resource``\n        return: (osid.resource.Resource) - the new ``Resource``\n        raise:  IllegalState - ``resource_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``resource_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``resource_form`` did not originate from\n                ``get_resource_form_for_create()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        if not isinstance(resource_form, ABCResourceForm):\n            raise errors.InvalidArgument('argument type is not an ResourceForm')\n        if resource_form.is_for_update():\n            raise errors.InvalidArgument('the ResourceForm is for update only, not create')\n        try:\n            if self._forms[resource_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('resource_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('resource_form did not originate from this session')\n        if not resource_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(resource_form._my_map)\n\n        self._forms[resource_form.get_id().get_identifier()] = CREATED\n        result = objects.Resource(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_resource(self, resource_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        if not isinstance(resource_form, ABCResourceForm):\n            raise errors.InvalidArgument('argument type is not an ResourceForm')\n        if not resource_form.is_for_update():\n            raise errors.InvalidArgument('the ResourceForm is for update only, not create')\n        try:\n            if self._forms[resource_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('resource_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('resource_form did not originate from this session')\n        if not resource_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(resource_form._my_map)\n\n        self._forms[resource_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Resource(\n            osid_object_map=resource_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Updates an existing resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete a resource from the database.", "response": "def delete_resource(self, resource_id):\n        \"\"\"Deletes a ``Resource``.\n\n        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n                to remove\n        raise:  NotFound - ``resource_id`` not found\n        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        if not isinstance(resource_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        resource_map = collection.find_one(\n            dict({'_id': ObjectId(resource_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.Resource(osid_object_map=resource_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(resource_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alias_resource(self, resource_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=resource_id, equivalent_id=alias_id)", "response": "Adds an Id to a resource in the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_for_deleted_resource(self, resource_id):\n        # Implemented from template for\n        # osid.resource.ResourceNotificationSession.register_for_deleted_resource\n        if not MONGO_LISTENER.receivers[self._ns][self._receiver]['d']:\n            MONGO_LISTENER.receivers[self._ns][self._receiver]['d'] = []\n        if isinstance(MONGO_LISTENER.receivers[self._ns][self._receiver]['d'], list):\n            MONGO_LISTENER.receivers[self._ns][self._receiver]['d'].append(resource_id.get_identifier())", "response": "Registers for notification of a deleted resource."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_resource_ids_by_bin(self, bin_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for resource in self.get_resources_by_bin(bin_id):\n            id_list.append(resource.get_id())\n        return IdList(id_list)", "response": "Gets the list of Resource Id s associated with a Bin."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_resources_by_bin(self, bin_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('RESOURCE', local=True)\n        lookup_session = mgr.get_resource_lookup_session_for_bin(bin_id, proxy=self._proxy)\n        lookup_session.use_isolated_bin_view()\n        return lookup_session.get_resources()", "response": "Gets the list of Resources associated with a Bin."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_resource_ids_by_bins(self, bin_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for resource in self.get_resources_by_bins(bin_ids):\n            id_list.append(resource.get_id())\n        return IdList(id_list)", "response": "Gets the list of Resource Ids corresponding to a list of Bin objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_resources_by_bins(self, bin_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        resource_list = []\n        for bin_id in bin_ids:\n            resource_list += list(\n                self.get_resources_by_bin(bin_id))\n        return objects.ResourceList(resource_list)", "response": "Gets the list of Resources corresponding to a list of Bins."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the list of Bin Ids mapped to a Resource.", "response": "def get_bin_ids_by_resource(self, resource_id):\n        \"\"\"Gets the list of ``Bin``  ``Ids`` mapped to a ``Resource``.\n\n        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n        return: (osid.id.IdList) - list of bin ``Ids``\n        raise:  NotFound - ``resource_id`` is not found\n        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('RESOURCE', local=True)\n        lookup_session = mgr.get_resource_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_bin_view()\n        resource = lookup_session.get_resource(resource_id)\n        id_list = []\n        for idstr in resource._my_map['assignedBinIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the list of Bin objects mapped to a Resource.", "response": "def get_bins_by_resource(self, resource_id):\n        \"\"\"Gets the list of ``Bin`` objects mapped to a ``Resource``.\n\n        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n        return: (osid.resource.BinList) - list of bins\n        raise:  NotFound - ``resource_id`` is not found\n        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('RESOURCE', local=True)\n        lookup_session = mgr.get_bin_lookup_session(proxy=self._proxy)\n        return lookup_session.get_bins_by_ids(\n            self.get_bin_ids_by_resource(resource_id))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of bin ids including and under the given bin node in which any resource can be assigned.", "response": "def get_assignable_bin_ids(self, bin_id):\n        \"\"\"Gets a list of bins including and under the given bin node in which any resource can be assigned.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of the ``Bin``\n        return: (osid.id.IdList) - list of assignable bin ``Ids``\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.get_assignable_bin_ids\n        # This will likely be overridden by an authorization adapter\n        mgr = self._get_provider_manager('RESOURCE', local=True)\n        lookup_session = mgr.get_bin_lookup_session(proxy=self._proxy)\n        bins = lookup_session.get_bins()\n        id_list = []\n        for bin in bins:\n            id_list.append(bin.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assign_resource_to_bin(self, resource_id, bin_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('RESOURCE', local=True)\n        lookup_session = mgr.get_bin_lookup_session(proxy=self._proxy)\n        lookup_session.get_bin(bin_id)  # to raise NotFound\n        self._assign_object_to_catalog(resource_id, bin_id)", "response": "Adds an existing Resource to a Bin."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unassign_resource_from_bin(self, resource_id, bin_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('RESOURCE', local=True)\n        lookup_session = mgr.get_bin_lookup_session(proxy=self._proxy)\n        lookup_session.get_bin(bin_id)  # to raise NotFound\n        self._unassign_object_from_catalog(resource_id, bin_id)", "response": "Removes a Resource from a Bin."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_resource_by_agent(self, agent_id):\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'agentIds': {'$in': [str(agent_id)]}},\n                 **self._view_filter()))\n        return objects.Resource(\n            osid_object_map=result,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Gets the Resource associated with the given agent."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the list of Agent Id s mapped to a Resource.", "response": "def get_agent_ids_by_resource(self, resource_id):\n        \"\"\"Gets the list of ``Agent``  ``Ids`` mapped to a ``Resource``.\n\n        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n        return: (osid.id.IdList) - list of agent ``Ids``\n        raise:  NotFound - ``resource_id`` is not found\n        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        resource = collection.find_one(\n            dict({'_id': ObjectId(resource_id.get_identifier())},\n                 **self._view_filter()))\n        if 'agentIds' not in resource:\n            result = IdList([])\n        else:\n            result = IdList(resource['agentIds'])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_agents_by_resource(self, resource_id):\n        agent_list = []\n        for agent_id in self.get_agent_ids_by_resource(resource_id):\n            agent_list.append(Agent(agent_id))\n        return AgentList(agent_list)", "response": "Gets the list of Agents mapped to a Resource."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assign_agent_to_resource(self, agent_id, resource_id):\n        # Should check for existence of Agent? We may mever manage them.\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        resource = collection.find_one({'_id': ObjectId(resource_id.get_identifier())})\n\n        try:\n            ResourceAgentSession(\n                self._catalog_id, self._proxy, self._runtime).get_resource_by_agent(agent_id)\n        except errors.NotFound:\n            pass\n        else:\n            raise errors.AlreadyExists()\n        if 'agentIds' not in resource:\n            resource['agentIds'] = [str(agent_id)]\n        else:\n            resource['agentIds'].append(str(agent_id))\n        collection.save(resource)", "response": "Adds an existing Agent to a Resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unassign_agent_from_resource(self, agent_id, resource_id):\n        collection = JSONClientValidated('resource',\n                                         collection='Resource',\n                                         runtime=self._runtime)\n        resource = collection.find_one({'_id': ObjectId(resource_id.get_identifier())})\n\n        try:\n            resource['agentIds'].remove(str(agent_id))\n        except (KeyError, ValueError):\n            raise errors.NotFound('agent_id not assigned to resource')\n        collection.save(resource)", "response": "Removes an Agent from a Resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_bins_by_query(self, bin_query):\n        # Implemented from template for\n        # osid.resource.BinQuerySession.get_bins_by_query_template\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalogs_by_query(bin_query)\n        query_terms = dict(bin_query._query_terms)\n        collection = JSONClientValidated('resource',\n                                         collection='Bin',\n                                         runtime=self._runtime)\n        result = collection.find(query_terms).sort('_id', DESCENDING)\n\n        return objects.BinList(result, runtime=self._runtime)", "response": "Gets a list of Bins matching the given bin query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if this user can create a single Bin using the desired record types.", "response": "def can_create_bin_with_record_types(self, bin_record_types):\n        \"\"\"Tests if this user can create a single ``Bin`` using the desired record types.\n\n        While ``ResourceManager.getBinRecordTypes()`` can be used to\n        examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Bin``.\n        Providing an empty array tests if a ``Bin`` can be created with\n        no records.\n\n        arg:    bin_record_types (osid.type.Type[]): array of bin record\n                types\n        return: (boolean) - ``true`` if ``Bin`` creation using the\n                specified ``Types`` is supported, ``false`` otherwise\n        raise:  NullArgument - ``bin_record_types`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=bin_record_types)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_bin(self, bin_form):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=bin_form)\n        collection = JSONClientValidated('resource',\n                                         collection='Bin',\n                                         runtime=self._runtime)\n        if not isinstance(bin_form, ABCBinForm):\n            raise errors.InvalidArgument('argument type is not an BinForm')\n        if not bin_form.is_for_update():\n            raise errors.InvalidArgument('the BinForm is for update only, not create')\n        try:\n            if self._forms[bin_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('bin_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('bin_form did not originate from this session')\n        if not bin_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(bin_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[bin_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Bin(osid_object_map=bin_form._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Updates an existing bin."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef alias_bin(self, bin_id, alias_id):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=bin_id, alias_id=alias_id)\n        self._alias_id(primary_id=bin_id, equivalent_id=alias_id)", "response": "Adds an Id to a Bin for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the root bins in the bin hierarchy.", "response": "def get_root_bins(self):\n        \"\"\"Gets the root bins in the bin hierarchy.\n\n        A node with no parents is an orphan. While all bin ``Ids`` are\n        known to the hierarchy, an orphan does not appear in the\n        hierarchy unless explicitly added as a root node or child of\n        another node.\n\n        return: (osid.resource.BinList) - the root bins\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return BinLookupSession(\n            self._proxy,\n            self._runtime).get_bins_by_ids(list(self.get_root_bin_ids()))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef has_parent_bins(self, bin_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=bin_id)\n        return self._hierarchy_session.has_parents(id_=bin_id)", "response": "Tests if the bin has any parents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_parent_of_bin(self, id_, bin_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=bin_id)\n        return self._hierarchy_session.is_parent(id_=bin_id, parent_id=id_)", "response": "Tests if an Id is a direct parent of a bin."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the parent Ids of the given bin.", "response": "def get_parent_bin_ids(self, bin_id):\n        \"\"\"Gets the parent ``Ids`` of the given bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of a bin\n        return: (osid.id.IdList) - the parent ``Ids`` of the bin\n        raise:  NotFound - ``bin_id`` is not found\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=bin_id)\n        return self._hierarchy_session.get_parents(id_=bin_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the parents of the given bin.", "response": "def get_parent_bins(self, bin_id):\n        \"\"\"Gets the parents of the given bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` to query\n        return: (osid.resource.BinList) - the parents of the bin\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=bin_id)\n        return BinLookupSession(\n            self._proxy,\n            self._runtime).get_bins_by_ids(\n                list(self.get_parent_bin_ids(bin_id)))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_ancestor_of_bin(self, id_, bin_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=bin_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=bin_id)", "response": "Tests if an Id is an ancestor of a bin."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if a bin has any children.", "response": "def has_child_bins(self, bin_id):\n        \"\"\"Tests if a bin has any children.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of a bin\n        return: (boolean) - ``true`` if the ``bin_id`` has children,\n                ``false`` otherwise\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=bin_id)\n        return self._hierarchy_session.has_children(id_=bin_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_child_of_bin(self, id_, bin_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=bin_id)\n        return self._hierarchy_session.is_child(id_=bin_id, child_id=id_)", "response": "Tests if a bin is a direct child of another."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the child Ids of the given bin.", "response": "def get_child_bin_ids(self, bin_id):\n        \"\"\"Gets the child ``Ids`` of the given bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` to query\n        return: (osid.id.IdList) - the children of the bin\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=bin_id)\n        return self._hierarchy_session.get_children(id_=bin_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_child_bins(self, bin_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=bin_id)\n        return BinLookupSession(\n            self._proxy,\n            self._runtime).get_bins_by_ids(\n                list(self.get_child_bin_ids(bin_id)))", "response": "Gets the children of the given bin."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if an Id is a descendant of a bin.", "response": "def is_descendant_of_bin(self, id_, bin_id):\n        \"\"\"Tests if an ``Id`` is a descendant of a bin.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    bin_id (osid.id.Id): the ``Id`` of a bin\n        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``bin_id,``  ``false`` otherwise\n        raise:  NotFound - ``bin_id`` is not found\n        raise:  NullArgument - ``id`` or ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` is not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=bin_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=bin_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a portion of the hierarchy for the given bin.", "response": "def get_bin_nodes(self, bin_id, ancestor_levels, descendant_levels, include_siblings):\n        \"\"\"Gets a portion of the hierarchy for the given bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n        return: (osid.resource.BinNode) - a bin node\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.BinNode(self.get_bin_node_ids(\n            bin_id=bin_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a root bin.", "response": "def add_root_bin(self, bin_id):\n        \"\"\"Adds a root bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of a bin\n        raise:  AlreadyExists - ``bin_id`` is already in hierarchy\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=bin_id)\n        return self._hierarchy_session.add_root(id_=bin_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a root bin.", "response": "def remove_root_bin(self, bin_id):\n        \"\"\"Removes a root bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of a bin\n        raise:  NotFound - ``bin_id`` not a root\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=bin_id)\n        return self._hierarchy_session.remove_root(id_=bin_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a child to a bin.", "response": "def add_child_bin(self, bin_id, child_id):\n        \"\"\"Adds a child to a bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of a bin\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``bin_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``bin_id`` or ``child_id`` not found\n        raise:  NullArgument - ``bin_id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=bin_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=bin_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_child_bin(self, bin_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=bin_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=bin_id, child_id=child_id)", "response": "Removes a child from a bin."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving all children from a bin.", "response": "def remove_child_bins(self, bin_id):\n        \"\"\"Removes all children from a bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of a bin\n        raise:  NotFound - ``bin_id`` not in hierarchy\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalogs(catalog_id=bin_id)\n        return self._hierarchy_session.remove_children(id_=bin_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self):\n        try:\n            self.connection = telnetlib.Telnet(self.host, self.port, timeout=self.timeout)\n        except Exception:\n            log_traceback()\n            return False\n        return True", "response": "Connect to CasparCG Server"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending an AMCP command to the server and return the result.", "response": "def query(self, query, **kwargs):\n        \"\"\"Send AMCP command\"\"\"\n        if not self.connection:\n            if not self.connect():\n                return CasparResponse(500, \"Unable to connect CasparCG server\")\n\n        query = query.strip()\n        if kwargs.get(\"verbose\", True):\n            if not query.startswith(\"INFO\"):\n                logging.debug(\"Executing AMCP: {}\".format(query))\n        query += \"\\r\\n\"\n\n        if PYTHON_VERSION >= 3:\n            query = bytes(query.encode(\"utf-8\"))\n            delim = bytes(\"\\r\\n\".encode(\"utf-8\"))\n        else:\n            delim = \"\\r\\n\"\n\n        try:\n            self.connection.write(query)\n            result = self.connection.read_until(delim).strip()\n        except Exception:\n            log_traceback()\n            return CasparResponse(500, \"Query failed\")\n\n        if PYTHON_VERSION >= 3:\n            result = result.decode(\"UTF-8\")\n\n        if not result:\n            return CasparResponse(500, \"No result\")\n\n        try:\n            if result[0:3] == \"202\":\n                return CasparResponse(202, \"No result\")\n\n            elif result[0:3] in [\"201\", \"200\"]:\n                stat = int(result[0:3])\n                result = decode_if_py3(self.connection.read_until(delim)).strip()\n                return CasparResponse(stat, result)\n\n            elif int(result[0:1]) > 3:\n                stat = int(result[0:3])\n                return CasparResponse(stat, result)\n        except Exception:\n            log_traceback()\n            return CasparResponse(500, \"Malformed result: {}\".format(result))\n        return CasparResponse(500, \"Unexpected result: {}\".format(result))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        orm['avocado.DataConcept'].objects.filter(name='Sample')\\\n                .update(queryable=False)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef backwards(self, orm):\n        \"Write your backwards methods here.\"\n        orm['avocado.DataConcept'].objects.filter(name='Sample')\\\n                .update(queryable=True)", "response": "Write your backwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn dictionary representation of type.", "response": "def get_type_data(self, name):\n        \"\"\"Return dictionary representation of type.\"\"\"\n        try:\n            return {\n                'authority': 'DLKIT.MIT.EDU',\n                'namespace': 'NoneType',\n                'identifier': name,\n                'domain': 'Generic Types',\n                'display_name': self.none_types[name] + ' Type',\n                'display_label': self.none_types[name],\n                'description': ('The ' + self.none_types[name] +\n                                ' Type. This type indicates that no type is specified.')\n            }\n        except IndexError:\n            raise NotFound('NoneType: ' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_type_data(self, name):\n        try:\n            return {\n                'authority': 'DLKIT.MIT.EDU',\n                'namespace': 'GenusType',\n                'identifier': name,\n                'domain': 'Generic Types',\n                'display_name': self.generic_types[name] + ' Generic Type',\n                'display_label': self.generic_types[name],\n                'description': ('The ' + self.generic_types[name] +\n                                ' Type. This type has no symantic meaning.')\n            }\n        except IndexError:\n            raise NotFound('GenusType: ' + name)", "response": "Return dictionary representation of type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_type_data(self, name):\n        try:\n            return {\n                'authority': 'DLKIT',\n                'namespace': 'relationship.Relationship',\n                'identifier': name.lower(),\n                'domain': 'Generic Types',\n                'display_name': name.title() + ' Type',\n                'display_label': name.title(),\n                'description': ('The ' + name.title() + ' Type.')\n            }\n        except IndexError:\n            raise NotFound('RelationshipType: ' + name.title())", "response": "Return dictionary representation of type."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naverages of the values", "response": "def average(arr):\n  \"\"\"average of the values, must have more than 0 entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: average\n  :rtype: float\n\n  \"\"\"\n  if len(arr) == 0:\n    sys.stderr.write(\"ERROR: no content in array to take average\\n\")\n    sys.exit()\n  if len(arr) == 1:  return arr[0]\n  return float(sum(arr))/float(len(arr))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef median(arr):\n  if len(arr) == 0:\n    sys.stderr.write(\"ERROR: no content in array to take average\\n\")\n    sys.exit()\n  if len(arr) == 1: return arr[0]\n  quot = len(arr)/2\n  rem = len(arr)%2\n  if rem != 0:\n    return sorted(arr)[quot]\n  return float(sum(sorted(arr)[quot-1:quot+1]))/float(2)", "response": "median of the values in a list of numbers"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_uuid4(instr):\n  v = instr.strip().replace('-','').lower()\n  if len(v) != 32: return False\n  if not re.match('^[0-9a-f]+$',v): return False\n  if v[12] != '4': return False\n  if not re.match('[89ab]',v[16]): return False\n  return True", "response": "A validator to confirm a string is indeed a UUID4 format"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _set_objective_bank_view(self, session):\n        if self._objective_bank_view == COMPARATIVE:\n            try:\n                session.use_comparative_objective_bank_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_objective_bank_view()\n            except AttributeError:\n                pass", "response": "Sets the underlying objective_bank view to match current view"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider ObjectiveObjectiveBankSession. use_comparative_objective_bank_view", "response": "def use_comparative_objective_bank_view(self):\n        \"\"\"Pass through to provider ObjectiveObjectiveBankSession.use_comparative_objective_bank_view\"\"\"\n        self._objective_bank_view = COMPARATIVE\n        # self._get_provider_session('objective_objective_bank_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_objective_bank_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_plenary_objective_bank_view(self):\n        self._objective_bank_view = PLENARY\n        # self._get_provider_session('objective_objective_bank_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_objective_bank_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider ObjectiveObjectiveBankSession. use_plenary_objective_bank_view"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npasses through to provider ActivityObjectiveBankSession. get_objective_banks_by_activity", "response": "def get_objective_banks_by_activity(self, *args, **kwargs):\n        \"\"\"Pass through to provider ActivityObjectiveBankSession.get_objective_banks_by_activity\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        catalogs = self._get_provider_session('activity_objective_bank_session').get_objective_banks_by_activity(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(ObjectiveBank(self._provider_manager, cat, self._runtime, self._proxy))\n        return ObjectiveBankList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npasses through to provider ObjectiveBankLookupSession. get_objective_banks", "response": "def get_objective_banks(self):\n        \"\"\"Pass through to provider ObjectiveBankLookupSession.get_objective_banks\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('objective_bank_lookup_session').get_objective_banks()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(ObjectiveBank(self._provider_manager, cat, self._runtime, self._proxy))\n        return ObjectiveBankList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npasses through to provider ObjectiveBankAdminSession. create_objective_bank", "response": "def create_objective_bank(self, *args, **kwargs):\n        \"\"\"Pass through to provider ObjectiveBankAdminSession.create_objective_bank\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.create_bin\n        return ObjectiveBank(\n            self._provider_manager,\n            self._get_provider_session('objective_bank_admin_session').create_objective_bank(*args, **kwargs),\n            self._runtime,\n            self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider ObjectiveBankAdminSession. get_objective_bank_form_for_update", "response": "def get_objective_bank_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider ObjectiveBankAdminSession.get_objective_bank_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'objective_bank_record_types' in kwargs:\n            return self.get_objective_bank_form_for_create(*args, **kwargs)\n        else:\n            return self.get_objective_bank_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_objective_bank(self, objective_bank_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if objective_bank_form.is_for_update():\n            return self.update_objective_bank(objective_bank_form, *args, **kwargs)\n        else:\n            return self.create_objective_bank(objective_bank_form, *args, **kwargs)", "response": "Pass through to provider ObjectiveBankAdminSession. update_objective_bank"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the underlying objective_bank view to match current view", "response": "def _set_objective_bank_view(self, session):\n        \"\"\"Sets the underlying objective_bank view to match current view\"\"\"\n        if self._objective_bank_view == FEDERATED:\n            try:\n                session.use_federated_objective_bank_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_objective_bank_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef use_comparative_objective_view(self):\n        self._object_views['objective'] = COMPARATIVE\n        # self._get_provider_session('objective_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_objective_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider ObjectiveLookupSession. use_comparative_objective_view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npassing through to provider ObjectiveLookupSession. use_plenary_objective_view", "response": "def use_plenary_objective_view(self):\n        \"\"\"Pass through to provider ObjectiveLookupSession.use_plenary_objective_view\"\"\"\n        self._object_views['objective'] = PLENARY\n        # self._get_provider_session('objective_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_objective_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef use_federated_objective_bank_view(self):\n        self._objective_bank_view = FEDERATED\n        # self._get_provider_session('objective_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_federated_objective_bank_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider ObjectiveLookupSession. use_federated_objective_bank_view"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass through to provider ObjectiveLookupSession. use_isolated_objective_bank_view", "response": "def use_isolated_objective_bank_view(self):\n        \"\"\"Pass through to provider ObjectiveLookupSession.use_isolated_objective_bank_view\"\"\"\n        self._objective_bank_view = ISOLATED\n        # self._get_provider_session('objective_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_isolated_objective_bank_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider ObjectiveAdminSession. get_objective_form_for_update", "response": "def get_objective_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider ObjectiveAdminSession.get_objective_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'objective_record_types' in kwargs:\n            return self.get_objective_form_for_create(*args, **kwargs)\n        else:\n            return self.get_objective_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_objective(self, objective_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if objective_form.is_for_update():\n            return self.update_objective(objective_form, *args, **kwargs)\n        else:\n            return self.create_objective(objective_form, *args, **kwargs)", "response": "Pass through to provider ObjectiveAdminSession. update_objective"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef use_comparative_activity_view(self):\n        self._object_views['activity'] = COMPARATIVE\n        # self._get_provider_session('activity_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_activity_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider ActivityLookupSession. use_comparative_activity_view"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef use_plenary_activity_view(self):\n        self._object_views['activity'] = PLENARY\n        # self._get_provider_session('activity_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_activity_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider ActivityLookupSession. use_plenary_activity_view"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_activity_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'activity_record_types' in kwargs:\n            return self.get_activity_form_for_create(*args, **kwargs)\n        else:\n            return self.get_activity_form_for_update(*args, **kwargs)", "response": "Pass through to provider ActivityAdminSession. get_activity_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider ActivityAdminSession. update_activity", "response": "def save_activity(self, activity_form, *args, **kwargs):\n        \"\"\"Pass through to provider ActivityAdminSession.update_activity\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if activity_form.is_for_update():\n            return self.update_activity(activity_form, *args, **kwargs)\n        else:\n            return self.create_activity(activity_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider ProficiencyLookupSession. use_comparative_proficiency_view", "response": "def use_comparative_proficiency_view(self):\n        \"\"\"Pass through to provider ProficiencyLookupSession.use_comparative_proficiency_view\"\"\"\n        self._object_views['proficiency'] = COMPARATIVE\n        # self._get_provider_session('proficiency_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_proficiency_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_plenary_proficiency_view(self):\n        self._object_views['proficiency'] = PLENARY\n        # self._get_provider_session('proficiency_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_proficiency_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider ProficiencyLookupSession. use_plenary_proficiency_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npasses through to provider ProficiencyAdminSession. get_proficiency_form_for_update", "response": "def get_proficiency_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider ProficiencyAdminSession.get_proficiency_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'proficiency_record_types' in kwargs:\n            return self.get_proficiency_form_for_create(*args, **kwargs)\n        else:\n            return self.get_proficiency_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npassing through to provider ProficiencyAdminSession. update_proficiency", "response": "def save_proficiency(self, proficiency_form, *args, **kwargs):\n        \"\"\"Pass through to provider ProficiencyAdminSession.update_proficiency\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if proficiency_form.is_for_update():\n            return self.update_proficiency(proficiency_form, *args, **kwargs)\n        else:\n            return self.create_proficiency(proficiency_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assets(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.AssetList(self._results, runtime=self._runtime)", "response": "Gets the asset list resulting from a search."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the composition list resulting from a search.", "response": "def get_compositions(self):\n        \"\"\"Gets the composition list resulting from a search.\n\n        return: (osid.repository.CompositionList) - the composition list\n        raise:  IllegalState - the list has already been retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.CompositionList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_repositories(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.RepositoryList(self._results, runtime=self._runtime)", "response": "Gets the repository list resulting from the search."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes this object as an OsidObject", "response": "def _init_object(self, catalog_id, proxy, runtime, cat_name, cat_class):\n        \"\"\"Initialize this object as an OsidObject....do we need this??\n        From the Mongo learning impl, but seems unnecessary for Handcar\"\"\"\n        self._catalog_identifier = None\n        self._init_proxy_and_runtime(proxy, runtime)\n        self._catalog = cat_class(self._my_catalog_map)\n        self._catalog._authority = self._authority  # there should be a better way...\n        self._catalog_id = self._catalog.get_id()\n        self._forms = dict()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntesting if an agent is authenticated to this session.", "response": "def is_authenticated(self):\n        \"\"\"Tests if an agent is authenticated to this session.\n\n        return: (boolean) - true if valid authentication credentials\n                exist, false otherwise\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if self._proxy is None:\n            return False\n        elif self._proxy.has_authentication():\n            return self._proxy.get_authentication().is_valid()\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the Id of the effective agent in use by this session.", "response": "def get_effective_agent_id(self):\n        \"\"\"Gets the Id of the effective agent in use by this session.\n        If is_authenticated() is true, then the effective agent may be\n        the same as the agent returned by get_authenticated_agent(). If\n        is_authenticated() is false, then the effective agent may be a\n        default agent used for authorization by an unknwon or anonymous\n        user.\n        return: (osid.id.Id) - the effective agent\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if self.is_authenticated():\n            return self._proxy.get_authentication().get_agent_id()\n        elif self._proxy is not None and self._proxy.has_effective_agent():\n            return self._proxy.get_effective_agent_id()\n        else:\n            return Id(identifier='MC3GUE$T@MIT.EDU',\n                      namespace='osid.agent.Agent',\n                      authority='MIT-OEIT')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the effective agent in use by this session.", "response": "def get_effective_agent(self):\n        \"\"\"Gets the effective agent in use by this session.\n        If is_authenticated() is true, then the effective agent may be\n        the same as the agent returned by get_authenticated_agent(). If\n        is_authenticated() is false, then the effective agent may be a\n        default agent used for authorization by an unknwon or anonymous\n        user.\n        return: (osid.authentication.Agent) - the effective agent\n        raise:  OperationFailed - unable to complete request\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if self._proxy is not None and self._proxy.has_authentication():\n            return self._proxy.get_authentication().get_agent()\n        elif self._proxy is not None and self._proxy.has_effective_agent():\n            return Agent(identifier=self._proxy.get_effective_agent_id().get_identifier(),\n                         namespace=self._proxy.get_effective_agent_id().get_namespace(),\n                         authority=self._proxy.get_effective_agent_id().get_authority())\n        else:\n            return Agent(identifier='MC3GUE$T@MIT.EDU',\n                         namespace='osid.agent.Agent',\n                         authority='MIT-OEIT')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if this user can perform Asset lookups.", "response": "def can_lookup_assets(self):\n        \"\"\"Tests if this user can perform ``Asset`` lookups.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations.\n\n        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``\n\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['assetHints']['canLookup']"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the Asset specified by its Id.", "response": "def get_asset(self, asset_id=None):\n        \"\"\"Gets the ``Asset`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Asset`` may have a different\n        ``Id`` than requested, such as the case where a duplicate ``Id``\n        was assigned to an ``Asset`` and retained for compatibility.\n\n        :param asset_id: the ``Id`` of the ``Asset`` to retrieve\n        :type asset_id: ``osid.id.Id``\n        :return: the returned ``Asset``\n        :rtype: ``osid.repository.Asset``\n        :raise: ``NotFound`` -- no ``Asset`` found with the given ``Id``\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if asset_id is None:\n            raise NullArgument()\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr,\n                                 asset_id=asset_id)\n        return objects.Asset(self._get_request(url_path))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget an asset list corresponding to the given IdList.", "response": "def get_assets_by_ids(self, asset_ids=None):\n        \"\"\"Gets an ``AssetList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the assets\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Assets`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set.\n\n        :param asset_ids: the list of ``Ids`` to retrieve\n        :type asset_ids: ``osid.id.IdList``\n        :return: the returned ``Asset list``\n        :rtype: ``osid.repository.AssetList``\n        :raise: ``NotFound`` -- an ``Id`` was not found\n        :raise: ``NullArgument`` -- ``asset_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if asset_ids is None:\n            raise NullArgument()\n        assets = []\n        for i in asset_ids:\n            asset = None\n            url_path = construct_url('assets',\n                                     bank_id=self._catalog_idstr,\n                                     asset_id=i)\n            try:\n                asset = self._get_request(url_path)\n            except (NotFound, OperationFailed):\n                if self._objective_view == PLENARY:\n                    raise\n                else:\n                    pass\n            if asset:\n                if not (self._asset_view == COMPARATIVE and\n                        asset in assets):\n                    assets.append(asset)\n        return objects.AssetList(assets)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_assets_by_genus_type(self, asset_genus_type=None):\n        if asset_genus_type is None:\n            raise NullArgument()\n        url_path = construct_url('assets_by_genus',\n                                 bank_id=self._catalog_idstr,\n                                 genus_type=asset_genus_type.get_identifier())\n        return objects.AssetList(self._get_request(url_path))", "response": "Gets an asset list corresponding to the given asset genus Type which does not have assets of types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_assets(self):\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr)\n        return objects.AssetList(self._get_request(url_path))", "response": "Gets all Assets in plenary mode."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if this user can create Assets.", "response": "def can_create_assets(self):\n        \"\"\"Tests if this user can create ``Assets``.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating an ``Asset``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer create\n        operations to an unauthorized user.\n\n        :return: ``false`` if ``Asset`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``\n\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['assetHints']['canCreate']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_asset_form_for_create(self, asset_record_types=None):\n        if asset_record_types is None:\n            pass  # Still need to deal with the record_types argument\n        asset_form = objects.AssetForm()\n        self._forms[asset_form.get_id().get_identifier()] = not CREATED\n        return asset_form", "response": "Gets the asset form for creating new assets."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef can_update_assets(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['assetHints']['canUpdate']", "response": "Tests if this user can update assets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_asset_form_for_update(self, asset_id=None):\n        if asset_id is None:\n            raise NullArgument()\n        try:\n            url_path = construct_url('assets',\n                                     bank_id=self._catalog_idstr,\n                                     asset_id=asset_id)\n            asset = objects.Asset(self._get_request(url_path))\n        except Exception:\n            raise\n        asset_form = objects.AssetForm(asset._my_map)\n        self._forms[asset_form.get_id().get_identifier()] = not UPDATED\n        return asset_form", "response": "Gets the asset form for updating an existing asset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating an existing asset.", "response": "def update_asset(self, asset_form=None):\n        \"\"\"Updates an existing asset.\n\n        :param asset_form: the form containing the elements to be updated\n        :type asset_form: ``osid.repository.AssetForm``\n        :raise: ``IllegalState`` -- ``asset_form`` already used in anupdate transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``asset_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``asset_form`` did not originate from ``get_asset_form_for_update()``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if asset_form is None:\n            raise NullArgument()\n        if not isinstance(asset_form, abc_repository_objects.AssetForm):\n            raise InvalidArgument('argument type is not an AssetForm')\n        if not asset_form.is_for_update():\n            raise InvalidArgument('form is for create only, not update')\n        try:\n            if self._forms[asset_form.get_id().get_identifier()] == UPDATED:\n                raise IllegalState('form already used in an update transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not asset_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr)\n        try:\n            result = self._put_request(url_path, asset_form._my_map)\n        except Exception:\n            raise  # OperationFailed()\n        self._forms[asset_form.get_id().get_identifier()] = UPDATED\n        return objects.Asset(result)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef can_delete_assets(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['assetHints']['canDelete']", "response": "Tests if this user can delete Assets."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_asset(self, asset_id=None):\n        if asset_id is None:\n            raise NullArgument()\n        if not isinstance(asset_id, Id):\n            raise InvalidArgument('argument type is not an osid Id')\n\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr,\n                                 asset_id=asset_id)\n        result = self._delete_request(url_path)\n        return objects.Asset(result)", "response": "Deletes an ``Asset``.\n\n        :param asset_id: the ``Id`` of the ``Asset`` to remove\n        :type asset_id: ``osid.id.Id``\n        :raise: ``NotFound`` -- ``asset_id`` not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef can_create_asset_content(self, asset_id=None):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['assetHints']['canCreate']", "response": "Tests if this user can create content for Assets."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntest if this user can create an asset content using the desired record types.", "response": "def can_create_asset_content_with_record_types(self, asset_id=None, asset_content_record_types=None):\n        \"\"\"Tests if this user can create an ``AssetContent`` using the desired record types.\n\n        While ``RepositoryManager.getAssetContentRecordTypes()`` can be\n        used to test which records are supported, this method tests\n        which records are required for creating a specific\n        ``AssetContent``. Providing an empty array tests if an\n        ``AssetContent`` can be created with no records.\n\n        :param asset_id: the ``Id`` of an ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param asset_content_record_types: array of asset content record types\n        :type asset_content_record_types: ``osid.type.Type[]``\n        :return: ``true`` if ``AssetContent`` creation using the specified ``Types`` is supported,\n            ``false`` otherwise\n        :rtype: ``boolean``\n        :raise: ``NullArgument`` -- ``asset_id`` or ``asset_content_record_types`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['assetHints']['canCreate']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_asset_content_form_for_create(self, asset_id=None, asset_content_record_types=None):\n        if asset_id is None:\n            raise NullArgument()\n        if asset_content_record_types is None:\n            pass  # Still need to deal with the record_types argument\n        asset_content_form = objects.AssetContentForm(asset_id=asset_id)\n        self._forms[asset_content_form.get_id().get_identifier()] = not CREATED\n        return asset_content_form", "response": "Gets an asset content form for creating new assets."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new asset content for a given asset.", "response": "def create_asset_content(self, asset_content_form=None):\n        \"\"\"Creates new ``AssetContent`` for a given asset.\n\n        :param asset_content_form: the form for this ``AssetContent``\n        :type asset_content_form: ``osid.repository.AssetContentForm``\n        :return: the new ``AssetContent``\n        :rtype: ``osid.repository.AssetContent``\n        :raise: ``IllegalState`` -- ``asset_content_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``asset_content_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``asset_content_form`` did not originate from ``get_asset_content_form_for_create()``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if asset_content_form is None:\n            raise NullArgument()\n        if not isinstance(asset_content_form, abc_repository_objects.AssetContentForm):\n            raise InvalidArgument('argument type is not an AssetContentForm')\n        if asset_content_form.is_for_update():\n            raise InvalidArgument('form is for update only, not create')\n        try:\n            if self._forms[asset_content_form.get_id().get_identifier()] == CREATED:\n                raise IllegalState('form already used in a create transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not asset_content_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr,\n                                 asset_id=asset_content_form._asset_id)\n        asset = objects.Asset(self._get_request(url_path))\n        previous_contents = asset._my_map['assetContents']\n        previous_content_ids = [c['id'] for c in previous_contents]\n        asset._my_map['assetContents'].append(asset_content_form._my_map)\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr)\n        try:\n            result = self._put_request(url_path, asset._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[asset_content_form.get_id().get_identifier()] = CREATED\n        content = result['assetContents']\n        if len(content) == 1:\n            return objects.AssetContent(content[0])\n        else:\n            # Assumes that in the split second this requires,\n            # no one else creates a new asset content for this\n            # asset...\n            for c in content:\n                if c['id'] not in previous_content_ids:\n                    return objects.AssetContent(c)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if this user can update an asset content.", "response": "def can_update_asset_contents(self, asset_id=None):\n        \"\"\"Tests if this user can update ``AssetContent``.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating an\n        ``AssetContent`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user.\n\n        :param asset_id: the ``Id`` of an ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :return: ``false`` if ``AssetContent`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['assetHints']['canUpdate']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_asset_content_form_for_update(self, asset_content_id=None):\n        if asset_content_id is None:\n            raise NullArgument()\n        asset = None\n        for a in AssetLookupSession(self._repository_id,\n                                    proxy=self._proxy,\n                                    runtime=self._runtime).get_assets():\n            # might want to set plenary view\n            # to assure ordering?\n            for ac in a.get_asset_contents():\n                if ac.get_id() == asset_content_id:\n                    asset = a\n                    asset_content = ac\n        if asset is None:\n            raise NotFound()\n        asset_content_form = objects.AssetContentForm(asset_content._my_map, asset_id=asset.get_id())\n        self._forms[asset_content_form.get_id().get_identifier()] = not UPDATED\n        return asset_content_form", "response": "Gets the asset content form for updating content for an existing asset."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_asset_content(self, asset_content_form=None):\n        if asset_content_form is None:\n            raise NullArgument()\n        if not isinstance(asset_content_form, abc_repository_objects.AssetContentForm):\n            raise InvalidArgument('argument type is not an AssetContentForm')\n        if not asset_content_form.is_for_update():\n            raise InvalidArgument('form is for create only, not update')\n        try:\n            if self._forms[asset_content_form.get_id().get_identifier()] == CREATED:\n                raise IllegalState('form already used in a create transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not asset_content_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr,\n                                 asset_id=asset_content_form._asset_id)\n        asset = objects.Asset(self._get_request(url_path))\n        index = 0\n        for ac in asset.get_asset_contents():\n            if str(ac.get_id()) == asset_content_form._my_map['id']:\n                break\n            index += 1\n        asset._my_map['assetContents'].pop(index)\n        asset._my_map['assetContents'].insert(index, asset_content_form._my_map)\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr)\n        try:\n            result = self._put_request(url_path, asset._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[asset_content_form.get_id().get_identifier()] = CREATED\n        return objects.AssetContent(asset_content_form._my_map)", "response": "Updates an existing asset content."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef can_delete_asset_contents(self, asset_id=None):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['assetHints']['canDelete']", "response": "Tests if this user can delete AssetsContent from Assets."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes an asset content from an Asset.", "response": "def delete_asset_content(self, asset_content_id=None):\n        \"\"\"Deletes content from an ``Asset``.\n\n        :param asset_content_id: the ``Id`` of the ``AssetContent``\n        :type asset_content_id: ``osid.id.Id``\n        :raise: ``NotFound`` -- ``asset_content_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_content_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if asset_content_id is None:\n            raise NullArgument()\n        asset = None\n        for a in AssetLookupSession(self._repository_id,\n                                    proxy=self._proxy,\n                                    runtime=self._runtime).get_assets():\n            i = 0\n            # might want to set plenary view\n            # to assure ordering?\n            for ac in a.get_asset_contents():\n                if ac.get_id() == asset_content_id:\n                    asset = a\n                    asset_content = ac\n                    index = i\n                i += 1\n        if asset is None:\n            raise NotFound()\n\n        asset._my_map['assetContents'].pop(index)\n        url_path = construct_url('assets',\n                                 bank_id=self._catalog_idstr)\n        try:\n            result = self._put_request(url_path, asset._my_map)\n        except Exception:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntesting if this user can perform Repository lookups.", "response": "def can_lookup_repositories(self):\n        \"\"\"Tests if this user can perform ``Repository`` lookups.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users.\n\n        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``\n\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._repository_id_str)\n        return self._get_request(url_path)['objectiveBankHints']['canLookup']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_repository(self, repository_id=None):\n        if repository_id is None:\n            raise NullArgument()\n        url_path = construct_url('objective_banks',\n                                 bank_id=repository_id)\n        return objects.Repository(self._get_request(url_path))", "response": "Gets the Repository specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_repositories_by_ids(self, repository_ids=None):\n        if repository_ids is None:\n            raise NullArgument()\n        repositories = []\n        for i in repository_ids:\n            repository = None\n            url_path = construct_url('objective_banks',\n                                     bank_id=i)\n            try:\n                repository = self._get_request(url_path)\n            except (NotFound, OperationFailed):\n                if self._repository_view == PLENARY:\n                    raise\n                else:\n                    pass\n            if repository:\n                if not (self._repository_view == COMPARATIVE and\n                        repository in repositories):\n                    repositories.append(repository)\n        return objects.RepositoryList(repositories)", "response": "Gets a list of repositories corresponding to the given Id list."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of repositories corresponding to the given repository genus Type.", "response": "def get_repositories_by_genus_type(self, repository_genus_type=None):\n        \"\"\"Gets a ``RepositoryList`` corresponding to the given repository genus ``Type`` which\n            does not include repositories of types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known\n        repositories or an error results. Otherwise, the returned list\n        may contain only those repositories that are accessible through\n        this session.\n\n        :param repository_genus_type: a repository genus type\n        :type repository_genus_type: ``osid.type.Type``\n        :return: the returned ``Repository list``\n        :rtype: ``osid.repository.RepositoryList``\n        :raise: ``NullArgument`` -- ``repository_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if repository_genus_type is None:\n            raise NullArgument()\n        url_path = construct_url('objective_banks')\n        repositories_of_type = []\n        all_repositories = self._get_request(url_path)\n        for repository in all_repositories:\n            # DO WE NEED TO CHECK ALL THREE ATRIBUTES OF THE Id HERE?\n            if repository['genusTypeId'] == repository_genus_type.get_identifier():\n                repositories_of_type.append[repository]\n        return objects.RepositoryList(repositories_of_type)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if this user can create repositories.", "response": "def can_create_repositories(self):\n        \"\"\"Tests if this user can create ``Repositories``.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Repository`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        create operations to unauthorized users.\n\n        :return: ``false`` if ``Repository`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``\n\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveBankHints']['canCreate']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest if this user can create a single repository using the desired record types.", "response": "def can_create_repository_with_record_types(self, repository_record_types=None):\n        \"\"\"Tests if this user can create a single ``Repository`` using the desired record types.\n\n        While ``RepositoryManager.getRepositoryRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Repository``. Providing an empty array tests if a\n        ``Repository`` can be created with no records.\n\n        :param repository_record_types: array of repository record types\n        :type repository_record_types: ``osid.type.Type[]``\n        :return: ``true`` if ``Repository`` creation using the specified ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``\n        :raise: ``NullArgument`` -- ``repository_record_types`` is ``null``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveBankHints']['canCreate']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the repository form for creating new repositories.", "response": "def get_repository_form_for_create(self, repository_record_types=None):\n        \"\"\"Gets the repository form for creating new repositories.\n\n        A new form should be requested for each create transaction.\n\n        :param repository_record_types: array of repository record types\n        :type repository_record_types: ``osid.type.Type[]``\n        :return: the repository form\n        :rtype: ``osid.repository.RepositoryForm``\n        :raise: ``NullArgument`` -- ``repository_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if repository_record_types is None:\n            pass  # Still need to deal with the record_types argument\n        repository_form = objects.RepositoryForm()\n        self._forms[repository_form.get_id().get_identifier()] = not CREATED\n        return repository_form"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new repository.", "response": "def create_repository(self, repository_form=None):\n        \"\"\"Creates a new ``Repository``.\n\n        :param repository_form: the form for this ``Repository``\n        :type repository_form: ``osid.repository.RepositoryForm``\n        :return: the new ``Repository``\n        :rtype: ``osid.repository.Repository``\n        :raise: ``IllegalState`` -- ``repository_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``repository_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``repository_form`` did not originate from ``get_repository_form_for_create()``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if repository_form is None:\n            raise NullArgument()\n        if not isinstance(repository_form, abc_repository_objects.RepositoryForm):\n            raise InvalidArgument('argument type is not a RepositoryForm')\n        if repository_form.is_for_update():\n            raise InvalidArgument('form is for update only, not create')\n        try:\n            if self._forms[repository_form.get_id().get_identifier()] == CREATED:\n                raise IllegalState('form already used in a create transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not repository_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('objective_banks')\n        try:\n            result = self._post_request(url_path, repository_form._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[repository_form.get_id().get_identifier()] = CREATED\n        return objects.Repository(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef can_update_repositories(self):\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveBankHints']['canUpdate']", "response": "Tests if this user can update repositories."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the repository form for updating an existing repository.", "response": "def get_repository_form_for_update(self, repository_id=None):\n        \"\"\"Gets the repository form for updating an existing repository.\n\n        A new repository form should be requested for each update\n        transaction.\n\n        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n        :return: the repository form\n        :rtype: ``osid.repository.RepositoryForm``\n        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if repository_id is None:\n            raise NullArgument()\n        try:\n            repository = RepositoryLookupSession(proxy=self._proxy,\n                                                 runtime=self._runtime).get_repository(repository_id)\n        except Exception:\n            raise\n        repository_form = objects.RepositoryForm(repository._my_map)\n        self._forms[repository_form.get_id().get_identifier()] = not UPDATED\n        return repository_form"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating an existing repository.", "response": "def update_repository(self, repository_form=None):\n        \"\"\"Updates an existing repository.\n\n        :param repository_form: the form containing the elements to be updated\n        :type repository_form: ``osid.repository.RepositoryForm``\n        :raise: ``IllegalState`` -- ``repository_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``repository_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``repository_form`` did not originate from ``get_repository_form_for_update()``\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if repository_form is None:\n            raise NullArgument()\n        if not isinstance(repository_form, abc_repository_objects.RepositoryForm):\n            raise InvalidArgument('argument type is not a RepositoryForm')\n        if not repository_form.is_for_update():\n            raise InvalidArgument('form is for create only, not update')\n\n        # Check for \"sandbox\" genus type.  Hardcoded for now:\n        if repository_form._my_map['genusTypeId'] != 'mc3-objectivebank%3Amc3.learning.objectivebank.sandbox%40MIT-OEIT':\n            raise PermissionDenied('Handcar only supports updating \\'sandbox\\' type Repositories')\n\n        try:\n            if self._forms[repository_form.get_id().get_identifier()] == UPDATED:\n                raise IllegalState('form already used in an update transaction')\n        except KeyError:\n            raise Unsupported('form did not originate from this session')\n        if not repository_form.is_valid():\n            raise InvalidArgument('one or more of the form elements is invalid')\n\n        url_path = construct_url('objective_banks')\n        try:\n            result = self._put_request(url_path, repository_form._my_map)\n        except Exception:\n            raise  # OperationFailed\n        self._forms[repository_form.get_id().get_identifier()] = UPDATED\n        return objects.Repository(result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if this user can delete repositories.", "response": "def can_delete_repositories(self):\n        \"\"\"Tests if this user can delete ``Repositories``.\n\n        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``Repository`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        delete operations to unauthorized users.\n\n        :return: ``false`` if ``Repository`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``\n\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        url_path = construct_url('authorization',\n                                 bank_id=self._catalog_idstr)\n        return self._get_request(url_path)['objectiveBankHints']['canDelete']"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes a ``Repository``. :param repository_id: the ``Id`` of the ``Repository`` to remove :type repository_id: ``osid.id.Id`` :raise: ``NotFound`` -- ``repository_id`` not found :raise: ``NullArgument`` -- ``repository_id`` is ``null`` :raise: ``OperationFailed`` -- unable to complete request :raise: ``PermissionDenied`` -- authorization failure *compliance: mandatory -- This method must be implemented.*", "response": "def delete_repository(self, repository_id=None):\n        \"\"\"Deletes a ``Repository``.\n\n        :param repository_id: the ``Id`` of the ``Repository`` to remove\n        :type repository_id: ``osid.id.Id``\n        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if repository_id is None:\n            raise NullArgument()\n        if not isinstance(repository_id, Id):\n            raise InvalidArgument('argument type is not an osid Id')\n\n        # Check for \"sandbox\" genus type.  Hardcoded for now:\n        try:\n            repository = RepositoryLookupSession(proxy=self._proxy,\n                                                 runtime=self._runtime).get_repository(repository_id)\n        except Exception:\n            raise\n        if repository._my_map['genusTypeId'] != 'mc3-objectivebank%3Amc3.learning.objectivebank.sandbox%40MIT-OEIT':\n            raise PermissionDenied('Handcar only supports deleting \\'sandbox\\' type Repositories')\n\n        url_path = construct_url('objective_banks',\n                                 bank_id=repository_id)\n        result = self._delete_request(url_path)\n        return objects.Repository(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef raise_if(self, exception, message, *args, **kwargs):\n        if issubclass(exception, self.minimum_defect):\n            raise exception(*args, **kwargs)\n        warn(message, SyntaxWarning, *args, **kwargs)", "response": "Raises exception if exception is smaller than minimum_defect."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef signal(e):\n    callback = find_handler(e)\n    if callback is None:\n        if _activate_debugger:\n            print 'Handler for error {0} not found'.format(type(e))\n            traceback.print_stack()\n            set_trace()\n        raise e\n    else:\n        return callback(e)", "response": "Signal that an error occurred."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverrides this so only right answers are returned", "response": "def get_answers(self):\n        \"\"\" override this so only right answers are returned\n        :return:\n        \"\"\"\n        all_answers = self.my_osid_object._my_map['answers']\n        right_answers = [a for a in all_answers\n                         if a['genusTypeId'] != str(WRONG_ANSWER_GENUS_TYPE)]\n        return AnswerList(right_answers,\n                          runtime=self.my_osid_object._runtime,\n                          proxy=self.my_osid_object._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noverriding this so only right answer ids are returned", "response": "def get_answer_ids(self):\n        \"\"\" override this so only right answer ids are returned\n        :return:\n        \"\"\"\n        id_list = []\n        for answer in self.get_answers():\n            id_list.append(answer.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprovides this method to return only wrong answers", "response": "def get_wrong_answers(self):\n        \"\"\" provide this method to return only wrong answers\n        :return:\n        \"\"\"\n        all_answers = self.my_osid_object._my_map['answers']\n        wrong_answers = [a for a in all_answers\n                         if a['genusTypeId'] == str(WRONG_ANSWER_GENUS_TYPE)]\n        return AnswerList(wrong_answers,\n                          runtime=self.my_osid_object._runtime,\n                          proxy=self.my_osid_object._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_wrong_answer_ids(self):\n        id_list = []\n        for answer in self.get_wrong_answers():\n            id_list.append(answer.get_id())\n        return IdList(id_list)", "response": "provide this method to return only wrong answer ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls before the configuration.converters are activated Here we make sure that we have harpoon options from ``args_dict`` in the configuration. We then load all the harpoon modules as specified by the ``harpoon.addons`` setting. Finally we inject into the configuration: $@ The ``harpoon.extra`` setting bash The ``bash`` setting command The ``command`` setting harpoon The harpoon settings collector This instance", "response": "def extra_prepare(self, configuration, args_dict):\n        \"\"\"\n        Called before the configuration.converters are activated\n\n        Here we make sure that we have harpoon options from ``args_dict`` in\n        the configuration.\n\n        We then load all the harpoon modules as specified by the\n        ``harpoon.addons`` setting.\n\n        Finally we inject into the configuration:\n\n        $@\n            The ``harpoon.extra`` setting\n\n        bash\n            The ``bash`` setting\n\n        command\n            The ``command`` setting\n\n        harpoon\n            The harpoon settings\n\n        collector\n            This instance\n        \"\"\"\n        harpoon = self.find_harpoon_options(configuration, args_dict)\n        self.register = self.setup_addon_register(harpoon)\n\n        # Make sure images is started\n        if \"images\" not in self.configuration:\n            self.configuration[\"images\"] = {}\n\n        # Add our special stuff to the configuration\n        self.configuration.update(\n            { \"$@\": harpoon.get(\"extra\", \"\")\n            , \"bash\": args_dict[\"bash\"] or sb.NotSpecified\n            , \"harpoon\": harpoon\n            , \"assume_role\": args_dict[\"assume_role\"] or NotSpecified\n            , \"command\": args_dict['command'] or sb.NotSpecified\n            , \"collector\": self\n            }\n        , source = \"<args_dict>\"\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_harpoon_options(self, configuration, args_dict):\n        d = lambda r: {} if r in (None, \"\", NotSpecified) else r\n        return MergedOptions.using(\n              dict(d(configuration.get('harpoon')).items())\n            , dict(d(args_dict.get(\"harpoon\")).items())\n            ).as_dict()", "response": "Return us all the harpoon options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_addon_register(self, harpoon):\n        # Create the addon getter and register the crosshairs namespace\n        self.addon_getter = AddonGetter()\n        self.addon_getter.add_namespace(\"harpoon.crosshairs\", Result.FieldSpec(), Addon.FieldSpec())\n\n        # Initiate the addons from our configuration\n        register = Register(self.addon_getter, self)\n\n        if \"addons\" in harpoon:\n            addons = harpoon[\"addons\"]\n            if type(addons) in (MergedOptions, dict) or getattr(addons, \"is_dict\", False):\n                spec = sb.dictof(sb.string_spec(), sb.listof(sb.string_spec()))\n                meta = Meta(harpoon, []).at(\"addons\")\n                for namespace, adns in spec.normalise(meta, addons).items():\n                    register.add_pairs(*[(namespace, adn) for adn in adns])\n\n        # Import our addons\n        register.recursive_import_known()\n\n        # Resolve our addons\n        register.recursive_resolve_imported()\n\n        return register", "response": "Setup our addon register"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extra_prepare_after_activation(self, configuration, args_dict):\n        def task_maker(name, description=None, action=None, label=\"Project\", **options):\n            if not action:\n                action = name\n            self.task_overrides[name] = Task(action=action, description=description, options=options, label=label)\n            return self.task_overrides[name]\n\n        # Post register our addons\n        extra_args = {\"harpoon.crosshairs\": {\"task_maker\": task_maker}}\n        self.register.post_register(extra_args)\n\n        # Make the task finder\n        task_finder = TaskFinder(self)\n        configuration[\"task_runner\"] = task_finder.task_runner\n        task_finder.find_tasks(self.task_overrides)", "response": "This method is called after the configuration. converters are activated and the configuration. converters are not activated."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_configuration(self, configuration, collect_another_source, done, result, src):\n        # Make sure to maintain the original config_root\n        if \"config_root\" in configuration:\n            # if we already have a config root then we only keep new config root if it's not the home location\n            # i.e. if it is the home configuration, we don't delete the new config_root\n            if configuration[\"config_root\"] != os.path.dirname(self.home_dir_configuration_location()):\n                if \"config_root\" in result:\n                    del result[\"config_root\"]\n\n        config_root = configuration.get(\"config_root\")\n        if config_root and src.startswith(config_root):\n            src = \"{{config_root}}/{0}\".format(src[len(config_root) + 1:])\n\n        if \"images\" in result and \"__images_from__\" in result[\"images\"]:\n            images_from_path = result[\"images\"][\"__images_from__\"]\n\n            if isinstance(images_from_path, six.string_types):\n                images_from_path = [images_from_path]\n\n            for ifp in images_from_path:\n\n                if not ifp.startswith(\"/\"):\n                    ifp = os.path.join(os.path.dirname(src), ifp)\n\n                if not os.path.exists(ifp) or not os.path.isdir(ifp):\n                    raise self.BadConfigurationErrorKls(\n                          \"Specified folder for other configuration files points to a folder that doesn't exist\"\n                        , path=\"images.__images_from__\"\n                        , value=ifp\n                        )\n\n                for root, dirs, files in os.walk(ifp):\n                    for fle in files:\n                        location = os.path.join(root, fle)\n                        if fle.endswith(\".yml\") or fle.endswith(\".yaml\"):\n                            collect_another_source(location\n                                , prefix = [\"images\", os.path.splitext(os.path.basename(fle))[0]]\n                                )\n\n            del result[\"images\"][\"__images_from__\"]\n\n        configuration.update(result, source=src)\n\n        if \"harpoon\" in result:\n            if \"extra_files\" in result[\"harpoon\"]:\n                spec = sb.listof(sb.formatted(sb.string_spec(), formatter=MergedOptionStringFormatter))\n                config_root = {\"config_root\": result.get(\"config_root\", configuration.get(\"config_root\"))}\n                meta = Meta(MergedOptions.using(result, config_root), []).at(\"harpoon\").at(\"extra_files\")\n                for extra in spec.normalise(meta, result[\"harpoon\"][\"extra_files\"]):\n                    if os.path.abspath(extra) not in done:\n                        if not os.path.exists(extra):\n                            raise BadConfiguration(\"Specified extra file doesn't exist\", extra=extra, source=src)\n                        collect_another_source(extra)", "response": "Add a new configuration file to the result."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhooks to do any extra configuration collection or converter registration", "response": "def extra_configuration_collection(self, configuration):\n        \"\"\"\n        Hook to do any extra configuration collection or converter registration\n        \"\"\"\n        harpoon_spec = HarpoonSpec()\n\n        for image in configuration.get('images', {}).keys():\n            self.make_image_converters(image, configuration, harpoon_spec)\n\n        self.register_converters(\n              { (0, (\"content\", )): sb.dictof(sb.string_spec(), sb.string_spec())\n              , (0, (\"harpoon\", )): harpoon_spec.harpoon_spec\n              , (0, (\"authentication\", )): harpoon_spec.authentications_spec\n              }\n            , Meta, configuration, sb.NotSpecified\n            )\n\n        # Some other code works better when harpoon no existy\n        if configuration[\"harpoon\"] is sb.NotSpecified:\n            del configuration[\"harpoon\"]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_image_converters(self, image, configuration, harpoon_spec):\n        def convert_image(path, val):\n            log.info(\"Converting %s\", path)\n            everything = path.configuration.root().wrapped()\n            meta = Meta(everything, [])\n            configuration.converters.started(path)\n\n            base = path.configuration.root().wrapped()\n            base.update(configuration.as_dict(ignore=[\"images\"]))\n            base.update(val.as_dict(ignore=[\"images\"]))\n\n            base[\"__image__\"] = base\n            everything[\"__image__\"] = base\n\n            base[\"harpoon\"] = configuration[\"harpoon\"]\n            base[\"configuration\"] = configuration\n            return harpoon_spec.image_spec.normalise(meta.at(\"images\").at(image), base)\n\n        converter = Converter(convert=convert_image, convert_path=[\"images\", image])\n        configuration.add_converter(converter)\n\n        def convert_tasks(path, val):\n            spec = harpoon_spec.tasks_spec(available_actions)\n            meta = Meta(path.configuration.root(), []).at(\"images\").at(image).at(\"tasks\")\n            configuration.converters.started(path)\n            tasks = spec.normalise(meta, val)\n            for task in tasks.values():\n                task.image = image\n            return tasks\n\n        converter = Converter(convert=convert_tasks, convert_path=[\"images\", image, \"tasks\"])\n        configuration.add_converter(converter)", "response": "Make converters for this image and add them to the configuration"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters arc to include only the top level arc.", "response": "def filter_arc(w, h, aspect):\n    \"\"\"Aspect ratio convertor. you must specify output size and source aspect ratio (as float)\"\"\"\n    taspect = float(w)/h\n    if abs(taspect - aspect) < 0.01:\n        return \"scale=%s:%s\"%(w,h)\n    if taspect > aspect: # pillarbox\n        pt = 0\n        ph = h\n        pw = int (h*aspect)\n        pl = int((w - pw)/2.0)\n    else: # letterbox\n        pl = 0\n        pw = w\n        ph = int(w * (1/aspect))\n        pt = int((h - ph)/2.0)\n    return \"scale=%s:%s[out];[out]pad=%s:%s:%s:%s:black\" % (pw,ph,w,h,pl,pt)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the Asset specified by its Id.", "response": "def get_asset(self, asset_id=None):\n        \"\"\"Gets the ``Asset`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Asset`` may have a different\n        ``Id`` than requested, such as the case where a duplicate ``Id``\n        was assigned to an ``Asset`` and retained for compatibility.\n\n        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset`` to\n                retrieve\n        return: (osid.repository.Asset) - the returned ``Asset``\n        raise:  NotFound - no ``Asset`` found with the given ``Id``\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return Asset(self._provider_session.get_asset(asset_id), self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_assets_by_ids(self, asset_ids=None):\n        return AssetList(self._provider_session.get_assets_by_ids(asset_ids),\n                         self._config_map)", "response": "Gets an AssetList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an AssetList corresponding to the given asset genus Type and optional Asset genus Type.", "response": "def get_assets_by_genus_type(self, asset_genus_type=None):\n        \"\"\"Gets an ``AssetList`` corresponding to the given asset genus ``Type``\n        which does not include assets of types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session.\n\n        arg:    asset_genus_type (osid.type.Type): an asset genus type\n        return: (osid.repository.AssetList) - the returned ``Asset\n                list``\n        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetList(self._provider_session.get_assets_by_genus_type(asset_genus_type),\n                         self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets an AssetList corresponding to the given asset genus Type and include any additional assets with genus types derived from the specified AssetGenusType.", "response": "def get_assets_by_parent_genus_type(self, asset_genus_type=None):\n        \"\"\"Gets an ``AssetList`` corresponding to the given asset genus ``Type``\n        and include any additional assets with genus types derived from the specified\n        ``Type``.\n\n        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session.\n\n        arg:    asset_genus_type (osid.type.Type): an asset genus type\n        return: (osid.repository.AssetList) - the returned ``Asset\n                list``\n        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetList(self._provider_session.get_assets_by_parent_genus_type(asset_genus_type),\n                         self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget an AssetList containing the given asset record Type.", "response": "def get_assets_by_record_type(self, asset_record_type=None):\n        \"\"\"Gets an ``AssetList`` containing the given asset record ``Type``.\n\n        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session.\n\n        arg:    asset_record_type (osid.type.Type): an asset record type\n        return: (osid.repository.AssetList) - the returned ``Asset\n                list``\n        raise:  NullArgument - ``asset_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetList(self._provider_session.get_assets_by_record_type(asset_record_type),\n                         self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assets_by_provider(self, resource_id=None):\n        return AssetList(self._provider_session.get_assets_by_provider(resource_id),\n                         self._config_map)", "response": "Gets an AssetList from the given provider."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_asset_content(self, asset_content_id):\n        return AssetContent(self._provider_session.get_asset_content(asset_content_id), self._config_map)", "response": "Gets the AssetContent specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an AssetContentList corresponding to the given IdList.", "response": "def get_asset_contents_by_ids(self, asset_content_ids):\n        \"\"\"Gets an ``AssetList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the asset contents\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``AssetContnts`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set.\n\n        :param asset_content_ids: the list of ``Ids`` to retrieve\n        :type asset_content_ids: ``osid.id.IdList``\n        :return: the returned ``AssetContent list``\n        :rtype: ``osid.repository.AssetContentList``\n        :raise: ``NotFound`` -- an ``Id`` was not found\n        :raise: ``NullArgument`` -- ``asset_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetContentList(self._provider_session.get_asset_contents_by_ids(asset_content_ids), self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting an AssetContentList corresponding to the given asset content genus Type which does not include asset contents of types derived from the specified Type.", "response": "def get_asset_contents_by_genus_type(self, asset_content_genus_type):\n        \"\"\"Gets an ``AssetContentList`` corresponding to the given asset content genus ``Type`` which does not include asset contents of types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known asset contents or\n        an error results. Otherwise, the returned list may contain only\n        those asset contents that are accessible through this session.\n\n        :param asset_content_genus_type: an asset content genus type\n        :type asset_content_genus_type: ``osid.type.Type``\n        :return: the returned ``AssetContent list``\n        :rtype: ``osid.repository.AssetContentList``\n        :raise: ``NullArgument`` -- ``asset_content_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetContentList(self._provider_session.get_asset_contents_by_genus_type(asset_content_genus_type), self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget an AssetContentList corresponding to the given asset content genus Type and include any additional asset contents with genus types derived from the specified Type.", "response": "def get_asset_contents_by_parent_genus_type(self, asset_content_genus_type):\n        \"\"\"Gets an ``AssetContentList`` corresponding to the given asset content genus ``Type`` and include any additional asset contents with genus types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known asset contents or\n        an error results. Otherwise, the returned list may contain only\n        those asset contents that are accessible through this session.\n\n        :param asset_content_genus_type: an asset content genus type\n        :type asset_content_genus_type: ``osid.type.Type``\n        :return: the returned ``AssetContent list``\n        :rtype: ``osid.repository.AssetContentList``\n        :raise: ``NullArgument`` -- ``asset_content_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetContentList(self._provider_session.get_asset_contents_by_parent_genus_type(asset_content_genus_type), self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_asset_contents_by_record_type(self, asset_content_record_type):\n        return AssetContentList(self._provider_session.get_asset_contents_by_record_type(asset_content_record_type), self._config_map)", "response": "Gets an AssetContentList containing the given asset record Type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget an AssetList from the given Asset.", "response": "def get_asset_contents_for_asset(self, asset_id):\n        \"\"\"Gets an ``AssetList`` from the given Asset.\n\n        In plenary mode, the returned list contains all known asset contents or\n        an error results. Otherwise, the returned list may contain only\n        those asset contents that are accessible through this session.\n\n        :param asset_id: an asset ``Id``\n        :type asset_id: ``osid.id.Id``\n        :return: the returned ``AssetContent list``\n        :rtype: ``osid.repository.AssetContentList``\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetContentList(self._provider_session.get_asset_contents_for_asset(asset_id), self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets an AssetContentList from the given GenusType and Asset Id.", "response": "def get_asset_contents_by_genus_type_for_asset(self, asset_content_genus_type, asset_id):\n        \"\"\"Gets an ``AssetContentList`` from the given GenusType and Asset Id.\n\n        In plenary mode, the returned list contains all known asset contents or\n        an error results. Otherwise, the returned list may contain only\n        those asset contents that are accessible through this session.\n\n        :param asset_content_genus_type: an an asset content genus type\n        :type asset_id: ``osid.type.Type``\n        :param asset_id: an asset ``Id``\n        :type asset_id: ``osid.id.Id``\n        :return: the returned ``AssetContent list``\n        :rtype: ``osid.repository.AssetContentList``\n        :raise: ``NullArgument`` -- ``asset_content_genus_type`` or ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetContentList(self._provider_session.get_asset_contents_by_genus_type_for_asset(asset_content_genus_type, asset_id), self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a list of Assets matching the given asset query.", "response": "def get_assets_by_query(self, asset_query=None):\n        \"\"\"Gets a list of ``Assets`` matching the given asset query.\n\n        arg:    asset_query (osid.repository.AssetQuery): the asset\n                query\n        return: (osid.repository.AssetList) - the returned ``AssetList``\n        raise:  NullArgument - ``asset_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - the ``asset_query`` is not of this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetList(self._provider_session.get_assets_by_query(asset_query),\n                         self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of AssetContents matching the given asset content query.", "response": "def get_asset_contents_by_query(self, asset_content_query=None):\n        \"\"\"Gets a list of ``AssetContents`` matching the given asset content query.\n\n        arg:    asset_content_query (osid.repository.AssetContentQuery): the asset\n                content query\n        return: (osid.repository.AssetContentList) - the returned ``AssetContentList``\n        raise:  NullArgument - ``asset_content_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - the ``asset_content_query`` is not of this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return AssetContentList(self._provider_session.get_asset_contents_by_query(asset_content_query),\n                                self._config_map)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_asset(self, asset_form=None):\n        return Asset(self._provider_session.update_asset(asset_form), self._config_map)", "response": "Updates an existing asset."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_asset(self, asset_id=None):\n        # Implemented from awsosid template for -\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        # clean up AWS\n        asset = self._asset_lookup_session.get_asset(asset_id)\n        for ac in asset.asset_contents:\n            self.delete_asset_content(ac.ident)\n        self._provider_session.delete_asset(asset_id)", "response": "Deletes an ``Asset``.\n\n        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset`` to\n                remove\n        raise:  NotFound - ``asset_id`` not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_asset_content_form_for_create(self,\n                                          asset_id=None,\n                                          asset_content_record_types=None):\n        \"\"\"Gets an asset content form for creating new assets.\n\n        arg:    asset_id (osid.id.Id): the ``Id`` of an ``Asset``\n        arg:    asset_content_record_types (osid.type.Type[]): array of\n                asset content record types\n        return: (osid.repository.AssetContentForm) - the asset content\n                form\n        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` or\n                ``asset_content_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if AWS_ASSET_CONTENT_RECORD_TYPE in asset_content_record_types:\n            asset_content_record_types.remove(AWS_ASSET_CONTENT_RECORD_TYPE)\n            return AssetContentForm(\n                self._provider_session.get_asset_content_form_for_create(\n                    asset_id,\n                    asset_content_record_types),\n                self._config_map,\n                self.get_repository_id())\n        else:\n            return self._provider_session.get_asset_content_form_for_create(\n                asset_id,\n                asset_content_record_types)", "response": "Gets an asset content form for creating new assets."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_asset_content(self, asset_content_form=None):\n        if isinstance(asset_content_form, AssetContentForm):\n            asset_content = self._provider_session.create_asset_content(\n                asset_content_form._payload)\n        else:\n            asset_content = self._provider_session.create_asset_content(\n                asset_content_form)\n        try:\n            if asset_content.has_url() and 'amazonaws.com' in asset_content.get_url():\n                return AssetContent(asset_content, self._config_map)\n        except TypeError:\n            pass\n        return asset_content", "response": "Creates a new AssetContent for a given asset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the asset content form for updating an existing asset content.", "response": "def get_asset_content_form_for_update(self, asset_content_id=None):\n        \"\"\"Gets the asset content form for updating an existing asset content.\n\n        A new asset content form should be requested for each update\n        transaction.\n\n        arg:    asset_content_id (osid.id.Id): the ``Id`` of the\n                ``AssetContent``\n        return: (osid.repository.AssetContentForm) - the asset content\n                form\n        raise:  NotFound - ``asset_content_id`` is not found\n        raise:  NullArgument - ``asset_content_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        asset_content_form = self._provider_session.get_asset_content_form_for_update(\n            asset_content_id)\n        if 'amazonaws.com' in asset_content_form.get_url_metadata().get_existing_string_values()[0]:\n            return AssetContentForm(asset_content_form,\n                                    self._config_map,\n                                    self.get_repository_id())\n        return asset_content_form"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating an existing asset content.", "response": "def update_asset_content(self, asset_content_form=None):\n        \"\"\"Updates an existing asset content.\n\n        arg:    asset_content_form (osid.repository.AssetContentForm):\n                the form containing the elements to be updated\n        raise:  IllegalState - ``asset_content_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``asset_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_content_form`` did not originate\n                from ``get_asset_content_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if isinstance(asset_content_form, AssetContentForm):\n            asset_content = self._provider_session.update_asset_content(\n                asset_content_form._payload)\n        else:\n            asset_content = self._provider_session.update_asset_content(\n                asset_content_form)\n        if asset_content is not None and asset_content.has_url() and \\\n                'amazonaws.com' in asset_content.get_url():\n            return AssetContent(asset_content, self._config_map)\n        return asset_content"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_asset_content(self, asset_content_id=None):\n        asset_content = self._get_asset_content(asset_content_id)\n        if asset_content.has_url() and 'amazonaws.com' in asset_content.get_url():\n            # print \"Still have to implement removing files from aws\"\n            key = asset_content.get_url().split('amazonaws.com')[1]\n            remove_file(self._config_map, key)\n            self._provider_session.delete_asset_content(asset_content_id)\n        else:\n            self._provider_session.delete_asset_content(asset_content_id)", "response": "Deletes content from an Asset."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_asset_content(self, asset_content_id):\n        asset_content = None\n        for asset in self._asset_lookup_session.get_assets():\n            for content in asset.get_asset_contents():\n                if content.get_id() == asset_content_id:\n                    asset_content = content\n                    break\n            if asset_content is not None:\n                break\n        if asset_content is None:\n            raise NotFound('THe AWS Adapter could not find AssetContent ' +\n                           str(asset_content_id))\n        return asset_content", "response": "get the AssetContent object for the given asset content_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_repository(self, repository_id=None):\n        # Implemented from awsosid template for -\n        # osid.resource.BinLookupSession.get_bin_template\n        if not self._can('lookup'):\n            raise PermissionDenied()\n        else:\n            return self._provider_session.get_repository(repository_id)", "response": "Gets the Repository specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_repositories_by_ids(self, repository_ids=None):\n        # Implemented from awsosid template for -\n        # osid.resource.BinLookupSession.get_bins_by_ids_template\n        if not self._can('lookup'):\n            raise PermissionDenied()\n        else:\n            return self._provider_session.get_repositories_by_ids(repository_ids)", "response": "Gets a list of repositories corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the repository form for creating new repositories.", "response": "def get_repository_form_for_create(self, repository_record_types=None):\n        \"\"\"Gets the repository form for creating new repositories.\n\n        A new form should be requested for each create transaction.\n\n        arg:    repository_record_types (osid.type.Type[]): array of\n                repository record types\n        return: (osid.repository.RepositoryForm) - the repository form\n        raise:  NullArgument - ``repository_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from awsosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_create_template\n        if not self._can('create'):\n            raise PermissionDenied()\n        else:\n            return self._provider_session.get_repository_form_for_create(repository_record_types)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_repository_form_for_update(self, repository_id=None):\n        # Implemented from awsosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        if not self._can('update'):\n            raise PermissionDenied()\n        else:\n            return self._provider_session.get_repository_form_for_update(repository_id)", "response": "Gets the repository form for updating an existing repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates an existing repository.", "response": "def update_repository(self, repository_form=None):\n        \"\"\"Updates an existing repository.\n\n        arg:    repository_form (osid.repository.RepositoryForm): the\n                form containing the elements to be updated\n        raise:  IllegalState - ``repository_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``repository_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``repository_form`` did not originate from\n                ``get_repository_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from awsosid template for -\n        # osid.resource.BinAdminSession.update_bin_template\n        if not self._can('update'):\n            raise PermissionDenied()\n        else:\n            return self._provider_session.update_repository(repository_form)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_repository(self, repository_id=None):\n        # Implemented from awsosid template for -\n        # osid.resource.BinAdminSession.delete_bin_template\n        if not self._can('delete'):\n            raise PermissionDenied()\n        else:\n            return self._provider_session.delete_repository(repository_id)", "response": "Deletes a ``Repository``.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository`` to remove\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef alias_repository(self, repository_id=None, alias_id=None):\n        # Implemented from awsosid template for -\n        # osid.resource.BinAdminSession.alias_bin_template\n        if not self._can('alias'):\n            raise PermissionDenied()\n        else:\n            return self._provider_session.alias_repository(repository_id)", "response": "Adds an Id to a repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_asset(self, asset_id, composition_id):\n        self._provider_session.add_asset(self, asset_id, composition_id)", "response": "Adds an asset to the composition."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef move_asset_ahead(self, asset_id, composition_id, reference_id):\n        self._provider_session.move_asset_ahead(self, asset_id, composition_id, reference_id)", "response": "Moves an asset in a composition in front of a reference asset."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef move_asset_behind(self, asset_id, composition_id, reference_id):\n        self._provider_session.move_asset_behind(self, asset_id, composition_id, reference_id)", "response": "Moves the specified asset behind of a reference asset."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef order_assets(self, asset_ids, composition_id):\n        self._provider_session.order_assets(self, asset_ids, composition_id)", "response": "Reorders a set of assets in a composition."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves an Asset from a Composition.", "response": "def remove_asset(self, asset_id, composition_id):\n        \"\"\"Removes an ``Asset`` from a ``Composition``.\n\n        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n        raise:  NotFound - ``asset_id``  ``not found in composition_id``\n        raise:  NullArgument - ``asset_id`` or ``composition_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._provider_session.remove_asset(self, asset_id, composition_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef docker_context():\n    try:\n        client = docker.from_env(\n              version = \"auto\"\n            , timeout = int(os.environ.get(\"DOCKER_CLIENT_TIMEOUT\", 180))\n            , assert_hostname = False\n            )\n\n        info = client.info()\n        log.info(\"Connected to docker daemon\\tdriver=%s\\tkernel=%s\", info[\"Driver\"], info[\"KernelVersion\"])\n    except (DockerException, APIError) as error:\n        raise BadDockerConnection(error=error)\n\n    return client", "response": "Make a docker context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'birdland.mit.edu',\n            'namespace': 'time format',\n            'identifier': name,\n            'domain': 'Time Format Types',\n            'display_name': JEFFS_TIME_FORMAT_TYPES[name] + ' Time Format Type',\n            'display_label': JEFFS_TIME_FORMAT_TYPES[name],\n            'description': ('The time format type for ' +\n                            JEFFS_TIME_FORMAT_TYPES[name])\n        }\n    except KeyError:\n        raise NotFound('Time Format Type: ' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_hierarchy_traversal_session(self, proxy):\n        if not self.supports_hierarchy_traversal():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.HierarchyTraversalSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the hierarchy traversal service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the hierarchy traversal service for the given hierarchy.", "response": "def get_hierarchy_traversal_session_for_hierarchy(self, hierarchy_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the hierarchy traversal service for the given hierarchy.\n\n        arg:    hierarchy_id (osid.id.Id): the ``Id`` of the hierarchy\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.hierarchy.HierarchyTraversalSession) - a\n                ``HierarchyTraversalSession``\n        raise:  NotFound - ``hierarchyid`` not found\n        raise:  NullArgument - ``hierarchy_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_hierarchy_traversal()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_hierarchy_traversal()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_hierarchy_traversal():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.HierarchyTraversalSession(hierarchy_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the hierarchy design service.", "response": "def get_hierarchy_design_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the hierarchy design service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.hierarchy.HierarchyDesignSession) - a\n                ``HierarchyDesignSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_hierarchy_design()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_hierarchy_design()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.HierarchyDesignSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the topology design service using for the given hierarchy.", "response": "def get_hierarchy_design_session_for_hierarchy(self, hierarchy_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the topology design service using for the given hierarchy.\n\n        arg:    hierarchy_id (osid.id.Id): the ``Id`` of the hierarchy\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.hierarchy.HierarchyDesignSession) - a\n                ``HierarchyDesignSession``\n        raise:  NotFound - ``hierarchy_id`` is not found\n        raise:  NullArgument - ``hierarchy_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_hierarchy_design()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_hierarchy_design()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_hierarchy_design():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.HierarchyDesignSession(hierarchy_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_hierarchy_lookup_session(self, proxy):\n        if not self.supports_hierarchy_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.HierarchyLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the hierarchy lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the hierarchy administrative session.", "response": "def get_hierarchy_admin_session(self, proxy):\n        \"\"\"Gets the hierarchy administrative session.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.hierarchy.HierarchyAdminSession) - a\n                ``HierarchyAdminSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_hierarchy_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_hierarchy_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_hierarchy_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.HierarchyAdminSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwalking an AST and returns a list of headings.", "response": "def ast_to_headings(node):\n    \"\"\"\n    Walks AST and returns a list of headings\n    \"\"\"\n\n    Heading = namedtuple('Heading', ['level', 'title'])\n\n    level = None\n    walker = node.walker()\n    headings = []\n\n    event = walker.nxt()\n    while event is not None:\n        entering = event['entering']\n        node = event['node']\n\n        if node.t == 'Heading':\n            if entering:\n                level = node.level\n            else:\n                level = None\n        elif level:\n            if node.t != 'Text':\n                raise Exception('Unexpected node {}, only text may be within a heading.'.format(node.t))\n\n            headings.append(Heading(level=level, title=node.literal))\n\n        event = walker.nxt()\n\n    return headings"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts Dictator to Python s dict object", "response": "def copy(self):\n        \"\"\"Convert ``Dictator`` to standard ``dict`` object\n\n        >>> dc = Dictator()\n        >>> dc['l0'] = [1, 2]\n        >>> dc['1'] = 'abc'\n        >>> d = dc.copy()\n        >>> type(d)\n        dict\n        >>> d\n        {'l0': ['1', '2'], '1': 'abc'}\n        >>> dc.clear()\n\n        :return: Python's dict object\n        :rtype: dict\n        \"\"\"\n        logger.debug('call to_dict')\n        return {key: self.get(key) for key in self.keys()}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, key, default=None):\n        try:\n            value = self.__getitem__(key)\n        except KeyError:\n            value = None\n\n        # Py3 Redis compatibiility\n        if isinstance(value, bytes):\n            value = value.decode()\n        return value or default", "response": "Return the value at key or default value which is None by default."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves and return the last item of the list key. If key doesn t exist it return default.", "response": "def pop(self, key, default=None):\n        \"\"\"Remove and return the last item of the list ``key``.\n        If key doesn't exists it return ``default``.\n\n        >>> dc = Dictator()\n        >>> dc['l0'] = [1, 2, 3, 4]\n        >>> dc.pop('l0')\n        ['1', '2', '3', '4']\n        >>> dc.pop('l1', 'empty')\n        'empty'\n\n        :param key: key name to pop\n        :type key: str\n        :param default: default value if key doesn't exist\n        :type default: Any\n        :return: value associated with given key or None or ``default``\n        :rtype: Any\n        \"\"\"\n        logger.debug('call pop %s', key)\n        value = self.get(key)\n        self._redis.delete(key)\n        return value or default"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef keys(self, pattern=None):\n        logger.debug('call pop %s', pattern)\n        if pattern is None:\n            pattern = '*'\n        return self._redis.keys(pattern=pattern)", "response": "Returns a list of keys matching pattern."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef items(self):\n        logger.debug('call items')\n        return [(key, self.get(key)) for key in self.keys()]", "response": "Return list of tuples of keys and values in db\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef values(self):\n        logger.debug('call values')\n        return [self.get(key) for key in self.keys()]", "response": "Return list of values in db\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iterkeys(self, match=None, count=1):\n        logger.debug('call iterkeys %s', match)\n        if match is None:\n            match = '*'\n        for key in self._redis.scan_iter(match=match, count=count):\n            yield key", "response": "Return an iterator over the db s keys."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iteritems(self, match=None, count=1):\n        logger.debug('call iteritems %s', match)\n        if match is None:\n            match = '*'\n        for key in self._redis.scan_iter(match=match, count=count):\n            yield key, self.get(key)", "response": "Return an iterator over the db s keys and values."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the internal state of the internal state of the object.", "response": "def update(self, other=None, **kwargs):\n        \"\"\"D.update([other, ]**kwargs) -> None.\n        Update D From dict/iterable ``other`` and ``kwargs``.\n        If ``other`` present and has a .keys() method, does:\n            for k in other: D[k] = other[k]\n        If ``other`` present and lacks .keys() method, does:\n            for (k, v) in other: D[k] = v\n        In either case, this is followed by: for k in kwargs: D[k] = kwargs[k]\n\n        >>> dc = Dictator()\n        >>> dc['1'] = 'abc'\n        >>> dc['2'] = 'def'\n        >>> dc.values()\n        ['def', 'abc']\n        >>> dc.update({'3': 'ghi'}, name='Keys')\n        >>> dc.values()\n        ['Keys', 'ghi', 'def', 'abc']\n        >>> dc.clear()\n\n        :param other: dict/iterable with .keys() function.\n        :param kwargs: key/value pairs\n        \"\"\"\n        logger.debug('call update %s', other)\n        if other:\n            if hasattr(other, 'keys'):\n                for key in other.keys():\n                    self.set(key, other[key])\n            else:\n                for (key, value) in other:\n                    self.set(key, value)\n\n        if kwargs:\n            for key, value in six.iteritems(kwargs):\n                self.set(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npasses through to provider ResourceSearchSession. get_resources_by_search", "response": "def get_resources_by_search(self, resource_query, resource_search):\n        \"\"\"Pass through to provider ResourceSearchSession.get_resources_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_resources_by_search(resource_query, resource_search)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_resource_relationships_for_source_resource_on_date(self, source_resource_id, from_, to):\n        # Implemented from azosid template for -\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source_on_date_template\n        if self._can('lookup'):\n            return self._provider_session.get_resource_relationships_for_source_resource_on_date(source_resource_id, from_, to)\n        self._check_lookup_conditions()  # raises PermissionDenied\n        query = self._query_session.get_resource_relationship_query()\n        query.match_source_id(source_resource_id, match=True)\n        query.match_date(from_, to, match=True)\n        return self._try_harder(query)", "response": "Pass through to provider ResourceRelationshipLookupSession. get_resource_relationships_for_source_resource_on_date"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_resource_relationships_by_search(self, resource_relationship_query, resource_relationship_search):\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_resource_relationships_by_search(resource_relationship_query, resource_relationship_search)", "response": "Pass through to provider ResourceRelationshipSearchSession. get_resource_relationships_by_search"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef writeln(self, data):\n        self.f.write(\" \"*self.indent_level)\n        self.f.write(data + \"\\n\")", "response": "Writes a line of text to the file containing the current version of the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _function(self, type, name, args=\"\"):\n        return FunctionManager(self, type=type, name=name, args=args)", "response": "Returns a context manager for writing a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the code based on the given module configuration and writes it to the given file object f.", "response": "def write_to(self, f):\n        \"\"\"\n        Generates code based on the given module configuration and writes it to\n        the file object `f`.\n        \"\"\"\n        f = CodeWriter(f)\n\n        # Write all header files\n        headers = set()\n        for plugin in self.plugins:\n            headers = headers.union(plugin.header_files())\n        for header in headers:\n            f.writeln(\"#include <{}>\".format(header))\n        f.writeln(\"\")\n\n        # Write all declarations\n        for plugin in self.plugins:\n            plugin.write_declarations(f)\n        f.writeln(\"\")\n\n        # Write the setup function\n        with f._function(\"void\", \"setup\"):\n            # Setup all plugins\n            f.writeln(\"// Setup all plugins\")\n            for plugin in self.plugins:\n                plugin.setup_plugin(f)\n            # Setup all modules\n            f.writeln(\"// Setup all modules\")\n            for mod_name in self.modules.keys():\n                for plugin in self.plugins:\n                    plugin.setup_module(mod_name, f)\n        f.writeln(\"\")\n\n        # Write the loop function\n        with f._function(\"void\", \"loop\"):\n            # Update all plugins\n            f.writeln(\"// Update all plugins\")\n            for plugin in self.plugins:\n                plugin.update_plugin(f)\n            # Update all modules\n            f.writeln(\"// Update all modules\")\n            for mod_name, mod_info in self.modules.items():\n                for plugin in self.plugins:\n                    plugin.update_module(mod_name, f)\n\n                # Read all module outputs\n                for output_name in mod_info[\"outputs\"]:\n                    cond = \"{mod_name}.get_{output_name}({msg_name})\".format(\n                        mod_name=mod_name, output_name=output_name,\n                        msg_name=self.msg_name(mod_name, output_name)\n                    )\n                    with f._if(cond):\n                        for plugin in self.plugins:\n                            plugin.on_output(mod_name, output_name, f)\n\n            # Read statuses of all modules\n            f.writeln(\"// Read statuses of all modules\")\n            with f._if(\"should_read_statuses()\"):\n                for plugin in self.plugins:\n                    plugin.start_read_module_status(f)\n                for mod_name in self.modules:\n                    for plugin in self.plugins:\n                        plugin.read_module_status(mod_name, f)\n                for plugin in self.plugins:\n                    plugin.end_read_module_status(f)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _record_extension(self, key, value):\n        record_bean = {\n            'value': value,\n            'displayName': self._text_bean(key),\n            'description': self._text_bean(key),\n            'displayLabel': self._text_bean(key),\n            'associatedId': str(self.ident)\n        }\n        return record_bean", "response": "To structure a record extension property bean\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_genus_type(self):\n        if self._my_genus_type_map is None:\n            url_path = '/handcar/services/learning/types/' + self._my_map['genusTypeId']\n#            url_str = self._base_url + '/types/' + self._my_map['genusTypeId']\n#            self._my_genus_type_map = self._load_json(url_str)\n            self._my_genus_type_map = self._get_request(url_path)\n        return Type(self._my_genus_type_map)", "response": "Gets the genus type of this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if this object is of the given genus Type.", "response": "def is_of_genus_type(self, genus_type=None):\n        \"\"\"Tests if this object is of the given genus Type.\n\n        The given genus type may be supported by the object through the\n        type hierarchy.\n\n        | arg:    ``genus_type`` (``osid.type.Type``): a genus type\n        | return: (``boolean``) - true if this object is of the given genus\n                Type,  false otherwise\n        | raise:  ``NullArgument`` - ``genus_type`` is null\n        | *compliance: mandatory - This method must be implemented.*\n\n        \"\"\"\n        if genus_type is None:\n            raise NullArgument()\n        else:\n            my_genus_type = self.get_genus_type()\n            return (genus_type.get_authority() == my_genus_type.get_authority() and\n                    genus_type.get_identifier_namespace() == my_genus_type.get_identifier_namespace() and\n                    genus_type.get_identifier() == my_genus_type.get_identifier())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset a comment. arg: comment (string): the new comment raise: InvalidArgument - comment is invalid raise: NoAccess - metadata.is_readonly() is true raise: NullArgument - comment is null compliance: mandatory - This method must be implemented.", "response": "def set_journal_comment(self, comment=None):\n        \"\"\"Sets a comment.\n\n        arg:    comment (string): the new comment\n        raise:  InvalidArgument - comment is invalid\n        raise:  NoAccess - metadata.is_readonly() is true\n        raise:  NullArgument - comment is null\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if comment is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['comment'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(comment, metadata, array=False):\n            self._my_map['journalComment']['text'] = comment\n        else:\n            raise InvalidArgument()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if the current submission is in a valid state for submission.", "response": "def is_valid(self):\n        \"\"\"Tests if ths form is in a valid state for submission.\n\n        A form is valid if all required data has been supplied compliant\n        with any constraints.\n\n        return: (boolean) - false if there is a known error in this\n                form, true otherwise\n        raise:  OperationFailed - attempt to perform validation failed\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        validity = True\n        for element in self._validity_map:\n            if self._validity_map[element] is not VALID:\n                validity = False\n        return validity"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_display_name(self, display_name=None):\n        if display_name is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['display_name'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(display_name, metadata, array=False):\n            self._my_map['displayName']['text'] = display_name\n        else:\n            raise InvalidArgument", "response": "Sets the display name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the description of the assessment.", "response": "def set_description(self, description=None):\n        \"\"\"Sets a description.\n\n        arg:    description (string): the new description\n        raise:  InvalidArgument - description is invalid\n        raise:  NoAccess - metadata.is_readonly() is true\n        raise:  NullArgument - description is null\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if description is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['description'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(description, metadata, array=False):\n            self._my_map['description']['text'] = description\n        else:\n            raise InvalidArgument"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_genus_type(self, genus_type=None):\n        if genus_type is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['genus_type'])\n        metadata_id = Metadata(**settings.METADATA['genus_type_id'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(genus_type, metadata, array=False):\n            self._my_map['genusTypeId'] = str(genus_type)\n            # REALLY?  This assumes that all genus_type arguments\n            # will be Types that have come from Hancar.  Perhaps?\n        elif self._is_valid_input(genus_type, metadata_id, array=False):\n            self._my_map['genusTypeId'] = str(genus_type)\n        else:\n            raise InvalidArgument", "response": "Sets a genus.\n\n        A genus cannot be cleared because all objects have at minimum a\n        root genus.\n\n        arg:    genusType (osid.type.Type): the new genus\n        raise:  InvalidArgument - genusType is invalid\n        raise:  NoAccess - metadata.is_readonly() is true\n        raise:  NullArgument - genusType is null\n        compliance: mandatory - This method must be implemented."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef derive_toctree_rst(self, current_file):\n        TAB = \" \" * 4\n        lines = list()\n        lines.append(\".. toctree::\")\n        for opt in TocTree.option_spec:\n            value = self.options.get(opt)\n            if value is not None:\n                lines.append((\"{}:{}: {}\".format(TAB, opt, value)).rstrip())\n        lines.append(\"\")\n\n        append_ahead = \"append_ahead\" in self.options\n        if append_ahead:\n            for line in list(self.content):\n                lines.append(TAB + line)\n\n        article_folder = ArticleFolder(dir_path=Path(current_file).parent.abspath)\n        for af in article_folder.sub_article_folders:\n            line = \"{}{} <{}>\".format(TAB, af.title, af.rel_path)\n            lines.append(line)\n\n        append_behind = not append_ahead\n        if append_behind:\n            for line in list(self.content):\n                lines.append(TAB + line)\n\n        lines.append(\"\")\n        return \"\\n\".join(lines)", "response": "Derive the rst content from the current file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef confirm(prompt, default=None, show_default=True, abort=False, input_function=None):\n\t'''Prompts for confirmation from the user.\n\t'''\n\tvalid = {\n\t\t'yes': True,\n\t\t'y': True,\n\t\t'no': False,\n\t\t'n': False\n\t}\n\tinput_function = get_input_fn(input_function)\n\tif default not in ['yes', 'no', None]:\n\t\tdefault = None\n\tif show_default:\n\t\tprompt = '{} [{}/{}]: '.format(prompt,\n\t\t\t\t'Y' if default == 'yes' else 'y',\n\t\t\t\t'N' if default == 'no' else 'n')\n\twhile True:\n\t\tchoice = prompt_fn(input_function, prompt, default).lower()\n\t\tif choice in valid:\n\t\t\tif valid[choice] == False and abort:\n\t\t\t\traise_abort()\n\t\t\treturn valid[choice]\n\t\telse:\n\t\t\techo('Please respond with \"yes\" or \"no\" (or \"y\" or \"n\").')", "response": "Prompts for confirmation from the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prompt(text, default=None, show_default=True, invisible=False,\n           confirm=False, skip=False, type=None, input_function=None):\n\t'''Prompts for input from the user.\n\t'''\n\tt = determine_type(type, default)\n\tinput_function = get_input_fn(input_function, invisible)\n\tif default is not None and show_default:\n\t\ttext = '{} [{}]: '.format(text, default)\n\twhile True:\n\t\tval = prompt_fn(input_function, text, default, t, skip, repeat=True)\n\t\tif not confirm or (skip and val is None):\n\t\t\treturn val\n\t\tif val == prompt_fn(input_function, 'Confirm: ', default, t, repeat=True):\n\t\t\treturn val\n\t\techo('Error: The two values you entered do not match', True)", "response": "Prompts for input from the user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef consume(self, tokens):\n\t\t'''Have this parameter consume some tokens.\n\n\t\tThis stores the consumed value for later use and returns the\n\t\tmodified tokens array for further processing.\n\t\t'''\n\t\tn = len(tokens) if self._nargs == -1 else self._nargs\n\t\tif n > len(tokens):\n\t\t\texit('Error: Not enough arguments for \"{}\".'.format(self._name), True)\n\t\ttry:\n\t\t\tconsumed = [self._type(e) if self._type is not None else e for e in tokens[:n]]\n\t\texcept ValueError as e:\n\t\t\texit('Error: Invalid type given to \"{}\", expected {}.'.format(\n\t\t\t\t\tself._name, self._type.__name__), True)\n\t\tif n == 1 and self._nargs == 1:\n\t\t\tconsumed = consumed[0]\n\t\tself.post_consume(consumed)\n\t\treturn tokens[n:]", "response": "Have this parameter consume some tokens. This method stores the consumed value for later use and returns the consumed array for further processing."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(self, tokens):\n\t\t'''Parses a list of tokens into a JSON-serializable object.\n\n\t\tThe parsing proceeds from left to right and is greedy.\n\n\t\tPrecedence order:\n\t\t  1. Parameters with active context. For example, an Option with\n\t\t     nargs=-1 will gobble all the remaining tokens.\n\t\t  2. Subcommands.\n\t\t  3. Parameters.\n\n\t\tThe keys of the returned object are the names of parameters or\n\t\tsubcommands. Subcommands are encoded as nested objects. Multiple\n\t\tparameters are encoded as lists. All other values are encoded as\n\t\tparameter-specified data types, or strings if not specified.\n\t\t'''\n\t\tself._ping_main()\n\n\t\t# Pre-parsing:\n\t\t#   1. Expand globbed options: -abc --> -a -b -c\n\t\tdef is_globbed(s):\n\t\t\treturn len(s) > 2 and s.startswith('-') and not s.startswith('--')\n\t\texpanded = [[\"-\" + c for c in list(token[1:])] if is_globbed(token) else [token] for token in tokens]\n\n\t\t# Parsing: pass off to main command after flattening expanded tokens list\n\t\treturn self._main.parse(list(itertools.chain.from_iterable(expanded)))", "response": "Parses a list of tokens into a JSON - serializable object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_resource_mdata():\n    return {\n        'group': {\n            'element_label': {\n                'text': 'group',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'avatar': {\n            'element_label': {\n                'text': 'avatar',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Resource"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_affinity(user1, user2, round=False):  # pragma: no cover\n    return MALAffinity(base_user=user1, round=round).calculate_affinity(user2)", "response": "Quick one - off affinity calculations."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef s2time(secs, show_secs=True, show_fracs=True):\n    try:\n        secs = float(secs)\n    except:\n        return \"--:--:--.--\"\n    wholesecs = int(secs)\n    centisecs = int((secs - wholesecs) * 100)\n    hh = int(wholesecs / 3600)\n    hd = int(hh % 24)\n    mm = int((wholesecs / 60) - (hh*60))\n    ss = int(wholesecs - (hh*3600) - (mm*60))\n    r = \"{:02d}:{:02d}\".format(hd, mm)\n    if show_secs:\n        r += \":{:02d}\".format(ss)\n    if show_fracs:\n        r += \".{:02d}\".format(centisecs)\n    return r", "response": "Converts seconds to time"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert frames to timecode", "response": "def f2tc(f,base=25):\n    \"\"\"Converts frames to timecode\"\"\"\n    try:\n        f = int(f)\n    except:\n        return \"--:--:--:--\"\n    hh = int((f / base) / 3600)\n    mm = int(((f / base) / 60) - (hh*60))\n    ss = int((f/base) - (hh*3600) - (mm*60))\n    ff = int(f - (hh*3600*base) - (mm*60*base) - (ss*base))\n    return \"{:02d}:{:02d}:{:02d}:{:02d}\".format(hh, mm, ss, ff)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef s2tc(s,base=25):\n    try:\n        f = int(s*base)\n    except:\n        return \"--:--:--:--\"\n    hh  = int((f / base) / 3600)\n    hhd = int((hh % 24))\n    mm  = int(((f / base) / 60) - (hh*60))\n    ss  = int((f/base) - (hh*3600) - (mm*60))\n    ff  = int(f - (hh*3600*base) - (mm*60*base) - (ss*base))\n    return \"{:02d}:{:02d}:{:02d}:{:02d}\".format(hhd, mm, ss, ff)", "response": "Converts seconds to timecode"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_time(timestamp, time_format=\"%Y-%m-%d %H:%M:%S\", never_placeholder=\"never\", gmt=False):\n    if not timestamp:\n        return never_placeholder\n    return time.strftime(time_format, time.gmtime(timestamp) if gmt else time.localtime(timestamp))", "response": "Format a timestamp as a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main(args):\n\n  \"\"\" First read the genome \"\"\"\n  sys.stderr.write(\"reading reference genome\\n\")\n  ref = FASTAData(open(args.genome).read())\n  sys.stderr.write(\"read in \"+str(len(ref.keys()))+\" chromosomes\\n\")\n\n  \"\"\" Next make the transcriptome \"\"\"\n  txome = {}\n  sys.stderr.write(\"write the transcriptome\\n\")\n  inf = None\n  if args.gpd[-3:] == '.gz':\n    inf = gzip.open(args.gpd)\n  else:\n    inf = open(args.gpd)\n  stream = GPDStream(inf)\n  tof = open(args.tempdir+'/transcriptome.fa','w')\n  z = 0\n  for gpd in stream:\n    z += 1\n    if gpd.transcript_name in txome:\n      sys.stderr.write(\"WARNING already have a transcript \"+gpd.transcript_name+\" ignoring line \"+str(z)+\" of the gpd\\n\")\n      continue\n    txome[gpd.transcript_name] = gpd.gene_name\n    tof.write('>'+gpd.transcript_name+\"\\n\"+str(gpd.get_sequence(ref))+\"\\n\")\n  tof.close()\n  inf.close()\n  sys.stderr.write(\"wrote \"+str(len(txome.keys()))+\" transcripts\\n\")\n\n  \"\"\"Build the salmon index\"\"\"\n  sys.stderr.write(\"building a salmon index\\n\")\n  cmd = 'salmon index -p '+str(args.numThreads)+' -t '+args.tempdir+'/transcriptome.fa -i '+args.tempdir+'/salmon_index'\n  p = Popen(cmd.split())\n  p.communicate()\n  sys.stderr.write(\"finished building the index\\n\")\n\n  \"\"\"Use the index to quanitfy\"\"\"\n  sys.stderr.write(\"quanitfy reads\\n\")\n  reads = ''\n  if args.rU:\n    reads = '-r '+args.rU\n  else:\n    reads = '-1 '+args.r1+' -2 '+args.r2\n  cmd = 'salmon quant -p '+str(args.numThreads)+' -i '+args.tempdir+'/salmon_index -l A '+reads+' -o '+args.tempdir+'/output_quant'\n  p = Popen(cmd.split())\n  p.communicate()\n  sys.stderr.write(\"finished quanitfying\\n\")\n\n  \"\"\"Now parse the salmon output to add gene name\"\"\"\n  salmon = {}\n  with open(args.tempdir+'/output_quant/quant.sf') as inf:\n    header = inf.readline()\n    for line in inf:\n      f = line.rstrip().split(\"\\t\")\n      # by each transcript name hold a data strcture of the information\n      salmon[f[0]] = {'name':f[0],'length':int(f[1]),'EffectiveLength':float(f[2]),'TPM':float(f[3]),'NumReads':float(f[4])}\n  genes = {}\n  for name in salmon:\n    gene = txome[name]\n    if gene not in genes: genes[gene] = []\n    genes[gene].append(salmon[name])\n  genetot = {}\n  for gene in genes:\n    tot = sum([x['TPM'] for x in genes[gene]])\n    genetot[gene] = tot\n  ordered_gene_names = sorted(genetot.keys(), key=lambda x: genetot[x],reverse=True)\n      \n  \"\"\"Collected enough information to make output\"\"\"\n  sys.stderr.write(\"generating output\\n\")\n  of = sys.stdout\n  if args.output != '-':\n    of = open(args.output,'w')\n  of.write(\"geneName\\ttranscriptName\\tlength\\tEffectiveLength\\ttxTPM\\tNumReads\\tgeneTPM\\n\")\n  for gene in ordered_gene_names:\n    txs = sorted(genes[gene],key=lambda x: x['TPM'],reverse=True)\n    for tx in txs:\n      of.write(gene+\"\\t\"+tx['name']+\"\\t\"+str(tx['length'])+\"\\t\"+str(tx['EffectiveLength'])+\"\\t\"+str(tx['TPM'])+\"\\t\"+str(tx['NumReads'])+\"\\t\"+str(genetot[gene])+\"\\n\")\n  of.close()\n\n  # Temporary working directory step 3 of 3 - Cleanup\n  if not args.specific_tempdir:\n    rmtree(args.tempdir)", "response": "This function is the main function of the salmon index script."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clone_with_new_dockerfile(self, conf, docker_file):\n        log.info(\"Copying context to add a different dockerfile\")\n        self.close()\n        with a_temp_file() as tmpfile:\n            old_t = os.stat(self.tmpfile.name).st_size > 0\n            if old_t:\n                shutil.copy(self.tmpfile.name, tmpfile.name)\n\n            with tarfile.open(tmpfile.name, mode=\"a\") as t:\n                conf.add_docker_file_to_tarfile(docker_file, t)\n                yield ContextWrapper(t, tmpfile)", "response": "Clone this tar and add in another filename before closing the new tar and returning"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef the_context(self, content, silent_build=False):\n        if isinstance(content, six.string_types):\n            with a_temp_file() as fle:\n                fle.write(content.encode('utf-8'))\n                fle.seek(0)\n                yield fle\n        elif \"context\" in content:\n            with ContextBuilder().make_context(content[\"context\"], silent_build=silent_build) as wrapper:\n                wrapper.close()\n                yield wrapper.tmpfile\n        elif \"image\" in content:\n            from harpoon.ship.runner import Runner\n            with a_temp_file() as fle:\n                content[\"conf\"].command = \"yes\"\n                with Runner()._run_container(content[\"conf\"], content[\"images\"], detach=True, delete_anyway=True):\n                    try:\n                        strm, stat = content[\"docker_api\"].get_archive(content[\"conf\"].container_id, content[\"path\"])\n                    except docker.errors.NotFound:\n                        raise BadOption(\"Trying to get something from an image that don't exist!\", path=content[\"path\"], image=content[\"conf\"].image_name)\n                    else:\n                        log.debug(stat)\n\n                        fo = BytesIO(b''.join(strm))\n\n                        # In newer docker the archive is a gzipped archive\n                        # But in older docker, it's a normal tar\n                        for mode in (\"r:gz\", \"r\"):\n                            try:\n                                tf = tarfile.open(fileobj=fo, mode=mode)\n                                break\n                            except tarfile.ReadError:\n                                if mode == \"r\":\n                                    raise\n                                fo.seek(0)\n\n                        if tf.firstmember.isdir():\n                            tf2 = tarfile.TarFile(fileobj=fle, mode='w')\n                            name = tf.firstmember.name\n                            for member in tf.getmembers()[1:]:\n                                member.name = member.name[len(name)+1:]\n                                if member.issym():\n                                    with tempfile.NamedTemporaryFile() as symfle:\n                                        os.remove(symfle.name)\n                                        os.symlink(member.linkpath, symfle.name)\n                                        tf2.addfile(member, fileobj=symfle)\n                                elif not member.isdir():\n                                    tf2.addfile(member, fileobj=tf.extractfile(member.name))\n                            tf2.close()\n                        else:\n                            fle.write(tf.extractfile(tf.firstmember.name).read())\n\n                        tf.close()\n                        log.info(\"Got '{0}' from {1} for context\".format(content[\"path\"], content[\"conf\"].container_id))\n\n                fle.seek(0)\n                yield fle", "response": "Return either a file with the content written to it or a whole new context tar"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds all the files in the archive and yield them.", "response": "def find_files_for_tar(self, context, silent_build):\n        \"\"\"\n        Return [(filename, arcname), ...] for all the files.\n        \"\"\"\n        if not context.enabled:\n            return\n\n        files = self.find_files(context, silent_build)\n\n        for path in files:\n            relname = os.path.relpath(path, context.parent_dir)\n            arcname = \"./{0}\".format(relname.encode('utf-8').decode('ascii', 'ignore'))\n            if os.path.exists(path):\n                yield path, arcname"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the set of files that we care about", "response": "def find_files(self, context, silent_build):\n        \"\"\"\n        Find the set of files from our parent_dir that we care about\n        \"\"\"\n        first_layer = [\"'{0}'\".format(thing) for thing in os.listdir(context.parent_dir)]\n        output, status = command_output(\"find {0} -type l -or -type f {1} -follow -print\".format(' '.join(first_layer), context.find_options), cwd=context.parent_dir)\n        if status != 0:\n            if context.ignore_find_errors:\n                log.warning(\"The find command failed to run, will continue anyway\")\n            else:\n                raise HarpoonError(\"Couldn't find the files we care about\", output=output, cwd=context.parent_dir)\n        all_files = set(self.convert_nonascii(output))\n        total_files = set(all_files)\n\n        combined = set(all_files)\n\n        if context.use_gitignore:\n            if context.parent_dir == context.git_root:\n                all_files = set([path for path in all_files if not path.startswith(\".git\")])\n\n            combined = set(all_files)\n            valid_files = self.find_notignored_git_files(context, silent_build)\n\n            removed = set()\n            if valid_files:\n                for fle in combined:\n                    if fle not in valid_files:\n                        removed.add(fle)\n            if removed and not silent_build: log.info(\"Ignoring %s/%s files\", len(removed), len(combined))\n            combined -= removed\n\n        if context.exclude:\n            excluded = set()\n            for filename in combined:\n                for excluder in context.exclude:\n                    if fnmatch.fnmatch(filename, excluder):\n                        excluded.add(filename)\n                        break\n            if not silent_build: log.info(\"Filtering %s/%s items\\texcluding=%s\", len(excluded), len(combined), context.exclude)\n            combined -= excluded\n\n        if context.include:\n            extra_included = []\n            for filename in total_files:\n                for includer in context.include:\n                    if fnmatch.fnmatch(filename, includer):\n                        extra_included.append(filename)\n                        break\n            if not silent_build: log.info(\"Adding back %s items\\tincluding=%s\", len(extra_included), context.include)\n            combined = set(list(combined) + extra_included)\n\n        files = sorted(os.path.join(context.parent_dir, filename) for filename in combined)\n        if not silent_build: log.info(\"Adding %s things from %s to the context\", len(files), context.parent_dir)\n        return files"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_nonascii(self, lst):\n        for item in lst:\n            if item.startswith('\"') and item.endswith('\"'):\n                item = item[1:-1]\n                yield item.encode('utf-8').decode('unicode-escape')\n            else:\n                yield item.encode('utf-8').decode('unicode-escape')", "response": "Convert the strange outputs from git commands"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_notignored_git_files(self, context, silent_build):\n        def git(args, error_message, cwd=context.parent_dir, **error_kwargs):\n            output, status = command_output(\"git {0}\".format(args), cwd=cwd)\n            if status != 0:\n                error_kwargs['output'] = output\n                error_kwargs['directory'] = context.parent_dir\n                raise HarpoonError(error_message, **error_kwargs)\n            return output\n\n        changed_files = git(\"diff --name-only\", \"Failed to determine what files have changed\")\n        untracked_files = git(\"ls-files --others --exclude-standard\", \"Failed to find untracked files\")\n\n        valid = set()\n        under_source_control = git(\"ls-files --exclude-standard\", \"Failed to find all the files under source control\")\n        git_submodules = [regexes[\"whitespace\"].split(line.strip())[1] for line in git(\"submodule status\", \"Failed to find submodules\", cwd=context.git_root)]\n        git_submodules = [os.path.normpath(os.path.relpath(os.path.abspath(p), os.path.abspath(os.path.relpath(context.parent_dir, context.git_root)))) for p in git_submodules]\n\n        valid = under_source_control + untracked_files\n\n        for filename in list(valid):\n            matched = False\n            if context.exclude:\n                for excluder in context.exclude:\n                    if fnmatch.fnmatch(filename, excluder):\n                        matched = True\n                        break\n\n            if matched:\n                continue\n\n            location = os.path.join(context.parent_dir, filename)\n            if os.path.islink(location) and os.path.isdir(location):\n                actual_path = os.path.abspath(os.path.realpath(location))\n                parent_dir = os.path.abspath(os.path.realpath(context.parent_dir))\n                include_from = os.path.relpath(actual_path, parent_dir)\n\n                to_include = git(\"ls-files --exclude-standard -- {0}\".format(include_from), \"Failed to find files under a symlink\")\n                for found in to_include:\n                    valid += [os.path.join(filename, os.path.relpath(found, include_from))]\n            elif os.path.isdir(location) and filename in git_submodules:\n                to_include = git(\"ls-files --exclude-standard\", \"Failed to find files in a submodule\", cwd=location)\n                valid = [v for v in valid if v != filename]\n                for found in to_include:\n                    valid.append(os.path.join(filename, found))\n\n        return set(self.convert_nonascii(valid))", "response": "Find all git files that are not ignored by git"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ask(question, default=None):\n    question = str(question)\n\n    if default:\n        question += ' [' + str(default) + ']'\n\n    question += ': '\n\n    reply = raw_input(question)\n    return reply if reply else default", "response": "Ask a user for a question."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert user answer to boolean", "response": "def to_bool(answer, default):\n    \"\"\"\n    Converts user answer to boolean\n    \"\"\"\n    answer = str(answer).lower()\n    default = str(default).lower()\n\n    if answer and answer in \"yes\":\n        return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef out(*args):\n    for value in args:\n        sys.stdout.write(value)\n\n    sys.stdout.write(os.linesep)", "response": "Outputs its parameters to users stdout."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef err(*args):\n    for value in args:\n        sys.stderr.write(value)\n\n    sys.stderr.write(os.linesep)", "response": "Outputs its parameters to users stderr."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_next_assessment_section(self, assessment_section_id):\n        try:\n            self.get_next_assessment_section(assessment_section_id)\n        except errors.IllegalState:\n            return False\n        else:\n            return True", "response": "Tests if there is a next assessment section in the assessment following the given assessment section Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_next_assessment_section(self, assessment_section_id):\n        assessment_taken = self.get_assessment_section(assessment_section_id)._assessment_taken\n        return assessment_taken._get_next_assessment_section(assessment_section_id)", "response": "Gets the next assesment section in the hierarchy"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntest if there is a previous assessment section in the assessment following the given assessment section Id.", "response": "def has_previous_assessment_section(self, assessment_section_id):\n        \"\"\"Tests if there is a previous assessment section in the assessment following the given assessment section ``Id``.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        return: (boolean) - ``true`` if there is a previous assessment\n                section, ``false`` otherwise\n        raise:  IllegalState - ``has_assessment_begun()`` is ``false``\n        raise:  NotFound - ``assessment_section_id`` is not found\n        raise:  NullArgument - ``assessment_section_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        try:\n            self.get_previous_assessment_section(assessment_section_id)\n        except errors.IllegalState:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_previous_assessment_section(self, assessment_section_id):\n        assessment_taken = self.get_assessment_section(assessment_section_id)._assessment_taken\n        return assessment_taken._get_previous_assessment_section(assessment_section_id)", "response": "Gets the previous assesment section in the order of the given assesment section."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_section(self, assessment_section_id):\n        return get_section_util(assessment_section_id, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an AssessmentSection by Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the incomplete assessment sections of this assessment.", "response": "def get_incomplete_assessment_sections(self, assessment_taken_id):\n        \"\"\"Gets the incomplete assessment sections of this assessment.\n\n        arg:    assessment_taken_id (osid.id.Id): ``Id`` of the\n                ``AssessmentTaken``\n        return: (osid.assessment.AssessmentSectionList) - the list of\n                incomplete assessment sections\n        raise:  IllegalState - ``has_assessment_begun()`` is ``false``\n        raise:  NotFound - ``assessment_taken_id`` is not found\n        raise:  NullArgument - ``assessment_taken_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        section_list = []\n        for section in self.get_assessment_sections(assessment_taken_id):\n            if not section.is_complete():\n                section_list.append(section)\n        return objects.AssessmentSectionList(section_list, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if this assessment section has begun.", "response": "def has_assessment_section_begun(self, assessment_section_id):\n        \"\"\"Tests if this assessment section has started.\n\n        A section begins from the designated start time if a start time\n        is defined. If no start time is defined the section may begin at\n        any time. Assessment items cannot be accessed or submitted if\n        the return for this method is ``false``.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        return: (boolean) - ``true`` if this assessment section has\n                begun, ``false`` otherwise\n        raise:  IllegalState - ``has_assessment_begun()`` is ``false or\n                is_assessment_over()`` is ``true``\n        raise:  NotFound - ``assessment_section_id`` is not found\n        raise:  NullArgument - ``assessment_section_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return get_section_util(assessment_section_id,\n                                runtime=self._runtime)._assessment_taken.has_started()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_next_question(self, assessment_section_id, item_id):\n        try:\n            self.get_next_question(assessment_section_id, item_id)\n        except errors.IllegalState:\n            return False\n        else:\n            return True", "response": "Tests if there is a next question following the given question Id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the next question in the item in the assessment section", "response": "def get_next_question(self, assessment_section_id, item_id):\n        \"\"\"Gets the next question in this assesment section.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        return: (osid.assessment.Question) - the next question\n        raise:  IllegalState - ``has_next_question()`` is ``false``\n        raise:  NotFound - ``assessment_section_id`` or ``item_id`` is\n                not found, or ``item_id`` not part of\n                ``assessment_section_id``\n        raise:  NullArgument - ``assessment_section_id`` or ``item_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return self.get_assessment_section(assessment_section_id).get_next_question(question_id=item_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_previous_question(self, assessment_section_id, item_id):\n        try:\n            self.get_previous_question(assessment_section_id, item_id)\n        except errors.IllegalState:\n            return False\n        else:\n            return True", "response": "Tests if there is a previous question preceeding the given question Id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_previous_question(self, assessment_section_id, item_id):\n        return self.get_assessment_section(assessment_section_id).get_next_question(question_id=item_id, reverse=True)", "response": "Gets the previous question in this assesment section."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_question(self, assessment_section_id, item_id):\n        return self.get_assessment_section(assessment_section_id).get_question(question_id=item_id)", "response": "Gets the question specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_response_form(self, assessment_section_id, item_id):\n        if not isinstance(item_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n\n        # This is a little hack to get the answer record types from the Item's\n        # first Answer record types. Should really get it from item genus types somehow:\n        record_type_data_sets = get_registry('ANSWER_RECORD_TYPES', self._runtime)\n        section = self.get_assessment_section(assessment_section_id)\n        # because we're now giving session-unique question IDs\n        question = section.get_question(item_id)\n        ils = section._get_item_lookup_session()\n        real_item_id = Id(question._my_map['itemId'])\n        item = ils.get_item(real_item_id)\n        item_map = item.object_map\n        all_answers = item_map['answers']\n        try:\n            all_answers += [wa.object_map for wa in item.get_wrong_answers()]\n        except AttributeError:\n            pass\n\n        answer_record_types = []\n        if len(all_answers) > 0:\n            for record_type_idstr in all_answers[0]['recordTypeIds']:\n                identifier = Id(record_type_idstr).get_identifier()\n                if identifier in record_type_data_sets:\n                    answer_record_types.append(Type(**record_type_data_sets[identifier]))\n        else:\n            for record_type_idstr in item_map['question']['recordTypeIds']:\n                identifier = Id(record_type_idstr).get_identifier()\n                if identifier in record_type_data_sets:\n                    answer_record_types.append(Type(**record_type_data_sets[identifier]))\n        # Thus endith the hack.\n\n        obj_form = objects.AnswerForm(\n            bank_id=self._catalog_id,\n            record_types=answer_record_types,\n            item_id=item_id,\n            catalog_id=self._catalog_id,\n            assessment_section_id=assessment_section_id,\n            runtime=self._runtime,\n            proxy=self._proxy)\n        obj_form._for_update = False  # This may be redundant\n        self._forms[obj_form.get_id().get_identifier()] = not SUBMITTED\n        return obj_form", "response": "Gets the response form for submitting an answer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef submit_response(self, assessment_section_id, item_id, answer_form):\n        if not isinstance(answer_form, ABCAnswerForm):\n            raise errors.InvalidArgument('argument type is not an AnswerForm')\n\n        # OK, so the following should actually NEVER be true. Remove it?\n        if answer_form.is_for_update():\n            raise errors.InvalidArgument('the AnswerForm is for update only, not submit')\n        #\n\n        try:\n            if self._forms[answer_form.get_id().get_identifier()] == SUBMITTED:\n                raise errors.IllegalState('answer_form already used in a submit transaction')\n        except KeyError:\n            raise errors.Unsupported('answer_form did not originate from this assessment session')\n        if not answer_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        answer_form._my_map['_id'] = ObjectId()\n        self.get_assessment_section(assessment_section_id).submit_response(item_id, answer_form)\n        self._forms[answer_form.get_id().get_identifier()] = SUBMITTED", "response": "Submits an answer to an item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_first_unanswered_question(self, assessment_section_id):\n        questions = self.get_unanswered_questions(assessment_section_id)\n        if not questions.available():\n            raise errors.IllegalState('There are no more unanswered questions available')\n        return questions.next()", "response": "Gets the first unanswered question in this assesment section."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if there is a next unanswered question following the given question Id.", "response": "def has_next_unanswered_question(self, assessment_section_id, item_id):\n        \"\"\"Tests if there is a next unanswered question following the given question ``Id``.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        return: (boolean) - ``true`` if there is a next unanswered\n                question, ``false`` otherwise\n        raise:  IllegalState - ``has_assessment_section_begun() is false\n                or is_assessment_section_over() is true``\n        raise:  NotFound - ``assessment_section_id or item_id is not\n                found, or item_id not part of assessment_section_id``\n        raise:  NullArgument - ``assessment_section_id or item_id is\n                null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # There's probably a more efficient way to implement this:\n        try:\n            self.get_next_unanswered_question(assessment_section_id, item_id)\n        except errors.IllegalState:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the next unanswered question in this assesment section.", "response": "def get_next_unanswered_question(self, assessment_section_id, item_id):\n        \"\"\"Gets the next unanswered question in this assesment section.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        return: (osid.assessment.Question) - the next unanswered\n                question\n        raise:  IllegalState - ``has_next_unanswered_question()`` is\n                ``false``\n        raise:  NotFound - ``assessment_section_id or item_id is not\n                found, or item_id not part of assessment_section_id``\n        raise:  NullArgument - ``assessment_section_id or item_id is\n                null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Or this could call through to get_next_question in the section\n        questions = self.get_unanswered_questions(assessment_section_id)\n        for question in questions:\n            if question.get_id() == item_id:\n                if questions.available():\n                    return questions.next()\n                else:\n                    raise errors.IllegalState('No next unanswered question is available')\n        raise errors.NotFound('item_id is not found in Section')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if there is a previous unanswered question preceeding the given question Id.", "response": "def has_previous_unanswered_question(self, assessment_section_id, item_id):\n        \"\"\"Tests if there is a previous unanswered question preceeding the given question ``Id``.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        return: (boolean) - ``true`` if there is a previous unanswered\n                question, ``false`` otherwise\n        raise:  IllegalState - ``has_assessment_section_begun() is false\n                or is_assessment_section_over() is true``\n        raise:  NotFound - ``assessment_section_id or item_id is not\n                found, or item_id not part of assessment_section_id``\n        raise:  NullArgument - ``assessment_section_id or item_id is\n                null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # There's probably a more efficient way to implement this:\n        try:\n            self.get_previous_unanswered_question(assessment_section_id, item_id)\n        except errors.IllegalState:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_previous_unanswered_question(self, assessment_section_id, item_id):\n        # Or this could call through to get_next_question in the section with reverse=True\n        questions = self.get_unanswered_questions(assessment_section_id)\n        previous_question = questions.next()\n        if previous_question.get_id() == item_id:\n            raise errors.IllegalState('No previous unanswered question is available')\n        for question in questions:\n            if question.get_id() == item_id:\n                return previous_question\n            else:\n                previous_question = question\n        raise errors.NotFound('item_id is not found in Section')", "response": "Gets the previous unanswered question in this assesment section."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_response(self, assessment_section_id, item_id):\n        return self.get_assessment_section(assessment_section_id).get_response(question_id=item_id)", "response": "Gets the submitted response to the associated item."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nclears the response to an item", "response": "def clear_response(self, assessment_section_id, item_id):\n        \"\"\"Clears the response to an item The item appears as unanswered.\n\n        If no response exists, the method simply returns.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        raise:  IllegalState - ``has_assessment_section_begun() is false\n                or is_assessment_section_over() is true``\n        raise:  NotFound - ``assessment_section_id or item_id is not\n                found, or item_id not part of assessment_section_id``\n        raise:  NullArgument - ``assessment_section_id or item_id is\n                null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (not self.has_assessment_section_begun(assessment_section_id) or\n                self.is_assessment_section_over(assessment_section_id)):\n            raise errors.IllegalState()\n        # Should probably check to see if responses can be cleared, but how?\n        self.get_assessment_section(assessment_section_id).submit_response(item_id, None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nindicate an assessment section is complete. Finished sections may or may not allow new or updated responses. arg: assessment_section_id (osid.id.Id): ``Id`` of the ``AssessmentSection`` raise: IllegalState - ``has_assessment_section_begun()`` is ``false or is_assessment_section_over()`` is ``true`` raise: NotFound - ``assessment_section_id`` is not found raise: NullArgument - ``assessment_section_id`` is ``null`` raise: OperationFailed - unable to complete request raise: PermissionDenied - authorization failure *compliance: mandatory -- This method must be implemented.*", "response": "def finish_assessment_section(self, assessment_section_id):\n        \"\"\"Indicates an assessment section is complete.\n\n        Finished sections may or may not allow new or updated responses.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        raise:  IllegalState - ``has_assessment_section_begun()`` is\n                ``false or is_assessment_section_over()`` is ``true``\n        raise:  NotFound - ``assessment_section_id`` is not found\n        raise:  NullArgument - ``assessment_section_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (not self.has_assessment_section_begun(assessment_section_id) or\n                self.is_assessment_section_over(assessment_section_id)):\n            raise errors.IllegalState()\n        self.get_assessment_section(assessment_section_id).finish()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_answer_available(self, assessment_section_id, item_id):\n        # Note: we need more settings elsewhere to indicate answer available conditions\n        # This makes the simple assumption that answers are available only when\n        # a response has been submitted for an Item.\n        try:\n            response = self.get_response(assessment_section_id, item_id)\n            # need to invoke something like .object_map before\n            # a \"null\" response throws IllegalState\n            response.object_map\n        except errors.IllegalState:\n            return False\n        else:\n            return True", "response": "Tests if an answer is available for the given item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the acceptable answers to the associated item.", "response": "def get_answers(self, assessment_section_id, item_id):\n        \"\"\"Gets the acceptable answers to the associated item.\n\n        arg:    assessment_section_id (osid.id.Id): ``Id`` of the\n                ``AssessmentSection``\n        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        return: (osid.assessment.AnswerList) - the answers\n        raise:  IllegalState - ``is_answer_available()`` is ``false``\n        raise:  NotFound - ``assessment_section_id or item_id is not\n                found, or item_id not part of assessment_section_id``\n        raise:  NullArgument - ``assessment_section_id or item_id is\n                null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.is_answer_available(assessment_section_id, item_id):\n            return self.get_assessment_section(assessment_section_id).get_answers(question_id=item_id)\n        raise errors.IllegalState()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef finish_assessment(self, assessment_taken_id):\n        assessment_taken = self._get_assessment_taken(assessment_taken_id)\n        assessment_taken_map = assessment_taken._my_map\n        if assessment_taken.has_started() and not assessment_taken.has_ended():\n            assessment_taken_map['completionTime'] = DateTime.utcnow()\n            assessment_taken_map['ended'] = True\n            collection = JSONClientValidated('assessment',\n                                             collection='AssessmentTaken',\n                                             runtime=self._runtime)\n            collection.save(assessment_taken_map)\n        else:\n            raise errors.IllegalState()", "response": "Indicates the entire assessment is complete."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_items(self, assessment_taken_id):\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        taken_lookup_session = mgr.get_assessment_taken_lookup_session(proxy=self._proxy)\n        taken_lookup_session.use_federated_bank_view()\n        taken = taken_lookup_session.get_assessment_taken(assessment_taken_id)\n        ils = get_item_lookup_session(runtime=self._runtime, proxy=self._proxy)\n        ils.use_federated_bank_view()\n        item_list = []\n        if 'sections' in taken._my_map:\n            for section_id in taken._my_map['sections']:\n                section = get_assessment_section(Id(section_id),\n                                                 runtime=self._runtime,\n                                                 proxy=self._proxy)\n                for question in section._my_map['questions']:\n                    item_list.append(ils.get_item(Id(question['questionId'])))\n        return ItemList(item_list)", "response": "Gets the items questioned in an assessment."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_responses(self, assessment_taken_id):\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        taken_lookup_session = mgr.get_assessment_taken_lookup_session(proxy=self._proxy)\n        taken_lookup_session.use_federated_bank_view()\n        taken = taken_lookup_session.get_assessment_taken(assessment_taken_id)\n        response_list = OsidListList()\n        if 'sections' in taken._my_map:\n            for section_id in taken._my_map['sections']:\n                section = get_assessment_section(Id(section_id),\n                                                 runtime=self._runtime,\n                                                 proxy=self._proxy)\n                response_list.append(section.get_responses())\n        return ResponseList(response_list)", "response": "Gets the submitted responses."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the Item specified by its Id.", "response": "def get_item(self, item_id):\n        \"\"\"Gets the ``Item`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Item`` may have a different\n        ``Id`` than requested, such as the case where a duplicate ``Id``\n        was assigned to an ``Item`` and retained for compatibility.\n\n        arg:    item_id (osid.id.Id): the ``Id`` of the ``Item`` to\n                retrieve\n        return: (osid.assessment.Item) - the returned ``Item``\n        raise:  NotFound - no ``Item`` found with the given ``Id``\n        raise:  NullArgument - ``item_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(item_id, 'assessment').get_identifier())},\n                 **self._view_filter()))\n        return objects.Item(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget an ItemList corresponding to the given IdList.", "response": "def get_items_by_ids(self, item_ids):\n        \"\"\"Gets an ``ItemList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the items\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Items`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set.\n\n        arg:    item_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n        return: (osid.assessment.ItemList) - the returned ``Item`` list\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``item_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in item_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'assessment').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.ItemList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget an ItemList corresponding to the given assessment item genus Type which does not include assessment items of genus types derived from the specified Type.", "response": "def get_items_by_genus_type(self, item_genus_type):\n        \"\"\"Gets an ``ItemList`` corresponding to the given assessment item genus ``Type`` which does not include assessment items of genus types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known assessment\n        items or an error results. Otherwise, the returned list may\n        contain only those assessment items that are accessible through\n        this session.\n\n        arg:    item_genus_type (osid.type.Type): an assessment item\n                genus type\n        return: (osid.assessment.ItemList) - the returned ``Item`` list\n        raise:  NullArgument - ``item_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(item_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.ItemList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_items(self):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.ItemList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets all Items in the current session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_items_by_query(self, item_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in item_query._query_terms:\n            if '$in' in item_query._query_terms[term] and '$nin' in item_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': item_query._query_terms[term]['$in']}},\n                             {term: {'$nin': item_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: item_query._query_terms[term]})\n        for term in item_query._keyword_terms:\n            or_list.append({term: item_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('assessment',\n                                             collection='Item',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.ItemList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of Items matching the given item query."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_items_by_search(self, item_query, item_search):\n        # Implemented from template for\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        # Copied from osid.resource.ResourceQuerySession.get_resources_by_query_template\n        and_list = list()\n        or_list = list()\n        for term in item_query._query_terms:\n            and_list.append({term: item_query._query_terms[term]})\n        for term in item_query._keyword_terms:\n            or_list.append({term: item_query._keyword_terms[term]})\n        if item_search._id_list is not None:\n            identifiers = [ObjectId(i.identifier) for i in item_search._id_list]\n            and_list.append({'_id': {'$in': identifiers}})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if item_search.start is not None and item_search.end is not None:\n            result = collection.find(query_terms)[item_search.start:item_search.end]\n        else:\n            result = collection.find(query_terms)\n        return searches.ItemSearchResults(result, dict(item_query._query_terms), runtime=self._runtime)", "response": "Gets the items matching the given search query."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_item_form_for_create(self, item_record_types):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in item_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if item_record_types == []:\n            obj_form = objects.ItemForm(\n                bank_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.ItemForm(\n                bank_id=self._catalog_id,\n                record_types=item_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the assessment item form for creating new assessment items."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_item(self, item_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if not isinstance(item_form, ABCItemForm):\n            raise errors.InvalidArgument('argument type is not an ItemForm')\n        if item_form.is_for_update():\n            raise errors.InvalidArgument('the ItemForm is for update only, not create')\n        try:\n            if self._forms[item_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('item_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('item_form did not originate from this session')\n        if not item_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(item_form._my_map)\n\n        self._forms[item_form.get_id().get_identifier()] = CREATED\n        result = objects.Item(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new Item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate an existing item.", "response": "def update_item(self, item_form):\n        \"\"\"Updates an existing item.\n\n        arg:    item_form (osid.assessment.ItemForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - ``item_form`` already used in an update\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``item_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``item_form`` did not originate from\n                ``get_item_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if not isinstance(item_form, ABCItemForm):\n            raise errors.InvalidArgument('argument type is not an ItemForm')\n        if not item_form.is_for_update():\n            raise errors.InvalidArgument('the ItemForm is for update only, not create')\n        try:\n            if self._forms[item_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('item_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('item_form did not originate from this session')\n        if not item_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(item_form._my_map)\n\n        self._forms[item_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Item(\n            osid_object_map=item_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_item(self, item_id):\n        if not isinstance(item_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        # This needs to be updated to actually check for AssessmentsTaken (and does that find even work?)\n        if collection.find({'itemIds': str(item_id)}).count() != 0:\n            raise errors.IllegalState('this Item is being used in one or more Assessments')\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        item_map = collection.find_one({'_id': ObjectId(item_id.get_identifier())})\n        objects.Item(osid_object_map=item_map,\n                     runtime=self._runtime,\n                     proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(item_id.get_identifier())})", "response": "Deletes the Item identified by the given Id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef alias_item(self, item_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=item_id, equivalent_id=alias_id)", "response": "Adds an Id to an Item for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_question_form_for_create(self, item_id, question_record_types):\n        # Implemented from template for\n        # osid.learning.ActivityAdminSession.get_activity_form_for_create_template\n\n        if not isinstance(item_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in question_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if question_record_types == []:\n            # WHY are we passing bank_id = self._catalog_id below, seems redundant:\n            obj_form = objects.QuestionForm(\n                bank_id=self._catalog_id,\n                item_id=item_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.QuestionForm(\n                bank_id=self._catalog_id,\n                record_types=question_record_types,\n                item_id=item_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the question form for creating new questions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the question form for updating an existing question.", "response": "def get_question_form_for_update(self, question_id):\n        \"\"\"Gets the question form for updating an existing question.\n\n        A new question form should be requested for each update\n        transaction.\n\n        arg:    question_id (osid.id.Id): the ``Id`` of the ``Question``\n        return: (osid.assessment.QuestionForm) - the question form\n        raise:  NotFound - ``question_id`` is not found\n        raise:  NullArgument - ``question_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if not isinstance(question_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        document = collection.find_one({'question._id': ObjectId(question_id.get_identifier())})\n        obj_form = objects.QuestionForm(osid_object_map=document['question'],\n                                        runtime=self._runtime,\n                                        proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not UPDATED\n        return obj_form"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_question(self, question_form):\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if not isinstance(question_form, ABCQuestionForm):\n            raise errors.InvalidArgument('argument type is not an QuestionForm')\n        if not question_form.is_for_update():\n            raise errors.InvalidArgument('the QuestionForm is for update only, not create')\n        try:\n            if self._forms[question_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('question_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('question_form did not originate from this session')\n        if not question_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        item_id = Id(question_form._my_map['itemId']).get_identifier()\n        item = collection.find_one({'$and': [{'_id': ObjectId(item_id)},\n                                   {'assigned' + self._catalog_name + 'Ids': {'$in': [str(self._catalog_id)]}}]})\n        item['question'] = question_form._my_map\n        try:\n            collection.save(item)\n        except:  # what exceptions does mongodb save raise?\n            raise errors.OperationFailed()\n        self._forms[question_form.get_id().get_identifier()] = UPDATED\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Question(osid_object_map=question_form._my_map,\n                                runtime=self._runtime,\n                                proxy=self._proxy)", "response": "Updates an existing question."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the question identified by the given Id.", "response": "def delete_question(self, question_id):\n        \"\"\"Deletes the ``Question`` identified by the given ``Id``.\n\n        arg:    question_id (osid.id.Id): the ``Id`` of the ``Question``\n                to delete\n        raise:  NotFound - a ``Question`` was not found identified by\n                the given ``Id``\n        raise:  NullArgument - ``question_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if not isinstance(question_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        item = collection.find_one({'question._id': ObjectId(question_id.get_identifier())})\n\n        item['question'] = None\n        collection.save(item)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_answer(self, answer_form):\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.create_asset_content_template\n        from dlkit.abstract_osid.assessment.objects import AnswerForm as ABCAnswerForm\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if not isinstance(answer_form, ABCAnswerForm):\n            raise errors.InvalidArgument('argument type is not an AnswerForm')\n        if answer_form.is_for_update():\n            raise errors.InvalidArgument('the AnswerForm is for update only, not create')\n        try:\n            if self._forms[answer_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('answer_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('answer_form did not originate from this session')\n        if not answer_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        answer_form._my_map['_id'] = ObjectId()\n        item_id = Id(answer_form._my_map['itemId']).get_identifier()\n        item = collection.find_one(\n            {'$and': [{'_id': ObjectId(item_id)},\n                      {'assigned' + self._catalog_name + 'Ids': {'$in': [str(self._catalog_id)]}}]})\n        item['answers'].append(answer_form._my_map)\n        result = collection.save(item)\n\n        self._forms[answer_form.get_id().get_identifier()] = CREATED\n        from .objects import Answer\n        return Answer(\n            osid_object_map=answer_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Creates a new Answer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating an existing answer.", "response": "def update_answer(self, answer_form):\n        \"\"\"Updates an existing answer.\n\n        arg:    answer_form (osid.assessment.AnswerForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - ``answer_form`` already used in an update\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``answer_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``answer_form`` did not originate from\n                ``get_answer_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.update_asset_content_template\n        from dlkit.abstract_osid.assessment.objects import AnswerForm as ABCAnswerForm\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if not isinstance(answer_form, ABCAnswerForm):\n            raise errors.InvalidArgument('argument type is not an AnswerForm')\n        if not answer_form.is_for_update():\n            raise errors.InvalidArgument('the AnswerForm is for update only, not create')\n        try:\n            if self._forms[answer_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('answer_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('answer_form did not originate from this session')\n        if not answer_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        item_id = Id(answer_form._my_map['itemId']).get_identifier()\n        item = collection.find_one(\n            {'$and': [{'_id': ObjectId(item_id)},\n                      {'assigned' + self._catalog_name + 'Ids': {'$in': [str(self._catalog_id)]}}]})\n        index = 0\n        found = False\n        for i in item['answers']:\n            if i['_id'] == ObjectId(answer_form._my_map['_id']):\n                item['answers'].pop(index)\n                item['answers'].insert(index, answer_form._my_map)\n                found = True\n                break\n            index += 1\n        if not found:\n            raise errors.NotFound()\n        try:\n            collection.save(item)\n        except:  # what exceptions does mongodb save raise?\n            raise errors.OperationFailed()\n        self._forms[answer_form.get_id().get_identifier()] = UPDATED\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        from .objects import Answer\n\n        return Answer(\n            osid_object_map=answer_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes the Answer identified by the given Id.", "response": "def delete_answer(self, answer_id):\n        \"\"\"Deletes the ``Answer`` identified by the given ``Id``.\n\n        arg:    answer_id (osid.id.Id): the ``Id`` of the ``Answer`` to\n                delete\n        raise:  NotFound - an ``Answer`` was not found identified by the\n                given ``Id``\n        raise:  NullArgument - ``answer_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.delete_asset_content_template\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        from .objects import Answer\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        if not isinstance(answer_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        item = collection.find_one({'answers._id': ObjectId(answer_id.get_identifier())})\n\n        index = 0\n        found = False\n        for i in item['answers']:\n            if i['_id'] == ObjectId(answer_id.get_identifier()):\n                answer_map = item['answers'].pop(index)\n            index += 1\n            found = True\n        if not found:\n            raise errors.OperationFailed()\n        Answer(\n            osid_object_map=answer_map,\n            runtime=self._runtime,\n            proxy=self._proxy)._delete()\n        collection.save(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_for_deleted_item(self, item_id):\n        # Implemented from template for\n        # osid.resource.ResourceNotificationSession.register_for_deleted_resource\n        if not MONGO_LISTENER.receivers[self._ns][self._receiver]['d']:\n            MONGO_LISTENER.receivers[self._ns][self._receiver]['d'] = []\n        if isinstance(MONGO_LISTENER.receivers[self._ns][self._receiver]['d'], list):\n            MONGO_LISTENER.receivers[self._ns][self._receiver]['d'].append(item_id.get_identifier())", "response": "Registers for notification of a deleted assessment item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the list of Item Id s associated with a Bank.", "response": "def get_item_ids_by_bank(self, bank_id):\n        \"\"\"Gets the list of ``Item``  ``Ids`` associated with a ``Bank``.\n\n        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n        return: (osid.id.IdList) - list of related item ``Ids``\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for item in self.get_items_by_bank(bank_id):\n            id_list.append(item.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the list of Items associated with a Bank.", "response": "def get_items_by_bank(self, bank_id):\n        \"\"\"Gets the list of ``Items`` associated with a ``Bank``.\n\n        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n        return: (osid.assessment.ItemList) - list of related items\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_item_lookup_session_for_bank(bank_id, proxy=self._proxy)\n        lookup_session.use_isolated_bank_view()\n        return lookup_session.get_items()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the list of Item Ids corresponding to a list of Banks.", "response": "def get_item_ids_by_banks(self, bank_ids):\n        \"\"\"Gets the list of ``Item Ids`` corresponding to a list of ``Banks``.\n\n        arg:    bank_ids (osid.id.IdList): list of bank ``Ids``\n        return: (osid.id.IdList) - list of bank ``Ids``\n        raise:  NullArgument - ``bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - assessment failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for item in self.get_items_by_banks(bank_ids):\n            id_list.append(item.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_items_by_banks(self, bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        item_list = []\n        for bank_id in bank_ids:\n            item_list += list(\n                self.get_items_by_bank(bank_id))\n        return objects.ItemList(item_list)", "response": "Gets the list of Items corresponding to a list of Banks."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the list of Bank Id s mapped to an Item.", "response": "def get_bank_ids_by_item(self, item_id):\n        \"\"\"Gets the list of ``Bank``  ``Ids`` mapped to an ``Item``.\n\n        arg:    item_id (osid.id.Id): ``Id`` of an ``Item``\n        return: (osid.id.IdList) - list of bank ``Ids``\n        raise:  NotFound - ``item_id`` is not found\n        raise:  NullArgument - ``item_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - assessment failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_item_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_bank_view()\n        item = lookup_session.get_item(item_id)\n        id_list = []\n        for idstr in item._my_map['assignedBankIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the list of Banks mapped to an Item.", "response": "def get_banks_by_item(self, item_id):\n        \"\"\"Gets the list of ``Banks`` mapped to an ``Item``.\n\n        arg:    item_id (osid.id.Id): ``Id`` of an ``Item``\n        return: (osid.assessment.BankList) - list of banks\n        raise:  NotFound - ``item_id`` is not found\n        raise:  NullArgument - ``item_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - assessment failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        return lookup_session.get_banks_by_ids(\n            self.get_bank_ids_by_item(item_id))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assign_item_to_bank(self, item_id, bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._assign_object_to_catalog(item_id, bank_id)", "response": "Adds an existing Item to a Bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unassign_item_from_bank(self, item_id, bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._unassign_object_from_catalog(item_id, bank_id)", "response": "Removes an Item from a Bank."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the Assessment specified by its Id.", "response": "def get_assessment(self, assessment_id):\n        \"\"\"Gets the ``Assessment`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Assessment`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``Assessment`` and retained\n        for compatibility.\n\n        arg:    assessment_id (osid.id.Id): ``Id`` of the ``Assessment``\n        return: (osid.assessment.Assessment) - the assessment\n        raise:  NotFound - ``assessment_id`` not found\n        raise:  NullArgument - ``assessment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='Assessment',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(assessment_id, 'assessment').get_identifier())},\n                 **self._view_filter()))\n        return objects.Assessment(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets an AssessmentList corresponding to the given IdList.", "response": "def get_assessments_by_ids(self, assessment_ids):\n        \"\"\"Gets an ``AssessmentList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the\n        assessments specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Assessments`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set.\n\n        arg:    assessment_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n        return: (osid.assessment.AssessmentList) - the returned\n                ``Assessment`` list\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``assessment_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - assessment failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='Assessment',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in assessment_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'assessment').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.AssessmentList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting an AssessmentList corresponding to the given assessment genus Type which does not include assessments of types derived from the specified Type.", "response": "def get_assessments_by_genus_type(self, assessment_genus_type):\n        \"\"\"Gets an ``AssessmentList`` corresponding to the given assessment genus ``Type`` which does not include assessments of types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known\n        assessments or an error results. Otherwise, the returned list\n        may contain only those assessments that are accessible through\n        this session.\n\n        arg:    assessment_genus_type (osid.type.Type): an assessment\n                genus type\n        return: (osid.assessment.AssessmentList) - the returned\n                ``Assessment`` list\n        raise:  NullArgument - ``assessment_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='Assessment',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(assessment_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AssessmentList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all assessments in the current session.", "response": "def get_assessments(self):\n        \"\"\"Gets all ``Assessments``.\n\n        In plenary mode, the returned list contains all known\n        assessments or an error results. Otherwise, the returned list\n        may contain only those assessments that are accessible through\n        this session.\n\n        return: (osid.assessment.AssessmentList) - a list of\n                ``Assessments``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='Assessment',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.AssessmentList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of Assessments matching the given assessment query.", "response": "def get_assessments_by_query(self, assessment_query):\n        \"\"\"Gets a list of ``Assessments`` matching the given assessment query.\n\n        arg:    assessment_query (osid.assessment.AssessmentQuery): the\n                assessment query\n        return: (osid.assessment.AssessmentList) - the returned\n                ``AssessmentList``\n        raise:  NullArgument - ``assessment_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_query`` is not of this\n                service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        \"\"\"Gets a list of ``Assessments`` matching the given assessment query.\n\n        arg:    assessment_query (osid.assessment.AssessmentQuery): the\n                assessment query\n        return: (osid.assessment.AssessmentList) - the returned\n                ``AssessmentList``\n        raise:  NullArgument - ``assessment_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_query`` is not of this\n                service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if 'assessmentOfferedId' in assessment_query._query_terms:\n            collection = JSONClientValidated('assessment',\n                                             collection='AssessmentOffered',\n                                             runtime=self._runtime)\n            match = '$in' in assessment_query._query_terms['assessmentOfferedId'].keys()\n            if match:\n                match_identifiers = [ObjectId(Id(i).identifier) for i in assessment_query._query_terms['assessmentOfferedId']['$in']]\n                query = {'$in': match_identifiers}\n            else:\n                match_identifiers = [ObjectId(Id(i).identifier) for i in assessment_query._query_terms['assessmentOfferedId']['$in']]\n                query = {'$nin': match_identifiers}\n\n            result = collection.find({\n                \"_id\": query\n            })\n\n            assessment_ids = [ObjectId(Id(r['assessmentId']).identifier) for r in result]\n\n            collection = JSONClientValidated('assessment',\n                                             collection='Assessment',\n                                             runtime=self._runtime)\n            result = collection.find({\n                \"_id\": {\"$in\": assessment_ids}\n            })\n            return objects.AssessmentList(result, runtime=self._runtime, proxy=self._proxy)\n        else:\n            # and_list = list()\n            # or_list = list()\n            # for term in assessment_query._query_terms:\n            #     and_list.append({term: assessment_query._query_terms[term]})\n            # for term in assessment_query._keyword_terms:\n            #     or_list.append({term: assessment_query._keyword_terms[term]})\n            # if or_list:\n            #     and_list.append({'$or': or_list})\n            # view_filter = self._view_filter()\n            # if view_filter:\n            #     and_list.append(view_filter)\n            # if and_list:\n            #     query_terms = {'$and': and_list}\n            #\n            #     collection = JSONClientValidated('assessment',\n            #                                      collection='Assessment',\n            #                                      runtime=self._runtime)\n            #     result = collection.find(query_terms).sort('_id', DESCENDING)\n            # else:\n            #     result = []\n            # return objects.AssessmentList(result, runtime=self._runtime, proxy=self._proxy)\n            and_list = list()\n            or_list = list()\n            for term in assessment_query._query_terms:\n                if '$in' in assessment_query._query_terms[term] and '$nin' in assessment_query._query_terms[term]:\n                    and_list.append(\n                        {'$or': [{term: {'$in': assessment_query._query_terms[term]['$in']}},\n                                 {term: {'$nin': assessment_query._query_terms[term]['$nin']}}]})\n                else:\n                    and_list.append({term: assessment_query._query_terms[term]})\n            for term in assessment_query._keyword_terms:\n                or_list.append({term: assessment_query._keyword_terms[term]})\n            if or_list:\n                and_list.append({'$or': or_list})\n            view_filter = self._view_filter()\n            if view_filter:\n                and_list.append(view_filter)\n            if and_list:\n                query_terms = {'$and': and_list}\n                collection = JSONClientValidated('assessment',\n                                                 collection='Assessment',\n                                                 runtime=self._runtime)\n                result = collection.find(query_terms).sort('_id', DESCENDING)\n            else:\n                result = []\n            return objects.AssessmentList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the assessment form for creating new assessments.", "response": "def get_assessment_form_for_create(self, assessment_record_types):\n        \"\"\"Gets the assessment form for creating new assessments.\n\n        A new form should be requested for each create transaction.\n\n        arg:    assessment_record_types (osid.type.Type[]): array of\n                assessment record types to be included in the create\n                operation or an empty list if none\n        return: (osid.assessment.AssessmentForm) - the assessment form\n        raise:  NullArgument - ``assessment_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - unable to get form for requested record\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in assessment_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if assessment_record_types == []:\n            obj_form = objects.AssessmentForm(\n                bank_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.AssessmentForm(\n                bank_id=self._catalog_id,\n                record_types=assessment_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_assessment(self, assessment_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('assessment',\n                                         collection='Assessment',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_form, ABCAssessmentForm):\n            raise errors.InvalidArgument('argument type is not an AssessmentForm')\n        if assessment_form.is_for_update():\n            raise errors.InvalidArgument('the AssessmentForm is for update only, not create')\n        try:\n            if self._forms[assessment_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('assessment_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('assessment_form did not originate from this session')\n        if not assessment_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(assessment_form._my_map)\n\n        self._forms[assessment_form.get_id().get_identifier()] = CREATED\n        result = objects.Assessment(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new Assessment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_assessment(self, assessment_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('assessment',\n                                         collection='Assessment',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_form, ABCAssessmentForm):\n            raise errors.InvalidArgument('argument type is not an AssessmentForm')\n        if not assessment_form.is_for_update():\n            raise errors.InvalidArgument('the AssessmentForm is for update only, not create')\n        try:\n            if self._forms[assessment_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('assessment_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('assessment_form did not originate from this session')\n        if not assessment_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(assessment_form._my_map)\n\n        self._forms[assessment_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Assessment(\n            osid_object_map=assessment_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Updates an existing assessment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_assessment(self, assessment_id):\n        \"\"\"Delete all the children AssessmentParts recursively, too\"\"\"\n        def remove_children_parts(parent_id):\n            part_collection = JSONClientValidated('assessment_authoring',\n                                                  collection='AssessmentPart',\n                                                  runtime=self._runtime)\n            if 'assessment.Assessment' in parent_id:\n                query = {\"assessmentId\": parent_id}\n            else:\n                query = {\"assessmentPartId\": parent_id}\n\n            # need to account for magic parts ...\n            for part in part_collection.find(query):\n                part = assessment_authoring_objects.AssessmentPart(osid_object_map=part,\n                                                                   runtime=self._runtime,\n                                                                   proxy=self._proxy)\n                apls = get_assessment_part_lookup_session(runtime=self._runtime,\n                                                          proxy=self._proxy)\n                apls.use_unsequestered_assessment_part_view()\n                apls.use_federated_bank_view()\n                part = apls.get_assessment_part(part.ident)\n                try:\n                    part.delete()\n                except AttributeError:\n                    part_collection.delete_one({'_id': ObjectId(part.ident.get_identifier())})\n                remove_children_parts(str(part.ident))\n\n        if not isinstance(assessment_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        if collection.find({'assessmentId': str(assessment_id)}).count() != 0:\n            raise errors.IllegalState('there are still AssessmentsOffered associated with this Assessment')\n        collection = JSONClientValidated('assessment',\n                                         collection='Assessment',\n                                         runtime=self._runtime)\n        collection.delete_one({'_id': ObjectId(assessment_id.get_identifier())})\n        remove_children_parts(str(assessment_id))", "response": "Deletes an ``Assessment``.\n\n        arg:    assessment_id (osid.id.Id): the ``Id`` of the\n                ``Assessment`` to remove\n        raise:  NotFound - ``assessment_id`` not found\n        raise:  NullArgument - ``assessment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding an Id to an Assessment in the specifed base.", "response": "def alias_assessment(self, assessment_id, alias_id):\n        \"\"\"Adds an ``Id`` to an ``Assessment`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``Assessment`` is determined by the\n        provider. The new ``Id`` is an alias to the primary ``Id``. If\n        the alias is a pointer to another assessment, it is reassigned\n        to the given assessment ``Id``.\n\n        arg:    assessment_id (osid.id.Id): the ``Id`` of an\n                ``Assessment``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is in use as a primary\n                ``Id``\n        raise:  NotFound - ``assessment_id`` not found\n        raise:  NullArgument - ``assessment_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=assessment_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_assessment_ids_by_bank(self, bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for assessment in self.get_assessments_by_bank(bank_id):\n            id_list.append(assessment.get_id())\n        return IdList(id_list)", "response": "Gets the list of Assessment Ids associated with a Bank."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_assessments_by_bank(self, bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_assessment_lookup_session_for_bank(bank_id, proxy=self._proxy)\n        lookup_session.use_isolated_bank_view()\n        return lookup_session.get_assessments()", "response": "Gets the list of Assessments associated with a Bank."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assessment_ids_by_banks(self, bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for assessment in self.get_assessments_by_banks(bank_ids):\n            id_list.append(assessment.get_id())\n        return IdList(id_list)", "response": "Gets the list of Assessment Ids corresponding to a list of Banks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessments_by_banks(self, bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        assessment_list = []\n        for bank_id in bank_ids:\n            assessment_list += list(\n                self.get_assessments_by_bank(bank_id))\n        return objects.AssessmentList(assessment_list)", "response": "Gets the list of Assessments corresponding to a list of Banks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_bank_ids_by_assessment(self, assessment_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_assessment_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_bank_view()\n        assessment = lookup_session.get_assessment(assessment_id)\n        id_list = []\n        for idstr in assessment._my_map['assignedBankIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)", "response": "Gets the list of Bank Ids mapped to an Assessment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_banks_by_assessment(self, assessment_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        return lookup_session.get_banks_by_ids(\n            self.get_bank_ids_by_assessment(assessment_id))", "response": "Gets the list of Banks mapped to an Assessment."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an existing Assessment to an Bank.", "response": "def assign_assessment_to_bank(self, assessment_id, bank_id):\n        \"\"\"Adds an existing ``Assessment`` to a ``Bank``.\n\n        arg:    assessment_id (osid.id.Id): the ``Id`` of the\n                ``Assessment``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        raise:  AlreadyExists - ``assessment_id`` is already assigned to\n                ``bank_id``\n        raise:  NotFound - ``assessment_id`` or ``bank_id`` not found\n        raise:  NullArgument - ``assessment_id`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._assign_object_to_catalog(assessment_id, bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves an Assessment from an Bank.", "response": "def unassign_assessment_from_bank(self, assessment_id, bank_id):\n        \"\"\"Removes an ``Assessment`` from a ``Bank``.\n\n        arg:    assessment_id (osid.id.Id): the ``Id`` of the\n                ``Assessment``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        raise:  NotFound - ``assessment_id`` or ``bank_id`` not found or\n                ``assessment_id`` not assigned to ``bank_id``\n        raise:  NullArgument - ``assessment_id`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._unassign_object_from_catalog(assessment_id, bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the items in sequence from an Assessment", "response": "def get_items(self, assessment_id):\n        \"\"\"Gets the items in sequence from an assessment.\n\n        arg:    assessment_id (osid.id.Id): the ``Id`` of the\n                ``Assessment``\n        return: (osid.assessment.ItemList) - list of items\n        raise:  NotFound - ``assessmentid`` not found\n        raise:  NullArgument - ``assessment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if assessment_id.get_identifier_namespace() != 'assessment.Assessment':\n            raise errors.InvalidArgument\n        return self._part_item_session.get_assessment_part_items(self._get_first_part_id(assessment_id))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an existing Item to an Assessment.", "response": "def add_item(self, assessment_id, item_id):\n        \"\"\"Adds an existing ``Item`` to an assessment.\n\n        arg:    assessment_id (osid.id.Id): the ``Id`` of the\n                ``Assessment``\n        arg:    item_id (osid.id.Id): the ``Id`` of the ``Item``\n        raise:  NotFound - ``assessment_id`` or ``item_id`` not found\n        raise:  NullArgument - ``assessment_id`` or ``item_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if assessment_id.get_identifier_namespace() != 'assessment.Assessment':\n            raise errors.InvalidArgument\n        self._part_item_design_session.add_item(item_id, self._get_first_part_id(assessment_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves an existing item to follow another item in an assessment.", "response": "def move_item(self, assessment_id, item_id, preceeding_item_id):\n        \"\"\"Moves an existing item to follow another item in an assessment.\n\n        arg:    assessment_id (osid.id.Id): the ``Id`` of the\n                ``Assessment``\n        arg:    item_id (osid.id.Id): the ``Id`` of an ``Item``\n        arg:    preceeding_item_id (osid.id.Id): the ``Id`` of a\n                preceeding ``Item`` in the sequence\n        raise:  NotFound - ``assessment_id`` is not found, or\n                ``item_id`` or ``preceeding_item_id`` not on\n                ``assessment_id``\n        raise:  NullArgument - ``assessment_id, item_id`` or\n                ``preceeding_item_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if assessment_id.get_identifier_namespace() != 'assessment.Assessment':\n            raise errors.InvalidArgument\n        self._part_item_design_session.move_item_behind(item_id, self._get_first_part_id(assessment_id), preceeding_item_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nordering items in an assessment.", "response": "def order_items(self, item_ids, assessment_id):\n        \"\"\"Sequences existing items in an assessment.\n\n        arg:    item_ids (osid.id.Id[]): the ``Id`` of the ``Items``\n        arg:    assessment_id (osid.id.Id): the ``Id`` of the\n                ``Assessment``\n        raise:  NotFound - ``assessment_id`` is not found or an\n                ``item_id`` is not on ``assessment_id``\n        raise:  NullArgument - ``assessment_id`` or ``item_ids`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if assessment_id.get_identifier_namespace() != 'assessment.Assessment':\n            raise errors.InvalidArgument\n        self._part_item_design_session.order_items(item_ids, self._get_first_part_id(assessment_id))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the AssessmentOffered specified by its Id.", "response": "def get_assessment_offered(self, assessment_offered_id):\n        \"\"\"Gets the ``AssessmentOffered`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``AssessmentOffered`` may have\n        a different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to an ``AssessmentOffered`` and\n        retained for compatibility.\n\n        arg:    assessment_offered_id (osid.id.Id): ``Id`` of the\n                ``AssessmentOffered``\n        return: (osid.assessment.AssessmentOffered) - the assessment\n                offered\n        raise:  NotFound - ``assessment_offered_id`` not found\n        raise:  NullArgument - ``assessment_offered_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(assessment_offered_id, 'assessment').get_identifier())},\n                 **self._view_filter()))\n        return objects.AssessmentOffered(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting an AssessmentOfferedList corresponding to the given IdList.", "response": "def get_assessments_offered_by_ids(self, assessment_offered_ids):\n        \"\"\"Gets an ``AssessmentOfferedList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the\n        assessments specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``AssessmentOffered`` objects may be omitted from\n        the list and may present the elements in any order including\n        returning a unique set.\n\n        arg:    assessment_offered_ids (osid.id.IdList): the list of\n                ``Ids`` to retrieve\n        return: (osid.assessment.AssessmentOfferedList) - the returned\n                ``AssessmentOffered`` list\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``assessment_offered_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - assessment failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in assessment_offered_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'assessment').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.AssessmentOfferedList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assessments_offered_by_genus_type(self, assessment_offered_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(assessment_offered_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AssessmentOfferedList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an AssessmentOfferedList corresponding to the given assessment offered genus Type which does not include assessments of types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an AssessmentOfferedList corresponding to the given assessment.", "response": "def get_assessments_offered_for_assessment(self, assessment_id):\n        \"\"\"Gets an ``AssessmentOfferedList`` by the given assessment.\n\n        In plenary mode, the returned list contains all known\n        assessments offered or an error results. Otherwise, the returned\n        list may contain only those assessments offered that are\n        accessible through this session.\n\n        arg:    assessment_id (osid.id.Id): ``Id`` of an ``Assessment``\n        return: (osid.assessment.AssessmentOfferedList) - the returned\n                ``AssessmentOffered`` list\n        raise:  NullArgument - ``assessment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.learning.ActivityLookupSession.get_activities_for_objective_template\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'assessmentId': str(assessment_id)},\n                 **self._view_filter()))\n        return objects.AssessmentOfferedList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all AssessmentOffered elements.", "response": "def get_assessments_offered(self):\n        \"\"\"Gets all ``AssessmentOffered`` elements.\n\n        In plenary mode, the returned list contains all known\n        assessments offered or an error results. Otherwise, the returned\n        list may contain only those assessments offered that are\n        accessible through this session.\n\n        return: (osid.assessment.AssessmentOfferedList) - a list of\n                ``AssessmentOffered`` elements\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.AssessmentOfferedList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assessments_offered_by_query(self, assessment_offered_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in assessment_offered_query._query_terms:\n            if '$in' in assessment_offered_query._query_terms[term] and '$nin' in assessment_offered_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': assessment_offered_query._query_terms[term]['$in']}},\n                             {term: {'$nin': assessment_offered_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: assessment_offered_query._query_terms[term]})\n        for term in assessment_offered_query._keyword_terms:\n            or_list.append({term: assessment_offered_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('assessment',\n                                             collection='AssessmentOffered',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.AssessmentOfferedList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of AssessmentOffered elements matching the given assessment offered query."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_assessment_offered(self, assessment_offered_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_offered_form, ABCAssessmentOfferedForm):\n            raise errors.InvalidArgument('argument type is not an AssessmentOfferedForm')\n        if assessment_offered_form.is_for_update():\n            raise errors.InvalidArgument('the AssessmentOfferedForm is for update only, not create')\n        try:\n            if self._forms[assessment_offered_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('assessment_offered_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('assessment_offered_form did not originate from this session')\n        if not assessment_offered_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(assessment_offered_form._my_map)\n\n        self._forms[assessment_offered_form.get_id().get_identifier()] = CREATED\n        result = objects.AssessmentOffered(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new AssessmentOffered."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_assessment_offered(self, assessment_offered_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_offered_form, ABCAssessmentOfferedForm):\n            raise errors.InvalidArgument('argument type is not an AssessmentOfferedForm')\n        if not assessment_offered_form.is_for_update():\n            raise errors.InvalidArgument('the AssessmentOfferedForm is for update only, not create')\n        try:\n            if self._forms[assessment_offered_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('assessment_offered_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('assessment_offered_form did not originate from this session')\n        if not assessment_offered_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(assessment_offered_form._my_map)\n\n        self._forms[assessment_offered_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.AssessmentOffered(\n            osid_object_map=assessment_offered_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Updates an existing assessment offered."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an Id to an AssessmentOffered for the purpose of creating compatibility.", "response": "def alias_assessment_offered(self, assessment_offered_id, alias_id):\n        \"\"\"Adds an ``Id`` to an ``AssessmentOffered`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``AssessmentOffered`` is determined by\n        the provider. The new ``Id`` is an alias to the primary ``Id``.\n        If the alias is a pointer to another assessment offered, it is\n        reassigned to the given assessment offered ``Id``.\n\n        arg:    assessment_offered_id (osid.id.Id): the ``Id`` of an\n                ``AssessmentOffered``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is in use as a primary\n                ``Id``\n        raise:  NotFound - ``assessment_offered_id`` not found\n        raise:  NullArgument - ``assessment_offered_id`` or ``alias_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=assessment_offered_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the list of AssessmentOffered Id s associated with a Bank.", "response": "def get_assessment_offered_ids_by_bank(self, bank_id):\n        \"\"\"Gets the list of ``AssessmentOffered``  ``Ids`` associated with a ``Bank``.\n\n        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n        return: (osid.id.IdList) - list of related assessment offered\n                ``Ids``\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for assessment_offered in self.get_assessments_offered_by_bank(bank_id):\n            id_list.append(assessment_offered.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the list of AssessmentOffereds associated with a Bank.", "response": "def get_assessments_offered_by_bank(self, bank_id):\n        \"\"\"Gets the list of ``AssessmentOffereds`` associated with a ``Bank``.\n\n        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n        return: (osid.assessment.AssessmentOfferedList) - list of\n                related assessments offered\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_assessment_offered_lookup_session_for_bank(bank_id, proxy=self._proxy)\n        lookup_session.use_isolated_bank_view()\n        return lookup_session.get_assessments_offered()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessment_offered_ids_by_banks(self, bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for assessment_offered in self.get_assessments_offered_by_banks(bank_ids):\n            id_list.append(assessment_offered.get_id())\n        return IdList(id_list)", "response": "Gets the list of AssessmentOffered Ids corresponding to a list of Banks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessments_offered_by_banks(self, bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        assessment_offered_list = []\n        for bank_id in bank_ids:\n            assessment_offered_list += list(\n                self.get_assessments_offered_by_bank(bank_id))\n        return objects.AssessmentOfferedList(assessment_offered_list)", "response": "Gets the list of AssessmentOffered objects corresponding to a list of Banks."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_bank_ids_by_assessment_offered(self, assessment_offered_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_assessment_offered_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_bank_view()\n        assessment_offered = lookup_session.get_assessment_offered(assessment_offered_id)\n        id_list = []\n        for idstr in assessment_offered._my_map['assignedBankIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)", "response": "Gets the list of Bank Ids mapped to an AssessmentOffered."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the list of Banks mapped to an AssessmentOffered.", "response": "def get_banks_by_assessment_offered(self, assessment_offered_id):\n        \"\"\"Gets the list of ``Banks`` mapped to an ``AssessmentOffered``.\n\n        arg:    assessment_offered_id (osid.id.Id): ``Id`` of an\n                ``AssessmentOffered``\n        return: (osid.assessment.BankList) - list of banks\n        raise:  NotFound - ``assessment_offered_id`` is not found\n        raise:  NullArgument - ``assessment_offered_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        return lookup_session.get_banks_by_ids(\n            self.get_bank_ids_by_assessment_offered(assessment_offered_id))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an existing AssessmentOffered to a Bank.", "response": "def assign_assessment_offered_to_bank(self, assessment_offered_id, bank_id):\n        \"\"\"Adds an existing ``AssessmentOffered`` to a ``Bank``.\n\n        arg:    assessment_offered_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentOffered``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        raise:  AlreadyExists - ``assessment_offered_id`` is already\n                assigned to ``bank_id``\n        raise:  NotFound - ``assessment_offered_id`` or ``bank_id`` not\n                found\n        raise:  NullArgument - ``assessment_offered_id`` or ``bank_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._assign_object_to_catalog(assessment_offered_id, bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unassign_assessment_offered_from_bank(self, assessment_offered_id, bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._unassign_object_from_catalog(assessment_offered_id, bank_id)", "response": "Removes an AssessmentOffered from an Bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the AssessmentTaken specified by its Id.", "response": "def get_assessment_taken(self, assessment_taken_id):\n        \"\"\"Gets the ``AssessmentTaken`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``AssessmentTaken`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to an ``AssessmentTaken`` and\n        retained for compatibility.\n\n        arg:    assessment_taken_id (osid.id.Id): ``Id`` of the\n                ``AssessmentTaken``\n        return: (osid.assessment.AssessmentTaken) - the assessment taken\n        raise:  NotFound - ``assessment_taken_id`` not found\n        raise:  NullArgument - ``assessment_taken_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(assessment_taken_id, 'assessment').get_identifier())},\n                 **self._view_filter()))\n        return objects.AssessmentTaken(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting an AssessmentTakenList corresponding to the given IdList.", "response": "def get_assessments_taken_by_ids(self, assessment_taken_ids):\n        \"\"\"Gets an ``AssessmentTakenList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the\n        assessments specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``AssessmentTaken`` objects may be omitted from the\n        list and may present the elements in any order including\n        returning a unique set.\n\n        arg:    assessment_taken_ids (osid.id.IdList): the list of\n                ``Ids`` to retrieve\n        return: (osid.assessment.AssessmentTakenList) - the returned\n                ``AssessmentTaken list``\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``assessment_taken_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - assessment failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in assessment_taken_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'assessment').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.AssessmentTakenList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets an AssessmentTakenList corresponding to the given assessment taken genus Type which does not include assessments of types derived from the specified Type.", "response": "def get_assessments_taken_by_genus_type(self, assessment_taken_genus_type):\n        \"\"\"Gets an ``AssessmentTakenList`` corresponding to the given assessment taken genus ``Type`` which does not include assessments of types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known\n        assessments taken or an error results. Otherwise, the returned\n        list may contain only those assessments taken that are\n        accessible through this session.\n\n        arg:    assessment_taken_genus_type (osid.type.Type): an\n                assessment taken genus type\n        return: (osid.assessment.AssessmentTakenList) - the returned\n                ``AssessmentTaken list``\n        raise:  NullArgument - ``assessment_taken_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(assessment_taken_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AssessmentTakenList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting an AssessmentTakenList for the given assessment.", "response": "def get_assessments_taken_for_assessment(self, assessment_id):\n        \"\"\"Gets an ``AssessmentTakenList`` for the given assessment.\n\n        In plenary mode, the returned list contains all known\n        assessments taken or an error results. Otherwise, the returned\n        list may contain only those assessments taken that are\n        accessible through this session.\n\n        arg:    assessment_id (osid.id.Id): ``Id`` of an ``Assessment``\n        return: (osid.assessment.AssessmentTakenList) - the returned\n                ``AssessmentTaken`` list\n        raise:  NullArgument - ``assessment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentOffered',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'assessmentId': str(assessment_id)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        assessments_offered = objects.AssessmentOfferedList(\n            result,\n            runtime=self._runtime)\n\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        ao_ids = []\n        for assessment_offered in assessments_offered:\n            ao_ids.append(str(assessment_offered.get_id()))\n\n        result = collection.find(\n            dict({'assessmentOfferedId': {'$in': ao_ids}},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AssessmentTakenList(result,\n                                           runtime=self._runtime,\n                                           proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessments_taken_for_assessment_offered(self, assessment_offered_id):\n        # Implemented from template for\n        # osid.learning.ActivityLookupSession.get_activities_for_objective_template\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'assessmentOfferedId': str(assessment_offered_id)},\n                 **self._view_filter()))\n        return objects.AssessmentTakenList(result, runtime=self._runtime)", "response": "Gets an AssessmentTakenList corresponding to the given assessment offered."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessments_taken_for_taker_and_assessment_offered(self, resource_id, assessment_offered_id):\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n\n        am = self._get_provider_manager('ASSESSMENT')\n        aols = am.get_assessment_offered_lookup_session(proxy=self._proxy)\n        aols.use_federated_bank_view()\n        offered = aols.get_assessment_offered(assessment_offered_id)\n        try:\n            deadline = offered.get_deadline()\n            nowutc = DateTime.utcnow()\n            if nowutc > deadline:\n                raise errors.PermissionDenied('you are passed the deadline for the offered')\n        except errors.IllegalState:\n            # no deadline set\n            pass\n\n        result = collection.find(\n            dict({'assessmentOfferedId': str(assessment_offered_id),\n                  'takingAgentId': str(resource_id)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AssessmentTakenList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an AssessmentTakenList for the given resource and assessment offered."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all AssessmentTaken elements in the current session.", "response": "def get_assessments_taken(self):\n        \"\"\"Gets all ``AssessmentTaken`` elements.\n\n        In plenary mode, the returned list contains all known\n        assessments taken or an error results. Otherwise, the returned\n        list may contain only those assessments taken that are\n        accessible through this session.\n\n        return: (osid.assessment.AssessmentTakenList) - a list of\n                ``AssessmentTaken`` elements\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.AssessmentTakenList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assessments_taken_by_query(self, assessment_taken_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in assessment_taken_query._query_terms:\n            if '$in' in assessment_taken_query._query_terms[term] and '$nin' in assessment_taken_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': assessment_taken_query._query_terms[term]['$in']}},\n                             {term: {'$nin': assessment_taken_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: assessment_taken_query._query_terms[term]})\n        for term in assessment_taken_query._keyword_terms:\n            or_list.append({term: assessment_taken_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('assessment',\n                                             collection='AssessmentTaken',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.AssessmentTakenList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of AssessmentTaken elements matching the given assessment taken query."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the assessment taken form for creating new assessments taken.", "response": "def get_assessment_taken_form_for_create(self, assessment_offered_id, assessment_taken_record_types):\n        \"\"\"Gets the assessment taken form for creating new assessments taken.\n\n        A new form should be requested for each create transaction.\n\n        arg:    assessment_offered_id (osid.id.Id): the ``Id`` of the\n                related ``AssessmentOffered``\n        arg:    assessment_taken_record_types (osid.type.Type[]): array\n                of assessment taken record types to be included in the\n                create operation or an empty list if none\n        return: (osid.assessment.AssessmentTakenForm) - the assessment\n                taken form\n        raise:  NotFound - ``assessment_offered_id`` is not found\n        raise:  NullArgument - ``assessment_offered_id`` or\n                ``assessment_taken_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - unable to get form for requested record\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not isinstance(assessment_offered_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in assessment_taken_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n\n        am = self._get_provider_manager('ASSESSMENT')\n        aols = am.get_assessment_offered_lookup_session(proxy=self._proxy)\n        aols.use_federated_bank_view()\n        offered = aols.get_assessment_offered(assessment_offered_id)\n        try:\n            deadline = offered.get_deadline()\n            nowutc = DateTime.utcnow()\n            if nowutc > deadline:\n                raise errors.PermissionDenied('you are passed the deadline for the offered')\n        except errors.IllegalState:\n            # no deadline set\n            pass\n\n        if assessment_taken_record_types == []:\n            # WHY are we passing bank_id = self._catalog_id below, seems redundant:\n            obj_form = objects.AssessmentTakenForm(\n                bank_id=self._catalog_id,\n                assessment_offered_id=assessment_offered_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.AssessmentTakenForm(\n                bank_id=self._catalog_id,\n                record_types=assessment_taken_record_types,\n                assessment_offered_id=assessment_offered_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_assessment_taken(self, assessment_taken_form):\n        # This impl differs from the usual create_osid_object method in that it\n        # sets an agent id and default display name based on the underlying Assessment\n        # and checks for exceeding max attempts...\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_taken_form, ABCAssessmentTakenForm):\n            raise errors.InvalidArgument('argument type is not an AssessmentTakenForm')\n        if assessment_taken_form.is_for_update():\n            raise errors.InvalidArgument('the AssessmentForm is for update only, not create')\n        try:\n            if self._forms[assessment_taken_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('assessment_taken_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('assessment_taken_form did not originate from this session')\n        if not assessment_taken_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n\n        # ...here:\n        assessment_offered_id = Id(assessment_taken_form._my_map['assessmentOfferedId'])\n        aols = AssessmentOfferedLookupSession(\n            catalog_id=None, runtime=self._runtime)\n        aols.use_federated_bank_view()\n        assessment_offered = aols.get_assessment_offered(assessment_offered_id)\n        try:\n            if assessment_offered.has_max_attempts():\n                max_attempts = assessment_offered.get_max_attempts()\n                num_takens = collection.find({'$and': [{'assessmentOfferedId': str(assessment_offered.get_id())},\n                                                       {'takingAgentId': str(self.get_effective_agent_id())},\n                                                       {'assigned' + self._catalog_name + 'Ids': {'$in': [str(self._catalog_id)]}}]}).count()\n                if num_takens >= max_attempts:\n                    raise errors.PermissionDenied('exceeded max attempts')\n        except AttributeError:\n            pass\n        assessment_taken_form._my_map['takingAgentId'] = str(self.get_effective_agent_id())\n\n        insert_result = collection.insert_one(assessment_taken_form._my_map)\n        self._forms[assessment_taken_form.get_id().get_identifier()] = CREATED\n        return objects.AssessmentTaken(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Creates a new AssessmentTaken."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_assessment_taken(self, assessment_taken_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_taken_form, ABCAssessmentTakenForm):\n            raise errors.InvalidArgument('argument type is not an AssessmentTakenForm')\n        if not assessment_taken_form.is_for_update():\n            raise errors.InvalidArgument('the AssessmentTakenForm is for update only, not create')\n        try:\n            if self._forms[assessment_taken_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('assessment_taken_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('assessment_taken_form did not originate from this session')\n        if not assessment_taken_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(assessment_taken_form._my_map)\n\n        self._forms[assessment_taken_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.AssessmentTaken(\n            osid_object_map=assessment_taken_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Updates an existing assessment taken."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_assessment_taken(self, assessment_taken_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('assessment',\n                                         collection='AssessmentTaken',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_taken_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        assessment_taken_map = collection.find_one(\n            dict({'_id': ObjectId(assessment_taken_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.AssessmentTaken(osid_object_map=assessment_taken_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(assessment_taken_id.get_identifier())})", "response": "Deletes an ``AssessmentTaken``.\n\n        arg:    assessment_taken_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentTaken`` to remove\n        raise:  NotFound - ``assessment_taken_id`` not found\n        raise:  NullArgument - ``assessment_taken_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an Id to an AssessmentTaken alias_id.", "response": "def alias_assessment_taken(self, assessment_taken_id, alias_id):\n        \"\"\"Adds an ``Id`` to an ``AssessmentTaken`` for the purpose of creating compatibility.\n\n        The primary ``Id`` of the ``AssessmentTaken`` is determined by\n        the provider. The new ``Id`` is an alias to the primary ``Id``.\n        If the alias is a pointer to another assessment taken, it is\n        reassigned to the given assessment taken ``Id``.\n\n        arg:    assessment_taken_id (osid.id.Id): the ``Id`` of an\n                ``AssessmentTaken``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n        raise:  AlreadyExists - ``alias_id`` is in use as a primary\n                ``Id``\n        raise:  NotFound - ``assessment_taken_id`` not found\n        raise:  NullArgument - ``assessment_taken_id`` or ``alias_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=assessment_taken_id, equivalent_id=alias_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the list of AssessmentTaken Id s associated with a Bank.", "response": "def get_assessment_taken_ids_by_bank(self, bank_id):\n        \"\"\"Gets the list of ``AssessmentTaken``  ``Ids`` associated with a ``Bank``.\n\n        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n        return: (osid.id.IdList) - list of related assessment taken\n                ``Ids``\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for assessment_taken in self.get_assessments_taken_by_bank(bank_id):\n            id_list.append(assessment_taken.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_assessments_taken_by_bank(self, bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_assessment_taken_lookup_session_for_bank(bank_id, proxy=self._proxy)\n        lookup_session.use_isolated_bank_view()\n        return lookup_session.get_assessments_taken()", "response": "Gets the list of AssessmentTakenList associated with a Bank."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assessment_taken_ids_by_banks(self, bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for assessment_taken in self.get_assessments_taken_by_banks(bank_ids):\n            id_list.append(assessment_taken.get_id())\n        return IdList(id_list)", "response": "Gets the list of AssessmentTaken Ids corresponding to a list of Banks."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the list of AssessmentTaken objects corresponding to a list of Banks.", "response": "def get_assessments_taken_by_banks(self, bank_ids):\n        \"\"\"Gets the list of ``AssessmentTaken`` objects corresponding to a list of ``Banks``.\n\n        arg:    bank_ids (osid.id.IdList): list of bank ``Ids``\n        return: (osid.assessment.AssessmentTakenList) - list of\n                assessments taken\n        raise:  NullArgument - ``bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        assessment_taken_list = []\n        for bank_id in bank_ids:\n            assessment_taken_list += list(\n                self.get_assessments_taken_by_bank(bank_id))\n        return objects.AssessmentTakenList(assessment_taken_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the list of Bank Ids mapped to an AssessmentTaken.", "response": "def get_bank_ids_by_assessment_taken(self, assessment_taken_id):\n        \"\"\"Gets the list of ``Bank``  ``Ids`` mapped to an ``AssessmentTaken``.\n\n        arg:    assessment_taken_id (osid.id.Id): ``Id`` of an\n                ``AssessmentTaken``\n        return: (osid.id.IdList) - list of bank ``Ids``\n        raise:  NotFound - ``assessment_taken_id`` is not found\n        raise:  NullArgument - ``assessment_taken_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_assessment_taken_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_bank_view()\n        assessment_taken = lookup_session.get_assessment_taken(assessment_taken_id)\n        id_list = []\n        for idstr in assessment_taken._my_map['assignedBankIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_banks_by_assessment_taken(self, assessment_taken_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        return lookup_session.get_banks_by_ids(\n            self.get_bank_ids_by_assessment_taken(assessment_taken_id))", "response": "Gets the list of Banks mapped to an AssessmentTaken."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assign_assessment_taken_to_bank(self, assessment_taken_id, bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._assign_object_to_catalog(assessment_taken_id, bank_id)", "response": "Adds an existing AssessmentTaken to an Bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving an AssessmentTaken from an Bank.", "response": "def unassign_assessment_taken_from_bank(self, assessment_taken_id, bank_id):\n        \"\"\"Removes an ``AssessmentTaken`` from a ``Bank``.\n\n        arg:    assessment_taken_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentTaken``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        raise:  NotFound - ``assessment_taken_id`` or ``bank_id`` not\n                found or ``assessment_taken_id`` not assigned to\n                ``bank_id``\n        raise:  NullArgument - ``assessment_taken_id`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._unassign_object_from_catalog(assessment_taken_id, bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of Bank objects matching the given bank query.", "response": "def get_banks_by_query(self, bank_query):\n        \"\"\"Gets a list of ``Bank`` objects matching the given bank query.\n\n        arg:    bank_query (osid.assessment.BankQuery): the bank query\n        return: (osid.assessment.BankList) - the returned ``BankList``\n        raise:  NullArgument - ``bank_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``bank_query`` is not of this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinQuerySession.get_bins_by_query_template\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalogs_by_query(bank_query)\n        query_terms = dict(bank_query._query_terms)\n        collection = JSONClientValidated('assessment',\n                                         collection='Bank',\n                                         runtime=self._runtime)\n        result = collection.find(query_terms).sort('_id', DESCENDING)\n\n        return objects.BankList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef can_create_bank_with_record_types(self, bank_record_types):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=bank_record_types)\n        return True", "response": "Tests if this user can create a single Bank using the desired record types."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates an existing bank.", "response": "def update_bank(self, bank_form):\n        \"\"\"Updates an existing bank.\n\n        arg:    bank_form (osid.assessment.BankForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - ``bank_form`` already used in an update\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``bank_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``bank_form`` did not originate from\n                ``get_bank_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=bank_form)\n        collection = JSONClientValidated('assessment',\n                                         collection='Bank',\n                                         runtime=self._runtime)\n        if not isinstance(bank_form, ABCBankForm):\n            raise errors.InvalidArgument('argument type is not an BankForm')\n        if not bank_form.is_for_update():\n            raise errors.InvalidArgument('the BankForm is for update only, not create')\n        try:\n            if self._forms[bank_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('bank_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('bank_form did not originate from this session')\n        if not bank_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(bank_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[bank_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Bank(osid_object_map=bank_form._my_map, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alias_bank(self, bank_id, alias_id):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=bank_id, alias_id=alias_id)\n        self._alias_id(primary_id=bank_id, equivalent_id=alias_id)", "response": "Adds an Id to a Bank for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the root banks in this bank hierarchy.", "response": "def get_root_banks(self):\n        \"\"\"Gets the root banks in this bank hierarchy.\n\n        return: (osid.assessment.BankList) - the root banks\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return BankLookupSession(\n            self._proxy,\n            self._runtime).get_banks_by_ids(list(self.get_root_bank_ids()))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_parent_banks(self, bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=bank_id)\n        return self._hierarchy_session.has_parents(id_=bank_id)", "response": "Tests if the Bank has any parents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntesting if an Id is a direct parent of a bank.", "response": "def is_parent_of_bank(self, id_, bank_id):\n        \"\"\"Tests if an ``Id`` is a direct parent of a bank.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    bank_id (osid.id.Id): the ``Id`` of a bank\n        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``bank_id,``  ``false`` otherwise\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``id`` or ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=bank_id)\n        return self._hierarchy_session.is_parent(id_=bank_id, parent_id=id_)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_parent_bank_ids(self, bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=bank_id)\n        return self._hierarchy_session.get_parents(id_=bank_id)", "response": "Gets the parent Ids of the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parent_banks(self, bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=bank_id)\n        return BankLookupSession(\n            self._proxy,\n            self._runtime).get_banks_by_ids(\n                list(self.get_parent_bank_ids(bank_id)))", "response": "Gets the parents of the given bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntest if an Id is an ancestor of a bank.", "response": "def is_ancestor_of_bank(self, id_, bank_id):\n        \"\"\"Tests if an ``Id`` is an ancestor of a bank.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    bank_id (osid.id.Id): the ``Id`` of a bank\n        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``bank_id,``  ``false`` otherwise\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=bank_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntesting if a bank has any children.", "response": "def has_child_banks(self, bank_id):\n        \"\"\"Tests if a bank has any children.\n\n        arg:    bank_id (osid.id.Id): a ``bank_id``\n        return: (boolean) - ``true`` if the ``bank_id`` has children,\n                ``false`` otherwise\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=bank_id)\n        return self._hierarchy_session.has_children(id_=bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_child_of_bank(self, id_, bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=bank_id)\n        return self._hierarchy_session.is_child(id_=bank_id, child_id=id_)", "response": "Tests if an Id is a direct child of another."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_child_bank_ids(self, bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=bank_id)\n        return self._hierarchy_session.get_children(id_=bank_id)", "response": "Gets the child Ids of the given bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_child_banks(self, bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=bank_id)\n        return BankLookupSession(\n            self._proxy,\n            self._runtime).get_banks_by_ids(\n                list(self.get_child_bank_ids(bank_id)))", "response": "Gets the children of the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if an Id is a descendant of a bank.", "response": "def is_descendant_of_bank(self, id_, bank_id):\n        \"\"\"Tests if an ``Id`` is a descendant of a bank.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    bank_id (osid.id.Id): the ``Id`` of a bank\n        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``bank_id,``  ``false`` otherwise\n        raise:  NotFound - ``bank_id`` not found\n        raise:  NullArgument - ``bank_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` is not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=bank_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_bank_nodes(self, bank_id, ancestor_levels, descendant_levels, include_siblings):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.BankNode(self.get_bank_node_ids(\n            bank_id=bank_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a portion of the hierarchy for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_root_bank(self, bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=bank_id)\n        return self._hierarchy_session.add_root(id_=bank_id)", "response": "Adds a root bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_root_bank(self, bank_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=bank_id)\n        return self._hierarchy_session.remove_root(id_=bank_id)", "response": "Removes a root bank from this hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a child to a bank.", "response": "def add_child_bank(self, bank_id, child_id):\n        \"\"\"Adds a child to a bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of a bank\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``bank_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``bank_id`` or ``child_id`` not found\n        raise:  NullArgument - ``bank_id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=bank_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=bank_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_child_bank(self, bank_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=bank_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=bank_id, child_id=child_id)", "response": "Removes a child from a bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove all children from a bank.", "response": "def remove_child_banks(self, bank_id):\n        \"\"\"Removes all children from a bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of a bank\n        raise:  NotFound - ``bank_id`` is not in hierarchy\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalogs(catalog_id=bank_id)\n        return self._hierarchy_session.remove_children(id_=bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding list of tuples of names and images.", "response": "def layered(self):\n        \"\"\"Yield list of [[(name, image), ...], [(name, image), ...], ...]\"\"\"\n        result = []\n        for layer in self._layered:\n            nxt = []\n            for name in layer:\n                nxt.append((name, self.all_images[name]))\n            result.append(nxt)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(args):\n   txome = Transcriptome()\n   #read the reference gpd if one is gven\n   if args.reference: \n      rinf = None\n      if re.search('\\.gz$',args.reference):\n         rinf = gzip.open(args.reference)\n      else:\n         rinf = open(args.reference)\n      sys.stderr.write(\"Reading in reference\\n\")\n      z = 0\n      # populate txome with reference transcripts for each chromosome\n      for line in rinf:\n         z += 1\n         gpd = GPD(line)\n         gpd.set_payload(z)\n         if z%100 == 0:  sys.stderr.write(str(z)+\"          \\r\")\n         txome.add_transcript(gpd)\n      rinf.close()\n      sys.stderr.write(str(z)+\"          \\r\")\n      sys.stderr.write(\"\\n\")\n   txome.sort_transcripts()\n   sys.stderr.write(\"Buffering mappings\\n\")\n   inf = sys.stdin\n   if args.input != '-':\n      if re.search('\\.gz$',args.input):\n         inf = gzip.open(args.input)\n      else:\n         inf = open(args.input)\n   tof = gzip.open(args.tempdir+'/reads.gpd.gz','w')\n   for line in inf: tof.write(line.rstrip()+\"\\n\")\n   tof.close()\n  \n   sys.stderr.write(\"1. Process by overlapping locus.\\n\")\n   annotated_reads(txome,gzip.open(args.tempdir+'/reads.gpd.gz'),'initial',args)\n\n   #of.close()\n\n   \"\"\"Now sequences we should be able to annotate as partial have\n      consensus transcripts.  Lets put those to annotation scrutiny again.\n   \"\"\"\n   sys.stderr.write(\"2. Reannotated partially annotated by overlapping locus.\\n\")\n   annotated_reads(txome,gzip.open(args.tempdir+'/initial/partial_annotated_multiexon.sorted.gpd.gz'),'repartial',args)\n\n\n   txs = {}\n   for transcript in txome.transcripts:\n      txs[transcript.name] = transcript\n   detected = {}\n   tinf = gzip.open(args.tempdir+'/initial/annotated.txt.gz')\n   for line in tinf:\n      f = line.rstrip().split(\"\\t\")\n      detected[f[1]] = True\n   tinf.close()\n   tinf = gzip.open(args.tempdir+'/repartial/annotated.txt.gz')\n   remove_partial = {}\n   for line in tinf:\n      f = line.rstrip().split(\"\\t\")\n      detected[f[1]] = True\n      remove_partial[f[1]] = True\n   tinf.close()\n   tof = gzip.open(args.tempdir+'/candidate.gpd.gz','w')\n   for name in detected:\n      tof.write(txs[name].get_gpd_line()+\"\\n\")\n   tinf = gzip.open(args.tempdir+'/initial/partial_annotated_multiexon.sorted.gpd.gz')\n   for line in tinf:\n      f = line.rstrip().split(\"\\t\")\n      if f[1] not in remove_partial:\n         tof.write(line)\n   tinf = gzip.open(args.tempdir+'/initial/unannotated_singleexon.sorted.gpd.gz')\n   for line in tinf:\n      f = line.rstrip().split(\"\\t\")\n      f[0] = str(uuid.uuid4())\n      tof.write(\"\\t\".join(f)+\"\\n\")\n   tinf.close()\n   tof.close()\n   sort_gpd(args.tempdir+'/candidate.gpd.gz',args.tempdir+'/candidate.sorted.gpd.gz',args)\n   \"\"\"We can ignore the partial annotations that have been detected\"\"\"\n   ntxome = Transcriptome()\n   tinf = gzip.open(args.tempdir+'/candidate.sorted.gpd.gz')\n   for line in tinf: ntxome.add_transcript(GPD(line))     \n   annotated_reads(ntxome,gzip.open(args.tempdir+'/initial/unannotated_multiexon.sorted.gpd.gz'),'unannotated',args)\n   \"\"\"now we know which unannotated reads actually have annotations\"\"\"\n   tinf.close()\n\n   tof = gzip.open(args.tempdir+'/final.gpd.gz','w')\n   tinf = gzip.open(args.tempdir+'/candidate.sorted.gpd.gz')   \n   for line in tinf: tof.write(line)\n   tinf.close()\n   tinf = gzip.open(args.tempdir+'/unannotated/unannotated_multiexon.sorted.gpd.gz')   \n   for line in tinf: tof.write(line)\n   tinf.close()\n   tinf = gzip.open(args.tempdir+'/unannotated/partial_annotated_multiexon.sorted.gpd.gz')   \n   for line in tinf: tof.write(line)\n   tinf.close()\n   tof.close()\n   sort_gpd(args.tempdir+'/final.gpd.gz',args.tempdir+'/final.sorted.gpd.gz',args)\n   \"\"\"Prepare outputs\"\"\"\n   of = sys.stdout\n   if args.output:\n      if re.search('\\.gz$',args.output):\n         of = gzip.open(args.output,'w')\n      else:\n         of = open(args.output,'w')\n   tinf = gzip.open(args.tempdir+'/final.sorted.gpd.gz')\n   for line in tinf: of.write(line)\n   tinf.close()\n   of.close()", "response": "Read any transcriptome we can and populate the transcriptome with the transcript data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef annotated_reads(txome,sorted_read_stream,output,args):\n   if not os.path.exists(args.tempdir+'/'+output):\n      os.makedirs(args.tempdir+'/'+output)\n   ts = OrderedStream(iter(txome.transcript_stream()))\n   rs = OrderedStream(GPDStream(sorted_read_stream))\n   mls = MultiLocusStream([ts,rs])\n   \n   aof = gzip.open(args.tempdir+'/'+output+'/annotated.txt.gz','w')\n   of1 = gzip.open(args.tempdir+'/'+output+'/unannotated_multiexon.gpd.gz','w')\n   of2 = gzip.open(args.tempdir+'/'+output+'/partial_annotated_multiexon.gpd.gz','w')\n   of3 = gzip.open(args.tempdir+'/'+output+'/unannotated_singleexon.gpd.gz','w')\n   z = 0\n   for ml in mls:\n      refs, reads = ml.payload\n      if len(refs) == 0: continue\n      \"\"\"Check and see if we have single exons annotated\"\"\"\n      single_exon_refs = [x for x in refs if x.get_exon_count()==1]\n      single_exon_reads = [x for x in reads if x.get_exon_count()==1]\n      #print str(len(single_exon_refs))+\" \"+str(len(single_exon_reads))\n      unannotated_single_exon_reads = []\n      for seread in single_exon_reads:\n         ovs  = [(x.exons[0].length,seread.exons[0].length,x.exons[0].overlap_size(seread.exons[0]),x) for x in single_exon_refs if x.exons[0].overlaps(seread.exons[0])]\n         #check for minimum overlap\n         ovs = [x for x in ovs if x[2] >= args.single_exon_minimum_overlap]\n         ovs = [x for x in ovs if float(x[2])/float(max(x[0],x[1])) >= args.single_exon_mutual_overlap]\n         ovs = sorted(ovs,key=lambda x: float(x[2])/float(max(x[0],x[1])),reverse=True)\n         if len(ovs) == 0: \n            unannotated_single_exon_reads.append(seread)\n            continue\n         best_ref = ovs[0][3]\n         aof.write(seread.name+\"\\t\"+best_ref.name+\"\\tSE\"+\"\\n\")\n\n      \"\"\"May want an optional check for any better matches among exons\"\"\"\n      #now we can look for best matches among multi-exon transcripts\n      reads = [x for x in reads if x.get_exon_count() > 1]\n      multiexon_refs = [x for x in refs if x.get_exon_count() > 1]\n      unannotated_multi_exon_reads = []\n      partial_annotated_multi_exon_reads = []\n      for read in reads:\n         # we dont' need to have multiple exons matched. one is enough to call\n         ovs = [y for y in [(x,x.exon_overlap(read,\n                                              multi_minover=args.multi_exon_minimum_overlap,\n                                              multi_endfrac=args.multi_exon_end_frac,\n                                              multi_midfrac=args.multi_exon_mid_frac,\n                                              multi_consec=False)) for x in multiexon_refs] if y[1]]\n         for o in ovs: o[1].analyze_overs()\n         full =  sorted([x for x in ovs if x[1].is_subset()==1],\n                        key = lambda y: float(y[1].overlap_size())/float(max(y[1].tx_obj1.length,y[1].tx_obj2.length)),\n                        reverse=True\n                       )\n         if len(full) > 0:\n            aof.write(read.name+\"\\t\"+full[0][0].name+\"\\tfull\"+\"\\n\")\n            continue\n         subset =  sorted([x for x in ovs if x[1].is_subset()==2],\n                          key = lambda y: (y[1].match_exon_count(),\n                                           y[1].min_overlap_fraction()),\n                          reverse = True\n                         )\n         if len(subset) > 0:\n            aof.write(read.name+\"\\t\"+subset[0][0].name+\"\\tpartial\"+\"\\n\")\n            continue\n         #check for supersets\n         superset = sorted([x for x in ovs if x[1].is_subset()==3],\n                          key = lambda y: (y[1].match_exon_count(),\n                                           y[1].min_overlap_fraction()),\n                          reverse = True\n                         )\n         if len(superset) > 0:\n            partial_annotated_multi_exon_reads.append((read,superset[0][0]))\n            #print read.name+\"\\t\"+superset[0][0].name+\"\\tsuper\"\n            continue\n         #check for noncompatible overlaps\n         overset = sorted([x for x in ovs if x[1].match_exon_count > 0],\n                          key = lambda y: (y[1].consecutive_exon_count(),\n                                           y[1].min_overlap_fraction()),\n                          reverse = True\n                         )\n         #print [(x[1].consecutive_exon_count(), x[1].min_overlap_fraction()) for x in overset]\n         if len(overset) > 0:\n            partial_annotated_multi_exon_reads.append((read,overset[0][0]))\n            #print read.name+\"\\t\"+overset[0][0].name+\"\\tover\"\n            continue\n         unannotated_multi_exon_reads.append(read)\n      \"\"\"Now we have partially annotated multi and unannotated multi and unannotated single\"\"\"\n      if len(unannotated_multi_exon_reads) > 0:\n         sys.stderr.write(str(z)+\" \"+str(len(unannotated_multi_exon_reads))+\"   \\r\")\n         d = Deconvolution(downsample(unannotated_multi_exon_reads,args.downsample_locus))\n         groups = d.parse(tolerance=20,downsample=args.downsample)\n         for tx in groups:\n            z+=1\n            of1.write(tx.get_gpd_line()+\"\\n\")\n      if len(partial_annotated_multi_exon_reads) > 0:\n         sys.stderr.write(str(z)+\" \"+str(len(partial_annotated_multi_exon_reads))+\"   \\r\")\n         ### set the direction of the transcript\n         for v in partial_annotated_multi_exon_reads:\n            v[0].set_strand(v[1].direction)\n         ### set the gene name of the transcript\n         for v in partial_annotated_multi_exon_reads:\n            v[0].set_gene_name(v[1].gene_name)         \n         d = Deconvolution(downsample([x[0] for x in partial_annotated_multi_exon_reads],args.downsample_locus))\n         groups = d.parse(tolerance=20,downsample=args.downsample,use_gene_names=True)\n         for tx in groups:\n            z += 1\n            of2.write(tx.get_gpd_line()+\"\\n\")\n      \"\"\"Do the unannotated single exon reads\"\"\"\n      g = Graph()\n      for r in unannotated_single_exon_reads:\n         if len([x for x in partial_annotated_multi_exon_reads if x[0].overlaps(r)]) > 0: continue\n         if len([x for x in unannotated_multi_exon_reads if x.overlaps(r)]) > 0: continue\n         if len([x for x in txome.transcripts if x.overlaps(r)]) > 0: continue\n         g.add_node(Node(r))\n      for i in range(0,len(g.nodes)):\n         for j in range(0,len(g.nodes)):\n            if i == j: continue\n            if g.nodes[i].payload.overlaps(g.nodes[j].payload):\n               g.add_edge(Edge(g.nodes[i],g.nodes[j]))\n      g.merge_cycles()\n      for r in g.roots:\n         se = []\n         se += r.payload_list\n         children = g.get_children(r)\n         for child in children:  se += child.payload_list\n         rng = GenomicRange(se[0].exons[0].chr,\n                            min([x.exons[0].start for x in se]),\n                            max([x.exons[0].end for x in se]))\n         tx = Transcript([rng],Transcript.Options(direction='+'))\n         of3.write(tx.get_gpd_line()+\"\\n\")\n\n   of1.close()\n   of2.close()\n   of3.close()\n   sys.stderr.write(\"\\n\")      \n   \"\"\"Sort our progress\"\"\"\n   sys.stderr.write(\"sort transcriptome\\n\")\n   sort_gpd(args.tempdir+'/'+output+'/partial_annotated_multiexon.gpd.gz',args.tempdir+'/'+output+'/partial_annotated_multiexon.sorted.gpd.gz',args)\n   sort_gpd(args.tempdir+'/'+output+'/unannotated_multiexon.gpd.gz',args.tempdir+'/'+output+'/unannotated_multiexon.sorted.gpd.gz',args)\n   sort_gpd(args.tempdir+'/'+output+'/unannotated_singleexon.gpd.gz',args.tempdir+'/'+output+'/unannotated_singleexon.sorted.gpd.gz',args)\n   \"\"\"We still have the unannotated single exon reads to deal with\"\"\"", "response": "Read and return the annotated reads."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the weekly growth in percentage and rounds to one digit.", "response": "def weekly_growth(self, weeks):\n        \"\"\"Calculate the weekly growth in percentage, and rounds\n        to one digit.\n    \n        Parameters\n        ----------\n        weeks\n            Number of weeks to calculate growth over.\n\n        Returns\n        -------\n        growth_factor\n            A real number such that start * growth_factor** weeks = end.\n    \n    \n        Examples\n        -------\n        >>> bench = DynamicExercise('Bench press', 100, 120, 3, 8)\n        >>> bench.weekly_growth(8)\n        2.3\n        >>> bench.weekly_growth(4)\n        4.7\n        \"\"\"\n        start, end = self.start_weight, self.final_weight\n        growth_factor = ((end / start) ** (1 / weeks) - 1) * 100\n        return round(growth_factor, 1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the underlying family view to match current view", "response": "def _set_family_view(self, session):\n        \"\"\"Sets the underlying family view to match current view\"\"\"\n        if self._family_view == COMPARATIVE:\n            try:\n                session.use_comparative_family_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_family_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef use_comparative_family_view(self):\n        self._family_view = COMPARATIVE\n        # self._get_provider_session('family_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_family_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider FamilyLookupSession. use_comparative_family_view"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider FamilyLookupSession. use_plenary_family_view", "response": "def use_plenary_family_view(self):\n        \"\"\"Pass through to provider FamilyLookupSession.use_plenary_family_view\"\"\"\n        self._family_view = PLENARY\n        # self._get_provider_session('family_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_family_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_families_by_ids(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_by_ids\n        catalogs = self._get_provider_session('family_lookup_session').get_families_by_ids(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Family(self._provider_manager, cat, self._runtime, self._proxy))\n        return FamilyList(cat_list)", "response": "Pass through to provider FamilyLookupSession. get_families_by_ids"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npassing through to provider FamilyLookupSession. get_families", "response": "def get_families(self):\n        \"\"\"Pass through to provider FamilyLookupSession.get_families\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('family_lookup_session').get_families()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Family(self._provider_manager, cat, self._runtime, self._proxy))\n        return FamilyList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npassing through to provider FamilyAdminSession. get_family_form_for_update", "response": "def get_family_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider FamilyAdminSession.get_family_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'family_record_types' in kwargs:\n            return self.get_family_form_for_create(*args, **kwargs)\n        else:\n            return self.get_family_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_family(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        # OSID spec does not require returning updated catalog\n        return Family(\n            self._provider_manager,\n            self._get_provider_session('family_admin_session').update_family(*args, **kwargs),\n            self._runtime,\n            self._proxy)", "response": "Pass through to provider FamilyAdminSession. update_family"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_family(self, family_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if family_form.is_for_update():\n            return self.update_family(family_form, *args, **kwargs)\n        else:\n            return self.create_family(family_form, *args, **kwargs)", "response": "Pass through to provider FamilyAdminSession. update_family"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the underlying family view to match current view", "response": "def _set_family_view(self, session):\n        \"\"\"Sets the underlying family view to match current view\"\"\"\n        if self._family_view == FEDERATED:\n            try:\n                session.use_federated_family_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_family_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_provider_session(self, session_name):\n        agent_key = self._get_agent_key()\n        if session_name in self._provider_sessions[agent_key]:\n            return self._provider_sessions[agent_key][session_name]\n        else:\n            session_class = getattr(self._provider_manager, 'get_' + session_name + '_for_family')\n            if self._proxy is None:\n                if 'notification_session' in session_name:\n                    # Is there something else we should do about the receiver field?\n                    session = session_class('fake receiver', self._catalog.get_id())\n                else:\n                    session = session_class(self._catalog.get_id())\n            else:\n                if 'notification_session' in session_name:\n                    # Is there something else we should do about the receiver field?\n                    session = session_class('fake receiver', self._catalog.get_id(), self._proxy)\n                else:\n                    session = session_class(self._catalog.get_id(), self._proxy)\n            self._set_family_view(session)\n            self._set_object_view(session)\n            self._set_operable_view(session)\n            self._set_containable_view(session)\n            if self._session_management != DISABLED:\n                self._provider_sessions[agent_key][session_name] = session\n            return session", "response": "Returns the requested provider session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npass through to provider RelationshipLookupSession. use_comparative_relationship_view", "response": "def use_comparative_relationship_view(self):\n        \"\"\"Pass through to provider RelationshipLookupSession.use_comparative_relationship_view\"\"\"\n        self._object_views['relationship'] = COMPARATIVE\n        # self._get_provider_session('relationship_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_relationship_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef use_plenary_relationship_view(self):\n        self._object_views['relationship'] = PLENARY\n        # self._get_provider_session('relationship_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_relationship_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider RelationshipLookupSession. use_plenary_relationship_view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npass through to provider RelationshipLookupSession. use_federated_family_view", "response": "def use_federated_family_view(self):\n        \"\"\"Pass through to provider RelationshipLookupSession.use_federated_family_view\"\"\"\n        self._family_view = FEDERATED\n        # self._get_provider_session('relationship_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_federated_family_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass through to provider RelationshipLookupSession. use_isolated_family_view", "response": "def use_isolated_family_view(self):\n        \"\"\"Pass through to provider RelationshipLookupSession.use_isolated_family_view\"\"\"\n        self._family_view = ISOLATED\n        # self._get_provider_session('relationship_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_isolated_family_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npasses through to provider RelationshipAdminSession. get_relationship_form_for_update", "response": "def get_relationship_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider RelationshipAdminSession.get_relationship_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'relationship_record_types' in kwargs:\n            return self.get_relationship_form_for_create(*args, **kwargs)\n        else:\n            return self.get_relationship_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider RelationshipAdminSession. update_relationship", "response": "def save_relationship(self, relationship_form, *args, **kwargs):\n        \"\"\"Pass through to provider RelationshipAdminSession.update_relationship\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if relationship_form.is_for_update():\n            return self.update_relationship(relationship_form, *args, **kwargs)\n        else:\n            return self.create_relationship(relationship_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_error(exc):\n\n    if isinstance(exc, HTTPError):\n        # Returning the HTTP Error code coming from requests module\n        return exc.response.status_code, text(exc.response.content)\n\n    if isinstance(exc, Timeout):\n        # A timeout is a 408, and it's not a HTTPError (why? dunno).\n        return 408, exc\n\n    if isinstance(exc, Http404):\n        # 404 is 404\n        return 404, exc\n\n    if isinstance(exc, PermissionDenied):\n        # Permission denied is 403\n        return 403, exc\n\n    if isinstance(exc, SuspiciousOperation):\n        # Shouldn't happen, but you never know\n        return 400, exc\n\n    # The default error code is 500\n    return 500, exc", "response": "Return the appropriate HTTP status code and text for the given exception."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_form_kwargs(self):\n        data = super(UserContextFormViewMixin, self).get_form_kwargs()\n        data.update({\n            'user': self.get_agnocomplete_context(),\n        })\n        return data", "response": "Returns the form kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_klass(self):\n        # Extract the klass name from the URL arguments\n        klass_name = self.kwargs.get('klass', None)\n        klass = self.registry.get(klass_name, None)\n        if not klass:\n            raise Http404(\"Unknown autocomplete class `{}`\".format(klass_name))\n        return klass", "response": "Returns the agnocomplete class to be used with the eventual query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_v3_unit_placement(placement_str):\n    placement = placement_str\n    container = machine = service = unit = ''\n    if ':' in placement:\n        try:\n            container, placement = placement_str.split(':')\n        except ValueError:\n            msg = 'placement {} is malformed, too many parts'.format(\n                placement_str)\n            raise ValueError(msg.encode('utf-8'))\n    if '=' in placement:\n        try:\n            placement, unit = placement.split('=')\n        except ValueError:\n            msg = 'placement {} is malformed, too many parts'.format(\n                placement_str)\n            raise ValueError(msg.encode('utf-8'))\n    if placement.isdigit():\n        machine = placement\n    else:\n        service = placement\n    if (container and container not in VALID_CONTAINERS):\n        msg = 'invalid container {} for placement {}'.format(\n            container, placement_str)\n        raise ValueError(msg.encode('utf-8'))\n    unit = _parse_unit(unit, placement_str)\n    if machine and machine != '0':\n        raise ValueError(b'legacy bundles may not place units on machines '\n                         b'other than 0')\n    return UnitPlacement(container, machine, service, unit)", "response": "Parse a string that represents a placement string for bundles version 3."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a string that represents a valid placement string for bundles version 4.", "response": "def parse_v4_unit_placement(placement_str):\n    \"\"\"Return a UnitPlacement for bundles version 4, given a placement string.\n\n    See https://github.com/juju/charmstore/blob/v4/docs/bundles.md\n    Raise a ValueError if the placement is not valid.\n    \"\"\"\n    placement = placement_str\n    container = machine = service = unit = ''\n    if ':' in placement:\n        try:\n            container, placement = placement_str.split(':')\n        except ValueError:\n            msg = 'placement {} is malformed, too many parts'.format(\n                placement_str)\n            raise ValueError(msg.encode('utf-8'))\n    if '/' in placement:\n        try:\n            placement, unit = placement.split('/')\n        except ValueError:\n            msg = 'placement {} is malformed, too many parts'.format(\n                placement_str)\n            raise ValueError(msg.encode('utf-8'))\n    if placement.isdigit() or placement == 'new':\n        machine = placement\n    else:\n        service = placement\n    if (container and container not in VALID_CONTAINERS):\n        msg = 'invalid container {} for placement {}'.format(\n            container, placement_str)\n        raise ValueError(msg.encode('utf-8'))\n    unit = _parse_unit(unit, placement_str)\n    return UnitPlacement(container, machine, service, unit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_unit(unit, placement_str):\n    if not unit:\n        return None\n    try:\n        return int(unit)\n    except (TypeError, ValueError):\n        msg = 'unit in placement {} must be digit'.format(placement_str)\n        raise ValueError(msg.encode('utf-8'))", "response": "Parse a unit as part of the unit placement."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect(self):\n    r = self.get('gateway')\n    self.ws = websocket.WebSocketApp(r[\"url\"]+\"/?encoding=json&v=6\",\n                                     on_message=self.on_message,\n                                     on_error=self.on_error,\n                                     on_close=self.on_close)\n    self.ws.on_open = self.on_connect", "response": "Todo connect to the server"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_message(self, ws, message):\n    m = json.loads(message)\n    self.logger.debug(m)\n    if m.get(\"s\", 0):\n      self.sequence = m[\"s\"]\n    if m[\"op\"] == self.DISPATCH:\n      if m[\"t\"] == \"READY\":\n        for channel in m[\"d\"][\"private_channels\"]:\n          if len(channel[\"recipients\"]) == 1:\n            self.channels[channel[\"id\"]] = User(channel[\"recipients\"][0])\n            self.logger.info(\"added channel for %s\", self.channels[channel[\"id\"]])\n        self.session = m[\"d\"][\"session_id\"]\n        self.con_connect(User(m[\"d\"][\"user\"]))\n      elif m[\"t\"] == \"GUILD_CREATE\":\n        pass\n      elif m[\"t\"] == \"MESSAGE_CREATE\":\n#        if not m[\"d\"][\"channel_id\"] in self.channels:\n#        print(\"ch:\")\n#        print(self.get(\"channels/\"+m[\"d\"][\"channel_id\"]))\n        self.con_message(Message(m[\"d\"]))\n    elif m[\"op\"] == self.HELLO:\n      interval = int(m['d']['heartbeat_interval'] / 1000)\n      self.h = Heartbeat(self, interval)\n      self.h.daemon = True\n      self.h.start()\n    elif m[\"op\"] == self.HEARTBEAT_ACK:\n      pass\n    else:\n      self.logger.debug(m)", "response": "Called when a message is received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_error(self, ws, error):\n    if type(error).__name__ == \"KeyboardInterrupt\":\n      sys.exit()\n    self.logger.debug(\"error\")", "response": "Called when an error occurs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a message to a user", "response": "def send_message(self, user=None, message=None, channel=None):\n    \"\"\" Todo \"\"\"\n    self.logger.info(\"sending message to %s: %s\", user, message)\n    cid=channel\n    if not cid:\n      for cid in self.channels:\n        if str(self.channels[cid]) == str(user):\n          channel=cid\n          self.logger.debug(cid)\n    if (channel):\n      self.post('channels/'+cid+'/messages',\n                json.dumps({'content': message,\n                            'nonce': random_integer(-2**63, 2**63 - 1)}))\n    else:\n      logger.error(\"Unknown user %s\",user)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns the heartbeat loop.", "response": "def run(self):\n    \"\"\" Todo \"\"\"\n    self.logger.debug(\"heartbeat started\")\n    while True:\n      time.sleep(self.interval)\n      self.send_heartbeat()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_heartbeat(self):\n    self.logger.debug(\"heartbeat \"+str(self.t.sequence))\n    self.t.ws.send(json.dumps({'op': self.t.HEARTBEAT,\n                               'd': self.t.sequence}))", "response": "Send a heartbeat to the server."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply the Inference with restarts to the object with the given id.", "response": "def multiprocessing_apply_infer(object_id):\n    \"\"\"\n    Used in the InferenceWithRestarts class.\n    Needs to be in global scope for multiprocessing module to pick it up\n\n    \"\"\"\n    global inference_objects, inference_args, inference_kwargs\n    return inference_objects[object_id]._infer_raw(*inference_args, **inference_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reps_to_intensity(reps, slope=-4.8, constant=97.5, quadratic=True):\n    intensity = constant + slope * (reps - 1)\n    if quadratic:\n        return intensity + 0.05 * (reps - 1) ** 2\n    else:\n        return intensity", "response": "A function mapping from repetitions in the range 0 to 100 to intensities in the range 0 to 100."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef progression_linear(week, start_weight, final_weight, start_week, end_week):\n    # Calculate the slope of the linear function\n    slope = (start_weight - final_weight) / (start_week - end_week)\n\n    # Return the answer y = slope (x - x_0) + y_0\n    return slope * (week - start_week) + start_weight", "response": "A linear progression function going through the points\n    start_week and end_week and returns the answer y_0."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a single element from the domain.", "response": "def generate_one(self):\n        \"\"\"Generate a single element.\n    \n        Returns\n        -------\n        element\n            An element from the domain.\n    \n    \n        Examples\n        -------\n        >>> generator = RepellentGenerator(['a', 'b'])\n        >>> gen_item = generator.generate_one()\n        >>> gen_item in ['a', 'b']\n        True\n        \"\"\"\n        # Get the weights for all items in the domain\n        weights = [self.probability_func(self.generated[element])\n                   for element in self.domain]\n\n        # Sample from the domain using the weights\n        element = random.choices(self.domain, weights=weights)[0]\n\n        # Update the generated values and return\n        self.generated[element] += 1\n\n        return element"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_comments(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.CommentList(self._results, runtime=self._runtime)", "response": "Gets the comment list resulting from a search."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_books(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.BookList(self._results, runtime=self._runtime)", "response": "Gets the book list resulting from a search."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_part_mdata():\n    return {\n        'assessment_part': {\n            'element_label': {\n                'text': 'assessment part',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'assessment': {\n            'element_label': {\n                'text': 'assessment',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'weight': {\n            'element_label': {\n                'text': 'weight',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a cardinal value',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_cardinal_values': [None],\n            'syntax': 'CARDINAL',\n            'minimum_cardinal': None,\n            'maximum_cardinal': None,\n            'cardinal_set': []\n        },\n        'allocated_time': {\n            'element_label': {\n                'text': 'allocated time',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid duration object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_duration_values': [None],\n            'syntax': 'DURATION',\n            'date_time_set': [],\n        },\n    }", "response": "Return default mdata map for AssessmentPart"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn default mdata map for SequenceRule", "response": "def get_sequence_rule_mdata():\n    \"\"\"Return default mdata map for SequenceRule\"\"\"\n    return {\n        'next_assessment_part': {\n            'element_label': {\n                'text': 'next assessment part',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'cumulative': {\n            'element_label': {\n                'text': 'cumulative',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'assessment_part': {\n            'element_label': {\n                'text': 'assessment part',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'minimum_score': {\n            'element_label': {\n                'text': 'minimum score',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a cardinal value',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_cardinal_values': [None],\n            'syntax': 'CARDINAL',\n            'minimum_cardinal': None,\n            'maximum_cardinal': None,\n            'cardinal_set': []\n        },\n        'maximum_score': {\n            'element_label': {\n                'text': 'maximum score',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a cardinal value',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_cardinal_values': [None],\n            'syntax': 'CARDINAL',\n            'minimum_cardinal': None,\n            'maximum_cardinal': None,\n            'cardinal_set': []\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning default mdata map for Authorization", "response": "def get_authorization_mdata():\n    \"\"\"Return default mdata map for Authorization\"\"\"\n    return {\n        'function': {\n            'element_label': {\n                'text': 'function',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'qualifier': {\n            'element_label': {\n                'text': 'qualifier',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmatch the time of this log entry.", "response": "def match_timestamp(self, start_time, end_time, match):\n        \"\"\"Matches the time of this log entry.\n\n        arg:    start_time (osid.calendaring.DateTime): start time\n        arg:    end_time (osid.calendaring.DateTime): end time\n        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n        raise:  InvalidArgument - ``start_time`` is greater than\n                ``end_time``\n        raise:  NullArgument - ``start_time`` or ``end_time`` is\n                ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._match_minimum_date_time('timestamp', start_time, match)\n        self._match_maximum_date_time('timestamp', end_time, match)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_repository_view(self, session):\n        if self._repository_view == COMPARATIVE:\n            try:\n                session.use_comparative_repository_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_repository_view()\n            except AttributeError:\n                pass", "response": "Sets the underlying repository view to match current view"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef use_plenary_repository_view(self):\n        self._repository_view = PLENARY\n        # self._get_provider_session('asset_repository_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_repository_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssetRepositorySession. use_plenary_repository_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_comparative_composition_repository_view(self):\n        self._repository_view = COMPARATIVE\n        # self._get_provider_session('composition_repository_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_repository_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider CompositionRepositorySession. use_comparative_composition_repository_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider CompositionRepositorySession. get_repositories_by_composition", "response": "def get_repositories_by_composition(self, *args, **kwargs):\n        \"\"\"Pass through to provider CompositionRepositorySession.get_repositories_by_composition\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        catalogs = self._get_provider_session('composition_repository_session').get_repositories_by_composition(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Repository(self._provider_manager, cat, self._runtime, self._proxy))\n        return RepositoryList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npasses through to provider RepositoryLookupSession. get_repositories", "response": "def get_repositories(self):\n        \"\"\"Pass through to provider RepositoryLookupSession.get_repositories\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('repository_lookup_session').get_repositories()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Repository(self._provider_manager, cat, self._runtime, self._proxy))\n        return RepositoryList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_repository(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.create_bin\n        return Repository(\n            self._provider_manager,\n            self._get_provider_session('repository_admin_session').create_repository(*args, **kwargs),\n            self._runtime,\n            self._proxy)", "response": "Pass through to provider RepositoryAdminSession. create_repository"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_repository_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'repository_record_types' in kwargs:\n            return self.get_repository_form_for_create(*args, **kwargs)\n        else:\n            return self.get_repository_form_for_update(*args, **kwargs)", "response": "Pass through to provider RepositoryAdminSession. get_repository_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_repository(self, repository_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if repository_form.is_for_update():\n            return self.update_repository(repository_form, *args, **kwargs)\n        else:\n            return self.create_repository(repository_form, *args, **kwargs)", "response": "Pass through to provider RepositoryAdminSession. update_repository"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_repository_view(self, session):\n        if self._repository_view == FEDERATED:\n            try:\n                session.use_federated_repository_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_repository_view()\n            except AttributeError:\n                pass", "response": "Sets the underlying repository view to match current view"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass through to provider AssetLookupSession. use_comparative_asset_view", "response": "def use_comparative_asset_view(self):\n        \"\"\"Pass through to provider AssetLookupSession.use_comparative_asset_view\"\"\"\n        self._object_views['asset'] = COMPARATIVE\n        # self._get_provider_session('asset_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_asset_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_plenary_asset_view(self):\n        self._object_views['asset'] = PLENARY\n        # self._get_provider_session('asset_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_asset_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssetLookupSession. use_plenary_asset_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use_federated_repository_view(self):\n        self._repository_view = FEDERATED\n        # self._get_provider_session('asset_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_federated_repository_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssetLookupSession. use_federated_repository_view"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass through to provider AssetLookupSession. use_isolated_repository_view", "response": "def use_isolated_repository_view(self):\n        \"\"\"Pass through to provider AssetLookupSession.use_isolated_repository_view\"\"\"\n        self._repository_view = ISOLATED\n        # self._get_provider_session('asset_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_isolated_repository_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_asset_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'asset_record_types' in kwargs:\n            return self.get_asset_form_for_create(*args, **kwargs)\n        else:\n            return self.get_asset_form_for_update(*args, **kwargs)", "response": "Pass through to provider AssetAdminSession. get_asset_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass through to provider AssetAdminSession. update_asset", "response": "def save_asset(self, asset_form, *args, **kwargs):\n        \"\"\"Pass through to provider AssetAdminSession.update_asset\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if asset_form.is_for_update():\n            return self.update_asset(asset_form, *args, **kwargs)\n        else:\n            return self.create_asset(asset_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef use_comparative_asset_composition_view(self):\n        self._object_views['asset_composition'] = COMPARATIVE\n        # self._get_provider_session('asset_composition_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_asset_composition_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AssetCompositionSession. use_comparative_asset_composition_view"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass through to provider AssetCompositionSession. use_plenary_asset_composition_view", "response": "def use_plenary_asset_composition_view(self):\n        \"\"\"Pass through to provider AssetCompositionSession.use_plenary_asset_composition_view\"\"\"\n        self._object_views['asset_composition'] = PLENARY\n        # self._get_provider_session('asset_composition_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_asset_composition_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider CompositionLookupSession. use_comparative_composition_view", "response": "def use_comparative_composition_view(self):\n        \"\"\"Pass through to provider CompositionLookupSession.use_comparative_composition_view\"\"\"\n        self._object_views['composition'] = COMPARATIVE\n        # self._get_provider_session('composition_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_composition_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef use_plenary_composition_view(self):\n        self._object_views['composition'] = PLENARY\n        # self._get_provider_session('composition_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_composition_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider CompositionLookupSession. use_plenary_composition_view"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef use_active_composition_view(self):\n        self._operable_views['composition'] = ACTIVE\n        # self._get_provider_session('composition_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_active_composition_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider CompositionLookupSession. use_active_composition_view"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef use_any_status_composition_view(self):\n        self._operable_views['composition'] = ANY_STATUS\n        # self._get_provider_session('composition_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_any_status_composition_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider CompositionLookupSession. use_any_status_composition_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider CompositionLookupSession. use_sequestered_composition_view", "response": "def use_sequestered_composition_view(self):\n        \"\"\"Pass through to provider CompositionLookupSession.use_sequestered_composition_view\"\"\"\n        self._containable_views['composition'] = SEQUESTERED\n        # self._get_provider_session('composition_lookup_session')  # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_sequestered_composition_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass through to provider CompositionLookupSession. use_unsequestered_composition_view", "response": "def use_unsequestered_composition_view(self):\n        \"\"\"Pass through to provider CompositionLookupSession.use_unsequestered_composition_view\"\"\"\n        self._containable_views['composition'] = UNSEQUESTERED\n        # self._get_provider_session('composition_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_unsequestered_composition_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider CompositionAdminSession. get_composition_form_for_update", "response": "def get_composition_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider CompositionAdminSession.get_composition_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'composition_record_types' in kwargs:\n            return self.get_composition_form_for_create(*args, **kwargs)\n        else:\n            return self.get_composition_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npassing through to provider CompositionAdminSession. update_composition", "response": "def save_composition(self, composition_form, *args, **kwargs):\n        \"\"\"Pass through to provider CompositionAdminSession.update_composition\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if composition_form.is_for_update():\n            return self.update_composition(composition_form, *args, **kwargs)\n        else:\n            return self.create_composition(composition_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect(self):\n    self.transport = Transport(self.token, on_connect=self.on_connect, on_message=self.on_message)", "response": "Connect to the server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_connect(self, user):\n    self.user = user\n    self.logger.info(\"connected as %s\", user)\n    if not isinstance(self.con_connect, type(None)):\n      self.con_connect(user)", "response": "Called when a user connects to the sequence of nodes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_message(self, data):\n    if self.user.id != data.author.id:\n      self.logger.info(\"Message from %s: %s\", data.author, data.content)\n      if not isinstance(self.con_message, type(None)):\n        self.logger.debug(type(self.con_message))\n        self.con_message(data)", "response": "Called when a message is received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_message(self, user=None, message=None,channel=None):\n    self.transport.send_message(user=user, message=message, channel=channel)", "response": "Send a message to the virtual machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_metadata(self):\n        self._learning_objective_id_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'learning_objective_id'),\n            'element_label': 'Learning Objective Id',\n            'instructions': 'accepts a valid OSID Id string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }\n        self._minimum_proficiency_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'minimum_proficiency'),\n            'element_label': 'Minimum Proficiency in the given Objective to \"pass\"',\n            'instructions': 'accepts a valid OSID Id string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }", "response": "Initialize metadata for the object class."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the asset content filename on disk to match the ac. ident and the asset content id.", "response": "def _update_asset_content_filename_on_disk_to_match_id(self, ac):\n        \"\"\"Because we want the asset content filename to match the ac.ident,\n        here we manipulate the saved file on disk after creating the\n        asset content\"\"\"\n        def has_secondary_storage():\n            return 'secondary_data_store_path' in self._config_map\n\n        datastore_path = ''\n        secondary_data_store_path = ''\n\n        if 'data_store_full_path' in self._config_map:\n            datastore_path = self._config_map['data_store_full_path']\n        if has_secondary_storage():\n            secondary_data_store_path = self._config_map['secondary_data_store_path']\n        relative_path = self._config_map['data_store_path']\n\n        filepath = os.path.join(datastore_path, ac._my_map['url'])\n        old_filename = os.path.splitext(os.path.basename(filepath))[0]\n        new_path = filepath.replace(old_filename, ac.ident.identifier)\n        os.rename(filepath, new_path)\n\n        # Should also rename the file stored in the secondary path\n        if has_secondary_storage():\n            old_path = '{0}/repository/AssetContent'.format(relative_path)\n            filepath = os.path.join(datastore_path, ac._my_map['url']).replace(old_path, secondary_data_store_path)\n            old_filename = os.path.splitext(os.path.basename(filepath))[0]\n            new_path = filepath.replace(old_filename, ac.ident.identifier)\n            os.rename(filepath, new_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the ac URL value to match the ident", "response": "def _update_asset_content_url_to_match_id(self, ac):\n        \"\"\"update the ac URL value to match the ident\"\"\"\n        mgr = self._provider_session._get_provider_manager('REPOSITORY')\n        aas = mgr.get_asset_admin_session_for_repository(self._provider_session._catalog_id,\n                                                         proxy=self._provider_session._proxy)\n        form = aas.get_asset_content_form_for_update(ac.ident)\n\n        url = ac._my_map['url']\n        old_url = os.path.splitext(os.path.basename(url))[0]\n        new_url = url.replace(old_url, ac.ident.identifier)\n\n        form.set_url(new_url)\n        return aas.update_asset_content(form)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting content from an Asset.", "response": "def delete_asset_content(self, asset_content_id=None):\n        \"\"\"Deletes content from an ``Asset``.\n\n        arg:    asset_content_id (osid.id.Id): the ``Id`` of the\n                ``AssetContent``\n        raise:  NotFound - ``asset_content_id`` is not found\n        raise:  NullArgument - ``asset_content_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        asset_content = self._get_asset_content(asset_content_id)\n        if asset_content.has_url() and 'repository/AssetContent' in asset_content.get_url():\n            os.remove(asset_content.get_url())\n            self._provider_session.delete_asset_content(asset_content_id)\n        else:\n            self._provider_session.delete_asset_content(asset_content_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the map for this record", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(edXNumericResponseQuestionFormRecord, self)._init_map()\n        QuestionTextFormRecord._init_map(self)\n        QuestionFilesFormRecord._init_map(self)\n        self.my_osid_object_form._my_map['text']['text'] = ''"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the metadata for this record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(edXNumericResponseQuestionFormRecord, self)._init_metadata()\n        QuestionTextFormRecord._init_metadata(self)\n        QuestionFilesFormRecord._init_metadata(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_net(df,tf_idf,dump_path=None):\n    '''Generate WordNetwork dict of Word() instance, and dump as a file if asked to.\n\n    @Args:\n    --\n    df :        IDF value generated by find_tf_idf()\n    tf_idf :    TF-IDF value generated by find_tf_idf()\n    dump_path : file_path where to dump network entities, standart format is '.wrnt' (default=None)\n\n    @returns:\n    --\n    word_net : list if Word() instances.(creating a network of words)\n    '''\n    # error handling\n    if dump_path and dump_path[-4:] != __WRNT_FORMAT: raise Exception(__WRNG_FORMAT_MSG)\n\n    start_t = datetime.now()\n    print(TAG,'Network Genertion initiated..')\n    word_net = {} # list of word entities.\n    \n    #registering all word instances in a dict of network\n    for word in df.keys():\n        word_net[word] = Word(word)\n    print(TAG,'word-network instances created..',datetime.now()-start_t)\n    start_t = datetime.now()\n\n    #TODO: code for going through all the tf_idf elements and finding backward links and forward links of every word in word_net.\n    for docs in tf_idf:\n        for word in docs.keys():\n            word_net[word].addtofrwrd_links(set(docs.keys()))\n    print(TAG, 'word filled with their relative words(network generated)... ',datetime.now()-start_t)\n    \n    # Dump the generated lists if dump_path is given.\n    if dump_path:\n        start_t = datetime.now()\n        __words = {}\n        __network = []\n        i=0\n        # creating word dict for refrence in next stage.\n        for word in word_net:\n            __words[word] = i\n            i+=1\n        # creating final network list to be dumped. format=['word',1,2,3,4...(refrences from words dict)]\n        for word in word_net:   \n            __temp_list = [word]\n            __temp_list.extend([__words[w] for w in word_net[word].frwrd_links])\n            __network.append(__temp_list)\n            del __temp_list\n        print(TAG, 'created final relative-words list.. return ready.',datetime.now()-start_t)\n        start_t = datetime.now()\n        # Dumping data using pickle\n        dump_file = open(dump_path,'wb')\n        pickle.dump(__network,dump_file,protocol=pickle.HIGHEST_PROTOCOL)\n        dump_file.close()\n        print(TAG,'word network dumped @',dump_path,datetime.now()-start_t)\n        #cleaning afterwards\n        del __words\n        del __network\n\n    return word_net", "response": "Generate WordNetwork dict of Word instances and dump as a file if asked to."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef retrieve_net(wrnt_path):\n    '''Rerieves a dumped Network and generates WordNet instance.\n\n    @Args:\n    --\n    wrnt_path : file_path to the '.wrnt' network dumped file.\n\n    @returns:\n    --\n    word_net : dict of Word() entities generated from the input file.\n    '''\n    # Exception Handling of  wrong format.\n    if wrnt_path[-4:] != __WRNT_FORMAT: raise Exception(__WRNG_FORMAT_MSG)\n    \n    file = open(wrnt_path,'rb')\n    # retrieving a network  from .wrnt file.\n    network = pickle.load(file)\n    file.close()\n    # Generating Word() instance dictionary from retrieved network.\n    word_net = {}\n    for n in network:\n        word_net[n[0]] = Word(n[0],None,set([network[i][0] for i in n[1:]]))\n    # deleting useless resources, for efficient memory usage.\n    del network\n    return word_net", "response": "Rerieves a dumped Network and generates WordNet instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef return_net(word,word_net,depth=1):\n    '''Creates a list of unique words that are at a provided depth from root word.\n\n    @Args:\n    --\n    word :      root word from which the linked words should be returned.\n    word_net :  word network (dictionary of word instances)to be refered in this process.\n    depth :     depth to which this process must traverse and return words.\n\n    @return:\n    ---\n    res :   List of words that are within a certain depth from root word in network.\n\n    '''\n    if depth<1: raise Exception(TAG+\"Degree value error.range(1,~)\")\n    if depth==1:\n        return list(word_net[word].frwrd_links)\n    elif depth>1:\n        words  = word_net[word].frwrd_links\n        res=[]\n        for w in words: res.extend(return_net(w,word_net,depth=depth-1))\n        return list(set(res))", "response": "Returns a list of unique words that are at a certain depth from root word in word_net."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_config(self, name=None, path=None, home=False, ext='ini'):\n\n        opj = os.path.join\n\n        self.name = name\n        self.filename = '%s.%s' % (self.name, ext)\n\n        checks = []\n        if path is not None:\n            checks.append(opj(path.rstrip(os.sep), self.filename))\n        elif home is True:\n            checks.append(opj(os.getenv('HOME'), '%s' % self.filename))\n        else:\n            checks.append(opj('/etc', self.name, self.filename))\n\n        for check in checks:\n            if os.path.exists(check):\n                self.config_file = check\n                break\n        else:\n            self._find_config(name)", "response": "Load a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _find_config(self, config_file):\n        msg = ('Configuration file [ %s ] was not found.' % self.filename)\n        self.log.fatal(msg)\n        raise IOError(msg)", "response": "This method will check if the configuration file exist and if it does raise an IOError."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_perms(self, perms='0600,0400'):\n        confpath = os.path.realpath(self.config_file)\n        mode = stat.S_IMODE(os.stat(confpath).st_mode)\n        if not any([mode == int(i, 8) for i in perms.split(',')]):\n            msg = (\n                'To use a configuration file the permissions'\n                ' need to be any of the following \"%s\"' % perms\n            )\n            self.log.fatal(msg)\n            raise SystemExit(msg)\n        else:\n            self.log.info(\n                'Configuration file [ %s ] has been loaded',\n                self.config_file\n            )\n            return True", "response": "Check and enforce the permissions of a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef config_args(self, section='default'):\n        if sys.version_info >= (2, 7, 0):\n            parser = ConfigParser.SafeConfigParser(allow_no_value=True)\n        else:\n            parser = ConfigParser.SafeConfigParser()\n\n        # Set to preserve Case\n        parser.optionxform = str\n        args = {}\n        try:\n            parser.read(self.config_file)\n            for name, value in parser.items(section):\n                if any([value == 'False', value == 'false']):\n                    value = False\n                elif any([value == 'True', value == 'true']):\n                    value = True\n                else:\n                    value = utils.is_int(value=value)\n                args[name] = value\n        except Exception as exp:\n            self.log.warn('Section: [ %s ] Message: \"%s\"', section, exp)\n            return {}\n        else:\n            return args", "response": "Loop through the configuration file and set all of our values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_asset_content_lookup_session(self):\n        return getattr(sessions, 'AssetContentLookupSession')(\n            provider_session=self._provider_manager.get_asset_content_lookup_session(),\n            authz_session=self._authz_session)", "response": "Pass through to provider get_asset_content_lookup_session"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_asset_content_lookup_session_for_repository(self, repository_id):\n        return getattr(sessions, 'AssetContentLookupSession')(\n            provider_session=self._provider_manager.get_asset_content_lookup_session_for_repository(repository_id),\n            authz_session=self._authz_session)", "response": "Pass through to provider AssetContentLookupSession."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_asset_content_lookup_session(self, proxy):\n        return getattr(sessions, 'AssetContentLookupSession')(\n            provider_session=self._provider_manager.get_asset_content_lookup_session(proxy),\n            authz_session=self._get_authz_session(),\n            proxy=proxy)", "response": "Pass through to provider get_asset_content_lookup_session"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef end_range(self):\n      if len(self._exons) == 0: return None\n      return GenomicRange(self._exons[0].chr,\n             min([x.end for x in self._exons]),\n             max([x.end for x in self._exons]))", "response": "Similar to the junction range but don t need to check for leftmost or rightmost exons"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _rngs(self):\n      outputs = []\n      if len(self._exon_groups)==1:\n         return [self._exon_groups.consensus('single')]\n      z = 0 #output count\n      begin = 0\n      meeting_criteria = [i for i in range(0,len(self._exon_groups)) if  len(self._exon_groups) >= self._evidence]\n      if len(meeting_criteria) == 0: return []\n      finish = len(meeting_criteria)\n      if len(meeting_criteria) > 0:\n         begin = meeting_criteria[0]\n         finish = meeting_criteria[-1]\n      for i in range(0,len(self._exon_groups)):\n         if z == begin:\n            outputs.append(self._exon_groups[i].consensus('leftmost'))\n         elif z == finish:\n            #len(self._exon_groups)-1:\n            outputs.append(self._exon_groups[i].consensus('rightmost'))\n         else:\n            outputs.append(self._exon_groups[i].consensus('internal'))\n         z += 1\n      v = [seqtools.structure.transcript.Exon(x) for x in outputs]\n      v[0].set_leftmost()\n      v[-1].set_rightmost()\n      return v", "response": "This is where we enforce evidence requirements"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_transcripts(self,txs):\n      passed = []\n      for tx2 in txs:\n         for tx1 in self._initial:\n            jov = tx1.junction_overlap(tx2,self._tolerance)\n            sub = jov.is_subset()\n            if sub == 1 or sub == 2:\n               passed.append(tx2)\n               break\n      if len(passed) == 0:\n         sys.stderr.write(\"Warning unable to add\\n\")\n         return\n      for tx in txs:\n         self.add_transcript(tx)\n      return", "response": "Add transcripts from other transcripts to the current transcript group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a single transcript", "response": "def add_transcript(self,tx):\n      \"\"\"add a single transcript\"\"\"\n      candidates = tx.junctions\n      targets = self.junctions\n      matches = []\n      for i in range(0,len(targets)):\n         for j in range(0,len(candidates)):\n            if targets[i].overlaps(candidates[j],self._tolerance):\n               matches.append([i,j])\n      if len(matches) != len(candidates): return\n      if len(matches) > 1:\n         if False in  [(matches[i+1][0]-matches[i][0])==1 and\n                       (matches[i+1][1]-matches[i][1])==1 for i in range(0,len(matches)-1)]:\n            return\n      # nowe we can add them\n      for m in matches:\n         self._exon_groups[m[0]].add_exon(tx.exons[m[1]])\n         self._exon_groups[m[0]+1].add_exon(tx.exons[m[1]+1])\n      self._transcripts.append(tx)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(self,tolerance=0,downsample=None,evidence=2,use_gene_names=False):\n      g = Graph()\n      nodes = [Node(x) for x in self._transcripts]\n      for n in nodes: g.add_node(n)\n      for i in range(0,len(nodes)):\n         for j in range(0,len(nodes)):\n            if i == j: continue\n            jov = nodes[i].payload.junction_overlap(nodes[j].payload,tolerance)\n            sub = jov.is_subset()\n            if not sub: continue\n            if sub == 1:\n               g.add_edge(Edge(nodes[i],nodes[j]))\n               g.add_edge(Edge(nodes[j],nodes[i]))\n            if sub == 2:\n               g.add_edge(Edge(nodes[i],nodes[j]))\n      g.merge_cycles()\n      roots = g.roots\n      groups = []\n      for r in roots:\n         g2 = g.get_root_graph(r)\n         c = CompatibleGraph(g2,tolerance,downsample,evidence,use_gene_names=use_gene_names)\n         groups.append(c)\n      return groups", "response": "Divide out the transcripts."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread an entry from the locus stream and returns the range that describes the bounds of the current element.", "response": "def read_entry(self):\n      \"\"\"As long as entires overlap keep putting them together in a list that is\n         the payload for a range that describes the bounds of the list\n\n      :return: range with payload list of elements\n      :rtype: GenomicRange\n      \"\"\"\n      if not self._current_range:\n         return None\n      output = None\n      while True:\n         try:\n           e = self._stream.next()\n         except StopIteration: e = None\n         if e:\n            rng = e.range\n            if not rng:\n               raise ValueError('no range property. it is required in a locus stream')\n            if rng.overlaps(self._current_range):\n               self._current_range.payload.append(e)\n               if self._current_range.end < rng.end: self._current_range.end = rng.end\n            else:\n               output = self._current_range\n               self._current_range = rng\n               self._current_range.set_payload([e])\n               break\n         else:\n            output = self._current_range\n            self._current_range = None\n            break\n      return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns start and stop positions for all frames in the given transcript.", "response": "def get_start_stops(transcript_sequence, start_codons=None, stop_codons=None):\n        \"\"\"Return start and stop positions for all frames in the given\n        transcript.\n\n        \"\"\"\n        transcript_sequence = transcript_sequence.upper()  # for comparison with codons below\n        if not start_codons:\n            start_codons = ['ATG']\n        if not stop_codons:\n            stop_codons = ['TAA', 'TAG', 'TGA']\n\n        seq_frames = {1: {'starts': [], 'stops': []},\n                      2: {'starts': [], 'stops': []},\n                      3: {'starts': [], 'stops': []}}\n\n        for codons, positions in ((start_codons, 'starts'),\n                                  (stop_codons, 'stops')):\n            if len(codons) > 1:\n                pat = re.compile('|'.join(codons))\n            else:\n                pat = re.compile(codons[0])\n\n            for m in re.finditer(pat, transcript_sequence):\n                # Increment position by 1, Frame 1 starts at position 1 not 0\n                start = m.start() + 1\n                rem = start % 3\n                if rem == 1:  # frame 1\n                    seq_frames[1][positions].append(start)\n                elif rem == 2:  # frame 2\n                    seq_frames[2][positions].append(start)\n                elif rem == 0:  # frame 3\n                    seq_frames[3][positions].append(start)\n        return seq_frames"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_rna_counts(rna_file, transcript_name):\n    # check if the RNA file exists\n    if not os.path.exists(rna_file):\n        msg = 'RNA-Seq BAM file \"{}\" does not exist'.format(rna_file)\n        logging.error(msg)\n        raise OSError(msg)\n    rna_counts = {}\n\n    cov_file = tempfile.NamedTemporaryFile(delete=False)\n    try:\n        subprocess.check_call(\n            ['bedtools', 'genomecov', '-ibam', rna_file,\n             '-bg'], stdout=cov_file)\n    except subprocess.CalledProcessError as e:\n        # needs testing\n        raise ribocore.RNACountsError('Could not generate coverage for RNA BAM file. \\n{}\\n'.format(e))\n    for line in open(cov_file.name):\n        line = line.split()\n        if line[0] == transcript_name:\n            position, count = int(line[1]) + 1, int(line[3])\n            rna_counts[position] = count\n    cov_file.close()\n    os.unlink(cov_file.name)\n    return rna_counts", "response": "Get read counts for a given RNA BAM file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_axis_color(axis, color, alpha=None):\n    for side in ('top', 'right',  'bottom', 'left'):\n        spine = axis.spines[side]\n        spine.set_color(color)\n        if alpha is not None:\n            spine.set_alpha(alpha)", "response": "Sets the color of all sides of an axis."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning colors for a given scheme.", "response": "def get_color_palette(scheme):\n    \"\"\"Return colors for a given scheme. Default colors are returned for an item\n    if undefined in scheme.\n\n    \"\"\"\n    color_schemes = {\n        'default': {\n            'frames': ['tomato', 'limegreen', 'deepskyblue'], 'background': '#ffffff',\n            'color': '#616161', 'ticks': '#757575', 'start': '#ffffff', 'stop': '#909090',\n            'rna': '#eaeaea', 'axis': '#e0e0e0', 'grey': '#bdbdbd'\n        },\n        'colorbrewer': {\n            'frames': ['#fc8d62', '#66c2a5', '#8da0cb']\n        },\n        'rgb': {\n            'frames': ['red', 'green', 'blue']\n        },\n        'greyorfs': {}\n    }\n\n    colors = {}\n    for k, v in color_schemes['default'].items():\n        try:\n            vals = color_schemes[scheme][k]\n        except KeyError:\n            vals = v\n        colors[k] = vals\n    return colors"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_profile(ribo_counts, transcript_name, transcript_length,\n                 start_stops, read_lengths=None, read_offsets=None, rna_counts=None,\n                 color_scheme='default', html_file='index.html', output_path='output'):\n    \"\"\"Plot read counts (in all 3 frames) and RNA coverage if provided for a\n    single transcript.\n\n    \"\"\"\n    colors = get_color_palette(scheme=color_scheme)\n    gs = gridspec.GridSpec(3, 1, height_ratios=[6, 1.3, 0.5], hspace=0.35)\n    font_axis = {'family': 'sans-serif', 'color': colors['color'], 'weight': 'bold', 'size': 7}\n\n    # riboseq bar plots\n    gs2 = gridspec.GridSpecFromSubplotSpec(1, 1, subplot_spec=gs[0])\n    ax2 = plt.subplot(gs2[0])\n    label = 'Ribo-Seq count'\n\n    if read_lengths:\n        if len(read_lengths) > 1:\n            label = 'Ribo-Seq count ({}-mers)'.format(', '.join('{}'.format(item) for item in read_lengths))\n        else:\n            label = 'Ribo-Seq count ({}-mer)'.format('{}'.format(read_lengths[0]))\n\n    ax2.set_ylabel(label, fontdict=font_axis, labelpad=10)\n\n    # rna coverage if available\n    ax_rna = None\n    if rna_counts:\n        ax_rna = ax2.twinx()\n        ax_rna.set_ylabel('RNA-Seq count', fontdict=font_axis, labelpad=10)\n        ax_rna.bar(rna_counts.keys(), rna_counts.values(), facecolor=colors['rna'],\n                   edgecolor=colors['rna'], label='RNA')\n        ax_rna.set_zorder(1)\n\n    frame_counts = {1: {}, 2: {}, 3: {}}\n    for k, v in ribo_counts.iteritems():\n        for fr in (1, 2, 3):\n            if v[fr] > 0:\n                frame_counts[fr][k] = v[fr]\n                break\n\n    cnts = []\n    [cnts.extend(item.values()) for item in frame_counts.values()]\n    y_max = float(max(cnts) * 1.25)\n    ax2.set_ylim(0.0, y_max)\n    ax2.set_zorder(2)\n    ax2.patch.set_facecolor('none')\n\n    for frame in (1, 2, 3):\n        color = colors['frames'][frame - 1]\n        x_vals = frame_counts[frame].keys()\n        ax2.bar(x_vals, frame_counts[frame].values(), color=color, facecolor=color, edgecolor=color)\n\n    # ORF architecture\n    gs3 = gridspec.GridSpecFromSubplotSpec(3, 1, subplot_spec=gs[1], hspace=0.1)\n    if color_scheme == 'greyorfs':\n        axisbg = [colors['grey'] for i in range(3)]\n    else:\n        axisbg = colors['frames']\n\n    ax4 = plt.subplot(gs3[0], sharex=ax2, axisbg=axisbg[0])\n    ax5 = plt.subplot(gs3[1], sharex=ax2, axisbg=axisbg[1])\n    ax6 = plt.subplot(gs3[2], sharex=ax2, axisbg=axisbg[2])\n    ax6.set_xlabel('Transcript length ({} nt)'.format(transcript_length), fontdict=font_axis, labelpad=6)\n\n    # Legend\n    gs4 = gridspec.GridSpecFromSubplotSpec(1, 1, subplot_spec=gs[2], hspace=0.1)\n    ax7 = plt.subplot(gs4[0], axisbg=colors['background'])\n    set_axis_color(ax7, colors['background'])\n\n    ax7.text(0.02, 0.1, \"AUG\", size=5, ha=\"center\", va=\"center\", color=colors['color'],\n             bbox=dict(boxstyle=\"square\", facecolor=colors['start'], edgecolor=colors['color'], linewidth=0.3))\n    ax7.text(0.06, 0.1, \"STOP\", size=5, ha=\"center\", va=\"center\", color='white',\n             bbox=dict(boxstyle=\"square\", color=colors['stop']))\n    ax7.text(0.13, 0.1, \"Frames\", size=5, ha='center', va='center', color=colors['color'],\n             fontdict={'weight': 'bold'})\n    ax7.text(0.17, 0.1, \"1\", size=5, ha=\"center\", va=\"center\", color='white',\n             bbox=dict(boxstyle=\"square\", color=colors['frames'][0]))\n    ax7.text(0.19, 0.1, \"2\", size=5, ha=\"center\", va=\"center\", color='white',\n             bbox=dict(boxstyle=\"square\", color=colors['frames'][1]))\n    ax7.text(0.21, 0.1, \"3\", size=5, ha=\"center\", va=\"center\", color='white',\n             bbox=dict(boxstyle=\"square\", color=colors['frames'][2]))\n\n    # No ticks or labels for ORF 1, 2 and Legend\n    for axis in (ax4, ax5, ax7):\n        axis.tick_params(top=False, left=False, right=False, bottom=False, labeltop=False,\n                         labelleft=False, labelright=False, labelbottom=False)\n\n    axes = [ax2]\n    if ax_rna:\n        axes.append(ax_rna)\n\n    fp = FontProperties(size='5')\n    for axis in axes:\n        set_axis_color(axis, colors['axis'])\n        axis.tick_params(colors=colors['ticks'])\n        for item in (axis.get_xticklabels() + axis.get_yticklabels()):\n            item.set_fontproperties(fp)\n            item.set_color(colors['color'])\n\n    for axis, frame in ((ax4, 1), (ax5, 2), (ax6, 3)):\n        if color_scheme == 'greyorfs':\n            color = colors['grey']\n        else:\n            color = colors['frames'][frame - 1]\n        set_axis_color(axis, color, alpha=0.05)\n        axis.patch.set_alpha(0.3)  # opacity of ORF architecture\n        for item in (axis.get_xticklabels()):\n            item.set_fontproperties(fp)\n            item.set_color(colors['color'])\n        axis.set_ylim(0, 0.2)\n        axis.set_xlim(0, transcript_length)\n        starts = [(item, 1) for item in start_stops[frame]['starts']]\n        stops = [(item, 1) for item in start_stops[frame]['stops']]\n        start_colors = [colors['start'] for item in starts]\n        axis.broken_barh(starts, (0.11, 0.2), facecolors=start_colors,\n                         edgecolors=start_colors, label='start', zorder=5)\n        stop_colors = [colors['stop'] for item in stops]\n        axis.broken_barh(stops, (0, 0.2), facecolors=stop_colors,\n                         edgecolors=stop_colors, label='stop', zorder=5)\n        axis.set_ylabel('{}'.format(frame),\n                        fontdict={'family': 'sans-serif', 'color': colors['color'],\n                                  'weight': 'normal', 'size': '6'},\n                        rotation='horizontal', labelpad=10, verticalalignment='center')\n        axis.tick_params(top=False, left=False, right=False, labeltop=False,\n                         labelleft=False, labelright=False, direction='out', colors=colors['ticks'])\n    plt.title('{}'.format(transcript_name),\n              fontdict={'family': 'sans-serif', 'color': colors['color'],\n                        'weight': 'bold', 'size': 8, 'y': 20})\n    if not os.path.exists(output_path):\n        os.mkdir(output_path)\n    plt.savefig(os.path.join(output_path, 'riboplot.svg'), facecolor=colors['background'])\n    plt.savefig(os.path.join(output_path, 'riboplot.png'), dpi=600, facecolor=colors['background'])\n\n    with open(os.path.join(CONFIG.PKG_DATA_DIR, 'riboplot.html')) as g, open(os.path.join(output_path, html_file), 'w') as h:\n        h.write(g.read().format(transcript_name=transcript_name))\n\n    css_dir = os.path.join(output_path, 'css')\n    if not os.path.exists(css_dir):\n        os.mkdir(css_dir)\n\n    css_data_dir = os.path.join(CONFIG.PKG_DATA_DIR, 'css')\n    for fname in os.listdir(css_data_dir):\n        shutil.copy(os.path.join(css_data_dir, fname), os.path.join(output_path, 'css', fname))", "response": "Plot the ribo counts and rna coverage for a single ribo."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(args):\n    (ribo_file, rna_file, transcript_name, transcriptome_fasta, read_lengths,\n     read_offsets, output_path, html_file) = (\n         args.ribo_file, args.rna_file, args.transcript_name, args.transcriptome_fasta,\n         args.read_lengths, args.read_offsets, args.output_path, args.html_file)\n\n    # error messages (simple format) are written to html file\n    fh = logging.FileHandler(html_file)\n    fh.setLevel(logging.ERROR)\n    fh.setFormatter(ErrorLogFormatter('%(message)s'))\n    log.addHandler(fh)\n\n    log.debug('Supplied arguments\\n{}'.format(\n        '\\n'.join(['{:<20}: {}'.format(k, v) for k, v in vars(args).items()])))\n    log.debug('Testing debugggg')\n    log.info('Checking if required arguments are valid...')\n    ribocore.check_required_arguments(\n        ribo_file=ribo_file, transcriptome_fasta=transcriptome_fasta, transcript_name=transcript_name)\n    log.info('Done')\n\n    if rna_file:\n        log.info('Checking if RNA-Seq file is valid...')\n        ribocore.check_rna_file(rna_file=rna_file)\n        log.info('Done')\n\n    log.info('Checking read lengths...')\n    ribocore.check_read_lengths(ribo_file=ribo_file, read_lengths=read_lengths)\n    log.info('Done')\n\n    log.info('Checking read offsets...')\n    ribocore.check_read_offsets(read_offsets=read_offsets)\n    log.info('Done')\n\n    log.info('Checking if each read length has a corresponding offset')\n    ribocore.check_read_lengths_offsets(read_lengths=read_lengths, read_offsets=read_offsets)\n    log.info('Done')\n\n    log.info('Get sequence and length of the given transcript from FASTA file...')\n    record = ribocore.get_fasta_record(transcriptome_fasta, transcript_name)\n    transcript_sequence = record[transcript_name]\n    transcript_length = len(transcript_sequence)\n\n    log.info('Get ribo-seq read counts and total reads in Ribo-Seq...')\n    with ribocore.open_pysam_file(fname=ribo_file, ftype='bam') as bam_fileobj:\n        ribo_counts, total_reads = ribocore.get_ribo_counts(\n            ribo_fileobj=bam_fileobj, transcript_name=transcript_name,\n            read_lengths=read_lengths, read_offsets=read_offsets)\n\n    if not ribo_counts:\n        msg = ('No RiboSeq read counts for transcript {}. No plot will be '\n               'generated!'.format(transcript_name))\n        log.error(msg)\n        raise ribocore.RiboPlotError(msg)\n    else:\n        log.info('Get RNA counts for the given transcript...')\n        mrna_counts = {}\n        if rna_file:\n            try:\n                mrna_counts = get_rna_counts(rna_file, transcript_name)\n            except OSError as e:\n                log.error(e)\n                raise\n\n            if not mrna_counts:\n                log.warn('No RNA counts for this transcript from the given RNA Seq file. '\n                         'RNA-Seq coverage will not be generated')\n        else:\n            log.debug('No RNA-Seq data provided. Not generating coverage')\n\n        log.info('Get start/stop positions in transcript sequence (3 frames)...')\n        codon_positions = get_start_stops(transcript_sequence)\n\n        if not os.path.exists(output_path):\n            os.mkdir(output_path)\n\n        log.info('Writing RiboSeq read counts for {}'.format(transcript_name))\n        with open(os.path.join(output_path, 'RiboCounts.csv'), 'w') as f:\n            f.write('\"Position\",\"Nucleotide\",\"Frame 1\",\"Frame 2\",\"Frame 3\"\\n')\n\n            for pos in range(1, transcript_length + 1):\n                if pos in ribo_counts:\n                    f.write('{0},{1},{2},{3},{4}\\n'.format(\n                        pos, transcript_sequence[pos - 1], ribo_counts[pos][1], ribo_counts[pos][2], ribo_counts[pos][3]))\n                else:\n                    f.write('{0},{1},{2},{3},{4}\\n'.format(pos, transcript_sequence[pos - 1], 0, 0, 0))\n\n        log.info('Generating RiboPlot...')\n        plot_profile(ribo_counts, transcript_name, transcript_length,\n                     codon_positions, read_lengths, read_offsets, mrna_counts,\n                     color_scheme=args.color_scheme,\n                     html_file=args.html_file, output_path=args.output_path)\n    log.info('Finished!')", "response": "Main function for the\n    script"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_metadata(self):\n        self._choices_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choices'),\n            'element_label': 'Choices',\n            'instructions': 'Enter as many choices as you wish',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_object_values': [''],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._choice_name_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'question_string'),\n            'element_label': 'choice name',\n            'instructions': 'enter a short label for this choice',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [''],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 1024,\n            'string_set': []\n        }\n        self._multi_answer_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'multi_answer'),\n            'element_label': 'Is Multi-Answer',\n            'instructions': 'accepts a boolean (True/False) value',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': ['False'],\n            'syntax': 'BOOLEAN',\n            'id_set': []\n        }", "response": "Initializes the metadata for the object class"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear_choice(self, choice):\n        if len(self.my_osid_object_form._my_map['choices']) == 0:\n            raise IllegalState('there are currently no choices defined for this question')\n        if (len(self.my_osid_object_form._my_map['choices']) == 1 and\n                choice in self.my_osid_object_form._my_map['choices']):\n            raise IllegalState()\n        self.my_osid_object_form._my_map['choices'] = \\\n            [c for c in self.my_osid_object_form._my_map['choices'] if c != choice]", "response": "clear choice from question"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the metadata for the choice text question record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(BaseMultiChoiceTextQuestionFormRecord, self)._init_metadata()\n        self._choice_text_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choice_text'),\n            'element_label': 'choice text',\n            'instructions': 'enter the text for this choice',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 1024,\n            'string_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_choice(self, text, name='', identifier=None):\n        if not utilities.is_string(text):\n            raise InvalidArgument('text is not a string')\n        choice_display_text = self._choice_text_metadata['default_string_values'][0]\n        choice_display_text['text'] = text\n        if identifier is None:\n            identifier = str(ObjectId())\n        choice = {\n            'id': identifier,\n            'text': text,\n            'name': name\n        }\n        self.my_osid_object_form._my_map['choices'].append(choice)\n        return choice", "response": "add a new choice to the list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the metadata for the Choice File Question Form record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(BaseMultiChoiceFileQuestionFormRecord, self)._init_metadata()\n        self._choice_file_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choice-file'),\n            'element_label': 'Choice File',\n            'instructions': 'accepts an Asset Id',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_choice(self, asset_id, name='', identifier=None):\n        if identifier is None:\n            identifier = str(ObjectId())\n        self.my_osid_object_form._my_map['choices'].append({\n            'id': identifier,\n            'assetId': str(asset_id),\n            'name': name\n        })\n        return identifier", "response": "add a choice to the list"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the map of fields to use for the question text and files.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        QuestionTextAndFilesMixin._init_map(self)\n        BaseMultiChoiceTextQuestionFormRecord._init_map(self)\n        super(MultiChoiceTextAndFilesQuestionFormRecord, self)._init_map()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the metadata for this record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        QuestionTextAndFilesMixin._init_metadata(self)\n        BaseMultiChoiceTextQuestionFormRecord._init_metadata(self)\n        super(MultiChoiceTextAndFilesQuestionFormRecord, self)._init_metadata()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _init_metadata(self):\n        self._choice_ids_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choice_ids'),\n            'element_label': 'response set',\n            'instructions': 'submit correct choice for answer',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n        }\n        self._choice_id_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choice_id'),\n            'element_label': 'response set',\n            'instructions': 'submit correct choice for answer',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }", "response": "Initializes the metadata for the object class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the choice ids", "response": "def clear_choice_ids(self):\n        \"\"\"stub\"\"\"\n        if (self.get_choice_ids_metadata().is_read_only() or\n                self.get_choice_ids_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['choiceIds'] = \\\n            self._choice_ids_metadata['default_object_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the map of attributes to be used by the answer form records.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        MultiChoiceAnswerFormRecord._init_map(self)\n        FilesAnswerFormRecord._init_map(self)\n        FeedbackAnswerFormRecord._init_map(self)\n        super(MultiChoiceFeedbackAndFilesAnswerFormRecord, self)._init_map()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_metadata(self):\n        MultiChoiceAnswerFormRecord._init_metadata(self)\n        FilesAnswerFormRecord._init_metadata(self)\n        FeedbackAnswerFormRecord._init_metadata(self)\n        super(MultiChoiceFeedbackAndFilesAnswerFormRecord, self)._init_metadata()", "response": "Initialize the metadata for this record."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_choices(self):\n        # ideally would return a displayText object in text ... except for legacy\n        # use cases like OEA, it expects a text string.\n        choices = []\n        # for current_choice in self.my_osid_object.object_map['choices']:\n        for current_choice in self.my_osid_object._my_map['choices']:\n            filtered_choice = {\n                'id': current_choice['id'],\n                'text': self.get_matching_language_value('texts',\n                                                         dictionary=current_choice).text,\n                'name': current_choice['name']\n            }\n            choices.append(filtered_choice)\n        return choices", "response": "returns a list of dictionaries containing the choices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the map for the MultiLanguageMultipleChoiceQuestionFormRecord.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(MultiLanguageMultipleChoiceQuestionFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['choices'] = \\\n            self._choices_metadata['default_object_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the metadata for the Choice Question record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(MultiLanguageMultipleChoiceQuestionFormRecord, self)._init_metadata()\n        self._choices_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choices'),\n            'element_label': 'choices',\n            'instructions': 'Enter as many text choices as you wish',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_choice(self, choice, name='', identifier=None):\n        if not isinstance(choice, DisplayText):\n            raise InvalidArgument('choice is not a displayText object')\n        if identifier is None:\n            identifier = str(ObjectId())\n        current_identifiers = [c['id'] for c in self.my_osid_object_form._my_map['choices']]\n        if identifier not in current_identifiers:\n            choice = {\n                'id': identifier,\n                'texts': [self._dict_display_text(choice)],\n                'name': name\n            }\n            self.my_osid_object_form._my_map['choices'].append(choice)\n        else:\n            for current_choice in self.my_osid_object_form._my_map['choices']:\n                if current_choice['id'] == identifier:\n                    self.add_or_replace_value('texts', choice, dictionary=current_choice)\n                    choice = current_choice\n        return choice", "response": "add a choice to the list of available items"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear_choice_texts(self, choice_id):\n        if self.get_choices_metadata().is_read_only():\n            raise NoAccess()\n        updated_choices = []\n        for current_choice in self.my_osid_object_form._my_map['choices']:\n            if current_choice['id'] != choice_id:\n                updated_choices.append(current_choice)\n            else:\n                updated_choices.append({\n                    'id': current_choice['id'],\n                    'texts': [],\n                    'name': current_choice['name']\n                })\n        self.my_osid_object_form._my_map['choices'] = updated_choices", "response": "clear the choice texts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread a CSV file containing a tabular description of a transition function as found in Sipser. Major difference is used to only have one header row whose entries might be tuples. Major difference is used to only have one header row whose entries might be tuples.", "response": "def read_csv(filename):\n    \"\"\"Reads a CSV file containing a tabular description of a transition function,\n       as found in Sipser. Major difference: instead of multiple header rows,\n       only a single header row whose entries might be tuples.\n       \"\"\"\n\n    with open(filename) as file:\n        table = list(csv.reader(file))\n    m = from_table(table)\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_excel(filename, sheet=None):\n\n    from openpyxl import load_workbook\n    wb = load_workbook(filename)\n    if sheet is None:\n        ws = wb.active\n    else:\n        ws = wb.get_sheet_by_name(sheet)\n    table = [[cell.value or \"\" for cell in row] for row in ws.rows]\n    return from_table(table)", "response": "Reads an Excel file containing a tabular description of a transition function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mangle(data_point):\n    temp_dict = {}\n    temp_dict.update(data_point)\n    temp_dict['utc_datetime'] = \\\n        datetime.datetime.utcfromtimestamp(temp_dict['time'])\n    if 'solar' in data_point:\n        temp_dict['GHI (W/m^2)'] = data_point['solar']['ghi']\n        temp_dict['DNI (W/m^2)'] = data_point['solar']['dni']\n        temp_dict['DHI (W/m^2)'] = data_point['solar']['dhi']\n        temp_dict['ETR (W/m^2)'] = data_point['solar']['etr']\n        del temp_dict['solar']\n    else:\n        temp_dict['GHI (W/m^2)'] = 0.0\n        temp_dict['DNI (W/m^2)'] = 0.0\n        temp_dict['DHI (W/m^2)'] = 0.0\n        temp_dict['ETR (W/m^2)'] = 0.0\n    return temp_dict", "response": "mangle data into expected format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning data as list of dicts with all data filled in.", "response": "def hourly(place):\n    \"\"\"return data as list of dicts with all data filled in.\"\"\"\n    # time in utc?\n    lat, lon = place\n    url = \"https://api.forecast.io/forecast/%s/%s,%s?solar\" % (APIKEY, lat,\n                                                               lon)\n    w_data = json.loads(urllib2.urlopen(url).read())\n    hourly_data = w_data['hourly']['data']\n    mangled = []\n    for i in hourly_data:\n        mangled.append(mangle(i))\n    return mangled"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef current(place):\n    lat, lon = place\n    url = \"https://api.forecast.io/forecast/%s/%s,%s?solar\" % (APIKEY, lat,\n                                                               lon)\n    w_data = json.loads(urllib2.urlopen(url).read())\n    currently = w_data['currently']\n    return mangle(currently)", "response": "return data as list of dicts with all data filled in"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a laminate stacking sequence from the given stack.", "response": "def read_stack(stack, plyt=None, laminaprop=None, rho=None, plyts=None, laminaprops=None,\n        rhos=None, offset=0., calc_scf=True):\n    \"\"\"Read a laminate stacking sequence data.\n\n    An ``Laminate`` object is returned based on the inputs given.\n\n    Parameters\n    ----------\n    stack : list\n        Angles of the stacking sequence in degrees.\n    plyt : float, optional\n        When all plies have the same thickness, ``plyt`` can be supplied.\n    laminaprop : tuple, optional\n        When all plies have the same material properties, ``laminaprop``\n        can be supplied.\n    rho : float, optional\n        Uniform material density to be used for all plies.\n    plyts : list, optional\n        A list of floats with the thickness of each ply.\n    laminaprops : list, optional\n        A list of tuples with a laminaprop for each ply.\n    rhos : list, optional\n        A list of floats with the material density of each ply.\n    offset : float, optional\n        Offset along the normal axis about the mid-surface, which influences\n        the laminate properties.\n    calc_scf : bool, optional\n        If True, use :method:`.Laminate.calc_scf` to compute shear correction\n        factors, otherwise the default value of 5/6 is used\n\n    Notes\n    -----\n    ``plyt`` or ``plyts`` must be supplied\n    ``laminaprop`` or ``laminaprops`` must be supplied\n\n    For orthotropic plies, the ``laminaprop`` should be::\n\n        laminaprop = (E11, E22, nu12, G12, G13, G23)\n\n    For isotropic pliey, the ``laminaprop`` should be::\n\n        laminaprop = (E, E, nu)\n\n    \"\"\"\n    lam = Laminate()\n    lam.offset = offset\n    lam.stack = stack\n\n    if plyts is None:\n        if plyt is None:\n            raise ValueError('plyt or plyts must be supplied')\n        else:\n            plyts = [plyt for i in stack]\n\n    if laminaprops is None:\n        if laminaprop is None:\n            raise ValueError('laminaprop or laminaprops must be supplied')\n        else:\n            laminaprops = [laminaprop for i in stack]\n\n    if rhos is None:\n        rhos = [rho for i in stack]\n\n    lam.plies = []\n    for plyt, laminaprop, theta, rho in zip(plyts, laminaprops, stack, rhos):\n        laminaprop = laminaprop\n        ply = Lamina()\n        ply.theta = float(theta)\n        ply.h = plyt\n        ply.matobj = read_laminaprop(laminaprop, rho)\n        lam.plies.append(ply)\n\n    lam.rebuild()\n    lam.calc_constitutive_matrix()\n    if calc_scf:\n        lam.calc_scf()\n\n    return lam"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_lamination_parameters(thickness, laminaprop, rho,\n                               xiA1, xiA2, xiA3, xiA4,\n                               xiB1, xiB2, xiB3, xiB4,\n                               xiD1, xiD2, xiD3, xiD4,\n                               xiE1, xiE2, xiE3, xiE4):\n    r\"\"\"Calculates a laminate based on the lamination parameters.\n\n    The lamination parameters:\n    `\\xi_{A1} \\cdots \\xi_{A4}`,  `\\xi_{B1} \\cdots \\xi_{B4}`,\n    `\\xi_{C1} \\cdots \\xi_{C4}`,  `\\xi_{D1} \\cdots \\xi_{D4}`,\n    `\\xi_{E1} \\cdots \\xi_{E4}`\n\n    are used to calculate the laminate constitutive matrix.\n\n    Parameters\n    ----------\n    thickness : float\n        The total thickness of the laminate\n    laminaprop : tuple\n        The laminaprop tuple used to define the laminate material.\n    rho : float\n        Material density.\n    xiA1 to xiD4 : float\n        The 16 lamination parameters used to define the laminate.\n\n    Returns\n    -------\n    lam : Laminate\n        laminate with the ABD and ABDE matrices already calculated\n\n    \"\"\"\n    lam = Laminate()\n    lam.h = thickness\n    lam.matobj = read_laminaprop(laminaprop, rho)\n    lam.xiA = np.array([1, xiA1, xiA2, xiA3, xiA4], dtype=np.float64)\n    lam.xiB = np.array([0, xiB1, xiB2, xiB3, xiB4], dtype=np.float64)\n    lam.xiD = np.array([1, xiD1, xiD2, xiD3, xiD4], dtype=np.float64)\n    lam.xiE = np.array([1, xiE1, xiE2, xiE3, xiE4], dtype=np.float64)\n\n    lam.calc_ABDE_from_lamination_parameters()\n    return lam", "response": "r Calculates a laminate based on the lamination parameters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calc_scf(self):\n        D1 = 0\n        R1 = 0\n        den1 = 0\n\n        D2 = 0\n        R2 = 0\n        den2 = 0\n\n        offset = self.offset\n        zbot = -self.h/2 + offset\n        z1 = zbot\n\n        for ply in self.plies:\n            z2 = z1 + ply.h\n            e1 = (ply.matobj.e1 * np.cos(np.deg2rad(ply.theta)) +\n                  ply.matobj.e2 * np.sin(np.deg2rad(ply.theta)))\n            e2 = (ply.matobj.e2 * np.cos(np.deg2rad(ply.theta)) +\n                  ply.matobj.e1 * np.sin(np.deg2rad(ply.theta)))\n            nu12 = (ply.matobj.nu12 * np.cos(np.deg2rad(ply.theta)) +\n                  ply.matobj.nu21 * np.sin(np.deg2rad(ply.theta)))\n            nu21 = (ply.matobj.nu21 * np.cos(np.deg2rad(ply.theta)) +\n              ply.matobj.nu12 * np.sin(np.deg2rad(ply.theta)))\n\n            D1 += e1 / (1 - nu12*nu21)\n            R1 += D1*((z2 - offset)**3/3 - (z1 - offset)**3/3)\n            g13 = ply.matobj.g13\n            d1 = g13 * ply.h\n            den1 += d1 * (self.h / ply.h) * D1**2*(15*offset*z1**4 + 30*offset*z1**2*zbot*(2*offset - zbot) - 15*offset*z2**4 + 30*offset*z2**2*zbot*(-2*offset + zbot) - 3*z1**5 + 10*z1**3*(-2*offset**2 - 2*offset*zbot + zbot**2) - 15*z1*zbot**2*(4*offset**2 - 4*offset*zbot + zbot**2) + 3*z2**5 + 10*z2**3*(2*offset**2 + 2*offset*zbot - zbot**2) + 15*z2*zbot**2*(4*offset**2 - 4*offset*zbot + zbot**2))/(60*g13)\n\n            D2 += e2 / (1 - nu12*nu21)\n            R2 += D2*((z2 - self.offset)**3/3 - (z1 - self.offset)**3/3)\n            g23 = ply.matobj.g23\n            d2 = g23 * ply.h\n            den2 += d2 * (self.h / ply.h) * D2**2*(15*offset*z1**4 + 30*offset*z1**2*zbot*(2*offset - zbot) - 15*offset*z2**4 + 30*offset*z2**2*zbot*(-2*offset + zbot) - 3*z1**5 + 10*z1**3*(-2*offset**2 - 2*offset*zbot + zbot**2) - 15*z1*zbot**2*(4*offset**2 - 4*offset*zbot + zbot**2) + 3*z2**5 + 10*z2**3*(2*offset**2 + 2*offset*zbot - zbot**2) + 15*z2*zbot**2*(4*offset**2 - 4*offset*zbot + zbot**2))/(60*g23)\n\n            z1 = z2\n\n        self.scf_k13 = R1**2 / den1\n        self.scf_k23 = R2**2 / den2\n\n        return self.scf_k13, self.scf_k23", "response": "Calculates improved shear correction factors for plates and shells."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calc_equivalent_modulus(self):\n        AI = np.matrix(self.ABD, dtype=np.float64).I\n        a11, a12, a22, a33 = AI[0,0], AI[0,1], AI[1,1], AI[2,2]\n        self.e1 = 1./(self.h*a11)\n        self.e2 = 1./(self.h*a22)\n        self.g12 = 1./(self.h*a33)\n        self.nu12 = - a12 / a11\n        self.nu21 = - a12 / a22", "response": "Calculates the equivalent laminate properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calc_lamination_parameters(self):\n        if len(self.plies) == 0:\n            if self.xiA is None:\n                raise ValueError('Laminate with 0 plies!')\n            else:\n                return\n        xiA1, xiA2, xiA3, xiA4 = 0, 0, 0, 0\n        xiB1, xiB2, xiB3, xiB4 = 0, 0, 0, 0\n        xiD1, xiD2, xiD3, xiD4 = 0, 0, 0, 0\n        xiE1, xiE2, xiE3, xiE4 = 0, 0, 0, 0\n\n        lam_thick = sum([ply.h for ply in self.plies])\n        self.h = lam_thick\n\n        h0 = -lam_thick/2. + self.offset\n        for ply in self.plies:\n            if self.matobj is None:\n                self.matobj = ply.matobj\n            else:\n                assert np.allclose(self.matobj.u, ply.matobj.u), \"Plies with different materials\"\n            hk_1 = h0\n            h0 += ply.h\n            hk = h0\n\n            Afac = ply.h / lam_thick\n            Bfac = (2. / lam_thick**2) * (hk**2 - hk_1**2)\n            Dfac = (4. / lam_thick**3) * (hk**3 - hk_1**3)\n            Efac = (1. / lam_thick) * (hk - hk_1)\n\n            thetarad = np.deg2rad(ply.theta)\n            cos2t = np.cos(2*thetarad)\n            sin2t = np.sin(2*thetarad)\n            cos4t = np.cos(4*thetarad)\n            sin4t = np.sin(4*thetarad)\n\n            xiA1 += Afac * cos2t\n            xiA2 += Afac * sin2t\n            xiA3 += Afac * cos4t\n            xiA4 += Afac * sin4t\n\n            xiB1 += Bfac * cos2t\n            xiB2 += Bfac * sin2t\n            xiB3 += Bfac * cos4t\n            xiB4 += Bfac * sin4t\n\n            xiD1 += Dfac * cos2t\n            xiD2 += Dfac * sin2t\n            xiD3 += Dfac * cos4t\n            xiD4 += Dfac * sin4t\n\n            xiE1 += Efac * cos2t\n            xiE2 += Efac * sin2t\n            xiE3 += Efac * cos4t\n            xiE4 += Efac * sin4t\n\n        self.xiA = np.array([1, xiA1, xiA2, xiA3, xiA4], dtype=np.float64)\n        self.xiB = np.array([0, xiB1, xiB2, xiB3, xiB4], dtype=np.float64)\n        self.xiD = np.array([1, xiD1, xiD2, xiD3, xiD4], dtype=np.float64)\n        self.xiE = np.array([1, xiE1, xiE2, xiE3, xiE4], dtype=np.float64)", "response": "Calculates the lamination parameters for the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calc_ABDE_from_lamination_parameters(self):\n        # dummies used to unpack vector results\n        du1, du2, du3, du4, du5, du6 = 0, 0, 0, 0, 0, 0\n        # A matrix terms\n        A11,A22,A12, du1,du2,du3, A66,A16,A26 =\\\n            (self.h       ) * np.dot(self.matobj.u, self.xiA)\n        # B matrix terms\n        B11,B22,B12, du1,du2,du3, B66,B16,B26 =\\\n            (self.h**2/4. ) * np.dot(self.matobj.u, self.xiB)\n        # D matrix terms\n        D11,D22,D12, du1,du2,du3, D66,D16,D26 =\\\n            (self.h**3/12.) * np.dot(self.matobj.u, self.xiD)\n        # E matrix terms\n        du1,du2,du3, E44,E55,E45, du4,du5,du6 =\\\n            (self.h       ) * np.dot(self.matobj.u, self.xiE)\n\n        self.A = np.array([[A11, A12, A16],\n                           [A12, A22, A26],\n                           [A16, A26, A66]], dtype=np.float64)\n\n        self.B = np.array([[B11, B12, B16],\n                           [B12, B22, B26],\n                           [B16, B26, B66]], dtype=np.float64)\n\n        self.D = np.array([[D11, D12, D16],\n                           [D12, D22, D26],\n                           [D16, D26, D66]], dtype=np.float64)\n\n        # printing E acoordingly to Reddy definition for E44, E45 and E55\n        self.E = np.array([[E55, E45],\n                           [E45, E44]], dtype=np.float64)\n\n        self.ABD = np.array([[A11, A12, A16, B11, B12, B16],\n                             [A12, A22, A26, B12, B22, B26],\n                             [A16, A26, A66, B16, B26, B66],\n                             [B11, B12, B16, D11, D12, D16],\n                             [B12, B22, B26, D12, D22, D26],\n                             [B16, B26, B66, D16, D26, D66]], dtype=np.float64)\n\n        # printing ABDE acoordingly to Reddy definition for E44, E45 and E55\n        self.ABDE = np.array([[A11, A12, A16, B11, B12, B16, 0, 0],\n                              [A12, A22, A26, B12, B22, B26, 0, 0],\n                              [A16, A26, A66, B16, B26, B66, 0, 0],\n                              [B11, B12, B16, D11, D12, D16, 0, 0],\n                              [B12, B22, B26, D12, D22, D26, 0, 0],\n                              [B16, B26, B66, D16, D26, D66, 0, 0],\n                              [0, 0, 0, 0, 0, 0, E55, E45],\n                              [0, 0, 0, 0, 0, 0, E45, E44]],\n                               dtype=np.float64)", "response": "Calculate the ABD matrix based on the lamination parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the laminate constitutive matrix for a classical laminate class.", "response": "def calc_constitutive_matrix(self):\n        \"\"\"Calculates the laminate constitutive matrix\n\n        This is the commonly called ``ABD`` matrix with ``shape=(6, 6)`` when\n        the classical laminated plate theory is used, or the ``ABDE`` matrix\n        when the first-order shear deformation theory is used, containing the\n        transverse shear terms.\n\n        \"\"\"\n        self.A_general = np.zeros([5,5], dtype=np.float64)\n        self.B_general = np.zeros([5,5], dtype=np.float64)\n        self.D_general = np.zeros([5,5], dtype=np.float64)\n\n        lam_thick = sum([ply.h for ply in self.plies])\n        self.h = lam_thick\n\n        h0 = -lam_thick/2 + self.offset\n        for ply in self.plies:\n            hk_1 = h0\n            h0 += ply.h\n            hk = h0\n            self.A_general += ply.QL*(hk - hk_1)\n            self.B_general += 1/2.*ply.QL*(hk**2 - hk_1**2)\n            self.D_general += 1/3.*ply.QL*(hk**3 - hk_1**3)\n\n        self.A = self.A_general[0:3, 0:3]\n        self.B = self.B_general[0:3, 0:3]\n        self.D = self.D_general[0:3, 0:3]\n        self.E = self.A_general[3:5, 3:5]\n\n        conc1 = np.concatenate([self.A, self.B], axis=1)\n        conc2 = np.concatenate([self.B, self.D], axis=1)\n\n        self.ABD = np.concatenate([conc1, conc2], axis=0)\n        self.ABDE = np.zeros((8, 8), dtype=np.float64)\n        self.ABDE[0:6, 0:6] = self.ABD\n        self.ABDE[6:8, 6:8] = self.E"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nforce balanced lamination parameters", "response": "def force_balanced_LP(self):\n        r\"\"\"Force balanced lamination parameters\n\n        The lamination parameters `\\xi_{A2}` and `\\xi_{A4}` are set to null\n        to force a balanced laminate.\n\n        \"\"\"\n        dummy, xiA1, xiA2, xiA3, xiA4 = self.xiA\n        self.xiA = np.array([1, xiA1, 0, xiA3, 0], dtype=np.float64)\n        self.calc_ABDE_from_lamination_parameters()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nforcing an orthotropic laminate.", "response": "def force_orthotropic(self):\n        r\"\"\"Force an orthotropic laminate\n\n        The terms\n        `A_{13}`, `A_{23}`, `A_{31}`, `A_{32}`,\n        `B_{13}`, `B_{23}`, `B_{31}`, `B_{32}`,\n        `D_{13}`, `D_{23}`, `D_{31}`, `D_{32}` are set to zero to force an\n        orthotropic laminate.\n\n        \"\"\"\n        if self.offset != 0.:\n            raise RuntimeError(\n                    'Laminates with offset cannot be forced orthotropic!')\n        self.A[0, 2] = 0.\n        self.A[1, 2] = 0.\n        self.A[2, 0] = 0.\n        self.A[2, 1] = 0.\n\n        self.B[0, 2] = 0.\n        self.B[1, 2] = 0.\n        self.B[2, 0] = 0.\n        self.B[2, 1] = 0.\n\n        self.D[0, 2] = 0.\n        self.D[1, 2] = 0.\n        self.D[2, 0] = 0.\n        self.D[2, 1] = 0.\n\n        self.ABD[0, 2] = 0. # A16\n        self.ABD[1, 2] = 0. # A26\n        self.ABD[2, 0] = 0. # A61\n        self.ABD[2, 1] = 0. # A62\n\n        self.ABD[0, 5] = 0. # B16\n        self.ABD[5, 0] = 0. # B61\n        self.ABD[1, 5] = 0. # B26\n        self.ABD[5, 1] = 0. # B62\n\n        self.ABD[3, 2] = 0. # B16\n        self.ABD[2, 3] = 0. # B61\n        self.ABD[4, 2] = 0. # B26\n        self.ABD[2, 4] = 0. # B62\n\n        self.ABD[3, 5] = 0. # D16\n        self.ABD[4, 5] = 0. # D26\n        self.ABD[5, 3] = 0. # D61\n        self.ABD[5, 4] = 0. # D62\n\n        self.ABDE[0, 2] = 0. # A16\n        self.ABDE[1, 2] = 0. # A26\n        self.ABDE[2, 0] = 0. # A61\n        self.ABDE[2, 1] = 0. # A62\n\n        self.ABDE[0, 5] = 0. # B16\n        self.ABDE[5, 0] = 0. # B61\n        self.ABDE[1, 5] = 0. # B26\n        self.ABDE[5, 1] = 0. # B62\n\n        self.ABDE[3, 2] = 0. # B16\n        self.ABDE[2, 3] = 0. # B61\n        self.ABDE[4, 2] = 0. # B26\n        self.ABDE[2, 4] = 0. # B62\n\n        self.ABDE[3, 5] = 0. # D16\n        self.ABDE[4, 5] = 0. # D26\n        self.ABDE[5, 3] = 0. # D61\n        self.ABDE[5, 4] = 0."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nforcing a symmetric laminate on the current object.", "response": "def force_symmetric(self):\n        \"\"\"Force a symmetric laminate\n\n        The `B` terms of the constitutive matrix are set to zero.\n\n        \"\"\"\n        if self.offset != 0.:\n            raise RuntimeError(\n                    'Laminates with offset cannot be forced symmetric!')\n        self.B = np.zeros((3,3))\n        self.ABD[0:3, 3:6] = 0\n        self.ABD[3:6, 0:3] = 0\n\n        self.ABDE[0:3, 3:6] = 0\n        self.ABDE[3:6, 0:3] = 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the next grade in this list.", "response": "def get_next_grade(self):\n        \"\"\"Gets the next ``Grade`` in this list.\n\n        return: (osid.grading.Grade) - the next ``Grade`` in this list.\n                The ``has_next()`` method should be used to test that a\n                next ``Grade`` is available before calling this method.\n        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        try:\n            next_object = next(self)\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_grade_ids(self):\n        id_list = []\n        for grade_map in self._my_map['grades']:\n            id_list.append(Id(grade_map.id))\n        if id_list == []:\n            raise IllegalState()\n        else:\n            return IdList(id_list)", "response": "Gets the grade Ids in this system ranked from highest to lowest."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwaits for a task to finish and joins the thread", "response": "def wait_and_join(self, task):\n        \"\"\" Given a task, waits for it until it finishes\n        :param task: Task\n        :return:\n        \"\"\"\n        while not task.has_started:\n            time.sleep(self._polling_time)\n        task.thread.join()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninterfaces the GraphNode depends method", "response": "def depends(self, *tasks):\n        \"\"\" Interfaces the GraphNode `depends` method \"\"\"\n        nodes = [x.node for x in tasks]\n        self.node.depends(*nodes)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninterface the GraphNode then method", "response": "def then(self, *tasks):\n        \"\"\" Interfaces the GraphNode `then` method\n        \"\"\"\n        nodes = [x.node for x in tasks]\n        self.node.then(*nodes)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, *tasks):\n        nodes = [x.node for x in tasks]\n        self.node.add(*nodes)\n        return self", "response": "Add a set of tasks to the current node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _run(self):\n        for node in self.node.relatives:\n            launch_node_task(node)\n        for node in self.node.relatives:\n            self.wait_and_join(node.task)\n        if self.node.parent:\n            while not self.node.parent.task.siblings_permission:\n                time.sleep(self._polling_time)\n        self.has_started = True\n        self.main()\n        self.siblings_permission = True\n        for node in self.node.siblings:\n            launch_node_task(node)\n        for node in self.node.siblings:\n            self.wait_and_join(node.task)\n        self.finished_at = time.time()\n        self.scheduler.notify_execution(self)\n        self.has_finished = True", "response": "Runs the task respecting dependencies"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading version from the first line starting with digit", "response": "def read_version():\n    \"\"\"Read version from the first line starting with digit\n    \"\"\"\n    regex = re.compile('^(?P<number>\\d.*?) .*$')\n\n    with open('../CHANGELOG.rst') as f:\n        for line in f:\n            match = regex.match(line)\n            if match:\n                return match.group('number')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all the resource record types supported.", "response": "def get_resource_record_types(self):\n        \"\"\"Gets all the resource record types supported.\n\n        return: (osid.type.TypeList) - the list of supported resource\n                record types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceProfile.get_resource_record_types_template\n        record_type_maps = get_registry('RESOURCE_RECORD_TYPES', self._runtime)\n        record_types = []\n        for record_type_map in record_type_maps:\n            record_types.append(Type(**record_type_maps[record_type_map]))\n        return TypeList(record_types)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a resource search session for the given bin.", "response": "def get_resource_search_session_for_bin(self, bin_id):\n        \"\"\"Gets a resource search session for the given bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of the bin\n        return: (osid.resource.ResourceSearchSession) - ``a\n                ResourceSearchSession``\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``bin_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_resource_search()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_search()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_search():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ResourceSearchSession(bin_id, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_resource_agent_session(self):\n        if not self.supports_resource_agent():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceAgentSession(runtime=self._runtime)", "response": "Gets the session for retrieving resource agent mappings."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_resource_agent_assignment_session_for_bin(self, bin_id):\n        if not self.supports_resource_agent_assignment():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ResourceAgentAssignmentSession(bin_id, runtime=self._runtime)", "response": "Gets a resource agent assignment session for the given bin."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_bin_admin_session(self):\n        if not self.supports_bin_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BinAdminSession(runtime=self._runtime)", "response": "Gets the bin administrative session for creating updating and deleting bins."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the bin hierarchy traversal session.", "response": "def get_bin_hierarchy_session(self):\n        \"\"\"Gets the bin hierarchy traversal session.\n\n        return: (osid.resource.BinHierarchySession) - ``a\n                BinHierarchySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_bin_hierarchy()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_bin_hierarchy()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_bin_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BinHierarchySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_bin_hierarchy_design_session(self):\n        if not self.supports_bin_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BinHierarchyDesignSession(runtime=self._runtime)", "response": "Gets the bin hierarchy design session."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_resource_lookup_session(self, proxy):\n        if not self.supports_resource_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the resource lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the resource lookup service for the given bin.", "response": "def get_resource_lookup_session_for_bin(self, bin_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the resource lookup service for the given bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of the bin\n        arg:    proxy (osid.proxy.Proxy): ``a proxy``\n        return: (osid.resource.ResourceLookupSession) - ``a\n                ResourceLookupSession``\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``bin_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_resource_lookup()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_lookup()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ResourceLookupSession(bin_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a resource query session.", "response": "def get_resource_query_session(self, proxy):\n        \"\"\"Gets a resource query session.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.ResourceQuerySession) - ``a\n                ResourceQuerySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_resource_query()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceQuerySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_resource_query_session_for_bin(self, bin_id, proxy):\n        if not self.supports_resource_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ResourceQuerySession(bin_id, proxy, self._runtime)", "response": "Gets a resource query session for the given bin."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a resource search session.", "response": "def get_resource_search_session(self, proxy):\n        \"\"\"Gets a resource search session.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.ResourceSearchSession) - ``a\n                ResourceSearchSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_resource_search()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_search()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_search():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceSearchSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a resource administration session for creating updating and deleting resources.", "response": "def get_resource_admin_session(self, proxy):\n        \"\"\"Gets a resource administration session for creating, updating and deleting resources.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.ResourceAdminSession) - ``a\n                ResourceAdminSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_resource_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceAdminSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_resource_admin_session_for_bin(self, bin_id, proxy):\n        if not self.supports_resource_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ResourceAdminSession(bin_id, proxy, self._runtime)", "response": "Gets a resource administration session for the given bin."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the resource notification session for the given bin.", "response": "def get_resource_notification_session(self, resource_receiver, proxy):\n        \"\"\"Gets the resource notification session for the given bin.\n\n        arg:    resource_receiver (osid.resource.ResourceReceiver):\n                notification callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.ResourceNotificationSession) - ``a\n                ResourceNotificationSession``\n        raise:  NullArgument - ``resource_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_resource_notification()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_notification()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_notification():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceNotificationSession(proxy=proxy, runtime=self._runtime, receiver=resource_receiver)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the resource notification session for the given bin.", "response": "def get_resource_notification_session_for_bin(self, resource_receiver, bin_id, proxy):\n        \"\"\"Gets the resource notification session for the given bin.\n\n        arg:    resource_receiver (osid.resource.ResourceReceiver):\n                notification callback\n        arg:    bin_id (osid.id.Id): the ``Id`` of the bin\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.ResourceNotificationSession) - ``a\n                ResourceNotificationSession``\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``resource_receiver, bin_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_resource_notification()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_notfication()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_notification():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ResourceNotificationSession(catalog_id=bin_id, proxy=proxy, runtime=self._runtime, receiver=resource_receiver)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_resource_bin_session(self, proxy):\n        if not self.supports_resource_bin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceBinSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the resource to bin mappings for the given resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the session for assigning resource to bin mappings.", "response": "def get_resource_bin_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning resource to bin mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.ResourceBinAssignmentSession) - a\n                ``ResourceBinAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_resource_bin_assignment()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_bin_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_bin_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceBinAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the group hierarchy traversal session for the given resource group.", "response": "def get_group_hierarchy_session(self, proxy):\n        \"\"\"Gets the group hierarchy traversal session for the given resource group.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.BinHierarchySession) - ``a\n                GroupHierarchySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_group_hierarchy()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_group_hierarchy()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_group_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BinHierarchySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a resource agent session for the given bin.", "response": "def get_resource_agent_session_for_bin(self, bin_id, proxy):\n        \"\"\"Gets a resource agent session for the given bin.\n\n        arg:    bin_id (osid.id.Id): the ``Id`` of the bin\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.ResourceAgentSession) - a\n                ``ResourceAgentSession``\n        raise:  NotFound - ``bin_id`` not found\n        raise:  NullArgument - ``bin_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_resource_agent()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_agent()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_agent():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ResourceAgentSession(bin_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the session for assigning agents to resources.", "response": "def get_resource_agent_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning agents to resources.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.ResourceAgentAssignmentSession) - a\n                ``ResourceAgentAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_resource_agent_assignment()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_resource_agent_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_resource_agent_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ResourceAgentAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the bin lookup session.", "response": "def get_bin_lookup_session(self, proxy):\n        \"\"\"Gets the bin lookup session.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.BinLookupSession) - a\n                ``BinLookupSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_bin_lookup()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_bin_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_bin_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BinLookupSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the bin query session.", "response": "def get_bin_query_session(self, proxy):\n        \"\"\"Gets the bin query session.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.resource.BinQuerySession) - a ``BinQuerySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_bin_query()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_bin_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_bin_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BinQuerySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register(klass):\n    \"Register a class into the agnocomplete registry.\"\n    logger.info(\"registering {}\".format(klass.__name__))\n    AGNOCOMPLETE_REGISTRY[klass.slug] = klass", "response": "Register a class into the agnocomplete registry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a list of segments from mm_begin mm_end and slide_step.", "response": "def gen_slide_seg_list(mm_begin, mm_end, seg_duration, slide_step):\n    \"\"\"\n    \u751f\u6210\u65f6\u95f4\u7247\u5f00\u59cb\u65f6\u523b\u5217\u8868,\u65f6\u95f4\u7247\u4ee5slide_step\u6b65\u957f\u8fdb\u884c\u6ed1\u52a8\n    :param mm_begin:\n    :param mm_end:\n    :param seg_duration:\n    :param slide_step:\n    :return:\n    \"\"\"\n    seg_begin_list = [i for i in\n                      range(mm_begin, mm_end - seg_duration + 1, slide_step)]\n    seg_list = list(map(time_util.minutes_to_time_str, seg_begin_list))\n    return seg_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of segments that are belonged to a given slide.", "response": "def get_slide_seg_list_belonged(dt_str, seg_duration, slide_step=1,\n                                fmt='%Y-%m-%d %H:%M:%S'):\n    \"\"\"\n    \u83b7\u53d6\u8be5\u65f6\u523b\u6240\u5c5e\u7684\u6240\u6709\u65f6\u95f4\u7247\u5217\u8868\n    :param dt_str: datetime string, eg: 2016-10-31 12:22:11\n    :param seg_duration: \u65f6\u95f4\u7247\u957f\u5ea6, unit: minute\n    :param slide_step: \u6ed1\u52a8\u6b65\u957f\n    :param fmt: datetime string format\n    :return: \u65f6\u95f4\u7247\u5217\u8868\n    \"\"\"\n    dt = time_util.str_to_datetime(dt_str, fmt)\n    day_slide_seg_list = gen_slide_seg_list(\n            const.FIRST_MINUTE_OF_DAY, const.MINUTES_IN_A_DAY, seg_duration,\n            slide_step)\n    return filter(lambda x: lie_in_seg(dt, x, seg_duration), day_slide_seg_list)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a date that is still in the next segment.", "response": "def get_still_seg_belonged(dt_str, seg_duration, fmt='%Y-%m-%d %H:%M:%S'):\n    \"\"\"\n    \u83b7\u53d6\u8be5\u65f6\u523b\u6240\u5c5e\u7684\u975e\u6ed1\u52a8\u65f6\u95f4\u7247\n    :param dt_str: datetime string, eg: 2016-10-31 12:22:11\n    :param seg_duration: \u65f6\u95f4\u7247\u957f\u5ea6, unit: minute\n    :param fmt: datetime string format\n    :return:\n    \"\"\"\n    dt = time_util.str_to_datetime(dt_str, fmt)\n    minutes_of_day = time_util.get_minutes_of_day(dt)\n    return time_util.minutes_to_time_str(\n            minutes_of_day - minutes_of_day % seg_duration)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lie_in_seg(dt, time_str, seg_duration):\n    minutes_of_day = time_util.get_minutes_of_day(dt)\n    range_begin = time_util.time_str_to_minutes(time_str)\n    if range_begin <= minutes_of_day < range_begin + seg_duration:\n        return True\n    else:\n        return False", "response": "Returns True if dt is in a segment of the given duration."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a time_str to index in a node in the n - th time_seg", "response": "def time_seg_to_index(time_str, slide_step):\n    \"\"\"\n    \u5c06\u65f6\u95f4\u7247\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u65f6\u95f4\u7247\u7d22\u5f15\u503c\n    :param time_str: eg: '11:10:21'\n    :param slide_step:\n    :return:\n    \"\"\"\n    minutes_idx = time_util.time_str_to_minutes(time_str)\n    time_seg_idx = minutes_idx // slide_step\n    return time_seg_idx"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef index_to_time_seg(time_seg_idx, slide_step):\n    assert (time_seg_idx * slide_step < const.MINUTES_IN_A_DAY)\n    return time_util.minutes_to_time_str(time_seg_idx * slide_step)", "response": "Convert index to time_seg"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _compute_closed_central_moments(self, central_from_raw_exprs, n_counter, k_counter):\n        n_species = len([None for pm in k_counter if pm.order == 1])\n        covariance_matrix = sp.Matrix(n_species, n_species, lambda x,y: self._get_covariance_symbol(n_counter,x,y))\n        positive_n_counter = [n for n in n_counter if n.order > 1]\n        out_mat = [self._compute_one_closed_central_moment(n, covariance_matrix) for n in positive_n_counter ]\n        return sp.Matrix(out_mat)", "response": "Computes the parametric expressions for all closed central moments."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect(self):\r\n        try:\r\n            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\r\n\r\n            if has_timeout(self.timeout):\r\n                self.sock.settimeout(self.timeout)\r\n\r\n            self.sock.connect(unquote(self.host))\r\n        except socket.error as msg:\r\n            if self.sock:\r\n                self.sock.close()\r\n            self.sock = None\r\n\r\n            raise socket.error(msg)", "response": "Connect to the unix domain socket and return the socket object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cardinal_direction(self):\n        if self.direction is None:\n            return None\n\n        if self.direction > 360 or self.direction < 0:\n            raise Exception('Direction out of range')\n\n        if (315 <= self.direction) <= 360 or 0 <= (self.direction) < 45:\n            return 'N'\n        elif 45 <= self.direction < 135:\n            return 'E'\n        elif 135 <= self.direction < 225:\n            return 'S'\n        elif 225 <= self.direction < 315:\n            return 'W'", "response": "Returns the cardinal direction of the current locale in a string. Possible values are N E S W and None."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    if name in ISO_LANGUAGE_CODES:\n        name = ISO_LANGUAGE_CODES[name]\n    if name in ISO_MAJOR_LANGUAGE_TYPES:\n        namespace = '639-2'\n        lang_name = ISO_MAJOR_LANGUAGE_TYPES[name]\n    elif name in ISO_OTHER_LANGUAGE_TYPES:\n        namespace = '639-3'\n        lang_name = ISO_OTHER_LANGUAGE_TYPES[name]\n    else:\n        raise NotFound('Language Type: ' + name)\n\n    return {\n        'authority': 'ISO',\n        'namespace': namespace,\n        'identifier': name,\n        'domain': 'DisplayText Languages',\n        'display_name': lang_name + ' Language Type',\n        'display_label': lang_name,\n        'description': ('The display text language type for the ' +\n                        lang_name + ' language.')\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a Mount object.", "response": "def create_result(self, local_path, container_path, permissions, meta, val, dividers):\n        \"\"\"Default permissions to rw\"\"\"\n        if permissions is NotSpecified:\n            permissions = 'rw'\n        return Mount(local_path, container_path, permissions)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new result object based on the seperator", "response": "def create_result(self, env_name, other_val, meta, val, dividers):\n        \"\"\"Set default_val and set_val depending on the seperator\"\"\"\n        args = [env_name]\n        if other_val is NotSpecified:\n            other_val = None\n        if not dividers:\n            args.extend([None, None])\n        elif dividers[0] == ':':\n            args.extend([other_val, None])\n        elif dividers[0] == '=':\n            args.extend([None, other_val])\n        return Environment(*args)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef determine_2(self, container_name, container_alias, meta, val):\n        if container_alias is not NotSpecified:\n            return container_alias\n        return container_name[container_name.rfind(\":\")+1:].replace('/', '-')", "response": "Default the alias to the name of the container"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the container_name of the container if a container is specified", "response": "def alter_1(self, given_container_name, container_name, meta, val):\n        \"\"\"Get the container_name of the container if a container is specified\"\"\"\n        meta.container = None\n        if not isinstance(container_name, six.string_types):\n            meta.container = container_name\n            container_name = container_name.container_name\n        return container_name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new port object.", "response": "def create_result(self, ip, host_port, container_port, meta, val, dividers):\n        \"\"\"\n        The format is the same as the default docker cli client::\n\n            ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort | containerPort\n        \"\"\"\n        if host_port in ('', NotSpecified) and container_port in ('', NotSpecified):\n            container_port = ip\n            ip = NotSpecified\n            host_port = NotSpecified\n        elif container_port in ('', NotSpecified):\n            container_port = host_port\n            host_port = ip\n            ip = NotSpecified\n        elif host_port in ('', NotSpecified):\n            host_port = NotSpecified\n\n        if host_port == '':\n            host_port = NotSpecified\n        if container_port == '':\n            container_port = NotSpecified\n\n        if host_port is not NotSpecified:\n            host_port = sb.integer_spec().normalise(meta.indexed_at('host_port'), host_port)\n        container_port = sb.required(container_port_spec()).normalise(meta.indexed_at('container_port'), container_port)\n\n        return Port(ip, host_port, container_port)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the expression that is used to calculate the F expectation for each entry in the COUNTER.", "response": "def _make_f_expectation(self, expr):\n        \"\"\"\n        Calculates :math:`<F>` in eq. 12 (see Ale et al. 2013) to calculate :math:`<F>` for EACH VARIABLE combination.\n\n        :param expr: an expression\n        :return: a column vector. Each row correspond to an element of counter.\n        :rtype: :class:`sympy.Matrix`\n        \"\"\"\n        # compute derivatives for EACH ENTRY in COUNTER\n\n        derives = sp.Matrix([derive_expr_from_counter_entry(expr, self.__species, tuple(c.n_vector))\n                             for c in self.__n_counter])\n\n\n\n        # Computes the factorial terms for EACH entry in COUNTER\n        factorial_terms = sp.Matrix([get_one_over_n_factorial(tuple(c.n_vector)) for c in self.__n_counter])\n\n        # Element wise product of the two vectors\n        te_vector= derives.multiply_elementwise(factorial_terms)\n\n        return te_vector"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing s^e in equation 11 2010", "response": "def _make_s_pow_e(self, reac_idx, e_vec):\n        \"\"\"\n        Compute s^e in equation 11  (see Ale et al. 2013)\n\n        :param reac_idx: the index (that is the column in the stoichiometry matrix)\n         of the reaction to consider.\n        :type reac_idx: `int`\n        :param e_vec: the vector e\n        :return: a scalar (s^e)\n        \"\"\"\n        return product([self.__stoichoimetry_matrix[i, reac_idx] ** e for i,e in enumerate(e_vec)])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef catch_no_credentials(message, **info):\n    try:\n        yield\n    except NoCredentialsError as error:\n        if hasattr(error, \"response\"):\n            info['error_code'] = error.response[\"ResponseMetadata\"][\"HTTPStatusCode\"]\n            info['error_message'] = error.response[\"Error\"][\"Message\"]\n        else:\n            info['error_message'] = error.fmt\n\n        raise BadAmazon(message, **info)", "response": "Catch a NoCredentialsError into a BadAmazon"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef catch_boto_400(message, **info):\n    try:\n        yield\n    except ClientError as error:\n        if str(error.response[\"ResponseMetadata\"][\"HTTPStatusCode\"]).startswith(\"4\"):\n            error_message = error.response[\"Error\"][\"Message\"]\n            raise BadAmazon(message, error_message=error_message, error_code=error.response[\"ResponseMetadata\"][\"HTTPStatusCode\"], **info)\n        else:\n            raise", "response": "Turn a BotoServerError 400 into a BadAmazon"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _initialize(self, runtime):\n\n        if runtime is None:\n            raise NullArgument()\n        if self._my_runtime is not None:\n            raise IllegalState('this manager has already been initialized.')\n        self._my_runtime = runtime\n        config = runtime.get_configuration()\n\n        cf_public_key_param_id = Id('parameter:cloudFrontPublicKey@aws_adapter')\n        cf_private_key_param_id = Id('parameter:cloudFrontPrivateKey@aws_adapter')\n        cf_keypair_id_param_id = Id('parameter:cloudFrontSigningKeypairId@aws_adapter')\n        cf_private_key_file_param_id = Id('parameter:cloudFrontSigningPrivateKeyFile@aws_adapter')\n        cf_distro_param_id = Id('parameter:cloudFrontDistro@aws_adapter')\n        cf_distro_id_param_id = Id('parameter:cloudFrontDistroId@aws_adapter')\n        s3_public_key_param_id = Id('parameter:S3PublicKey@aws_adapter')\n        s3_private_key_param_id = Id('parameter:S3PrivateKey@aws_adapter')\n        s3_bucket_param_id = Id('parameter:S3Bucket@aws_adapter')\n\n        cf_public_key = config.get_value_by_parameter(cf_public_key_param_id).get_string_value()\n        cf_private_key = config.get_value_by_parameter(cf_private_key_param_id).get_string_value()\n        cf_keypair_id = config.get_value_by_parameter(cf_keypair_id_param_id).get_string_value()\n        cf_private_key_file = config.get_value_by_parameter(\n            cf_private_key_file_param_id).get_string_value()\n        cf_distro = config.get_value_by_parameter(cf_distro_param_id).get_string_value()\n        cf_distro_id = config.get_value_by_parameter(cf_distro_id_param_id).get_string_value()\n        s3_public_key = config.get_value_by_parameter(s3_public_key_param_id).get_string_value()\n        s3_private_key = config.get_value_by_parameter(s3_private_key_param_id).get_string_value()\n        s3_bucket = config.get_value_by_parameter(s3_bucket_param_id).get_string_value()\n\n        self._config_map['cloudfront_public_key'] = cf_public_key\n        self._config_map['cloudfront_private_key'] = cf_private_key\n        self._config_map['cloudfront_keypair_id'] = cf_keypair_id\n        self._config_map['cloudfront_private_key_file'] = cf_private_key_file\n        self._config_map['cloudfront_distro'] = cf_distro\n        self._config_map['cloudfront_distro_id'] = cf_distro_id\n        self._config_map['put_public_key'] = s3_public_key\n        self._config_map['put_private_key'] = s3_private_key\n        self._config_map['s3_bucket'] = s3_bucket", "response": "Common initialization for OsidManager and OsidProxyManager."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'ISO',\n            'namespace': '15924',\n            'identifier': name,\n            'domain': 'ISO Script Types',\n            'display_name': ISO_SCRIPT_TYPES[name] + ' Script Type',\n            'display_label': ISO_SCRIPT_TYPES[name],\n            'description': ('The display text script type for the ' +\n                            ISO_SCRIPT_TYPES[name] + ' script.')\n        }\n    except KeyError:\n        raise NotFound('Script Type:' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_first_part_id_for_assessment(assessment_id, runtime=None, proxy=None, create=False, bank_id=None):\n    if create and bank_id is None:\n        raise NullArgument('Bank Id must be provided for create option')\n    try:\n        return get_next_part_id(assessment_id, runtime, proxy, sequestered=False)[0]\n    except IllegalState:\n        if create:\n            return create_first_assessment_section(assessment_id, runtime, proxy, bank_id)\n        else:\n            raise", "response": "Gets the first part id which represents the first section of an assessment"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an assessment part lookup session", "response": "def get_assessment_part_lookup_session(runtime, proxy, section=None):\n    \"\"\"returns an assessment part lookup session, perhaps even a magic one\"\"\"\n    # This appears to share code with get_item_lookup_session\n    try:\n        config = runtime.get_configuration()\n        parameter_id = Id('parameter:magicAssessmentPartLookupSessions@json')\n        import_path_with_class = config.get_value_by_parameter(parameter_id).get_string_value()\n        module_path = '.'.join(import_path_with_class.split('.')[0:-1])\n        magic_class = import_path_with_class.split('.')[-1]\n        module = importlib.import_module(module_path)\n        part_lookup_session = getattr(module, magic_class)(section,\n                                                           runtime=runtime,\n                                                           proxy=proxy)\n    except (AttributeError, KeyError, NotFound):\n        mgr = get_provider_manager('ASSESSMENT_AUTHORING',\n                                   runtime=runtime,\n                                   proxy=proxy,\n                                   local=True)\n        part_lookup_session = mgr.get_assessment_part_lookup_session(proxy=proxy)\n    return part_lookup_session"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a Section given a section_id", "response": "def get_assessment_section(section_id, runtime=None, proxy=None):\n    \"\"\"Gets a Section given a section_id\"\"\"\n    from .mixins import LoadedSection\n    collection = JSONClientValidated('assessment',\n                                     collection='AssessmentSection',\n                                     runtime=runtime)\n    result = collection.find_one(dict({'_id': ObjectId(section_id.get_identifier())}))\n    return LoadedSection(osid_object_map=result, runtime=runtime, proxy=proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the child map of a simple sequence assessment part", "response": "def update_parent_sequence_map(child_part, delete=False):\n    \"\"\"Updates the child map of a simple sequence assessment assessment part\"\"\"\n    if child_part.has_parent_part():\n        object_map = child_part.get_assessment_part()._my_map\n        database = 'assessment_authoring'\n        collection_type = 'AssessmentPart'\n    else:\n        object_map = child_part.get_assessment()._my_map\n        database = 'assessment'\n        collection_type = 'Assessment'\n    collection = JSONClientValidated(database,\n                                     collection=collection_type,\n                                     runtime=child_part._runtime)\n    if delete and 'childIds' in object_map:\n        object_map['childIds'].remove(str(child_part.get_id()))\n    elif not delete:\n        if 'childIds' not in object_map:\n            object_map['childIds'] = []\n        object_map['childIds'].append(str(child_part.get_id()))\n    collection.save(object_map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_from_parent_sequence_map(assessment_part_admin_session, assessment_part_id):\n    apls = get_assessment_part_lookup_session(runtime=assessment_part_admin_session._runtime,\n                                              proxy=assessment_part_admin_session._proxy)\n    apls.use_federated_bank_view()\n    apls.use_unsequestered_assessment_part_view()\n    child_part = apls.get_assessment_part(assessment_part_id)\n    update_parent_sequence_map(child_part, delete=True)", "response": "Updates the child map of an assessment part to remove child part"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef p_array_literal_2(self, p):\n        items = p[2]\n        if len(p) == 6:\n            items.extend(p[4])\n        p[0] = ast.Array(items=items)", "response": "P array literal expression"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_property_assignment(self, p):\n        if len(p) == 4:\n            p[0] = ast.Assign(left=p[1], op=p[2], right=p[3])\n        elif len(p) == 8:\n            p[0] = ast.GetPropAssign(prop_name=p[2], elements=p[6])\n        else:\n            p[0] = ast.SetPropAssign(\n                prop_name=p[2], parameters=p[4], elements=p[7])", "response": "property_assignment \\\n             : property_name COLON assignment_expr\n             | GETPROP property_name LPAREN RPAREN LBRACE function_body RBRACE\n             | SETPROP property_name LPAREN formal_parameter_list RPAREN \\\n                   LBRACE function_body RBRACE"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef p_member_expr(self, p):\n        if len(p) == 2:\n            p[0] = p[1]\n        elif p[1] == 'new':\n            p[0] = ast.NewExpr(p[2], p[3])\n        elif p[2] == '.':\n            p[0] = ast.DotAccessor(p[1], p[3])\n        else:\n            p[0] = ast.BracketAccessor(p[1], p[3])", "response": "Parse the member_expr expression."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef p_member_expr_nobf(self, p):\n        if len(p) == 2:\n            p[0] = p[1]\n        elif p[1] == 'new':\n            p[0] = ast.NewExpr(p[2], p[3])\n        elif p[2] == '.':\n            p[0] = ast.DotAccessor(p[1], p[3])\n        else:\n            p[0] = ast.BracketAccessor(p[1], p[3])", "response": "Parse the member expression expression."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef p_new_expr_nobf(self, p):\n        if len(p) == 2:\n            p[0] = p[1]\n        else:\n            p[0] = ast.NewExpr(p[2])", "response": "Parse the NEW expression."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef p_call_expr(self, p):\n        if len(p) == 3:\n            p[0] = ast.FunctionCall(p[1], p[2])\n        elif len(p) == 4:\n            p[0] = ast.DotAccessor(p[1], p[3])\n        else:\n            p[0] = ast.BracketAccessor(p[1], p[3])", "response": "P - call - expr"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_call_expr_nobf(self, p):\n        if len(p) == 3:\n            p[0] = ast.FunctionCall(p[1], p[2])\n        elif len(p) == 4:\n            p[0] = ast.DotAccessor(p[1], p[3])\n        else:\n            p[0] = ast.BracketAccessor(p[1], p[3])", "response": "Parse the call expression nobf."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p_postfix_expr(self, p):\n        if len(p) == 2:\n            p[0] = p[1]\n        else:\n            p[0] = ast.UnaryOp(op=p[2], value=p[1], postfix=True)", "response": "postfix_expr : left_hand_side_expr\n                        | left_hand_side_expr PLUSPLUS\n                        | left_hand_side_expr MINUSMINUS"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a conditional expression", "response": "def p_conditional_expr(self, p):\n        \"\"\"\n        conditional_expr \\\n            : logical_or_expr\n            | logical_or_expr CONDOP assignment_expr COLON assignment_expr\n        \"\"\"\n        if len(p) == 2:\n            p[0] = p[1]\n        else:\n            p[0] = ast.Conditional(\n                predicate=p[1], consequent=p[3], alternative=p[5])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the Assignment Expression.", "response": "def p_assignment_expr(self, p):\n        \"\"\"\n        assignment_expr \\\n            : conditional_expr\n            | left_hand_side_expr assignment_operator assignment_expr\n        \"\"\"\n        if len(p) == 2:\n            p[0] = p[1]\n        else:\n            p[0] = ast.Assign(left=p[1], op=p[2], right=p[3])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_variable_declaration(self, p):\n        if len(p) == 2:\n            p[0] = ast.VarDecl(p[1])\n        else:\n            p[0] = ast.VarDecl(p[1], p[2])", "response": "variable_declaration | variable_declaration | identifier | identifier initializer | identifier"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_if_statement_2(self, p):\n        p[0] = ast.If(predicate=p[3], consequent=p[5], alternative=p[7])", "response": "P 2. 3. if_statement."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef p_iteration_statement_1(self, p):\n        p[0] = ast.DoWhile(predicate=p[5], statement=p[2])", "response": "Parse the SEMI - NIC entry point for iteration statements."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse WHILE LPAREN expr RPAREN statement", "response": "def p_iteration_statement_2(self, p):\n        \"\"\"iteration_statement : WHILE LPAREN expr RPAREN statement\"\"\"\n        p[0] = ast.While(predicate=p[3], statement=p[5])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the iteration_statement for 3. 6.", "response": "def p_iteration_statement_3(self, p):\n        \"\"\"\n        iteration_statement \\\n            : FOR LPAREN expr_noin_opt SEMI expr_opt SEMI expr_opt RPAREN \\\n                  statement\n            | FOR LPAREN VAR variable_declaration_list_noin SEMI expr_opt SEMI\\\n                  expr_opt RPAREN statement\n        \"\"\"\n        if len(p) == 10:\n            p[0] = ast.For(init=p[3], cond=p[5], count=p[7], statement=p[9])\n        else:\n            init = ast.VarStatement(p[4])\n            p[0] = ast.For(init=init, cond=p[6], count=p[8], statement=p[10])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_iteration_statement_4(self, p):\n        p[0] = ast.ForIn(item=p[3], iterable=p[5], statement=p[7])", "response": "P 3. 4. 1. iteration_statement. ForIn"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p_iteration_statement_6(self, p):\n        p[0] = ast.ForIn(item=ast.VarDecl(identifier=p[4], initializer=p[5]),\n                         iterable=p[7], statement=p[9])", "response": "P 6. 1. iteration_statement"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef p_with_statement(self, p):\n        p[0] = ast.With(expr=p[3], statement=p[5])", "response": "parse WITH expr RPAREN statement"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef p_case_clause(self, p):\n        p[0] = ast.Case(expr=p[2], elements=p[4])", "response": "CASE expr COLON source_elements"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef p_labelled_statement(self, p):\n        p[0] = ast.Label(identifier=p[1], statement=p[3])", "response": "parse a labelled statement"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef p_try_statement_1(self, p):\n        p[0] = ast.Try(statements=p[2], catch=p[3])", "response": "try_statement : TRY block catch"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef p_try_statement_2(self, p):\n        p[0] = ast.Try(statements=p[2], fin=p[3])", "response": "try_statement : TRY block finally"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing TRY block catch finally", "response": "def p_try_statement_3(self, p):\n        \"\"\"try_statement : TRY block catch finally\"\"\"\n        p[0] = ast.Try(statements=p[2], catch=p[3], fin=p[4])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses CATCH identifier RPAREN block", "response": "def p_catch(self, p):\n        \"\"\"catch : CATCH LPAREN identifier RPAREN block\"\"\"\n        p[0] = ast.Catch(identifier=p[3], elements=p[5])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting function expression to retrieve related object.", "response": "def p_function_expr_1(self, p):\n        \"\"\"\n        function_expr \\\n            : FUNCTION LPAREN RPAREN LBRACE function_body RBRACE\n            | FUNCTION LPAREN formal_parameter_list RPAREN \\\n                LBRACE function_body RBRACE\n        \"\"\"\n        if len(p) == 7:\n            p[0] = ast.FuncExpr(\n                identifier=None, parameters=None, elements=p[5])\n        else:\n            p[0] = ast.FuncExpr(\n                identifier=None, parameters=p[3], elements=p[6])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_provincie_adapter(obj, request):\n    return {\n        'niscode': obj.niscode,\n        'naam': obj.naam,\n        'gewest': {\n            'id': obj.gewest.id,\n            'naam': obj.gewest.naam\n        }\n    }", "response": "Returns a dictionary of all the items in a single resource that are part of a provincie."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_straten_adapter(obj, request):\n    return {\n        'id': obj.id,\n        'label': obj.label,\n        'status': {\n            'id': obj.status.id,\n            'naam': obj.status.naam,\n            'definitie': obj.status.definitie\n        },\n    }", "response": "Returns a dictionary of the contents of the object as a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary of all the objects in the gebouw format that can be used to render a list of a gebouw.", "response": "def list_gebouwen_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering a list of\n    :class:`crabpy.gateway.crab.Gebouw` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'aard': {\n            'id': obj.aard.id,\n            'naam': obj.aard.naam,\n            'definitie': obj.aard.definitie\n        },\n        'status': {\n            'id': obj.status.id,\n            'naam': obj.status.naam,\n            'definitie': obj.status.definitie\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary of the subadres and status for the current user.", "response": "def list_subadres_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering a list of\n    :class:`crabpy.gateway.crab.Subadres` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'subadres': obj.subadres,\n        'status': {\n            'id': obj.status.id,\n            'naam': obj.status.naam,\n            'definitie': obj.status.definitie\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef item_gewest_adapter(obj, request):\n    return {\n        'id': obj.id,\n        'namen': obj._namen,\n        'centroid': obj.centroid,\n        'bounding_box': obj.bounding_box\n    }", "response": "Returns a dictionary that can be used to render a crab. Gewest object to json."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef item_provincie_adapter(obj, request):\n    return {\n        'niscode': obj.niscode,\n        'naam': obj.naam,\n        'gewest': {\n            'id': obj.gewest.id,\n            'naam': obj.gewest.naam\n        }\n    }", "response": "Returns a dictionary of items from a crab. Provincie to json."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dictionary of items for the given object.", "response": "def item_gemeente_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering an object of\n    :class:`crabpy.gateway.crab.Gemeente` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'niscode': obj.niscode,\n        'naam': obj.naam,\n        'centroid': obj.centroid,\n        'bounding_box': obj.bounding_box,\n        'metadata': {\n            'begin_tijd': obj.metadata.begin_tijd,\n            'begin_datum': obj.metadata.begin_datum,\n            'begin_bewerking': {\n                'id': obj.metadata.begin_bewerking.id,\n                'naam': obj.metadata.begin_bewerking.naam,\n                'definitie': obj.metadata.begin_bewerking.definitie\n            },\n            'begin_organisatie': {\n                'id': obj.metadata.begin_organisatie.id,\n                'naam': obj.metadata.begin_organisatie.naam,\n                'definitie': obj.metadata.begin_organisatie.definitie\n            }\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef item_deelgemeente_adapter(obj, request):\n    return {\n        'id': obj.id,\n        'naam': obj.naam,\n        'gemeente': {\n            'id': obj.gemeente.id,\n            'naam': obj.gemeente.naam\n        }\n    }", "response": "Returns a dictionary of items for the given object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary of items from the object obj to json.", "response": "def item_straat_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering an object of\n    :class:`crabpy.gateway.crab.Straat` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'label': obj.label,\n        'namen': obj.namen,\n        'status': {\n            'id': obj.status.id,\n            'naam': obj.status.naam,\n            'definitie': obj.status.definitie\n        },\n        'taal': {\n            'id': obj.taal.id,\n            'naam': obj.taal.naam,\n            'definitie': obj.taal.definitie\n        },\n        'metadata': {\n            'begin_tijd': obj.metadata.begin_tijd,\n            'begin_datum': obj.metadata.begin_datum,\n            'begin_bewerking': {\n                'id': obj.metadata.begin_bewerking.id,\n                'naam': obj.metadata.begin_bewerking.naam,\n                'definitie': obj.metadata.begin_bewerking.definitie\n            },\n            'begin_organisatie': {\n                'id': obj.metadata.begin_organisatie.id,\n                'naam': obj.metadata.begin_organisatie.naam,\n                'definitie': obj.metadata.begin_organisatie.definitie\n            }\n        },\n        'bounding_box': obj.bounding_box\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef item_huisnummer_adapter(obj, request):\n    return {\n        'id': obj.id,\n        'huisnummer': obj.huisnummer,\n        'postadres': obj.postadres,\n        'status': {\n            'id': obj.status.id,\n            'naam': obj.status.naam,\n            'definitie': obj.status.definitie\n        },\n        'metadata': {\n            'begin_tijd': obj.metadata.begin_tijd,\n            'begin_datum': obj.metadata.begin_datum,\n            'begin_bewerking': {\n                'id': obj.metadata.begin_bewerking.id,\n                'naam': obj.metadata.begin_bewerking.naam,\n                'definitie': obj.metadata.begin_bewerking.definitie\n            },\n            'begin_organisatie': {\n                'id': obj.metadata.begin_organisatie.id,\n                'naam': obj.metadata.begin_organisatie.naam,\n                'definitie': obj.metadata.begin_organisatie.definitie\n            }\n        },\n        'bounding_box': obj.bounding_box\n    }", "response": "Adapter for rendering an object of\n    to json."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef item_perceel_crab_adapter(obj, request):\n    return {\n        'id': obj.id,\n        'centroid': obj.centroid,\n        'postadressen': obj.postadressen,\n        'metadata': {\n            'begin_tijd': obj.metadata.begin_tijd,\n            'begin_datum': obj.metadata.begin_datum,\n            'begin_bewerking': {\n                'id': obj.metadata.begin_bewerking.id,\n                'naam': obj.metadata.begin_bewerking.naam,\n                'definitie': obj.metadata.begin_bewerking.definitie\n            },\n            'begin_organisatie': {\n                'id': obj.metadata.begin_organisatie.id,\n                'naam': obj.metadata.begin_organisatie.naam,\n                'definitie': obj.metadata.begin_organisatie.definitie\n            }\n        }\n    }", "response": "Returns a dictionary of items for the given object of crabpy. gateway. crab. Perceel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary that maps the object into a single object of the appropriate class.", "response": "def item_gebouw_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering an object of\n    :class:`crabpy.gateway.crab.Gebouw` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'aard': {\n            'id': obj.aard.id,\n            'naam': obj.aard.naam,\n            'definitie': obj.aard.definitie\n        },\n        'status': {\n            'id': obj.status.id,\n            'naam': obj.status.naam,\n            'definitie': obj.status.definitie\n        },\n        'geometriemethode': {\n            'id': obj.methode.id,\n            'naam': obj.methode.naam,\n            'definitie': obj.methode.definitie\n        },\n        'geometrie': obj.geometrie,\n        'metadata': {\n            'begin_tijd': obj.metadata.begin_tijd,\n            'begin_datum': obj.metadata.begin_datum,\n            'begin_bewerking': {\n                'id': obj.metadata.begin_bewerking.id,\n                'naam': obj.metadata.begin_bewerking.naam,\n                'definitie': obj.metadata.begin_bewerking.definitie\n            },\n            'begin_organisatie': {\n                'id': obj.metadata.begin_organisatie.id,\n                'naam': obj.metadata.begin_organisatie.naam,\n                'definitie': obj.metadata.begin_organisatie.definitie\n            }\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef item_subadres_adapter(obj, request):\n    return {\n        'id': obj.id,\n        'subadres': obj.subadres,\n        'postadres': obj.postadres,\n        'status': {\n            'id': obj.status.id,\n            'naam': obj.status.naam,\n            'definitie': obj.status.definitie\n        },\n        'aard': {\n            'id': obj.aard.id,\n            'naam': obj.aard.naam,\n            'definitie': obj.aard.definitie\n        },\n        'metadata': {\n            'begin_tijd': obj.metadata.begin_tijd,\n            'begin_datum': obj.metadata.begin_datum,\n            'begin_bewerking': {\n                'id': obj.metadata.begin_bewerking.id,\n                'naam': obj.metadata.begin_bewerking.naam,\n                'definitie': obj.metadata.begin_bewerking.definitie\n            },\n            'begin_organisatie': {\n                'id': obj.metadata.begin_organisatie.id,\n                'naam': obj.metadata.begin_organisatie.naam,\n                'definitie': obj.metadata.begin_organisatie.definitie\n            }\n        }\n    }", "response": "Returns a dictionary of items for the given object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef item_adrespositie_adapter(obj, request):\n    return {\n        'id': obj.id,\n        'herkomst': {\n            'id': obj.herkomst.id,\n            'naam': obj.herkomst.naam,\n            'definitie': obj.herkomst.definitie\n        },\n        'geometrie': obj.geometrie,\n        'aard': {\n            'id': obj.aard.id,\n            'naam': obj.aard.naam,\n            'definitie': obj.aard.definitie\n        },\n        'metadata': {\n            'begin_tijd': obj.metadata.begin_tijd,\n            'begin_datum': obj.metadata.begin_datum,\n            'begin_bewerking': {\n                'id': obj.metadata.begin_bewerking.id,\n                'naam': obj.metadata.begin_bewerking.naam,\n                'definitie': obj.metadata.begin_bewerking.definitie\n            },\n            'begin_organisatie': {\n                'id': obj.metadata.begin_organisatie.id,\n                'naam': obj.metadata.begin_organisatie.naam,\n                'definitie': obj.metadata.begin_organisatie.definitie\n            }\n        }\n    }", "response": "Returns a dictionary of items from the object to json."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_dot(dot):\n    global impl\n    if impl is None:\n        impl = guess_impl()\n    if impl == \"dot\":\n        return run_dot_dot(dot)\n    elif impl == \"js\":\n        return run_dot_js(dot)\n    else:\n        raise ValueError(\"unknown implementation {}\".format(impl))", "response": "Converts a graph in DOT format into an IPython displayable object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_type_data(name):\n    name = name.upper()\n    if name in CELESTIAL_COORDINATE_TYPES:\n        domain = 'Celestial Coordinate Systems'\n        coordinate_name = CELESTIAL_COORDINATE_TYPES[name]\n    elif name in GEOGRAPHIC_COORDINATE_TYPES:\n        domain = 'Geographic Coordinate Systems'\n        coordinate_name = GEOGRAPHIC_COORDINATE_TYPES[name]\n    else:\n        raise NotFound('Coordinate Type' + name)\n\n    return {\n        'authority': 'okapia.net',\n        'namespace': 'coordinate',\n        'identifier': name,\n        'domain': domain,\n        'display_name': coordinate_name + ' Type',\n        'display_label': coordinate_name,\n        'description': ('The type for the ' + coordinate_name + ' System.')\n    }", "response": "Return dictionary representation of type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_agent_key(self, proxy=None):\n        if self._proxy is None:\n            self._proxy = proxy\n        if self._proxy is not None and self._proxy.has_effective_agent():\n            agent_key = self._proxy.get_effective_agent_id()\n        else:\n            agent_key = None\n        if agent_key not in self._provider_sessions:\n            self._provider_sessions[agent_key] = dict()\n        return agent_key", "response": "Gets an agent key for session management."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets list of all known provider sessions.", "response": "def _get_provider_sessions(self):\n        \"\"\"Gets list of all known provider sessions.\"\"\"\n        agent_key = self._get_agent_key()\n        sessions = []\n        for session_name in self._provider_sessions[agent_key]:\n            sessions.append(self._provider_sessions[agent_key][session_name])\n        return sessions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninjecting the domain of the current user in the new model instances.", "response": "def extra_create_kwargs(self):\n        \"\"\"\n        Inject the domain of the current user in the new model instances.\n        \"\"\"\n        user = self.get_agnocomplete_context()\n        if user:\n            _, domain = user.email.split('@')\n            return {\n                'domain': domain\n            }\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a pseudo salt", "response": "def get_pseudo_salt(length, *args):\n    \"\"\"\n    generate a pseudo salt (used, if user is wrong)\n    \"\"\"\n    temp = \"\".join([arg for arg in args])\n    return hash_hexdigest(temp)[:length]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hexlify_pbkdf2(password, salt, iterations, length, digest=hashlib.sha1):\n    # log.debug(\"hexlify_pbkdf2 with iterations=%i\", iterations)\n    hash = crypto.pbkdf2(password, salt, iterations=iterations, dklen=length, digest=digest)\n    hash = binascii.hexlify(hash)\n    hash = six.text_type(hash, \"ascii\")\n    return hash", "response": "Hexlify a password with a salt value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a XOR encrypted PBKDF2 salted checksum from a plaintext password.", "response": "def salt_hash_from_plaintext(password):\n    \"\"\"\n    Create a XOR encrypted PBKDF2 salted checksum from a plaintext password.\n\n    >>> seed_generator.DEBUG=True # Generate always the same seed for tests\n\n    >>> salt, data = salt_hash_from_plaintext(\"test\")\n    >>> salt == 'DEBUG'\n    True\n    >>> data =='pbkdf2_sha1$5$DEBUG$a2220ab7dea891f260edd481$50530c0e530f030b08070353'\n    True\n    \"\"\"\n    init_pbkdf2_salt = seed_generator(app_settings.PBKDF2_SALT_LENGTH)\n    pbkdf2_temp_hash = hexlify_pbkdf2(\n        password,\n        salt=init_pbkdf2_salt,\n        iterations=app_settings.ITERATIONS1,\n        length=app_settings.PBKDF2_BYTE_LENGTH\n    )\n\n    first_pbkdf2_part = pbkdf2_temp_hash[:PBKDF2_HALF_HEX_LENGTH]\n    second_pbkdf2_part = pbkdf2_temp_hash[PBKDF2_HALF_HEX_LENGTH:]\n\n    encrypted_part = xor_crypt.encrypt(first_pbkdf2_part, key=second_pbkdf2_part)\n\n    # log.debug(\"locals():\\n%s\", pprint.pformat(locals()))\n    return init_pbkdf2_salt, encrypted_part"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsimulate a JavaScript client part.", "response": "def _simulate_client(plaintext_password, init_pbkdf2_salt, cnonce, server_challenge):\n    \"\"\"\n    A implementation of the JavaScript client part.\n    Needful for finding bugs.\n    \"\"\"\n    # log.debug(\"_simulate_client(plaintext_password='%s', init_pbkdf2_salt='%s', cnonce='%s', server_challenge='%s')\",\n    #     plaintext_password, init_pbkdf2_salt, cnonce, server_challenge\n    # )\n    pbkdf2_temp_hash = hexlify_pbkdf2(\n        plaintext_password,\n        salt=init_pbkdf2_salt,\n        iterations=app_settings.ITERATIONS1,\n        length=app_settings.PBKDF2_BYTE_LENGTH\n    )\n    first_pbkdf2_part = pbkdf2_temp_hash[:PBKDF2_HALF_HEX_LENGTH]\n    second_pbkdf2_part = pbkdf2_temp_hash[PBKDF2_HALF_HEX_LENGTH:]\n\n    second_pbkdf2_salt = cnonce + server_challenge\n    pbkdf2_hash = hexlify_pbkdf2(\n        first_pbkdf2_part,\n        salt=second_pbkdf2_salt,\n        iterations=app_settings.ITERATIONS2,\n        length=app_settings.PBKDF2_BYTE_LENGTH\n    )\n    # log.debug(\"_simulate_client() locals():\\n%s\", pprint.pformat(locals()))\n    return pbkdf2_hash, second_pbkdf2_part"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if secure_password is correct for the server_challenge", "response": "def check_secure_js_login(secure_password, encrypted_part, server_challenge):\n    \"\"\"\n    first_pbkdf2_part = xor_decrypt(encrypted_part, key=second_pbkdf2_part)\n    test_hash = pbkdf2(first_pbkdf2_part, key=cnonce + server_challenge)\n    compare test_hash with transmitted pbkdf2_hash\n    \"\"\"\n    # log.debug(\"check_secure_js_login(secure_password='%s', encrypted_part='%s', server_challenge='%s')\",\n    #     secure_password, encrypted_part, server_challenge\n    # )\n\n    pbkdf2_hash, second_pbkdf2_part, cnonce = split_secure_password(secure_password)\n    # log.debug(\"split_secure_password(): pbkdf2_hash='%s', second_pbkdf2_part='%s', cnonce='%s'\",\n    #     pbkdf2_hash, second_pbkdf2_part, cnonce\n    # )\n\n    first_pbkdf2_part = xor_crypt.decrypt(encrypted_part, key=second_pbkdf2_part)\n\n    test_hash = hexlify_pbkdf2(\n        first_pbkdf2_part,\n        cnonce + server_challenge,\n        iterations=app_settings.ITERATIONS2,\n        length=app_settings.PBKDF2_BYTE_LENGTH\n    )\n    # log.debug(\"check_secure_js_login() locals():\\n%s\", pprint.pformat(locals()))\n    if test_hash != pbkdf2_hash:\n        raise SecureJSLoginError(\"test_hash != pbkdf2_hash\")\n    # log.debug(\"OK: test_hash == pbkdf2_hash\")\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encrypt(self, txt, key):\n        # log.debug(\"encrypt(txt='%s', key='%s')\", txt, key)\n        assert isinstance(txt, six.text_type), \"txt: %s is not text type!\" % repr(txt)\n        assert isinstance(key, six.text_type), \"key: %s is not text type!\" % repr(key)\n\n        if len(txt) != len(key):\n            raise SecureJSLoginError(\"encrypt error: %s and '%s' must have the same length!\" % (txt, key))\n\n        pbkdf2_hash = PBKDF2SHA1Hasher1().get_salt_hash(txt)\n\n        txt=force_bytes(txt)\n        key=force_bytes(key)\n        crypted = self.xor(txt, key)\n        crypted = binascii.hexlify(crypted)\n        crypted = six.text_type(crypted, \"ascii\")\n        return \"%s$%s\" % (pbkdf2_hash, crypted)", "response": "encrypt a string with a PBKDF2 checksum"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef decrypt(self, txt, key):\n        # log.debug(\"decrypt(txt='%s', key='%s')\", txt, key)\n        assert isinstance(txt, six.text_type), \"txt: %s is not text type!\" % repr(txt)\n        assert isinstance(key, six.text_type), \"key: %s is not text type!\" % repr(key)\n\n        pbkdf2_hash, crypted = txt.rsplit(\"$\",1)\n\n        # if not seed_generator.DEBUG and len(pbkdf2_hash)!=SALT_HASH_LEN:\n        #     raise SecureJSLoginError(\n        #         \"encrypt error: Salt-hash %s with length %i must be length %i!\" % (\n        #             repr(pbkdf2_hash), len(pbkdf2_hash), SALT_HASH_LEN\n        #         )\n        #     )\n\n        try:\n            crypted = binascii.unhexlify(crypted)\n        except (binascii.Error, TypeError) as err:\n            # Py2 will raise TypeError - Py3 the binascii.Error\n            raise SecureJSLoginError(\"unhexlify error: %s with data: %s\" % (err, crypted))\n\n        if len(crypted) != len(key):\n            raise SecureJSLoginError(\"encrypt error: %s and '%s' must have the same length!\" % (crypted, key))\n\n        key=force_bytes(key)\n        decrypted = self.xor(crypted, key)\n\n        try:\n            decrypted = force_text(decrypted)\n        except UnicodeDecodeError:\n            raise SecureJSLoginError(\"Can't decode data.\")\n\n        test = PBKDF2SHA1Hasher1().verify(decrypted, pbkdf2_hash)\n        if not test:\n            raise SecureJSLoginError(\"XOR decrypted data: PBKDF2 hash test failed\")\n\n        return decrypted", "response": "Decrypt a string with a key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncast a datetime to a float", "response": "def _cast_float(temp_dt):\n    \"\"\"returns utc timestamp\"\"\"\n    if type(temp_dt) == str:\n        fmt = '%Y-%m-%dT%H:%M:00'\n        base_dt = temp_dt[0:19]\n        tz_offset = eval(temp_dt[19:22])\n        temp_dt = datetime.datetime.strptime(base_dt, fmt) - \\\n                datetime.timedelta(hours=tz_offset)\n    return (temp_dt - datetime.datetime(1970, 1, 1)).total_seconds()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_agent_lookup_session(self):\n        if not self.supports_agent_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AgentLookupSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the agent lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_agent_lookup_session_for_agency(self, agency_id):\n        if not self.supports_agent_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AgentLookupSession(agency_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the agent lookup service for the given agency."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    if name in CALENDAR_TYPES:\n        domain = 'Calendar Types'\n        calendar_name = CALENDAR_TYPES[name]\n    elif name in ANCIENT_CALENDAR_TYPES:\n        domain = 'Ancient Calendar Types'\n        calendar_name = ANCIENT_CALENDAR_TYPES[name]\n    elif name in ALTERNATE_CALENDAR_TYPES:\n        domain = 'Alternative Calendar Types'\n        calendar_name = ALTERNATE_CALENDAR_TYPES[name]\n    else:\n        raise NotFound('Calendar Type: ' + name)\n\n    return {\n        'authority': 'okapia.net',\n        'namespace': 'calendar',\n        'identifier': name,\n        'domain': domain,\n        'display_name': calendar_name + ' Calendar Type',\n        'display_label': calendar_name,\n        'description': ('The time type for the ' + calendar_name + ' calendar.')\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_index(path,index_file,verbose=False,samtools=False):\n  if verbose:\n    sys.stderr.write(\"scanning for primaries\\n\")\n  reads = {}\n  z = 0\n  # force use of primary alignment flag if its not already used\n  # require one and only one primary alignment for each read (or mate)\n  fail_primary = False\n  b2 = None\n  if samtools:\n    b2 = SamtoolsBAMStream(path)\n  else:\n    b2 = BAMFile(path)\n\n  for e in b2:\n    z+=1\n    if verbose:\n      if z %1000==0: sys.stderr.write(str(z)+\"\\r\")\n    name = e.value('qname')\n    if name not in reads:\n      reads[name] = {}\n    type = 'u'\n    if e.check_flag(64):\n      type = 'l' #left mate\n    elif e.check_flag(128):\n      type = 'r' #right mate\n    if not e.check_flag(2304):\n      if type not in reads[name]: reads[name][type] = 0\n      reads[name][type] += 1 # we have one\n      if reads[name][type] > 1: \n        fail_primary = True\n        break # too many primaries set to be useful\n  # see if we have one primary set for each read\n  for name in reads:\n    for type in reads[name]:\n      if reads[name][type] != 1:\n        fail_primary = True\n  if verbose:\n    sys.stderr.write(\"\\n\")\n  if fail_primary:\n    sys.stderr.write(\"Failed to find a single primary for each read (or each mate).  Reading through bam to find best.\\n\")\n    best = {}\n    # must find the primary for each\n\n    b2 = None\n    if samtools:\n      b2 = SamtoolsBAMStream(path)\n    else:\n      b2 = BAMFile(path)\n    z = 0\n    for e in b2:\n      z += 1\n      if verbose:\n        if z %1000==0: sys.stderr.write(str(z)+\"\\r\")\n      name = e.value('qname')\n      type = 'u'\n      if e.check_flag(64):\n        type = 'l' #left mate\n      elif e.check_flag(128):\n        type = 'r' #right mate\n      if name not in best: best[name] = {}\n      # get length\n      l = 0\n      if e.is_aligned():\n        l = e.get_aligned_bases_count()\n      if type not in best[name]: best[name][type] = {'line':z,'bpcnt':l}\n      if l > best[name][type]['bpcnt']: \n        best[name][type]['bpcnt'] = l\n        best[name][type]['line'] = z\n    bestlinenumbers = set()\n    for name in best:\n      for type in best[name]:\n        bestlinenumbers.add(best[name][type]['line'])\n    if verbose:\n      sys.stderr.write(\"\\n\")\n  of = None\n  try:\n    of = gzip.open(index_file,'w')\n  except IOError:\n    sys.sterr.write(\"ERROR: could not find or create index\\n\")\n    sys.exit()\n\n\n  b2 = None\n  if samtools:\n    b2 = SamtoolsBAMStream(path)\n  else:\n    b2 = BAMFile(path)\n  z = 0\n  for e in b2:\n    z+=1\n    if verbose:\n      if z%1000==0:\n        sys.stderr.write(str(z)+\" reads indexed\\r\")\n    myflag = e.value('flag')\n    if fail_primary: # see if this should be a primary\n      if z not in bestlinenumbers:\n        myflag = myflag | 2304\n    rng = e.get_target_range()\n    if rng: \n      l = e.get_aligned_bases_count()\n      of.write(e.value('qname')+\"\\t\"+rng.get_range_string()+\"\\t\"+str(e.get_block_start())+\"\\t\"+str(e.get_inner_start())+\"\\t\"+str(l)+\"\\t\"+str(myflag)+\"\\n\")\n    else: of.write(e.value('qname')+\"\\t\"+''+\"\\t\"+str(e.get_block_start())+\"\\t\"+str(e.get_inner_start())+\"\\t\"+'0'+\"\\t\"+str(myflag)+\"\\n\")\n  sys.stderr.write(\"\\n\")\n  of.close()", "response": "Writes a new index file to a gzipped TSV file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntrues if each chromosome is listed together as a chunk and if the range starts go from smallest to largest otherwise False", "response": "def check_ordered(self): \n    \"\"\" True if each chromosome is listed together as a chunk and if the range starts go from smallest to largest otherwise false\n\n    :return: is it ordered?\n    :rtype: bool\n    \"\"\"\n    sys.stderr.write(\"error unimplemented check_ordered\\n\")\n    sys.exit()\n    seen_chrs = set()\n    curr_chr = None\n    prevstart = 0\n    for l in self._lines:\n      if not l['rng']: continue\n      if l['rng'].chr != curr_chr:\n        prevstart = 0\n        if l['rng'].chr in seen_chrs:\n          return False\n        curr_chr = l['rng'].chr\n        seen_chrs.add(curr_chr)\n      if l['rng'].start < prevstart:  return False\n      prevstart = l['rng'].start\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the coordinates of a query by its name.", "response": "def get_coords_by_name(self,name):\n    \"\"\"\n    .. warning:: not implemented\n    \"\"\"\n    sys.stderr.write(\"error unimplemented get_coords_by_name\\n\")\n    sys.exit()\n    return [[self._lines[x]['filestart'],self._lines[x]['innerstart']] for x in self._queries[self._name_to_num[name]]]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the longest alignment set for a given name", "response": "def get_longest_target_alignment_coords_by_name(self,name):\n    \"\"\"For a name get the best alignment\n\n    :return: [filebyte,innerbyte] describing the to distance the zipped block start, and the distance within the unzipped block\n    :rtype: list\n    \"\"\"\n    longest = -1\n    coord = None\n    #for x in self._queries[self._name_to_num[name]]:\n    for line in [self._lines[x] for x in self._name_to_num[name]]:\n      if line['flag'] & 2304 == 0: \n        return [line['filestart'],line['innerstart']]\n    return None\n    sys.stderr.write(\"ERROR: no primary alignment set in index\\n\")\n    sys.exit()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_index_line(self,lnum):\n    if lnum < 1:\n      sys.stderr.write(\"ERROR: line number should be greater than zero\\n\")\n      sys.exit()\n    elif lnum > len(self._lines):\n      sys.stderr.write(\"ERROR: too far this line nuber is not in index\\n\")\n      sys.exit()\n    return self._lines[lnum-1]", "response": "Take the 1 - indexed line number and return its index information"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_coord_line_number(self,coord):\n    if coord[0] in self._coords:\n      if coord[1] in self._coords[coord[0]]:\n        return self._coords[coord[0]][coord[1]]\n    return None", "response": "return the one - indexed line number given the coordinates"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the unaligned lines", "response": "def get_unaligned_lines(self):\n    \"\"\"get the lines that are not aligned\"\"\"\n    sys.stderr.write(\"error unimplemented get_unaligned_lines\\n\")\n    sys.exit()\n    return [self._lines[x-1] for x in self._unaligned]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the start coordinate of the unaligned line.", "response": "def get_unaligned_start_coord(self):\n    \"\"\"\n    .. warning:: not implemented\n    \"\"\"\n    sys.stderr.write(\"error unimplemented get_unaligned_start_coord\\n\")\n    sys.exit()\n    if len(self._unaligned)==0: return None\n    return [self._lines[self._unaligned[0]-1]['filestart'],self._lines[self._unaligned[0]-1]['innerstart']]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the start coordinate of rng in the order of the start of the line", "response": "def get_range_start_coord(self,rng):\n    \"\"\"\n    .. warning:: not implemented\n    \"\"\"\n    sys.stderr.write(\"error unimplemented get_range_start_coord\\n\")\n    sys.exit()\n    if rng.chr not in self._chrs: return None\n    for l in [self._lines[x-1] for x in self._chrs[rng.chr]]:\n      ####\n      y = l['rng']\n      c = y.cmp(rng)\n      if c > 0: return None\n      if c == 0:\n        x = y.get_payload()\n        return [x[1],x[2]] # don't need the name\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the line number of the first range in the file.", "response": "def get_range_start_line_number(self,rng):\n    \"\"\"\n    .. warning:: not implemented\n    \"\"\"\n    sys.stderr.write(\"error unimplemented get_range_start_line\\n\")\n    sys.exit()\n    for i in range(0,len(self._lines)):\n      if rng.cmp(self._lines[i]['rng'])==0: return i+1\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert bytes to a dict of TagDatums", "response": "def _bin_to_extra(extra_bytes):\n  \"\"\"Pre all the reamining bytes of an entry\n  Post an array of \n   1. A dict keyed by Tag with {'type':,'value':} where value is a string unless type is i\n   2. A string of the remainder\n  \"\"\"\n  #global _bam_value_type\n  extra = StringIO(extra_bytes)\n  tags = {}\n  rem = ''\n  while extra.tell() < len(extra_bytes):\n    tag = extra.read(2)\n    val_type = extra.read(1)\n    if val_type == 'Z':\n      rem += tag+':'\n      rem += val_type+':'\n      p = re.compile('([!-~])')\n      m = p.match(extra.read(1))\n      vre = ''\n      while m:\n        vre += m.group(1)\n        c = extra.read(1)\n        #print c\n        m = p.match(c)\n      rem += vre+\"\\t\"\n      tags[tag] = TagDatum(val_type, vre)\n      #tags[tag] = {'type':val_type,'value':vre}\n    elif val_type == 'A':\n      rem += tag+':'\n      rem += val_type+':'\n      vre = extra.read(1)\n      rem += vre+\"\\t\"      \n      tags[tag] = TagDatum(val_type, vre)\n      #tags[tag] = {'type':val_type,'value':vre}      \n    elif val_type in _bam_value_type:\n      rem += tag+':'\n      rem += 'i'+':'\n      val = struct.unpack(_bam_value_type[val_type][1],extra.read(_bam_value_type[val_type][0]))[0]\n      rem += str(val)+\"\\t\"\n      tags[tag] = TagDatum(val_type, val)\n      #tags[tag] = {'type':val_type,'value':val}\n    elif val_type == 'B':\n      sys.sterr.write(\"WARNING array not implmented\\n\")\n      continue\n      rem += tag+':'\n      rem += val_type+':'\n      array_type = _bam_value_type[extra.read(1)]\n      element_count = struct.unpack('<I',extra.read(4))[0]\n      array_bytes = extra.read(element_count*_bam_value_type[array_type][0])\n      for by in [array_bytes[i:i+_bam_value_type[array_type][0]] for i in range(0,len(array_bytes),_bam_value_type[array_type][0])]:\n        aval = struct.unpack(_bam_value_type[array_type][1],by)\n  return [tags,rem.rstrip(\"\\t\")]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lie_between(self, target_time_range):\n        if self.begin_dt >= target_time_range.begin_dt and self.end_dt <= \\\n                target_time_range.end_dt:\n            return True\n        else:\n            return False", "response": "Returns True if the time range is between the current time range and the target time range."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if two time intervals intersect.", "response": "def do_intersect(self, another_time_range):\n        \"\"\"\n        \u5224\u65ad\u4e0e\u53e6\u4e00\u65f6\u95f4\u533a\u95f4\u662f\u5426\u6709\u91cd\u53e0\n        :param another_time_range:\n        :return: True or False\n        \"\"\"\n        if self.begin_dt > another_time_range.end_dt or self.end_dt < \\\n                another_time_range.begin_dt:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enqueue(self, item, queue=None):\n        if queue is None:\n            queue = self.queue\n        is_enqueue_item = True\n\n        if self.invalid_key_list is not None:\n            for entry in self.invalid_key_list:\n                if entry in item.data['key']:\n                    is_enqueue_item = False\n                    log_message = (\n                        '{key} is filtered by \"invalid_key_list\".'\n                        ''.format(key=item.data['key'],\n                                  plugin=__name__)\n                    )\n                    self.logger.debug(log_message)\n                    break\n\n        if is_enqueue_item:\n            try:\n                queue.put(item, block=False)\n                return True\n            except Full:\n                self.logger.error('Blackbird item Queue is Full!!!')\n                return False\n\n        else:\n            return False", "response": "Enqueue an item to the blacklist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __set_timestamp(self, clock):\n        if clock is None:\n            unix_timestamp = time.mktime(\n                datetime.datetime.now().utctimetuple()\n            )\n            timestamp = int(unix_timestamp)\n\n            return timestamp\n\n        else:\n            return clock", "response": "Set the timestamp of the current time."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compose(first_func, second_func):\n\n    @wraps(first_func)\n    def composed_func(*args, **kwargs):\n        return second_func((first_func(*args, **kwargs)))\n\n    return composed_func", "response": "Compose two functions. Documentation is retrieved from the first one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef escape_string(text):\n    if text is None:\n        return text\n\n\n    TO_REMOVE = [r'&', r'%', r'$', r'#', r'_', r'{', r'}',\n                 r'~', r'^', r'\\\\']\n\n    for char in TO_REMOVE:\n        text = text.replace(char, '')\n    return text", "response": "Remove problematic characters from a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields a chunk of the given iterable.", "response": "def chunker(iterable, size=5, fill=''):\n    \"\"\"Chunk the iterable.\n\n    Parameters\n    ----------\n    iterable\n        A list.\n\n    size\n        The size of the chunks.\n\n    fill\n        Fill value if the chunk is not of length 'size'.\n\n    Yields\n    -------\n    chunk\n        A chunk of length 'size'.\n\n\n    Examples\n    -------\n    >>> l = list(range(6))\n    >>> chunks = list(chunker(l, size=4, fill=''))\n    >>> chunks == [[0, 1, 2, 3], [4, 5, '', '']]\n    True\n    \"\"\"\n\n    for index in range(0, len(iterable) // size + 1):\n        to_yield = iterable[index * size: (index + 1) * size]\n\n        # Stop yielding if empty\n        if len(to_yield) == 0:\n            break\n\n        # Add fill values if there are too few elements\n        if len(to_yield) < size:\n            yield to_yield + [fill] * (size - len(to_yield))\n        else:\n            # Yield\n            yield to_yield"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nround a number to the nearest multiple of nearest.", "response": "def round_to_nearest(number, nearest=1):\n    \"\"\"Round 'number' to the nearest multiple of 'nearest'.\n\n    Parameters\n    ----------\n    number\n        A real number to round.\n    nearest\n        Number to round to closes multiple of.\n\n    Returns\n    -------\n    rounded\n        A rounded number.\n\n\n    Examples\n    -------\n    >>> round_to_nearest(6.8, nearest = 2.5)\n    7.5\n    \"\"\"\n    result = nearest * round(number / nearest)\n    if result % 1 == 0:\n        return int(result)\n\n    if nearest % 1 == 0:\n        return round(result)\n    if nearest % 0.1 == 0:\n        return round(result, 1)\n    if nearest % 0.01 == 0:\n        return round(result, 2)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all_equal(iterable):\n    if len(iterable) in [0, 1]:\n        return False\n\n    first = iterable[0]\n    return all([first == i for i in iterable[1:]])", "response": "Checks whether all items in an iterable are equal."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions to decide the minimum number of reps to perform given min_reps and max_reps and percentile.", "response": "def min_between(min_reps=3, max_reps=8, percentile=0.33):\n    \"\"\"Function to decide the minimum number of reps to perform\n    given `min_reps` and `max_rep`.\n\n    Parameters\n    ----------\n    min_reps\n        The minimum number of repeitions.\n\n    max_reps\n        The maximum number of repetitions.\n\n    percentile\n        The percentile to cap at.\n\n    Return\n    -------\n    (low, high)\n        A tuple containing a new rep range.\n\n\n    Examples\n    -------\n    >>> min_between(min_reps = 3, max_reps = 8, percentile = 0.33)\n    (3, 5)\n    \"\"\"\n    higher_limit = min_reps + (max_reps - min_reps) * percentile\n    return min_reps, math.ceil(higher_limit)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates repetitions between min_reps and max_reps.", "response": "def generate_reps(min_reps=3, max_reps=8, total=25, existing=None):\n    \"\"\"Generate 'total' repetitions between 'min_reps' and 'max_reps',\n    if existing is given (not None), then some repetitions are already\n    drawn.\n\n    Parameters\n    ----------\n    min_reps\n        Lower limit for the repetitions dawing, e.g. 3.\n        \n    max_reps\n        Upper limit for the repetitions dawing, e.g. 8.\n        \n    total\n        The total number of repetitions to return.\n        \n    existing\n        A list of prior reps drawn.\n\n    Returns\n    -------\n    reps_list\n        A list of repetitions between 'min_reps' and 'max_reps', summing to 'total'\n        or a number close to it.\n    \"\"\"\n\n    # If no existing repetitions exist, start from empty list\n    if existing is None:\n        existing = []\n\n    # List of possible rep strings to return\n    possible = []\n\n    for _ in range(3):\n\n        # Fill list with randomly drawn reptitions\n        created = existing.copy()\n        while sum(created) < (total - min_reps):\n            generated = random.randint(min_reps, max_reps)\n            created.append(generated)\n\n        # Sort and append to the list of lists\n        created.sort(reverse=True)\n        possible.append(created)\n\n    # Return the list of reps which is closest to the total desired number\n    return min(possible, key=lambda l: abs(total - sum(l)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the maximal spread of a sorted list of numbers.", "response": "def spread(iterable):\n    \"\"\"Returns the maximal spread of a sorted list of numbers.\n\n    Parameters\n    ----------\n    iterable\n        A list of numbers.\n\n    Returns\n    -------\n    max_diff\n        The maximal difference when the iterable is sorted.\n\n\n    Examples\n    -------\n    >>> spread([1, 11, 13, 15])\n    10\n    \n    >>> spread([1, 15, 11, 13])\n    10\n    \"\"\"\n    if len(iterable) == 1:\n        return 0\n\n    iterable = iterable.copy()\n    iterable.sort()\n\n    max_diff = max(abs(i - j) for (i, j) in zip(iterable[1:], iterable[:-1]))\n\n    return max_diff"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef secure(self, value):\n        self._secure = value\n        self._thumb  = self._link_to_img()", "response": "Set the secure parameter and regenerate the thumbnail link."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the rating parameter and regenerate the thumbnail link.", "response": "def rating(self, value):\n        \"\"\"Set the rating parameter and regenerate the thumbnail link.\"\"\"\n        self._rating = value\n        self._thumb  = self._link_to_img()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the size parameter and regenerate the thumbnail link.", "response": "def size(self, value):\n        \"\"\"Set the size parameter and regenerate the thumbnail link.\"\"\"\n        self._size   = value\n        self._thumb  = self._link_to_img()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef default(self, value):\n        self._default = value\n        self._thumb  = self._link_to_img()", "response": "Set the default parameter and regenerate the thumbnail link."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a link to the user s gravatar.", "response": "def _link_to_img(self):\n        \"\"\"\n        Generates a link to the user's Gravatar.\n        \n        >>> Gravatar('gridaphobe@gmail.com')._link_to_img()\n        'http://www.gravatar.com/avatar/16b87da510d278999c892cdbdd55c1b6?s=80&r=g'\n        \"\"\"\n        # make sure options are valid\n        if self.rating.lower() not in RATINGS:\n            raise InvalidRatingError(self.rating)\n        if not (MIN_SIZE <= self.size <= MAX_SIZE):\n            raise InvalidSizeError(self.size)\n        \n        url = ''\n        if self.secure:\n            url = SECURE_BASE_URL\n        else:\n            url = BASE_URL\n\n        options = {'s' : self.size, 'r' : self.rating}\n        if self.default is not None:\n            options['d'] = self.default\n        url += self.hash + '?' + urlencode(options)\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_profile(self):\n        url = PROFILE_URL + self.hash + '.json'\n        try:\n            profile = json.load(urlopen(url))\n            # set the profile as an instance variable\n            self._profile = profile['entry'][0]\n        except:\n            self._profile = {}", "response": "Retrieves the profile data of the user and formats it as a\n        Python dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_url(url):\n    if url.startswith(('http', 'https', '//')):\n        if url.startswith('//'):\n            return urlparse.urlparse(url, scheme='http')\n        else:\n            return urlparse.urlparse(url)\n    else:\n        return urlparse.urlparse(urlparse.urljoin('http://', url))", "response": "Return a clean URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef html_encode(path):\n    if sys.version_info > (3, 2, 0):\n        return urllib.parse.quote(utils.ensure_string(path))\n    else:\n        return urllib.quote(utils.ensure_string(path))", "response": "Return an HTML encoded Path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a URL string.", "response": "def _get_url(url):\n        \"\"\"Returns a URL string.\n\n        If the ``url`` parameter is a ParsedResult from `urlparse` the full url\n        will be unparsed and made into a string. Otherwise the ``url``\n        parameter is returned as is.\n\n        :param url: ``str`` || ``object``\n        \"\"\"\n        if isinstance(url, urlparse.ParseResult):\n            return urlparse.urlunparse(url)\n        else:\n            return url"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a request. To make a request pass the ``method`` and the ``url``. Valid methods are, ``['post', 'put', 'get', 'delete', 'patch', 'option', 'head']``. :param url: ``str`` :param headers: ``dict`` :param body: ``object`` :param kwargs: ``dict``", "response": "def _request(self, method, url, headers=None, body=None, kwargs=None):\n        \"\"\"Make a request.\n\n        To make a request pass the ``method`` and the ``url``. Valid methods\n        are, ``['post', 'put', 'get', 'delete', 'patch', 'option', 'head']``.\n\n        :param url: ``str``\n        :param headers: ``dict``\n        :param body: ``object``\n        :param kwargs: ``dict``\n        \"\"\"\n        _kwargs = utils.dict_update(self.request_kwargs.copy(), kwargs)\n        _headers = utils.dict_update(self.headers.copy(), headers)\n        _url = self._get_url(url=url)\n\n        try:\n            func = getattr(requests, method.lower())\n            if body is None:\n                resp = func(_url, headers=_headers, **_kwargs)\n            else:\n                resp = func(_url, data=body, headers=_headers, **_kwargs)\n            self.log.debug(\n                '%s %s %s', resp.status_code, resp.reason, resp.request\n            )\n        except AttributeError as exp:\n            self._report_error(request=method.upper(), exp=exp)\n        else:\n            return resp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake a POST request.", "response": "def post(self, url, headers=None, body=None, kwargs=None):\n        \"\"\"Make a POST request.\n\n        To make a POST request pass, ``url``\n\n        :param url: ``str``\n        :param headers: ``dict``\n        :param body: ``object``\n        :param kwargs: ``dict``\n        \"\"\"\n        return self._request(\n            method='post',\n            url=url,\n            headers=headers,\n            body=body,\n            kwargs=kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef head(self, url, headers=None, kwargs=None):\n        return self._request(\n            method='head',\n            url=url,\n            headers=headers,\n            kwargs=kwargs\n        )", "response": "Make a HEAD request pass url and headers pass kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking a PATCH request.", "response": "def patch(self, url, headers=None, body=None, kwargs=None):\n        \"\"\"Make a PATCH request.\n\n        To make a PATCH request pass, ``url``\n\n        :param url: ``str``\n        :param headers: ``dict``\n        :param body: ``object``\n        :param kwargs: ``dict``\n        \"\"\"\n        return self._request(\n            method='patch',\n            url=url,\n            headers=headers,\n            body=body,\n            kwargs=kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes a PUT request pass url headers body kwargs", "response": "def put(self, url, headers=None, body=None, kwargs=None):\n        \"\"\"Make a PUT request.\n\n        To make a PUT request pass, ``url``\n\n        :param url: ``str``\n        :param headers: ``dict``\n        :param body: ``object``\n        :param kwargs: ``dict``\n        \"\"\"\n        return self._request(\n            method='put',\n            url=url,\n            headers=headers,\n            body=body,\n            kwargs=kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a DELETE request pass url and headers", "response": "def delete(self, url, headers=None, kwargs=None):\n        \"\"\"Make a DELETE request.\n\n        To make a DELETE request pass, ``url``\n\n        :param url: ``str``\n        :param headers: ``dict``\n        :param kwargs: ``dict``\n        \"\"\"\n        return self._request(\n            method='delete',\n            url=url,\n            headers=headers,\n            kwargs=kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes a GET request pass url headers and kwargs", "response": "def get(self, url, headers=None, kwargs=None):\n        \"\"\"Make a GET request.\n\n        To make a GET request pass, ``url``\n\n        :param url: ``str``\n        :param headers: ``dict``\n        :param kwargs: ``dict``\n        \"\"\"\n        return self._request(\n            method='get',\n            url=url,\n            headers=headers,\n            kwargs=kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef option(self, url, headers=None, kwargs=None):\n        return self._request(\n            method='option',\n            url=url,\n            headers=headers,\n            kwargs=kwargs\n        )", "response": "Make an OPTION request pass url and headers"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef match(self, text, noprefix=False):\n        n = len(text)\n        if self.cachedpats is not None:\n            pats = self.cachedpats\n        else:\n            pats = self.patterns\n        if n > 5 and not noprefix:\n            basekeys = self.__matchPrefix(text[:6])\n        else:\n            basekeys = []\n        for p in pats:\n            if n < p['length']['min'] or n > p['length']['max']: continue\n            if p['right'] and len(basekeys) > 0 and p['basekey'] not in basekeys: continue\n            try:\n                r = p['pattern'].parseString(text)\n                # Do sanity check\n                d = r.asDict()\n                if 'month' in d:\n                    val = int(d['month'])\n                    if val > 12 or val < 1:\n                        continue\n                if 'day' in d:\n                    val = int(d['day'])\n                    if val > 31 or val < 1:\n                        continue\n                return {'values' : r, 'pattern' : p}\n            except ParseException as e:\n#                print p['key'], text.encode('utf-8'), e\n                pass\n        return None", "response": "Matches a date or datetime string against date patterns and returns pattern and parsed date if matched."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse date and time from given date string.", "response": "def parse(self, text, noprefix=False):\n        \"\"\"Parse date and time from given date string.\n\n        :param text:\n            Any human readable string\n        :type date_string: str|unicode\n        :param noprefix:\n            If set True than doesn't use prefix based date patterns filtering settings\n        :type noprefix: bool\n\n\n        :return: Returns :class:`datetime <datetime.datetime>` representing parsed date if successful, else returns None\n        :rtype: :class:`datetime <datetime.datetime>`.\"\"\"\n\n        res = self.match(text, noprefix)\n        if res:\n            r = res['values']\n            p = res['pattern']\n            d = {'month': 0, 'day': 0, 'year': 0}\n            if 'noyear' in p and p['noyear'] == True:\n                d['year'] = datetime.datetime.now().year\n            for k, v in list(r.items()):\n                d[k] = int(v)\n            dt = datetime.datetime(**d)\n            return dt\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform a safe load using Avocado s backup utilities.", "response": "def forwards(self, orm):\n        \"Perform a 'safe' load using Avocado's backup utilities.\"\n        from avocado.core import backup\n        backup.safe_load(u'0002_avocado_metadata', backup_path=None,\n            using='default')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the next Id in this list.", "response": "def get_next_id(self):\n        \"\"\"Gets the next Id in this list.\n\n        return: (osid.id.Id) - the next Id in this list. The has_next()\n                method should be used to test that a next Id is\n                available before calling this method.\n        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        try:\n            next_item = next(self)\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_item"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_catalogs_by_query(self, catalog_query):\n        # Implemented from template for\n        # osid.resource.BinQuerySession.get_bins_by_query_template\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalogs_by_query(catalog_query)\n        query_terms = dict(catalog_query._query_terms)\n        collection = JSONClientValidated('cataloging',\n                                         collection='Catalog',\n                                         runtime=self._runtime)\n        result = collection.find(query_terms).sort('_id', DESCENDING)\n\n        return objects.CatalogList(result, runtime=self._runtime)", "response": "Gets a list of Catalogs matching the given catalog query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef can_create_catalog_with_record_types(self, catalog_record_types):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=catalog_record_types)\n        return True", "response": "Tests if this user can create a single Catalog using the desired record types."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_catalog(self, catalog_form):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=catalog_form)\n        collection = JSONClientValidated('cataloging',\n                                         collection='Catalog',\n                                         runtime=self._runtime)\n        if not isinstance(catalog_form, ABCCatalogForm):\n            raise errors.InvalidArgument('argument type is not an CatalogForm')\n        if not catalog_form.is_for_update():\n            raise errors.InvalidArgument('the CatalogForm is for update only, not create')\n        try:\n            if self._forms[catalog_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('catalog_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('catalog_form did not originate from this session')\n        if not catalog_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(catalog_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[catalog_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Catalog(osid_object_map=catalog_form._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Updates an existing catalog."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_catalog(self, catalog_id):\n        if self._catalog_session is not None:\n            return self._catalog_session.delete_catalog(catalog_id=bin_id)\n        collection = JSONClientValidated('cataloging',\n                                         collection='Catalog',\n                                         runtime=self._runtime)\n        if not isinstance(catalog_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        collection.delete_one({'_id': ObjectId(catalog_id.get_identifier())})", "response": "Deletes a ``Catalog``.\n\n        arg:    catalog_id (osid.id.Id): the ``Id`` of the ``Catalog``\n                to remove\n        raise:  NotFound - ``catalog_id`` not found\n        raise:  NullArgument - ``catalog_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef alias_catalog(self, catalog_id, alias_id):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=catalog_id, alias_id=alias_id)\n        self._alias_id(primary_id=catalog_id, equivalent_id=alias_id)", "response": "Adds an Id to a catalog for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_root_catalogs(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return CatalogLookupSession(\n            self._proxy,\n            self._runtime).get_catalogs_by_ids(list(self.get_root_catalog_ids()))", "response": "Gets the root catalogs in the catalog hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_parent_catalogs(self, catalog_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=catalog_id)\n        return self._hierarchy_session.has_parents(id_=catalog_id)", "response": "Tests if the catalog has any parents."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_parent_of_catalog(self, id_, catalog_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=catalog_id)\n        return self._hierarchy_session.is_parent(id_=catalog_id, parent_id=id_)", "response": "Tests if an Id is a direct parent of a catalog."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_parent_catalog_ids(self, catalog_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=catalog_id)\n        return self._hierarchy_session.get_parents(id_=catalog_id)", "response": "Gets the parent Ids of the given catalog."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_parent_catalogs(self, catalog_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=catalog_id)\n        return CatalogLookupSession(\n            self._proxy,\n            self._runtime).get_catalogs_by_ids(\n                list(self.get_parent_catalog_ids(catalog_id)))", "response": "Gets the parent catalogs of the given id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_ancestor_of_catalog(self, id_, catalog_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=catalog_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=catalog_id)", "response": "Tests if an Id is an ancestor of a catalog."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_child_catalogs(self, catalog_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=catalog_id)\n        return self._hierarchy_session.has_children(id_=catalog_id)", "response": "Tests if a catalog has any children."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_child_of_catalog(self, id_, catalog_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=catalog_id)\n        return self._hierarchy_session.is_child(id_=catalog_id, child_id=id_)", "response": "Tests if a catalog is a direct child of another."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the child Ids of the given catalog.", "response": "def get_child_catalog_ids(self, catalog_id):\n        \"\"\"Gets the child ``Ids`` of the given catalog.\n\n        arg:    catalog_id (osid.id.Id): the ``Id`` to query\n        return: (osid.id.IdList) - the children of the catalog\n        raise:  NotFound - ``catalog_id`` is not found\n        raise:  NullArgument - ``catalog_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=catalog_id)\n        return self._hierarchy_session.get_children(id_=catalog_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_child_catalogs(self, catalog_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=catalog_id)\n        return CatalogLookupSession(\n            self._proxy,\n            self._runtime).get_catalogs_by_ids(\n                list(self.get_child_catalog_ids(catalog_id)))", "response": "Gets the child catalogs of the given id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntest if an Id is a descendant of a catalog.", "response": "def is_descendant_of_catalog(self, id_, catalog_id):\n        \"\"\"Tests if an ``Id`` is a descendant of a catalog.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    catalog_id (osid.id.Id): the ``Id`` of a catalog\n        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``catalog_id,``  ``false`` otherwise\n        raise:  NotFound - ``catalog_id`` not found\n        raise:  NullArgument - ``catalog_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` is not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=catalog_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=catalog_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_catalog_nodes(self, catalog_id, ancestor_levels, descendant_levels, include_siblings):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.CatalogNode(self.get_catalog_node_ids(\n            catalog_id=catalog_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the portion of the hierarchy for the given catalog."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a root catalog.", "response": "def add_root_catalog(self, catalog_id):\n        \"\"\"Adds a root catalog.\n\n        arg:    catalog_id (osid.id.Id): the ``Id`` of a catalog\n        raise:  AlreadyExists - ``catalog_id`` is already in hierarchy\n        raise:  NotFound - ``catalog_id`` not found\n        raise:  NullArgument - ``catalog_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=catalog_id)\n        return self._hierarchy_session.add_root(id_=catalog_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a root catalog.", "response": "def remove_root_catalog(self, catalog_id):\n        \"\"\"Removes a root catalog.\n\n        arg:    catalog_id (osid.id.Id): the ``Id`` of a catalog\n        raise:  NotFound - ``catalog_id`` is not a root\n        raise:  NullArgument - ``catalog_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=catalog_id)\n        return self._hierarchy_session.remove_root(id_=catalog_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a child to a catalog.", "response": "def add_child_catalog(self, catalog_id, child_id):\n        \"\"\"Adds a child to a catalog.\n\n        arg:    catalog_id (osid.id.Id): the ``Id`` of a catalog\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``catalog_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``catalog_id`` or ``child_id`` not found\n        raise:  NullArgument - ``catalog_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=catalog_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=catalog_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_child_catalog(self, catalog_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=catalog_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=catalog_id, child_id=child_id)", "response": "Removes a child from a catalog."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving all children from a catalog.", "response": "def remove_child_catalogs(self, catalog_id):\n        \"\"\"Removes all children from a catalog.\n\n        arg:    catalog_id (osid.id.Id): the ``Id`` of a catalog\n        raise:  NotFound - ``catalog_id`` is not in hierarchy\n        raise:  NullArgument - ``catalog_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalogs(catalog_id=catalog_id)\n        return self._hierarchy_session.remove_children(id_=catalog_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_scan_parameter_description(scan_parameters):\n    '''Generate scan parameter dictionary. This is the only way to dynamically create table with dictionary, cannot be done with tables.IsDescription\n\n    Parameters\n    ----------\n    scan_parameters : list, tuple\n        List of scan parameters names (strings).\n\n    Returns\n    -------\n    table_description : dict\n        Table description.\n\n    Usage\n    -----\n    pytables.createTable(self.raw_data_file_h5.root, name = 'scan_parameters', description = generate_scan_parameter_description(['PlsrDAC']), title = 'scan_parameters', filters = filter_tables)\n    '''\n    table_description = np.dtype([(key, tb.Int32Col(pos=idx)) for idx, key in enumerate(scan_parameters)])\n    return table_description", "response": "Generate the scan parameter dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_scan_configuration_description(scan_parameters):\n    '''Generate scan parameter dictionary. This is the only way to dynamically create table with dictionary, cannot be done with tables.IsDescription\n\n    Parameters\n    ----------\n    scan_parameters : list, tuple\n        List of scan parameters names (strings).\n\n    Returns\n    -------\n    table_description : dict\n        Table description.\n\n    Usage\n    -----\n    pytables.createTable(self.raw_data_file_h5.root, name = 'scan_parameters', description = generate_scan_configuration_description(['PlsrDAC']), title = 'scan_parameters', filters = filter_tables)\n    '''\n    table_description = np.dtype([(key, tb.StringCol(512, pos=idx)) for idx, key in enumerate(scan_parameters)])\n    return table_description", "response": "Generate the scan parameter dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsplits a nick!host string into nick user and host.", "response": "def split_hostmask(hostmask):\n    \"\"\"Splits a nick@host string into nick and host.\"\"\"\n    nick, _, host = hostmask.partition('@')\n    nick, _, user = nick.partition('!')\n    return nick, user or None, host or None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes histogram for a given vector of values.", "response": "def compute_histogram(values, edges, use_orig_distr=False):\n    \"\"\"Computes histogram (density) for a given vector of values.\"\"\"\n\n    if use_orig_distr:\n        return values\n\n    # ignoring invalid values: Inf and Nan\n    values = check_array(values).compressed()\n\n    hist, bin_edges = np.histogram(values, bins=edges, density=True)\n    hist = preprocess_histogram(hist, values, edges)\n\n    return hist"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef preprocess_histogram(hist, values, edges):\n\n    # working with extremely skewed histograms\n    if np.count_nonzero(hist) == 0:\n        # all of them above upper bound\n        if np.all(values >= edges[-1]):\n            hist[-1] = 1\n        # all of them below lower bound\n        elif np.all(values <= edges[0]):\n            hist[0] = 1\n\n    return hist", "response": "Handles edge - cases and extremely skewed histograms"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_array(array):\n    \"Converts to flattened numpy arrays and ensures its not empty.\"\n\n    if len(array) < 1:\n        raise ValueError('Input array is empty! Must have atleast 1 element.')\n\n    return np.ma.masked_invalid(array).flatten()", "response": "Converts to flattened numpy arrays and ensures its not empty."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of Accounts from Toshl for the current user", "response": "def list(self):\n        \"\"\"\n        Return a list of Accounts from Toshl for the current user\n        \"\"\"\n        response = self.client._make_request('/accounts')\n        response = response.json()\n        return self.client._list_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch the Accounts for the current user and return the ID of the account with the specified name.", "response": "def search(self, account_name):\n        \"\"\"\n        Get a list of all the Accounts for the current user and return the ID\n        of the one with the specified name.\n        \"\"\"\n        accounts = self.list()\n        for a in accounts:\n            if a['name'] == account_name:\n                return a['id']"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a specific account given its ID", "response": "def get(self, account_id):\n        \"\"\"\n        Return a specific account given its ID\n        \"\"\"\n        response = self.client._make_request('/accounts/{0}'.format(account_id))\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessment_part_bank_session(self):\n        if not self.supports_assessment_part_bank():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentPartBankSession(runtime=self._runtime)", "response": "Gets the OsidSession to lookup assessment part / bank mappings for assessment parts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_part_bank_assignment_session(self):\n        if not self.supports_assessment_part_bank_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentPartBankAssignmentSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with assigning assessment part to bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the sequence rule lookup service.", "response": "def get_sequence_rule_lookup_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the sequence rule lookup service.\n\n        return: (osid.assessment.authoring.SequenceRuleLookupSession) -\n                a ``SequenceRuleLookupSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_lookup()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_sequence_rule_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_sequence_rule_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.SequenceRuleLookupSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_sequence_rule_admin_session(self):\n        if not self.supports_sequence_rule_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.SequenceRuleAdminSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the sequence rule administration service."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_sequence_rule_admin_session_for_bank(self, bank_id):\n        if not self.supports_sequence_rule_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.SequenceRuleAdminSession(bank_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the sequence rule administration service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assessment_part_item_session(self, *args, **kwargs):\n        if not self.supports_assessment_part_lookup():  # This is kludgy, but only until Tom fixes spec\n            raise errors.Unimplemented()\n        if self._proxy_in_args(*args, **kwargs):\n            raise errors.InvalidArgument('A Proxy object was received but not expected.')\n        # pylint: disable=no-member\n        return sessions.AssessmentPartItemSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment part item service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the OsidSession associated with the assessment part item design service.", "response": "def get_assessment_part_item_design_session(self, *args, **kwargs):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment part item design service.\n\n        return: (osid.assessment.authoring.AssessmentPartItemDesignSession)\n                - an ``AssessmentPartItemDesignSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_item_design()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_part_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_part_lookup():  # This is kludgy, but only until Tom fixes spec\n            raise errors.Unimplemented()\n        if self._proxy_in_args(*args, **kwargs):\n            raise errors.InvalidArgument('A Proxy object was received but not expected.')\n        # pylint: disable=no-member\n        return sessions.AssessmentPartItemDesignSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assessment_part_lookup_session(self, proxy):\n        if not self.supports_assessment_part_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentPartLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment part lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the assessment part lookup service for the given bank.", "response": "def get_assessment_part_lookup_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment part lookup service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.authoring.AssessmentPartLookupSession)\n                - an ``AssessmentPartLookupSession``\n        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_lookup()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_part_lookup()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_part_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentPartLookupSession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the assessment part query service.", "response": "def get_assessment_part_query_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment part query service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.authoring.AssessmentPartQuerySession) -\n                an ``AssessmentPartQuerySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_query()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_part_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_part_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentPartQuerySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the assessment part query service for the given bank.", "response": "def get_assessment_part_query_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment part query service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.authoring.AssessmentPartQuerySession) -\n                an ``AssessmentPartQuerySession``\n        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_query()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_part_query()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_part_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentPartQuerySession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_part_admin_session(self, proxy):\n        if not self.supports_assessment_part_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentPartAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment part administration service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the assessment part administration service for the given bank.", "response": "def get_assessment_part_admin_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment part administration service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.authoring.AssessmentPartAdminSession) -\n                an ``AssessmentPartAdminSession``\n        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_part_admin()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_part_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.AssessmentPartAdminSession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the sequence rule lookup service for the given bank.", "response": "def get_sequence_rule_lookup_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the sequence rule lookup service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.assessment.authoring.SequenceRuleLookupSession) -\n                a ``SequenceRuleLookupSession``\n        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_lookup()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_sequence_rule_lookup()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_sequence_rule_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.SequenceRuleLookupSession(bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assessment_part_item_session(self, proxy):\n        if not self.supports_assessment_part_lookup():  # This is kludgy, but only until Tom fixes spec\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentPartItemSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment part item service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assessment_part_item_session_for_bank(self, bank_id, proxy):\n        if not self.supports_assessment_part_lookup():  # This is kludgy, but only until Tom fixes spec\n            raise errors.Unimplemented()\n\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        # pylint: disable=no-member\n        return sessions.AssessmentPartItemSession(bank_id, proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the assessment part item service for the given bank."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the OsidSession associated with the assessment part item design service.", "response": "def get_assessment_part_item_design_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment part item design service.\n\n        return: (osid.assessment.authoring.AssessmentPartItemDesignSession)\n                - an ``AssessmentPartItemDesignSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_item_design()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_part_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_part_lookup():  # This is kludgy, but only until Tom fixes spec\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.AssessmentPartItemDesignSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the assessment part item design service for the given bank.", "response": "def get_assessment_part_item_design_session_for_bank(self, bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the assessment part item design service for the given bank.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        return: (osid.assessment.authoring.AssessmentPartItemDesignSession)\n                - an ``AssessmentPartItemDesignSession``\n        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_item_design()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_assessment_part_item_design()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_assessment_part_lookup():  # This is kludgy, but only until Tom fixes spec\n            raise errors.Unimplemented()\n\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        # pylint: disable=no-member\n        return sessions.AssessmentPartItemDesignSession(bank_id, proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deprecated(operation=None):\n    def inner(o):\n        o.deprecated = True\n        return o\n    return inner(operation) if operation else inner", "response": "Mark an operation deprecated."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_param(param):\n    # type: (Param) -> Callable\n    \"\"\"\n    Add parameter, you should probably use on of :meth:`path_param`, :meth:`query_param`,\n    :meth:`body_param`, or :meth:`header_param`.\n    \"\"\"\n    def inner(o):\n        try:\n            getattr(o, 'parameters').add(param)\n        except AttributeError:\n            setattr(o, 'parameters', {param})\n        return o\n    return inner", "response": "Decorator to add a parameter to a node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef response(status, description, resource=DefaultResource):\n    # type: (HTTPStatus, str, Optional[Resource]) -> Callable\n    \"\"\"\n    Define an expected response.\n\n    The values are based off `Swagger <https://swagger.io/specification>`_.\n\n    \"\"\"\n    def inner(o):\n        value = Response(status, description, resource)\n        try:\n            getattr(o, 'responses').add(value)\n        except AttributeError:\n            setattr(o, 'responses', {value})\n        return o\n    return inner", "response": "Define an expected response."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndefine content types produced by an endpoint.", "response": "def produces(*content_types):\n    \"\"\"\n    Define content types produced by an endpoint.\n    \"\"\"\n    def inner(o):\n        if not all(isinstance(content_type, _compat.string_types) for content_type in content_types):\n            raise ValueError(\"In parameter not a valid value.\")\n        try:\n            getattr(o, 'produces').update(content_types)\n        except AttributeError:\n            setattr(o, 'produces', set(content_types))\n        return o\n    return inner"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_resource_id(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['resourceId']):\n            raise errors.IllegalState('this Authorization has no resource')\n        else:\n            return Id(self._my_map['resourceId'])", "response": "Gets the resource Id for this authorization."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_resource(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['resourceId']):\n            raise errors.IllegalState('this Authorization has no resource')\n        mgr = self._get_provider_manager('RESOURCE')\n        if not mgr.supports_resource_lookup():\n            raise errors.OperationFailed('Resource does not support Resource lookup')\n        lookup_session = mgr.get_resource_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_bin_view()\n        osid_object = lookup_session.get_resource(self.get_resource_id())\n        return osid_object", "response": "Gets the Resource for this authorization."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_trust_id(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['trustId']):\n            raise errors.IllegalState('this Authorization has no trust')\n        else:\n            return Id(self._my_map['trustId'])", "response": "Gets the Trust Id for this authorization."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the Trust for this authorization.", "response": "def get_trust(self):\n        \"\"\"Gets the ``Trust`` for this authorization.\n\n        return: (osid.authentication.process.Trust) - the ``Trust``\n        raise:  IllegalState - ``has_trust()`` is ``false``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['trustId']):\n            raise errors.IllegalState('this Authorization has no trust')\n        mgr = self._get_provider_manager('AUTHENTICATION.PROCESS')\n        if not mgr.supports_trust_lookup():\n            raise errors.OperationFailed('Authentication.Process does not support Trust lookup')\n        lookup_session = mgr.get_trust_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_agency_view()\n        osid_object = lookup_session.get_trust(self.get_trust_id())\n        return osid_object"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the Function Id for this authorization.", "response": "def get_function_id(self):\n        \"\"\"Gets the ``Function Id`` for this authorization.\n\n        return: (osid.id.Id) - the function ``Id``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['functionId']):\n            raise errors.IllegalState('function empty')\n        return Id(self._my_map['functionId'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_function(self):\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['functionId']):\n            raise errors.IllegalState('function empty')\n        mgr = self._get_provider_manager('AUTHORIZATION')\n        if not mgr.supports_function_lookup():\n            raise errors.OperationFailed('Authorization does not support Function lookup')\n        lookup_session = mgr.get_function_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_vault_view()\n        return lookup_session.get_function(self.get_function_id())", "response": "Gets the Function for this authorization."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the Qualifier Id for this authorization.", "response": "def get_qualifier_id(self):\n        \"\"\"Gets the ``Qualifier Id`` for this authorization.\n\n        return: (osid.id.Id) - the qualifier ``Id``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['qualifierId']):\n            raise errors.IllegalState('qualifier empty')\n        return Id(self._my_map['qualifierId'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the qualifier for this authorization.", "response": "def get_qualifier(self):\n        \"\"\"Gets the qualifier for this authorization.\n\n        return: (osid.authorization.Qualifier) - the qualifier\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['qualifierId']):\n            raise errors.IllegalState('qualifier empty')\n        mgr = self._get_provider_manager('AUTHORIZATION')\n        if not mgr.supports_qualifier_lookup():\n            raise errors.OperationFailed('Authorization does not support Qualifier lookup')\n        lookup_session = mgr.get_qualifier_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_vault_view()\n        return lookup_session.get_qualifier(self.get_qualifier_id())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_vault(self):\n        if self._lookup_session is None:\n            mgr = get_provider_manager('AUTHORIZATION', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_vault_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_vault(Id(self._my_map['id']))", "response": "Gets the Vault at this node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the parents of this vault.", "response": "def get_parent_vault_nodes(self):\n        \"\"\"Gets the parents of this vault.\n\n        return: (osid.authorization.VaultNodeList) - the parents of this\n                vault\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        parent_vault_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_vault_nodes.append(VaultNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return VaultNodeList(parent_vault_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nflips a sequence direction with 0. 5 probability", "response": "def random_flip(sequence,rnum=None):\n  \"\"\"Flip a sequence direction with 0.5 probability\"\"\"\n  randin = rnum\n  if not randin: randin = RandomSource()\n  if randin.random() < 0.5:\n    return rc(sequence)\n  return sequence"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef random_substitution(self,fastq,rate):\n    sequence = fastq.sequence\n    seq = ''\n    for i in range(len(sequence)):\n      # check context\n      prev = None\n      if i >= 1: prev = sequence[i-1]\n      next = None\n      if i < len(sequence)-1: next = sequence[i+1]\n      if self._before_base and (not prev or prev != self._before_base): \n        seq+=sequence[i]\n        continue\n      if self._after_base and (not next or next != self._after_base): \n        seq+=sequence[i]\n        continue\n      if self._observed_base and (sequence[i] != self._observed_base):\n        seq+=sequence[i]\n        continue\n\n      rnum = self.random.random()\n      if rnum < rate:\n        if not self._modified_base:\n          seq += self.random.different_random_nt(sequence[i])\n        else:\n          seq += self._modified_base\n      else:\n        seq += sequence[i]\n    return FASTQ('@'+fastq.header+\"\\n\"+seq+\"\\n+\\n\"+fastq.qual+\"\\n\")", "response": "Perform the permutation on the sequence\n    and return the result."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms the permutation on the sequence", "response": "def random_deletion(self,fastq,rate):\n    \"\"\"Perform the permutation on the sequence\n\n    :param fastq: FASTQ sequence to permute\n    :type fastq: format.fastq.FASTQ\n    :param rate: how frequently to permute\n    :type rate: float\n    :return: Permutted FASTQ\n    :rtype: format.fastq.FASTQ\n    \"\"\"\n    sequence = fastq.sequence\n    quality = fastq.qual\n    seq = ''\n    qual = None\n    if quality: qual = ''\n    for i in range(len(sequence)):\n      # check context\n      prev = None\n      if i >= 1: prev = sequence[i-1]\n      next = None\n      if i < len(sequence)-1: next = sequence[i+1]\n      if self._before_base and (not prev or prev != self._before_base): \n        seq+=sequence[i]\n        if quality: qual+=quality[i]\n        continue\n      if self._after_base and (not next or next != self._after_base): \n        seq+=sequence[i]\n        if quality: qual+=quality[i]\n        continue\n      if self._observed_base and (sequence[i] != self._observed_base):\n        seq+=sequence[i]\n        if quality: qual+=quality[i]\n        continue\n\n      rnum = self.random.random()\n      if rnum >= rate:\n        seq += sequence[i]\n        if quality: qual+=quality[i]\n    return FASTQ('@'+fastq.header+\"\\n\"+seq+\"\\n+\\n\"+qual+\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef random_insertion(self,fastq,rate,max_inserts=1):\n    sequence = fastq.sequence\n    quality = fastq.qual\n    seq = ''\n    qual = None\n    ibase = rate_to_phred33(rate)\n    if quality: qual = ''\n    z = 0\n    while self.random.random() < rate and z < max_inserts:\n      if self._before_base: break # can't do this one\n      if self._after_base:\n        if self._after_base != sequence[1]: break\n      z += 1\n      if self._modified_base:\n        seq += self._modified_base\n        if quality: qual += ibase\n      else:\n        seq += self.random.random_nt()\n        if quality: qual += ibase\n    z = 0\n    for i in range(len(sequence)):\n      # check context\n      prev = sequence[i]\n      next = None\n      if i < len(sequence)-1: next = sequence[i+1]\n      if self._before_base and (not prev or prev != self._before_base): \n        seq+=sequence[i]\n        if quality: qual+=quality[i]\n        continue\n      if self._after_base and (not next or next != self._after_base): \n        seq+=sequence[i]\n        if quality: qual+= quality[i]\n        continue\n\n      seq += sequence[i]\n      if quality: qual += quality[i]\n      while self.random.random() < rate and z < max_inserts:\n        z+=1\n        if self._modified_base:\n          seq += self._modified_base\n          if quality: qual += ibase\n        else:\n          seq += self.random.random_nt()\n          if quality: qual += ibase\n      z = 0\n    return FASTQ('@'+fastq.name+\"\\n\"+seq+\"\\n+\\n\"+qual+\"\\n\")", "response": "Perform the permutation on the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a minimum lengtha and then the gaussian distribution parameters for cutting", "response": "def set_custom(self,gmin,gmu,gsigma):\n    \"\"\"Set a minimum lengtha, and then the gaussian distribution parameters for cutting\n       For any sequence longer than the minimum the guassian parameters will be used\"\"\"\n    self._gauss_min = gmin\n    self._gauss_mu = gmu\n    self._gauss_sigma = gsigma"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _is_match(self, response, answer):\n\n        def compare_conditions(droppable_id, spatial_units, response_conditions):\n            \"\"\"Compare response coordinates with spatial units for droppable_id\"\"\"\n            coordinate_match = True\n            for coordinate in response_conditions['coordinate_conditions']['include'][droppable_id]:\n                answer_match = False\n                for spatial_unit in spatial_units:\n                    if (coordinate['containerId'] == spatial_unit['containerId'] and\n                            coordinate['coordinate'] in spatial_unit['spatialUnit']):\n                        answer_match = True\n                        break\n                coordinate_match = coordinate_match and answer_match\n            return coordinate_match\n\n        # Did the consumer application already do the work for us?\n        if response.has_zone_conditions():\n            return bool(response.get_zone_conditions() == answer.get_zone_conditions())\n\n        answer_conditions = self._get_conditions_map(answer)\n        response_conditions = self._get_conditions_map(response)\n\n        # Check to see if the lists of droppables used are the same:\n        if set(answer_conditions['spatial_unit_conditions']['include']) != set(response_conditions['coordinate_conditions']['include']):\n            return False\n\n        # Compare included answer spatial unit areas to response coordinates\n        for droppable_id, spatial_units in answer_conditions['spatial_unit_conditions']['include'].items():\n            # Do the number of defined include conditions match:\n            if len(spatial_units) != len(response_conditions['coordinate_conditions']['include'][droppable_id]):\n                return False\n            if not compare_conditions(droppable_id, spatial_units, response_conditions):\n                return False\n\n        # Compare excluded answer spatial unit areas to response coordinates\n        for droppable_id, spatial_units in answer_conditions['spatial_unit_conditions']['exclude'].items():\n            if compare_conditions(droppable_id, spatial_units, response_conditions):\n                return False\n        return True", "response": "Does the response match the answer?"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget measure of correctness available for a particular response", "response": "def get_correctness_for_response(self, response):\n        \"\"\"get measure of correctness available for a particular response\"\"\"\n        for answer in self.my_osid_object.get_answers():\n            if self._is_match(response, answer):\n                try:\n                    return answer.get_score()\n                except AttributeError:\n                    return 100\n        for answer in self.my_osid_object.get_wrong_answers():\n            if self._is_match(response, answer):\n                try:\n                    return answer.get_score()\n                except AttributeError:\n                    return 0\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_coordinate_conditions(self):\n        condition_list = deepcopy(self.my_osid_object._my_map['coordinateConditions'])\n        for condition in condition_list:\n            condition['coordinate'] = BasicCoordinate(condition['coordinate'])\n        return condition_list", "response": "get the list of conditions for this object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_spatial_unit_conditions(self):\n        condition_list = deepcopy(self.my_osid_object._my_map['spatialUnitConditions'])\n        for condition in condition_list:\n            condition['spatialUnit'] = SpatialUnitFactory().get_spatial_unit(spatial_unit_map=condition['spatialUnit'])\n        return condition_list", "response": "get the spatial unit conditions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_map(self):\n        self.my_osid_object_form._my_map['zoneConditions'] = \\\n            self._zone_conditions_metadata['default_object_values'][0]\n        self.my_osid_object_form._my_map['coordinateConditions'] = \\\n            self._coordinate_conditions_metadata['default_object_values'][0]\n        self.my_osid_object_form._my_map['spatialUnitConditions'] = \\\n            self._spatial_unit_conditions_metadata['default_object_values'][0]", "response": "Initialize the map with the default values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_metadata(self):\n        self._zone_conditions_metadata = {\n            'zone_matches': Id(self.my_osid_object_form._authority,\n                               self.my_osid_object_form._namespace,\n                               'zone_conditions'),\n            'element_label': 'zone conditions',\n            'instructions': 'zone conditions for answer',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n        }\n        self._coordinate_conditions_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'coordinate_conditions'),\n            'element_label': 'coordinate conditions',\n            'instructions': 'coordinate conditions for answer',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n        }\n        self._spatial_unit_conditions_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'spatial_unit_conditions'),\n            'element_label': 'spatial unit conditions',\n            'instructions': 'spatial unit conditions for answer',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n        }", "response": "Initializes the metadata for the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a condition to the list of zones that can be dropped", "response": "def add_zone_condition(self, droppable_id, zone_id, match=True):\n        \"\"\"stub\"\"\"\n        self.my_osid_object_form._my_map['zoneConditions'].append(\n            {'droppableId': droppable_id, 'zoneId': zone_id, 'match': match})\n        self.my_osid_object_form._my_map['zoneConditions'].sort(key=lambda k: k['zoneId'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_zone_conditions(self):\n        if (self.get_zone_conditions_metadata().is_read_only() or\n                self.get_zone_conditions_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['zoneConditions'] = \\\n            self._zone_conditions_metadata['default_object_values'][0]", "response": "clear the zone conditions"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_coordinate_condition(self, droppable_id, container_id, coordinate, match=True):\n        if not isinstance(coordinate, BasicCoordinate):\n            raise InvalidArgument('coordinate is not a BasicCoordinate')\n        self.my_osid_object_form._my_map['coordinateConditions'].append(\n            {'droppableId': droppable_id, 'containerId': container_id, 'coordinate': coordinate.get_values(), 'match': match})\n        self.my_osid_object_form._my_map['coordinateConditions'].sort(key=lambda k: k['containerId'])", "response": "add a condition to the list of coordinate conditions"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_coordinate_conditions(self):\n        if (self.get_zone_conditions_metadata().is_read_only() or\n                self.get_zone_conditions_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['coordinateConditions'] = \\\n            self._coordinate_conditions_metadata['default_object_values'][0]", "response": "clear the coordinate conditions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_spatial_unit_condition(self, droppable_id, container_id, spatial_unit, match=True):\n        if not isinstance(spatial_unit, abc_mapping_primitives.SpatialUnit):\n            raise InvalidArgument('spatial_unit is not a SpatialUnit')\n\n        self.my_osid_object_form._my_map['spatialUnitConditions'].append(\n            {'droppableId': droppable_id, 'containerId': container_id, 'spatialUnit': spatial_unit.get_spatial_unit_map(), 'match': match})\n        self.my_osid_object_form._my_map['spatialUnitConditions'].sort()", "response": "add a spatial unit condition"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_spatial_unit_conditions(self):\n        if (self.get_spatial_unit_conditions_metadata().is_read_only() or\n                self.get_zone_conditions_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['spatialUnitConditions'] = \\\n            self._zone_conditions_metadata['default_object_values'][0]", "response": "clear spatial unit conditions"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_droppables(self):\n        droppables = []\n        for current_droppable in self.my_osid_object._my_map['droppables']:\n            droppables.append({\n                'id': current_droppable['id'],\n                'text': self.get_matching_language_value('texts',\n                                                         dictionary=current_droppable).text,\n                'name': self.get_matching_language_value('names',\n                                                         dictionary=current_droppable).text,\n                'reuse': current_droppable['reuse'],\n                'dropBehaviorType': current_droppable['dropBehaviorType']\n            })\n        return droppables", "response": "returns a list of all the droppables"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all the target objects", "response": "def get_targets(self):\n        \"\"\"stub\"\"\"\n        targets = []\n        for current_target in self.my_osid_object._my_map['targets']:\n            targets.append({\n                'id': current_target['id'],\n                'text': self.get_matching_language_value('texts',\n                                                         dictionary=current_target).text,\n                'name': self.get_matching_language_value('names',\n                                                         dictionary=current_target).text,\n                'dropBehaviorType': current_target['dropBehaviorType']\n            })\n        return targets"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_zones(self):\n        zones = []\n        for current_zone in self.my_osid_object._my_map['zones']:\n            zones.append({\n                'id': current_zone['id'],\n                'name': self.get_matching_language_value('names',\n                                                         dictionary=current_zone).text,\n                'description': self.get_matching_language_value('descriptions',\n                                                                dictionary=current_zone).text,\n                'spatialUnit': SpatialUnitFactory().get_spatial_unit(current_zone['spatialUnit']).get_spatial_unit_map(),\n                'containerId': current_zone['containerId'],\n                'visible': current_zone['visible'],\n                'reuse': current_zone['reuse'],\n                'dropBehaviorType': current_zone['dropBehaviorType']\n            })\n        return zones", "response": "returns a list of all zones"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the object map with the current values of the object.", "response": "def _update_object_map(self, obj_map):\n        \"\"\"unclear if it's better to use this method or get_object_map\n        My main consideration is that MultiLanguageQuestionRecord already\n        overrides get_object_map\n        \"\"\"\n        obj_map['droppables'] = self.get_droppables()\n        obj_map['targets'] = self.get_targets()\n        obj_map['zones'] = self.get_zones()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_map(self):\n        super(MultiLanguageDragAndDropQuestionFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['droppables'] = \\\n            self._droppables_metadata['default_object_values'][0]\n        self.my_osid_object_form._my_map['targets'] = \\\n            self._targets_metadata['default_object_values'][0]\n        self.my_osid_object_form._my_map['zones'] = \\\n            self._zones_metadata['default_object_values'][0]\n        self.my_osid_object_form._my_map['shuffleDroppables'] = \\\n            bool(self._shuffle_droppables_metadata['default_boolean_values'][0])\n        self.my_osid_object_form._my_map['shuffleTargets'] = \\\n            bool(self._shuffle_targets_metadata['default_boolean_values'][0])\n        self.my_osid_object_form._my_map['shuffleZones'] = \\\n            bool(self._shuffle_zones_metadata['default_boolean_values'][0])", "response": "Initialize the map of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the metadata for the record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(MultiLanguageDragAndDropQuestionFormRecord, self)._init_metadata()\n        self._droppables_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'droppables'),\n            'element_label': 'droppables',\n            'instructions': 'Enter as many droppables as you wish',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._targets_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'targets'),\n            'element_label': 'targets',\n            'instructions': 'Enter as many targets as you wish',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._zones_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'zones'),\n            'element_label': 'zones',\n            'instructions': 'Enter as many zones as you wish',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._shuffle_droppables_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'shuffleDroppables'),\n            'element_label': 'Shuffle Droppables',\n            'instructions': 'Shuffle droppables',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN',\n        }\n        self._shuffle_targets_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'shuffleTargets'),\n            'element_label': 'Shuffle Targets',\n            'instructions': 'Shuffle targets',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN',\n        }\n        self._shuffle_zones_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'shuffleZones'),\n            'element_label': 'Shuffle Zones',\n            'instructions': 'Shuffle zones',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN',\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a droppable entry to the list", "response": "def add_droppable(self, droppable_text, name='', reuse=1, drop_behavior_type=None):\n        \"\"\"stub\"\"\"\n        if not isinstance(droppable_text, DisplayText):\n            raise InvalidArgument('droppable_text is not a DisplayText object')\n        if not isinstance(reuse, int):\n            raise InvalidArgument('reuse must be an integer')\n        if reuse < 0:\n            raise InvalidArgument('reuse must be >= 0')\n        if not isinstance(name, DisplayText):\n            # if default ''\n            name = self._str_display_text(name)\n        droppable = {\n            'id': str(ObjectId()),\n            'texts': [self._dict_display_text(droppable_text)],\n            'names': [self._dict_display_text(name)],\n            'reuse': reuse,\n            'dropBehaviorType': drop_behavior_type\n        }\n        self.my_osid_object_form._my_map['droppables'].append(droppable)\n        return droppable"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear_droppable_texts(self, droppable_id):\n        if self.get_droppables_metadata().is_read_only():\n            raise NoAccess()\n        updated_droppables = []\n        for current_droppable in self.my_osid_object_form._my_map['droppables']:\n            if current_droppable['id'] != droppable_id:\n                updated_droppables.append(current_droppable)\n            else:\n                updated_droppables.append({\n                    'id': current_droppable['id'],\n                    'texts': [],\n                    'names': current_droppable['names'],\n                    'reuse': current_droppable['reuse'],\n                    'dropBehaviorType': current_droppable['dropBehaviorType']\n                })\n        self.my_osid_object_form._my_map['droppables'] = updated_droppables", "response": "clear the droppable texts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_droppable(self, droppable_id):\n        updated_droppables = []\n        for droppable in self.my_osid_object_form._my_map['droppables']:\n            if droppable['id'] != droppable_id:\n                updated_droppables.append(droppable)\n        self.my_osid_object_form._my_map['droppables'] = updated_droppables", "response": "remove a droppable given the id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_droppable_order(self, droppable_ids):\n        reordered_droppables = []\n        current_droppable_ids = [d['id'] for d in self.my_osid_object_form._my_map['droppables']]\n        if set(droppable_ids) != set(current_droppable_ids):\n            raise IllegalState('droppable_ids do not match existing droppables')\n\n        for droppable_id in droppable_ids:\n            for current_droppable in self.my_osid_object_form._my_map['droppables']:\n                if droppable_id == current_droppable['id']:\n                    reordered_droppables.append(current_droppable)\n                    break\n\n        self.my_osid_object_form._my_map['droppables'] = reordered_droppables", "response": "reorder the droppables per the passed in list\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_target(self, target_text, name='', drop_behavior_type=None):\n        if not isinstance(target_text, DisplayText):\n            raise InvalidArgument('target_text is not a DisplayText object')\n        if not isinstance(name, DisplayText):\n            # if default ''\n            name = self._str_display_text(name)\n        target = {\n            'id': str(ObjectId()),\n            'texts': [self._dict_display_text(target_text)],\n            'names': [self._dict_display_text(name)],\n            'dropBehaviorType': drop_behavior_type\n        }\n        self.my_osid_object_form._my_map['targets'].append(target)\n        return target", "response": "add a target to the list of targets"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nclears the names of the target", "response": "def clear_target_names(self, target_id):\n        \"\"\"stub\"\"\"\n        if self.get_targets_metadata().is_read_only():\n            raise NoAccess()\n        updated_targets = []\n        for current_target in self.my_osid_object_form._my_map['targets']:\n            if current_target['id'] != target_id:\n                updated_targets.append(current_target)\n            else:\n                updated_targets.append({\n                    'id': current_target['id'],\n                    'texts': current_target['texts'],\n                    'names': [],\n                    'dropBehaviorType': current_target['dropBehaviorType']\n                })\n        self.my_osid_object_form._my_map['targets'] = updated_targets"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a target given the id", "response": "def remove_target(self, target_id):\n        \"\"\"remove a target, given the id\"\"\"\n        updated_targets = []\n        for target in self.my_osid_object_form._my_map['targets']:\n            if target['id'] != target_id:\n                updated_targets.append(target)\n        self.my_osid_object_form._my_map['targets'] = updated_targets"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreordering the list of target_ids per the passed in list", "response": "def set_target_order(self, target_ids):\n        \"\"\" reorder targets per the passed in list\n        :param target_ids:\n        :return:\n        \"\"\"\n        reordered_targets = []\n        current_target_ids = [t['id'] for t in self.my_osid_object_form._my_map['targets']]\n        if set(target_ids) != set(current_target_ids):\n            raise IllegalState('target_ids do not match existing targets')\n\n        for target_id in target_ids:\n            for current_target in self.my_osid_object_form._my_map['targets']:\n                if target_id == current_target['id']:\n                    reordered_targets.append(current_target)\n                    break\n\n        self.my_osid_object_form._my_map['targets'] = reordered_targets"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_zone(self, spatial_unit, container_id, name='', description='', visible=True, reuse=0, drop_behavior_type=None):\n        if not isinstance(spatial_unit, abc_mapping_primitives.SpatialUnit):\n            raise InvalidArgument('zone is not a SpatialUnit')\n        # if not isinstance(name, DisplayText):\n        #     raise InvalidArgument('name is not a DisplayText object')\n        if not isinstance(reuse, int):\n            raise InvalidArgument('reuse must be an integer')\n        if reuse < 0:\n            raise InvalidArgument('reuse must be >= 0')\n        if not isinstance(name, DisplayText):\n            # if default ''\n            name = self._str_display_text(name)\n        if not isinstance(description, DisplayText):\n            # if default ''\n            description = self._str_display_text(description)\n        zone = {\n            'id': str(ObjectId()),\n            'spatialUnit': spatial_unit.get_spatial_unit_map(),\n            'containerId': container_id,\n            'names': [self._dict_display_text(name)],\n            'descriptions': [self._dict_display_text(description)],\n            'visible': visible,\n            'reuse': reuse,\n            'dropBehaviorType': str(drop_behavior_type)\n        }\n        self.my_osid_object_form._my_map['zones'].append(zone)\n        return zone", "response": "add a zone to the map"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a zone given the id", "response": "def remove_zone(self, zone_id):\n        \"\"\"remove a zone, given the id\"\"\"\n        updated_zones = []\n        for zone in self.my_osid_object_form._my_map['zones']:\n            if zone['id'] != zone_id:\n                updated_zones.append(zone)\n        self.my_osid_object_form._my_map['zones'] = updated_zones"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_zone_order(self, zone_ids):\n        reordered_zones = []\n        current_zone_ids = [z['id'] for z in self.my_osid_object_form._my_map['zones']]\n        if set(zone_ids) != set(current_zone_ids):\n            raise IllegalState('zone_ids do not match existing zones')\n\n        for zone_id in zone_ids:\n            for current_zone in self.my_osid_object_form._my_map['zones']:\n                if zone_id == current_zone['id']:\n                    reordered_zones.append(current_zone)\n                    break\n\n        self.my_osid_object_form._my_map['zones'] = reordered_zones", "response": "reorder zones per the passed in list\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndefines __unicode__ and __str__ methods on the given class in Python 2. The given class must define a __str__ method returning a unicode string, otherwise a TypeError is raised. Under Python 3, the class is returned as is.", "response": "def string_class(cls):\n    \"\"\"Define __unicode__ and __str__ methods on the given class in Python 2.\n\n    The given class must define a __str__ method returning a unicode string,\n    otherwise a TypeError is raised.\n    Under Python 3, the class is returned as is.\n    \"\"\"\n    if not PY3:\n        if '__str__' not in cls.__dict__:\n            raise TypeError('the given class has no __str__ method')\n        cls.__unicode__, cls.__string__ = (\n            cls.__str__, lambda self: self.__unicode__().encode('utf-8'))\n    return cls"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_verb(cls, verb):\n        pattern = r'^(?P<meta>[A-Z]+)(?P<version>\\d+)(?P<action>[A-Z]+)(?P<arg1>\\d+)?(\\/(?P<arg2>\\d+))?$'\n        try:\n            verb = verb.decode()\n        except AttributeError:\n            pass\n        match = re.match(pattern, verb)\n        if not match:\n            raise SpoolverbError('Invalid spoolverb: {}'.format(verb))\n\n        data = match.groupdict()\n        meta = data['meta']\n        version = data['version']\n        action = data['action']\n        if action == 'EDITIONS':\n            num_editions = data['arg1']\n            return cls(meta=meta, version=version, action=action, num_editions=int(num_editions))\n        elif action == 'LOAN':\n            # TODO Review. Workaround for piece loans\n            try:\n                edition_num = int(data['arg1'])\n            except TypeError:\n                edition_num = 0\n            loan_start = data['arg2'][:6]\n            loan_end = data['arg2'][6:]\n            return cls(meta=meta, version=version, action=action, edition_num=int(edition_num),\n                       loan_start=loan_start, loan_end=loan_end)\n        elif action in ['FUEL', 'PIECE', 'CONSIGNEDREGISTRATION']:\n            # no edition number for these verbs\n            return cls(meta=meta, version=version, action=action)\n        else:\n            edition_num = data['arg1']\n            return cls(meta=meta, version=version, action=action, edition_num=int(edition_num))", "response": "Constructs a new instance of the class Spoolverb from the string representation of the given verb."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string representation of the LOAN spoolverb.", "response": "def loan(self):\n        \"\"\"\n        str: representation of the ``LOAN`` spoolverb. E.g.:\n            ``'ASCRIBESPOOL01LOAN1/150526150528'``.\n        \"\"\"\n        return '{}{}LOAN{}/{}{}'.format(self.meta, self.version, self.edition_number,\n                                        self.loan_start, self.loan_end)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_objective_lookup_session(self):\n        if not self.supports_objective_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise  # OperationFailed()\n        try:\n            session = sessions.ObjectiveLookupSession(runtime=self._runtime)\n        except AttributeError:\n            raise  # OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective lookup\n        service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_objective_lookup_session_for_objective_bank(self, objective_bank_id=None):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveLookupSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective lookup service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the OsidSession associated with the objective query service for the given objective bank.", "response": "def get_objective_query_session_for_objective_bank(self, objective_bank_id=None):\n        \"\"\"Gets the OsidSession associated with the objective query service\n        for the given objective bank.\n\n        arg:    objectiveBankId (osid.id.Id): the Id of the objective\n                bank\n        return: (osid.learning.ObjectiveQuerySession) - an\n                ObjectiveQuerySession\n        raise:  NotFound - objectiveBankId not found\n        raise:  NullArgument - objectiveBankId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_objective_query() or\n                supports_visible_federation() is false\n        compliance: optional - This method must be implemented if\n                    supports_objective_query() and\n                    supports_visible_federation() are true.\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveQuerySession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_objective_search_session(self):\n        if not self.supports_objective_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveSearchSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective search\n        service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the OsidSession associated with the objective search session for the given objective bank.", "response": "def get_objective_search_session_for_objective_bank(self, objective_bank_id=None):\n        \"\"\"Gets the OsidSession associated with the objective search\n        service for the given objective bank.\n\n        arg:    objectiveBankId (osid.id.Id): the Id of the objective\n                bank\n        return: (osid.learning.ObjectiveSearchSession) - an\n                ObjectiveSearchSession\n        raise:  NotFound - objectiveBankId not found\n        raise:  NullArgument - objectiveBankId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_objective_search() or\n                supports_visible_federation() is false\n        compliance: optional - This method must be implemented if\n                    supports_objective_search() and\n                    supports_visible_federation() are true.\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveSearchSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_admin_session(self):\n        if not self.supports_objective_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveAdminSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective\n        administration service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_objective_admin_session_for_objective_bank(self, objective_bank_id=None):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveAdminSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective admin service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_objective_hierarchy_session_for_objective_bank(self, objective_bank_id=None, *args, **kwargs):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_hierarchy():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveHierarchySession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective hierarchy service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the session for designing objective hierarchies.", "response": "def get_objective_hierarchy_design_session(self):\n        \"\"\"Gets the session for designing objective hierarchies.\n\n        return: (osid.learning.ObjectiveHierarchyDesignSession) - an\n                ObjectiveHierarchyDesignSession\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_objective_hierarchy_design() is\n                false\n        compliance: optional - This method must be implemented if\n                    supports_objective_hierarchy_design() is true.\n\n        \"\"\"\n        if not self.supports_objective_hierarchy_design():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveHierarchyDesignSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objective_hierarchy_design_session_for_objective_bank(self, objective_bank_id=None, *args, **kwargs):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_hierarchy_design():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveHierarchyDesignSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective hierarchy design service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_objective_requisite_session(self):\n        if not self.supports_objective_requisite():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveRequisiteSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the session for examining objective requisites."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_objective_requisite_session_for_objective_bank(self, objective_bank_id=None, *args, **kwargs):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_requisite():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveRequisiteSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective sequencing\n        service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objective_requisite_assignment_session(self, *args, **kwargs):\n        if not self.supports_objective_requisite_assignment():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveRequisiteAssignmentSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the session for managing objective requisites."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_activity_search_session(self):\n        if not self.supports_activity_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ActivitySearchSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the activity search\n        service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the activity search service for the given objective bank.", "response": "def get_activity_search_session_for_objective_bank(self, objective_bank_id=None):\n        \"\"\"Gets the OsidSession associated with the activity search service\n        for the given objective bank.\n\n        arg:    objectiveBankId (osid.id.Id): the Id of the objective\n                bank\n        return: (osid.learning.ActivitySearchSession) - an\n                ActivitySearchSession\n        raise:  NotFound - objectiveBankId not found\n        raise:  NullArgument - objectiveBankId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_activity_search() or\n                supports_visible_federation() is false\n        compliance: optional - This method must be implemented if\n                    supports_activity_search() and\n                    supports_visible_federation() are true.\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_activity_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ActivitySearchSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the OsidSession associated with the activity administration service.", "response": "def get_activity_admin_session(self):\n        \"\"\"Gets the OsidSession associated with the activity administration\n        service.\n\n        return: (osid.learning.ActivityAdminSession) - a\n                ActivityAdminSession\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_activity_admin() is false\n        compliance: optional - This method must be implemented if\n                    supports_activity_admin() is true.\n\n        \"\"\"\n        if not self.supports_activity_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ActivityAdminSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the activity admin service for the given objective bank.", "response": "def get_activity_admin_session_for_objective_bank(self, objective_bank_id=None):\n        \"\"\"Gets the OsidSession associated with the activity admin service\n        for the given objective bank.\n\n        arg:    objectiveBankId (osid.id.Id): the Id of the objective\n                bank\n        return: (osid.learning.ActivityAdminSession) - an\n                ActivityAdminSession\n        raise:  NotFound - objectiveBankId not found\n        raise:  NullArgument - objectiveBankId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_activity_admin() or\n                supports_visible_federation() is false\n        compliance: optional - This method must be implemented if\n                    supports_activity_admin() and\n                    supports_visible_federation() are true.\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_activity_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ActivityAdminSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_proficiency_lookup_session(self):\n        if not self.supports_proficiency_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ProficiencyLookupSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the proficiency lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OsidSession associated with the proficiency lookup service for the given objective bank.", "response": "def get_proficiency_lookup_session_for_objective_bank(self, objective_bank_id=None):\n        \"\"\"Gets the OsidSession associated with the proficiency lookup\n        service for the given objective bank.\n\n        arg:    objectiveBankId (osid.id.Id): the Id of the obective\n                bank\n        return: (osid.learning.ProficiencyLookupSession) - a\n                ProficiencyLookupSession\n        raise:  NotFound - no ObjectiveBank found by the given Id\n        raise:  NullArgument - objectiveBankId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_proficiency_lookup() or\n                supports_visible_federation() is false\n        compliance: optional - This method must be implemented if\n                    supports_proficiency_lookup() and\n                    supports_visible_federation() are true\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_proficiency_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ProficiencyLookupSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the OsidSession associated with the proficiency administration service for the given objective bank.", "response": "def get_proficiency_admin_session_for_objective_bank(self, objective_bank_id=None):\n        \"\"\"Gets the OsidSession associated with the proficiency\n        administration service for the given objective bank.\n\n        arg:    objectiveBankId (osid.id.Id): the Id of the\n                ObjectiveBank\n        return: (osid.learning.ProficiencyAdminSession) - a\n                ProficiencyAdminSession\n        raise:  NotFound - no objective bank found by the given Id\n        raise:  NullArgument - objectiveBankId is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_proficiency_admin() or\n                supports_visible_federation() is false\n        compliance: optional - This method must be implemented if\n                    supports_proficiency_admin() and\n                    supports_visible_federation() are true\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_proficiency_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ProficiencyAdminSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the learning path service.", "response": "def get_learning_path_session(self):\n        \"\"\"Gets the OsidSession associated with the learning path service.\n\n        return: (osid.learning.LearningPathSession) - a\n                LearningPathSession\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_learning_path() is false\n        compliance: optional - This method must be implemented if\n                    supports_learning_path() is true.\n\n        \"\"\"\n        if not self.supports_learning_path():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.LearningPathSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_learning_path_session_for_objective_bank(self, objective_bank_id=None):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_learning_path():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.LearningPathSession(objective_bank_id, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the learning path service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objective_bank_lookup_session(self, *args, **kwargs):\n        if not self.supports_objective_bank_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveBankLookupSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective bank lookup\n        service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_objective_bank_hierarchy_design_session(self):\n        if not self.supports_objective_bank_hierarchy_design():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        try:\n            session = sessions.ObjectiveBankHierarchyDesignSession(runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the session designing objective bank hierarchies."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_objective_lookup_session(self, proxy):\n        if not self.supports_objective_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveLookupSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise  # OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the objective lookup service for the given objective bank.", "response": "def get_objective_lookup_session_for_objective_bank(self, objective_bank_id, proxy, *args, **kwargs):\n        \"\"\"Gets the ``OsidSession`` associated with the objective lookup service for the given objective bank.\n\n        :param objective_bank_id: the ``Id`` of the objective bank\n        :type objective_bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: ``an _objective_lookup_session``\n        :rtype: ``osid.learning.ObjectiveLookupSession``\n        :raise: ``NotFound`` -- ``objective_bank_id`` not found\n        :raise: ``NullArgument`` -- ``objective_bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_objective_lookup()`` or ``supports_visible_federation()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveLookupSession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the objective query service.", "response": "def get_objective_query_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the objective query service.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ObjectiveQuerySession``\n        :rtype: ``osid.learning.ObjectiveQuerySession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_objective_query()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveQuerySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the OsidSession associated with the objective administration service.", "response": "def get_objective_admin_session(self, proxy, *args, **kwargs):\n        \"\"\"Gets the ``OsidSession`` associated with the objective administration service.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ObjectiveAdminSession``\n        :rtype: ``osid.learning.ObjectiveAdminSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_objective_admin()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveAdminSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_objective_admin_session_for_objective_bank(self, objective_bank_id, proxy, *args, **kwargs):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveAdminSession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective admin service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_objective_hierarchy_session(self, proxy):\n        if not self.supports_objective_hierarchy():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveHierarchySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the session for traversing objective hierarchies."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_objective_sequencing_session(self, proxy):\n        if not self.supports_objective_sequencing():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveSequencingSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the session for sequencing objectives."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_objective_sequencing_session_for_objective_bank(self, objective_bank_id, proxy):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_sequencing():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveSequencingSession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the objective sequencing service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the objective to objective bank mappings.", "response": "def get_objective_objective_bank_session(self, proxy):\n        \"\"\"Gets the session for retrieving objective to objective bank mappings.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ObjectiveObjectiveBankSession``\n        :rtype: ``osid.learning.ObjectiveObjectiveBankSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_objective_objective_bank()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_objective_bank()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_objective_bank():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveObjectiveBankSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the session for assigning objective to objective bank mappings.", "response": "def get_objective_objective_bank_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning objective to objective bank mappings.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ObjectiveObjectiveBankAssignmentSession``\n        :rtype: ``osid.learning.ObjectiveObjectiveBankAssignmentSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_objective_objective_bank_assignment()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_objective_bank_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_objective_bank_assignment():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveObjectiveBankAssignmentSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the OsidSession associated with the objective sequencing service for the given objective bank.", "response": "def get_objective_requisite_assignment_session_for_objective_bank(self, objective_bank_id, proxy, *args, **kwargs):\n        \"\"\"Gets the ``OsidSession`` associated with the objective sequencing service for the given objective bank.\n\n        :param objective_bank_id: the ``Id`` of the objective bank\n        :type objective_bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ObjectiveRequisiteAssignmentSession``\n        :rtype: ``osid.learning.ObjectiveRequisiteAssignmentSession``\n        :raise: ``NotFound`` -- ``objective_bank_id`` not found\n        :raise: ``NullArgument`` -- ``objective_bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_objective_requisite_assignment()`` or ``supports_visible_federation()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_requisite_assignment()`` and ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_objective_requisite_assignment():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveRequisiteAssignmentSession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_activity_lookup_session(self, proxy, *args, **kwargs):\n        if not self.supports_activity_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ActivityLookupSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the activity lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the activity lookup service for the given objective bank.", "response": "def get_activity_lookup_session_for_objective_bank(self, objective_bank_id, proxy, *args, **kwargs):\n        \"\"\"Gets the ``OsidSession`` associated with the activity lookup service for the given objective bank.\n\n        :param objective_bank_id: the ``Id`` of the objective bank\n        :type objective_bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ActivityLookupSession``\n        :rtype: ``osid.learning.ActivityLookupSession``\n        :raise: ``NotFound`` -- ``objective_bank_id`` not found\n        :raise: ``NullArgument`` -- ``objective_bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_activity_lookup()`` or ``supports_visible_federation()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_activity_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_activity_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ActivityLookupSession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_activity_query_session(self, proxy):\n        if not self.supports_activity_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ActivityQuerySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the activity query service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_activity_query_session_for_objective_bank(self, objective_bank_id, proxy):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_activity_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ActivityQuerySession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the activity query service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_activity_admin_session(self, proxy, *args, **kwargs):\n        if not self.supports_activity_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ActivityAdminSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the activity administration service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_activity_admin_session_for_objective_bank(self, objective_bank_id, proxy, *args, **kwargs):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_activity_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ActivityAdminSession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the activity admin service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the session for retrieving activity to objective bank mappings.", "response": "def get_activity_objective_bank_session(self, proxy):\n        \"\"\"Gets the session for retrieving activity to objective bank mappings.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ActivityObjectiveBankSession``\n        :rtype: ``osid.learning.ActivityObjectiveBankSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_activity_objective_bank()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_activity_objective_bank()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_activity_objective_bank():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ActivityObjectiveBankSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the session for assigning activity to objective bank mappings.", "response": "def get_activity_objective_bank_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning activity to objective bank mappings.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ActivityObjectiveBankAssignmentSession``\n        :rtype: ``osid.learning.ActivityObjectiveBankAssignmentSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_activity_objective_bank_assignment()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_activity_objective_bank_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_activity_objective_bank_assignment():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ActivityObjectiveBankAssignmentSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the OsidSession associated with the proficiency query service.", "response": "def get_proficiency_query_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the proficiency query service.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: a ``ProficiencyQuerySession``\n        :rtype: ``osid.learning.ProficiencyQuerySession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_proficiency_query()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_proficiency_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_proficiency_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ProficiencyQuerySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_proficiency_query_session_for_objective_bank(self, objective_bank_id, proxy):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_proficiency_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ProficiencyQuerySession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the proficiency query service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the proficiency search service.", "response": "def get_proficiency_search_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the proficiency search service.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: a ``ProficiencySearchSession``\n        :rtype: ``osid.learning.ProficiencySearchSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_proficiency_search()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_proficiency_search()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_proficiency_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ProficiencySearchSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_proficiency_search_session_for_objective_bank(self, objective_bank_id, proxy):\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_proficiency_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ProficiencySearchSession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the proficiency search service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_proficiency_admin_session(self, proxy):\n        if not self.supports_proficiency_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ProficiencyAdminSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the proficiency administration service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_proficiency_objective_bank_session(self, proxy):\n        if not self.supports_proficiency_objective_bank():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ProficiencyObjectiveBankSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession to lookup proficiency / objective bank mappings."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the OsidSession associated with assigning proficiencies to objective banks.", "response": "def get_proficiency_objective_bank_assignment_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with assigning proficiencies to objective banks.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: a ``ProficiencyObjectiveBankAssignmentSession``\n        :rtype: ``osid.learning.ProficiencyObjectiveBankAssignmentSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_proficiency_objective_bank_assignment()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_proficiency_objective_bank_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_proficiency_objective_bank_assignment():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ProficiencyObjectiveBankAssignmentSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_my_learning_path_session(self, proxy):\n        if not self.supports_my_learning_path():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.MyLearningPathSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the my learning path service."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the OsidSession associated with the my learning path service for the given objective bank.", "response": "def get_my_learning_path_session_for_objective_bank(self, objective_bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the my learning path service for the given objective bank.\n\n        :param objective_bank_id: the ``Id`` of the ``ObjectiveBank``\n        :type objective_bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: a ``MyLearningPathSession``\n        :rtype: ``osid.learning.MyLearningPathSession``\n        :raise: ``NotFound`` -- no objective bank found by the given ``Id``\n        :raise: ``NullArgument`` -- ``objective_bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_my_learning_path()`` or ``supports_visible_federation()`` is ``false``\n\n        *compliance: optional -- This method must be implemented if ``supports_my_learning_path()`` and ``supports_visible_federation()`` are ``true``*\n\n        \"\"\"\n        if not objective_bank_id:\n            raise NullArgument\n        if not self.supports_my_learning_path():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.MyLearningPathSession(objective_bank_id=objective_bank_id, proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the objective bank query service.", "response": "def get_objective_bank_query_session(self, proxy):\n        \"\"\"Gets the OsidSession associated with the objective bank query service.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ObjectiveBankQuerySession``\n        :rtype: ``osid.learning.ObjectiveBankQuerySession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_objective_bank_query() is false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_bank_query()`` is true.*\n\n        \"\"\"\n        if not self.supports_objective_bank_query():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveBankQuerySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the OsidSession associated with the objective bank search service.", "response": "def get_objective_bank_search_session(self, proxy):\n        \"\"\"Gets the OsidSession associated with the objective bank search service.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ObjectiveBankSearchSession``\n        :rtype: ``osid.learning.ObjectiveBankSearchSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_objective_bank_search() is false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_bank_search()`` is true.*\n\n        \"\"\"\n        if not self.supports_objective_bank_search():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveBankSearchSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the OsidSession associated with the objective bank administration service.", "response": "def get_objective_bank_admin_session(self, proxy, *args, **kwargs):\n        \"\"\"Gets the OsidSession associated with the objective bank administration service.\n\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n        :return: an ``ObjectiveBankAdminSession``\n        :rtype: ``osid.learning.ObjectiveBankAdminSession``\n        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_objective_bank_admin() is false``\n\n        *compliance: optional -- This method must be implemented if ``supports_objective_bank_admin()`` is true.*\n\n        \"\"\"\n        if not self.supports_objective_bank_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveBankAdminSession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_objective_bank_hierarchy_session(self, proxy):\n        if not self.supports_objective_bank_hierarchy():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise OperationFailed()\n        proxy = self._convert_proxy(proxy)\n        try:\n            session = sessions.ObjectiveBankHierarchySession(proxy=proxy, runtime=self._runtime)\n        except AttributeError:\n            raise OperationFailed()\n        return session", "response": "Gets the session traversing objective bank hierarchies."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_piece(self, from_address, to_address, hash, password, min_confirmations=6, sync=False, ownership=True):\n        file_hash, file_hash_metadata = hash\n        path, from_address = from_address\n        verb = Spoolverb()\n        unsigned_tx = self.simple_spool_transaction(from_address,\n                                                    [file_hash, file_hash_metadata, to_address],\n                                                    op_return=verb.piece,\n                                                    min_confirmations=min_confirmations)\n\n        signed_tx = self._t.sign_transaction(unsigned_tx, password)\n        txid = self._t.push(signed_tx)\n        return txid", "response": "Register a piece in the wallet."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef refill_main_wallet(self, from_address, to_address, nfees, ntokens, password, min_confirmations=6, sync=False):\n        path, from_address = from_address\n        unsigned_tx = self._t.simple_transaction(from_address,\n                                                 [(to_address, self.fee)] * nfees + [(to_address, self.token)] * ntokens,\n                                                 min_confirmations=min_confirmations)\n\n        signed_tx = self._t.sign_transaction(unsigned_tx, password)\n        txid = self._t.push(signed_tx)\n        return txid", "response": "Refill the main wallet with the given token and fees."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrefills the wallets with the necessary fuel to perform a spool transaction.", "response": "def refill(self, from_address, to_address, nfees, ntokens, password, min_confirmations=6, sync=False):\n        \"\"\"\n        Refill wallets with the necessary fuel to perform spool transactions\n\n        Args:\n            from_address (Tuple[str]): Federation wallet address. Fuels the wallets with tokens and fees. All transactions to wallets\n                holding a particular piece should come from the Federation wallet\n            to_address (str): Wallet address that needs to perform a spool transaction\n            nfees (int): Number of fees to transfer. Each fee is 10000 satoshi. Used to pay for the transactions\n            ntokens (int): Number of tokens to transfer. Each token is 600 satoshi. Used to register hashes in the blockchain\n            password (str): Password for the Federation wallet. Used to sign the transaction\n            min_confirmations (int): Number of confirmations when chosing the inputs of the transaction. Defaults to 6\n            sync (bool): Perform the transaction in synchronous mode, the call to the function will block until there is at\n                least on confirmation on the blockchain. Defaults to False\n\n        Returns:\n            str: transaction id\n\n        \"\"\"\n        path, from_address = from_address\n        verb = Spoolverb()\n        # nfees + 1: nfees to refill plus one fee for the refill transaction itself\n        inputs = self.select_inputs(from_address, nfees + 1, ntokens, min_confirmations=min_confirmations)\n        outputs = [{'address': to_address, 'value': self.token}] * ntokens\n        outputs += [{'address': to_address, 'value': self.fee}] * nfees\n        outputs += [{'script': self._t._op_return_hex(verb.fuel), 'value': 0}]\n        unsigned_tx = self._t.build_transaction(inputs, outputs)\n        signed_tx = self._t.sign_transaction(unsigned_tx, password, path=path)\n        txid = self._t.push(signed_tx)\n        return txid"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef simple_spool_transaction(self, from_address, to, op_return, min_confirmations=6):\n        # list of addresses to send\n        ntokens = len(to)\n        nfees = old_div(self._t.estimate_fee(ntokens, 2), self.fee)\n        inputs = self.select_inputs(from_address, nfees, ntokens, min_confirmations=min_confirmations)\n        # outputs\n        outputs = [{'address': to_address, 'value': self.token} for to_address in to]\n        outputs += [{'script': self._t._op_return_hex(op_return), 'value': 0}]\n        # build transaction\n        unsigned_tx = self._t.build_transaction(inputs, outputs)\n        return unsigned_tx", "response": "This function creates a simple spool transaction."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef select_inputs(self, address, nfees, ntokens, min_confirmations=6):\n        unspents = self._t.get(address, min_confirmations=min_confirmations)['unspents']\n        unspents = [u for u in unspents if u not in self._spents.queue]\n        if len(unspents) == 0:\n            raise Exception(\"No spendable outputs found\")\n\n        fees = [u for u in unspents if u['amount'] == self.fee][:nfees]\n        tokens = [u for u in unspents if u['amount'] == self.token][:ntokens]\n        if len(fees) != nfees or len(tokens) != ntokens:\n            raise SpoolFundsError(\"Not enough outputs to spend. Refill your wallet\")\n        if self._spents.qsize() > self.SPENTS_QUEUE_MAXSIZE - (nfees + ntokens):\n            [self._spents.get() for i in range(self._spents.qsize() + nfees + ntokens - self.SPENTS_QUEUE_MAXSIZE)]\n        [self._spents.put(fee) for fee in fees]\n        [self._spents.put(token) for token in tokens]\n        return fees + tokens", "response": "Selects the inputs for the spool transaction."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_edxml(self):\n        if self.has_raw_edxml():\n            has_python = False\n            my_files = self.my_osid_object.object_map['fileIds']\n            raw_text = self.get_text('edxml').text\n            soup = BeautifulSoup(raw_text, 'xml')\n            # replace all file listings with an appropriate path...\n            attrs = {\n                'draggable': 'icon',\n                'drag_and_drop_input': 'img',\n                'files': 'included_files',\n                'img': 'src'\n            }\n            local_regex = re.compile('[^http]')\n            for key, attr in attrs.items():\n                search = {attr: local_regex}\n                tags = soup.find_all(**search)\n                for item in tags:\n                    if key == 'files' or item.name == key:\n                        file_label = self._clean(item[attr])\n                        if file_label in my_files:\n                            content_type = Id(my_files[file_label]['assetContentTypeId'])\n                            item[attr] = '/static/' + file_label + '.' + \\\n                                         content_type.get_identifier()\n\n            # replace any python script with the item's get_text('python_script')\n            # text...will fix weird whitespace issues\n            if len(soup.find_all('script')) >= 1:\n                scripts = soup.find_all('script')\n                for script in scripts:\n                    if 'python' in script['type']:\n                        has_python = True\n                        # contents = script.contents[0]\n                        # contents.replaceWith(str(NavigableString(self.python)))\n                        break\n\n            try:\n                if has_python:\n                    return str(soup.find('problem'))\n                else:\n                    return soup.find('problem').prettify()\n            except Exception:\n                # if the edxml is not valid XML, it will not parse properly in soup\n                # return just the raw edxml\n                return self.get_text('edxml').text\n        else:\n            # have to construct the edxml from various components\n            obj_map = self.my_osid_object.object_map\n            question = obj_map['question']\n            answers = obj_map['answers']\n            if 'edx-multi-choice-problem-type' in obj_map['genusTypeId']:\n                # get answer Ids to compare them to the choices\n                answer_ids = []\n                for answer in answers:\n                    answer_ids += answer['choiceIds']\n                # add the body text element (item.question.text)\n                soup = BeautifulSoup('<problem></problem>', 'xml')\n                p = soup.new_tag('p')\n                p.string = self.get_text('questionString').text\n                problem = soup.find('problem')\n                problem.append(p)\n                # add the metadata\n                problem['display_name'] = question['displayName']['text']\n                problem['showanswer'] = self.showanswer\n                if 'rerandomize' in obj_map:\n                    problem['rerandomize'] = obj_map['rerandomize']\n                elif 'rerandomize' in question:\n                    problem['rerandomize'] = question['rerandomize']\n                problem['max_attempts'] = self.attempts\n\n                # add the choices\n                multichoice = soup.new_tag('multiplechoiceresponse')\n                problem.append(multichoice)\n\n                choicegroup = soup.new_tag('choicegroup')\n                choicegroup['direction'] = 'vertical'\n                multichoice.append(choicegroup)\n\n                choices = question['choices']\n                for choice in choices:\n                    new_choice = soup.new_tag('choice')\n\n                    # mark the correct choice(s)\n                    if choice['id'] in answer_ids:\n                        new_choice['correct'] = 'true'\n                    else:\n                        new_choice['correct'] = 'false'\n\n                    new_choice['name'] = choice['name']\n                    choice_text = soup.new_tag('text')\n                    choice_text.string = choice['text']\n                    new_choice.append(choice_text)\n                    choicegroup.append(new_choice)\n                return problem.prettify()\n        raise IllegalState('records.assessment.edx.item_records.get_edxml()')", "response": "returns the raw edxml"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the xproblem of the user", "response": "def get_xproblem(self, parameters=None):\n        \"\"\"stub\"\"\"\n        if not self.get_text('python_script'):\n            return self.get_text('edxml').text\n        if not parameters:\n            parameters = self.get_parameters()\n        return self._get_parameterized_text(parameters)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_solution(self, parameters=None):\n        if not self.has_solution():\n            raise IllegalState()\n        try:\n            if not self.get_text('python_script'):\n                return self.get_text('solution').text\n            if not parameters:\n                parameters = self.get_parameters()\n            return self._get_parameterized_text(parameters)\n        except Exception:\n            return self.get_text('solution').text", "response": "get_solution - Gets the solution text"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_parameterized_text(self, parameters):\n        text = self.get_text('edxml').text\n        done = False\n        while not done:\n            result = re.search(r'\\$\\w+', text)\n            if result:\n                replacement = str(parameters[result.group()[1:]])\n                text = text.replace(result.group(), replacement)\n            else:\n                done = True\n        return text", "response": "get the text of the current object with the specified parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_map(self):\n        ItemTextsFormRecord._init_map(self)\n        ItemFilesFormRecord._init_map(self)\n        edXBaseFormRecord._init_map(self)\n        IRTItemFormRecord._init_map(self)\n        TimeValueFormRecord._init_map(self)\n        ProvenanceFormRecord._init_map(self)\n        super(edXItemFormRecord, self)._init_map()", "response": "Initialize the internal map of items and items."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_metadata(self):\n        ItemTextsFormRecord._init_metadata(self)\n        ItemFilesFormRecord._init_metadata(self)\n        edXBaseFormRecord._init_metadata(self)\n        IRTItemFormRecord._init_metadata(self)\n        TimeValueFormRecord._init_metadata(self)\n        ProvenanceFormRecord._init_metadata(self)\n        super(edXItemFormRecord, self)._init_metadata()", "response": "Initialize the metadata for this item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_admin(controller, client, actor):\n    config = controller.config\n    if not config.has_section(\"admins\"):\n        logging.debug(\"Ignoring is_admin check - no [admins] config found.\")\n        return False\n    for key,val in config.items(\"admins\"):\n        if actor == User(key):\n            logging.debug(\"is_admin: %r matches admin %r\", actor, key)\n            return True\n        if actor.nick.lower() == key.lower() and actor.host.lower() == val.lower():\n            logging.debug(\"is_admin: %r matches admin %r=%r\", actor, key, val)\n            return True\n    logging.debug(\"is_admin: %r is not an admin.\", actor)\n    return False", "response": "Returns True if the actor is an admin."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the item list resulting from the search.", "response": "def get_items(self):\n        \"\"\"Gets the item list resulting from the search.\n\n        return: (osid.assessment.ItemList) - the item list\n        raise:  IllegalState - the item list has already been retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.ItemList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the assessment list resulting from the search.", "response": "def get_assessments(self):\n        \"\"\"Gets the assessment list resulting from the search.\n\n        return: (osid.assessment.AssessmentList) - the assessment list\n        raise:  IllegalState - the assessment list has already been\n                retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.AssessmentList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessments_offered(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.AssessmentOfferedList(self._results, runtime=self._runtime)", "response": "Gets the assessment offered list resulting from the search."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assessments_taken(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.AssessmentTakenList(self._results, runtime=self._runtime)", "response": "Gets the assessment taken list resulting from the search."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_banks(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.BankList(self._results, runtime=self._runtime)", "response": "Gets the bank list resulting from a search."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef roots(self):\n      return [x for x in self._nodes.values() if x.id not in self._c2p]", "response": "get the nodes with no children"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn back a graph containing just the root and children", "response": "def get_root_graph(self,root):\n      \"\"\"Return back a graph containing just the root and children\"\"\"\n      children = self.get_children(root)\n      g = Graph()\n      nodes = [root]+children\n      for node in nodes: g.add_node(node)\n      node_ids = [x.id for x in nodes]\n      edges = [x for x in self._edges.values() if x.node1.id in node_ids and x.node2.id in node_ids]\n      for e in edges: g.add_edge(e)\n      return g"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nworking on this graph and remove cycles with nodes containing concatonated lists of payloads", "response": "def merge_cycles(self):\n      \"\"\"Work on this graph and remove cycles, with nodes containing concatonated lists of payloads\"\"\"\n      while True:\n         ### remove any self edges\n         own_edges = self.get_self_edges()\n         if len(own_edges) > 0:\n            for e in own_edges: self.remove_edge(e)\n         c = self.find_cycle()\n         if not c: return\n         keep = c[0]\n         remove_list = c[1:]\n         for n in remove_list: self.move_edges(n,keep)\n         for n in remove_list: keep.payload_list += n.payload_list\n         for n in remove_list: self.remove_node(n)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_node(self,node):\n      if node.id not in self._nodes: return      \n      \"\"\"find edges to remove\"\"\"\n      edges = set()\n      for e in self._edges.values():\n         if e.node1.id == node.id: edges.add(e.id)\n         if e.node2.id == node.id: edges.add(e.id)\n      edges = [self._edges[x] for x in list(edges)]\n      for e in edges: self.remove_edge(e)\n      del self._nodes[node.id]", "response": "Removes the node from the graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the edge from the graph.", "response": "def remove_edge(self,edge):\n      \"\"\"Remove the edge\"\"\"\n      if edge.id not in self._edges: return # its not in the graph\n      del self._p2c[edge.node1.id][edge.node2.id][edge.id]\n      if len(self._p2c[edge.node1.id][edge.node2.id].keys()) == 0:\n         del self._p2c[edge.node1.id][edge.node2.id]\n      if len(self._p2c[edge.node1.id].keys()) == 0:\n         del self._p2c[edge.node1.id]\n\n      del self._c2p[edge.node2.id][edge.node1.id][edge.id]\n      if len(self._c2p[edge.node2.id][edge.node1.id].keys()) == 0:\n         del self._c2p[edge.node2.id][edge.node1.id]\n      if len(self._c2p[edge.node2.id].keys()) == 0:\n         del self._c2p[edge.node2.id]\n\n      del self._edges[edge.id]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmove edges from node 1 to node 2", "response": "def move_edges(self,n1,n2):\n      \"\"\"Move edges from node 1 to node 2\n \n         Not self edges though\n\n         Overwrites edges\n      \"\"\"\n      #Traverse edges to find incoming with n1\n      incoming = []\n      for e in self._edges.values():\n         if e.node2.id == n1.id: incoming.append(e)\n      #Traverse edges to find outgoing from n1\n      outgoing = []\n      for e in self._edges.values():\n         if e.node1.id == n1.id: outgoing.append(e)\n      #Make new edges to the new target\n      for e in incoming:\n         if e.node1.id == n2.id: continue # skip self\n         newedge = Edge(e.node1,n2,payload_list=n2.payload_list+n1.payload_list)\n         self.add_edge(newedge)\n      for e in outgoing:\n         if e.node2.id == n2.id: continue # skip self\n         newedge = Edge(n2,e.node2,payload_list=n2.payload_list+n1.payload_list)\n         self.add_edge(newedge)\n      #now remove the edges that got transfered\n      for e in incoming: self.remove_edge(e)\n      for e in outgoing: self.remove_edge(e)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass through to provider AuthorizationSearchSession. get_authorizations_by_search", "response": "def get_authorizations_by_search(self, authorization_query, authorization_search):\n        \"\"\"Pass through to provider AuthorizationSearchSession.get_authorizations_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_authorizations_by_search(authorization_query, authorization_search)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npass through to provider FunctionSearchSession. get_functions_by_search", "response": "def get_functions_by_search(self, function_query, function_search):\n        \"\"\"Pass through to provider FunctionSearchSession.get_functions_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_functions_by_search(function_query, function_search)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_qualifiers_by_search(self, qualifier_query, qualifier_search):\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_qualifiers_by_search(qualifier_query, qualifier_search)", "response": "Pass through to provider QualifierSearchSession. get_qualifiers_by_search"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint stack trace for current exceptions chain.", "response": "def print_trace(self):\n        \"\"\"\n        Prints stack trace for current exceptions chain.\n        \"\"\"\n        traceback.print_exc()\n        for tb in self.tracebacks:\n            print tb,\n        print ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef c(source, libraries=[]):\n    path = _cc_build_shared_lib(source, '.c', libraries)\n    return ctypes.cdll.LoadLibrary(path)", "response": "r Loads the C library."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cxx(source, libraries=[]):\n    path = _cc_build_shared_lib(source, '.cc', libraries)\n    return ctypes.cdll.LoadLibrary(path)", "response": "r Returns a C library."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _exec(object, globals, locals):\n    if sys.version_info < (3,):\n        exec('exec object in globals, locals')\n    else:\n        exec(object, globals, locals)", "response": "r Executes the given object in the given globals and locals."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_type_lookup_session(self):\n        if not self.supports_type_lookup():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise  # OperationFailed()\n        try:\n            session = sessions.TypeLookupSession(runtime=self._runtime)\n        except AttributeError:\n            raise  # OperationFailed()\n        return session", "response": "Gets the OsidSession associated with the type lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the type admin service.", "response": "def get_type_admin_session(self):\n        \"\"\"Gets the OsidSession associated with the type admin service.\n\n        return: (osid.type.TypeAdminSession) - a TypeAdminSession\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - supports_type_admin() is false\n        compliance: optional - This method must be implemented if\n                    supports_type_admin() is true.\n\n        \"\"\"\n        pass\n        if not self.supports_type_admin():\n            raise Unimplemented()\n        try:\n            from . import sessions\n        except ImportError:\n            raise  # OperationFailed()\n        try:\n            session = sessions.TypeAdminSession()\n        except AttributeError:\n            raise  # OperationFailed()\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _line_to_entry(self,line):\n    f = line.rstrip().split(\"\\t\")\n    \"\"\"\n    'chrom'\n    'chromStart'\n    'chromEnd'\n    'name'\n    'score'\n    'strand'\n    'thickStart'\n    'thickEnd'\n    'itemRgb'\n    'blockCount'\n    'blockSizes'\n    'blockStarts'\n    \"\"\"\n    return Bed12Fields(\n       f[0],\n       int(f[1]),\n       int(f[2]),\n       f[3],\n       int(f[4]),\n       f[5],\n       int(f[6]),\n       int(f[7]),\n       [int(x) for x in f[8].rstrip(',').split(',')],\n       int(f[9]),\n       [int(x) for x in f[10].rstrip(',').split(',')],\n       [int(x) for x in f[11].rstrip(',').split(',')])", "response": "parse the line into entries and keys"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _to_swagger(base=None, description=None, resource=None, options=None):\n    # type: (Dict[str, str], str, Resource, Dict[str, str]) -> Dict[str, str]\n    \"\"\"\n    Common to swagger definition.\n\n    :param base: The base dict.\n    :param description: An optional description.\n    :param resource: An optional resource.\n    :param options: Any additional options\n\n    \"\"\"\n    definition = dict_filter(base or {}, options or {})\n\n    if description:\n        definition['description'] = description.format(\n            name=getmeta(resource).name if resource else \"UNKNOWN\"\n        )\n\n    if resource:\n        definition['schema'] = {\n            '$ref': '#/definitions/{}'.format(getmeta(resource).resource_name)\n        }\n\n    return definition", "response": "Convert the base dict to a swagger dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting any object into a UrlPath.", "response": "def from_object(cls, obj):\n        # type: (Any) -> UrlPath\n        \"\"\"\n        Attempt to convert any object into a UrlPath.\n\n        Raise a value error if this is not possible.\n        \"\"\"\n        if isinstance(obj, UrlPath):\n            return obj\n        if isinstance(obj, _compat.string_types):\n            return UrlPath.parse(obj)\n        if isinstance(obj, PathParam):\n            return UrlPath(obj)\n        if isinstance(obj, (tuple, list)):\n            return UrlPath(*obj)\n        raise ValueError(\"Unable to convert object to UrlPath `%r`\" % obj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(cls, url_path):\n        # type: (str) -> UrlPath\n        \"\"\"\n        Parse a string into a URL path (simple eg does not support typing of URL parameters)\n        \"\"\"\n        if not url_path:\n            return cls()\n\n        nodes = []\n        for node in url_path.rstrip('/').split('/'):\n            # Identifies a PathNode\n            if '{' in node or '}' in node:\n                m = PATH_NODE_RE.match(node)\n                if not m:\n                    raise ValueError(\"Invalid path param: {}\".format(node))\n\n                # Parse out name and type\n                name, param_type, param_arg = m.groups()\n                try:\n                    type_ = Type[param_type]\n                except KeyError:\n                    if param_type is not None:\n                        raise ValueError(\"Unknown param type `{}` in: {}\".format(param_type, node))\n                    type_ = Type.Integer\n\n                nodes.append(PathParam(name, type_, param_arg))\n            else:\n                nodes.append(node)\n\n        return cls(*nodes)", "response": "Parses a string into a UrlPath object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if this path starts with the other path.", "response": "def startswith(self, other):\n        # type: (UrlPath) -> bool\n        \"\"\"\n        Return True if this path starts with the other path.\n        \"\"\"\n        try:\n            other = UrlPath.from_object(other)\n        except ValueError:\n            raise TypeError('startswith first arg must be UrlPath, str, PathParam, not {}'.format(type(other)))\n        else:\n            return self._nodes[:len(other._nodes)] == other._nodes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply_args(self, **kwargs):\n        # type: (**str) -> UrlPath\n        \"\"\"\n        Apply formatting to each path node.\n\n        This is used to apply a name to nodes (used to apply key names) eg:\n\n        >>> a = UrlPath(\"foo\", PathParam('{key_field}'), \"bar\")\n        >>> b = a.apply_args(id=\"item_id\")\n        >>> b.format()\n        'foo/{item_id}/bar'\n\n        \"\"\"\n        def apply_format(node):\n            if isinstance(node, PathParam):\n                return PathParam(node.name.format(**kwargs), node.type, node.type_args)\n            else:\n                return node\n        return UrlPath(*(apply_format(n) for n in self._nodes))", "response": "Returns a new url path that is applied to each path node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef odinweb_node_formatter(path_node):\n        # type: (PathParam) -> str\n        \"\"\"\n        Format a node to be consumable by the `UrlPath.parse`.\n        \"\"\"\n        args = [path_node.name]\n        if path_node.type:\n            args.append(path_node.type.name)\n        if path_node.type_args:\n            args.append(path_node.type_args)\n        return \"{{{}}}\".format(':'.join(args))", "response": "Formats a node to be consumable by the UrlPath. parse method."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format(self, node_formatter=None, separator='/'):\n        # type: (Optional[Callable[[PathParam], str]]) -> str\n        \"\"\"\n        Format a URL path.\n        \n        An optional `node_parser(PathNode)` can be supplied for converting a \n        `PathNode` into a string to support the current web framework.  \n        \n        \"\"\"\n        if self._nodes == ('',):\n            return separator\n        else:\n            node_formatter = node_formatter or self.odinweb_node_formatter\n            return separator.join(node_formatter(n) if isinstance(n, PathParam) else n for n in self._nodes)", "response": "Formats a URL path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef path(cls, name, type_=Type.String, description=None, default=None,\n             minimum=None, maximum=None, enum=None, **options):\n        \"\"\"\n        Define a path parameter\n        \"\"\"\n        if minimum is not None and maximum is not None and minimum > maximum:\n            raise ValueError(\"Minimum must be less than or equal to the maximum.\")\n        return cls(name, In.Path, type_, None, description,\n                   default=default, minimum=minimum, maximum=maximum,\n                   enum=enum, required=True, **options)", "response": "Define a path parameter"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef query(cls, name, type_=Type.String, description=None, required=None, default=None,\n              minimum=None, maximum=None, enum=None, **options):\n        \"\"\"\n        Define a query parameter\n        \"\"\"\n        if minimum is not None and maximum is not None and minimum > maximum:\n            raise ValueError(\"Minimum must be less than or equal to the maximum.\")\n        return cls(name, In.Query, type_, None, description,\n                   required=required, default=default,\n                   minimum=minimum, maximum=maximum,\n                   enum=enum, **options)", "response": "Define a query parameter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndefining a header parameter.", "response": "def header(cls, name, type_=Type.String, description=None, default=None, required=None, **options):\n        \"\"\"\n        Define a header parameter.\n        \"\"\"\n        return cls(name, In.Header, type_, None, description,\n                   required=required, default=default,\n                   **options)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_swagger(self, bound_resource=None):\n        return _to_swagger(\n            {\n                'name': self.name,\n                'in': self.in_.value,\n                'type': str(self.type) if self.type else None,\n            },\n            description=self.description,\n            resource=bound_resource if self.resource is DefaultResource else self.resource,\n            options=self.options\n        )", "response": "Generate a swagger representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a swagger representation of the resource entry.", "response": "def to_swagger(self, bound_resource=None):\n        \"\"\"\n        Generate a swagger representation.\n        \"\"\"\n        response_def = _to_swagger(\n            description=self.description,\n            resource=bound_resource if self.resource is DefaultResource else self.resource,\n        )\n        status = self.status if self.status == 'default' else self.status.value\n        return status, response_def"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pre_request(self):\n        middleware = sort_by_priority(self)\n        return tuple(m.pre_request for m in middleware if hasattr(m, 'pre_request'))", "response": "Returns a tuple of pre - request methods from registered middleware."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pre_dispatch(self):\n        middleware = sort_by_priority(self)\n        return tuple(m.pre_dispatch for m in middleware if hasattr(m, 'pre_dispatch'))", "response": "Returns a tuple of pre - dispatch methods from registered middleware."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a tuple of post - dispatch methods from registered middleware.", "response": "def post_dispatch(self):\n        \"\"\"\n        List of post-dispatch methods from registered middleware.\n        \"\"\"\n        middleware = sort_by_priority(self, reverse=True)\n        return tuple(m.post_dispatch for m in middleware if hasattr(m, 'post_dispatch'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a tuple of post - swagger methods from registered middleware.", "response": "def post_swagger(self):\n        \"\"\"\n        List of post-swagger methods from registered middleware.\n\n        This is used to modify documentation (eg add/remove any extra information, provided by the middleware)\n\n        \"\"\"\n        middleware = sort_by_priority(self)\n        return tuple(m.post_swagger for m in middleware if hasattr(m, 'post_swagger'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, key, value):\n        # type: (Hashable, Any) -> None\n        \"\"\"\n        Adds a new value for the key.\n\n        :param key: the key for the value.\n        :param value: the value to add.\n\n        \"\"\"\n        dict.setdefault(self, key, []).append(value)", "response": "Adds a new value for the key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the last data value for the passed key.", "response": "def get(self, key, default=None, type_=None):\n        \"\"\"\n        Return the last data value for the passed key. If key doesn't exist\n        or value is an empty list, return `default`.\n        \"\"\"\n        try:\n            rv = self[key]\n        except KeyError:\n            return default\n        if type_ is not None:\n            try:\n                rv = type_(rv)\n            except ValueError:\n                rv = default\n        return rv"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the list of items for a given key.", "response": "def getlist(self, key, type_=None):\n        # type: (Hashable, Callable) -> List[Any]\n        \"\"\"\n        Return the list of items for a given key. If that key is not in the\n        `MultiDict`, the return value will be an empty list.  Just as `get`\n        `getlist` accepts a `type` parameter.  All items will be converted\n        with the callable defined there.\n\n        :param key: The key to be looked up.\n        :param type_: A callable that is used to cast the value in the\n                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n                     by this callable the value will be removed from the list.\n        :return: a :class:`list` of all the values for the key.\n\n        \"\"\"\n        try:\n            rv = dict.__getitem__(self, key)\n        except KeyError:\n            return []\n        if type_ is None:\n            return list(rv)\n        result = []\n        for item in rv:\n            try:\n                result.append(type_(item))\n            except ValueError:\n                pass\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setlist(self, key, new_list):\n        # type: (Hashable, List[Any]) -> None\n        \"\"\"\n        Remove the old values for a key and add new ones.  Note that the list\n        you pass the values in will be shallow-copied before it is inserted in\n        the dictionary.\n        >>> d = MultiValueDict()\n        >>> d.setlist('foo', ['1', '2'])\n        >>> d['foo']\n        '1'\n        >>> d.getlist('foo')\n        ['1', '2']\n        :param key: The key for which the values are set.\n        :param new_list: An iterable with the new values for the key.  Old values\n                         are removed first.\n        \"\"\"\n        dict.__setitem__(self, key, list(new_list))", "response": "Set the list of values for a key to a list of new values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlikes setlistdefault but returns a list of default values.", "response": "def setlistdefault(self, key, default_list=None):\n        # type: (Hashable, List[Any]) -> List[Any]\n        \"\"\"\n        Like `setdefault` but sets multiple values.  The list returned\n        is not a copy, but the list that is actually used internally.  This\n        means that you can put new values into the dict by appending items\n        to the list:\n        >>> d = MultiValueDict({\"foo\": 1})\n        >>> d.setlistdefault(\"foo\").extend([2, 3])\n        >>> d.getlist(\"foo\")\n        [1, 2, 3]\n\n        :param key: The key to be looked up.\n        :param default_list: An iterable of default values.  It is either copied\n                             (in case it was a list) or converted into a list\n                             before returned.\n        :return: a :class:`list`\n\n        \"\"\"\n        if key not in self:\n            default_list = list(default_list or ())\n            dict.__setitem__(self, key, default_list)\n        else:\n            default_list = dict.__getitem__(self, key)\n        return default_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an iterator of tuples.", "response": "def items(self, multi=False):\n        # type: (bool) -> Iterator[Tuple[Hashable, Any]]\n        \"\"\"\n        Return an iterator of ``(key, value)`` pairs.\n\n        :param multi: If set to `True` the iterator returned will have a pair\n                      for each value of each key.  Otherwise it will only\n                      contain pairs for the lasted added of each key.\n        \"\"\"\n        for key, values in iteritems(self):\n            if multi:\n                for value in values:\n                    yield key, value\n            else:\n                yield key, values[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sorteditems(self, multi=False):\n        # type: (bool) -> Iterator[Tuple[Hashable, Any]]\n        \"\"\"\n        Return an iterator of ``(key, value)`` pairs, sorted by key.\n\n        :param multi: If set to `True` the iterator returned will have a pair\n                      for each value of each key.  Otherwise it will only\n                      contain pairs for the lasted added of each key.\n\n        \"\"\"\n        for key in sorted(dict.keys(self)):\n            if multi:\n                for value in self.getlist(key):\n                    yield key, value\n            else:\n                yield key, self[key]", "response": "Returns an iterator of tuples sorted by key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields the last value on every key list.", "response": "def values(self, multi=False):\n        # type: (bool) -> Iterator[Any]\n        \"\"\"\n        Yield the last value on every key list.\n\n        :param multi: If set to `True` the iterator returned will have a pair\n                      for each value of each key.  Otherwise it will only\n                      contain pairs for the lasted added of each key.\n\n        \"\"\"\n        for values in itervalues(self):\n            if multi:\n                for value in values:\n                    yield value\n            else:\n                yield values[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_dict(self, flat=True):\n        if flat:\n            return dict(self.items())\n        return dict(self.lists())", "response": "Return the contents as regular dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pop(self, key, default=NotDefined):\n        # type: (Hashable, Any) -> Any\n        \"\"\"\n        Pop the last item for a list on the dict.  Afterwards the\n        key is removed from the dict, so additional values are discarded:\n        >>> d = MultiValueDict({\"foo\": [1, 2, 3]})\n        >>> d.pop(\"foo\")\n        1\n        >>> \"foo\" in d\n        False\n\n        :param key: the key to pop.\n        :param default: if provided the value to return if the key was\n                        not in the dictionary.\n        \"\"\"\n        try:\n            return dict.pop(self, key)[-1]\n        except LookupError:\n            if default is NotDefined:\n                raise MultiValueDictKeyError(key)\n            return default", "response": "Pop the last item for a list on the dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_proxy(self, input_):\n        if input_._http_request is not None:\n            authentication = Authentication()\n            authentication.set_django_user(input_._http_request.user)\n        else:\n            authentication = None\n        effective_agent_id = input_._effective_agent_id\n        # Also need to deal with effective dates and Local\n        return rules.Proxy(authentication=authentication,\n                           effective_agent_id=effective_agent_id)", "response": "Gets a proxy.\n\n        arg:    input (osid.proxy.ProxyCondition): a proxy condition\n        return: (osid.proxy.Proxy) - a proxy\n        raise:  NullArgument - ``input`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``input`` is not of this service\n        *compliance: mandatory -- This method is must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_plain_text(str):\n    '''\n    Return a plain-text version of a given string\n\n    This is a dumb approach that tags and then removing entity markers\n    but this is fine for the content from biocyc where entities are &beta; etc.\n    \n    Stripping in this way turns these into plaintext 'beta' which is preferable \n    to unicode\n    '''\n    \n    str = strip_tags_re.sub('', str)\n    str = strip_entities_re.sub('', str)\n    return str", "response": "Converts a string to a plain - text version of a given string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting an object from the cache", "response": "def get_from_cache(self, org_id, id):\n        '''\n        Get an object from the cache\n        \n        Use all cache folders available (primary first, then secondary in order) and look for the ID in the dir\n        if found unpickle and return the object, else return False\n        \n        FIXME: Check for expiry of object! Return false is expired (will auto-refetch and overwrite)\n        '''\n        current_time = datetime.now()\n        \n        # Check memory cache first\n        if id in self.memory_cache[org_id]:\n            obj = self.memory_cache[org_id][id]\n            if obj.created_at > current_time - self.expire_records_after:\n                return obj\n        \n        for cache in [self.cache_path] + self.secondary_cache_paths:\n            read_path = os.path.join( cache, org_id, id )\n            try:\n                with open(read_path, 'rb') as f:\n                    obj = pickle.load(f)\n\n            except:\n                # Continue to try the next cache\n                pass \n                \n            else:\n                # It worked so we have obj\n                # Check for expiry date; if it's not expired return it else continue\n                if obj.created_at > current_time - self.expire_records_after:\n                    # If we're here it mustn't be in the memory cache\n                    self.memory_cache[org_id][id] = obj\n                    if len(self.memory_cache[org_id]) > self.max_memory_cache:\n                        self.memory_cache[org_id].popitem(last=False)\n\n                    return obj\n                    \n                # Else continue looking\n\n        # We found nothing (or all expired)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstores an object in the cache", "response": "def cache(self, obj):\n        '''\n        Store an object in the cache (this allows temporarily assigning a new cache\n        for exploring the DB without affecting the stored version\n        '''\n        # Check cache path exists for current obj\n        write_path = os.path.join( self.cache_path, obj.org_id )\n        if not os.path.exists( write_path ): \n            mkdir_p( write_path )\n\n        with open(os.path.join( write_path, obj.id ), 'wb') as f:\n            pickle.dump( obj, f )\n        \n        # Add to localstore (keep track of numbers of objects, etc.)\n        self.add_to_localstore(obj)   \n        self.add_to_names(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimports the object metadata from the given XML string.", "response": "def import_from_xml(self, xml):\n        '''\n        Standard imports for all types of object\n        These must fail gracefully, skip if not found\n        '''\n        self._import_orgid(xml)\n        self._import_parents_from_xml(xml)\n        self._import_instances_from_xml(xml)\n        self._import_common_name(xml)\n        self._import_synonyms(xml)\n        self._import_dblinks(xml)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a object variable from the xml if it is there and passing it through a data conversion based on the variable datatype", "response": "def _set_var_from_xml_text(self, xml, xmlpath, var):\n        '''\n        Sets a object variable from the xml if it is there\n        and passing it through a data conversion based on the variable datatype\n        '''\n        xmle = xml.find(xmlpath)\n        if xmle is not None:\n            setattr(self, var, type_converter[ xmle.attrib.get('datatype', 'string') ]( xmle.text ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset a list variable from the frameids of matching xml entities", "response": "def _set_list_ids_from_xml_iter(self, xml, xmlpath, var):\n        '''\n        Set a list variable from the frameids of matching xml entities\n        '''\n        es = xml.iterfind(xmlpath)\n        if es is not None:\n            l = []\n            for e in es:\n                l.append( e.attrib['frameid'] )\n            \n            setattr(self, var, l)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets a single variable with the frameids of matching entity", "response": "def _set_id_from_xml_frameid(self, xml, xmlpath, var):\n        '''\n        Set a single variable with the frameids of matching entity\n        '''\n        e = xml.find(xmlpath)\n        if e is not None:\n            setattr(self, var, e.attrib['frameid'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_avatar_id(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['avatarId']):\n            raise errors.IllegalState('this Resource has no avatar')\n        else:\n            return Id(self._my_map['avatarId'])", "response": "Gets the asset Id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the asset. return: (osid.repository.Asset) - the asset raise: IllegalState - ``has_avatar()`` is ``false`` raise: OperationFailed - unable to complete request *compliance: mandatory -- This method must be implemented.*", "response": "def get_avatar(self):\n        \"\"\"Gets the asset.\n\n        return: (osid.repository.Asset) - the asset\n        raise:  IllegalState - ``has_avatar()`` is ``false``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['avatarId']):\n            raise errors.IllegalState('this Resource has no avatar')\n        mgr = self._get_provider_manager('REPOSITORY')\n        if not mgr.supports_asset_lookup():\n            raise errors.OperationFailed('Repository does not support Asset lookup')\n        lookup_session = mgr.get_asset_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_repository_view()\n        osid_object = lookup_session.get_asset(self.get_avatar_id())\n        return osid_object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_group_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['group'])\n        metadata.update({'existing_boolean_values': self._my_map['group']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a group"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the resource as a group.", "response": "def set_group(self, group):\n        \"\"\"Sets the resource as a group.\n\n        arg:    group (boolean): ``true`` if this resource is a group,\n                ``false`` otherwise\n        raise:  InvalidArgument - ``group`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_group_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(group):\n            raise errors.InvalidArgument()\n        self._my_map['group'] = group"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclearing the group designation.", "response": "def clear_group(self):\n        \"\"\"Clears the group designation.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_group_metadata().is_read_only() or\n                self.get_group_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['group'] = self._group_default"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the metadata for an asset.", "response": "def get_avatar_metadata(self):\n        \"\"\"Gets the metadata for an asset.\n\n        return: (osid.Metadata) - metadata for the asset\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['avatar'])\n        metadata.update({'existing_id_values': self._my_map['avatarId']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_avatar(self, asset_id):\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_avatar_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(asset_id):\n            raise errors.InvalidArgument()\n        self._my_map['avatarId'] = str(asset_id)", "response": "Sets the avatar asset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclear the asset. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_avatar(self):\n        \"\"\"Clears the asset.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_avatar_metadata().is_read_only() or\n                self.get_avatar_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['avatarId'] = self._avatar_default"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_bin(self):\n        if self._lookup_session is None:\n            mgr = get_provider_manager('RESOURCE', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_bin_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_bin(Id(self._my_map['id']))", "response": "Gets the bin at this node."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the parents of this bin.", "response": "def get_parent_bin_nodes(self):\n        \"\"\"Gets the parents of this bin.\n\n        return: (osid.resource.BinNodeList) - the parents of the ``id``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        parent_bin_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_bin_nodes.append(BinNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return BinNodeList(parent_bin_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef supports_coordinate_type(self, coordinate_type):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``COORDINATE``']:\n            raise errors.IllegalState()\n        return coordinate_type in self.get_coordinate_types", "response": "Tests if the given coordinate type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if the given currency type is supported.", "response": "def supports_currency_type(self, currency_type):\n        \"\"\"Tests if the given currency type is supported.\n\n        arg:    currency_type (osid.type.Type): a currency Type\n        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise\n        raise:  IllegalState - syntax is not a ``CURRENCY``\n        raise:  NullArgument - ``currency_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``CURRENCY``']:\n            raise errors.IllegalState()\n        return currency_type in self.get_currency_types"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef supports_calendar_type(self, calendar_type):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``DATETIME``', '``DURATION``']:\n            raise errors.IllegalState()\n        return calendar_type in self.get_calendar_types", "response": "Tests if the given calendar type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef supports_time_type(self, time_type):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``DATETIME,', 'DURATION,``', '``TIME``']:\n            raise errors.IllegalState()\n        return time_type in self.get_time_types", "response": "Tests if the given time type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef supports_heading_type(self, heading_type):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``HEADING``']:\n            raise errors.IllegalState()\n        return heading_type in self.get_heading_types", "response": "Tests if the given heading type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntesting if the given object type is supported.", "response": "def supports_object_type(self, object_type):\n        \"\"\"Tests if the given object type is supported.\n\n        arg:    object_type (osid.type.Type): an object Type\n        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise\n        raise:  IllegalState - syntax is not an ``OBJECT``\n        raise:  NullArgument - ``object_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``OBJECT``']:\n            raise errors.IllegalState()\n        return object_type in self.get_object_types"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if the given spatial unit record type is supported.", "response": "def supports_spatial_unit_record_type(self, spatial_unit_record_type):\n        \"\"\"Tests if the given spatial unit record type is supported.\n\n        arg:    spatial_unit_record_type (osid.type.Type): a spatial\n                unit record Type\n        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise\n        raise:  IllegalState - syntax is not an ``SPATIALUNIT``\n        raise:  NullArgument - ``spatial_unit_record_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``SPATIALUNIT``']:\n            raise errors.IllegalState()\n        return spatial_unit_record_type in self.get_spatial_unit_record_types"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef supports_string_match_type(self, string_match_type):\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``STRING``']:\n            raise errors.IllegalState()\n        return string_match_type in self.get_string_match_types", "response": "Tests if the given string match type is supported."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if the given version type is supported.", "response": "def supports_version_type(self, version_type):\n        \"\"\"Tests if the given version type is supported.\n\n        arg:    version_type (osid.type.Type): a version Type\n        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise\n        raise:  IllegalState - syntax is not a ``VERSION``\n        raise:  NullArgument - ``version_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.Metadata.supports_coordinate_type\n        if self._kwargs['syntax'] not in ['``VERSION``']:\n            raise errors.IllegalState()\n        return version_type in self.get_version_types"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, index1, index2=None):\n        returnvar = self.tk.call(self._w, 'get', index1, index2)\n        return returnvar.strip()", "response": "Return the text from INDEX1 to INDEX2"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'okapia.net',\n            'namespace': 'TextFormats',\n            'identifier': name,\n            'domain': 'DisplayText Formats',\n            'display_name': FORMAT_TYPES[name] + ' Format Type',\n            'display_label': FORMAT_TYPES[name],\n            'description': ('The display text format type for the ' +\n                            FORMAT_TYPES[name] + ' format.')\n        }\n    except KeyError:\n        raise NotFound('Format Type:' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_view(func):\n\n    @functools.wraps(func)\n    def view_logger(*args, **kwargs):\n        log.debug(\"call view %r\", func.__name__)\n        try:\n            response = func(*args, **kwargs)\n        except Exception as err:\n            log.error(\"view exception: %s\", err)\n            traceback.print_exc(file=sys.stderr)\n            raise\n\n        log.debug(\"Response: %s\", response)\n        return response\n\n    return view_logger", "response": "Decorator for logging Selenium unittests."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmoves element_id ahead of reference_id in the list", "response": "def move_id_ahead(element_id, reference_id, idstr_list):\n    \"\"\"Moves element_id ahead of reference_id in the list\"\"\"\n    if element_id == reference_id:\n        return idstr_list\n    idstr_list.remove(str(element_id))\n    reference_index = idstr_list.index(str(reference_id))\n    idstr_list.insert(reference_index, str(element_id))\n    return idstr_list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure the root logger with some sensible defaults.", "response": "def initialize_logging(args):\n    \"\"\"Configure the root logger with some sensible defaults.\"\"\"\n    log_handler = logging.StreamHandler()\n    log_formatter = logging.Formatter(\n        \"%(levelname)s %(asctime)s %(name)s:%(lineno)04d - %(message)s\")\n    log_handler.setFormatter(log_formatter)\n\n    root_logger = logging.getLogger()\n    root_logger.addHandler(log_handler)\n    root_logger.setLevel(getattr(logging, args.loglevel))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n    args = parser.parse_args()\n    initialize_logging(args)\n\n    # Allow expansion of paths even if the shell doesn't do it\n    config_path = os.path.abspath(os.path.expanduser(args.config))\n\n    client = kitnirc.client.Client()\n    controller = kitnirc.modular.Controller(client, config_path)\n\n    # Make sure the configuration file is loaded so we can check for\n    # connection information.\n    controller.load_config()\n\n    def config_or_none(section, value, integer=False, boolean=False):\n        \"\"\"Helper function to get values that might not be set.\"\"\"\n        if controller.config.has_option(section, value):\n            if integer:\n                return controller.config.getint(section, value)\n            elif boolean:\n                return controller.config.getboolean(section, value)\n            return controller.config.get(section, value)\n        return None\n\n    # If host isn't specified on the command line, try from config file\n    host = args.host or config_or_none(\"server\", \"host\")\n    if not host:\n        parser.error(\n            \"IRC host must be specified if not in config file.\")\n\n    # If nick isn't specified on the command line, try from config file\n    nick = args.nick or config_or_none(\"server\", \"nick\")\n    if not nick:\n        parser.error(\n            \"Nick must be specified if not in config file.\")\n\n    # KitnIRC's default client will use port 6667 if nothing else is specified,\n    # but since we want to potentially specify something else, we add that\n    # fallback here ourselves.\n    port = args.port or config_or_none(\"server\", \"port\", integer=True) or 6667\n    ssl = args.ssl or config_or_none(\"server\", \"ssl\", boolean=True)\n    password = args.password or config_or_none(\"server\", \"password\")\n    username = args.username or config_or_none(\"server\", \"username\") or nick\n    realname = args.realname or config_or_none(\"server\", \"realname\") or username\n\n    controller.start()\n    client.connect(\n        nick,\n        host=host,\n        port=port,\n        username=username,\n        realname=realname,\n        password=password,\n        ssl=ssl,\n    )\n    try:\n        client.run()\n    except KeyboardInterrupt:\n        client.disconnect()", "response": "Main function for the KitnIRC client."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the agent Id who created this entry.", "response": "def get_agent_id(self):\n        \"\"\"Gets the agent ``Id`` who created this entry.\n\n        return: (osid.id.Id) - the agent ``Id``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['agentId']):\n            raise errors.IllegalState('this LogEntry has no agent')\n        else:\n            return Id(self._my_map['agentId'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the Agent who created this entry.", "response": "def get_agent(self):\n        \"\"\"Gets the ``Agent`` who created this entry.\n\n        return: (osid.authentication.Agent) - the ``Agent``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['agentId']):\n            raise errors.IllegalState('this LogEntry has no agent')\n        mgr = self._get_provider_manager('AUTHENTICATION')\n        if not mgr.supports_agent_lookup():\n            raise errors.OperationFailed('Authentication does not support Agent lookup')\n        lookup_session = mgr.get_agent_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_agency_view()\n        osid_object = lookup_session.get_agent(self.get_agent_id())\n        return osid_object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the metadata for a priority type", "response": "def get_priority_metadata(self):\n        \"\"\"Gets the metadata for a priority type.\n\n        return: (osid.Metadata) - metadata for the priority\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.logging.LogEntryForm.get_priority_metadata\n        metadata = dict(self._mdata['priority'])\n        metadata.update({'existing_type_values': self._my_map['priorityId']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_priority(self, priority):\n        # Implemented from template for osid.logging.LogEntryForm.set_priority\n        if self.get_priority_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_type(priority):\n            raise errors.InvalidArgument()\n        self._my_map['priority'] = str(priority)", "response": "Sets the priority.\n\n        arg:    priority (osid.type.Type): the new priority\n        raise:  InvalidArgument - ``priority`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``priority`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the priority. raise: NoAccess - ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_priority(self):\n        \"\"\"Removes the priority.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.logging.LogEntryForm.clear_priority_template\n        if (self.get_priority_metadata().is_read_only() or\n                self.get_priority_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['priority'] = self._priority_default"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the metadata for a timestamp", "response": "def get_timestamp_metadata(self):\n        \"\"\"Gets the metadata for a timestamp.\n\n        return: (osid.Metadata) - metadata for the timestamp\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['timestamp'])\n        metadata.update({'existing_date_time_values': self._my_map['timestamp']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the timestamp. arg: timestamp (osid.calendaring.DateTime): the new timestamp raise: InvalidArgument - ``timestamp`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``timestamp`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_timestamp(self, timestamp):\n        \"\"\"Sets the timestamp.\n\n        arg:    timestamp (osid.calendaring.DateTime): the new timestamp\n        raise:  InvalidArgument - ``timestamp`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``timestamp`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.assessment.AssessmentOfferedForm.set_start_time_template\n        if self.get_timestamp_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_date_time(\n                timestamp,\n                self.get_timestamp_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['timestamp'] = timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_agent_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['agent'])\n        metadata.update({'existing_id_values': self._my_map['agentId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the agent"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the agent. arg: agent_id (osid.id.Id): the new agent raise: InvalidArgument - ``agent_id`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``agent_id`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_agent(self, agent_id):\n        \"\"\"Sets the agent.\n\n        arg:    agent_id (osid.id.Id): the new agent\n        raise:  InvalidArgument - ``agent_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``agent_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_agent_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(agent_id):\n            raise errors.InvalidArgument()\n        self._my_map['agentId'] = str(agent_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the log at this node.", "response": "def get_log(self):\n        \"\"\"Gets the ``Log`` at this node.\n\n        return: (osid.logging.Log) - the log represented by this node\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._lookup_session is None:\n            mgr = get_provider_manager('LOGGING', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_log_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_log(Id(self._my_map['id']))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the parents of this log.", "response": "def get_parent_log_nodes(self):\n        \"\"\"Gets the parents of this log.\n\n        return: (osid.logging.LogNodeList) - the parents of this log\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        parent_log_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_log_nodes.append(LogNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return LogNodeList(parent_log_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a key that is enclosed in a double quotes.", "response": "def _brace_key(self, key):\n        \"\"\"\n        key: 'x' -> '{x}'\n        \"\"\"\n        if isinstance(key, six.integer_types):\n            t = str\n            key = t(key)\n        else:\n            t = type(key)\n        return t(u'{') + key + t(u'}')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _inject_conversion(self, value, conversion):\n        t = type(value)\n        return value[:-1] + t(u'!') + conversion + t(u'}')", "response": "Injects conversion into the value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninjects format_spec into value", "response": "def _inject_format_spec(self, value, format_spec):\n        \"\"\"\n        value: '{x}', format_spec: 'f' -> '{x:f}'\n        \"\"\"\n        t = type(value)\n        return value[:-1] + t(u':') + format_spec + t(u'}')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _escape(self, bits):\n        # for value, field_name, format_spec, conversion in bits:\n        while True:\n            try:\n                value, field_name, format_spec, conversion = next(bits)\n                if value:\n                    end = value[-1]\n                    if end in (u'{', u'}'):\n                        value += end\n                yield value, field_name, format_spec, conversion\n            except StopIteration:\n                break", "response": "Yields the set of key value pairs that are escaped."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting the todo based on ID", "response": "def POST(self, id):\n        \"\"\" Delete based on ID \"\"\"\n        id = int(id)\n        model.del_todo(id)\n        raise web.seeother('/')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _can(self, func_name, qualifier_id=None):\n        function_id = self._get_function_id(func_name)\n        if qualifier_id is None:\n            qualifier_id = self._qualifier_id\n        agent_id = self.get_effective_agent_id()\n        try:\n            return self._authz_cache[str(agent_id) + str(function_id) + str(qualifier_id)]\n        except KeyError:\n            authz = self._authz_session.is_authorized(agent_id=agent_id,\n                                                      function_id=function_id,\n                                                      qualifier_id=qualifier_id)\n            self._authz_cache[str(agent_id) + str(function_id) + str(qualifier_id)] = authz\n            return authz", "response": "Tests if the named function is authorized with agent and qualifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _can_for_object(self, func_name, object_id, method_name):\n        can_for_session = self._can(func_name)\n        if (can_for_session or\n                self._object_catalog_session is None or\n                self._override_lookup_session is None):\n            return can_for_session\n\n        override_auths = self._override_lookup_session.get_authorizations_for_agent_and_function(\n            self.get_effective_agent_id(),\n            self._get_function_id(func_name))\n        if not override_auths.available():\n            return False\n\n        if self._object_catalog_session is not None:\n            catalog_ids = list(getattr(self._object_catalog_session, method_name)(object_id))\n            for auth in override_auths:\n                if auth.get_qualifier_id() in catalog_ids:\n                    return True\n        return False", "response": "Checks if agent can perform function for object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_alt_texts_metadata(self):\n        metadata = dict(self._alt_texts_metadata)\n        metadata.update({'existing_string_values': [t['text'] for t in self.my_osid_object_form._my_map['altTexts']]})\n        return Metadata(**metadata)", "response": "Gets the metadata for all alt_texts"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an alt_text. arg: alt_text (displayText): the new alt_text raise: InvalidArgument - ``alt_text`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``alt_text`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def add_alt_text(self, alt_text):\n        \"\"\"Adds an alt_text.\n\n        arg:    alt_text (displayText): the new alt_text\n        raise:  InvalidArgument - ``alt_text`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``alt_text`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.get_alt_texts_metadata().is_read_only():\n            raise NoAccess()\n        self.add_or_replace_value('altTexts', alt_text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_alt_text_language(self, language_type):\n        if self.get_alt_texts_metadata().is_read_only():\n            raise NoAccess()\n        self.remove_field_by_language('altTexts',\n                                      language_type)", "response": "Removes the specified alt_text."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_media_descriptions_metadata(self):\n        metadata = dict(self._media_descriptions_metadata)\n        metadata.update({'existing_string_values': [t['text'] for t in self.my_osid_object_form._my_map['mediaDescriptions']]})\n        return Metadata(**metadata)", "response": "Gets the metadata for all media descriptions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a media_description. arg: media_description (displayText): the new media_description raise: InvalidArgument - ``media_description`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``media_description`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def add_media_description(self, media_description):\n        \"\"\"Adds a media_description.\n\n        arg:    media_description (displayText): the new media_description\n        raise:  InvalidArgument - ``media_description`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``media_description`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.get_media_descriptions_metadata().is_read_only():\n            raise NoAccess()\n        self.add_or_replace_value('mediaDescriptions', media_description)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the specified media_description.", "response": "def remove_media_description_language(self, language_type):\n        \"\"\"Removes the specified media_description.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.get_media_descriptions_metadata().is_read_only():\n            raise NoAccess()\n        self.remove_field_by_language('mediaDescriptions',\n                                      language_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_vtt_file(self, vtt_file, language_type=None):\n        if not isinstance(vtt_file, DataInputStream):\n            raise InvalidArgument('vtt_file')\n        # for now, don't bother with genusTypeIds for the newly created\n        # asset or assetContent...supposed to be managed via this one, I think\n        locale = DEFAULT_LANGUAGE_TYPE.identifier\n        if language_type is not None:\n            locale = language_type.identifier\n        self.my_osid_object_form.add_file(vtt_file,\n                                          locale,\n                                          asset_name=\"VTT File Container\",\n                                          asset_description=\"Used by an asset content to manage multi-language VTT files\")", "response": "Adds a VTT file with the given language."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a transcript file to the metadata.", "response": "def add_transcript_file(self, transcript_file, language_type=None):\n        \"\"\"Adds a transcript file tagged as the given language.\n\n        arg:    transcript_file (displayText): the new transcript_file\n        raise:  InvalidArgument - ``transcript_file`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``media_description`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not isinstance(transcript_file, DataInputStream):\n            raise InvalidArgument('transcript_file')\n        # for now, don't bother with genusTypeIds for the newly created\n        # asset or assetContent...supposed to be managed via this one, I think\n        locale = DEFAULT_LANGUAGE_TYPE.identifier\n        if language_type is not None:\n            locale = language_type.identifier\n        self.my_osid_object_form.add_file(transcript_file,\n                                          locale,\n                                          asset_name=\"Transcript File Container\",\n                                          asset_description=\"Used by an asset content to manage multi-language Transcript files\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'birdland.mit.edu',\n            'namespace': 'unit system',\n            'identifier': name,\n            'domain': 'Unit System Types',\n            'display_name': JEFFS_UNIT_SYSTEM_TYPES[name] + ' Unit System Type',\n            'display_label': JEFFS_UNIT_SYSTEM_TYPES[name],\n            'description': ('The unit system type for the ' +\n                            JEFFS_UNIT_SYSTEM_TYPES[name] + ' System')\n        }\n    except KeyError:\n        raise NotFound('Unit System Type: ' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'okapia.net',\n            'namespace': 'string match types',\n            'identifier': name,\n            'domain': 'String Match Types',\n            'display_name': STRING_MATCH_TYPES[name] + ' String Match Type',\n            'display_label': STRING_MATCH_TYPES[name],\n            'description': ('The string match type for the ' +\n                            STRING_MATCH_TYPES[name])\n        }\n    except KeyError:\n        raise NotFound('String Type: ' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads sizes from settings or fallback to the module constants", "response": "def load_settings_sizes():\n    \"\"\"\n    Load sizes from settings or fallback to the module constants\n    \"\"\"\n    page_size = AGNOCOMPLETE_DEFAULT_PAGESIZE\n    settings_page_size = getattr(\n        settings, 'AGNOCOMPLETE_DEFAULT_PAGESIZE', None)\n    page_size = settings_page_size or page_size\n\n    page_size_min = AGNOCOMPLETE_MIN_PAGESIZE\n    settings_page_size_min = getattr(\n        settings, 'AGNOCOMPLETE_MIN_PAGESIZE', None)\n    page_size_min = settings_page_size_min or page_size_min\n\n    page_size_max = AGNOCOMPLETE_MAX_PAGESIZE\n    settings_page_size_max = getattr(\n        settings, 'AGNOCOMPLETE_MAX_PAGESIZE', None)\n    page_size_max = settings_page_size_max or page_size_max\n\n    # Query sizes\n    query_size = AGNOCOMPLETE_DEFAULT_QUERYSIZE\n    settings_query_size = getattr(\n        settings, 'AGNOCOMPLETE_DEFAULT_QUERYSIZE', None)\n    query_size = settings_query_size or query_size\n\n    query_size_min = AGNOCOMPLETE_MIN_QUERYSIZE\n    settings_query_size_min = getattr(\n        settings, 'AGNOCOMPLETE_MIN_QUERYSIZE', None)\n    query_size_min = settings_query_size_min or query_size_min\n\n    return (\n        page_size, page_size_min, page_size_max,\n        query_size, query_size_min,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_valid_query(self, query):\n        # No query, no item\n        if not query:\n            return False\n        # Query is too short, no item\n        if len(query) < self.get_query_size_min():\n            return False\n        return True", "response": "Return True if the search query is valid."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the selected options as a list of tuples", "response": "def selected(self, ids):\n        \"\"\"\n        Return the selected options as a list of tuples\n        \"\"\"\n        result = copy(self.choices)\n        result = filter(lambda x: x[0] in ids, result)\n        # result = ((item, item) for item in result)\n        return list(result)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_model(self):\n        if hasattr(self, 'model') and self.model:\n            return self.model\n        # Give me a \"none\" queryset\n        try:\n            none = self.get_queryset().none()\n            return none.model\n        except Exception:\n            raise ImproperlyConfigured(\n                \"Integrator: Unable to determine the model with this queryset.\"\n                \" Please add a `model` property\")", "response": "Returns the class Model used by this Agnocomplete\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_field_name(self):\n        if hasattr(self, 'agnocomplete_field') and \\\n           hasattr(self.agnocomplete_field, 'to_field_name'):\n            return self.agnocomplete_field.to_field_name or 'pk'\n        return 'pk'", "response": "Returns the name of the model field to be used as a value or pk if unset\n        is True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a case - insensitive filter condition name usable as a queryset filter keyword argument.", "response": "def _construct_qs_filter(self, field_name):\n        \"\"\"\n        Using a field name optionnaly prefixed by `^`, `=`, `@`, return a\n        case-insensitive filter condition name usable as a queryset `filter()`\n        keyword argument.\n        \"\"\"\n        if field_name.startswith('^'):\n            return \"%s__istartswith\" % field_name[1:]\n        elif field_name.startswith('='):\n            return \"%s__iexact\" % field_name[1:]\n        elif field_name.startswith('@'):\n            return \"%s__search\" % field_name[1:]\n        else:\n            return \"%s__icontains\" % field_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the filtered queryset", "response": "def get_queryset_filters(self, query):\n        \"\"\"\n        Return the filtered queryset\n        \"\"\"\n        conditions = Q()\n        for field_name in self.fields:\n            conditions |= Q(**{\n                self._construct_qs_filter(field_name): query\n            })\n        return conditions"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef item(self, current_item):\n        return {\n            'value': text(getattr(current_item, self.get_field_name())),\n            'label': self.label(current_item)\n        }", "response": "Return the current item.\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_filtered_queryset(self, query, **kwargs):\n        # Take the basic queryset\n        qs = self.get_queryset()\n        # filter it via the query conditions\n        qs = qs.filter(self.get_queryset_filters(query))\n        return self.build_extra_filtered_queryset(qs, **kwargs)", "response": "Build and return the fully - filtered queryset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef items(self, query=None, **kwargs):\n        # Cut this, we don't need no empty query\n        if not query:\n            self.__final_queryset = self.get_model().objects.none()\n            return self.serialize(self.__final_queryset)\n        # Query is too short, no item\n        if len(query) < self.get_query_size_min():\n            self.__final_queryset = self.get_model().objects.none()\n            return self.serialize(self.__final_queryset)\n\n        if self.requires_authentication:\n            if not self.user:\n                raise AuthenticationRequiredAgnocompleteException(\n                    \"Authentication is required to use this autocomplete\"\n                )\n            if not self.user.is_authenticated:\n                raise AuthenticationRequiredAgnocompleteException(\n                    \"Authentication is required to use this autocomplete\"\n                )\n\n        qs = self.build_filtered_queryset(query, **kwargs)\n        # The final queryset is the paginated queryset\n        self.__final_queryset = qs\n        return self.serialize(qs)", "response": "Returns the items to be sent to the client"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef selected(self, ids):\n        # Cleanup the ID list\n        if self.get_field_name() == 'pk':\n            ids = filter(lambda x: \"{}\".format(x).isdigit(), copy(ids))\n        else:\n            ids = filter(lambda x: len(\"{}\".format(x)) > 0, copy(ids))\n        # Prepare the QS\n        # TODO: not contextually filtered, check if it's possible at some point\n        qs = self.get_model_queryset().filter(\n            **{'{}__in'.format(self.get_field_name()): ids})\n        result = []\n        for item in qs:\n            item_repr = self.item(item)\n            result.append(\n                (item_repr['value'], item_repr['label'])\n            )\n        return result", "response": "Return the selected options as a list of tuples"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the HTTP function to call and the params and data argument name", "response": "def get_http_method_arg_name(self):\n        \"\"\"\n        Return the HTTP function to call and the params/data argument name\n        \"\"\"\n        if self.method == 'get':\n            arg_name = 'params'\n        else:\n            arg_name = 'data'\n        return getattr(requests, self.method), arg_name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef http_call(self, url=None, **kwargs):\n        if not url:\n            url = self.search_url\n        http_func, arg_name = self.get_http_method_arg_name()\n        # Build the argument dictionary to pass in the http function\n        _kwargs = {\n            arg_name: kwargs,\n        }\n        # The actual HTTP call\n        response = http_func(\n            url=url.format(**kwargs),\n            headers=self.get_http_headers(),\n            **_kwargs\n        )\n        # Error handling\n        if response.status_code != 200:\n            logger.warning('Invalid Request for `%s`', response.url)\n            # Raising a \"requests\" exception\n            response.raise_for_status()\n        return response.json()", "response": "Calls the HTTP method of the target URL via HTTP and returns the JSON result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate the value of the item attribute.", "response": "def validate(self, value):\n        \"\"\"\n        From a value available on the remote server, the method returns the\n        complete item matching the value.\n        If case the value is not available on the server side or filtered\n        through :meth:`item`, the class:`agnocomplete.exceptions.ItemNotFound`\n        is raised.\n        \"\"\"\n\n        url = self.get_item_url(value)\n        try:\n            data = self.http_call(url=url)\n        except requests.HTTPError:\n            raise ItemNotFound()\n\n        data = self.get_http_result(data)\n\n        try:\n            self.item(data)\n        except SkipItem:\n            raise ItemNotFound()\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a mapping from a transcript to a random sequence", "response": "def emit(self):\n    \"\"\"Get a mapping from a transcript\n\n    :return: One random Transcript sequence\n    :rtype: sequence\n    \"\"\"\n    i = self.options.rand.get_weighted_random_index(self._weights)\n    return self._transcriptome.transcripts[i]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the weight of the objects in the xml file by a dictionary of weights", "response": "def set_weights_by_dict(self,weights):\n    \"\"\"input: an array of weights <<txname1> <weight1>> <<txname2> <weight2>>...\n       if this does not get set then even weighting will be used\n\n    :param weights: [[tx1,wght1],[tx2,wght2],...[txN,wightN]]\n    :type weights: list\n    \"\"\"\n    self._weights = []\n    txnames = [x.name for x in self._transcriptome.transcripts]\n    for txname in txnames:\n      if txname in weights:\n        self._weights.append(float(weights[txname]))\n      else:\n        self._weights.append(float(0))\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nemitting a read based on a source sequence", "response": "def emit(self,rlen=150):\n      \"\"\"Emit a read based on a source sequence\"\"\"\n      source_tx = self._source.emit()\n      source_read = self._cutter.cut(source_tx)\n      if self._flip and self.options.rand.random() < 0.5: source_read = source_read.rc()\n      srname = self.options.rand.uuid4()\n      seqfull = FASTQ('@'+self.options.rand.uuid4()+\"\\tlong\\n\"+str(source_read.sequence)+\"\\n+\\n\"+'I'*source_read.sequence.length+\"\\n\")\n      seqperm1 = seqfull.copy()\n      seqperm2 = seqfull.copy()\n      for e in self.errors:\n        seqperm1 = e.permute(seqperm1)\n        seqperm2 = e.permute(seqperm2)\n      sleft = seqperm1[0:rlen]\n      sleft = FASTQ('@'+sleft.name+\"\\tleft\\n\"+sleft.sequence+\"\\n+\\n\"+sleft.qual+\"\\n\")\n      sright = seqperm2.rc()[0:rlen]\n      sright = FASTQ('@'+sright.name+\"\\tright\\n\"+sright.sequence+\"\\n+\\n\"+sright.qual+\"\\n\")\n      emission = TranscriptEmission(source_tx,\n             Source(source_read,\n                    source_read.slice_sequence(0,rlen),\n                    source_read.rc().slice_sequence(0,rlen)),\n             Read(seqperm1,\n                  sleft,\n                  sright\n                 ))\n      return emission"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dictToH5(h5, d, link_copy=False):\n    global _array_cache\n    _array_cache = dict()\n    h5 = h5py.File(h5, mode=\"w\")\n    dictToH5Group(d, h5[\"/\"], link_copy=link_copy)\n    h5.close()\n    _array_cache = dict();", "response": "Save a dictionary into an hdf5 file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef h5ToDict(h5, readH5pyDataset=True):\n    h = h5py.File(h5, \"r\")\n    ret = unwrapArray(h, recursive=True, readH5pyDataset=readH5pyDataset)\n    if readH5pyDataset: h.close()\n    return ret", "response": "Read a hdf5 file into a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a dict of items into a dict", "response": "def _toDict(datastorage_obj,recursive=True):\n    \"\"\" this is the recursive part of the toDict (otherwise it fails when converting to DataStorage \"\"\"\n    if \"items\" not in dir(datastorage_obj): return datastorage_obj\n    d = dict()\n    for k, v in datastorage_obj.items():\n        try:\n            d[k] = _toDict(v)\n        except Exception as e:\n            log.info(\"In toDict, could not convert key %s to dict, error was %s\" %\n                     (k, e))\n            d[k] = v\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a DataStorage object to a dictionary", "response": "def toDict(datastorage_obj, recursive=True):\n    \"\"\" convert a DataStorage object to a dictionary (useful for saving); it should work for other objects too \n    \"\"\"\n    # if not a DataStorage, convert to it first\n    if \"items\" not in dir(datastorage_obj): datastorage_obj = DataStorage(datastorage_obj)\n    return _toDict(datastorage_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the object d to a file fname.", "response": "def save(fname, d, link_copy=True,raiseError=False):\n    \"\"\" link_copy is used by hdf5 saving only, it allows to creat link of identical arrays (saving space) \"\"\"\n    # make sure the object is dict (recursively) this allows reading it\n    # without the DataStorage module\n    fname = pathlib.Path(fname)\n    d = toDict(d, recursive=True)\n    d['filename'] = str(fname)\n    extension = fname.suffix\n    log.info(\"Saving storage file %s\" % fname)\n    try:\n        if extension == \".npz\":\n            return dictToNpz(fname, d)\n        elif extension == \".h5\":\n            return dictToH5(fname, d, link_copy=link_copy)\n        elif extension == \".npy\":\n            return dictToNpy(fname, d)\n        else:\n            raise ValueError(\n                \"Extension must be h5, npy or npz, it was %s\" % extension)\n    except Exception as e:\n        log.exception(\"Could not save %s\" % fname)\n        if raiseError: raise  e"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self, fname=None, link_copy=False,raiseError=False):\n        if fname is None:\n            fname = self.filename\n        assert fname is not None\n        save(fname, self, link_copy=link_copy,raiseError=raiseError)", "response": "Save the current object to a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef match_learning_objective_id(self, objective_id, match):\n        self._add_match('learningObjectiveIds', str(objective_id), bool(match))", "response": "Sets the learning objective Id for this query."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch assessments whose start time falls between the specified range inclusive.", "response": "def match_start_time(self, start, end, match):\n        \"\"\"Matches assessments whose start time falls between the specified range inclusive.\n\n        arg:    start (osid.calendaring.DateTime): start of range\n        arg:    end (osid.calendaring.DateTime): end of range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n        raise:  InvalidArgument - ``end`` is less than ``start``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._match_minimum_date_time('startTime', start, match)\n        self._match_maximum_date_time('startTime', end, match)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_deadline(self, start, end, match):\n        self._match_minimum_date_time('deadline', start, match)\n        self._match_maximum_date_time('deadline', end, match)", "response": "Matches assessments whose end time falls between the specified range inclusive."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match_taking_agent_id(self, agent_id, match):\n        self._add_match('takingAgentId', str(agent_id), bool(match))", "response": "Sets the agent Id for this query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_ancestor_bank_id(self, bank_id, match):\n        # matches when the bank_id param is an ancestor of\n        # any bank\n        bank_descendants = self._get_descendant_catalog_ids(bank_id)\n        identifiers = [ObjectId(i.identifier) for i in bank_descendants]\n        self._query_terms['_id'] = {'$in': identifiers}", "response": "Sets the bank Id for to match banks in which the specified bank is an ancestor of the specified one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfill in a dictionary of values from parms and insert them into cdb based on the field definitions in defs.", "response": "def fill(cdb, defs, pparms):\n        \"\"\"\n        Take field values in parms and insert them into cdb based on\n        the field definitions in defs.\n        \"\"\"\n        #print \"defs =\", defs\n        parms = {n:v[2] for (n,v) in defs.items()}  # Create parms for default field values.\n        parms.update(pparms)  # Insert real parameters.\n        for (name, value) in parms.items():\n            if name not in defs:\n                raise Exception(\"unknown field: \"+name)\n            width = defs[name][1]\n            start = defs[name][0]\n            if type(start) == type(0):  # must be either number or list of 2\n                start = (start,7)\n            # TODO Check type of start.\n\n            if type(value) == type(\"str\"):\n                if len(value) > width/8:\n                    raise Exception(\"value too large for field: \"+name)\n                if start[1] != 7:\n                    raise Exception(\"string must start in bit 7: \"+name)\n                value += \" \" * (width/8 - len(value))  # Fill with blanks.\n                cdb[start[0]:start[0]+len(value)] = value\n            else:\n                if value >= 1<<width:\n                    raise Exception(\"value too large for field: \"+name)\n                startbitnum = start[0]*8 + (7-start[1])  # Number bits l-to-r.\n                bitnum = startbitnum + defs[name][1] - 1\n                # TODO Is value inserted backwards?\n                while width > 0:\n                    if bitnum % 8 == 7 and width >= 8:\n                        bitlen= 8\n                        cdb[bitnum//8] = value & 0xff;\n                    else:\n                        startofbyte = bitnum // 8 * 8  # Find first bit num in byte.\n                        firstbit = max(startofbyte, bitnum-width+1)\n                        bitlen= bitnum-firstbit+1\n                        shift = (7 - bitnum%8)\n                        vmask = (1 << bitlen) - 1\n                        bmask = ~(vmask << shift)\n                        cdb[bitnum//8] &= bmask\n                        cdb[bitnum//8] |= (value & vmask) << shift\n                    bitnum -= bitlen\n                    value >>= bitlen\n                    width  -= bitlen"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract(data, defs, byteoffset=0):\n        \n        retval = ListDict()\n        for fielddef in defs:\n            start, width, form, name, desc = fielddef\n            if form == \"int\":\n                if type(start) == type(0):\n                    # It's a number. Convert it into a (bytenum,bitnum) tuple.\n                    start = (start,7)\n                ix, bitnum = start\n                val = 0\n                while (width > 0):\n                    if bitnum == 7 and width >= 8:\n                        val = (val << 8) | ord(data[ix])\n                        ix += 1\n                        width -= 8\n                    else:\n                        lastbit = bitnum+1 - width\n                        if lastbit < 0:\n                            lastbit = 0\n                        thiswidth = bitnum+1 - lastbit\n                        val = (val << thiswidth) | ((ord(data[ix]) >> lastbit) & ((1<<thiswidth)-1))\n                        bitnum = 7\n                        ix += 1\n                        width -= thiswidth\n                retval.append(Cmd.Field(val, byteoffset+start[0], name, desc), name)\n            elif form == \"str\":\n                assert(type(start) == type(0))\n                assert(width % 8 == 0)\n                retval.append(Cmd.Field(data[start:start+width/8], byteoffset+start, name, desc), name)\n            else:\n                # error in form\n                pass\n        return retval", "response": "Extracts fields from data into a list of fields."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an Inquiry command send it and parse the results.", "response": "def inq(pt, page=None, alloc=74):\n        \"\"\"\n        Create an Inquiry command, send it, and parse the results.\n        Input:\n          pt   : ScsiPT object\n          page : vital product page number or None\n          alloc: size to allocate for result\n        TODO: implement page\n        \"\"\"\n        cmd = Cmd(\"inq\", {\"evpd\":0, \"alloc\":alloc})\n        cdb = CDB(cmd.cdb)\n        cdb.set_data_in(alloc)\n        pt.sendcdb(cdb)\n        inq = Cmd.extract(cdb.buf, Cmd.data_inquiry)\n        return inq"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_question_mdata():\n    return {\n        'item': {\n            'element_label': {\n                'text': 'item',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Question"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_answer_mdata():\n    return {\n        'item': {\n            'element_label': {\n                'text': 'item',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Answer"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_item_mdata():\n    return {\n        'learning_objectives': {\n            'element_label': {\n                'text': 'learning objectives',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id[] object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_id_values': [],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Item"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns default mdata map for Assessment", "response": "def get_assessment_mdata():\n    \"\"\"Return default mdata map for Assessment\"\"\"\n    return {\n        'rubric': {\n            'element_label': {\n                'text': 'rubric',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'level': {\n            'element_label': {\n                'text': 'level',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assessment_offered_mdata():\n    return {\n        'level': {\n            'element_label': {\n                'text': 'level',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'start_time': {\n            'element_label': {\n                'text': 'start time',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid datetime object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_date_time_values': [None],\n            'syntax': 'DATETIME',\n            'date_time_set': [],\n        },\n        'grade_system': {\n            'element_label': {\n                'text': 'grade system',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'items_shuffled': {\n            'element_label': {\n                'text': 'items shuffled',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n        'score_system': {\n            'element_label': {\n                'text': 'score system',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'deadline': {\n            'element_label': {\n                'text': 'deadline',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid datetime object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_date_time_values': [None],\n            'syntax': 'DATETIME',\n            'date_time_set': [],\n        },\n        'duration': {\n            'element_label': {\n                'text': 'duration',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter a valid duration object.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_duration_values': [None],\n            'syntax': 'DURATION',\n            'date_time_set': [],\n        },\n        'assessment': {\n            'element_label': {\n                'text': 'assessment',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'items_sequential': {\n            'element_label': {\n                'text': 'items sequential',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'enter either true or false.',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_boolean_values': [None],\n            'syntax': 'BOOLEAN',\n        },\n    }", "response": "Return default mdata map for AssessmentOffered"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning default mdata map for AssessmentTaken", "response": "def get_assessment_taken_mdata():\n    \"\"\"Return default mdata map for AssessmentTaken\"\"\"\n    return {\n        'assessment_offered': {\n            'element_label': {\n                'text': 'assessment offered',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'taker': {\n            'element_label': {\n                'text': 'taker',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn default mdata map for AssessmentSection", "response": "def get_assessment_section_mdata():\n    \"\"\"Return default mdata map for AssessmentSection\"\"\"\n    return {\n        'assessment_taken': {\n            'element_label': {\n                'text': 'assessment taken',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmatching the agent identified by the given Id.", "response": "def match_agent_id(self, agent_id, match):\n        \"\"\"Matches the agent identified by the given ``Id``.\n\n        arg:    agent_id (osid.id.Id): the Id of the ``Agent``\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n        raise:  NullArgument - ``agent_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._add_match('agentId', str(agent_id), bool(match))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch the function identified by the given Id.", "response": "def match_function_id(self, function_id, match):\n        \"\"\"Matches the function identified by the given ``Id``.\n\n        arg:    function_id (osid.id.Id): the Id of the ``Function``\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n        raise:  NullArgument - ``function_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._add_match('functionId', str(function_id), bool(match))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_qualifier_id(self, qualifier_id, match):\n        self._add_match('qualifierId', str(qualifier_id), bool(match))", "response": "Matches the qualifier identified by the given Id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'okapia.net',\n            'namespace': 'heading',\n            'identifier': name,\n            'domain': 'Headings',\n            'display_name': HEADING_TYPES[name] + ' Heading Type',\n            'display_label': HEADING_TYPES[name],\n            'description': ('The heading type for the ' +\n                            HEADING_TYPES[name] + ' heading.')\n        }\n    except KeyError:\n        raise NotFound('Heading Type:' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_temp(suffix=\"\", prefix=\"tmp\", dir=None):\n    temporary = tempfile.mkstemp(suffix=suffix, prefix=prefix, dir=dir)\n    os.close(temporary[0])\n    try:\n        yield temporary[1]\n    finally:\n        os.remove(temporary[1])", "response": "A contextmanager that creates a temporary file and returns the path to that file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _list_response(self, response):\n        if type(response) is list:\n            return response\n        if type(response) is dict:\n            return [response]", "response": "This method checks if the response is already a list and if it is return it directly. If it is a dict it returns it as a list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main(args):\n    (ribo_file, transcriptome_fasta, read_lengths, read_offsets, count_five, count_three,\n     output_path, html_file) = \\\n        (args.ribo_file, args.transcriptome_fasta, args.read_lengths, args.read_offsets,\n         args.count_five, args.count_three, args.output_path, args.html_file)\n\n    log.debug('Supplied arguments\\n{}'.format(\n        '\\n'.join(['{:<20}: {}'.format(k, v) for k, v in vars(args).items()])))\n\n    # error messages (simple format) are written to html file\n    fh = logging.FileHandler(html_file)\n    fh.setLevel(logging.ERROR)\n    fh.setFormatter(ErrorLogFormatter('%(message)s'))\n    log.addHandler(fh)\n\n    log.info('Checking if required arguments are valid...')\n    ribocore.check_required_arguments(ribo_file=ribo_file, transcriptome_fasta=transcriptome_fasta)\n\n    log.info('Checking read lengths...')\n    ribocore.check_read_lengths(ribo_file=ribo_file, read_lengths=read_lengths)\n    log.info('Done')\n\n    log.info('Checking read offsets...')\n    ribocore.check_read_offsets(read_offsets=read_offsets)\n    log.info('Done')\n\n    log.info('Checking if each read length has a corresponding offset...')\n    ribocore.check_read_lengths_offsets(read_lengths=read_lengths, read_offsets=read_offsets)\n    log.info('Done')\n\n    with ribocore.open_pysam_file(fname=ribo_file, ftype='bam') as b, ribocore.open_pysam_file(fname=transcriptome_fasta, ftype='fasta') as f:\n        # Total valid transcript count (ones with reads)\n        count = 0\n        prime = None\n        table_body = ''  # HTML table body content\n        if count_five:\n            log.info('Only 5\\' read counts requested')\n            prime = '5'\n        elif count_three:\n            log.info('Only 3\\' read counts requested')\n            prime = '3'\n\n        # create output directories\n        if not os.path.exists(output_path):\n            os.mkdir(output_path)\n\n        # zip_dir contents will be written here and a zip archive will be created\n        # from this directory\n        zip_dir = os.path.join(output_path, 'ribocount_output')\n        if not os.path.exists(zip_dir):\n            os.mkdir(zip_dir)\n\n        csv_dir = os.path.join(zip_dir, 'csv')\n        if not os.path.exists(csv_dir):\n            os.mkdir(csv_dir)\n\n        log.info('Get RiboSeq read counts for all transcripts in FASTA')\n        for transcript in f.references:\n            ribo_counts, ribo_reads = ribocore.get_ribo_counts(ribo_fileobj=b, transcript_name=transcript,\n                                                               read_lengths=read_lengths, read_offsets=read_offsets)\n            if not ribo_reads:  # no reads for this transcript. skip.\n                continue\n\n            transcript_sequence = f[transcript]\n            # By default, all counts will be written (ribo_counts)\n            # If 5' or 3' counts requested, filter and use\n            # those counts for printing instead\n            write_counts = ribo_counts\n            log.debug('Total read counts {}'.format(ribo_reads))\n\n            # find longest ORF and filter counts based on whether 5' or 3' is\n            # requested\n            longest_orf = {}\n            if count_five or count_three:\n                # use default start and stop codons and find ORFs in all 3\n                # frames (+)\n                orfs = ribocore.get_three_frame_orfs(sequence=transcript_sequence)\n                if not len(orfs):\n                    log.debug('No ORFs for transcript {0}'.format(transcript))\n                    continue\n                longest_orf = ribocore.get_longest_orf(orfs=orfs)\n                orf_start, orf_stop = longest_orf['start'], longest_orf['stop']\n                log.info('Transcript: {0} Longest ORF Start: {1}, Stop: {2}'.format(transcript, orf_start, orf_stop))\n\n                if count_five:\n                    write_counts, five_reads = ribocore.filter_ribo_counts(counts=ribo_counts, orf_start=orf_start)\n                    log.debug('5\\' region read counts: {}'.format(five_reads))\n                elif count_three:\n                    write_counts, three_reads = ribocore.filter_ribo_counts(counts=ribo_counts, orf_stop=orf_stop)\n                    log.debug('3\\' region read counts: {}'.format(three_reads))\n\n            if not len(write_counts):\n                # no counts for transcript\n                continue\n\n            log.debug('Writing counts to CSV file for transcript {}'.format(transcript))\n            count += 1\n            csv_file = 'RiboCounts{}.csv'.format(count)\n            with open(os.path.join(csv_dir, csv_file), 'w') as cw:\n                cw.write('\"Position\",\"Nucleotide\",\"Frame 1\",\"Frame 2\",\"Frame 3\"\\n')\n                for pos in range(1, len(transcript_sequence) + 1):\n                    nucleotide = transcript_sequence[pos - 1]\n                    if pos in write_counts:\n                        cw.write('{0},{1},{2},{3},{4}\\n'.format(\n                            pos, nucleotide, write_counts[pos][1], write_counts[pos][2], write_counts[pos][3]))\n                    else:\n                        cw.write('{0},{1},{2},{3},{4}\\n'.format(pos, nucleotide, 0, 0, 0))\n            # HTML table\n            table_body += '<tr><td>{0}</td><td>{1}</td>'.format(transcript, ribo_reads)\n            if count_five:\n                table_body += '<td>{0}</td>'.format(five_reads)\n            elif count_three:\n                table_body += '<td>{0}</td>'.format(three_reads)\n            table_body += '<td><a href=\"csv/{0}\">{0}</a></td></tr>'.format(csv_file)\n        table_body += '</tbody>'\n\n    # only for display in HTML\n    valid_lengths = ['{}'.format(item) for item in read_lengths]\n    if len(valid_lengths) == 1 and valid_lengths[0] == '0':\n        valid_lengths = ['All']\n\n    if not count:\n        if len(valid_lengths) >= 1:\n            log.info('No transcripts found for read lengths: {}'.format(', '.join(valid_lengths)))\n        else:\n            log.info('No transcripts found')\n    else:\n        if prime:\n            template = 'ribocount_prime.html'\n        else:\n            template = 'ribocount.html'\n        with open(os.path.join(CONFIG.PKG_DATA_DIR, template)) as g,\\\n                open(os.path.join(zip_dir, 'index.html'), 'w') as h:\n            h.write(g.read().format(count=count, length='{}'.format(', '.join(valid_lengths)),\n                                    prime=prime, table_body=table_body))\n\n        for asset in ('css', 'js'):\n            asset_dir = os.path.join(zip_dir, asset)\n            if not os.path.exists(asset_dir):\n                os.mkdir(asset_dir)\n            asset_data_dir = os.path.join(CONFIG.PKG_DATA_DIR, asset)\n            for fname in os.listdir(asset_data_dir):\n                shutil.copy(os.path.join(asset_data_dir, fname),\n                            os.path.join(zip_dir, asset, fname))\n\n        log.info('Creating zip file')\n        os.chdir(output_path)\n        with zipfile.ZipFile('ribocount_output.zip', 'w', allowZip64=True) as zipf:\n            for root, d, f in os.walk('ribocount_output'):\n                for name in f:\n                    zipf.write(os.path.join(root, name))\n        shutil.rmtree('ribocount_output')\n        os.chdir('../')\n        log.debug('Writing HTML report')\n\n        with open(os.path.join(CONFIG.PKG_DATA_DIR, 'ribocount_index.html')) as j, open(args.html_file, 'w') as k:\n            k.write(j.read().format(count=count, read_length=', '.join(valid_lengths)))\n    log.info('Finished')", "response": "Main function for the\n    script"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the objective Id for this query to match objectives that have the specified objective as an ancestor.", "response": "def match_ancestor_objective_id(self, objective_id=None, match=None):\n        \"\"\"Sets the objective ``Id`` for this query to match objectives that have the specified objective as an ancestor.\n\n        arg:    objective_id (osid.id.Id): an objective ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n        raise:  NullArgument - ``objective_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if match:\n            self._add_match('ancestorObjectiveId', objective_id)\n        else:\n            raise errors.Unimplemented()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_descendant_objective_id(self, objective_id=None, match=None):\n        if match:\n            self._add_match('descendantObjectiveId', objective_id)\n        else:\n            raise errors.Unimplemented()", "response": "Sets the objective Id for this query to match objectives that have the specified objective as a descendant."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nskips a specified number of bytes in the current file.", "response": "def skip(self, n):\n        \"\"\"Skips a specified number of ``bytes`` in the stream.\n\n        arg:    n (cardinal): the number of ``bytes`` to skip\n        return: (cardinal) - the actual number of ``bytes`` skipped\n        raise:  IllegalState - this stream has been closed or\n                ``at_end_of_stream()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._my_data.closed or self.at_end_of_stream():\n            raise IllegalState()\n        if n is not None:\n            self._my_data.seek(n)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads a specified number of bytes from this stream into a buffer.", "response": "def read_to_buffer(self, buf, n):\n        \"\"\"Reads a specified number of ``bytes`` from this stream.\n\n        arg:    buf (byte[]): the buffer in which the data is read\n        arg:    n (cardinal): the number of ``bytes`` to read\n        return: (integer) - the actual number of ``bytes`` read\n        raise:  IllegalState - this stream has been closed or\n                ``at_end_of_stream()`` is ``true``\n        raise:  InvalidArgument - the size of ``buf`` is less than ``n``\n        raise:  NullArgument - ``buf`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if buf is None:\n            raise NullArgument()\n        if self._my_data.closed or self.at_end_of_stream():\n            raise IllegalState()\n        initial_buf_len = len(buf)\n        buf.append(self._my_data.read(size=n))\n        return len(buf) - initial_buf_len"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a specified number of bytes from this stream.", "response": "def read(self, buf=None, n=None):\n        \"\"\"Reads a specified number of ``bytes`` from this stream.\n\n        arg:    n (cardinal): the number of ``bytes`` to read\n        return: (integer) - the ``bytes`` read\n        raise:  IllegalState - this stream has been closed or\n                ``at_end_of_stream()`` is ``true``\n        raise:  InvalidArgument - the size of ``buf`` is less than ``n``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if n is not None:\n            return self._my_data.read(n)\n        else:\n            return self._my_data.read()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef next_fat(self, current):\n        sector_size = self.header.sector_size // 4\n        block = current // sector_size\n        difat_position = 76\n\n        if block >= 109:\n            block -= 109\n            sector = self.header.difat_sector_start\n\n            while block >= sector_size:\n                position = (sector + 1) << self.header.sector_shift\n                position += self.header.sector_size - 4\n                sector = self.get_long(position)\n                block -= sector_size - 1\n\n            difat_position = (sector + 1) << self.header.sector_shift\n        fat_sector = self.get_long(difat_position + block * 4)\n\n        fat_position = (fat_sector + 1) << self.header.sector_shift\n        fat_position += (current % sector_size) * 4\n\n        return self.get_long(fat_position)", "response": "Helper gives you seekable position of next FAT sector. Should not be called from external code. Should not be called from external code. Should not be called from external code. Should not be called from external code. Should not be called from external code. Should not be called from external code. Should not be called from external code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npassing through to provider ItemSearchSession. get_items_by_search", "response": "def get_items_by_search(self, item_query, item_search):\n        \"\"\"Pass through to provider ItemSearchSession.get_items_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_items_by_search(item_query, item_search)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessments_by_search(self, assessment_query, assessment_search):\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_assessments_by_search(assessment_query, assessment_search)", "response": "Pass through to provider AssessmentSearchSession. get_assessments_by_search"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assessments_offered_by_search(self, assessment_offered_query, assessment_offered_search):\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_assessments_offered_by_search(assessment_offered_query, assessment_offered_search)", "response": "Pass through to provider AssessmentOfferedSearchSession. get_assessments_offered_by_search"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass through to provider AssessmentTakenSearchSession. get_assessments_taken_by_search", "response": "def get_assessments_taken_by_search(self, assessment_taken_query, assessment_taken_search):\n        \"\"\"Pass through to provider AssessmentTakenSearchSession.get_assessments_taken_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_assessments_taken_by_search(assessment_taken_query, assessment_taken_search)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_choices_files_map(self):\n        files_map = []\n        for choice in self.get_choices():\n            choice = dict(choice)\n            choice['smallOrthoViewSet'] = base64.b64encode(\n                self._get_asset_content(Id(choice['assetId']),\n                                        OV_SET_SMALL_ASSET_CONTENT_TYPE\n                                        ).get_data().read())\n            choice['largeOrthoViewSet'] = base64.b64encode(\n                self._get_asset_content(Id(choice['assetId']),\n                                        OV_SET_LARGE_ASSET_CONTENT_TYPE\n                                        ).get_data().read())\n            del choice['assetId']\n            files_map.append(choice)\n        return files_map", "response": "returns a list of dicts that maps from assetId to file content."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_choices_file_urls_map(self):\n        file_urls_map = []\n        for choice in self.get_choices():\n            choice = dict(choice)\n            small_asset_content = self._get_asset_content(\n                Id(choice['assetId']), OV_SET_SMALL_ASSET_CONTENT_TYPE)\n            choice['smallOrthoViewSet'] = small_asset_content.get_url()\n\n            small_asset_content = self._get_asset_content(\n                Id(choice['assetId']), OV_SET_LARGE_ASSET_CONTENT_TYPE)\n            choice['largeOrthoViewSet'] = small_asset_content.get_url()\n\n            del choice['assetId']\n            file_urls_map.append(choice)\n        return file_urls_map", "response": "returns a list of choice dicts that maps from asset ids to file urls."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_files(self):\n        files_map = {}\n        try:\n            files_map['choices'] = self.get_choices_file_urls_map()\n            try:\n                files_map.update(self.get_file_urls_map())\n            except IllegalState:\n                pass\n        except Exception:\n            files_map['choices'] = self.get_choices_files_map()\n            try:\n                files_map.update(self.get_files_map())\n            except IllegalState:\n                pass\n        return files_map", "response": "get_files returns a dictionary of all available files"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the map of fields to use for the question.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        QuestionFilesFormRecord._init_map(self)\n        FirstAngleProjectionFormRecord._init_map(self)\n        super(MultiChoiceOrthoQuestionFormRecord, self)._init_map()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_metadata(self):\n        QuestionFilesFormRecord._init_metadata(self)\n        FirstAngleProjectionFormRecord._init_metadata(self)\n        super(MultiChoiceOrthoQuestionFormRecord, self)._init_metadata()", "response": "Initialize the metadata for this record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_manip_id(self, o3d_asset_id):\n        if not isinstance(o3d_asset_id, ABCId):\n            raise InvalidArgument('Argument must be a valid Id')\n        self.add_asset(o3d_asset_id,\n                       label='manip',\n                       asset_content_type=MANIP_ASSET_CONTENT_TYPE)", "response": "Stub method to set the ManipId of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_o3d_asset(self,\n                         manip=None,\n                         small_ov_set=None,\n                         large_ov_set=None,\n                         display_name='',\n                         description=''):\n        \"\"\"stub\"\"\"\n        if manip and not isinstance(manip, ABCDataInputStream):\n            raise InvalidArgument('Manipulatable object must be an ' +\n                                  'osid.transport.DataInputStream object')\n        if small_ov_set and not isinstance(small_ov_set, ABCDataInputStream):\n            raise InvalidArgument('Small OV Set object must be an ' +\n                                  'osid.transport.DataInputStream object')\n        if large_ov_set and not isinstance(large_ov_set, ABCDataInputStream):\n            raise InvalidArgument('Large OV Set object must be an ' +\n                                  'osid.transport.DataInputStream object')\n        asset_id, asset_content_id = self.create_asset(asset_type=O3D_ASSET_TYPE,\n                                                       display_name=display_name,\n                                                       description=description)\n        if manip is not None:\n            self.add_content_to_asset(asset_id=asset_id,\n                                      asset_data=manip,\n                                      asset_content_type=MANIP_ASSET_CONTENT_TYPE,\n                                      asset_label='3d manipulatable')\n        if small_ov_set is not None:\n            self.add_content_to_asset(asset_id=asset_id,\n                                      asset_data=small_ov_set,\n                                      asset_content_type=OV_SET_SMALL_ASSET_CONTENT_TYPE,\n                                      asset_label='small orthoviewset')\n        if large_ov_set is not None:\n            self.add_content_to_asset(asset_id=asset_id,\n                                      asset_data=large_ov_set,\n                                      asset_content_type=OV_SET_LARGE_ASSET_CONTENT_TYPE,\n                                      asset_label='large orthoviewset')\n        return asset_id", "response": "Create an O3D asset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the manipulated asset", "response": "def set_manip(self, manip, ovs_sm=None, ovs_lg=None, name='A manipulatable'):\n        \"\"\"stub\"\"\"\n        o3d_manip_id = self.create_o3d_asset(manip,\n                                             small_ov_set=ovs_sm,\n                                             large_ov_set=ovs_lg,\n                                             display_name=name)\n        self.set_manip_id(o3d_manip_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the ortho choice of the asset", "response": "def set_ortho_choice(self, small_asset_data, large_asset_data, name='Choice'):\n        \"\"\"stub\"\"\"\n        o3d_asset_id = self.create_o3d_asset(manip=None,\n                                             small_ov_set=small_asset_data,\n                                             large_ov_set=large_asset_data,\n                                             display_name=name)\n        self.add_choice(o3d_asset_id, name=name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_dmu_over_dt(species, propensity, n_counter, stoichiometry_matrix):\r\n\r\n\r\n    # compute derivatives :math:`\\frac{\\partial^n \\mathbf{n}a_l(\\mathbf{x})}{\\partial \\mathbf{x^n}}`\r\n    # for EACH REACTION and EACH entry in COUNTER\r\n    derives =[derive_expr_from_counter_entry(reac, species, c.n_vector) for (reac, c) in itertools.product(propensity, n_counter)]\r\n    # Computes the factorial terms (:math:`\\frac{1}{\\mathbf{n!}}`) for EACH REACTION and EACH entry in COUNTER\r\n    # this does not depend of the reaction, so we just repeat the result for each reaction\r\n    factorial_terms = [get_one_over_n_factorial(tuple(c.n_vector)) for c in n_counter] * len(propensity)\r\n    # we make a matrix in which every element is the entry-wise multiplication of `derives` and factorial_terms\r\n    taylor_exp_matrix = sp.Matrix(len(propensity), len(n_counter), [d*f for (d, f) in zip(derives, factorial_terms)])\r\n    # dmu_over_dt is the product of the stoichiometry matrix by the taylor expansion matrix\r\n    return stoichiometry_matrix * taylor_exp_matrix", "response": "r Generate a single dmu over dt."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_authentication_mdata():\n    return {\n        'agent': {\n            'element_label': {\n                'text': 'agent',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }", "response": "Return default mdata map for Authentication"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register(username, password):\n    check_for_cloud_server()\n    server = Server(config[\"cloud_server\"][\"url\"])\n    server.create_user(username, password)", "response": "Create a new user account on the selected cloud server."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlog into your user account", "response": "def login(username, password):\n    \"\"\" Log into your user account \"\"\"\n    check_for_cloud_server()\n    old_username = config[\"cloud_server\"][\"username\"]\n    if old_username and old_username != username:\n        raise click.ClickException(\n            \"Already logged in as user \\\"{}\\\". Run `openag cloud user logout` \"\n            \"before attempting to log in as a different user\".format(\n                old_username\n            )\n        )\n    server = Server(config[\"cloud_server\"][\"url\"])\n    server.log_in(username, password)\n    config[\"cloud_server\"][\"username\"] = username\n    config[\"cloud_server\"][\"password\"] = password"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs out of your user account", "response": "def logout(ctx):\n    \"\"\" Log out of your user account \"\"\"\n    check_for_cloud_server()\n    check_for_cloud_user()\n    if config[\"cloud_server\"][\"farm_name\"]:\n        ctx.invoke(deinit_farm)\n    config[\"cloud_server\"][\"username\"] = None\n    config[\"cloud_server\"][\"password\"] = None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the action and command from an instruction", "response": "def instruction(self, val):\n        \"\"\"Set the action and command from an instruction\"\"\"\n        self._instruction = val\n        if isinstance(val, tuple):\n            if len(val) is 2:\n                self._action, self.command = val\n            else:\n                self._action, self.command, self.extra = val\n        else:\n            split = val.split(\" \", 1)\n            if split[0] == \"FROM\":\n                split = val.split(\" \", 2)\n\n            if len(split) == 3:\n                self._action, self.command, self.extra = split\n            else:\n                self._action, self.command = split"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_string(self):\n        if type(self.instruction) is str:\n            return self.instruction\n\n        if self.action == \"FROM\" and not isinstance(self.command, six.string_types):\n            extra = \"\" if self.extra is NotSpecified else \" {0}\".format(self.extra)\n            return \"{0} {1}{2}\".format(self.action, self.command.from_name, extra)\n        else:\n            return \"{0} {1}\".format(self.action, self.command)", "response": "Return the command as a single string for the docker file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef external_dependencies(self):\n        found = []\n        for dep in self.dependent_images:\n            if isinstance(dep, six.string_types):\n                if dep not in found:\n                    yield dep\n                    found.append(dep)", "response": "Return all the external images this Dockerfile will depend on"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dependent_images(self):\n        found = []\n        for command in self.commands:\n            dep = command.dependent_image\n            if dep:\n                if dep not in found:\n                    yield dep\n                    found.append(dep)", "response": "Returns an iterator over the dependent images of this container."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate whether the left - hand side and right - hand side equations are correct.", "response": "def validate(self):\n        \"\"\"\n        Validates whether the ODE equations provided make sense  i.e. the number of right-hand side equations\n        match the number of left-hand side equations.\n        \"\"\"\n        if self.left_hand_side.rows != self.right_hand_side.rows:\n            raise ValueError(\"There are {0} left hand side equations and {1} right hand side equations. \"\n                             \"The same number is expected.\".format(self.left_hand_side.rows, self.right_hand_side.rows))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate and returns the right hand side of the model as a callable function that takes two parameters values for variables and values for constants and returns the right hand side of the model as a callable function that takes two parameters values for variables and values for constants.", "response": "def right_hand_side_as_function(self):\n        \"\"\"\n        Generates and returns the right hand side of the model as a callable function that takes two parameters:\n        values for variables and values for constants,\n        e.g. `f(values_for_variables=[1,2,3], values_for_constants=[3,4,5])\n\n        This function is directly used in `means.simulation.Simulation`\n        :return:\n        :rtype: function\n        \"\"\"\n        wrapped_functions = self._right_hand_side_as_numeric_functions\n\n        def f(values_for_variables, values_for_constants):\n            all_values = np.concatenate((values_for_constants, values_for_variables))\n            ans = np.array([w_f(*all_values) for w_f in wrapped_functions])\n            return ans\n\n        return f"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef descriptor_for_symbol(self, symbol):\n        if isinstance(symbol, basestring):\n            symbol = sympy.Symbol(symbol)\n\n        try:\n            return self._descriptions_dict[symbol]\n        except KeyError:\n            raise KeyError(\"Symbol {0!r} not found in left-hand-side of the equations\".format(symbol))", "response": "Returns the descriptor associated with that symbol."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _repr_latex_(self):\n        # TODO: we're mixing HTML with latex here. That is not necessarily a good idea, but works\n        # with IPython 1.2.0. Once IPython 2.0 is released, this needs to be changed to _ipython_display_\n        lines = []\n        lines.append(r\"<h1>{0}</h1>\".format(self.__class__.__name__))\n\n        lines.append(\"<p>Method: <code>{0!r}</code></p>\".format(self.method))\n        lines.append(\"<p>Parameters: <code>{0!r}</code></p>\".format(self.parameters))\n        lines.append(\"<p>Terms:</p>\")\n        lines.append(\"<ul>\")\n        lines.extend(['<li><code>{0!r}</code></li>'.format(lhs) for lhs in self.left_hand_side_descriptors])\n        lines.append(\"</ul>\")\n        lines.append('<hr />')\n        lines.append(r\"\\begin{align*}\")\n        for lhs, rhs in zip(self.left_hand_side_descriptors, self.right_hand_side):\n            lines.append(r\"\\dot{{{0}}} &= {1} \\\\\".format(sympy.latex(lhs.symbol), sympy.latex(rhs)))\n        lines.append(r\"\\end{align*}\")\n        return \"\\n\".join(lines)", "response": "Return a string representation of the ODEProblem object in LaTeX."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decensor_iter(posts_info: Iterable[dict], site_url: str = DEFAULT_SITE\n                 ) -> Generator[dict, None, None]:\n    \"\"\"Apply decensoring on an iterable of posts info dicts from Danbooru API.\n    Any censored post is automatically decensored if needed.\"\"\"\n    for info in posts_info:\n        yield decensor(info, site_url)", "response": "Apply decensoring on an iterable of posts info dicts from Danbooru API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decensor(post_info: dict, site_url: str = DEFAULT_SITE) -> dict:\n    \"Decensor a post info dict from Danbooru API if needed.\"\n    return post_info \\\n           if \"md5\" in post_info else fill_missing_info(post_info, site_url)", "response": "Decensor a post info dict from Danbooru API if needed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd missing info in a censored post info dict.", "response": "def fill_missing_info(info: dict, site_url: str = DEFAULT_SITE) -> dict:\n    \"Add missing info in a censored post info dict.\"\n    try:\n        md5, ext = find_censored_md5ext(info[\"id\"])\n    except TypeError:  # None returned by find_..\n        return info\n\n    sample_ext = \"jpg\" if ext != \"zip\" else \"webm\"\n\n    if info[\"id\"] > 2_800_000:\n        site_url   = site_url.rstrip(\"/\")\n        file_url   = f\"{site_url}/data/{md5}.{ext}\"\n        sample_url = f\"{site_url}/data/sample/sample-{md5}.{sample_ext}\"\n    else:\n        server     = \"raikou2\" if info[\"id\"] > 850_000 else \"raikou1\"\n        url_base   = f\"https://{server}.donmai.us\"\n        file_url   = f\"{url_base}/{md5[:2]}/{md5[2:4]}/{md5}.{ext}\"\n        sample_url = (f\"{url_base}/sample/{md5[:2]}/{md5[2:4]}/\"\n                      f\"sample-{md5}.{sample_ext}\")\n\n    if info[\"image_width\"] < 850:\n        sample_url = file_url\n\n    return {**info, **{\n        \"file_ext\":         ext,\n        \"md5\":              md5,\n        \"file_url\":         file_url,\n        \"large_file_url\":   sample_url,\n        \"preview_file_url\": (f\"https://raikou4.donmai.us/preview/\"\n                             f\"{md5[:2]}/{md5[2:4]}/{md5}.jpg\"),\n    }}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_censored_md5ext(post_id: int) -> Optional[str]:\n    \"Find MD5 for a censored post's ID, return None if can't find.\"\n    try:\n        last_pull_date = LAST_PULL_DATE_FILE.read_text().strip()\n    except FileNotFoundError:\n        last_pull_date = \"\"\n\n    date = datetime.utcnow()\n    date = f\"{date.year}{date.month}{date.day}\"\n\n    if last_pull_date != date:\n        update_batches()\n        LAST_PULL_DATE_FILE.parent.mkdir(exist_ok=True, parents=True)\n        LAST_PULL_DATE_FILE.write_text(date)\n\n    # Faster than converting every ID in files to int\n    post_id = str(post_id)\n\n    for batch in BATCHES_DIR.iterdir():\n        with open(batch, \"r\") as content:\n            for line in content:\n                an_id, its_md5_ext = line.split(\":\")\n\n                if post_id == an_id:\n                    return its_md5_ext.rstrip().split(\".\")\n\n    return None", "response": "Find MD5 for a censored post s ID return None if can t find."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate id : md5. ext batches from Dencensooru s repository.", "response": "def update_batches() -> None:\n    \"Update id:md5.ext batches from Dencensooru's repository.\"\n    batches_data  = requests.get(BATCHES_API_URL).json()\n    batches_url   = {i[\"name\"]: i[\"download_url\"] for i in batches_data\n                     if i[\"type\"] == \"file\"}\n    order_batches = sorted(batches_url, key=int)\n\n    try:\n        existing = set(os.listdir(BATCHES_DIR))\n    except FileNotFoundError:\n        BATCHES_DIR.mkdir(parents=True)\n        existing = set()\n\n    def get_batch(name: str) -> None:\n        if name in existing and name != order_batches[-1]:\n            return\n\n        answer = requests.get(batches_url[name])\n        try:\n            answer.raise_for_status()\n        except requests.RequestException:\n            return\n\n        with AtomicFile(BATCHES_DIR / name, \"w\") as file:\n            file.write(answer.text)\n\n    ThreadPool(8).map(get_batch, order_batches)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _init_map(self):\n        super(IRTItemFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['decimalValues']['difficulty'] = \\\n            self._decimal_value_metadata['default_decimal_values'][1]\n        self.my_osid_object_form._my_map['decimalValues']['discrimination'] = \\\n            self._decimal_value_metadata['default_decimal_values'][1]\n        self.my_osid_object_form._my_map['decimalValues']['pseudoGuessing'] = \\\n            self._decimal_value_metadata['default_decimal_values'][1]", "response": "Initialize the map with the values for the class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_difficulty_value(self, difficulty):\n        if not isinstance(difficulty, float):\n            raise InvalidArgument('difficulty value must be a decimal')\n        self.add_decimal_value(difficulty, 'difficulty')", "response": "set the difficulty value for the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_pseudo_guessing_value(self, pseudo_guessing):\n        if not isinstance(pseudo_guessing, float):\n            raise InvalidArgument('pseudo-guessing value must be a decimal')\n        self.add_decimal_value(pseudo_guessing, 'pseudoGuessing')", "response": "set the pseudo - guessing value for the resource class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _view_filter(self):\n        view_filter = OsidSession._view_filter(self)\n        if self._sequestered_view == SEQUESTERED:\n            view_filter['sequestered'] = False\n        return view_filter", "response": "Returns a dictionary of the filter parameters to be used in the view function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the AssessmentPart specified by its Id.", "response": "def get_assessment_part(self, assessment_part_id):\n        \"\"\"Gets the ``AssessmentPart`` specified by its ``Id``.\n\n        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to retrieve\n        return: (osid.assessment.authoring.AssessmentPart) - the\n                returned ``AssessmentPart``\n        raise:  NotFound - no ``AssessmentPart`` found with the given\n                ``Id``\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(assessment_part_id, 'assessment_authoring').get_identifier())},\n                 **self._view_filter()))\n        return objects.AssessmentPart(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting an AssessmentPartList corresponding to the given IdList.", "response": "def get_assessment_parts_by_ids(self, assessment_part_ids):\n        \"\"\"Gets an ``AssessmentPartList`` corresponding to the given ``IdList``.\n\n        arg:    assessment_part_ids (osid.id.IdList): the list of\n                ``Ids`` to retrieve\n        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPart`` list\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``assessment_part_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in assessment_part_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'assessment_authoring').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.AssessmentPartList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_parts_by_genus_type(self, assessment_part_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(assessment_part_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AssessmentPartList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an AssessmentPartList corresponding to the given assessment part genus Type which does not include assessment parts of types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_parts_for_assessment(self, assessment_id):\n        # Implemented from template for\n        # osid.learning.ActivityLookupSession.get_activities_for_objective_template\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'assessmentId': str(assessment_id)},\n                 **self._view_filter()))\n        return objects.AssessmentPartList(result, runtime=self._runtime)", "response": "Gets an AssessmentPartList for the given assessment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all AssessmentParts in this assessment set.", "response": "def get_assessment_parts(self):\n        \"\"\"Gets all ``AssessmentParts``.\n\n        return: (osid.assessment.authoring.AssessmentPartList) - a list\n                of ``AssessmentParts``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.AssessmentPartList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an AssessmentPartList for the given assessment part.", "response": "def get_assessment_parts_for_assessment_part(self, assessment_part_id):\n        \"\"\"Gets an ``AssessmentPart`` for the given assessment part.\n\n        arg:    assessment_part_id (osid.id.Id): an assessment part ``Id``\n        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPart`` list\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # NOT IN SPEC - Implemented from\n        # osid.assessment_authoring.AssessmentPartLookupSession.additional_methods\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'assessmentPartId': str(assessment_part_id)},\n                 **self._view_filter()))\n        return objects.AssessmentPartList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_assessment_parts_by_query(self, assessment_part_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in assessment_part_query._query_terms:\n            if '$in' in assessment_part_query._query_terms[term] and '$nin' in assessment_part_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': assessment_part_query._query_terms[term]['$in']}},\n                             {term: {'$nin': assessment_part_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: assessment_part_query._query_terms[term]})\n        for term in assessment_part_query._keyword_terms:\n            or_list.append({term: assessment_part_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('assessment_authoring',\n                                             collection='AssessmentPart',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.AssessmentPartList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of AssessmentParts matching the given assessment part query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessment_part_form_for_create_for_assessment(self, assessment_id, assessment_part_record_types):\n        # Implemented from template for\n        # osid.learning.ActivityAdminSession.get_activity_form_for_create_template\n\n        if not isinstance(assessment_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in assessment_part_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if assessment_part_record_types == []:\n            # WHY are we passing bank_id = self._catalog_id below, seems redundant:\n            obj_form = objects.AssessmentPartForm(\n                bank_id=self._catalog_id,\n                assessment_id=assessment_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.AssessmentPartForm(\n                bank_id=self._catalog_id,\n                record_types=assessment_part_record_types,\n                assessment_id=assessment_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the assessment part form for creating new assessment parts for an assessment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new assessment part for an Assessment.", "response": "def create_assessment_part_for_assessment(self, assessment_part_form):\n        \"\"\"Creates a new assessment part.\n\n        arg:    assessment_part_form\n                (osid.assessment.authoring.AssessmentPartForm):\n                assessment part form\n        return: (osid.assessment.authoring.AssessmentPart) - the new\n                part\n        raise:  IllegalState - ``assessment_part_form`` already used in\n                a create transaction\n        raise:  InvalidArgument - ``assessment_part_form`` is invalid\n        raise:  NullArgument - ``assessment_part_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_part_form`` did not originate\n                from\n                ``get_assessment_part_form_for_create_for_assessment()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_part_form, ABCAssessmentPartForm):\n            raise errors.InvalidArgument('argument type is not an AssessmentPartForm')\n        if assessment_part_form.is_for_update():\n            raise errors.InvalidArgument('the AssessmentPartForm is for update only, not create')\n        try:\n            if self._forms[assessment_part_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('assessment_part_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('assessment_part_form did not originate from this session')\n        if not assessment_part_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(assessment_part_form._my_map)\n\n        self._forms[assessment_part_form.get_id().get_identifier()] = CREATED\n        result = objects.AssessmentPart(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the assessment part form for creating new assessment parts under another assessment part.", "response": "def get_assessment_part_form_for_create_for_assessment_part(self, assessment_part_id, assessment_part_record_types):\n        \"\"\"Gets the assessment part form for creating new assessment parts under another assessment part.\n\n        A new form should be requested for each create transaction.\n\n        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n        arg:    assessment_part_record_types (osid.type.Type[]): array\n                of assessment part record types to be included in the\n                create operation or an empty list if none\n        return: (osid.assessment.authoring.AssessmentPartForm) - the\n                assessment part form\n        raise:  NotFound - ``assessment_part_id`` is not found\n        raise:  NullArgument - ``assessment_part_id`` or\n                ``assessment_part_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - unable to get form for requested record\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not isinstance(assessment_part_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in assessment_part_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if assessment_part_record_types == []:\n            assessment_part_record_types = None\n        mgr = self._get_provider_manager('ASSESSMENT_AUTHORING', local=True)\n        lookup_session = mgr.get_assessment_part_lookup_session_for_bank(self._catalog_id, proxy=self._proxy)\n        child_parts = lookup_session.get_assessment_parts_for_assessment_part(assessment_part_id)\n        mdata = {}\n        # Check for underlying Parts, whether Sections and set appropriate mdata overrides:\n        if child_parts.available == 0:\n            pass\n        else:\n            mdata['sequestered'] = {}\n            mdata['sequestered']['is_read_only'] = True\n            mdata['sequestered']['is_required'] = True\n            if child_parts.available() > 0 and child_parts.next().is_section():\n                mdata['sequestered']['default_boolean_values'] = [False]\n            else:\n                mdata['sequestered']['default_boolean_values'] = [True]\n        # WHY are we passing bank_id = self._catalog_id below, seems redundant:\n        obj_form = objects.AssessmentPartForm(\n            bank_id=self._catalog_id,\n            record_types=assessment_part_record_types,\n            assessment_part_id=assessment_part_id,\n            catalog_id=self._catalog_id,\n            runtime=self._runtime,\n            mdata=mdata)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_assessment_part_form_for_update(self, assessment_part_id):\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_part_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        if (assessment_part_id.get_identifier_namespace() != 'assessment_authoring.AssessmentPart' or\n                assessment_part_id.get_authority() != self._authority):\n            raise errors.InvalidArgument()\n        result = collection.find_one({'_id': ObjectId(assessment_part_id.get_identifier())})\n\n        mdata = {}\n        if not result['assessmentPartId']:\n            pass\n        else:\n            parent_part_id = Id(result['assessmentPartId'])\n            mgr = self._get_provider_manager('ASSESSMENT_AUTHORING', local=True)\n            lookup_session = mgr.get_assessment_part_lookup_session_for_bank(self._catalog_id, proxy=self._proxy)\n            if lookup_session.get_assessment_parts_for_assessment_part(parent_part_id).available() > 1:\n                mdata['sequestered']['is_read_only'] = True\n                mdata['sequestered']['is_required'] = True\n        obj_form = objects.AssessmentPartForm(osid_object_map=result,\n                                              runtime=self._runtime,\n                                              proxy=self._proxy,\n                                              mdata=mdata)\n        self._forms[obj_form.get_id().get_identifier()] = not UPDATED\n\n        return obj_form", "response": "Gets the assessment part form for updating an existing assessment part."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate an existing assessment part.", "response": "def update_assessment_part(self, assessment_part_id, assessment_part_form):\n        \"\"\"Updates an existing assessment part.\n\n        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart``\n        arg:    assessment_part_form\n                (osid.assessment.authoring.AssessmentPartForm): part\n                form\n        raise:  NotFound - ``assessment_part_id`` not found\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_part_form`` is not of this\n                service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        if not isinstance(assessment_part_form, ABCAssessmentPartForm):\n            raise errors.InvalidArgument('argument type is not an AssessmentPartForm')\n        if not assessment_part_form.is_for_update():\n            raise errors.InvalidArgument('the AssessmentPartForm is for update only, not create')\n        try:\n            if self._forms[assessment_part_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('assessment_part_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('assessment_part_form did not originate from this session')\n        if not assessment_part_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(assessment_part_form._my_map)\n\n        self._forms[assessment_part_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.AssessmentPart(\n            osid_object_map=assessment_part_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_assessment_part(self, assessment_part_id):\n        # Should be implemented from template for\n        # osid.learning.ObjectiveAdminSession.delete_objective_template\n        # but need to handle magic part delete ...\n\n        if not isinstance(assessment_part_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        if collection.find({'assessmentPartId': str(assessment_part_id)}).count() != 0:\n            raise errors.IllegalState('there are still AssessmentParts associated with this AssessmentPart')\n\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        try:\n            apls = get_assessment_part_lookup_session(runtime=self._runtime,\n                                                      proxy=self._proxy)\n            apls.use_unsequestered_assessment_part_view()\n            apls.use_federated_bank_view()\n            part = apls.get_assessment_part(assessment_part_id)\n            part.delete()\n        except AttributeError:\n            collection.delete_one({'_id': ObjectId(assessment_part_id.get_identifier())})", "response": "Removes an asessment part and all mapped items."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef alias_assessment_part(self, assessment_part_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=assessment_part_id, equivalent_id=alias_id)", "response": "Adds an Id to an AssessmentPart for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the list of AssessmentPartIds associated with an Bank.", "response": "def get_assessment_part_ids_by_bank(self, bank_id):\n        \"\"\"Gets the list of ``AssessmentPartIds`` associated with an ``Bank``.\n\n        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n        return: (osid.id.IdList) - list of related assessment part\n                ``Ids``\n        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for assessment_part in self.get_assessment_parts_by_bank(bank_id):\n            id_list.append(assessment_part.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_parts_by_bank(self, bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('ASSESSMENT_AUTHORING', local=True)\n        lookup_session = mgr.get_assessment_part_lookup_session_for_bank(bank_id, proxy=self._proxy)\n        lookup_session.use_isolated_bank_view()\n        return lookup_session.get_assessment_parts()", "response": "Gets the list of assessment parts associated with an Bank."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_assessment_part_ids_by_banks(self, bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for assessment_part in self.get_assessment_parts_by_banks(bank_ids):\n            id_list.append(assessment_part.get_id())\n        return IdList(id_list)", "response": "Gets the list of AssessmentPart Ids corresponding to a list of Banks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assessment_parts_by_banks(self, bank_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        assessment_part_list = []\n        for bank_id in bank_ids:\n            assessment_part_list += list(\n                self.get_assessment_parts_by_bank(bank_id))\n        return objects.AssessmentPartList(assessment_part_list)", "response": "Gets the list of assessment parts corresponding to a list of Banks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_bank_ids_by_assessment_part(self, assessment_part_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('ASSESSMENT_AUTHORING', local=True)\n        lookup_session = mgr.get_assessment_part_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_bank_view()\n        assessment_part = lookup_session.get_assessment_part(assessment_part_id)\n        id_list = []\n        for idstr in assessment_part._my_map['assignedBankIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)", "response": "Gets the Bank Ids mapped to an AssessmentPart."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_banks_by_assessment_part(self, assessment_part_id):\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        return lookup_session.get_banks_by_ids(\n            self.get_bank_ids_by_assessment_part(assessment_part_id))", "response": "Gets the Banks mapped to an AssessmentPart."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a list of bank including and under the given bank node in which any assessment part can be assigned.", "response": "def get_assignable_bank_ids(self, bank_id):\n        \"\"\"Gets a list of bank including and under the given bank node in which any assessment part can be assigned.\n\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        return: (osid.id.IdList) - list of assignable bank ``Ids``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # This will likely be overridden by an authorization adapter\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        banks = lookup_session.get_banks()\n        id_list = []\n        for bank in banks:\n            id_list.append(bank.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assign_assessment_part_to_bank(self, assessment_part_id, bank_id):\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._assign_object_to_catalog(assessment_part_id, bank_id)", "response": "Adds an existing AssessmentPart to an Bank."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove an AssessmentPart from an Bank.", "response": "def unassign_assessment_part_from_bank(self, assessment_part_id, bank_id):\n        \"\"\"Removes an ``AssessmentPart`` from an ``Bank``.\n\n        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        raise:  NotFound - ``assessment_part_id`` or ``bank_id`` not\n                found or ``assessment_part_id`` not assigned to\n                ``bank_id``\n        raise:  NullArgument - ``assessment_part_id`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_bank_lookup_session(proxy=self._proxy)\n        lookup_session.get_bank(bank_id)  # to raise NotFound\n        self._unassign_object_from_catalog(assessment_part_id, bank_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reassign_assessment_part_to_bank(self, assessment_part_id, from_biank_id, to_bank_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.reassign_resource_to_bin\n        self.assign_assessment_part_to_bank(assessment_part_id, to_bank_id)\n        try:\n            self.unassign_assessment_part_from_bank(assessment_part_id, from_biank_id)\n        except:  # something went wrong, roll back assignment to to_bank_id\n            self.unassign_assessment_part_from_bank(assessment_part_id, to_bank_id)\n            raise", "response": "Moves an AssessmentPart from one Bank to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the list of items mapped to the given AssessmentPart.", "response": "def get_assessment_part_items(self, assessment_part_id):\n        \"\"\"Gets the list of items mapped to the given ``AssessmentPart``.\n\n        In plenary mode, the returned list contains all known items or\n        an error results. Otherwise, the returned list may contain only\n        those items that are accessible through this session.\n\n        arg:    assessment_part_id (osid.id.Id): ``Id`` of the\n                ``AssessmentPart``\n        return: (osid.assessment.ItemList) - list of items\n        raise:  NotFound - ``assessment_part_id`` not found\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        mgr = self._get_provider_manager('ASSESSMENT_AUTHORING', local=True)\n        lookup_session = mgr.get_assessment_part_lookup_session(proxy=self._proxy)\n        if self._catalog_view == ISOLATED:\n            lookup_session.use_isolated_bank_view()\n        else:\n            lookup_session.use_federated_bank_view()\n        item_ids = lookup_session.get_assessment_part(assessment_part_id).get_item_ids()\n        mgr = self._get_provider_manager('ASSESSMENT')\n        lookup_session = mgr.get_item_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_bank_view()\n        return lookup_session.get_items_by_ids(item_ids)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assessment_parts_by_item(self, item_id):\n        # Implemented from template for\n        # osid.repository.AssetCompositionSession.get_compositions_by_asset\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'itemIds': {'$in': [str(item_id)]}},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AssessmentPartList(result, runtime=self._runtime)", "response": "Gets the assessment parts containing the given item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_item(self, item_id, assessment_part_id):\n        # The item found check may want to be run through _get_provider_manager\n        # so as to ensure access control:\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        if not isinstance(item_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        if (not isinstance(assessment_part_id, ABCId) and\n                assessment_part_id.get_identifier_namespace() != 'assessment_authoring.AssessmentPart'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        if item_id.get_identifier_namespace() != 'assessment.Item':\n            if item_id.get_authority() != self._authority:\n                raise errors.InvalidArgument()\n            else:\n                mgr = self._get_provider_manager('ASSESSMENT')\n                admin_session = mgr.get_item_admin_session_for_bank(self._catalog_id, proxy=self._proxy)\n                item_id = admin_session._get_item_id_with_enclosure(item_id)\n        collection = JSONClientValidated('assessment',\n                                         collection='Item',\n                                         runtime=self._runtime)\n        item = collection.find_one({'_id': ObjectId(item_id.get_identifier())})\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        assessment_part = collection.find_one({'_id': ObjectId(assessment_part_id.get_identifier())})\n        if 'itemIds' in assessment_part:\n            if str(item_id) not in assessment_part['itemIds']:\n                assessment_part['itemIds'].append(str(item_id))\n        else:\n            assessment_part['itemIds'] = [str(item_id)]\n        collection.save(assessment_part)", "response": "Adds an item to an assessment part."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmoving an item in an assessment part in front of a reference item.", "response": "def move_item_ahead(self, item_id, assessment_part_id, reference_id):\n        \"\"\"Reorders items in an assessment part by moving the specified item in front of a reference item.\n\n        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        arg:    assessment_part_id (osid.id.Id): ``Id`` of the\n                ``AssessmentPartId``\n        arg:    reference_id (osid.id.Id): ``Id`` of the reference\n                ``Item``\n        raise:  NotFound - ``item_id`` or ``reference_id``  ``not found\n                in assessment_part_id``\n        raise:  NullArgument - ``item_id, reference_id`` or\n                ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (not isinstance(assessment_part_id, ABCId) and\n                assessment_part_id.get_identifier_namespace() != 'assessment_authoring.AssessmentPart'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        assessment_part_map, collection = self._get_assessment_part_collection(assessment_part_id)\n        assessment_part_map['itemIds'] = move_id_ahead(item_id, reference_id, assessment_part_map['itemIds'])\n        collection.save(assessment_part_map)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef move_item_behind(self, item_id, assessment_part_id, reference_id):\n        if (not isinstance(assessment_part_id, ABCId) and\n                assessment_part_id.get_identifier_namespace() != 'assessment_authoring.AssessmentPart'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        assessment_part_map, collection = self._get_assessment_part_collection(assessment_part_id)\n        assessment_part_map['itemIds'] = move_id_behind(item_id, reference_id, assessment_part_map['itemIds'])\n        collection.save(assessment_part_map)", "response": "Moves the specified item behind of a reference item."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreorder items in an Assessment Part", "response": "def order_items(self, item_ids, assessment_part_id):\n        \"\"\"Reorders a set of items in an assessment part.\n\n        arg:    item_ids (osid.id.Id[]): ``Ids`` for a set of ``Items``\n        arg:    assessment_part_id (osid.id.Id): ``Id`` of the\n                ``AssessmentPartId``\n        raise:  NotFound - ``assessment_part_id`` not found or, an\n                ``item_id`` not related to ``assessment_part_id``\n        raise:  NullArgument - ``item_ids`` or ``agenda_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (not isinstance(assessment_part_id, ABCId) and\n                assessment_part_id.get_identifier_namespace() != 'assessment_authoring.AssessmentPart'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        assessment_part_map, collection = self._get_assessment_part_collection(assessment_part_id)\n        assessment_part_map['itemIds'] = order_ids(item_ids, assessment_part_map['itemIds'])\n        collection.save(assessment_part_map)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_item(self, item_id, assessment_part_id):\n        if (not isinstance(assessment_part_id, ABCId) and\n                assessment_part_id.get_identifier_namespace() != 'assessment_authoring.AssessmentPart'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        assessment_part_map, collection = self._get_assessment_part_collection(assessment_part_id)\n        try:\n            assessment_part_map['itemIds'].remove(str(item_id))\n        except (KeyError, ValueError):\n            raise errors.NotFound()\n        collection.save(assessment_part_map)", "response": "Removes an Item from an AssessmentPart."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_assessment_part_collection(self, assessment_part_id):\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='AssessmentPart',\n                                         runtime=self._runtime)\n        assessment_part_map = collection.find_one({'_id': ObjectId(assessment_part_id.get_identifier())})\n        if 'itemIds' not in assessment_part_map:\n            raise errors.NotFound('no Items are assigned to this AssessmentPart')\n        return assessment_part_map, collection", "response": "Returns a Mongo Collection and AssessmentPart given an AssessmentPart Id"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the SequenceRule specified by its Id.", "response": "def get_sequence_rule(self, sequence_rule_id):\n        \"\"\"Gets the ``SequenceRule`` specified by its ``Id``.\n\n        arg:    sequence_rule_id (osid.id.Id): ``Id`` of the\n                ``SequenceRule``\n        return: (osid.assessment.authoring.SequenceRule) - the sequence\n                rule\n        raise:  NotFound - ``sequence_rule_id`` not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(sequence_rule_id, 'assessment_authoring').get_identifier())},\n                 **self._view_filter()))\n        return objects.SequenceRule(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a SequenceRuleList corresponding to the given IdList.", "response": "def get_sequence_rules_by_ids(self, sequence_rule_ids):\n        \"\"\"Gets a ``SequenceRuleList`` corresponding to the given ``IdList``.\n\n        arg:    sequence_rule_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list\n        raise:  NotFound - a ``Id was`` not found\n        raise:  NullArgument - ``sequence_rule_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in sequence_rule_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'assessment_authoring').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.SequenceRuleList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a SequenceRuleList corresponding to the given sequence rule genus Type which does not include sequence rules of genus types derived from the specified Type.", "response": "def get_sequence_rules_by_genus_type(self, sequence_rule_genus_type):\n        \"\"\"Gets a ``SequenceRuleList`` corresponding to the given sequence rule genus ``Type`` which does not include sequence rule of genus types derived from the specified ``Type``.\n\n        arg:    sequence_rule_genus_type (osid.type.Type): a sequence\n                rule genus type\n        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list\n        raise:  NullArgument - ``sequence_rule_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(sequence_rule_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.SequenceRuleList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a SequenceRuleList for the given assessment part.", "response": "def get_sequence_rules_for_assessment_part(self, assessment_part_id):\n        \"\"\"Gets a ``SequenceRuleList`` for the given source assessment part.\n\n        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.learning.ActivityLookupSession.get_activities_for_objective_template\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'assessmentPartId': str(assessment_part_id)},\n                 **self._view_filter()))\n        return objects.SequenceRuleList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_sequence_rules_for_assessment(self, assessment_id):\n        # First, recursively get all the partIds for the assessment\n        def get_all_children_part_ids(part):\n            child_ids = []\n            if part.has_children():\n                child_ids = list(part.get_child_assessment_part_ids())\n                for child in part.get_child_assessment_parts():\n                    child_ids += get_all_children_part_ids(child)\n            return child_ids\n\n        all_assessment_part_ids = []\n\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        lookup_session = mgr.get_assessment_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_bank_view()\n        assessment = lookup_session.get_assessment(assessment_id)\n\n        if assessment.has_children():\n            mgr = self._get_provider_manager('ASSESSMENT_AUTHORING', local=True)\n            lookup_session = mgr.get_assessment_part_lookup_session(proxy=self._proxy)\n            lookup_session.use_federated_bank_view()\n            all_assessment_part_ids = list(assessment.get_child_ids())\n            for child_part_id in assessment.get_child_ids():\n                child_part = lookup_session.get_assessment_part(child_part_id)\n                all_assessment_part_ids += get_all_children_part_ids(child_part)\n\n        id_strs = [str(part_id) for part_id in all_assessment_part_ids]\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'assessmentPartId': {'$in': id_strs}},\n                 **self._view_filter()))\n        return objects.SequenceRuleList(result, runtime=self._runtime)", "response": "Gets a SequenceRuleList for an entire assessment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all SequenceRules in this hierarchy.", "response": "def get_sequence_rules(self):\n        \"\"\"Gets all ``SequenceRules``.\n\n        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.SequenceRuleList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_sequence_rule_form_for_create(self, assessment_part_id, next_assessment_part_id, sequence_rule_record_types):\n        for arg in sequence_rule_record_types:\n            if not isinstance(arg, ABCId):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID ${arg0_type}')\n        if sequence_rule_record_types == []:\n            obj_form = objects.SequenceRuleForm(\n                bank_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy,\n                next_assessment_part_id=next_assessment_part_id,\n                assessment_part_id=assessment_part_id)\n        else:\n            obj_form = objects.SequenceRuleForm(\n                bank_id=self._catalog_id,\n                record_types=sequence_rule_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy,\n                next_assessment_part_id=next_assessment_part_id,\n                assessment_part_id=assessment_part_id)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the sequence rule form for creating new sequence rules between two assessment parts."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new SequenceRule.", "response": "def create_sequence_rule(self, sequence_rule_form):\n        \"\"\"Creates a new ``SequenceRule``.\n\n        arg:    sequence_rule_form\n                (osid.assessment.authoring.SequenceRuleForm): the form\n                for this ``SequenceRule``\n        return: (osid.assessment.authoring.SequenceRule) - the new\n                ``SequenceRule``\n        raise:  IllegalState - ``sequence_rule_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``sequence_rule_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_form`` did not originate\n                from ``get_sequence_rule_form_for_create()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        if not isinstance(sequence_rule_form, ABCSequenceRuleForm):\n            raise errors.InvalidArgument('argument type is not an SequenceRuleForm')\n        if sequence_rule_form.is_for_update():\n            raise errors.InvalidArgument('the SequenceRuleForm is for update only, not create')\n        try:\n            if self._forms[sequence_rule_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('sequence_rule_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('sequence_rule_form did not originate from this session')\n        if not sequence_rule_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(sequence_rule_form._my_map)\n\n        self._forms[sequence_rule_form.get_id().get_identifier()] = CREATED\n        result = objects.SequenceRule(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating an existing sequence rule.", "response": "def update_sequence_rule(self, sequence_rule_form):\n        \"\"\"Updates an existing sequence rule.\n\n        arg:    sequence_rule_form\n                (osid.assessment.authoring.SequenceRuleForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - ``sequence_rule_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``sequence_rule_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_form`` did not originate\n                from ``get_sequence_rule_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        if not isinstance(sequence_rule_form, ABCSequenceRuleForm):\n            raise errors.InvalidArgument('argument type is not an SequenceRuleForm')\n        if not sequence_rule_form.is_for_update():\n            raise errors.InvalidArgument('the SequenceRuleForm is for update only, not create')\n        try:\n            if self._forms[sequence_rule_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('sequence_rule_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('sequence_rule_form did not originate from this session')\n        if not sequence_rule_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(sequence_rule_form._my_map)\n\n        self._forms[sequence_rule_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.SequenceRule(\n            osid_object_map=sequence_rule_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes a ``SequenceRule``. arg: sequence_rule_id (osid.id.Id): the ``Id`` of the ``SequenceRule`` to remove raise: NotFound - ``sequence_rule_id`` not found raise: NullArgument - ``sequence_rule_id`` is ``null`` raise: OperationFailed - unable to complete request raise: PermissionDenied - authorization failure *compliance: mandatory -- This method must be implemented.*", "response": "def delete_sequence_rule(self, sequence_rule_id):\n        \"\"\"Deletes a ``SequenceRule``.\n\n        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule`` to remove\n        raise:  NotFound - ``sequence_rule_id`` not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('assessment_authoring',\n                                         collection='SequenceRule',\n                                         runtime=self._runtime)\n        if not isinstance(sequence_rule_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        sequence_rule_map = collection.find_one(\n            dict({'_id': ObjectId(sequence_rule_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.SequenceRule(osid_object_map=sequence_rule_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(sequence_rule_id.get_identifier())})"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef alias_sequence_rule(self, sequence_rule_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=sequence_rule_id, equivalent_id=alias_id)", "response": "Adds an Id to a sequence rule."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the Id of the Agent identified in this authentication credential.", "response": "def get_agent_id(self):\n        \"\"\"Gets the ``Id`` of the ``Agent`` identified in this authentication credential.\n\n        :return: the ``Agent Id``\n        :rtype: ``osid.id.Id``\n\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: The Agent should be determined at the\n        time this credential is created.\n\n        \"\"\"\n        if self._django_user is not None:\n            if self._use_user_id:\n                identifier = self._django_user.id\n            else:\n                identifier = self._django_user.get_username()\n            return Id(identifier=identifier,\n                      namespace='osid.agent.Agent',\n                      authority='MIT-ODL')\n        else:\n            # perhaps this id should come from django settings?\n            return Id(identifier='MC3GUE$T@MIT.EDU',\n                      namespace='osid.agent.Agent',\n                      authority='MIT-ODL')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the Agent identified in this authentication credential.", "response": "def get_agent(self):\n        \"\"\"Gets the ``Agent`` identified in this authentication credential.\n\n        :return: the ``Agent``\n        :rtype: ``osid.authentication.Agent``\n        :raise: ``OperationFailed`` -- unable to complete request\n\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        agent_id = self.get_agent_id()\n        return Agent(identifier=agent_id.identifier,\n                     namespace=agent_id.namespace,\n                     authority=agent_id.authority)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef spectrogram_image(mediafile, dpi=72, outdir=None, outfile=None):\n    # TODO: Add some of the constants below as parameters\n    \"\"\" Create spectrogram image from audio data.\n        Return path to created image file.\n    \"\"\"\n    import matplotlib\n    matplotlib.use('Agg')\n\n    import matplotlib.pyplot as plt\n    import scipy.io.wavfile\n    import numpy as np\n    import pylab\n\n    # Output file path\n    outfile = outfile or \"\"\n    if outdir and outfile and os.sep in outfile:\n        raise ValueError(\"Do not specify paths in both output directory '%s' and filename '%s'\" % (outdir, outfile))\n\n    if os.sep not in outfile:\n        if not outfile:\n            outfile = os.path.splitext(os.path.basename(mediafile))[0] + \".jpg\"\n        if not outdir:\n            outdir = os.path.dirname(mediafile)\n        outfile = os.path.join(outdir, outfile)\n\n    with closing(open(os.devnull, \"wb\")) as black_hole:\n        # Read audio data\n        with transcode.to_wav(mediafile) as wavfile:\n            sys.stdout, saved_stdout = black_hole, sys.stdout\n            try:\n                sample_rate, waveform = scipy.io.wavfile.read(wavfile)\n            finally:\n                sys.stdout = saved_stdout\n\n        # Limit data to 10 second window from the middle, else the FFT needs ages\n        data_window = sample_rate * 2 # secs\n        waveform = [i[0] for i in waveform[(len(waveform) - data_window) // 2 : (len(waveform) + data_window) // 2]]\n        # TODO: combine / add the channels to mono\n\n        # Calculate FFT inputs\n        nstep = int(sample_rate * 0.001) # 1ms step\n        nfft = nwin = int(sample_rate * 0.005) & ~1 # 5ms window\n        window = np.hamming(nwin)\n\n        # Create spectrogram\n        pylab.spectral()\n        for khz in (5, 10, 16, 18, 20):\n            pylab.text(data_window / sample_rate * .99, khz * 1000 + 75, \"%d kHz\" % khz, ha=\"right\")\n            pylab.axhline(khz * 1000)\n        pylab.axis(\"off\")\n        pylab.specgram(waveform, NFFT=nfft, Fs=sample_rate, window=window)\n\n        # Write to image\n        try:\n            pylab.savefig(outfile + \".png\", format='png', facecolor=\"#000000\", edgecolor=\"#000000\", \n                dpi=dpi, transparent=True, bbox_inches=\"tight\")\n\n            cmd = [config.CMD_IM_CONVERT, \"-trim\", \"-quality\", \"85\", outfile + \".png\", outfile]\n            subprocess.check_call(cmd, stdout=black_hole, stderr=subprocess.STDOUT)\n        finally:\n            if os.path.exists(outfile + \".png\"):\n                os.remove(outfile + \".png\")\n\n    return outfile", "response": "Create a spectrogram image from audio data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _main():\n    if len(sys.argv) != 2:\n        print(\"Usage: python -m auvyon.imaging.spectrograms <mediafile>\")\n    else:\n        try:\n            print(\"Created %s\" % spectrogram_image(sys.argv[1], dpi=103, outfile=\"spectrogram.jpg\"))\n        except subprocess.CalledProcessError, exc:\n            print(\"Conversion error: %s\" % exc)", "response": "Command line interface for testing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noverride get_genus_type of extended object", "response": "def get_genus_type(self):\n        \"\"\"Overrides get_genus_type of extended object\"\"\"\n        enclosed_object_id = self.get_enclosed_object_id()\n        package = enclosed_object_id.get_identifier_namespace().split('.')[0]\n        obj = enclosed_object_id.get_identifier_namespace().split('.')[1]\n        return Type(\n            authority='OSID.ORG',\n            namespace=package,\n            identifier=obj,\n            display_name=obj,\n            display_label=obj,\n            description=package + ' ' + obj + ' type',\n            domain=package + '.' + obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_enclosed_object(self):\n        if self._enclosed_object is None:\n            enclosed_object_id = self.get_enclosed_object_id()\n            package_name = enclosed_object_id.get_identifier_namespace().split('.')[0]\n            obj_name = enclosed_object_id.get_identifier_namespace().split('.')[1]\n            mgr = self.my_osid_object._get_provider_manager(package_name.upper())\n            try:\n                lookup_session = getattr(mgr, 'get_' + obj_name.lower() + '_lookup_session')(self.my_osid_object._proxy)\n            except TypeError:\n                lookup_session = getattr(mgr, 'get_' + obj_name.lower() + '_lookup_session')()\n            getattr(lookup_session, 'use_federated_' + CATALOG_LOOKUP[package_name] + '_view')()\n            self._enclosed_object = getattr(\n                lookup_session, 'get_' + obj_name.lower())(enclosed_object_id)\n        return self._enclosed_object", "response": "Return the enclosed object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nneeds to clone both the enclosed object + the wrapping asset", "response": "def clone_to(self, target_catalog):\n        \"\"\"need to clone both the enclosed object + the wrapping asset\"\"\"\n        def _clone(obj_id):\n            package_name = obj_id.get_identifier_namespace().split('.')[0]\n            obj_name = obj_id.get_identifier_namespace().split('.')[1].lower()\n\n            catalogs = {\n                'assessment': 'bank',\n                'repository': 'repository'\n            }\n\n            my_catalog_name = catalogs[package_name.lower()]\n\n            mgr = self.my_osid_object._get_provider_manager(package_name.upper())\n\n            if self.my_osid_object._proxy is not None:\n                catalog_lookup_session = getattr(mgr, 'get_' + my_catalog_name + '_lookup_session')(\n                    proxy=self.my_osid_object._proxy\n                )\n            else:\n                catalog_lookup_session = getattr(mgr, 'get_' + my_catalog_name + '_lookup_session')()\n\n            catalog = getattr(catalog_lookup_session, 'get_' + my_catalog_name)(target_catalog.ident)\n\n            if self.my_osid_object._proxy is not None:\n                admin_session = getattr(mgr, 'get_' + obj_name + '_admin_session_for_' + my_catalog_name)(\n                    catalog.ident,\n                    proxy=self.my_osid_object._proxy\n                )\n            else:\n                admin_session = getattr(mgr, 'get_' + obj_name + '_admin_session_for_' + my_catalog_name)(catalog.ident)\n\n            new_obj = getattr(admin_session, 'duplicate_' + obj_name)(obj_id)\n            try:\n                form = getattr(admin_session, 'get_' + obj_name + '_form_for_update')(new_obj.ident)\n                form.set_provenance(str(obj_id))\n                new_obj = getattr(admin_session, 'update_' + obj_name)(form)\n            except AttributeError:\n                pass\n            return new_obj\n\n        enclosed_object_id = self.get_enclosed_object_id()\n        new_enclosed_object = _clone(enclosed_object_id)\n\n        # Let's do the asset here\n        enclosure_id = self.my_osid_object.ident\n        new_asset = _clone(enclosure_id)\n        package_name = enclosure_id.get_identifier_namespace().split('.')[0]\n        obj_name = enclosure_id.get_identifier_namespace().split('.')[1].lower()\n\n        catalogs = {\n            'assessment': 'bank',\n            'repository': 'repository'\n        }\n\n        my_catalog_name = catalogs[package_name.lower()]\n\n        mgr = self.my_osid_object._get_provider_manager(package_name.upper())\n\n        if self.my_osid_object._proxy is not None:\n            catalog_lookup_session = getattr(mgr, 'get_' + my_catalog_name + '_lookup_session')(\n                proxy=self.my_osid_object._proxy\n            )\n        else:\n            catalog_lookup_session = getattr(mgr, 'get_' + my_catalog_name + '_lookup_session')()\n        catalog = getattr(catalog_lookup_session, 'get_' + my_catalog_name)(target_catalog.ident)\n\n        if self.my_osid_object._proxy is not None:\n            admin_session = getattr(mgr, 'get_' + obj_name + '_admin_session_for_' + my_catalog_name)(\n                catalog.ident,\n                proxy=self.my_osid_object._proxy\n            )\n        else:\n            admin_session = getattr(mgr, 'get_' + obj_name + '_admin_session_for_' + my_catalog_name)(catalog.ident)\n\n        form = getattr(admin_session, 'get_' + obj_name + '_form_for_update')(new_asset.ident)\n        form.set_enclosed_object(new_enclosed_object.ident)\n        return getattr(admin_session, 'update_' + obj_name)(form)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _init_metadata(self):\n        self._enclosed_object_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'enclosed_object'),\n            'element_label': 'Enclosed Object',\n            'instructions': 'accepts an osid object Id',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }", "response": "Initialize the metadata for this record"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverrides get_display_name_metadata of extended object", "response": "def get_display_name_metadata(self):\n        \"\"\"Overrides get_display_name_metadata of extended object\"\"\"\n        metadata = dict(self.my_osid_object_form._mdata['display_name'])\n        metadata.update({'read_only': True})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\noverrides get_description_metadata of extended object", "response": "def get_description_metadata(self):\n        \"\"\"Overrides get_description_metadata of extended object\"\"\"\n        metadata = dict(self.my_osid_object_form._description_metadata)\n        metadata.update({'read_only': True})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_genus_type_metadata(self):\n        metadata = dict(self.my_osid_object_form._genus_type_metadata)\n        metadata.update({'read_only': True})\n        return Metadata(**metadata)", "response": "Overrides get_genus_type_metadata of extended object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _initialize_manager(self, runtime):\n        if self._runtime is not None:\n            raise errors.IllegalState('this manager has already been initialized.')\n        self._runtime = runtime\n        self._config = runtime.get_configuration()\n        set_json_client(runtime)", "response": "Sets the runtime configuration and json client"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a display name for this service implementation.", "response": "def get_display_name(self):\n        \"\"\"Gets a display name for this service implementation.\n\n        return: (osid.locale.DisplayText) - a display name\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return DisplayText(\n            text=profile.DISPLAYNAME,\n            language_type=Type(**profile.LANGUAGETYPE),\n            script_type=Type(**profile.SCRIPTTYPE),\n            format_type=Type(**profile.FORMATTYPE))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_description(self):\n        return DisplayText(\n            text=profile.DESCRIPTION,\n            language_type=Type(**profile.LANGUAGETYPE),\n            script_type=Type(**profile.SCRIPTTYPE),\n            format_type=Type(**profile.FORMATTYPE))", "response": "Gets a description of this service implementation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_args():\n\n    description = \"The Daemon send various value for zabbix_sender.\"\n    parser = argparse.ArgumentParser(description)\n\n    parser.add_argument('--config', '-c',\n                        default='conf/defaults.cfg',\n                        help='Specify \"defaults.cfg\" file'\n                        )\n\n    parser.add_argument('--debug-mode', '-d',\n                        action='store_true',\n                        help='Turn on debug mode',\n                        dest='debug_mode'\n                        )\n\n    parser.add_argument('--pid-file', '-p',\n                        default=os.path.join(\n                            os.path.abspath(os.path.curdir),\n                            'blackbird.pid'\n                        ),\n                        help='pid file location',\n                        dest='pid_file'\n                        )\n\n    parser.add_argument('--foreground', '-f',\n                        default=True,\n                        action='store_false',\n                        help='Turn on foreground mode',\n                        dest='detach_process'\n                        )\n\n    parser.add_argument('--version', '-V',\n                        default=False,\n                        action='store_true',\n                        help='Show version information',\n                        dest='show_version'\n                        )\n\n    args = parser.parse_args()\n    args.pid_file = is_pid(args.pid_file)\n\n    return parser.parse_args()", "response": "u Returns command - line options."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_pid(value):\n\n    value = os.path.expanduser(value)\n    value = os.path.expandvars(value)\n    value = os.path.abspath(value)\n\n    pid_file = 'blackbird.pid'\n\n    if os.path.exists(value):\n\n        if os.path.isdir(value):\n\n            if os.access(value, os.W_OK):\n                return os.path.join(value, pid_file)\n\n            else:\n                err_message = ('{path}: Permission denied.'\n                               ''.format(path=value)\n                               )\n                raise validate.VdtValueError(err_message)\n\n        else:\n            err_message = 'pid file already exists.'\n            raise AlreadyLocked(err_message)\n\n    else:\n        directory = os.path.split(value)[0]\n\n        if os.path.isdir(directory):\n\n            if os.access(directory, os.W_OK):\n                return value\n\n            else:\n                err_message = ('{directory}: Permission denied.'\n                               ''.format(directory=directory)\n                               )\n                raise validate.VdtValueError(err_message)\n\n        else:\n\n            if os.path.exists(directory):\n                err_message = ('{directory} is file.'\n                               ''.format(directory=directory)\n                               )\n                raise validate.VdtTypeError(err_message)\n\n            else:\n                err_message = ('{directory}: No such file or directory.'\n                               ''.format(directory=directory)\n                               )\n                raise validate.VdtValueError(err_message)", "response": "This function checks whether a file path exists and write permission to the file path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_field(self, field_instance_or_string):\n        if isinstance(field_instance_or_string, basestring):\n            field_instance = Field(field_instance_or_string)\n        elif isinstance(field_instance_or_string, Field):\n            field_instance_or_string = field_instance\n        else:\n            raise ValueError('Expected a basetring or Field instance')\n\n        self.fields.append(field_instance)\n\n        return self", "response": "Adds a field to the list of fields."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dfs(node, expand=expansion_all, callback=None, silent=True):\n    nodes = deque()\n    for n in expand(node):\n        nodes.append(n)\n\n    while nodes:\n        n = nodes.pop()\n        n.visits += 1\n        if callback:\n            callback(n)\n        for k in expand(n):\n            if k.visits < 1:\n                nodes.append(k)\n            else:\n                if not silent:\n                    raise CircularDependency('Circular Dependency')", "response": "Perform a depth - first search on a node graph\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef explore(node):\n    explored = set()\n    explored.add(node)\n    dfs(node, callback=lambda n: explored.add(n))\n    return explored", "response": "Given a node explore on relatives siblings and children and return a set of explored nodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef depends(self, *nodes):\n        for node in nodes:\n            self.add_relative(node)\n            node.add_children(self)", "response": "Adds nodes as relatives to this one and updates the relatives with self as children."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, *nodes):\n        for node in nodes:\n            node.set_parent(self)\n            self.add_sibling(node)", "response": "Adds nodes as siblings to the current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_hierarchies(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.HierarchyList(self._results, runtime=self._runtime)", "response": "Gets the hierarchy list resulting from the search."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the sequence from a start position for the length of the sequence", "response": "def _set_seq(self,sequence,start=0):\n    \"\"\"Set the sequence from a start position for the length of the sequence\"\"\"\n    if start+len(sequence) > self._slen: \n      sys.stderr.write(\"Error not long enough to add\\n\")\n      sys.exit()\n    z = 0\n    for i in xrange(start, start+len(sequence)):\n      self._set_nt(sequence[z],i)\n      z+=1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_agent(self, agent_id):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authentication',\n                                         collection='Agent',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(agent_id, 'authentication').get_identifier())},\n                 **self._view_filter()))\n        return objects.Agent(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the Agent specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_agents_by_ids(self, agent_ids):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authentication',\n                                         collection='Agent',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in agent_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'authentication').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.AgentList(sorted_result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an AgentList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_agents_by_genus_type(self, agent_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authentication',\n                                         collection='Agent',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(agent_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AgentList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an AgentList corresponding to the given agent genus Type which does not include agents of genus types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_agents(self):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('authentication',\n                                         collection='Agent',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.AgentList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets all Agents in this session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether a stream is allowed formatting such as coloring.", "response": "def __stream_format_allowed(self, stream):\n        \"\"\"\n        Check whether a stream allows formatting such as coloring.\n        Inspired from Python cookbook, #475186\n        \"\"\"\n        # curses isn't available on all platforms\n        try:\n            import curses as CURSES\n        except:\n            return False\n        try:\n            CURSES.setupterm()\n            return CURSES.tigetnum(\"colors\") >= 2\n        except:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lastLogged(self):\n        d = copy.deepcopy(self.__lastLogged)\n        d.pop(-1, None)\n        return d", "response": "Get a dictionary of last logged messages."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_stdout(self, stream=None):\n        if stream is None:\n            self.__stdout = sys.stdout\n        else:\n            assert hasattr(stream, 'read') and hasattr(stream, 'write'), \"stdout stream is not valid\"\n            self.__stdout = stream\n        # set stdout colors\n        self.__stdoutFontFormat = self.__get_stream_fonts_attributes(stream)", "response": "Sets the standard output stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_log_type_flags(self, logType, stdoutFlag, fileFlag):\n        assert logType in self.__logTypeStdoutFlags.keys(), \"logType '%s' not defined\" %logType\n        assert isinstance(stdoutFlag, bool), \"stdoutFlag must be boolean\"\n        assert isinstance(fileFlag, bool), \"fileFlag must be boolean\"\n        self.__logTypeStdoutFlags[logType] = stdoutFlag\n        self.__logTypeFileFlags[logType]   = fileFlag", "response": "Sets the log type flags for the current log record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the log file full path including directory path basename and extension.", "response": "def set_log_file(self, logfile):\n        \"\"\"\n        Set the log file full path including directory path basename and extension.\n\n        :Parameters:\n           #. logFile (string): the full log file path including basename and\n              extension. If this is given, all of logFileBasename and logFileExtension\n              will be discarded. logfile is equivalent to logFileBasename.logFileExtension\n        \"\"\"\n        assert isinstance(logfile, basestring), \"logfile must be a string\"\n        basename, extension = os.path.splitext(logfile)\n        self.__set_log_file_basename(logFileBasename=basename)\n        self.set_log_file_extension(logFileExtension=extension)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the log file extension. :Parameters: #. logFileExtension (string): Logging file extension. A logging file full name is set as logFileBasename.logFileExtension", "response": "def set_log_file_extension(self, logFileExtension):\n        \"\"\"\n        Set the log file extension.\n\n        :Parameters:\n           #. logFileExtension (string): Logging file extension. A logging file full name is\n              set as logFileBasename.logFileExtension\n        \"\"\"\n        assert isinstance(logFileExtension, basestring), \"logFileExtension must be a basestring\"\n        assert len(logFileExtension), \"logFileExtension can't be empty\"\n        if logFileExtension[0] == \".\":\n            logFileExtension = logFileExtension[1:]\n        assert len(logFileExtension), \"logFileExtension is not allowed to be single dot\"\n        if logFileExtension[-1] == \".\":\n            logFileExtension = logFileExtension[:-1]\n        assert len(logFileExtension), \"logFileExtension is not allowed to be double dots\"\n        self.__logFileExtension = logFileExtension\n        # set log file name\n        self.__set_log_file_name()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __set_log_file_name(self):\n        # ensure directory exists\n        dir, _ = os.path.split(self.__logFileBasename)\n        if len(dir) and not os.path.exists(dir):\n            os.makedirs(dir)\n        # create logFileName\n        self.__logFileName = self.__logFileBasename+\".\"+self.__logFileExtension\n        number = 0\n        while os.path.isfile(self.__logFileName):\n            if os.stat(self.__logFileName).st_size/1e6 < self.__maxlogFileSize:\n                break\n            number += 1\n            self.__logFileName = self.__logFileBasename+\"_\"+str(number)+\".\"+self.__logFileExtension\n        # create log file stram\n        self.__logFileStream = None", "response": "Automatically set logFileName attribute"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the log file maximum size in Megabytes.", "response": "def set_log_file_maximum_size(self, logFileMaxSize):\n        \"\"\"\n        Set the log file maximum size in megabytes\n\n        :Parameters:\n           #. logFileMaxSize (number): The maximum size in Megabytes of a logging file.\n              Once exceeded, another logging file as logFileBasename_N.logFileExtension\n              will be created. Where N is an automatically incremented number.\n        \"\"\"\n        assert _is_number(logFileMaxSize), \"logFileMaxSize must be a number\"\n        logFileMaxSize = float(logFileMaxSize)\n        assert logFileMaxSize>=1, \"logFileMaxSize minimum size is 1 megabytes\"\n        self.__maxlogFileSize = logFileMaxSize"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_minimum_level(self, level=0, stdoutFlag=True, fileFlag=True):\n        # check flags\n        assert isinstance(stdoutFlag, bool), \"stdoutFlag must be boolean\"\n        assert isinstance(fileFlag, bool), \"fileFlag must be boolean\"\n        if not (stdoutFlag or fileFlag):\n            return\n        # check level\n        if level is not None:\n            if isinstance(level, basestring):\n                level = str(level)\n                assert level in self.__logTypeStdoutFlags.keys(), \"level '%s' given as string, is not defined logType\" %level\n                level = self.__logTypeLevels[level]\n            assert _is_number(level), \"level must be a number\"\n            level = float(level)\n            if stdoutFlag:\n                if self.__stdoutMaxLevel is not None:\n                    assert level<=self.__stdoutMaxLevel, \"stdoutMinLevel must be smaller or equal to stdoutMaxLevel %s\"%self.__stdoutMaxLevel\n            if fileFlag:\n                if self.__fileMaxLevel is not None:\n                    assert level<=self.__fileMaxLevel, \"fileMinLevel must be smaller or equal to fileMaxLevel %s\"%self.__fileMaxLevel\n        # set flags\n        if stdoutFlag:\n            self.__stdoutMinLevel = level\n            self.__update_stdout_flags()\n        if fileFlag:\n            self.__fileMinLevel = level\n            self.__update_file_flags()", "response": "Set the minimum logging level."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nforce a logtype standard output logging flag despite minimum and maximum logging level boundaries.", "response": "def force_log_type_stdout_flag(self, logType, flag):\n        \"\"\"\n        Force a logtype standard output logging flag despite minimum and maximum logging level boundaries.\n\n        :Parameters:\n           #. logType (string): A defined logging type.\n           #. flag (None boolean): The standard output logging flag.\n              If None, logtype existing forced flag is released.\n        \"\"\"\n        assert logType in self.__logTypeStdoutFlags.keys(), \"logType '%s' not defined\" %logType\n        if flag is None:\n            self.__forcedStdoutLevels.pop(logType, None)\n            self.__update_stdout_flags()\n        else:\n            assert isinstance(flag, bool), \"flag must be boolean\"\n            self.__logTypeStdoutFlags[logType] = flag\n            self.__forcedStdoutLevels[logType] = flag"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nforce a logtype file logging flag despite minimum and maximum logging level boundaries.", "response": "def force_log_type_file_flag(self, logType, flag):\n        \"\"\"\n        Force a logtype file logging flag despite minimum and maximum logging level boundaries.\n\n        :Parameters:\n           #. logType (string): A defined logging type.\n           #. flag (None, boolean): The file logging flag.\n              If None, logtype existing forced flag is released.\n        \"\"\"\n        assert logType in self.__logTypeStdoutFlags.keys(), \"logType '%s' not defined\" %logType\n        if flag is None:\n            self.__forcedFileLevels.pop(logType, None)\n            self.__update_file_flags()\n        else:\n            assert isinstance(flag, bool), \"flag must be boolean\"\n            self.__logTypeFileFlags[logType] = flag\n            self.__forcedFileLevels[logType] = flag"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nforcing a logtype logging flags.", "response": "def force_log_type_flags(self, logType, stdoutFlag, fileFlag):\n        \"\"\"\n        Force a logtype logging flags.\n\n        :Parameters:\n           #. logType (string): A defined logging type.\n           #. stdoutFlag (None, boolean): The standard output logging flag.\n              If None, logtype stdoutFlag forcing is released.\n           #. fileFlag (None, boolean): The file logging flag.\n              If None, logtype fileFlag forcing is released.\n        \"\"\"\n        self.force_log_type_stdout_flag(logType, stdoutFlag)\n        self.force_log_type_file_flag(logType, fileFlag)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting a logtype name.", "response": "def set_log_type_name(self, logType, name):\n        \"\"\"\n        Set a logtype name.\n\n        :Parameters:\n           #. logType (string): A defined logging type.\n           #. name (string): The logtype new name.\n        \"\"\"\n        assert logType in self.__logTypeStdoutFlags.keys(), \"logType '%s' not defined\" %logType\n        assert isinstance(name, basestring), \"name must be a string\"\n        name = str(name)\n        self.__logTypeNames[logType] = name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a logtype logging level.", "response": "def set_log_type_level(self, logType, level):\n        \"\"\"\n        Set a logtype logging level.\n\n        :Parameters:\n           #. logType (string): A defined logging type.\n           #. level (number): The level of logging.\n        \"\"\"\n        assert _is_number(level), \"level must be a number\"\n        level = float(level)\n        name = str(name)\n        self.__logTypeLevels[logType] = level"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_log_type(self, logType, _assert=False):\n        # check logType\n        if _assert:\n            assert logType in self.__logTypeStdoutFlags.keys(), \"logType '%s' is not defined\" %logType\n        # remove logType\n        self.__logTypeColor.pop(logType)\n        self.__logTypeHighlight.pop(logType)\n        self.__logTypeAttributes.pop(logType)\n        self.__logTypeNames.pop(logType)\n        self.__logTypeLevels.pop(logType)\n        self.__logTypeFormat.pop(logType)\n        self.__logTypeStdoutFlags.pop(logType)\n        self.__logTypeFileFlags.pop(logType)\n        self.__forcedStdoutLevels.pop(logType, None)\n        self.__forcedFileLevels.pop(logType, None)", "response": "Removes a logtype from the log file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_log_type(self, logType, name=None, level=0, stdoutFlag=None, fileFlag=None, color=None, highlight=None, attributes=None):\n        # check logType\n        assert logType not in self.__logTypeStdoutFlags.keys(), \"logType '%s' already defined\" %logType\n        assert isinstance(logType, basestring), \"logType must be a string\"\n        logType = str(logType)\n        # set log type\n        self.__set_log_type(logType=logType, name=name, level=level,\n                            stdoutFlag=stdoutFlag, fileFlag=fileFlag,\n                            color=color, highlight=highlight, attributes=attributes)", "response": "Add a new logtype to the log."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_log_type(self, logType, name=None, level=None, stdoutFlag=None, fileFlag=None, color=None, highlight=None, attributes=None):\n        # check logType\n        assert logType in self.__logTypeStdoutFlags.keys(), \"logType '%s' is not defined\" %logType\n        # get None updates\n        if name is None:       name       = self.__logTypeNames[logType]\n        if level is None:      level      = self.__logTypeLevels[logType]\n        if stdoutFlag is None: stdoutFlag = self.__logTypeStdoutFlags[logType]\n        if fileFlag is None:   fileFlag   = self.__logTypeFileFlags[logType]\n        if color is None:      color      = self.__logTypeColor[logType]\n        if highlight is None:  highlight  = self.__logTypeHighlight[logType]\n        if attributes is None: attributes = self.__logTypeAttributes[logType]\n        # update log type\n        self.__set_log_type(logType=logType, name=name, level=level,\n                            stdoutFlag=stdoutFlag, fileFlag=fileFlag,\n                            color=color, highlight=highlight, attributes=attributes)", "response": "update a logtype.\n\n        :Parameters:\n           #. logType (string): The logtype.\n           #. name (None, string): The logtype name. If None, name will be set to logtype.\n           #. level (number): The level of logging.\n           #. stdoutFlag (None, boolean): Force standard output logging flag.\n              If None, flag will be set according to minimum and maximum levels.\n           #. fileFlag (None, boolean): Force file logging flag.\n              If None, flag will be set according to minimum and maximum levels.\n           #. color (None, string): The logging text color. The defined colors are:\\n\n              black , red , green , orange , blue , magenta , cyan , grey , dark grey ,\n              light red , light green , yellow , light blue , pink , light cyan\n           #. highlight (None, string): The logging text highlight color. The defined highlights are:\\n\n              black , red , green , orange , blue , magenta , cyan , grey\n           #. attributes (None, string): The logging text attribute. The defined attributes are:\\n\n              bold , underline , blink , invisible , strike through\n\n        **N.B** *logging color, highlight and attributes are not allowed on all types of streams.*"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlogging a message of a certain logtype. :Parameters: #. logType (string): A defined logging type. #. message (string): Any message to log. #. data (None, object): Any type of data to print and/or write to log file after log message #. tback (None, str, list): Stack traceback to print and/or write to log file. In general, this should be traceback.extract_stack", "response": "def log(self, logType, message, data=None, tback=None):\n        \"\"\"\n        log a message of a certain logtype.\n\n        :Parameters:\n           #. logType (string): A defined logging type.\n           #. message (string): Any message to log.\n           #. data (None,  object): Any type of data to print and/or write to log file\n              after log message\n           #. tback (None, str, list): Stack traceback to print and/or write to\n              log file. In general, this should be traceback.extract_stack\n        \"\"\"\n        # log to stdout\n        log = self._format_message(logType=logType, message=message, data=data, tback=tback)\n        if self.__logToStdout and self.__logTypeStdoutFlags[logType]:\n            self.__log_to_stdout(self.__logTypeFormat[logType][0] + log + self.__logTypeFormat[logType][1] + \"\\n\")\n            if self.__flush:\n                try:\n                    self.__stdout.flush()\n                except:\n                    pass\n                try:\n                    os.fsync(self.__stdout.fileno())\n                except:\n                    pass\n        # log to file\n        if self.__logToFile and self.__logTypeFileFlags[logType]:\n            self.__log_to_file(log)\n            self.__log_to_file(\"\\n\")\n            if self.__flush:\n                try:\n                    self.__logFileStream.flush()\n                except:\n                    pass\n                try:\n                    os.fsync(self.__logFileStream.fileno())\n                except:\n                    pass\n        # set last logged message\n        self.__lastLogged[logType] = log\n        self.__lastLogged[-1]      = log"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef force_log(self, logType, message, data=None, tback=None, stdout=True, file=True):\n        # log to stdout\n        log = self._format_message(logType=logType, message=message, data=data, tback=tback)\n        if stdout:\n            self.__log_to_stdout(self.__logTypeFormat[logType][0] + log + self.__logTypeFormat[logType][1] + \"\\n\")\n            try:\n                self.__stdout.flush()\n            except:\n                pass\n            try:\n                os.fsync(self.__stdout.fileno())\n            except:\n                pass\n        if file:\n            # log to file\n            self.__log_to_file(log)\n            self.__log_to_file(\"\\n\")\n            try:\n                self.__logFileStream.flush()\n            except:\n                pass\n            try:\n                os.fsync(self.__logFileStream.fileno())\n            except:\n                pass\n        # set last logged message\n        self.__lastLogged[logType] = log\n        self.__lastLogged[-1]      = log", "response": "Force logging a message of a certain logtype level."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef info(self, message, *args, **kwargs):\n        self.log(\"info\", message, *args, **kwargs)", "response": "alias to message at information level"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef information(self, message, *args, **kwargs):\n        self.log(\"info\", message, *args, **kwargs)", "response": "alias to message at information level"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warn(self, message, *args, **kwargs):\n        self.log(\"warn\", message, *args, **kwargs)", "response": "alias to message at warning level"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warning(self, message, *args, **kwargs):\n        self.log(\"warn\", message, *args, **kwargs)", "response": "alias to message at warning level"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ts_to_dt_str(ts, dt_format='%Y-%m-%d %H:%M:%S'):\n    return datetime.datetime.fromtimestamp(int(ts)).strftime(dt_format)", "response": "Returns a datetime. datetime object from a timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a string to a datetime object", "response": "def str_to_datetime(dt_str, fmt='%Y-%m-%d %H:%M:%S'):\n    \"\"\"\n    \u5b57\u7b26\u4e32\u8f6c\u6362\u4e3adatetime\u7c7b\u578b\u6570\u636e\n    :param dt_str:\n    :param fmt:\n    :return:\n    \"\"\"\n    d_time = datetime.datetime.strptime(dt_str, fmt)\n    return d_time"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dt_delta(dt, delta):\n    delta_time = datetime.timedelta(days=delta)\n    target_date = dt + delta_time\n    return target_date", "response": "\u83b7\u53d6dt\u76f8\u9694delta\u7684\u65e5\u671f\n    :param dt:\n    :param delta:\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a string to a number of minutes", "response": "def time_str_to_minutes(time_str):\n    \"\"\"\n    \u901a\u8fc7\u65f6\u95f4\u5b57\u7b26\u4e32\u8ba1\u7b97\u5f97\u5230\u8fd9\u662f\u4e00\u5929\u4e2d\u7b2c\u591a\u5c11\u5206\u949f\n    :param time_str: eg: '11:10:00'\n    :return: int\n    \"\"\"\n    time_arr = time_str.split(\":\")\n    hours = int(time_arr[0])\n    minutes = int(time_arr[1])\n    return hours * 60 + minutes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if a and b are almost equal.", "response": "def almost_eq(a, b, threshold=0.000001):\n    \"\"\"\n    \u6bd4\u8f83\u4e24\u4e2a\u5c0f\u6570\u662f\u5426\u51e0\u4e4e\u76f8\u7b49\n    \u5f53\u4e24\u6570\u5dee\u7684\u7edd\u5bf9\u503c\u5c0f\u4e8ethreshold\u65f6\u8ba4\u4e3a\u5176\u76f8\u7b49\n    :param a:\n    :param b:\n    :param threshold:\n    :return: True or False\n    \"\"\"\n    if abs(a - b) < threshold:\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sort_transcripts(self):\n     txs = sorted(self.transcripts,key=lambda x: (x.range.chr, x.range.start, x.range.end))\n     self._transcripts = txs", "response": "Sort the transcripts stored here"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the underlying no_catalog view to match current view", "response": "def _set_no_catalog_view(self, session):\n        \"\"\"Sets the underlying no_catalog view to match current view\"\"\"\n        if self._no_catalog_view == COMPARATIVE:\n            try:\n                session.use_comparative_no_catalog_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_no_catalog_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a message to the specified recipients.", "response": "def send(self, send_to, from_who, subject, message, reply_to=None):\n        \"\"\"Send Email.\n\n        To use this module pass in a message, send_to, from_who, and subject.\n\n        :param send_to: ``str``\n        :param from_who: ``str``\n        :param subject: ``str``\n        :param message: ``str``\n        :param reply_to: ``str``\n        \"\"\"\n        # Set the reply to address if it's None\n        if reply_to is None:\n            reply_to = from_who\n\n        try:\n            em_msg = text.MIMEText(\n                _text=message.encode('utf8'),\n                _subtype='plain',\n                _charset='utf8'\n            )\n            em_msg[\"Subject\"] = subject\n            em_msg[\"From\"] = from_who\n            em_msg[\"To\"] = send_to\n            em_msg[\"Reply-To\"] = reply_to\n\n            # Send Customer Messages\n            built_message = em_msg.as_string()\n\n            self.smtp.sendmail(\n                from_addr=em_msg[\"From\"],\n                to_addrs=em_msg[\"To\"],\n                msg=built_message\n            )\n        except Exception as exp:\n            msg = 'Failed to send message due to \"%s\"' % exp\n            self.log.error(msg)\n            raise cloudlib.MessageFailure(msg)\n        else:\n            self.log.debug(message)\n        finally:\n            self.smtp.quit()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef authenticate(self, account_name, password):\n        self.auth_token = self.authenticator.authenticate(self.transport,\n                                                          account_name,\n                                                          password)", "response": "Authenticates zimbra account.\n        @param account_name: account email address\n        @param password: account password\n        @raise AuthException: if authentication fails\n        @raise SoapException: if soap communication fails"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef change_password(self, current_password, new_password):\n        attrs = {sconstant.A_BY: sconstant.V_NAME}\n        account = SOAPpy.Types.stringType(data=self.auth_token.account_name,\n                                          attrs=attrs)\n\n        params = {sconstant.E_ACCOUNT: account,\n                  sconstant.E_OLD_PASSWORD: current_password,\n                  sconstant.E_PASSWORD: new_password}\n\n        self.invoke(zconstant.NS_ZIMBRA_ACC_URL,\n                    sconstant.ChangePasswordRequest,\n                    params)", "response": "Changes account password.\n        @param current_password: current password\n        @param new_password: new password"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting account info. @return: AccountInfo", "response": "def get_account_info(self):\n        \"\"\"\n        Gets account info.\n        @return: AccountInfo\n        \"\"\"\n        attrs = {sconstant.A_BY: sconstant.V_NAME}\n        account = SOAPpy.Types.stringType(data=self.auth_token.account_name,\n                                          attrs=attrs)\n\n        params = {sconstant.E_ACCOUNT: account}\n\n        res = self.invoke(zconstant.NS_ZIMBRA_ACC_URL,\n                          sconstant.GetAccountInfoRequest,\n                          params)\n\n        info = AccountInfo()\n        info.parse(res)\n\n        return info"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets mailbox info. @param params: params to retrieve @return: AccountInfo", "response": "def get_info(self, params={}):\n        \"\"\"\n        Gets mailbox info.\n        @param params: params to retrieve\n        @return: AccountInfo\n        \"\"\"\n        res = self.invoke(zconstant.NS_ZIMBRA_ACC_URL,\n                          sconstant.GetInfoRequest,\n                          params)\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn default mdata map for Relationship", "response": "def get_relationship_mdata():\n    \"\"\"Return default mdata map for Relationship\"\"\"\n    return {\n        'source': {\n            'element_label': {\n                'text': 'source',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n        'destination': {\n            'element_label': {\n                'text': 'destination',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'instructions': {\n                'text': 'accepts an osid.id.Id object',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            },\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': [],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _match_minimum_date_time(self, match_key, date_time_value, match=True):\n        if match:\n            gtelt = '$gte'\n        else:\n            gtelt = '$lt'\n        if match_key in self._query_terms:\n            self._query_terms[match_key][gtelt] = date_time_value\n        else:\n            self._query_terms[match_key] = {gtelt: date_time_value}", "response": "Matches a minimum date time value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _clear_minimum_terms(self, match_key):\n        try:  # clear match = True case\n            del self._query_terms[match_key]['$gte']\n        except KeyError:\n            pass\n        try:  # clear match = False case\n            del self._query_terms[match_key]['$lt']\n        except KeyError:\n            pass\n        try:\n            if self._query_terms[match_key] == {}:\n                del self._query_terms[match_key]\n        except KeyError:\n            pass", "response": "clears minimum match_key term values"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears maximum match_key term values", "response": "def _clear_maximum_terms(self, match_key):\n        \"\"\"clears maximum match_key term values\"\"\"\n        try:  # clear match = True case\n            del self._query_terms[match_key]['$lte']\n        except KeyError:\n            pass\n        try:  # clear match = False case\n            del self._query_terms[match_key]['$gt']\n        except KeyError:\n            pass\n        try:\n            if self._query_terms[match_key] == {}:\n                del self._query_terms[match_key]\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a keyword to match.", "response": "def match_keyword(self, keyword, string_match_type=DEFAULT_STRING_MATCH_TYPE, match=True):\n        \"\"\"Adds a keyword to match.\n\n        Multiple keywords can be added to perform a boolean ``OR`` among\n        them. A keyword may be applied to any of the elements defined in\n        this object such as the display name, description or any method\n        defined in an interface implemented by this object.\n\n        arg:    keyword (string): keyword to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n        raise:  InvalidArgument - ``keyword`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``keyword`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Note: this currently ignores match argument\n        match_value = self._get_string_match_value(keyword, string_match_type)\n        for field_name in self._keyword_fields:\n            if field_name not in self._keyword_terms:\n                self._keyword_terms[field_name] = {'$in': list()}\n            self._keyword_terms[field_name]['$in'].append(match_value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch any object. arg: match (boolean): ``true`` to match any object ``,`` ``false`` to match no objects *compliance: mandatory -- This method must be implemented.*", "response": "def match_any(self, match):\n        \"\"\"Matches any object.\n\n        arg:    match (boolean): ``true`` to match any object ``,``\n                ``false`` to match no objects\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        match_key = '_id'\n        param = '$exists'\n        if match:\n            flag = 'true'\n        else:\n            flag = 'false'\n        if match_key in self._query_terms:\n            self._query_terms[match_key][param] = flag\n        else:\n            self._query_terms[match_key] = {param: flag}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmatches temporals whose start date falls in between the given dates inclusive.", "response": "def match_start_date(self, start, end, match):\n        \"\"\"Matches temporals whose start date falls in between the given dates inclusive.\n\n        arg:    start (osid.calendaring.DateTime): start of date range\n        arg:    end (osid.calendaring.DateTime): end of date range\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n        raise:  InvalidArgument - ``start`` is less than ``end``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if match:\n            if end < start:\n                raise errors.InvalidArgument('end date must be >= start date when match = True')\n            self._query_terms['startDate'] = {\n                '$gte': start,\n                '$lte': end\n            }\n        else:\n            raise errors.InvalidArgument('match = False not currently supported')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmatches temporals whose effective end date falls in between the given dates inclusive.", "response": "def match_end_date(self, start, end, match):\n        \"\"\"Matches temporals whose effective end date falls in between the given dates inclusive.\n\n        arg:    start (osid.calendaring.DateTime): start of date range\n        arg:    end (osid.calendaring.DateTime): end of date range\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for negative match\n        raise:  InvalidArgument - ``start`` is less than ``end``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if match:\n            if end < start:\n                raise errors.InvalidArgument('end date must be >= start date when match = True')\n            self._query_terms['endDate'] = {\n                '$gte': start,\n                '$lte': end\n            }\n        else:\n            raise errors.InvalidArgument('match = False not currently supported')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_date(self, from_, to, match):\n        if match:\n            if to < from_:\n                raise errors.InvalidArgument('end date must be >= start date when match = True')\n            self._query_terms['startDate'] = {\n                '$gte': from_\n            }\n            self._query_terms['endDate'] = {\n                '$lte': to\n            }\n        else:\n            raise errors.InvalidArgument('match = False not currently supported')", "response": "Matches temporals where the given date range falls entirely between the start and end dates inclusive."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a display name to match.", "response": "def match_display_name(self, display_name, string_match_type=DEFAULT_STRING_MATCH_TYPE, match=True):\n        \"\"\"Adds a display name to match.\n\n        Multiple display name matches can be added to perform a boolean\n        ``OR`` among them.\n\n        arg:    display_name (string): display name to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n        raise:  InvalidArgument - ``display_name`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``display_name`` or ``string_match_type``\n                is ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._match_display_text('displayName', display_name, string_match_type, match)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_description(self, description, string_match_type=DEFAULT_STRING_MATCH_TYPE, match=True):\n        self._match_display_text('description', description, string_match_type, match)", "response": "Adds a description name to match."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_handler_fp(logger):\n    if not hasattr(logger, 'handlers'):\n        raise blackbird.utils.error.BlackbirdError(\n            'Given logger is not logging.Logger instance!'\n        )\n\n    if len(logger.handlers) != 1:\n        raise blackbird.utils.error.BlackbirdError(\n            'Given logger has invalid handlers.'\n        )\n\n    if hasattr(logger.handlers[0], 'stream'):\n        return logger.handlers[0].stream\n\n    # case of setting SysLogHandler to logger.handlers[0]\n    return logger.handlers[0]", "response": "Get handler_fp.\n    This method is integrated to LoggerFactory Object in the future.\n    :param logging.Logger logger: Python logging.Logger. logger instance.\n    :rtype: logging.Logger.handlers.BaseRotatingHandler\n    :return: Handler or Handler's stream. We call it `handler_fp`."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_status(cls, http_status, code_index=0, message=None, developer_message=None, meta=None):\n        # type: (HTTPStatus, int, AnyStr, AnyStr, dict) -> Error\n        \"\"\"\n        Automatically build an HTTP response from the HTTP Status code.\n        \n        :param http_status: \n        :param code_index: \n        :param message: \n        :param developer_message: \n        :param meta: \n\n        \"\"\"\n        return cls(http_status.value,\n                   (http_status.value * 100) + code_index,\n                   message or http_status.description,\n                   developer_message or http_status.description,\n                   meta)", "response": "Create an Error object from a HTTP Status code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nacquiring - Acquire given lock. Can be blocking or nonblocking by providing a timeout. Returns \"True\" if you got the lock, otherwise \"False\" @param timeout <None/float> - Max number of seconds to wait, or None to block until we can acquire it. @return <bool> - True if you got the lock, otherwise False.", "response": "def acquire(self, timeout=None):\n        '''\n            acquire - Acquire given lock. Can be blocking or nonblocking by providing a timeout.\n              Returns \"True\" if you got the lock, otherwise \"False\"\n\n            @param timeout <None/float> - Max number of seconds to wait, or None to block until we can acquire it.\n\n            @return  <bool> - True if you got the lock, otherwise False.\n        '''\n        if self.held is True:\n            # NOTE: Without some type of in-directory marker (like a uuid) we cannot\n            #        refresh an expired lock accurately\n            if os.path.exists(self.lockPath):\n                return True\n            # Someone removed our lock\n            self.held = False\n\n        # If we aren't going to poll at least 5 times, give us a smaller interval\n        if timeout:\n            if timeout / 5.0 < DEFAULT_POLL_TIME:\n                pollTime = timeout / 10.0\n            else:\n                pollTime = DEFAULT_POLL_TIME\n            \n            endTime = time.time() + timeout\n            keepGoing = lambda : bool(time.time() < endTime)\n        else:\n            pollTime = DEFAULT_POLL_TIME\n            keepGoing = lambda : True\n\n                    \n\n        success = False\n        while keepGoing():\n            try:\n                os.mkdir(self.lockPath) \n                success = True\n                break\n            except:\n                time.sleep(pollTime)\n                if self.maxLockAge:\n                    if os.path.exists(self.lockPath) and os.stat(self.lockPath).st_mtime < time.time() - self.maxLockAge:\n                        try:\n                            os.rmdir(self.lockPath)\n                        except:\n                            # If we did not remove the lock, someone else is at the same point and contending. Let them win.\n                            time.sleep(pollTime)\n        \n        if success is True:\n            self.acquiredAt = time.time()\n\n        self.held = success\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef release(self, forceRelease=False):\n        '''\n            release - Release the lock.\n\n            @param forceRelease <bool> default False - If True, will release the lock even if we don't hold it.\n\n            @return - True if lock is released, otherwise False\n        '''\n        if not self.held:\n            if forceRelease is False:\n                return False # We were not holding the lock\n            else:\n                self.held = True # If we have force release set, pretend like we held its\n        \n        if not os.path.exists(self.lockPath):\n            self.held = False\n            self.acquiredAt = None\n            return True\n\n        if forceRelease is False:\n            # We waited too long and lost the lock\n            if self.maxLockAge and time.time() > self.acquiredAt + self.maxLockAge:\n                self.held = False\n                self.acquiredAt = None\n                return False\n\n        self.acquiredAt = None\n\n        try:\n            os.rmdir(self.lockPath)\n            self.held = False\n            return True\n        except:\n            self.held = False\n            return False", "response": "release - Release the lock.\n\n            @param forceRelease <bool> default False - If True, will release the lock even if we don't hold it.\n\n            @return - True if lock is released, otherwise False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __checkExpiration(self, mtime=None):\n        '''\n            __checkExpiration - Check if we have expired\n            \n            @param mtime <int> - Optional mtime if known, otherwise will be gathered\n\n            @return <bool> - True if we did expire, otherwise False\n        '''\n        if not self.maxLockAge:\n            return False\n\n        if mtime is None:\n            try:\n                mtime = os.stat(self.lockPath).st_mtime\n            except FileNotFoundError as e:\n                return False\n\n        if mtime < time.time() - self.maxLockAge:\n            return True\n\n        return False", "response": "Check if we have expired a resource in the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef isHeld(self):\n        '''\n            isHeld - True if anyone holds the lock, otherwise False.\n\n            @return bool - If lock is held by anyone\n        '''\n        if not os.path.exists(self.lockPath):\n            return False\n        \n        try:\n            mtime = os.stat(self.lockPath).st_mtime\n        except FileNotFoundError as e:\n            return False\n        \n        if self.__checkExpiration(mtime):\n            return False\n\n        return True", "response": "Returns True if anyone holds the lock otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hasLock(self):\n        '''\n            hasLock - Property, returns True if we have the lock, or False if we do not.\n\n            @return <bool> - True/False if we have the lock or not.\n        '''\n        # If we don't hold it currently, return False\n        if self.held is False:\n            return False\n        \n        # Otherwise if we think we hold it, but it is not held, we have lost it.\n        if not self.isHeld:\n            self.acquiredAt = None\n            self.held = False\n            return False\n\n        # Check if we expired\n        if self.__checkExpiration(self.acquiredAt):\n            self.acquiredAt = None\n            self.held = False\n            return False\n\n\n        return True", "response": "Property returns True if we have the lock or False if we do not have the lock or not."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a named tuple with information about the given stack frame.", "response": "def stack_frame_info(stacklevel):\n    '''\n    Return a named tuple with information about the given stack frame:\n        - filename\n        - line_number\n        - module_name\n        - function_name\n\n    stacklevel: How far up the stack to look. 1 means the immediate caller, 2\n      its caller, and so on.\n    '''\n    import inspect\n\n    if stacklevel < 1:\n        raise ValueError('A stacklevel less than 1 is pointless')\n\n    frame, filename, line_number, function_name, _, _ = inspect.stack()[stacklevel]\n    module = inspect.getmodule(frame) # it is possible for getmodule to return None\n    if module is not None:\n        module_name = module.__name__\n    else:\n        module_name = \"\"\n\n    return Where(\n        filename=filename,\n        line_number=line_number,\n        module_name=module_name,\n        function_name=function_name\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pretty(self):\n        '''\n        Return a string like '/foo/bar.py:230 in foo.bar.my_func'.\n        '''\n        return '{}:{} in {}.{}'.format(\n            self.filename,\n            self.line_number,\n            self.module_name,\n            self.function_name)", "response": "Return a string like '/foo. py : 222 in foo. bar. my_func."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate a bundle object and all of its components.", "response": "def validate(bundle):\n    \"\"\"Validate a bundle object and all of its components.\n\n    The bundle must be passed as a YAML decoded object.\n\n    Return a list of bundle errors, or an empty list if the bundle is valid.\n    \"\"\"\n    errors = []\n    add_error = errors.append\n\n    # Check that the bundle sections are well formed.\n    series, services, machines, relations = _validate_sections(\n        bundle, add_error)\n    # If there are errors already, there is no point in proceeding with the\n    # validation process.\n    if errors:\n        return errors\n\n    # Validate each individual section.\n    _validate_series(series, 'bundle', add_error)\n    _validate_services(services, machines, add_error)\n    _validate_machines(machines, add_error)\n    _validate_relations(relations, services, add_error)\n\n    # Return all the collected errors.\n    return errors"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates the base bundle sections.", "response": "def _validate_sections(bundle, add_error):\n    \"\"\"Check that the base bundle sections are valid.\n\n    The bundle argument is a YAML decoded bundle content.\n\n    A bundle is composed of series, services, machines and relations.\n    Only the services section is mandatory.\n\n    Use the given add_error callable to register validation error.\n    Return the four sections\n    \"\"\"\n    # Check that the bundle itself is well formed.\n    if not isdict(bundle):\n        add_error('bundle does not appear to be a bundle')\n        return None, None, None, None\n    # Validate the services section.\n    services = bundle.get('services', {})\n    if not services:\n        add_error('bundle does not define any services')\n    elif not isdict(services):\n        add_error('services spec does not appear to be well-formed')\n    # Validate the machines section.\n    machines = bundle.get('machines')\n    if machines is not None:\n        if isdict(machines):\n            try:\n                machines = dict((int(k), v) for k, v in machines.items())\n            except (TypeError, ValueError):\n                add_error('machines spec identifiers must be digits')\n        else:\n            add_error('machines spec does not appear to be well-formed')\n    # Validate the relations section.\n    relations = bundle.get('relations')\n    if (relations is not None) and (not islist(relations)):\n        add_error('relations spec does not appear to be well-formed')\n    return bundle.get('series'), services, machines, relations"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _validate_series(series, label, add_error):\n    if series is None:\n        return\n    if not isstring(series):\n        add_error('{} series must be a string, found {}'.format(label, series))\n        return\n    if series == 'bundle':\n        add_error('{} series must specify a charm series'.format(label))\n        return\n    if not references.valid_series(series):\n        add_error('{} has invalid series {}'.format(label, series))", "response": "Validate the given series."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate_services(services, machines, add_error):\n    machine_ids = set()\n\n    for service_name, service in services.items():\n        if not isstring(service_name):\n            add_error('service name {} must be a string'.format(service_name))\n        if service.get('expose') not in (True, False, None):\n            add_error(\n                'invalid expose value for service {}'.format(service_name))\n        # Validate and retrieve the service charm URL and number of units.\n        charm = _validate_charm(service.get('charm'), service_name, add_error)\n        num_units = _validate_num_units(\n            service.get('num_units'), service_name, add_error)\n        # Validate service constraints and storage constraints.\n        label = 'service {}'.format(service_name)\n        _validate_constraints(service.get('constraints'), label, add_error)\n        _validate_storage(service.get('storage'), service_name, add_error)\n        # Validate service options and annotations.\n        _validate_options(service.get('options'), service_name, add_error)\n        _validate_annotations(service.get('annotations'), label, add_error)\n        # Retrieve and validate the service units placement.\n        placements = service.get('to', [])\n        if not islist(placements):\n            placements = [placements]\n        if (num_units is not None) and (len(placements) > num_units):\n            add_error(\n                'too many units placed for service {}'.format(service_name))\n        for placement in placements:\n            machine_id = _validate_placement(\n                placement, services, machines, charm, add_error)\n            machine_ids.add(machine_id)\n\n    if machines is not None:\n        # Notify unused machines.\n        unused = set(machines).difference(machine_ids)\n        for machine_id in unused:\n            add_error(\n                'machine {} not referred to by a placement directive'\n                ''.format(machine_id))", "response": "Validate each service within the bundle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the given charm URL.", "response": "def _validate_charm(url, service_name, add_error):\n    \"\"\"Validate the given charm URL.\n\n    Use the given service name to describe possible errors.\n    Use the given add_error callable to register validation error.\n\n    If the URL is valid, return the corresponding charm reference object.\n    Return None otherwise.\n    \"\"\"\n    if url is None:\n        add_error('no charm specified for service {}'.format(service_name))\n        return None\n    if not isstring(url):\n        add_error(\n            'invalid charm specified for service {}: {}'\n            ''.format(service_name, url))\n        return None\n    if not url.strip():\n        add_error('empty charm specified for service {}'.format(service_name))\n        return None\n    try:\n        charm = references.Reference.from_string(url)\n    except ValueError as e:\n        msg = pyutils.exception_string(e)\n        add_error(\n            'invalid charm specified for service {}: {}'\n            ''.format(service_name, msg))\n        return None\n    if charm.is_local():\n        add_error(\n            'local charms not allowed for service {}: {}'\n            ''.format(service_name, charm))\n        return None\n    if charm.is_bundle():\n        add_error(\n            'bundle cannot be used as charm for service {}: {}'\n            ''.format(service_name, charm))\n        return None\n    return charm"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_num_units(num_units, service_name, add_error):\n    if num_units is None:\n        # This should be a subordinate charm.\n        return 0\n    try:\n        num_units = int(num_units)\n    except (TypeError, ValueError):\n        add_error(\n            'num_units for service {} must be a digit'.format(service_name))\n        return\n    if num_units < 0:\n        add_error(\n            'num_units {} for service {} must be a positive digit'\n            ''.format(num_units, service_name))\n        return\n    return num_units", "response": "Validate that the given num_units is a valid integer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the given service or machine constraints.", "response": "def _validate_constraints(constraints, label, add_error):\n    \"\"\"Validate the given service or machine constraints.\n\n    Use the given label (e.g. \"machine X\" or \"service Y\") to describe\n    possible errors.\n    Use the given add_error callable to register validation error.\n    \"\"\"\n    if constraints is None:\n        return\n    msg = '{} has invalid constraints {}'.format(label, constraints)\n    if not isstring(constraints):\n        add_error(msg)\n        return\n    sep = ',' if ',' in constraints else None\n    for constraint in constraints.split(sep):\n        try:\n            key, value = constraint.split('=')\n        except (TypeError, ValueError):\n            add_error(msg)\n            return\n        if key not in _CONSTRAINTS:\n            add_error(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _validate_storage(storage, service_name, add_error):\n    if storage is None:\n        return\n    if not isdict(storage):\n        msg = 'service {} has invalid storage constraints {}'.format(\n            service_name, storage)\n        add_error(msg)", "response": "Ensure that the storage constraints are a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _validate_options(options, service_name, add_error):\n    if options is None:\n        return\n    if not isdict(options):\n        add_error('service {} has malformed options'.format(service_name))", "response": "Ensure that the options are a dict."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _validate_annotations(annotations, label, add_error):\n    if annotations is None:\n        return\n    if not isdict(annotations):\n        add_error('{} has invalid annotations {}'.format(label, annotations))\n        return\n    # Check that all the annotations keys are strings.\n    if not all(map(isstring, annotations)):\n        add_error(\n            '{} has invalid annotations: keys must be strings'.format(label))", "response": "Validate the given annotations."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate_placement(placement, services, machines, charm, add_error):\n    if not isstring(placement):\n        add_error(\n            'invalid placement {}: placement must be a string'\n            ''.format(placement))\n        return\n    is_legacy_bundle = machines is None\n    try:\n        if is_legacy_bundle:\n            # This is a v3 legacy bundle.\n            unit_placement = models.parse_v3_unit_placement(placement)\n            # This is a v4 new style bundle.\n        else:\n            unit_placement = models.parse_v4_unit_placement(placement)\n    except ValueError as e:\n        add_error(pyutils.exception_string(e))\n        return\n    if unit_placement.service:\n        service = services.get(unit_placement.service)\n        if service is None:\n            add_error(\n                'placement {} refers to non-existent service {}'\n                ''.format(placement, unit_placement.service))\n            return\n        if unit_placement.unit is not None:\n            try:\n                num_units = int(service['num_units'])\n            except (TypeError, ValueError):\n                # This will be notified when validating the service itself.\n                pass\n            else:\n                if int(unit_placement.unit) + 1 > num_units:\n                    add_error(\n                        'placement {} specifies a unit greater than the units '\n                        'in service {}'\n                        ''.format(placement, unit_placement.service))\n    elif (\n        unit_placement.machine and\n        not is_legacy_bundle and\n        (unit_placement.machine != 'new')\n    ):\n        machine_id = int(unit_placement.machine)\n        # A machine can be included in machines but its value can be None.\n        # This is so that we are compatible with go-style YAML unmarshaling.\n        if machine_id not in machines:\n            add_error(\n                'placement {} refers to a non-existent machine {}'\n                ''.format(placement, unit_placement.machine))\n            return\n        machine = machines[machine_id]\n        if not isdict(machine):\n            # Ignore this error here, as it is emitted while validating the\n            # machines section of the bundle.\n            machine = {}\n        # If the unit is \"hulk smashed\", then we need to check that the charm\n        # and the machine series match.\n        if not unit_placement.container_type:\n            series = machine.get('series')\n            if charm.series and series and charm.series != series:\n                # If the machine series is invalid, ignore this check, as an\n                # error for the machine will be added elsewhere.\n                errors = []\n                _validate_series(series, '', errors.append)\n                if not errors:\n                    add_error(\n                        'charm {} cannot be deployed to machine with '\n                        'different series {}'.format(charm, series))\n        return machine_id", "response": "Validate a placement directive against other services and machines."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_machines(machines, add_error):\n    if not machines:\n        return\n    for machine_id, machine in machines.items():\n        if machine_id < 0:\n            add_error(\n                'machine {} has an invalid id, must be positive digit'\n                ''.format(machine_id))\n        if machine is None:\n            continue\n        elif not isdict(machine):\n            add_error(\n                'machine {} does not appear to be well-formed'\n                ''.format(machine_id))\n            continue\n        label = 'machine {}'.format(machine_id)\n        _validate_constraints(machine.get('constraints'), label, add_error)\n        _validate_series(machine.get('series'), label, add_error)\n        _validate_annotations(machine.get('annotations'), label, add_error)", "response": "Validate the given machines section."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate the relations and services bundle sections.", "response": "def _validate_relations(relations, services, add_error):\n    \"\"\"Validate relations, ensuring that the endpoints exist.\n\n    Receive the relations and services bundle sections.\n    Use the given add_error callable to register validation error.\n    \"\"\"\n    if not relations:\n        return\n    for relation in relations:\n        if not islist(relation):\n            add_error('relation {} is malformed'.format(relation))\n            continue\n        relation_str = ' -> '.join('{}'.format(i) for i in relation)\n        for endpoint in relation:\n            if not isstring(endpoint):\n                add_error(\n                    'relation {} has malformed endpoint {}'\n                    ''.format(relation_str, endpoint))\n                continue\n            try:\n                service, _ = endpoint.split(':')\n            except ValueError:\n                service = endpoint\n            if service not in services:\n                add_error(\n                    'relation {} endpoint {} refers to a non-existent service '\n                    '{}'.format(relation_str, endpoint, service))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_block_bounds(filename):\n bs = []\n with open(filename,'rb') as inf:\n  while True:\n   bytes1 = inf.read(12)\n   if len(bytes1) < 12: break\n   bs.append([inf.tell()-12])\n   gzip_id1,gzip_id2,compression_method,flag,mtime,xfl,osval,xlen=struct.unpack('<BBBBIBBH',bytes1)\n   # ready to look in extra field\n   bytes2 = inf.read(xlen) # all the extra field stuff \n   s = StringIO.StringIO(bytes2)\n   obsslen = 0\n   blocksize = 0\n   while True:\n     v1 = s.read(4)\n     if len(v1) == 0: \n       break\n     if len(v1) < 4:\n       sys.stderr.write(\"lack header values ERROR\\n\")\n       return False\n     s1,s2,slen = struct.unpack('<BBH',v1)\n     if s1 == 66 and s2 == 67:\n       has_id = True\n       obsslen = slen\n       blocksize = struct.unpack('<H',s.read(slen))[0]\n     else:\n       v = s.read(slen)\n   chunk = inf.read(blocksize-1-xlen-19)\n   inf.read(9)\n   bs[-1].append(inf.tell())\n return bs", "response": "Get the bounds of a gzipped file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntesting if a file is a bgzf file.", "response": "def is_bgzf(filename):\n  \"\"\"Pre: filename to test if it is a bgzf format\n\n  Post: True or False\n\n  :param filename:\n  :type filename: string\n  :return: if its a bgzf\n  :rtype: bool\n  \"\"\"\n  with open(filename,'rb') as inf:\n   bytes1 = inf.read(12)\n   if len(bytes1) != 12:\n     sys.stderr.write(\"File length ERROR\\n\")\n     return False\n   try:\n     gzip_id1,gzip_id2,compression_method,flag,mtime,xfl,osval,xlen=struct.unpack('<BBBBIBBH',bytes1)\n   except:\n     sys.stderr.write(\"Unpack ERROR\\n\")\n     return False\n   if gzip_id1 != 31:\n     sys.stderr.write(\"ID1 ERROR\\n\")\n     return False\n   if gzip_id2 != 139:\n     sys.stderr.write(\"ID2 ERROR\\n\")\n     return False\n   if compression_method != 8:\n     sys.stderr.write(\"Compression Method ERROR\\n\")\n     return False\n   if flag != 4:\n     sys.stderr.write(\"flg ERROR\\n\")\n     return False\n   if xlen < 6:\n     sys.stderr.write(\"no extra fields ERROR\\n\")\n   # ready to look in extra field\n   bytes2 = inf.read(xlen) # all the extra field stuff \n   if len(bytes2) != xlen: \n     sys.stderr.write(\"file length ERROR\\n\")\n     return False\n   s = StringIO.StringIO(bytes2)\n   has_id = False\n   obsslen = 0\n   while True:\n     v1 = s.read(4)\n     if len(v1) == 0: break\n     if len(v1) < 4:\n       sys.stderr.write(\"lack header values ERROR\\n\")\n       return False\n     s1,s2,slen = struct.unpack('<BBH',v1)\n     if s1 == 66 and s2 == 67:\n       has_id = True\n       obsslen = slen\n     v = s.read(slen)\n     if len(v) != slen:\n       sys.stderr.write(\"extra field read ERROR\\n\")\n       return False\n   if not has_id or not obsslen == 2:\n     sys.stderr.write(\"no proper extra header ERROR\\n\")\n     return False\n  return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(self,size):\n    done = 0 #number of bytes that have been read so far\n    v = ''\n    while True:\n      if size-done < len(self._buffer['data']) - self._buffer_pos:\n        v +=  self._buffer['data'][self._buffer_pos:self._buffer_pos+(size-done)]\n        self._buffer_pos += (size-done)\n        #self.pointer += size\n        return v\n      else: # we need more buffer\n        vpart = self._buffer['data'][self._buffer_pos:]\n        self._buffer = self._load_block()\n        v += vpart\n        self._buffer_pos = 0\n        if len(self._buffer['data'])==0: return v\n        done += len(vpart)", "response": "read size bytes and return them"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_objective_admin_session(self):\n        if not self.supports_objective_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveAdminSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the objective administration service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the objective admin service for the given objective bank.", "response": "def get_objective_admin_session_for_objective_bank(self, objective_bank_id):\n        \"\"\"Gets the ``OsidSession`` associated with the objective admin service for the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                objective bank\n        return: (osid.learning.ObjectiveAdminSession) - ``an\n                _objective_admin_session``\n        raise:  NotFound - ``objective_bank_id`` not found\n        raise:  NullArgument - ``objective_bank_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_objective_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_admin()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ObjectiveAdminSession(objective_bank_id, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the session for retrieving objective to objective bank mappings.", "response": "def get_objective_objective_bank_session(self):\n        \"\"\"Gets the session for retrieving objective to objective bank mappings.\n\n        return: (osid.learning.ObjectiveObjectiveBankSession) - an\n                ``ObjectiveObjectiveBankSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_objective_objective_bank()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_objective_bank()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_objective_bank():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveObjectiveBankSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_objective_objective_bank_assignment_session(self):\n        if not self.supports_objective_objective_bank_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveObjectiveBankAssignmentSession(runtime=self._runtime)", "response": "Gets the session for assigning objective to objective bank mappings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_activity_query_session(self):\n        if not self.supports_activity_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ActivityQuerySession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the activity query service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_activity_query_session_for_objective_bank(self, objective_bank_id):\n        if not self.supports_activity_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ActivityQuerySession(objective_bank_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the activity query service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the OsidSession associated with the proficiency query service.", "response": "def get_proficiency_query_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the proficiency query service.\n\n        return: (osid.learning.ProficiencyQuerySession) - a\n                ``ProficiencyQuerySession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_proficiency_query()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_proficiency_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_proficiency_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ProficiencyQuerySession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_proficiency_query_session_for_objective_bank(self, objective_bank_id):\n        if not self.supports_proficiency_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ProficiencyQuerySession(objective_bank_id, runtime=self._runtime)", "response": "Gets the OsidSession associated with the proficiency query service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the session designing objective bank hierarchies.", "response": "def get_objective_bank_hierarchy_design_session(self):\n        \"\"\"Gets the session designing objective bank hierarchies.\n\n        return: (osid.learning.ObjectiveBankHierarchyDesignSession) - an\n                ``ObjectiveBankHierarchyDesignSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_objective_bank_hierarchy_design() is false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_bank_hierarchy_design()`` is true.*\n\n        \"\"\"\n        if not self.supports_objective_bank_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveBankHierarchyDesignSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_objective_lookup_session(self, proxy):\n        if not self.supports_objective_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the objective lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_lookup_session_for_objective_bank(self, objective_bank_id, proxy):\n        if not self.supports_objective_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ObjectiveLookupSession(objective_bank_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the objective lookup service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with the objective query service.", "response": "def get_objective_query_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the objective query service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveQuerySession) - an\n                ``ObjectiveQuerySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_objective_query()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_query()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveQuerySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the OsidSession associated with the objective query service for the given objective bank.", "response": "def get_objective_query_session_for_objective_bank(self, objective_bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the objective query service for the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                objective bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveQuerySession) - ``an\n                _objective_query_session``\n        raise:  NotFound - ``objective_bank_id`` not found\n        raise:  NullArgument - ``objective_bank_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_objective_query()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_query()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ObjectiveQuerySession(objective_bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_objective_hierarchy_session(self, proxy):\n        if not self.supports_objective_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveHierarchySession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with traversing objective hierarchies."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the OsidSession associated with the objective hierarchy traversal service for the given objective bank.", "response": "def get_objective_hierarchy_session_for_objective_bank(self, objective_bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the objective hierarchy traversal service for the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                objective bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveHierarchySession) - an\n                ``ObjectiveHierarchySession``\n        raise:  NotFound - ``objective_bank_id`` not found\n        raise:  NullArgument - ``objective_bank_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_objective_hierarchy()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_hierarchy()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_hierarchy():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ObjectiveHierarchySession(objective_bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the OsidSession associated with the objective hierarchy design service.", "response": "def get_objective_hierarchy_design_session(self, proxy):\n        \"\"\"Gets the session for designing objective hierarchies.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveHierarchyDesignSession) - an\n                ``ObjectiveHierarchyDesignSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_objective_hierarchy_design()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_hierarchy_design()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveHierarchyDesignSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OsidSession associated with the objective hierarchy design service for the given objective bank.", "response": "def get_objective_hierarchy_design_session_for_objective_bank(self, objective_bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the objective hierarchy design service for the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                objective bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveHierarchyDesignSession) - an\n                ``ObjectiveHierarchyDesignSession``\n        raise:  NotFound - ``objective_bank_id`` not found\n        raise:  NullArgument - ``objective_bank_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_objective_hierarchy_design()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_hierarchy_design()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_hierarchy_design():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ObjectiveHierarchyDesignSession(objective_bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the OsidSession associated with the objective sequencing service.", "response": "def get_objective_sequencing_session(self, proxy):\n        \"\"\"Gets the session for sequencing objectives.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveSequencingSession) - an\n                ``ObjectiveSequencingSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_objective_sequencing()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_sequencing()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_sequencing():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveSequencingSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_objective_sequencing_session_for_objective_bank(self, objective_bank_id, proxy):\n        if not self.supports_objective_sequencing():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ObjectiveSequencingSession(objective_bank_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the objective sequencing service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_objective_requisite_session(self, proxy):\n        if not self.supports_objective_requisite():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveRequisiteSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with examining objective requisites."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the objective sequencing service for the given objective bank.", "response": "def get_objective_requisite_session_for_objective_bank(self, objective_bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the objective sequencing service for the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                objective bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveRequisiteSession) - an\n                ``ObjectiveRequisiteSession``\n        raise:  NotFound - ``objective_bank_id`` not found\n        raise:  NullArgument - ``objective_bank_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_objective_requisite()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_requisite()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_requisite():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ObjectiveRequisiteSession(objective_bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objective_requisite_assignment_session(self, proxy):\n        if not self.supports_objective_requisite_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveRequisiteAssignmentSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the objective requisite assignment service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the OsidSession associated with the objective sequencing service for the given objective bank.", "response": "def get_objective_requisite_assignment_session_for_objective_bank(self, objective_bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the objective sequencing service for the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                objective bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveRequisiteAssignmentSession) - an\n                ``ObjectiveRequisiteAssignmentSession``\n        raise:  NotFound - ``objective_bank_id`` not found\n        raise:  NullArgument - ``objective_bank_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_objective_requisite_assignment()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_requisite_assignment()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_objective_requisite_assignment():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ObjectiveRequisiteAssignmentSession(objective_bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_activity_lookup_session(self, proxy):\n        if not self.supports_activity_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ActivityLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the activity lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_activity_lookup_session_for_objective_bank(self, objective_bank_id, proxy):\n        if not self.supports_activity_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ActivityLookupSession(objective_bank_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the activity lookup service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the OsidSession associated with the activity administration service.", "response": "def get_activity_admin_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the activity administration service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ActivityAdminSession) - an\n                ``ActivityAdminSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_activity_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_activity_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_activity_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ActivityAdminSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the activity admin service for the given objective bank.", "response": "def get_activity_admin_session_for_objective_bank(self, objective_bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the activity admin service for the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                objective bank\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ActivityAdminSession) - a\n                ``ActivityAdminSession``\n        raise:  NotFound - ``objective_bank_id`` not found\n        raise:  NullArgument - ``objective_bank_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_activity_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_activity_admin()`` and\n        ``supports_visible_federation()`` are ``true``.*\n\n        \"\"\"\n        if not self.supports_activity_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ActivityAdminSession(objective_bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the activity to objective bank mappings.", "response": "def get_activity_objective_bank_session(self, proxy):\n        \"\"\"Gets the session for retrieving activity to objective bank mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ActivityObjectiveBankSession) - an\n                ``ActivityObjectiveBankSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_activity_objective_bank()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_activity_objective_bank()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_activity_objective_bank():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ActivityObjectiveBankSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the session for assigning activity to objective bank mappings.", "response": "def get_activity_objective_bank_assignment_session(self, proxy):\n        \"\"\"Gets the session for assigning activity to objective bank mappings.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ActivityObjectiveBankAssignmentSession) -\n                an ``ActivityObjectiveBankAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_activity_objective_bank_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_activity_objective_bank_assignment()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_activity_objective_bank_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ActivityObjectiveBankAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_proficiency_lookup_session(self, proxy):\n        if not self.supports_proficiency_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ProficiencyLookupSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the proficiency lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_proficiency_lookup_session_for_objective_bank(self, objective_bank_id, proxy):\n        if not self.supports_proficiency_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ProficiencyLookupSession(objective_bank_id, proxy, self._runtime)", "response": "Gets the OsidSession associated with the proficiency lookup service for the given objective bank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the OsidSession associated with the proficiency administration service.", "response": "def get_proficiency_admin_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the proficiency administration service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ProficiencyAdminSession) - a\n                ``ProficiencyAdminSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_proficiency_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_proficiency_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_proficiency_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ProficiencyAdminSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the OsidSession associated with the proficiency administration service for the given objective bank.", "response": "def get_proficiency_admin_session_for_objective_bank(self, objective_bank_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the proficiency administration service for the given objective bank.\n\n        arg:    objective_bank_id (osid.id.Id): the ``Id`` of the\n                ``ObjectiveBank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ProficiencyAdminSession) - a\n                ``ProficiencyAdminSession``\n        raise:  NotFound - no objective bank found by the given ``Id``\n        raise:  NullArgument - ``objective_bank_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_proficiency_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_proficiency_admin()`` and\n        ``supports_visible_federation()`` are ``true``*\n\n        \"\"\"\n        if not self.supports_proficiency_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.ProficiencyAdminSession(objective_bank_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the OsidSession associated with assigning proficiencies to objective banks.", "response": "def get_proficiency_objective_bank_assignment_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with assigning proficiencies to objective banks.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return:\n                (osid.learning.ProficiencyObjectiveBankAssignmentSession\n                ) - a ``ProficiencyObjectiveBankAssignmentSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_proficiency_objective_bank_assignment()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_proficiency_objective_bank_assignment()`` is\n        ``true``.*\n\n        \"\"\"\n        if not self.supports_proficiency_objective_bank_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ProficiencyObjectiveBankAssignmentSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the OsidSession associated with the objective bank lookup service.", "response": "def get_objective_bank_lookup_session(self, proxy):\n        \"\"\"Gets the OsidSession associated with the objective bank lookup service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.learning.ObjectiveBankLookupSession) - an\n                ``ObjectiveBankLookupSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_objective_bank_lookup() is\n                false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_objective_bank_lookup()`` is true.*\n\n        \"\"\"\n        if not self.supports_objective_bank_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveBankLookupSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_objective_bank_admin_session(self, proxy):\n        if not self.supports_objective_bank_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveBankAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the objective bank administration service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_objective_bank_hierarchy_session(self, proxy):\n        if not self.supports_objective_bank_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.ObjectiveBankHierarchySession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the objective bank hierarchy service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef limit_result_set(self, start, end):\n        if not isinstance(start, int) or not isinstance(end, int):\n            raise errors.InvalidArgument('start and end arguments must be integers.')\n        if end <= start:\n            raise errors.InvalidArgument('End must be greater than start.')\n\n        # because Python is 0 indexed\n        # Spec says that passing in (1, 25) should include 25 entries (1 - 25)\n        # Python indices 0 - 24\n        # Python [#:##] stops before the last index, but does not include it\n        self._limit_result_set_start = start - 1\n        self._limit_result_set_end = end", "response": "By default searches return all matching results."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_map(self):\n        self.my_osid_object_form._my_map['startTimestamp'] = \\\n            self._start_timestamp_metadata['default_integer_values'][0]\n        self.my_osid_object_form._my_map['endTimestamp'] = \\\n            self._end_timestamp_metadata['default_integer_values'][0]", "response": "Initialize the map with the start and end timestamps."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_metadata(self):\n        self._start_timestamp_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'start_timestamp'),\n            'element_label': 'start timestamp',\n            'instructions': 'enter an integer number of seconds for the start time',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'syntax': 'INTEGER',\n            'minimum_integer': 0,\n            'maximum_integer': None,\n            'integer_set': [],\n            'default_integer_values': [0]\n        }\n        self._end_timestamp_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'end_timestamp'),\n            'element_label': 'end timestamp',\n            'instructions': 'enter an integer number of seconds for the end time',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'syntax': 'INTEGER',\n            'minimum_integer': 0,\n            'maximum_integer': None,\n            'integer_set': [],\n            'default_integer_values': [0]\n        }", "response": "Initialize the metadata for the object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_start_timestamp(self, start_timestamp=None):\n        if start_timestamp is None:\n            raise NullArgument()\n        if self.get_start_timestamp_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_integer(\n                start_timestamp,\n                self.get_start_timestamp_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['startTimestamp'] = start_timestamp", "response": "set the start timestamp of the entry"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the end timestamp of the entry", "response": "def set_end_timestamp(self, end_timestamp=None):\n        \"\"\"stub\"\"\"\n        if end_timestamp is None:\n            raise NullArgument()\n        if self.get_end_timestamp_metadata().is_read_only():\n            raise NoAccess()\n        if not self.my_osid_object_form._is_valid_integer(\n                end_timestamp,\n                self.get_end_timestamp_metadata()):\n            raise InvalidArgument()\n        self.my_osid_object_form._my_map['endTimestamp'] = end_timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears the end timestamp", "response": "def clear_end_timestamp(self):\n        \"\"\"stub\"\"\"\n        if (self.get_end_timestamp_metadata().is_read_only() or\n                self.get_end_timestamp_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['endTimestamp'] = \\\n            self.get_end_timestamp_metadata().get_default_integer_values()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_comment_lookup_session(self):\n        if not self.supports_comment_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CommentLookupSession(runtime=self._runtime)", "response": "Gets the OsidSession associated with the comment lookup service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_comment_book_session(self):\n        if not self.supports_comment_book():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CommentBookSession(runtime=self._runtime)", "response": "Gets the session for retrieving comment to book mappings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_comment_book_assignment_session(self):\n        if not self.supports_comment_book_assignment():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CommentBookAssignmentSession(runtime=self._runtime)", "response": "Gets the session for assigning comment to book mappings."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the book lookup service.", "response": "def get_book_lookup_session(self):\n        \"\"\"Gets the ``OsidSession`` associated with the book lookup service.\n\n        return: (osid.commenting.BookLookupSession) - a\n                ``BookLookupSession``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_book_lookup()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_book_lookup()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_book_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BookLookupSession(runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the comment lookup service for the given book.", "response": "def get_comment_lookup_session_for_book(self, book_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the comment lookup service for the given book.\n\n        arg:    book_id (osid.id.Id): the ``Id`` of the ``Book``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.commenting.CommentLookupSession) - a\n                ``CommentLookupSession``\n        raise:  NotFound - no ``Book`` found by the given ``Id``\n        raise:  NullArgument - ``book_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_comment_lookup()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_comment_lookup()`` and\n        ``supports_visible_federation()`` are ``true``*\n\n        \"\"\"\n        if not self.supports_comment_lookup():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.CommentLookupSession(book_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_comment_query_session(self, proxy):\n        if not self.supports_comment_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CommentQuerySession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the comment query service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the comment query service for the given book.", "response": "def get_comment_query_session_for_book(self, book_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the comment query service for the given book.\n\n        arg:    book_id (osid.id.Id): the ``Id`` of the ``Book``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.commenting.CommentQuerySession) - a\n                ``CommentQuerySession``\n        raise:  NotFound - no ``Comment`` found by the given ``Id``\n        raise:  NullArgument - ``book_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_comment_query()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_comment_query()`` and\n        ``supports_visible_federation()`` are ``true``*\n\n        \"\"\"\n        if not self.supports_comment_query():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.CommentQuerySession(book_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_comment_admin_session(self, proxy):\n        if not self.supports_comment_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CommentAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the comment administration service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the OsidSession associated with the comment administration service for the given book.", "response": "def get_comment_admin_session_for_book(self, book_id, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the comment administration service for the given book.\n\n        arg:    book_id (osid.id.Id): the ``Id`` of the ``Book``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.commenting.CommentAdminSession) - a\n                ``CommentAdminSession``\n        raise:  NotFound - no ``Comment`` found by the given ``Id``\n        raise:  NullArgument - ``book_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_comment_admin()`` or\n                ``supports_visible_federation()`` is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_comment_admin()`` and\n        ``supports_visible_federation()`` are ``true``*\n\n        \"\"\"\n        if not self.supports_comment_admin():\n            raise errors.Unimplemented()\n        ##\n        # Also include check to see if the catalog Id is found otherwise raise errors.NotFound\n        ##\n        # pylint: disable=no-member\n        return sessions.CommentAdminSession(book_id, proxy, self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_book_admin_session(self, proxy):\n        if not self.supports_book_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BookAdminSession(proxy=proxy, runtime=self._runtime)", "response": "Gets the OsidSession associated with the book administrative service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OsidSession associated with the book hierarchy service.", "response": "def get_book_hierarchy_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the book hierarchy service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.commenting.BookHierarchySession) - a\n                ``BookHierarchySession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_book_hierarchy()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_book_hierarchy()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_book_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BookHierarchySession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the OsidSession associated with the book hierarchy design service.", "response": "def get_book_hierarchy_design_session(self, proxy):\n        \"\"\"Gets the ``OsidSession`` associated with the book hierarchy design service.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.commenting.BookHierarchyDesignSession) - a\n                ``BookHierarchyDesignSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_book_hierarchy_design()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_book_hierarchy_design()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_book_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.BookHierarchyDesignSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_items(self):\n\n        conn = self.connect(address=self.server_address, port=self.server_port)\n\n        if conn:\n\n            while not self.queue.empty():\n                item = self.queue.get()\n                self.pool.append(item)\n                if type(item.data) is (tuple or list):\n                    self.body['data'].extend(item.data)\n                else:\n                    self.body['data'].append(item.data)\n            self.logger.debug(self.body['data'])\n\n            try:\n                log_message = (\n                    'Queue length is {0}'.format(len(self.body['data']))\n                )\n                self.logger.debug(log_message)\n                if len(self.body['data']) != 0:\n                    self.send(conn)\n                    self.logger.debug(self.get_result())\n            except:\n                self._reverse_queue()\n                log_message = (\n                    'An error occurred.'\n                    'Maybe socket error, or get invalid value.'\n                )\n                self.logger.debug(log_message)\n            else:\n                del self.body['data'][:]\n\n        self.build_statistics_item()", "response": "Build the items from the queue and send them to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _reverse_queue(self):\n\n        while self.pool:\n            item = self.pool.pop()\n            self.queue.put(item, block=False)", "response": "Reverse the queue of items in the pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_statistics_item(self):\n        if self.result is not None:\n            stats = dict()\n            result = self.get_result()\n            info = result['info']\n            info = info.split(';')\n            info = [entry.split(':') for entry in info]\n\n            prefix = 'blackbird.zabbix_sender'\n\n            for entry in info:\n                key = entry[0].strip()\n                value = None\n\n                if key == 'processed':\n                    value = int(entry[1])\n                elif key == 'failed':\n                    value = int(entry[1])\n                elif key == 'total':\n                    value = int(entry[1])\n                elif key == 'seconds spent':\n                    key = key.replace(' ', '_')\n                    value = float(entry[1])\n                    value *= 1000\n                    value = str(round(value, 6))\n                else:\n                    log_message = (\n                        'Blackbird has never seen {key}. {key} is new key??'\n                        ''.format(key=key)\n                    )\n                    self.logger.info(log_message)\n\n                if value is not None:\n                    key = '.'.join([prefix, key])\n                    stats[key] = value\n\n            if 'response' in result:\n                key = '.'.join([prefix, 'response'])\n                stats[key] = result['response']\n\n            for key, value in stats.iteritems():\n                stats_key_list = [\n                    'blackbird.zabbix_sender.processed',\n                    'blackbird.zabbix_sender.failed',\n                    'blackbird.zabbix_sender.total',\n                ]\n                item = BlackbirdStatisticsItem(\n                    key=key,\n                    value=value,\n                    host=self.options['hostname']\n                )\n                if key in stats_key_list:\n                    if self.enqueue(item=item, queue=self.stats_queue):\n                        self.logger.debug(\n                            'Inserted {0} to the statistics queue'\n                            ''.format(item.data)\n                        )\n                else:\n                    if self.enqueue(item=item, queue=self.queue):\n                        self.logger.debug(\n                            'Inserted {0} to the queue'.format(item.data)\n                        )", "response": "Builds a BlackbirdStatisticsItem object for the current result of the action."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a field to the set of fields.", "response": "def add_field(self, field_instance):\n        \"\"\"\n        Appends a field.\n        \"\"\"\n        if isinstance(field_instance, BaseScriptField):\n            field_instance = field_instance\n        else:\n            raise ValueError('Expected a basetring or Field instance')\n\n        self.fields.append(field_instance)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a json - serializable representation of the object.", "response": "def to_query(self):\n        \"\"\"\n        Returns a json-serializable representation.\n        \"\"\"\n        query = {}\n\n        for field_instance in self.fields:\n            query.update(field_instance.to_query())\n\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a json - serializable representation of the object.", "response": "def to_query(self):\n        \"\"\"\n        Returns a json-serializable representation.\n        \"\"\"\n        return {\n            self.name: {\n                'lang': self.lang,\n                'script': self.script,\n                'params': self.script_params\n            }\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getfield(f):\n    if isinstance(f, list):\n        return [getfield(x) for x in f]\n    else:\n        return f.value", "response": "convert values from cgi. Field objects to plain values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef data(self):\n\n        # the environment variable CONTENT_LENGTH may be empty or missing\n        try:\n            request_body_size = int(self.environ.get('CONTENT_LENGTH', 0))\n        except (ValueError):\n            request_body_size = 0\n\n        data = self.environ['wsgi.input'].read(request_body_size)\n\n        return data", "response": "Returns the data sent with the request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef distro_check():\n    distro_data = platform.linux_distribution()\n    distro = [d.lower() for d in distro_data if d.isalpha()]\n\n    if any(['ubuntu' in distro, 'debian' in distro]) is True:\n        return 'apt'\n    elif any(['centos' in distro, 'redhat' in distro]) is True:\n        return 'yum'\n    elif any(['suse' in distro]) is True:\n        return 'zypper'\n    else:\n        raise AssertionError(\n            'Distro [ %s ] is unsupported.' % distro\n        )", "response": "Return a string containing the distro package manager."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninstall operating system packages for the system.", "response": "def _installer(self, package_list, install_string=None):\n        \"\"\"Install operating system packages for the system.\n\n        :param: package_list: ``list``\n        :param install_string: ``str``\n        \"\"\"\n        packages = ' '.join(package_list)\n\n        if install_string is None:\n            self.install_string = self.install_process[self.distro] % packages\n        else:\n            self.install_string = install_string\n\n        output, outcome = self.shell.run_command(command=self.install_string)\n\n        if outcome is False:\n            raise IOError(output)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install(self):\n        self.distro = distro_check()\n        package_list = self.packages_dict.get(self.distro)\n        self._installer(package_list=package_list.get('packages'))", "response": "Install packages from the packages_dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_commenting_agent(self):\n        if not self.has_commentor():\n            raise errors.IllegalState('this Comment has no commenting_agent')\n        try:\n            from ..authentication import managers\n        except ImportError:\n            raise errors.OperationFailed('failed to import authentication.managers')\n        try:\n            mgr = managers.AuthenticationManager()\n        except:\n            raise errors.OperationFailed('failed to instantiate AuthenticationManager')\n        if not mgr.supports_agent_lookup():\n            raise errors.OperationFailed('Authentication does not support Agent lookup')\n        try:\n            osid_object = mgr.get_agent_lookup_session().get_agent(self.get_commenting_agent_id())\n        except:\n            raise errors.OperationFailed()\n        else:\n            return osid_object", "response": "Gets the agent who created this comment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_rating_id(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_id_template\n        if not bool(self._my_map['ratingId']):\n            raise errors.IllegalState('this Comment has no rating')\n        else:\n            return Id(self._my_map['ratingId'])", "response": "Gets the Id of the Comment s rating."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the metadata for the text", "response": "def get_text_metadata(self):\n        \"\"\"Gets the metadata for the text.\n\n        return: (osid.Metadata) - metadata for the text\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['text'])\n        metadata.update({'existing_string_values': self._my_map['text']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the text for the current language.", "response": "def set_text(self, text):\n        \"\"\"Sets the text.\n\n        arg:    text (string): the new text\n        raise:  InvalidArgument - ``text`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``text`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.repository.AssetForm.set_title_template\n        self._my_map['text'] = self._get_display_text(text, self.get_text_metadata())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the text. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_text(self):\n        \"\"\"Clears the text.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.repository.AssetForm.clear_title_template\n        if (self.get_text_metadata().is_read_only() or\n                self.get_text_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['text'] = dict(self._text_default)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_rating_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['rating'])\n        metadata.update({'existing_id_values': self._my_map['ratingId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a rating."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_rating(self, grade_id):\n        # Implemented from template for osid.resource.ResourceForm.set_avatar_template\n        if self.get_rating_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(grade_id):\n            raise errors.InvalidArgument()\n        self._my_map['ratingId'] = str(grade_id)", "response": "Sets the rating.\n\n        arg:    grade_id (osid.id.Id): the new rating\n        raise:  InvalidArgument - ``grade_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``grade_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear_rating(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_avatar_template\n        if (self.get_rating_metadata().is_read_only() or\n                self.get_rating_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['ratingId'] = self._rating_default", "response": "Clears the rating.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_book(self):\n        if self._lookup_session is None:\n            mgr = get_provider_manager('COMMENTING', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_book_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_book(Id(self._my_map['id']))", "response": "Gets the Book at this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the parents of this book.", "response": "def get_parent_book_nodes(self):\n        \"\"\"Gets the parents of this book.\n\n        return: (osid.commenting.BookNodeList) - the parents of this\n                book\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        parent_book_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_book_nodes.append(BookNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return BookNodeList(parent_book_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider CommentLookupSession. get_comments_for_reference_on_date", "response": "def get_comments_for_reference_on_date(self, reference_id, from_, to):\n        \"\"\"Pass through to provider CommentLookupSession.get_comments_for_reference_on_date\"\"\"\n        # Implemented from azosid template for -\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source_on_date_template\n        if self._can('lookup'):\n            return self._provider_session.get_comments_for_reference_on_date(reference_id, from_, to)\n        self._check_lookup_conditions()  # raises PermissionDenied\n        query = self._query_session.get_comment_query()\n        query.match_source_id(reference_id, match=True)\n        query.match_date(from_, to, match=True)\n        return self._try_harder(query)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_comments_by_search(self, comment_query, comment_search):\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_comments_by_search(comment_query, comment_search)", "response": "Pass through to provider CommentSearchSession. get_comments_by_search"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_genus_type(self):\n        try:\n            # Try to stand up full Type objects if they can be found\n            # (Also need to LOOK FOR THE TYPE IN types or through type lookup)\n            genus_type_identifier = Id(self._my_map['genusTypeId']).get_identifier()\n            return Type(**types.Genus().get_type_data(genus_type_identifier))\n        except:\n            # If that doesn't work, return the id only type, still useful for comparison.\n            return Type(idstr=self._my_map['genusTypeId'])", "response": "Gets the genus type of this object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _is_valid_input(self, inpt, metadata, array):\n        # pylint: disable=too-many-branches,no-self-use\n        # Please redesign, and move to utility module\n        syntax = metadata.get_syntax()\n\n        # First check if this is a required data element\n        if metadata.is_required and not inpt:\n            return False\n\n        valid = True  # Innocent until proven guilty\n        # Recursively run through all the elements of an array\n        if array:\n            if len(inpt) < metadata.get_minimum_elements():\n                valid = False\n            elif len(inpt) > metadata.get_maximum_elements():\n                valid = False\n            else:\n                for element in inpt:\n                    valid = (valid and self._is_valid_input(element, metadata, False))\n\n        # Run through all the possible syntax types\n        elif syntax == 'ID':\n            valid = self._is_valid_id(inpt)\n        elif syntax == 'TYPE':\n            valid = self._is_valid_type(inpt)\n        elif syntax == 'BOOLEAN':\n            valid = self._is_valid_boolean(inpt)\n        elif syntax == 'STRING':\n            valid = self._is_valid_string(inpt, metadata)\n        elif syntax == 'INTEGER':\n            valid = self._is_valid_integer(inpt, metadata)\n        elif syntax == 'DECIMAL':\n            valid = self._is_valid_decimal(inpt, metadata)\n        elif syntax == 'DATETIME':\n            valid = self._is_valid_date_time(inpt, metadata)\n        elif syntax == 'DURATION':\n            valid = self._is_valid_duration(inpt, metadata)\n        elif syntax == 'CARDINAL':\n            valid = self._is_valid_cardinal(inpt, metadata)\n        elif syntax == 'INTEGER':\n            valid = self._is_valid_integer(inpt, metadata)\n        elif syntax == 'DECIMAL':\n            valid = self._is_valid_decimal(inpt, metadata)\n        else:\n            raise errors.OperationFailed('no validation function available for ' + syntax)\n\n        return valid", "response": "Checks if the user input is a valid entry in the specified object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if input is a valid Id", "response": "def _is_valid_id(self, inpt):\n        \"\"\"Checks if input is a valid Id\"\"\"\n        from dlkit.abstract_osid.id.primitives import Id as abc_id\n        if isinstance(inpt, abc_id):\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_valid_type(self, inpt):\n        from dlkit.abstract_osid.type.primitives import Type as abc_type\n        if isinstance(inpt, abc_type):\n            return True\n        else:\n            return False", "response": "Checks if input is a valid Type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if input is a valid string", "response": "def _is_valid_string(self, inpt, metadata):\n        \"\"\"Checks if input is a valid string\"\"\"\n        if not is_string(inpt):\n            return False\n        if metadata.get_minimum_string_length() and len(inpt) < metadata.get_minimum_string_length():\n            return False\n        elif metadata.get_maximum_string_length() and len(inpt) > metadata.get_maximum_string_length():\n            return False\n        if metadata.get_string_set() and inpt not in metadata.get_string_set():\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if input is a valid cardinal value", "response": "def _is_valid_cardinal(self, inpt, metadata):\n        \"\"\"Checks if input is a valid cardinal value\"\"\"\n        if not isinstance(inpt, int):\n            return False\n        if metadata.get_minimum_cardinal() and inpt < metadata.get_maximum_cardinal():\n            return False\n        if metadata.get_maximum_cardinal() and inpt > metadata.get_minimum_cardinal():\n            return False\n        if metadata.get_cardinal_set() and inpt not in metadata.get_cardinal_set():\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _is_valid_integer(self, inpt, metadata):\n        if not isinstance(inpt, int):\n            return False\n        if metadata.get_minimum_integer() and inpt < metadata.get_maximum_integer():\n            return False\n        if metadata.get_maximum_integer() and inpt > metadata.get_minimum_integer():\n            return False\n        if metadata.get_integer_set() and inpt not in metadata.get_integer_set():\n            return False\n        else:\n            return True", "response": "Checks if input is a valid integer value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if input is a valid decimal value", "response": "def _is_valid_decimal(self, inpt, metadata):\n        \"\"\"Checks if input is a valid decimal value\"\"\"\n        if not (isinstance(inpt, float) or isinstance(inpt, Decimal)):\n            return False\n        if not isinstance(inpt, Decimal):\n            inpt = Decimal(str(inpt))\n        if metadata.get_minimum_decimal() and inpt < metadata.get_minimum_decimal():\n            return False\n        if metadata.get_maximum_decimal() and inpt > metadata.get_maximum_decimal():\n            return False\n        if metadata.get_decimal_set() and inpt not in metadata.get_decimal_set():\n            return False\n        if metadata.get_decimal_scale() and len(str(inpt).split('.')[-1]) != metadata.get_decimal_scale():\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _is_valid_date_time(self, inpt, metadata):\n        # NEED TO ADD CHECKS FOR OTHER METADATA, LIKE MINIMUM, MAXIMUM, ETC.\n        from dlkit.abstract_osid.calendaring.primitives import DateTime as abc_datetime\n        if isinstance(inpt, abc_datetime):\n            return True\n        else:\n            return False", "response": "Checks if input is a valid DateTime object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if input is a valid Duration", "response": "def _is_valid_duration(self, inpt, metadata):\n        \"\"\"Checks if input is a valid Duration\"\"\"\n        # NEED TO ADD CHECKS FOR OTHER METADATA, LIKE MINIMUM, MAXIMUM, ETC.\n        from dlkit.abstract_osid.calendaring.primitives import Duration as abc_duration\n        if isinstance(inpt, abc_duration):\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_in_set(self, inpt, metadata):\n        # makes an assumption there is only one _set in the metadata dict\n        get_set_methods = [m for m in dir(metadata) if 'get_' in m and '_set' in m]\n        set_results = None\n        for m in get_set_methods:\n            try:\n                set_results = getattr(metadata, m)()\n                break\n            except errors.IllegalState:\n                pass\n        if set_results is not None and inpt in set_results:\n            return True\n        return False", "response": "checks if the input is in the metadata s _set list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_locale(self, language_type, script_type):\n        # Someday I might have a real implementation\n        # For now only default Locale is supported\n        self._locale_map['languageType'] = language_type\n        self._locale_map['scriptType'] = script_type", "response": "Sets the locale for the display text fields in this form."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a comment. arg: comment (string): the new comment raise: InvalidArgument - ``comment`` is invalid raise: NoAccess - ``Metadata.isReadonly()`` is ``true`` raise: NullArgument - ``comment`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_journal_comment(self, comment):\n        \"\"\"Sets a comment.\n\n        arg:    comment (string): the new comment\n        raise:  InvalidArgument - ``comment`` is invalid\n        raise:  NoAccess - ``Metadata.isReadonly()`` is ``true``\n        raise:  NullArgument - ``comment`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._my_map['journal_comment'] = self._get_display_text(comment, self.get_journal_comment_metadata())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\noverride this from osid. Extensible because Forms use a different attribute in record_type_data.", "response": "def _init_record(self, record_type_idstr):\n        \"\"\"Override this from osid.Extensible because Forms use a different\n        attribute in record_type_data.\"\"\"\n        record_type_data = self._record_type_data_sets[Id(record_type_idstr).get_identifier()]\n        module = importlib.import_module(record_type_data['module_path'])\n        record = getattr(module, record_type_data['form_record_class_name'])\n        if record is not None:\n            self._records[record_type_idstr] = record(self)\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_start_date_metadata(self):\n        metadata = dict(self._mdata['start_date'])\n        metadata.update({'existing_date_time_values': self._my_map['startDate']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the start date"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the start date.", "response": "def set_start_date(self, date):\n        \"\"\"Sets the start date.\n\n        arg:    date (osid.calendaring.DateTime): the new date\n        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``date`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.get_start_date_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_date_time(date, self.get_start_date_metadata()):\n            raise errors.InvalidArgument()\n        # self._my_map['startDate'] = self._get_date_map(date)\n        self._my_map['startDate'] = date"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears the start date.", "response": "def clear_start_date(self):\n        \"\"\"Clears the start date.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_start_date_metadata().is_read_only() or\n                self.get_start_date_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['startDate'] = self._mdata['start_date']['default_date_time_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the metadata for an end date", "response": "def get_end_date_metadata(self):\n        \"\"\"Gets the metadata for an end date.\n\n        return: (osid.Metadata) - metadata for the date\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = dict(self._mdata['end_date'])\n        metadata.update({'existing_date_time_values': self._my_map['endDate']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the end date.", "response": "def set_end_date(self, date):\n        \"\"\"Sets the end date.\n\n        arg:    date (osid.calendaring.DateTime): the new date\n        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``date`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.get_end_date_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_date_time(date, self.get_end_date_metadata()):\n            raise errors.InvalidArgument()\n        # self._my_map['endDate'] = self._get_date_map(date)\n        self._my_map['endDate'] = date"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclear the end date.", "response": "def clear_end_date(self):\n        \"\"\"Clears the end date.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_end_date_metadata().is_read_only() or\n                self.get_end_date_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['endDate'] = self._mdata['end_date']['default_date_time_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the sequestered flag.", "response": "def set_sequestered(self, sequestered):\n        \"\"\"Sets the sequestered flag.\n\n        arg:    sequestered (boolean): the new sequestered flag\n        raise:  InvalidArgument - ``sequestered`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if sequestered is None:\n            raise errors.NullArgument()\n        if self.get_sequestered_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not isinstance(sequestered, bool):\n            raise errors.InvalidArgument()\n        self._my_map['sequestered'] = sequestered"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear_sequestered(self):\n        if (self.get_sequestered_metadata().is_read_only() or\n                self.get_sequestered_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['sequestered'] = self._sequestered_default", "response": "Clears the sequestered flag."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_provider_metadata(self):\n        metadata = dict(self._mdata['provider'])\n        metadata.update({'existing_id_values': self._my_map['providerId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a provider"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_provider(self, provider_id):\n        if self.get_provider_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(provider_id):\n            raise errors.InvalidArgument()\n        self._my_map['providerId'] = str(provider_id)", "response": "Sets a provider.\n\n        arg:    provider_id (osid.id.Id): the new provider\n        raise:  InvalidArgument - ``provider_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``provider_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_provider(self):\n        if (self.get_provider_metadata().is_read_only() or\n                self.get_provider_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['providerId'] = self._provider_default", "response": "Removes the provider.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_branding_metadata(self):\n        metadata = dict(self._mdata['branding'])\n        metadata.update({'existing_id_values': self._my_map['brandingIds']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the asset branding."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_branding(self, asset_ids):\n        if self.get_branding_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_input(asset_ids, self.get_branding_metadata(), array=True):\n            raise errors.InvalidArgument()\n        branding_ids = []\n        for asset_id in asset_ids:\n            branding_ids.append(str(asset_id))\n        self._my_map['brandingIds'] = branding_ids", "response": "Sets the branding.\n\n        arg:    asset_ids (osid.id.Id[]): the new assets\n        raise:  InvalidArgument - ``asset_ids`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``asset_ids`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_license_metadata(self):\n        metadata = dict(self._mdata['license'])\n        metadata.update({'existing_string_values': self._my_map['license']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the license"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the license. arg: license (string): the new license raise: InvalidArgument - ``license`` is invalid raise: NoAccess - ``Metadata.isReadOnly()`` is ``true`` raise: NullArgument - ``license`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_license(self, license_):\n        \"\"\"Sets the license.\n\n        arg:    license (string): the new license\n        raise:  InvalidArgument - ``license`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``license`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._my_map['license'] = self._get_display_text(license_, self.get_license_metadata())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_license(self):\n        if (self.get_license_metadata().is_read_only() or\n                self.get_license_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['license'] = dict(self._license_default)", "response": "Removes the license.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _init_metadata(self, **kwargs):\n        self._mdata.update(default_mdata.get_osid_object_mdata())\n        OsidForm._init_metadata(self)\n        if 'default_display_name' in kwargs:\n            self._mdata['display_name']['default_string_values'][0]['text'] = kwargs['default_display_name']\n        update_display_text_defaults(self._mdata['display_name'], self._locale_map)\n        if 'default_description' in kwargs:\n            self._mdata['description']['default_string_values'][0]['text'] = kwargs['default_description']\n        update_display_text_defaults(self._mdata['description'], self._locale_map)\n        self._display_name_default = dict(self._mdata['display_name']['default_string_values'][0])\n        self._description_default = dict(self._mdata['description']['default_string_values'][0])\n        self._genus_type_default = self._mdata['genus_type']['default_type_values'][0]\n\n        if 'mdata' in kwargs:\n            self._mdata.update(kwargs['mdata'])", "response": "Initialize metadata for the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the map for the form.", "response": "def _init_map(self, record_types=None):\n        \"\"\"Initialize map for form\"\"\"\n        OsidForm._init_map(self)\n        self._my_map['displayName'] = dict(self._display_name_default)\n        self._my_map['description'] = dict(self._description_default)\n        self._my_map['genusTypeId'] = self._genus_type_default\n        OsidExtensibleForm._init_map(self, record_types)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_display_name_metadata(self):\n        metadata = dict(self._mdata['display_name'])\n        metadata.update({'existing_string_values': self._my_map['displayName']['text']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a display name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_display_name(self, display_name):\n        self._my_map['displayName'] = self._get_display_text(display_name, self.get_display_name_metadata())", "response": "Sets the display name for this asset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclear the display name.", "response": "def clear_display_name(self):\n        \"\"\"Clears the display name.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (self.get_display_name_metadata().is_read_only() or\n                self.get_display_name_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['displayName'] = dict(self._display_name_default)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the metadata for a description", "response": "def get_description_metadata(self):\n        \"\"\"Gets the metadata for a description.\n\n        return: (osid.Metadata) - metadata for the description\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        metadata = dict(self._mdata['description'])\n        metadata.update({'existing_string_values': self._my_map['description']['text']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the description for this assessment.", "response": "def set_description(self, description):\n        \"\"\"Sets a description.\n\n        arg:    description (string): the new description\n        raise:  InvalidArgument - ``description`` is invalid\n        raise:  NoAccess - ``Metadata.isReadonly()`` is ``true``\n        raise:  NullArgument - ``description`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        self._my_map['description'] = self._get_display_text(description, self.get_description_metadata())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_description(self):\n        if (self.get_description_metadata().is_read_only() or\n                self.get_description_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['description'] = dict(self._description_default)", "response": "Clears the description.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_genus_type_metadata(self):\n        metadata = dict(self._mdata['genus_type'])\n        metadata.update({'existing_string_values': self._my_map['genusTypeId']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a genus type"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_genus_type(self, genus_type):\n        if self.get_genus_type_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_type(genus_type):\n            raise errors.InvalidArgument()\n        self._my_map['genusTypeId'] = str(genus_type)", "response": "Sets a genus.\n\n        A genus cannot be cleared because all objects have at minimum a\n        root genus.\n\n        arg:    genus_type (osid.type.Type): the new genus\n        raise:  InvalidArgument - ``genus_type`` is invalid\n        raise:  NoAccess - ``Metadata.isReadonly()`` is ``true``\n        raise:  NullArgument - ``genus_type`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_genus_type(self):\n        if (self.get_genus_type_metadata().is_read_only() or\n                self.get_genus_type_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['genusTypeId'] = self._genus_type_default", "response": "Clears the genus type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the next n elements in this list.", "response": "def _get_next_n(self, object_class, number=None):\n        \"\"\"Gets the next set of \"n\" elements in this list.\n\n        The specified amount must be less than or equal to the return\n        from ``available()``.\n\n        arg:    n (cardinal): the number of ``Relationship`` elements\n                requested which must be less than or equal to\n                ``available()``\n        return: (osid.relationship.Relationship) - an array of\n                ``Relationship`` elements.The length of the array is\n                less than or equal to the number specified.\n        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if number > self.available():\n            # !!! This is not quite as specified (see method docs) !!!\n            raise errors.IllegalState('not enough elements available in this list')\n        else:\n            next_list = []\n            counter = 0\n            while counter < number:\n                try:\n                    next_list.append(next(self))\n                except Exception:  # Need to specify exceptions here!\n                    raise errors.OperationFailed()\n                counter += 1\n            return object_class(next_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting next object from list", "response": "def _get_next_object(self, object_class):\n        \"\"\"stub\"\"\"\n        next_object = OsidList.next(self)\n        if isinstance(next_object, dict):\n            next_object = object_class(osid_object_map=next_object, runtime=self._runtime, proxy=self._proxy)\n        elif is_string(next_object) and object_class == Id:\n            next_object = Id(next_object)\n        return next_object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef skip(self, n):\n        try:\n            self._iter_object.skip(n)\n        except AttributeError:\n            for i in range(0, n):\n                self.next()", "response": "Skip the specified number of elements in the list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the parents of this node.", "response": "def get_parent_ids(self):\n        \"\"\"Gets the parents of this node.\n\n        return: (osid.id.IdList) - the parents of this node\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        id_list = []\n        from ..id.objects import IdList\n        for parent_node in self._my_map['parentNodes']:\n            id_list.append(str(parent_node.ident))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the children of this node.", "response": "def get_child_ids(self):\n        \"\"\"Gets the children of this node.\n\n        return: (osid.id.IdList) - the children of this node\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        id_list = []\n        from ..id.objects import IdList\n        for child_node in self._my_map['childNodes']:\n            id_list.append(str(child_node.ident))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the Family at this node.", "response": "def get_family(self):\n        \"\"\"Gets the ``Family`` at this node.\n\n        return: (osid.relationship.Family) - the family represented by\n                this node\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._lookup_session is None:\n            mgr = get_provider_manager('RELATIONSHIP', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_family_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_family(Id(self._my_map['id']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_parent_family_nodes(self):\n        parent_family_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_family_nodes.append(FamilyNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return FamilyNodeList(parent_family_nodes)", "response": "Gets the parents of this family."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting configuration for superficial aspects of display.", "response": "def set_display_config(cls, config): # pragma: no cover\n        \"\"\"\n        Set configuration for superficial aspects of display.\n\n        :param DisplayConfig config: a configuration object\n        \"\"\"\n        cls.DISPLAY_CONFIG = DisplayConfig(\n            show_approx_str=config.show_approx_str,\n            base_config=config.base_config,\n            digits_config=config.digits_config,\n            strip_config=config.strip_config\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a cache key for a model instance.", "response": "def cache_key(model, pk):\n    \"Generates a cache key for a model instance.\"\n    app = model._meta.app_label\n    name = model._meta.module_name\n    return 'api:{0}:{1}:{2}'.format(app, name, pk)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the genpred format string representation of the mapping", "response": "def transcript_to_gpd_line(tx,transcript_name=None,gene_name=None,direction=None):\n    \"\"\"Get the genpred format string representation of the mapping\n\n    :param transcript_name:\n    :param gene_name:\n    :param strand:\n    :type transcript_name: string\n    :type gene_name: string\n    :type strand: string\n    :return: GPD line\n    :rtype: string\n    \"\"\"\n    tname = tx._options.name\n    if transcript_name: tname = transcript_name\n    gname = tx._options.gene_name\n    if gene_name: gname = gene_name\n    dir = tx._options.direction\n    if direction: dir = direction\n    # check for if we just have a single name\n    if not tname: tname = str(uuid.uuid4())\n    if not gname:\n        gname = tname\n    out = ''\n    out += gname + \"\\t\"\n    out += tname + \"\\t\"\n    out += tx.exons[0].chr + \"\\t\"\n    out += dir + \"\\t\"\n    out += str(tx.exons[0].start-1) + \"\\t\"\n    out += str(tx.exons[-1].end) + \"\\t\"\n    out += str(tx.exons[0].start-1) + \"\\t\"\n    out += str(tx.exons[-1].end) + \"\\t\"\n    out += str(len(tx.exons)) + \"\\t\"\n    out += str(','.join([str(x.start-1) for x in tx.exons]))+','+\"\\t\"\n    out += str(','.join([str(x.end) for x in tx.exons]))+','\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a mapping from a genome to a fake PSL line.", "response": "def transcript_to_fake_psl_line(self,ref):\n    \"\"\"Convert a mapping to a fake PSL line\n\n    :param ref: reference genome dictionary\n    :type ref: dict()\n    :return: psl line\n    :rtype: string\n    \"\"\"\n    self._initialize()\n    e = self\n    mylen = 0\n    matches = 0\n    qstartslist = []\n    for exon in self.exons:\n      mylen = exon.rng.length()\n      matches += mylen\n      qstartslist.append(matches-mylen)\n    qstarts = ','.join([str(x) for x in qstartslist])+','\n    oline =  str(matches)+\"\\t\" # 1\n    oline += \"0\\t\" # 2\n    oline += \"0\\t\" # 3\n    oline += \"0\\t\" # 4\n    oline += \"0\\t\" # 5\n    oline += \"0\\t\" # 6\n    oline += \"0\\t\" # 7\n    oline += \"0\\t\" # 8\n    oline += e.get_strand()+\"\\t\" # 9\n    oline += e.get_transcript_name()+\"\\t\" # 10\n    oline += str(matches)+\"\\t\" # 11\n    oline += \"0\\t\" # 12\n    oline += str(matches)+\"\\t\" # 13\n    oline += e.get_chrom()+\"\\t\" # 14\n    oline += str(len(ref[e.get_chrom()]))+\"\\t\" # 15\n    oline += str(e.exons[0].rng.start-1)+\"\\t\" # 16\n    oline += str(e.exons[-1].rng.end)+\"\\t\" # 17\n    oline += str(len(e.exons))+\"\\t\" # 18\n    oline += ','.join([str(e.exons[x].rng.end-(e.exons[x].rng.start-1)) for x in range(0,len(e.exons))])+','+\"\\t\" # 19\n    oline += qstarts + \"\\t\" # 20\n    oline += ','.join([str(x.rng.start-1) for x in e.exons])+',' # 21\n    return oline"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef invoke(self, ns, request_name, params, auth_token, simplify=False):\n        ZimbraClientTransport.invoke(self,\n                                     ns,\n                                     request_name,\n                                     params,\n                                     auth_token,\n                                     simplify)\n\n        headers = SOAPpy.Types.headerType()\n\n        if auth_token.token != None:\n            data={sconstant.E_AUTH_TOKEN: auth_token.token,\n                  sconstant.E_SESSION_ID: auth_token.session_id}\n            context = SOAPpy.Types.structType(data=data, name=sconstant.CONTEXT)\n            context._validURIs = []\n            context._ns = (zconstant.SOAP_DEFAULT_PREFIX, zconstant.NS_ZIMBRA_URL)\n            headers.context = context\n\n        proxy = SOAPpy.SOAPProxy(self.soap_url,\n                                 ns,\n                                 header=headers,\n                                 noroot=1,\n                                 simplify_objects=simplify)\n        proxy.config.debug = self.log.isEnabledFor(logging.DEBUG)\n        proxy.config.strictNamespaces = 0\n        proxy.config.buildWithNamespacePrefix = 0\n        proxy.transport = self.http_transport\n\n        _parseSOAP = SOAPpy.Parser._parseSOAP\n        SOAPpy.Parser._parseSOAP = parseSOAP\n        try:\n            m = proxy.__getattr__(request_name)\n            return m.__call__(**params)\n        finally:\n            SOAPpy.Parser._parseSOAP = _parseSOAP", "response": "Invoke the zimbra soap request."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    if name in ISO_CURRENCY_TYPES:\n        article = 'the '\n        type_name = ISO_CURRENCY_TYPES[name]\n    elif name in ISO_CURRENCY_ELEMENT_TYPES:\n        article = ''\n        type_name = ISO_CURRENCY_ELEMENT_TYPES[name]\n    else:\n        raise NotFound('Currency Type: ' + name)\n\n    return {\n        'authority': 'ISO',\n        'namespace': '4217',\n        'identifier': name,\n        'domain': 'ISO Currency Types',\n        'display_name': type_name + ' Currency Type',\n        'display_label': type_name,\n        'description': ('The ISO currency type for ' + article +\n                        type_name + '.')\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding package data in a distutils setup. py file.", "response": "def find_package_data(\n    where='.', package='',\n    exclude=standard_exclude,\n    exclude_directories=standard_exclude_directories,\n    only_in_packages=True,\n    show_ignored=False,\n    ):\n    \"\"\"\n    Return a dictionary suitable for use in ``package_data``\n    in a distutils ``setup.py`` file.\n\n    The dictionary looks like::\n\n        {'package': [files]}\n\n    Where ``files`` is a list of all the files in that package that\n    don't match anything in ``exclude``.\n\n    If ``only_in_packages`` is true, then top-level directories that\n    are not packages won't be included (but directories under packages\n    will).\n\n    Directories matching any pattern in ``exclude_directories`` will\n    be ignored; by default directories with leading ``.``, ``CVS``,\n    and ``_darcs`` will be ignored.\n\n    If ``show_ignored`` is true, then all the files that aren't\n    included in package data are shown on stderr (for debugging\n    purposes).\n\n    Note patterns use wildcards, or can be exact paths (including\n    leading ``./``), and all searching is case-insensitive.\n\n    This function is by Ian Bicking.\n    \"\"\"\n\n    out = {}\n    stack = [(convert_path(where), '', package, only_in_packages)]\n    while stack:\n        where, prefix, package, only_in_packages = stack.pop(0)\n        for name in os.listdir(where):\n            fn = os.path.join(where, name)\n            if os.path.isdir(fn):\n                bad_name = False\n                for pattern in exclude_directories:\n                    if (fnmatchcase(name, pattern)\n                        or fn.lower() == pattern.lower()):\n                        bad_name = True\n                        if show_ignored:\n                            print >> sys.stderr, (\n                                \"Directory %s ignored by pattern %s\"\n                                % (fn, pattern))\n                        break\n                if bad_name:\n                    continue\n                if os.path.isfile(os.path.join(fn, '__init__.py')):\n                    if not package:\n                        new_package = name\n                    else:\n                        new_package = package + '.' + name\n                    stack.append((fn, '', new_package, False))\n                else:\n                    stack.append((fn,\n                                  prefix + name + '/',\n                                  package,\n                                  only_in_packages))\n            elif package or not only_in_packages:\n                # is a file\n                bad_name = False\n                for pattern in exclude:\n                    if (fnmatchcase(name, pattern)\n                        or fn.lower() == pattern.lower()):\n                        bad_name = True\n                        if show_ignored:\n                            print >> sys.stderr, (\n                                \"File %s ignored by pattern %s\"\n                                % (fn, pattern))\n                        break\n                if bad_name:\n                    continue\n                out.setdefault(package, []).append(prefix + name)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a standard button box.", "response": "def buttons(self, master):\n        '''Add a standard button box.\n\n        Override if you do not want the standard buttons\n        '''\n\n        box = tk.Frame(master)\n\n        ttk.Button(\n            box,\n            text=\"Next\",\n            width=10,\n            command=self.next_day\n        ).pack(side=tk.LEFT, padx=5, pady=5)\n        ttk.Button(\n            box,\n            text=\"OK\",\n            width=10,\n            command=self.ok,\n            default=tk.ACTIVE\n        ).pack(side=tk.LEFT, padx=5, pady=5)\n        ttk.Button(\n            box,\n            text=\"Cancel\",\n            width=10,\n            command=self.cancel\n        ).pack(side=tk.LEFT, padx=5, pady=5)\n\n        self.bind(\"n\", self.next_day)\n        self.bind(\"<Return>\", self.ok)\n        self.bind(\"<Escape>\", self.cancel)\n\n        box.pack()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close(self):\n    self._target_context_errors = None\n    self._query_context_errors = None\n    self._general_errors = None\n    for ae in self._alignment_errors:\n      ae.close()\n    self._alignment_errors = None", "response": "Close all objects in the sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds an alignment error to the list of errors that are not found in the current context.", "response": "def add_alignment_errors(self,ae):\n    \"\"\"If you alread have thealignment errors, add them for profile construction.\"\"\"\n    self._target_context_errors = None\n    self._query_context_errors = None\n    self._alignment_errors.append(ae)\n    self._general_errors.add_alignment_errors(ae)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_alignment(self,align):\n    self._target_context_errors = None\n    self._query_context_errors = None\n    ae = AlignmentErrors(align)\n    self._alignment_errors.append(ae)\n    self._general_errors.add_alignment_errors(ae)", "response": "Calculate alignment errors from the alignment and add it to the profile."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_target_context_error_report(self):\n    report = {}\n    report['header'] = ['before','after','reference','query','fraction']\n    report['data'] = []\n    r = self.get_target_context_errors()\n    for b in sorted(r.keys()):\n      for a in sorted(r[b].keys()):\n        for t in sorted(r[b][a]):\n          for q in sorted(r[b][a]):\n            v = 0\n            if r[b][a][t]['total'] > 0:\n              v = float(r[b][a][t]['types'][q])/float(r[b][a][t]['total'])\n            report['data'].append([b,a,t,q,v])\n    return report", "response": "Get a report on context - specific errors relative to what is expected on the target strand."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate out which context has the minum coverage thusfar.", "response": "def get_min_context_count(self,context_type):\n    \"\"\"Calculate out which context has the minum coverage thusfar.\n\n    :param context_type: 'target' or 'query'\n    :type context_type: string\n    :returns: Minimum Coverage\n    :rtype: int\n\n    \"\"\"\n    cnt = 10000000000\n    bases = ['A','C','G','T']\n    basesplus = ['A','C','G','T','-']\n    r = None\n    if context_type == 'target':\n      r = self.get_target_context_errors()\n    elif context_type == 'query':\n      r = self.get_query_context_errors()\n    else:\n      sys.stderr.write(\"ERROR incorrect context type\\n\")\n      sys.exit()\n    for b1 in bases:\n      for b2 in bases:\n        for b3 in basesplus:\n          if r[b1][b2][b3]['total'] < cnt: cnt = r[b1][b2][b3]['total']\n    return cnt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_context_error_report(self,file,context_type):\n    if context_type == 'target':\n      r = self.get_target_context_error_report()\n    elif context_type == 'query':\n      r = self.get_query_context_error_report()\n    else:\n      sys.stderr.write(\"ERROR invalid type must be target or query\\n\")\n      sys.exit()\n    of = open(file,'w')\n    of.write(\"\\t\".join(r['header'])+\"\\n\")\n    for row in r['data']:\n      of.write(\"\\t\".join([str(x) for x in row])+\"\\n\")\n    return", "response": "Writes a context error report relative to the target or query based on the profile."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a report on context - specific errors relative to what is expected on the query strand.", "response": "def get_query_context_error_report(self):\n    \"\"\"Get a report on context-specific errors relative to what is expected on the query strand.\n\n    :returns: Object with a 'header' and a 'data' where data describes context: before,after ,reference, query.  A total is kept for each reference base, and individual errors are finally checked\n    :rtype: dict()\n\n    \"\"\"\n    report = {}\n    report['header'] = ['before','after','reference','query','fraction']\n    report['data'] = []\n    r = self.get_query_context_errors()\n    for b in sorted(r.keys()):\n      for a in sorted(r[b].keys()):\n        for t in sorted(r[b][a]):\n          for q in sorted(r[b][a]):\n            v = 0\n            if r[b][a][q]['total'] > 0:\n              v = float(r[b][a][q]['types'][t])/float(r[b][a][q]['total'])\n            report['data'].append([b,a,t,q,v])\n    return report"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef combine_context_errors(self):\n    r = {}\n    if self._target_context_errors: r = self._target_context_errors\n    for k in [x.get_context_target_errors() for x in self._alignment_errors]:\n      for b in k:\n        if b not in r: r[b] = {}\n        for c in k[b]:\n          if c not in r[b]: r[b][c] = {}\n          for a in k[b][c]:\n            if a not in r[b][c]: \n              r[b][c][a] = {}\n              r[b][c][a]['total'] = 0\n              r[b][c][a]['types'] = {}\n            r[b][c][a]['total'] += k[b][c][a]['total']\n            for type in k[b][c][a]['types']:\n              if type not in r[b][c][a]['types']: r[b][c][a]['types'][type] = 0\n              r[b][c][a]['types'][type] += k[b][c][a]['types'][type]\n    self._target_context_errors = r\n    r = {}\n    if self._query_context_errors: r = self._query_context_errors\n    for k in [x.get_context_query_errors() for x in self._alignment_errors]:\n      for b in k:\n        if b not in r: r[b] = {}\n        for c in k[b]:\n          if c not in r[b]: r[b][c] = {}\n          for a in k[b][c]:\n            if a not in r[b][c]: \n              r[b][c][a] = {}\n              r[b][c][a]['total'] = 0\n              r[b][c][a]['types'] = {}\n            r[b][c][a]['total'] += k[b][c][a]['total']\n            for type in k[b][c][a]['types']:\n              if type not in r[b][c][a]['types']: r[b][c][a]['types'][type] = 0\n              r[b][c][a]['types'][type] += k[b][c][a]['types'][type]\n    self._query_context_errors = r", "response": "Combine the error counts on the context base and the error counts on the query base."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_string(self):\n    ostr = ''\n    ostr += str(len(self._alignment_errors))+\" Alignments\\n\"\n    ostr += 'Target: '+\"\\n\"\n    totbases = sum([len(x.get_target_sequence()) for x in self._alignment_errors])\n    ostr += '  '+str(totbases)+\" Target Bases\\n\"\n    adjerror = sum([sum([y.get_error_probability() for y in x.get_target_errors()]) for x in self._alignment_errors])\n    ostr += '  '+str(adjerror)+\" Approximate error count\\n\"\n    ostr += '  '+str(float(adjerror)/float(totbases))+\" Error rate\\n\"\n    ostr += 'Query: '+\"\\n\"\n    totbases = sum([len(x.get_query_sequence()) for x in self._alignment_errors])\n    ostr += '  '+str(totbases)+\" Query Bases\\n\"\n    adjerror = sum([sum([y.get_error_probability() for y in x.get_query_errors()]) for x in self._alignment_errors])\n    ostr += '  '+str(adjerror)+\" Approximate error count\\n\"\n    ostr += '  '+str(float(adjerror)/float(totbases))+\" Error rate\\n\"\n    return ostr", "response": "Make a string reprentation of the error stats."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the error probability of the base object.", "response": "def get_error_probability(self):\n    \"\"\"This means for the base we are talking about how many errors between 0 and 1 do we attribute to it?\n       For the 'unobserved' errors, these can only count when one is adjacent to base\n\n    :returns: error probability p(error_observed)+(1-p_error_observed)*error_unobserved\n    :rtype: float\n\n    \"\"\"\n    a = self._observable.get_error_probability()\n    b = self._unobservable.get_error_probability()\n    return a+(1-a)*b"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_observable(self,tseq,qseq):\n    tnt = None\n    qnt = None\n    if len(tseq) > 0: tnt = tseq[0]\n    if len(qseq) > 0: qnt = qseq[0]\n    self._observable.set(len(tseq),len(qseq),tnt,qnt)", "response": "Set the observable sequence"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_unobserved_before(self,tlen,qlen,nt,p):\n    self._unobservable.set_before(tlen,qlen,nt,p)", "response": "Set the unobservable sequence data before this base base"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the unobservable sequence data after this base", "response": "def set_unobserved_after(self,tlen,qlen,nt,p):\n    \"\"\"Set the unobservable sequence data after this base\n\n    :param tlen: target homopolymer length\n    :param qlen: query homopolymer length\n    :param nt: nucleotide\n    :param p: p is the probability of attributing this base to the unobserved error\n    :type tlen: int\n    :type qlen: int\n    :type nt: char\n    :type p: float\n\n    \"\"\"\n    self._unobservable.set_after(tlen,qlen,nt,p)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_adjusted_error_count(self):\n    p1 =  self._observable.get_attributable_length()\n    p1 += self._unobservable.get_attributable_length()\n    return p1", "response": "Returns the total error count associated with this base."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the single base at this position.", "response": "def get_base(self):\n    \"\"\" Get the single base at this position.\n\n    :returns: base\n    :rtype: char\n\n    \"\"\"\n    if self._type == 'query':\n      return self._observable.get_query_base()\n    return self._observable.get_target_base()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a string representation of this base error.", "response": "def get_string(self):\n    \"\"\" Get a string representation of this single base error.\n\n    :returns: report\n    :rtype: string\n\n\n    \"\"\"\n    ostr = ''\n    ostr += 'BaseError for ['+self._type+'] base: '+self.get_base()+\"\\n\"\n    if self._observable.get_error_probability() > 0:\n      ostr += '  Homopolymer set:'+\"\\n\"\n      ostr += '    '+str(self.get_homopolymer())+\"\\n\"\n      ostr += '  Observable:'+\"\\n\"\n      ostr += '    type is: '+str(self.get_observable_type())+\"\\n\"\n      ostr += '    P(error): '+str(self._observable.get_error_probability())+\"\\n\"\n      ostr += '    Elength:  '+str(self._observable.get_attributable_length())+\"\\n\"\n    before = self._unobservable.get_before_type()\n    after = self._unobservable.get_after_type()\n    if before or after:\n      ostr += '  Unobservable '\n      if self._type == 'query': ostr += 'deletion:'+\"\\n\"\n      else: ostr += 'insertion:'+\"\\n\"\n      ostr += '    P(error): '+str(self._unobservable.get_error_probability())+\"\\n\"\n      ostr += '    Elength:  '+str(self._unobservable.get_attributable_length())+\"\\n\"\n      if before:\n        ostr += '    before: '+\"\\n\"\n        ostr += '      P(error): '+str(self._unobservable.get_before_probability())+\"\\n\"\n        ostr += '      '+str(before)+\"\\n\"\n      if after:\n        ostr += '    after:'+\"\\n\"\n        ostr += '      P(error): '+str(self._unobservable.get_after_probability())+\"\\n\"\n        ostr += '      '+str(after)+\"\\n\"\n    return ostr"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_context_target_errors(self):\n    if self._context_target_errors:  return self._context_target_errors\n    if len(self._query_errors) < 3: return {}\n    nts = ['A','C','G','T']\n    poss = ['A','C','G','T','-']\n    r = {}\n    for i in nts:\n      if i not in r:  r[i] = {}\n      for j in nts:\n        if j not in r[i]: r[i][j] = {}\n        for k in poss:\n          if k not in r[i][j]: \n            r[i][j][k] = {}\n            r[i][j][k]['types'] = {}\n            r[i][j][k]['total'] = 0\n          for l in poss:\n            if l not in r[i][j][k]['types']: r[i][j][k]['types'][l] = 0\n    # now r is initialized\n    for i in range(1,len(self._target_errors)-1):\n\n      tobs = self._target_errors[i].get_observable()\n      tunobs = self._target_errors[i].get_unobservable()\n      otype = tobs.get_type()\n      op = tobs.get_error_probability()\n      before = tunobs.get_before_type()\n      bp = tunobs.get_before_probability()\n      after = tunobs.get_after_type()\n      ap = tunobs.get_after_probability()\n      if otype[2][0][0] == 'N': continue\n      if otype[2][1][0] == 'N': continue\n      if before:\n        if before[2][0][0] == 'N': continue\n        if before[2][1][0] == 'N': continue\n      if after:\n        if after[2][0][0] == 'N': continue\n        if after[2][1][0] == 'N': continue\n\n      tbefore = self._target_errors[i-1].get_base()\n      t = self._target_errors[i].get_base()\n      tafter = self._target_errors[i+1].get_base()\n\n      if tbefore == 'N' or tafter == 'N' or t == 'N': continue\n      r[tbefore][t]['-']['total'] += 0.5\n      r[t][tafter]['-']['total'] += 0.5\n      r[tbefore][tafter][t]['total'] += 1\n\n      # We know we made an observation\n      if otype[0] == 'mismatch':\n        tb = otype[2][0][0]\n        qb = otype[2][1][0]\n        r[tbefore][tafter][t]['types'][qb] += op\n      elif otype[0] == 'match':\n        tb = otype[2][0][0]\n        qb = otype[2][1][0]\n        r[tbefore][tafter][t]['types'][qb] += float(1)\n      elif otype[0] == 'deletion':\n        tb = otype[2][0][0]\n        qb = otype[2][1][0]\n        r[tbefore][tafter][t]['types']['-'] += op\n        r[tbefore][tafter][t]['types'][qb] += (1-op)\n      # make sure our insertion can't be bigger than 1\n      hp_insert_before = 0\n      hp_insert_after = 0\n      if otype[0] == 'insertion':\n        tb = otype[2][0][0]\n        qb = otype[2][1][0]\n        r[tbefore][tb]['-']['types'][qb] += op/2\n        r[tb][tafter]['-']['types'][qb] += op/2\n        #homopolymer ... so we do have the correct base\n        r[tbefore][tafter][t]['types'][qb] += 1\n\n      # now take care of total insertions\n      total_bp = 0\n      total_ap = 0\n      if before:\n        qb = before[2][1][0]\n        r[tbefore][t]['-']['types'][qb] += bp\n      if after:\n        qb = after[2][1][0]\n        r[t][tafter]['-']['types'][qb] += ap\n      #r[tbefore][t]['-']['types'][qb] += total_bp+(1-total_bp)*hp_insert_before\n      #r[t][tafter]['-']['types'][qb] += total_ap+(1-total_ap)*hp_insert_after\n\n      ##type = self._target_errors[i].get_type()\n      #p = self._target_errors[i].get_error_probability()\n      #if p > 0:\n      #  if type[0] not in r[tbefore][t][tafter]['types']:\n      #    r[tbefore][t][tafter]['types'][type[0]] = 0\n      #  r[tbefore][t][tafter]['types'][type[0]] += p\n      #r[tbefore][t][tafter]['total']+=1\n    for b in r:\n      for a in r:\n        val = sum([r[b][a]['-']['types'][q] for q in nts])\n        r[b][a]['-']['types']['-'] = r[b][a]['-']['total'] - val\n    return r", "response": "A more straitfoward calculation of the context - specific errors \n    relative to the target_errors."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_context_query_errors(self):\n    if self._context_query_errors:  return self._context_query_errors\n    if len(self._query_errors) < 3: return {}\n    nts = ['A','C','G','T']\n    poss = ['A','C','G','T','-']\n    r = {}\n    for i in nts:\n      if i not in r:  r[i] = {}\n      for j in nts:\n        if j not in r[i]: r[i][j] = {}\n        for k in poss:\n          if k not in r[i][j]: \n            r[i][j][k] = {}\n            r[i][j][k]['types'] = {}\n            r[i][j][k]['total'] = 0\n          for l in poss:\n            if l not in r[i][j][k]['types']: r[i][j][k]['types'][l] = 0\n    # now r is initialized\n    for i in range(1,len(self._query_errors)-1):\n\n      tobs = self._query_errors[i].get_observable()\n      tunobs = self._query_errors[i].get_unobservable()\n      otype = tobs.get_type()\n      op = tobs.get_error_probability()\n      before = tunobs.get_before_type()\n      bp = tunobs.get_before_probability()\n      after = tunobs.get_after_type()\n      ap = tunobs.get_after_probability()\n      if otype[2][0][0] == 'N': continue\n      if otype[2][1][0] == 'N': continue\n      if before:\n        if before[2][0][0] == 'N': continue\n        if before[2][1][0] == 'N': continue\n      if after:\n        if after[2][0][0] == 'N': continue\n        if after[2][1][0] == 'N': continue\n\n      tbefore = self._query_errors[i-1].get_base()\n      t = self._query_errors[i].get_base()\n      tafter = self._query_errors[i+1].get_base()\n\n      if tbefore == 'N' or tafter == 'N' or t == 'N': continue\n      r[tbefore][t]['-']['total'] += 0.5\n      r[t][tafter]['-']['total'] += 0.5\n      r[tbefore][tafter][t]['total'] += 1\n\n      # We know we made an observation\n      if otype[0] == 'mismatch':\n        tb = otype[2][0][0]\n        qb = otype[2][1][0]\n        r[tbefore][tafter][t]['types'][tb] += op\n      elif otype[0] == 'match':\n        tb = otype[2][0][0]\n        qb = otype[2][1][0]\n        r[tbefore][tafter][t]['types'][tb] += float(1)\n      elif otype[0] == 'insertion':\n        tb = otype[2][0][0]\n        qb = otype[2][1][0]\n        r[tbefore][tafter][t]['types']['-'] += op\n        r[tbefore][tafter][t]['types'][tb] += (1-op)\n      # make sure our deletion can't be bigger than 1\n      hp_deletion_before = 0\n      hp_deletion_after = 0\n      if otype[0] == 'deletion':\n        tb = otype[2][0][0]\n        qb = otype[2][1][0]\n        r[tbefore][tb]['-']['types'][tb] += op/2\n        r[tb][tafter]['-']['types'][tb] += op/2\n        #homopolymer ... so we do have the correct base\n        r[tbefore][tafter][t]['types'][tb] += 1\n\n      # now take care of total deletions\n      if before:\n        tb = before[2][0][0]\n        r[tbefore][t]['-']['types'][tb] += bp\n      if after:\n        tb = after[2][0][0]\n        r[t][tafter]['-']['types'][tb] += ap\n\n      ##type = self._target_errors[i].get_type()\n      #p = self._target_errors[i].get_error_probability()\n      #if p > 0:\n      #  if type[0] not in r[tbefore][t][tafter]['types']:\n      #    r[tbefore][t][tafter]['types'][type[0]] = 0\n      #  r[tbefore][t][tafter]['types'][type[0]] += p\n      #r[tbefore][t][tafter]['total']+=1\n    for b in r:\n      for a in r:\n        val = sum([r[b][a]['-']['types'][q] for q in nts])\n        r[b][a]['-']['types']['-'] = r[b][a]['-']['total'] - val\n    return r", "response": "A more straitfoward calculation of the context - specific errors \n    relative to the query\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_query_errors(self):\n    if self._query_errors: return self._query_errors\n    v = []\n    for i in range(len(self._query_hpas)):\n      v.append(self.get_query_error(i))\n    return v", "response": "Returns a list of base - wise error observations for the query \n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_target_errors(self):\n    if self._target_errors: return self._target_errors\n    v = []\n    for i in range(len(self._target_hpas)):\n      v.append(self.get_target_error(i))\n    return v", "response": "Just get a single error characterization based on the index relative to the target HPA"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngoes through HPAGroups and store the distro of ordinal values of quality scores", "response": "def analyze_quality(self):\n    \"\"\"Go through HPAGroups and store the distro of ordinal values of \n       quality scores\"\"\"\n    res = {}\n    for h in self._hpas:\n      if h.type() not in res: res[h.type()]={}\n      for c in h.get_quality():\n        if c not in res[h.type()]: res[h.type()][c] = 0\n        res[h.type()][c]+=1\n    self._quality_distro = res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_quality_report_string(self):\n    if not self._quality_distro:\n      self.analyze_quality()\n    ostr = \"\"\n    for type in sorted(self._quality_distro.keys()):\n      total = sum([ord(x)*self._quality_distro[type][x] for x in self._quality_distro[type]])\n      cnt = sum([self._quality_distro[type][x] for x in self._quality_distro[type]])\n      if cnt == 0: continue\n      print 'type: '+type+' '+str(cnt)+' '+str(float(total)/float(cnt))\n    return ostr", "response": "get a report on quality score distribution currently prints to stdout"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrequire alignment strings have been set so for each exon we have query, target and query_quality _has_quality will specify whether or not the quality is meaningful", "response": "def _misalign_split(self,alns):\n    \"\"\"Requires alignment strings have been set so for each exon we have\n       query, target and query_quality\n       _has_quality will specify whether or not the quality is meaningful\n    \"\"\"\n    total = []\n    z = 0\n    for x in alns:\n      z += 1\n      exon_num = z\n      if self._alignment.strand == '-':\n        exon_num = (len(alns)-z)+1\n      buffer = {'query':x['query'][0],'target':x['target'][0],'query_quality':x['query_quality'][0],'exon':exon_num}\n      if buffer['query'] == '-': buffer['nt'] = buffer['target']\n      elif buffer['target'] == '-': buffer['nt'] = buffer['query']\n      elif buffer['query'] == buffer['target']: buffer['nt'] = buffer['query']\n      elif buffer['query'] != buffer['target']: buffer['nt'] = '*'\n      else:\n\tsys.stderr.write(\"WARNING unkonwn case\\n\")\n      for i in range(1,len(x['query'])):\n        qchar = x['query'][i]\n        tchar = x['target'][i]\n        qualchar = x['query_quality'][i]\n        if qchar != tchar and (qchar != '-' and tchar != '-'):\n          #classic mismatch\n          #print 'mismatch'\n          #print buffer\n          total.append(buffer)\n          buffer = {'query':qchar,'target':tchar,'query_quality':qualchar,'exon':exon_num}\n          buffer['nt'] = '*'\n        elif qchar == buffer['nt'] or tchar == buffer['nt']:\n          # its a homopolymer match\n          buffer['query'] += qchar\n\n          buffer['target'] += tchar\n          buffer['query_quality'] += qualchar\n          #print 'homopoly'\n        else:\n          #print 'new thing'\n          #print buffer\n          total.append(buffer)\n          buffer = {'query':qchar,'target':tchar,'query_quality':qualchar,'exon':exon_num}\n          if qchar == '-': buffer['nt'] = tchar\n          else:  buffer['nt'] = qchar\n      total.append(buffer)\n    result = [AlignmentErrors.HPAGroup(self,y) for y in total]\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking a string representation of the general error report", "response": "def get_string(self):\n    \"\"\"make a string representation of the general error report\"\"\"\n    ostr = ''\n    errtotal = self.deletions['total']+self.insertions['total']+self.mismatches\n    ostr += 'from '+str(self.alignment_length)+' bp of alignment'+\"\\n\"\n    ostr += '  '+str(float(errtotal)/float(self.alignment_length))+\" error rate\\n\"\n    ostr += '    '+str(float(self.mismatches)/float(self.alignment_length))+ \" mismatches\\n\"\n    ostr += '    '+str(float(self.deletions['total'])/float(self.alignment_length))+ \" deletions\\n\"\n    ostr += '      '+str(float(self.deletions['specific'])/float(self.alignment_length))+ \" total deletions\\n\"\n    ostr += '      '+str(float(self.deletions['homopolymer'])/float(self.alignment_length))+ \" homopolymer deletions\\n\"\n    ostr += '    '+str(float(self.insertions['total'])/float(self.alignment_length))+ \" insertions\\n\"\n    ostr += '      '+str(float(self.insertions['specific'])/float(self.alignment_length))+ \" total insertions\\n\"\n    ostr += '      '+str(float(self.insertions['homopolymer'])/float(self.alignment_length))+ \" homopolymer insertions\\n\"\n    ostr += '  More specific errors'+\"\\n\"\n    poss = ['-','A','C','G','T']\n    ostr += '  -    A    C    G    T'+\"\\n\"\n    t = 0\n    for p1 in poss:\n      ostr += p1\n      for p2 in poss:\n        val = float(self.matrix[p1][p2])/float(self.alignment_length)\n        ostr += \" \"+str(round(val,3))\n        t += val\n      ostr += \"\\n\"\n    ostr += \"\\n\"\n    return ostr"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_stats(self):\n    ostr = ''\n    errtotal = self.deletions['total']+self.insertions['total']+self.mismatches\n    ostr += \"ALIGNMENT_COUNT\\t\"+str(self.alignment_count)+\"\\n\"\n    ostr += \"ALIGNMENT_BASES\\t\"+str(self.alignment_length)+\"\\n\"\n    ostr += \"ANY_ERROR\\t\"+str(errtotal)+\"\\n\"\n    ostr += \"MISMATCHES\\t\"+str(self.mismatches)+\"\\n\"\n    ostr += \"ANY_DELETION\\t\"+str(self.deletions['total'])+\"\\n\"\n    ostr += \"COMPLETE_DELETION\\t\"+str(self.deletions['specific'])+\"\\n\"\n    ostr += \"HOMOPOLYMER_DELETION\\t\"+str(self.deletions['homopolymer'])+\"\\n\"\n    ostr += \"ANY_INSERTION\\t\"+str(self.insertions['total'])+\"\\n\"\n    ostr += \"COMPLETE_INSERTION\\t\"+str(self.insertions['specific'])+\"\\n\"\n    ostr += \"HOMOPOLYMER_INSERTION\\t\"+str(self.insertions['homopolymer'])+\"\\n\"\n    return ostr", "response": "Return a string describing the stats"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_report(self):\n    ostr = ''\n    ostr += \"target\\tquery\\tcnt\\ttotal\\n\"\n    poss = ['-','A','C','G','T']\n    for target in poss:\n      for query in poss:\n        ostr += target+ \"\\t\"+query+\"\\t\"+str(self.matrix[target][query])+\"\\t\"+str(self.alignment_length)+\"\\n\"\n    return ostr", "response": "Another report but not context based"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds alignment errors to the group", "response": "def add_alignment_errors(self,ae):\n    \"\"\"Add alignment errors to the group\n\n    :param ae: one set of alignment errors\n    :param type:\n    \"\"\"\n    self.alignment_count += 1\n    for v in ae.get_HPAGroups():\n      self._add_HPAGroup(v)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _set_catalog_view(self, session):\n        if self._catalog_view == COMPARATIVE:\n            try:\n                session.use_comparative_catalog_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_catalog_view()\n            except AttributeError:\n                pass", "response": "Sets the underlying catalog view to match current view"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider CatalogLookupSession. use_comparative_catalog_view", "response": "def use_comparative_catalog_view(self):\n        \"\"\"Pass through to provider CatalogLookupSession.use_comparative_catalog_view\"\"\"\n        self._catalog_view = COMPARATIVE\n        # self._get_provider_session('catalog_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_catalog_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider CatalogLookupSession. use_plenary_catalog_view", "response": "def use_plenary_catalog_view(self):\n        \"\"\"Pass through to provider CatalogLookupSession.use_plenary_catalog_view\"\"\"\n        self._catalog_view = PLENARY\n        # self._get_provider_session('catalog_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_catalog_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider CatalogLookupSession. get_catalogs_by_ids", "response": "def get_catalogs_by_ids(self, *args, **kwargs):\n        \"\"\"Pass through to provider CatalogLookupSession.get_catalogs_by_ids\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_by_ids\n        catalogs = self._get_provider_session('catalog_lookup_session').get_catalogs_by_ids(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Catalog(self._provider_manager, cat, self._runtime, self._proxy))\n        return CatalogList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing through to provider CatalogLookupSession. get_catalogs", "response": "def get_catalogs(self):\n        \"\"\"Pass through to provider CatalogLookupSession.get_catalogs\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('catalog_lookup_session').get_catalogs()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Catalog(self._provider_manager, cat, self._runtime, self._proxy))\n        return CatalogList(cat_list)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_catalog(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.create_bin\n        return Catalog(\n            self._provider_manager,\n            self._get_provider_session('catalog_admin_session').create_catalog(*args, **kwargs),\n            self._runtime,\n            self._proxy)", "response": "Pass through to provider CatalogAdminSession. create_catalog"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass through to provider CatalogAdminSession. get_catalog_form_for_update", "response": "def get_catalog_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider CatalogAdminSession.get_catalog_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'catalog_record_types' in kwargs:\n            return self.get_catalog_form_for_create(*args, **kwargs)\n        else:\n            return self.get_catalog_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass through to provider CatalogAdminSession. update_catalog", "response": "def save_catalog(self, catalog_form, *args, **kwargs):\n        \"\"\"Pass through to provider CatalogAdminSession.update_catalog\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if catalog_form.is_for_update():\n            return self.update_catalog(catalog_form, *args, **kwargs)\n        else:\n            return self.create_catalog(catalog_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the underlying catalog view to match current view", "response": "def _set_catalog_view(self, session):\n        \"\"\"Sets the underlying catalog view to match current view\"\"\"\n        if self._catalog_view == FEDERATED:\n            try:\n                session.use_federated_catalog_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_catalog_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_n_and_k_counters(max_order, species, central_symbols_prefix=\"M_\", raw_symbols_prefix=\"x_\"):\n        n_moments = max_order + 1\n        # first order moments are always 1\n        k_counter = [Moment([0] * len(species), sp.Integer(1))]\n        n_counter = [Moment([0] * len(species), sp.Integer(1))]\n\n        # build descriptors for first order raw moments aka expectations (e.g. [1, 0, 0], [0, 1, 0] and [0, 0, 1])\n        descriptors = []\n        for i in range(len(species)):\n            row = [0]*len(species)\n            row[i] = 1\n            descriptors.append(row)\n\n        # We use species name as symbols for first order raw moment\n        k_counter += [Moment(d, s) for d,s in zip(descriptors, species)]\n\n        # Higher order raw moment descriptors\n        k_counter_descriptors = [i for i in itertools.product(range(n_moments + 1), repeat=len(species))\n                                 if 1 < sum(i) <= n_moments]\n\n        #this mimics the order in the original code\n        k_counter_descriptors = sorted(k_counter_descriptors,lambda x,y: sum(x) - sum(y))\n        #k_counter_descriptors = [[r for r in reversed(k)] for k in k_counter_descriptors]\n\n        k_counter_symbols = [sp.Symbol(raw_symbols_prefix + \"_\".join([str(s) for s in count]))\n                             for count in k_counter_descriptors]\n        k_counter += [Moment(d, s) for d,s in zip(k_counter_descriptors, k_counter_symbols)]\n\n        #  central moments\n        n_counter_descriptors = [m for m in k_counter_descriptors if sum(m) > 1]\n        # arbitrary symbols\n        n_counter_symbols = [sp.Symbol(central_symbols_prefix + \"_\".join([str(s) for s in count]))\n                             for count in n_counter_descriptors]\n\n        n_counter += [Moment(c, s) for c,s in zip(n_counter_descriptors, n_counter_symbols)]\n\n        return n_counter, k_counter", "response": "r Generate n and k counters for the central moments and raw moments."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds the config file for the given dataset.", "response": "def build_config(dataset, datasets_dir, phase, problem=None, output_dir='data/output'):\n    \"\"\"\n    root@d3m-example-pod:/# cat /input/185_baseball/test_config.json\n    {\n      \"problem_schema\": \"/input/TEST/problem_TEST/problemDoc.json\",\n      \"problem_root\": \"/input/TEST/problem_TEST\",\n      \"dataset_schema\": \"/input/TEST/dataset_TEST/datasetDoc.json\",\n      \"test_data_root\": \"/input/TEST/dataset_TEST\",\n      \"results_root\": \"/output/predictions\",\n      \"executables_root\": \"/output/executables\",\n      \"temp_storage_root\": \"/output/supporting_files\"\n    }\n    root@d3m-example-pod:/# cat /input/185_baseball/search_config.json\n    {\n      \"problem_schema\": \"/input/TRAIN/problem_TRAIN/problemDoc.json\",\n      \"problem_root\": \"/input/TRAIN/problem_TRAIN\",\n      \"dataset_schema\": \"/input/TRAIN/dataset_TRAIN/datasetDoc.json\",\n      \"training_data_root\": \"/input/TRAIN/dataset_TRAIN\",\n      \"pipeline_logs_root\": \"/output/pipelines\",\n      \"executables_root\": \"/output/executables\",\n      \"user_problems_root\": \"/output/user_problems\",\n      \"temp_storage_root\": \"/output/supporting_files\"\n    }\n\n    \"\"\"\n\n    if problem:\n        full_phase = phase + '_' + problem\n    else:\n        full_phase = phase\n\n    root_dir = os.path.join(datasets_dir, dataset, full_phase)\n    problem_root = os.path.join(root_dir, 'problem_' + phase)\n    data_root = os.path.join(root_dir, 'dataset_' + phase)\n\n    config = {\n        'problem_root': problem_root,\n        'problem_schema': os.path.join(problem_root, 'problemDoc.json'),\n        'dataset_schema': os.path.join(data_root, 'datasetDoc.json'),\n        'executables_root': os.path.join(output_dir, 'executables'),\n        'temp_storage_root': os.path.join(output_dir, 'supporting_files'),\n    }\n\n    if phase == 'TRAIN':\n        config['training_data_root'] = data_root\n        config['pipeline_logs_root'] = os.path.join(output_dir, 'pipelines')\n    else:\n        config['test_data_root'] = data_root\n        config['results_root'] = os.path.join(output_dir, 'predictions')\n\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\n\n        S = self.model.stoichiometry_matrix\n        amat = self.model.propensities\n        ymat = self.model.species\n        n_species = len(ymat)\n\n        # dPdt is matrix of each species differentiated w.r.t. time\n        # The code below literally multiplies the stoichiometry matrix to a column vector of propensities\n        # from the right (::math::`\\frac{dP}{dt} = \\mathbf{Sa}`)\n        dPdt =  S * amat\n\n\n        # A Is a matrix of each species (rows) and the derivatives of their stoichiometry matrix rows\n        # against each other species\n        # Code below computes the matrix A, that is of size `len(ymat) x len(ymat)`, for which each entry\n        # ::math::`A_{ik} = \\sum_j S_{ij} \\frac{\\partial a_j}{\\partial y_k} = \\mathfb{S_i} \\frac{\\partial \\mathbf{a}}{\\partial y_k}`\n        A = sp.Matrix(len(ymat), len(ymat), lambda i, j: 0)\n        for i in range(A.rows):\n            for k in range(A.cols):\n                A[i, k] = reduce(operator.add, [S[i, j] * sp.diff(amat[j], ymat[k]) for j in range(len(amat))])\n\n\n        # `diagA` is a matrix that has values sqrt(a[i]) on the diagonal (0 elsewhere)\n        diagA = sp.Matrix(len(amat), len(amat), lambda i, j: amat[i] ** sp.Rational(1,2) if i==j else 0)\n        # E is stoichiometry matrix times diagA\n        E = S * diagA\n\n        variance_terms = []\n        cov_matrix = []\n        for i in range(len(ymat)):\n            row = []\n            for j in range(len(ymat)):\n                if i <= j:\n                    symbol = 'V_{0}_{1}'.format(i, j)\n                    variance_terms.append(VarianceTerm(position=(i,j), symbol=symbol))\n                else:\n                    # Since Vi,j = Vj,i, i.e. covariance are equal, we only record Vi,j but not Vj,i\n                    symbol = 'V_{0}_{1}'.format(j, i)\n                    variance_terms.append(VarianceTerm(position=(j,i), symbol=symbol))\n                row.append(symbol)\n            cov_matrix.append(row)\n\n        V = sp.Matrix(cov_matrix)\n\n\n        # Matrix of variances (diagonal) and covariances of species i and j differentiated wrt time.\n        # I.e. if i=j, V_ij is the variance, and if i!=j, V_ij is the covariance between species i and species j\n        dVdt = A * V + V * (A.T) + E * (E.T)\n\n\n        # build ODEProblem object\n        rhs_redundant = sp.Matrix([i for i in dPdt] + [i for i in dVdt])\n\n\n        #generate ODE terms\n        n_vectors = [tuple([1 if i==j else 0 for i in range(n_species)]) for j in range(n_species)]\n        moment_terms = [Moment(nvec,lhs) for (lhs, nvec) in zip(ymat, n_vectors)]\n\n        ode_description = moment_terms + variance_terms\n\n\n        non_redundant_idx = []\n        ode_terms = []\n        # remove repetitive covariances, as Vij = Vji\n        for i, cov in enumerate(ode_description):\n            if cov in ode_terms:\n                continue\n            else:\n                ode_terms.append(cov)\n                non_redundant_idx.append(i)\n        rhs = []\n        for i in non_redundant_idx:\n            rhs.append(rhs_redundant[i])\n\n\n        out_problem = ODEProblem(\"LNA\", ode_terms, rhs, sp.Matrix(self.model.parameters))\n\n\n        return out_problem", "response": "Private method that computes the complete set of Ordinary Differential Equations for the current entry set."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the path of learningData. csv in a dataset", "response": "def _get_learning_data_path(self):\n        \"\"\"\n        Returns the path of learningData.csv in a dataset\n        \"\"\"\n        for res in self.dsDoc['dataResources']:\n            resPath = res['resPath']\n            resType = res['resType']\n\n            dirname = os.path.basename(os.path.normpath(os.path.dirname(resPath)))\n\n            if resType == 'table' and dirname == 'tables':\n                if 'learningData.csv' in res['resPath']:\n                    return os.path.join(self.dsHome, resPath)\n\n        # if the for loop is over and learningDoc is not found, then return None\n        raise RuntimeError('could not find learningData file the dataset')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_learning_data_resource(self):\n        for res in self.dsDoc['dataResources']:\n            resPath = res['resPath']\n            resType = res['resType']\n            if resType == 'table':\n                if 'learningData.csv' in resPath:\n                    return res\n                else:\n                    raise RuntimeError('could not find learningData.csv')\n\n        # if the for loop is over and learningDoc is not found, then return None\n        raise RuntimeError('could not find learningData resource')", "response": "Returns the path of learningData. csv in a dataset"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetect the data modality based on the resource types.", "response": "def get_data_modality(self):\n        \"\"\"Detect the data modality based on the resource_types.\n\n        resource_types == ['table'] => 'single_table'\n        resource_types == ['something_else'...] => 'something_else'   # this is not likely\n        resource_types == ['table', 'table'...] => 'multi_table'\n        resource_types == ['table', 'something_else'...] => 'something_else'\n        \"\"\"\n        resource_types = self.get_resource_types()\n        first_type = resource_types[0]\n        if first_type != 'table':\n            return first_type\n\n        elif len(resource_types) == 1:\n            return 'single_table'\n\n        else:\n            second_type = resource_types[1]\n            if second_type == 'table':\n                return 'multi_table'\n\n            return second_type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the list of resources that are of the specified type", "response": "def _get_resources_by_type(self, resource_type):\n        \"\"\"\n        Returns the list of resources that are of the indicated type\n        \"\"\"\n        resources = []\n        for res in self.dsDoc['dataResources']:\n            if res['resType'] == resource_type:\n                resources.append(res)\n\n        return resources"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the path of the directory containing text if they exist in this dataset.", "response": "def get_text_path(self):\n        \"\"\"\n        Returns the path of the directory containing text if they exist in this dataset.\n        \"\"\"\n        for res in self.dsDoc['dataResources']:\n            resPath = res['resPath']\n            resType = res['resType']\n            isCollection = res['isCollection']\n            if resType == 'text' and isCollection:\n                return os.path.join(self.dsHome, resPath)\n\n        # if the for loop is over and no image directory is found, then return None\n        raise RuntimeError('could not find learningData file the dataset')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_scope_with_mangled(self, name):\n        scope = self\n        while True:\n            parent = scope.get_enclosing_scope()\n            if parent is None:\n                return\n\n            if name in parent.rev_mangled:\n                return parent\n\n            scope = parent", "response": "Return a scope containing passed mangled name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_scope_with_symbol(self, name):\n        scope = self\n        while True:\n            parent = scope.get_enclosing_scope()\n            if parent is None:\n                return\n\n            if name in parent.symbols:\n                return parent\n\n            scope = parent", "response": "Return a scope containing passed name as a symbol name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget next mangled name from the next scope.", "response": "def get_next_mangled_name(self):\n        \"\"\"\n        1. Do not shadow a mangled name from a parent scope\n           if we reference the original name from that scope\n           in this scope or any sub-scope.\n\n        2. Do not shadow an original name from a parent scope\n           if it's not mangled and we reference it in this scope\n           or any sub-scope.\n\n        \"\"\"\n        while True:\n            mangled = next(self.base54)\n\n            # case 1\n            ancestor = self._get_scope_with_mangled(mangled)\n            if (ancestor is not None\n                and self.refs.get(ancestor.rev_mangled[mangled]) is ancestor\n                ):\n                continue\n\n            # case 2\n            ancestor = self._get_scope_with_symbol(mangled)\n            if (ancestor is not None\n                and self.refs.get(mangled) is ancestor\n                and mangled not in ancestor.mangled\n                ):\n                continue\n\n            # make sure a new mangled name is not a reserved word\n            if mangled.upper() in Lexer.keywords:\n                continue\n\n            return mangled"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generator(\n        worker_id,\n        sleep=lambda x: time.sleep(x/1000.0),\n        now=lambda: int(time.time()*1000)):\n    \"\"\"\n    worker_id: a unique for your *entire* environment number between 0 and 255\n               to identify this generator.\n\n    sleep(n):  function to pause this worker for n milliseconds. you usually\n               want to supply a custom method for this in asynchronous\n               processes.\n\n    now():     function to return a current unix timestamp in milliseconds.\n               useful for testing.\n\n    returns an iterator which yields a series of increasing integers,\n    guaranteed to be unique for this worker_id.\n    \"\"\"\n    assert worker_id >= 0 and worker_id <= max_worker_id\n\n    last_timestamp = -1\n    sequence = 0\n\n    while True:\n        timestamp = now()\n\n        if last_timestamp > timestamp:\n            log.warning(\n                \"clock is moving backwards. waiting until %i\" % last_timestamp)\n            sleep(last_timestamp-timestamp)\n            continue\n\n        if last_timestamp == timestamp:\n            sequence = (sequence + 1) & sequence_mask\n            if sequence == 0:\n                log.warning(\"sequence overrun\")\n                sequence = -1 & sequence_mask\n                sleep(1)\n                continue\n        else:\n            sequence = 0\n\n        last_timestamp = timestamp\n\n        yield (\n            ((timestamp-fitepoch) << timestamp_left_shift) |\n            (worker_id << worker_id_shift) |\n            sequence)", "response": "A generator function that returns a sequence of integers."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the map of the record.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        QuestionTextFormRecord._init_map(self)\n        self.my_osid_object_form._my_map['choices'] = \\\n            self._choices_metadata['default_object_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the metadata for the question text form record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        QuestionTextFormRecord._init_metadata(self)\n        self._choices_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choices'),\n            'element_label': 'Choices',\n            'instructions': 'Enter as many choices as you wish',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._choice_text_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choice_text'),\n            'element_label': 'choice text',\n            'instructions': 'enter the text for this choice',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 1024,\n            'string_set': []\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new choice to the list", "response": "def add_choice(self, text, inline_region, name='', identifier=None):\n        \"\"\"stub\"\"\"\n        choice_display_text = self._choice_text_metadata['default_string_values'][0]\n        choice_display_text['text'] = text\n        if identifier is None:\n            identifier = str(ObjectId())\n        choice = {\n            'id': identifier,\n            'text': text,\n            'name': name\n        }\n        if inline_region in self.my_osid_object_form._my_map['choices']:\n            self.my_osid_object_form._my_map['choices'][inline_region].append(choice)\n        else:\n            raise IllegalState('that inline region does not exist')\n        return choice"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef edit_choice(self, choice_id, text, inline_region, name=''):\n        if inline_region not in self.my_osid_object_form._my_map['choices']:\n            raise IllegalState('that inline region does not exist')\n        for choice in self.my_osid_object_form._my_map['choices'][inline_region]:\n            if choice['id'] == choice_id:\n                if choice['text'] != text:\n                    choice['text'] = text\n                if choice['name'] != name and name != '':\n                    choice['name'] = name\n                break", "response": "edit an existing choice"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_choice(self, choice_id, inline_region):\n        if inline_region in self.my_osid_object_form._my_map['choices']:\n            updated_choices = []\n            for choice in self.my_osid_object_form._my_map['choices'][inline_region]:\n                if choice['id'] != choice_id:\n                    updated_choices.append(choice)\n            self.my_osid_object_form._my_map['choices'][inline_region] = updated_choices", "response": "remove a choice given the id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_choice_order(self, choice_ids, inline_region):\n        reordered_choices = []\n        current_choice_ids = [c['id'] for c in self.my_osid_object_form._my_map['choices'][inline_region]]\n        if set(choice_ids) != set(current_choice_ids):\n            raise IllegalState('missing choices for choice order')\n\n        for choice_id in choice_ids:\n            for current_choice in self.my_osid_object_form._my_map['choices'][inline_region]:\n                if choice_id == current_choice['id']:\n                    reordered_choices.append(current_choice)\n                    break\n\n        self.my_osid_object_form._my_map['choices'][inline_region] = reordered_choices", "response": "reorder choices per the passed in list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_values(self, choice_ids):\n        # if not self.my_osid_object._my_map['choices']:\n        #     raise IllegalState()\n        organized_regions = {}\n        for region, choice_ids in choice_ids.items():\n            organized_choice_ids = []\n            for choice in choice_ids:\n                original_region_choices = self._original_choice_order[region]\n                choice_obj = [c for c in original_region_choices if c['id'] == choice['id']][0]\n                organized_choice_ids.append(choice_obj)\n            organized_regions[region] = organized_choice_ids\n        self.my_osid_object._my_map['choices'] = organized_regions", "response": "set the values of the choice_ids to the values in the choice_ids dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the map of resources to answer form record", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        FilesAnswerFormRecord._init_map(self)\n        FeedbackAnswerFormRecord._init_map(self)\n        self.my_osid_object_form._my_map['inlineRegions'] = \\\n            self._inline_regions_metadata['default_object_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_choice_id(self, choice_id, inline_region):\n        if inline_region in self.my_osid_object_form._my_map['inlineRegions']:\n            self.my_osid_object_form._my_map['inlineRegions'][inline_region]['choiceIds'].append(choice_id)\n        else:\n            raise IllegalState('that inline region is invalid')", "response": "add a choice id to the list of available items"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclearing the choice ids for the given inline region", "response": "def clear_choice_ids(self, inline_region):\n        \"\"\"stub\"\"\"\n        if (self.get_choice_ids_metadata().is_read_only() or\n                self.get_choice_ids_metadata().is_required()):\n            raise NoAccess()\n        if inline_region in self.my_osid_object_form._my_map['inlineRegions']:\n            self.my_osid_object_form._my_map['inlineRegions'][inline_region]['choiceIds'] = \\\n                deepcopy(self._choice_ids_metadata['default_object_values'][0])\n        else:\n            raise IllegalState('that inline region is invalid')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the list of choice ids for this inline", "response": "def get_inline_choice_ids(self):\n        \"\"\"stub\"\"\"\n        return_data = {}\n        for inline_region, data in self.my_osid_object._my_map['inlineRegions'].items():\n            return_data[inline_region] = {\n                'choiceIds': IdList(data['choiceIds'])\n            }\n        return return_data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_map(self):\n        super(MultiLanguageInlineChoiceQuestionFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['choices'] = \\\n            self._choices_metadata['default_object_values'][0]", "response": "Initialize the map for the MultiLanguageInlineChoiceQuestionFormRecord."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_choice_language(self, language_type, choice_id, inline_region):\n        if len(self.my_osid_object_form._my_map['choices'][inline_region]) == 0:\n            raise IllegalState('there are currently no choices defined for this region')\n        if self.get_choices_metadata().is_read_only():\n            raise NoAccess()\n\n        choices = [c for c in self.my_osid_object_form._my_map['choices'][inline_region] if c['id'] == choice_id]\n        if len(choices) == 0:\n            raise InvalidArgument('invalid choice_id')\n\n        for current_choice in self.my_osid_object_form._my_map['choices'][inline_region]:\n            if choice_id == current_choice['id']:\n                self.remove_field_by_language('texts',\n                                              language_type,\n                                              current_choice)", "response": "remove a choice from the given language"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a choice to the list of items in the given inline region", "response": "def add_choice(self, choice, inline_region, identifier=None, name=''):\n        \"\"\"stub\"\"\"\n        if inline_region not in self.my_osid_object_form._my_map['choices']:\n            raise IllegalState('that inline region does not exist. Please call add_inline_region first')\n\n        if identifier is None:\n            identifier = str(ObjectId())\n        current_identifiers = [c['id'] for c in self.my_osid_object_form._my_map['choices'][inline_region]]\n        if identifier not in current_identifiers:\n            choice = {\n                'id': identifier,\n                'texts': [self._dict_display_text(choice)],\n                'name': name\n            }\n            self.my_osid_object_form._my_map['choices'][inline_region].append(choice)\n        else:\n            for current_choice in self.my_osid_object_form._my_map['choices'][inline_region]:\n                if current_choice['id'] == identifier:\n                    self.add_or_replace_value('texts', choice, dictionary=current_choice)\n                    choice = current_choice\n        return choice"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef edit_choice(self, new_choice, choice_id, inline_region):\n        if inline_region not in self.my_osid_object_form._my_map['choices']:\n            raise IllegalState('that inline region does not exist')\n        if not isinstance(new_choice, DisplayText):\n            raise InvalidArgument('new choice is not a DisplayText object')\n        choices = [c for c in self.my_osid_object_form._my_map['choices'][inline_region] if c['id'] == choice_id]\n        if len(choices) == 0:\n            raise InvalidArgument('invalid choice_id for that region')\n\n        for current_choice in self.my_osid_object_form._my_map['choices'][inline_region]:\n            if choice_id == current_choice['id']:\n                index = self.get_index_of_language_type('texts',\n                                                        new_choice.language_type,\n                                                        dictionary=current_choice)\n\n                current_choice['texts'][index] = self._dict_display_text(new_choice)", "response": "edit an existing choice"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_choices(self):\n        # ideally would return a displayText object in text ... except for legacy\n        # use cases like OEA, it expects a text string.\n        choices = {}\n        # for region_name, region_choices in self.my_osid_object.object_map['choices'].items():\n        for region_name, region_choices in self.my_osid_object._my_map['choices'].items():\n            updated_region_choices = []\n            for current_choice in region_choices:\n                filtered_choice = {\n                    'id': current_choice['id'],\n                    'text': self.get_matching_language_value('texts',\n                                                             dictionary=current_choice).text,\n                    'name': current_choice['name']\n                }\n                updated_region_choices.append(filtered_choice)\n            choices[region_name] = updated_region_choices\n        return choices", "response": "get the choices for this object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _init_metadata(self):\n        self._inline_regions_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'inline_regions'),\n            'element_label': 'set of inline regions',\n            'instructions': 'submit correct choice for answer for each region',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n        }\n        self._choice_ids_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choice_ids'),\n            'element_label': 'response set with inline regions',\n            'instructions': 'submit correct choice for answer for each region',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_object_values': [[]],\n            'syntax': 'OBJECT',\n        }\n        self._choice_id_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'choice_id'),\n            'element_label': 'response set',\n            'instructions': 'submit correct choice for answer',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }", "response": "Initializes the metadata for the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses multiple comma - separated elements each of which is parsed using function f.", "response": "def parse_multiple(s, f, values=None):\n    \"\"\"Parse multiple comma-separated elements, each of which is parsed\n       using function f.\"\"\"\n    if values is None: values = []\n    values.append(f(s))\n    if s.pos < len(s) and s.cur == ',':\n        s.pos += 1\n        return parse_multiple(s, f, values)\n    else:\n        return values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a string into a set of tuples of store names and store IDs.", "response": "def string_to_configs(s):\n    \"\"\"s is a string in one of the following formats:\n       - x,y\n       - (x,y)\n       - {x,y}\n       - {(w,x),(y,z)}\n       In any case, returns a set of tuples of stores.\n    \"\"\"\n\n    s = lexer(s)\n    value = None\n    if s.pos == len(s):\n        value = set()\n    elif s.cur == '{':\n        value = parse_set(s)\n    elif s.cur == '(':\n        value = {parse_tuple(s)}\n    else:\n        value = {tuple(parse_multiple(s, parse_store))}\n    parse_end(s)\n\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef string_to_transition(s):\n    from .machines import Transition\n    s = lexer(s)\n    lhs = parse_multiple(s, parse_store)\n    if s.pos < len(s) and s.cur == \"->\":\n        s.pos += 1\n        rhs = parse_multiple(s, parse_store)\n    else:\n        rhs = ()\n    parse_end(s)\n    return Transition(lhs, rhs)", "response": "parse a string of the form a b c d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hypercube(number_of_samples, variables):\n    number_of_dimensions = len(variables)\n\n    # Split range 0-1 into `nSeg` segments of equal size\n    segment_ranges = []\n    for i in range(number_of_samples):\n        ratio = 1.0 / number_of_samples\n        segment_ranges.append((ratio * i, ratio * (i + 1)))\n\n    x = []\n    for i in range(number_of_dimensions):\n        values = []\n        for j, segment in enumerate(segment_ranges):\n            # Set values[j] to a random value within the appropriate segment\n            random_element = random.random()\n            value = (random_element * (segment[1] - segment[0])) + (segment[0])\n            values.append(value)\n\n        # TODO: replace the below line with random.shuffle(values) (no need values= in front)\n        # this breaks regression tests as the values are shuffled in different order\n        values = random.sample(values, len(values))\n        x.append(values)\n\n    # at this point x is a list of lists containing a randomly-ordered list of random values\n    # in each of the `possvalues` segments\n\n    samples = []\n    for i in range(len(segment_ranges)):\n        sample = [y[i] for y in x]\n        samples.append(sample)\n    # It looks like `samples` is just transposed version of `x`, i.e. `samples[i][j] = x[j][i]`\n\n    for sample in samples:\n        for i, variable in enumerate(variables):\n            # if no range given for parameter/variable\n            if variable[1] == variable[0]:\n                # just return the whatever constant was given\n                sample[i] = variable[1]\n            else:\n                # return the value indicated by random number in sample[i] that is within that range\n                sample[i] = (sample[i] * (variable[1] - variable[0])) + variable[0]\n\n    return samples", "response": "This function implements Latin Hypercube Sampling."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noutputs the latex document to a file handle.", "response": "def output_latex(self, filename_or_file_handle):\n        \"\"\"\n        Output the file to a latex document\n        :param filename_or_file_handle: filename or already opened file handle to output to\n        :return:\n        \"\"\"\n\n        if isinstance(filename_or_file_handle, basestring):\n            file_handle = file(filename_or_file_handle, 'w')\n            we_opened = True\n        else:\n            file_handle = filename_or_file_handle\n            we_opened = False\n\n        try:\n            file_handle.write(self.latex)\n        finally:\n            if we_opened:\n                file_handle.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the map of the record.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        self.my_osid_object_form._my_map['maxStrings'] = \\\n            self._max_strings_metadata['default_integer_values'][0]\n        self.my_osid_object_form._my_map['expectedLength'] = \\\n            self._expected_length_metadata['default_integer_values'][0]\n        self.my_osid_object_form._my_map['expectedLines'] = \\\n            self._expected_lines_metadata['default_integer_values'][0]\n        super(QTIExtendedTextAnswerQuestionFormRecord, self)._init_map()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the metadata for the extended text field.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._max_strings_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'maxStrings'),\n            'element_label': 'maxStrings',\n            'instructions': 'QTI maxStrings settings',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_integer_values': [100],\n            'syntax': 'INTEGER',\n            'object_set': [],\n            'minimum_integer': None,\n            'maximum_integer': None,\n            'integer_set': []\n        }\n        self._expected_length_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'expectedLength'),\n            'element_label': 'expectedLength',\n            'instructions': 'QTI expectedLength setting',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_integer_values': [200],\n            'syntax': 'INTEGER',\n            'object_set': [],\n            'minimum_integer': None,\n            'maximum_integer': None,\n            'integer_set': []\n        }\n        self._expected_lines_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'expectedLines'),\n            'element_label': 'expectedLines',\n            'instructions': 'QTI expectedLines setting',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_integer_values': [10],\n            'syntax': 'INTEGER',\n            'object_set': [],\n            'minimum_integer': None,\n            'maximum_integer': None,\n            'integer_set': []\n        }\n        super(QTIExtendedTextAnswerQuestionFormRecord, self)._init_metadata()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_max_strings(self, max_strings):\n        if not self.my_osid_object_form._is_valid_integer(\n                max_strings, self.get_max_strings_metadata()):\n            raise InvalidArgument('maxStrings')\n        self.my_osid_object_form._my_map['maxStrings'] = max_strings", "response": "set the max string length for this resource"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the expected length of the resource", "response": "def set_expected_length(self, expected_length):\n        \"\"\"stub\"\"\"\n        if not self.my_osid_object_form._is_valid_integer(\n                expected_length, self.get_expected_length_metadata()):\n            raise InvalidArgument('expectedLength')\n        self.my_osid_object_form._my_map['expectedLength'] = expected_length"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_expected_lines(self, expected_lines):\n        if not self.my_osid_object_form._is_valid_integer(\n                expected_lines, self.get_expected_lines_metadata()):\n            raise InvalidArgument('expectedLines')\n        self.my_osid_object_form._my_map['expectedLines'] = expected_lines", "response": "set the expected lines"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomplaining if we don t have an image", "response": "def find_image(self, image, configuration):\n        \"\"\"Complain if we don't have an image\"\"\"\n        images = configuration[\"images\"]\n        available = list(images.keys())\n\n        if not image:\n            info = {}\n            if available:\n                info[\"available\"] = available\n            raise BadOption(\"Please use --image to specify an image\", **info)\n\n        if image not in images:\n            raise BadOption(\"No such image\", wanted=image, available=available)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replicate_global_dbs(cloud_url=None, local_url=None):\n    local_url = local_url or config[\"local_server\"][\"url\"]\n    cloud_url = cloud_url or config[\"cloud_server\"][\"url\"]\n    server = Server(local_url)\n    for db_name in global_dbs:\n        server.replicate(\n            db_name, urljoin(cloud_url, db_name), db_name, continuous=True,\n        )", "response": "Set up replication of the global databases from the cloud server to the local server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cancel_global_db_replication():\n    local_url = config[\"local_server\"][\"url\"]\n    server = Server(local_url)\n    for db_name in global_dbs:\n        server.cancel_replication(db_name)", "response": "Cancel replication of the global databases from the cloud server to the local server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replicate_per_farm_dbs(cloud_url=None, local_url=None, farm_name=None):\n    cloud_url = cloud_url or config[\"cloud_server\"][\"url\"]\n    local_url = local_url or config[\"local_server\"][\"url\"]\n    farm_name = farm_name or config[\"cloud_server\"][\"farm_name\"]\n    username = config[\"cloud_server\"][\"username\"]\n    password = config[\"cloud_server\"][\"password\"]\n\n    # Add credentials to the cloud url\n    parsed_cloud_url = urlparse(cloud_url)\n    if not parsed_cloud_url.username:\n        new_netloc = \"{}:{}@{}\".format(\n            username, password, parsed_cloud_url.netloc\n        )\n    cloud_url = ParseResult(\n        parsed_cloud_url.scheme, new_netloc, parsed_cloud_url.path,\n        parsed_cloud_url.params, parsed_cloud_url.query,\n        parsed_cloud_url.fragment\n    ).geturl()\n\n    server = Server(local_url)\n    for db_name in per_farm_dbs:\n        remote_db_name = \"{}/{}/{}\".format(username, farm_name, db_name)\n        server.replicate(\n            db_name, db_name, urljoin(cloud_url, remote_db_name),\n            continuous=True\n        )", "response": "Sete up replication of the per - farm databases from the local server to the cloud server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncanceling replication of the per - farm databases from the local server to the cloud server.", "response": "def cancel_per_farm_db_replication():\n    \"\"\"\n    Cancel replication of the per-farm databases from the local server to the\n    cloud server.\n    \"\"\"\n    cloud_url = config[\"cloud_server\"][\"url\"]\n    local_url = config[\"local_server\"][\"url\"]\n    server = Server(local_url)\n    for db_name in per_farm_dbs:\n        server.cancel_replication(db_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _register_options(self, api_interface):\n        # type: (ApiInterfaceBase) -> None\n        \"\"\"\n        Register CORS options endpoints.\n        \"\"\"\n        op_paths = api_interface.op_paths(collate_methods=True)\n        for path, operations in op_paths.items():\n            if api.Method.OPTIONS not in operations:\n                self._options_operation(api_interface, path, operations.keys())", "response": "Register CORS options endpoints."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cors_options(self, request, **_):\n        return create_response(\n            request,\n            headers=self.pre_flight_headers(request, request.supported_methods)\n        )", "response": "A CORS options response method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate an OPTIONS operation for the specified path.", "response": "def _options_operation(self, api_interface, path, methods):\n        # type: (ApiInterfaceBase, UrlPath, List[api.Method]) -> None\n        \"\"\"\n        Generate an options operation for the specified path\n        \"\"\"\n        # Trim off path prefix.\n        if path.startswith(api_interface.path_prefix):\n            path = path[len(api_interface.path_prefix):]\n\n        methods = set(methods)\n        methods.add(api.Method.OPTIONS)\n\n        # Apply operation decorator\n        operation_decorator = api_interface.operation(\n            path, api.Method.OPTIONS, middleware=[_MethodsMiddleware(methods)])\n        operation = operation_decorator(self.cors_options)\n        operation.operation_id = path.format(separator='.') + '.cors_options'"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate allow origin header", "response": "def allow_origin(self, request):\n        # type: (BaseHttpRequest) -> str\n        \"\"\"\n        Generate allow origin header\n        \"\"\"\n        origins = self.origins\n        if origins is AnyOrigin:\n            return '*'\n        else:\n            origin = request.origin\n            return origin if origin in origins else ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pre_flight_headers(self, request, methods):\n        # type: (BaseHttpRequest, Sequence[api.Method]) -> Dict[str, str]\n        \"\"\"\n        Generate pre-flight headers.\n        \"\"\"\n        methods = ', '.join(m.value for m in methods)\n        headers = {\n            'Allow': methods,\n            'Cache-Control': 'no-cache, no-store'\n        }\n\n        allow_origin = self.allow_origin(request)\n        if allow_origin:\n            headers = dict_filter(headers, {\n                'Access-Control-Allow-Origin': allow_origin,\n                'Access-Control-Allow-Methods': methods,\n                'Access-Control-Allow-Credentials': {True: 'true', False: 'false'}.get(self.allow_credentials),\n                'Access-Control-Allow-Headers': ', '.join(self.allow_headers) if self.allow_headers else None,\n                'Access-Control-Expose-Headers': ', '.join(self.expose_headers) if self.expose_headers else None,\n                'Access-Control-Max-Age': str(self.max_age) if self.max_age else None,\n            })\n\n        return headers", "response": "Generate pre - flight headers."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates standard request headers", "response": "def request_headers(self, request):\n        \"\"\"\n        Generate standard request headers\n        \"\"\"\n        headers = {}\n\n        allow_origin = self.allow_origin(request)\n        if allow_origin:\n            headers = dict_filter({\n                'Access-Control-Allow-Origin': allow_origin,\n                'Access-Control-Allow-Credentials': {True: 'true', False: 'false'}.get(self.allow_credentials),\n                'Access-Control-Expose-Headers': ', '.join(self.expose_headers) if self.expose_headers else None,\n            })\n\n        return headers"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nposting - request hook to allow CORS headers to responses.", "response": "def post_request(self, request, response):\n        # type: (BaseHttpRequest, HttpResponse) -> HttpResponse\n        \"\"\"\n        Post-request hook to allow CORS headers to responses.\n        \"\"\"\n        if request.method != api.Method.OPTIONS:\n            response.headers.update(self.request_headers(request))\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _muck_w_date(record):\n    # minute 60 is actually minute 0?\n    temp_d = datetime.datetime(int(record['Year']), int(record['Month']),\n                               int(record['Day']), int(record['Hour']) % 24,\n                               int(record['Minute']) % 60)\n    d_off = int(record['Hour'])//24   # hour 24 is actually hour 0\n    if d_off > 0:\n        temp_d += datetime.timedelta(days=d_off)\n    return temp_d", "response": "muck with the date because EPW starts counting from 1 and goes to 24."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the basename of a given station.", "response": "def _basename(station_code, fmt=None):\n    \"\"\"region, country, weather_station, station_code, data_format, url.\"\"\"\n    info = _station_info(station_code)\n    if not fmt:\n        fmt = info['data_format']\n    basename = '%s.%s' % (info['url'].rsplit('/', 1)[1].rsplit('.', 1)[0],\n                          DATA_EXTENTIONS[fmt])\n    return basename"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn two percent high design temperature for a location.", "response": "def twopercent(station_code):\n    \"\"\"Two percent high design temperature for a location.\n\n    Degrees in Celcius\n\n    Args:\n        station_code (str): Weather Station Code\n\n    Returns:\n        float degrees Celcius\n    \"\"\"\n    # (DB=>MWB) 2%, MaxDB=\n    temp = None\n    try:\n        fin = open('%s/%s' % (env.WEATHER_DATA_PATH,\n                              _basename(station_code, 'ddy')))\n        for line in fin:\n            value = re.search(\"\"\"2%, MaxDB=(\\\\d+\\\\.\\\\d*)\"\"\", line)\n            if value:\n                temp = float(value.groups()[0])\n    except IOError:\n        pass\n\n    if not temp:\n        # (DB=>MWB) 2%, MaxDB=\n        try:\n            fin = open('%s/%s' % (env.WEATHER_DATA_PATH,\n                                  _basename(station_code, 'stat')))\n            flag = 0\n            tdata = []\n            for line in fin:\n                if line.find('2%') is not -1:\n                    flag = 3\n                if flag > 0:\n                    tdata.append(line.split('\\t'))\n                    flag -= 1\n            temp = float(tdata[2][5].strip())\n        except IOError:\n            pass\n    if temp:\n        return temp\n    else:\n        raise Exception(\"Error: 2% High Temperature not found\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef minimum(station_code):\n    temp = None\n    fin = None\n    try:\n        fin = open('%s/%s' % (env.WEATHER_DATA_PATH,\n                              _basename(station_code, 'ddy')))\n    except IOError:\n        logger.info(\"File not found\")\n        download_extract(_eere_url(station_code))\n        fin = open('%s/%s' % (env.WEATHER_DATA_PATH,\n                              _basename(station_code, 'ddy')))\n    for line in fin:\n        value = re.search('Max Drybulb=(-?\\\\d+\\\\.\\\\d*)', line)\n        if value:\n            temp = float(value.groups()[0])\n    if not temp:\n        try:\n            fin = open('%s/%s' % (env.WEATHER_DATA_PATH,\n                                  _basename(station_code, 'stat')))\n            for line in fin:\n                if line.find('Minimum Dry Bulb') is not -1:\n                    return float(line[37:-1].split('\\xb0')[0])\n        except IOError:\n            pass\n    if temp:\n        return temp\n    else:\n        raise Exception(\"Error: Minimum Temperature not found\")", "response": "Extreme Minimum Design Temperature for a location."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding the next weather data record.", "response": "def next(self):\n        \"\"\"Weather data record.\n\n        Yields:\n            dict\n        \"\"\"\n        record = self.epw_data.next()\n        local_time = _muck_w_date(record)\n        record['datetime'] = local_time\n        # does this fix a specific data set or a general issue?\n        if self.DST:\n            localdt = self.local_tz.localize(record['datetime'])\n            record['utc_datetime'] = localdt.astimezone(pytz.UTC)\n        else:\n            record['utc_datetime'] = local_time - \\\n                datetime.timedelta(hours=self.TZ)\n\n        return record"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ensure_string(obj):\n\n    if sys.version_info < (3, 2, 0) and isinstance(obj, unicode):\n        return str(obj.encode('utf8'))\n    else:\n        return obj", "response": "Return a string if Unicode convert to string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the base_dict with the update_dict.", "response": "def dict_update(base_dict, update_dict):\n    \"\"\"Return an updated dictionary.\n\n    If ``update_dict`` is a dictionary it will be used to update the `\n    `base_dict`` which is then returned.\n\n    :param request_kwargs: ``dict``\n    :param kwargs: ``dict``\n    :return: ``dict``\n    \"\"\"\n    if isinstance(update_dict, dict):\n        base_dict.update(update_dict)\n\n    return base_dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef op_paths(self, path_base):\n        # type: (Union[str, UrlPath]) -> Generator[Tuple[UrlPath, Operation]]\n        \"\"\"\n        Return all operations stored in containers.\n        \"\"\"\n        path_base += self.path_prefix\n\n        for operation in self._operations:\n            for op_path in operation.op_paths(path_base):\n                yield op_path", "response": "Return all the operation paths that are stored in the given path_base."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef operation(self, path, methods=Method.GET, resource=None, tags=None, summary=None, middleware=None):\n        # type: (UrlPath, Union[Method, Tuple[Method]], Type[Resource], Tags, str, list) -> Operation\n        \"\"\"\n        :param path: A sub path that can be used as a action.\n        :param methods: HTTP method(s) this function responses to.\n        :param resource: Specify the resource that this function encodes/decodes,\n            default is the one specified on the ResourceAPI instance.\n        :param tags: Tags to be applied to operation\n        :param summary: Summary of the what method does (for documentation)\n        :param middleware: List of additional middleware\n\n        \"\"\"\n        def inner(callback):\n            operation = Operation(callback, path, methods, resource, tags, summary, middleware)\n            self.containers.append(operation)\n            return operation\n        return inner", "response": "Decorator for adding an operation to the container."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all operations stored in containers.", "response": "def op_paths(self, path_base=None):\n        # type: (Union[str, UrlPath]) -> Generator[Tuple[UrlPath, Operation]]\n        \"\"\"\n        Return all operations stored in containers.\n        \"\"\"\n        if path_base:\n            path_base += self.path_prefix\n        else:\n            path_base = self.path_prefix or UrlPath()\n\n        for container in self.containers:\n            for op_path in container.op_paths(path_base):\n                yield op_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling an internal server error.", "response": "def handle_500(self, request, exception):\n        # type: (BaseHttpRequest, BaseException) -> Resource\n        \"\"\"\n        Handle an *un-handled* exception.\n        \"\"\"\n        # Let middleware attempt to handle exception\n        try:\n            for middleware in self.middleware.handle_500:\n                resource = middleware(request, exception)\n                if resource:\n                    return resource\n\n        except Exception as ex:  # noqa - This is a top level handler\n            exception = ex\n\n        # Fallback to generic error\n        logger.exception('Internal Server Error: %s', exception, extra={\n            'status_code': 500,\n            'request': request\n        })\n        return Error.from_status(HTTPStatus.INTERNAL_SERVER_ERROR, 0,\n                                 \"An unhandled error has been caught.\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndispatching and handle exceptions from an operation.", "response": "def dispatch_operation(self, operation, request, path_args):\n        # type: (Operation, BaseHttpRequest, Dict[str, Any]) -> Tuple[Any, Optional[HTTPStatus], Optional[dict]]\n        \"\"\"\n        Dispatch and handle exceptions from operation.\n        \"\"\"\n        try:\n            # path_args is passed by ref so changes can be made.\n            for middleware in self.middleware.pre_dispatch:\n                middleware(request, path_args)\n\n            resource = operation(request, path_args)\n\n            for middleware in self.middleware.post_dispatch:\n                resource = middleware(request, resource)\n\n        except ImmediateHttpResponse as e:\n            # An exception used to return a response immediately, skipping any\n            # further processing.\n            return e.resource, e.status, e.headers\n\n        except ValidationError as e:\n            # A validation error was raised by a resource.\n            if hasattr(e, 'message_dict'):\n                resource = Error.from_status(HTTPStatus.BAD_REQUEST, 0, \"Failed validation\", meta=e.message_dict)\n            else:\n                resource = Error.from_status(HTTPStatus.BAD_REQUEST, 0, str(e))\n            return resource, resource.status, None\n\n        except NotImplementedError:\n            resource = Error.from_status(HTTPStatus.NOT_IMPLEMENTED, 0, \"The method has not been implemented\")\n            return resource, resource.status, None\n\n        except Exception as e:\n            if self.debug_enabled:\n                # If debug is enabled then fallback to the frameworks default\n                # error processing, this often provides convenience features\n                # to aid in the debugging process.\n                raise\n\n            resource = None\n            # Fallback to the default handler\n            if resource is None:\n                resource = self.handle_500(request, e)\n\n            return resource, resource.status, None\n\n        else:\n            return resource, None, None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _dispatch(self, operation, request, path_args):\n        # Determine the request and response types. Ensure API supports the requested types\n        request_type = resolve_content_type(self.request_type_resolvers, request)\n        request_type = self.remap_codecs.get(request_type, request_type)\n        try:\n            request.request_codec = self.registered_codecs[request_type]\n        except KeyError:\n            return HttpResponse.from_status(HTTPStatus.UNPROCESSABLE_ENTITY)\n\n        response_type = resolve_content_type(self.response_type_resolvers, request)\n        response_type = self.remap_codecs.get(response_type, response_type)\n        try:\n            request.response_codec = self.registered_codecs[response_type]\n        except KeyError:\n            return HttpResponse.from_status(HTTPStatus.NOT_ACCEPTABLE)\n\n        # Check if method is in our allowed method list\n        if request.method not in operation.methods:\n            return HttpResponse.from_status(\n                HTTPStatus.METHOD_NOT_ALLOWED,\n                {'Allow': ','.join(m.value for m in operation.methods)}\n            )\n\n        # Response types\n        resource, status, headers = self.dispatch_operation(operation, request, path_args)\n\n        if isinstance(status, HTTPStatus):\n            status = status.value\n\n        # Return a HttpResponse and just send it!\n        if isinstance(resource, HttpResponse):\n            return resource\n\n        # Encode the response\n        return create_response(request, resource, status, headers)", "response": "Wrapped dispatch method, prepare request and generate a HTTP Response."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dispatch(self, operation, request, **path_args):\n        # Add current operation to the request (for convenience in middleware methods)\n        request.current_operation = operation\n\n        try:\n            for middleware in self.middleware.pre_request:\n                response = middleware(request, path_args)\n                # Return HttpResponse if one is returned.\n                if isinstance(response, HttpResponse):\n                    return response\n\n            response = self._dispatch(operation, request, path_args)\n\n            for middleware in self.middleware.post_request:\n                response = middleware(request, response)\n\n        except Exception as ex:\n            if self.debug_enabled:\n                # If debug is enabled then fallback to the frameworks default\n                # error processing, this often provides convenience features\n                # to aid in the debugging process.\n                raise\n            self.handle_500(request, ex)\n            return HttpResponse(\"Error processing response.\", HTTPStatus.INTERNAL_SERVER_ERROR)\n\n        else:\n            return response", "response": "Dispatch incoming request and capture top level exceptions and return a response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef op_paths(self, path_base=None, collate_methods=False):\n        # type: (Union[str, UrlPath], bool) -> Union[Generator[Tuple[UrlPath, Operation]], Dict[UrlPath, Operation]]\n        \"\"\"\n        Return all operations stored in containers.\n\n        Use the `collate_methods` option to collate methods by path. This is required for\n        certain web frameworks (eg Django) where it is up the developer to handle routing\n        of request method.\n        \"\"\"\n        op_paths = super(ApiInterfaceBase, self).op_paths()\n\n        if collate_methods:\n            # Transform into a path -> method -> operation mapping.\n            paths = collections.OrderedDict()\n            for path, operation in op_paths:\n                methods = paths.setdefault(path, {})\n                for method in operation.methods:\n                    methods[method] = operation\n\n            return paths\n\n        else:\n            return op_paths", "response": "Return all operations stored in containers."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first entry of the source directory.", "response": "def left(self):\n        \"\"\"\n        Entry is left sibling of current directory entry\n        \"\"\"\n        return self.source.directory[self.left_sibling_id] \\\n            if self.left_sibling_id != NOSTREAM else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the right sibling of the current entry or None if no such entry exists.", "response": "def right(self):\n        \"\"\"\n        Entry is right sibling of current directory entry\n        \"\"\"\n        return self.source.directory[self.right_sibling_id] \\\n            if self.right_sibling_id != NOSTREAM else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self, size=None):\n        if self._is_mini:\n            self.seek(self._position)\n        else:\n            self.source.seek(self._source_position)\n        if not size or size < 0:\n            size = self.size - self.tell()\n\n        data = b('')\n        while len(data) < size:\n            if self.tell() > self.size:\n                break\n            if self._sector_number == ENDOFCHAIN:\n                break\n\n            to_read = size - len(data)\n            to_end = self.sector_size - self._position_in_sector\n            to_do = min(to_read, to_end)\n            data += self.stream.read(to_do)\n\n            self._position += to_do\n            self._source_position = self.source.tell()\n\n            if to_read >= to_end:\n                self._position_in_sector = 0\n\n                self._sector_number = self.next_sector(self._sector_number)\n                position = (self._sector_number + int(not self._is_mini)) \\\n                    << self.sector_shift\n                self.stream.seek(position)\n            else:\n                self._position_in_sector += to_do\n\n        return data", "response": "Reads size bytes from the current directory entry."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nseek to specified offset in current directory entry entry.", "response": "def seek(self, offset, whence=SEEK_SET):\n        \"\"\"\n        Seeks to specified `offset` position in current directory entry\n        stream. `Whence` can be SEEK_SET - from entry's start, SEEK_CUR -\n        from current position and SEEK_END - from entry's end. Constants are\n        same with same stored `os` module.\n        \"\"\"\n        if whence == SEEK_CUR:\n            offset += self.tell()\n        elif whence == SEEK_END:\n            offset = self.size - offset\n\n        self._position = offset\n        self._sector_number = self.sector_start\n        current = 0\n\n        while self._sector_number != ENDOFCHAIN and \\\n                (current + 1) * self.sector_size < offset:\n            self._sector_number = self.next_sector(self._sector_number)\n            current += 1\n\n        self._position_in_sector = offset - current * self.sector_size\n\n        position = (self._sector_number + int(not self._is_mini)) \\\n            << self.sector_shift\n        position += self._position_in_sector\n\n        self.stream.seek(position)\n        self._source_position = self.source.tell()\n        return self.tell()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the child entry object.", "response": "def child(self):\n        \"\"\"\n        Root entry object has only one child entry and no siblings.\n        \"\"\"\n        return self.stream.directory[self.child_id] \\\n            if self.child_id != NOSTREAM else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply_filter(objs, selector, mode):\n    '''Apply selector to transform each object in objs.\n\n    This operates in-place on objs. Empty objects are removed from the list.\n\n    Args:\n        mode: either KEEP (to keep selected items & their ancestors) or DELETE\n              (to delete selected items and their children).\n    '''\n    indices_to_delete = []\n    presumption = DELETE if mode == KEEP else KEEP\n    for i, obj in enumerate(objs):\n        timer.log('Applying selector: %s' % selector)\n        marks = {k: mode for k in selector_to_ids(selector, obj, mode)}\n        timer.log('done applying selector')\n        timer.log('filtering object...')\n        filter_object(obj, marks, presumption=presumption)\n        timer.log('done filtering')\n        if obj is None:\n            indices_to_delete.append(i)\n\n    for index in reversed(indices_to_delete):\n        del objs[index]", "response": "Apply selector to transform each object in objs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply_selector(objs, selector):\n    '''Returns a list of objects which match the selector in any of objs.'''\n    out = []\n    for obj in objs:\n        timer.log('Applying selector: %s' % selector)\n        out += list(jsonselect.match(selector, objs))\n        timer.log('done applying selector')\n    return out", "response": "Returns a list of objects which match the selector in any of objs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites statement to stderr with timing info in DEBUG mode.", "response": "def log(self, statement):\n        '''Write statement to stderr with timing info in DEBUG mode.'''\n        global DEBUG\n        time_ms = 1000 * time.time()\n        if DEBUG:\n            total_time_ms = time_ms - self._start_time_ms_\n            lap_time_ms = time_ms - self._last_time_ms_\n            sys.stderr.write('%6.f (%6.f ms) %s\\n' % (\n                total_time_ms, lap_time_ms, statement))\n        self._last_time_ms_ = time_ms"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_data(self):\n        remote_url = self.get_url()\n        filename = remote_url.split('/')[-1].split('?')[0]\n        req = requests.get(remote_url)\n        buf = StringIO(req.content)\n        data = DataInputStream(buf)\n        data.name = filename\n        return data", "response": "Gets the asset content data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_object_map(self):\n        obj_map = self._payload.get_object_map()\n        obj_map.update({'url': self.get_url()})\n        obj_map['recordTypeIds'].append(str(AWS_ASSET_CONTENT_RECORD_TYPE))\n        return obj_map", "response": "stub Get the object map for this ASSET content record type."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the content data for the current object.", "response": "def set_data(self, data=None):\n        \"\"\"Sets the content data.\n\n        arg:    data (osid.transport.DataInputStream): the content data\n        raise:  InvalidArgument - ``data`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``data`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # cjshaw, Jan 7, 2015\n        # Testing this with AWS -- set data + set_url (to save the S3 URL)\n        # Uses:\n        #    1) AWS repository-put user key pair\n        #    2) S3 bucket for odl-repository\n        #\n        # For now, follow a convention of all items need to be in a catalog_id\n        # folder...like:\n        #    self._repository_id.identifier/<file>\n        #\n        # following: http://stackoverflow.com/questions/15085864/\n        # how-to-upload-a-file-to-directory-in-s3-bucket-using-boto\n        odl_repo, url = get_aws_s3_handle(self._config_map)\n        repository_id = self._repository_id.get_identifier()\n        try:\n            filename = data.name.split('/')[-1]\n            filename = re.sub(r'[^\\w.]', '_', filename)  # clean out the spaces\n        except AttributeError:\n            filename = ObjectId()\n        remote_location = str(repository_id) + '/' + str(filename)\n        url += '/' + remote_location\n\n        data.seek(0)\n\n        odl_repo.put_object(\n            Body=data.read(),\n            Bucket=self._config_map['s3_bucket'],\n            Key=remote_location\n        )\n        # odl_repo.key = remote_location\n        # odl_repo.set_contents_from_file(data._my_data)\n\n        # this should set the original S3 location, so we can retrieve the\n        # original document if needed\n        # do NOT set to the Cloudfront location...that should be locked down for\n        # expiring URLs\n        # constructed by the Cloudfront keypair only.\n        self._payload.set_url(url)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_data(self):\n        # cjshaw@mit.edu, Jan 9, 2015\n        # Removes the item from AWS S3 and resets URL to ''\n        odl_repo, url = get_aws_s3_handle(self._config_map)\n        existing_url = self._payload.get_url_metadata().get_existing_string_values()[0]\n        # try to clear from payload first, in case that fails we won't mess with AWS\n        self._payload.clear_url()\n        key_path = existing_url.replace(url, '')\n\n        # for boto3, remove leading /\n        if key_path[0] == '/':\n            key_path = key_path[1::]\n        odl_repo.delete_object(\n            Bucket=self._config_map['s3_bucket'],\n            Key=key_path\n        )", "response": "Removes the content data from AWS S3 and resets URL to ''"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_next_asset_contents(self, n=None):\n        if n is None:\n            raise NullArgument()\n        if not isinstance(n, int):\n            raise InvalidArgument()\n        provider_list = self._payload_list.get_next_asset_contents(n)\n        new_list = []\n        for asset_content in provider_list:\n            if asset_content.has_url() and 'amazonaws.com' in asset_content.get_url():\n                new_list.append(AssetContent(asset_content, self._config_map))\n            else:\n                new_list.append(asset_content)\n        return new_list", "response": "Gets the next set of AssetContents in this list which must be less than or equal to the return from available."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresolving content types from a request.", "response": "def resolve_content_type(type_resolvers, request):\n    # type: (Iterable[Callable[[Any], str]], Any) -> Optional[str]\n    \"\"\"\n    Resolve content types from a request.\n    \"\"\"\n    for resolver in type_resolvers:\n        content_type = parse_content_type(resolver(request))\n        if content_type:\n            return content_type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a resource instance from the request body.", "response": "def get_resource(request, resource, allow_multiple=False, full_clean=True, default_to_not_supplied=False):\n    \"\"\"\n    Get a resource instance from ``request.body``.\n\n    Note error code 98 is returned in multiple places, this is to prevent leakage of details of defined resources.\n\n    \"\"\"\n    # Decode the request body.\n    body = request.body\n    if isinstance(body, bytes):\n        try:\n            body = body.decode('UTF8')\n        except UnicodeDecodeError as ude:\n            raise HttpError(HTTPStatus.BAD_REQUEST, 99, \"Unable to decode request body.\", str(ude))\n\n    try:\n        instance = request.request_codec.loads(body, resource=resource, full_clean=full_clean,\n                                               default_to_not_supplied=default_to_not_supplied)\n\n    except ResourceException:\n        raise HttpError(HTTPStatus.BAD_REQUEST, 98, \"Invalid resource type.\")\n\n    except CodecDecodeError as cde:\n        raise HttpError(HTTPStatus.BAD_REQUEST, 96, \"Unable to decode body.\", str(cde))\n\n    # Check we have the correct resource\n    if isinstance(instance, list):\n        # Check types first. This is to prevent being able to infer other resource types by sending lists of them.\n        if any(not isinstance(i, resource) for i in instance):\n            raise HttpError(HTTPStatus.BAD_REQUEST, 98, \"Invalid resource type.\")\n\n        if not allow_multiple:\n            raise HttpError(HTTPStatus.BAD_REQUEST, 97, \"Expected a single resource not a list.\")\n\n    elif not isinstance(instance, resource):\n        raise HttpError(HTTPStatus.BAD_REQUEST, 98, \"Invalid resource type.\")\n\n    return instance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a HttpResponse object.", "response": "def create_response(request, body=None, status=None, headers=None):\n    # type: (BaseHttpRequest, Any, HTTPStatus, dict) -> HttpResponse\n    \"\"\"\n    Generate a HttpResponse.\n\n    :param request: Request object\n    :param body: Body of the response\n    :param status: HTTP status code\n    :param headers: Any headers.\n\n    \"\"\"\n    if body is None:\n        return HttpResponse(None, status or HTTPStatus.NO_CONTENT, headers)\n    else:\n        body = request.response_codec.dumps(body)\n        response = HttpResponse(body, status or HTTPStatus.OK, headers)\n        response.set_content_type(request.response_codec.CONTENT_TYPE)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads internal cache entries from the internal cache.", "response": "def read(self):\n        \"\"\"\n        This module is lazy-loaded by default. You can read all internal\n        structure by calling this method.\n        \"\"\"\n        stack = [self[0].child]\n        while stack:\n            current = stack.pop()\n            if current.right:\n                stack.append(current.right)\n            if current.left:\n                stack.append(current.left)\n\n        self[0].seek(0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a specific entry in the cache by its name.", "response": "def by_name(self, name):\n        \"\"\"\n        In many cases you want to access directory not by it's ID, but by\n        it's name. This method implements red-black search method, which\n        internally uses CFB format. Also this method has internal name cache\n        to speed up 2nd+ named accesses.\n        \"\"\"\n        if name in self._name_cache:\n            return self[self._name_cache[name]]\n\n        if self.source.root.name == name:\n            return self.source.root\n        current = self.source.root.child\n\n        while current:\n            if len(current.name) < len(name):\n                current = current.right\n            elif len(current.name) > len(name):\n                current = current.left\n            elif current.name < name:\n                current = current.right\n            elif current.name > name:\n                current = current.left\n            else:\n                return current\n\n        raise KeyError(name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompare two sets of values.", "response": "def _compare(self, other, method):\n        \"\"\"see https://regebro.wordpress.com/2010/12/13/python-implementing-rich-comparison-the-correct-way/\"\"\"\n        # This needs to be updated to take uncertainty into account:\n        if isinstance(other, abc_mapping_primitives.Coordinate):\n            if self.get_dimensions() != other.get_dimensions():\n                return False\n            other_values = other.get_values()\n            for index in range(self._dimensions):\n                if not method(self._values[index], other_values[index]):\n                    return False\n            return True\n        return NotImplemented"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the underlying vault view to match current view", "response": "def _set_vault_view(self, session):\n        \"\"\"Sets the underlying vault view to match current view\"\"\"\n        if self._vault_view == COMPARATIVE:\n            try:\n                session.use_comparative_vault_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_vault_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npass through to provider AuthorizationVaultSession. use_comparative_vault_view", "response": "def use_comparative_vault_view(self):\n        \"\"\"Pass through to provider AuthorizationVaultSession.use_comparative_vault_view\"\"\"\n        self._vault_view = COMPARATIVE\n        # self._get_provider_session('authorization_vault_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_vault_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_plenary_vault_view(self):\n        self._vault_view = PLENARY\n        # self._get_provider_session('authorization_vault_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_vault_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AuthorizationVaultSession. use_plenary_vault_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vaults_by_ids(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_by_ids\n        catalogs = self._get_provider_session('vault_lookup_session').get_vaults_by_ids(*args, **kwargs)\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Vault(self._provider_manager, cat, self._runtime, self._proxy))\n        return VaultList(cat_list)", "response": "Pass through to provider VaultLookupSession. get_vaults_by_ids"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_vaults(self):\n        # Implemented from kitosid template for -\n        # osid.resource.BinLookupSession.get_bins_template\n        catalogs = self._get_provider_session('vault_lookup_session').get_vaults()\n        cat_list = []\n        for cat in catalogs:\n            cat_list.append(Vault(self._provider_manager, cat, self._runtime, self._proxy))\n        return VaultList(cat_list)", "response": "Pass through to provider VaultLookupSession. get_vaults"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npass through to provider VaultAdminSession. create_vault", "response": "def create_vault(self, *args, **kwargs):\n        \"\"\"Pass through to provider VaultAdminSession.create_vault\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.create_bin\n        return Vault(\n            self._provider_manager,\n            self._get_provider_session('vault_admin_session').create_vault(*args, **kwargs),\n            self._runtime,\n            self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vault_form(self, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.get_bin_form_for_update_template\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'vault_record_types' in kwargs:\n            return self.get_vault_form_for_create(*args, **kwargs)\n        else:\n            return self.get_vault_form_for_update(*args, **kwargs)", "response": "Pass through to provider VaultAdminSession. get_vault_form_for_update"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_vault(self, vault_form, *args, **kwargs):\n        # Implemented from kitosid template for -\n        # osid.resource.BinAdminSession.update_bin\n        if vault_form.is_for_update():\n            return self.update_vault(vault_form, *args, **kwargs)\n        else:\n            return self.create_vault(vault_form, *args, **kwargs)", "response": "Pass through to provider VaultAdminSession. update_vault"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the underlying vault view to match current view", "response": "def _set_vault_view(self, session):\n        \"\"\"Sets the underlying vault view to match current view\"\"\"\n        if self._vault_view == FEDERATED:\n            try:\n                session.use_federated_vault_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_isolated_vault_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider AuthorizationLookupSession. use_comparative_authorization_view", "response": "def use_comparative_authorization_view(self):\n        \"\"\"Pass through to provider AuthorizationLookupSession.use_comparative_authorization_view\"\"\"\n        self._object_views['authorization'] = COMPARATIVE\n        # self._get_provider_session('authorization_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_comparative_authorization_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npassing through to provider AuthorizationLookupSession. use_plenary_authorization_view", "response": "def use_plenary_authorization_view(self):\n        \"\"\"Pass through to provider AuthorizationLookupSession.use_plenary_authorization_view\"\"\"\n        self._object_views['authorization'] = PLENARY\n        # self._get_provider_session('authorization_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_plenary_authorization_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npass through to provider AuthorizationLookupSession. use_federated_vault_view", "response": "def use_federated_vault_view(self):\n        \"\"\"Pass through to provider AuthorizationLookupSession.use_federated_vault_view\"\"\"\n        self._vault_view = FEDERATED\n        # self._get_provider_session('authorization_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_federated_vault_view()\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef use_isolated_vault_view(self):\n        self._vault_view = ISOLATED\n        # self._get_provider_session('authorization_lookup_session') # To make sure the session is tracked\n        for session in self._get_provider_sessions():\n            try:\n                session.use_isolated_vault_view()\n            except AttributeError:\n                pass", "response": "Pass through to provider AuthorizationLookupSession. use_isolated_vault_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npasses through to provider AuthorizationAdminSession. get_authorization_form_for_update", "response": "def get_authorization_form(self, *args, **kwargs):\n        \"\"\"Pass through to provider AuthorizationAdminSession.get_authorization_form_for_update\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.get_resource_form_for_update\n        # This method might be a bit sketchy. Time will tell.\n        if isinstance(args[-1], list) or 'authorization_record_types' in kwargs:\n            return self.get_authorization_form_for_create(*args, **kwargs)\n        else:\n            return self.get_authorization_form_for_update(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npass through to provider AuthorizationAdminSession. update_authorization", "response": "def save_authorization(self, authorization_form, *args, **kwargs):\n        \"\"\"Pass through to provider AuthorizationAdminSession.update_authorization\"\"\"\n        # Implemented from kitosid template for -\n        # osid.resource.ResourceAdminSession.update_resource\n        if authorization_form.is_for_update():\n            return self.update_authorization(authorization_form, *args, **kwargs)\n        else:\n            return self.create_authorization(authorization_form, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_grade_system_id(self):\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['gradeSystemId']):\n            raise errors.IllegalState('grade_system empty')\n        return Id(self._my_map['gradeSystemId'])", "response": "Gets the grade system Id in which this grade belongs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_input_score_start_range_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['input_score_start_range'])\n        metadata.update({'existing_decimal_values': self._my_map['inputScoreStartRange']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the input score start range."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_input_score_start_range(self, score):\n        # Implemented from template for osid.grading.GradeSystemForm.set_lowest_numeric_score\n        if self.get_input_score_start_range_metadata().is_read_only():\n            raise errors.NoAccess()\n        try:\n            score = float(score)\n        except ValueError:\n            raise errors.InvalidArgument()\n        if not self._is_valid_decimal(score, self.get_input_score_start_range_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['inputScoreStartRange'] = score", "response": "Sets the input score start range."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclearing the input score start range.", "response": "def clear_input_score_start_range(self):\n        \"\"\"Clears the input score start.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.grading.GradeSystemForm.clear_lowest_numeric_score\n        if (self.get_input_score_start_range_metadata().is_read_only() or\n                self.get_input_score_start_range_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['inputScoreStartRange'] = self._input_score_start_range_default"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the metadata for the input score start range.", "response": "def get_input_score_end_range_metadata(self):\n        \"\"\"Gets the metadata for the input score start range.\n\n        return: (osid.Metadata) - metadata for the input score start\n                range\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['input_score_end_range'])\n        metadata.update({'existing_decimal_values': self._my_map['inputScoreEndRange']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_input_score_end_range(self, score):\n        # Implemented from template for osid.grading.GradeSystemForm.set_lowest_numeric_score\n        if self.get_input_score_end_range_metadata().is_read_only():\n            raise errors.NoAccess()\n        try:\n            score = float(score)\n        except ValueError:\n            raise errors.InvalidArgument()\n        if not self._is_valid_decimal(score, self.get_input_score_end_range_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['inputScoreEndRange'] = score", "response": "Sets the input score end range."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear_input_score_end_range(self):\n        # Implemented from template for osid.grading.GradeSystemForm.clear_lowest_numeric_score\n        if (self.get_input_score_end_range_metadata().is_read_only() or\n                self.get_input_score_end_range_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['inputScoreEndRange'] = self._input_score_end_range_default", "response": "Clears the input score end range."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_output_score_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['output_score'])\n        metadata.update({'existing_decimal_values': self._my_map['outputScore']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the output score start range."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_output_score(self, score):\n        # Implemented from template for osid.grading.GradeSystemForm.set_lowest_numeric_score\n        if self.get_output_score_metadata().is_read_only():\n            raise errors.NoAccess()\n        try:\n            score = float(score)\n        except ValueError:\n            raise errors.InvalidArgument()\n        if not self._is_valid_decimal(score, self.get_output_score_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['outputScore'] = score", "response": "Sets the output score."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the output score.", "response": "def clear_output_score(self):\n        \"\"\"Clears the output score.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.grading.GradeSystemForm.clear_lowest_numeric_score\n        if (self.get_output_score_metadata().is_read_only() or\n                self.get_output_score_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['outputScore'] = self._output_score_default"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the grade Ids in this system ranked from highest to lowest.", "response": "def get_grade_ids(self):\n        \"\"\"Gets the grade ``Ids`` in this system ranked from highest to lowest.\n\n        return: (osid.id.IdList) - the list of grades ``Ids``\n        raise:  IllegalState - ``is_based_on_grades()`` is ``false``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.repository.Asset.get_asset_content_ids_template\n        id_list = []\n        for grade in self.get_grades():\n            id_list.append(grade.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_grades(self):\n        # Implemented from template for osid.repository.Asset.get_asset_contents_template\n        return GradeList(\n            self._my_map['grades'],\n            runtime=self._runtime,\n            proxy=self._proxy)", "response": "Gets the grades in this system ranked from highest to lowest."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_lowest_numeric_score(self):\n        if self.is_based_on_grades():\n            raise errors.IllegalState('This GradeSystem is based on grades')\n        if self._my_map['lowestNumericScore'] is None:\n            return None\n        else:\n            return Decimal(str(self._my_map['lowestNumericScore']))", "response": "Gets the lowest number in a numeric grading system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_numeric_score_increment(self):\n        if self.is_based_on_grades():\n            raise errors.IllegalState('This GradeSystem is based on grades')\n        if self._my_map['numericScoreIncrement'] is None:\n            return None\n        else:\n            return Decimal(str(self._my_map['numericScoreIncrement']))", "response": "Gets the incremental step."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the highest number in a numeric grading system.", "response": "def get_highest_numeric_score(self):\n        \"\"\"Gets the highest number in a numeric grading system.\n\n        return: (decimal) - the highest number\n        raise:  IllegalState - ``is_based_on_grades()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.is_based_on_grades():\n            raise errors.IllegalState('This GradeSystem is based on grades')\n        if self._my_map['highestNumericScore'] is None:\n            return None\n        else:\n            return Decimal(str(self._my_map['highestNumericScore']))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the map of the record types to use for this object", "response": "def _init_map(self, record_types=None, **kwargs):\n        \"\"\"Initialize form map\"\"\"\n        osid_objects.OsidObjectForm._init_map(self, record_types=record_types)\n        self._my_map['numericScoreIncrement'] = self._numeric_score_increment_default\n        self._my_map['lowestNumericScore'] = self._lowest_numeric_score_default\n        self._my_map['basedOnGrades'] = self._based_on_grades_default\n        self._my_map['highestNumericScore'] = self._highest_numeric_score_default\n        self._my_map['assignedGradebookIds'] = [str(kwargs['gradebook_id'])]\n        self._my_map['grades'] = []"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the metadata for a grade - based designation.", "response": "def get_based_on_grades_metadata(self):\n        \"\"\"Gets the metadata for a grade-based designation.\n\n        return: (osid.Metadata) - metadata for the grade-based\n                designation\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['based_on_grades'])\n        metadata.update({'existing_boolean_values': self._my_map['basedOnGrades']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the grade - based designation.", "response": "def set_based_on_grades(self, grades):\n        \"\"\"Sets the grade-based designation.\n\n        arg:    grades (boolean): the grade-based designation\n        raise:  InvalidArgument - ``grades`` is invalid\n        raise:  NoAccess - ``grades`` cannot be modified\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_based_on_grades_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(grades):\n            raise errors.InvalidArgument()\n        self._my_map['basedOnGrades'] = grades"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear_based_on_grades(self):\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_based_on_grades_metadata().is_read_only() or\n                self.get_based_on_grades_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['basedOnGrades'] = self._based_on_grades_default", "response": "Clears the based on grades designation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the metadata for the lowest numeric score.", "response": "def get_lowest_numeric_score_metadata(self):\n        \"\"\"Gets the metadata for the lowest numeric score.\n\n        return: (osid.Metadata) - metadata for the lowest numeric score\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['lowest_numeric_score'])\n        metadata.update({'existing_decimal_values': self._my_map['lowestNumericScore']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_lowest_numeric_score(self, score):\n        # Implemented from template for osid.grading.GradeSystemForm.set_lowest_numeric_score\n        if self.get_lowest_numeric_score_metadata().is_read_only():\n            raise errors.NoAccess()\n        try:\n            score = float(score)\n        except ValueError:\n            raise errors.InvalidArgument()\n        if not self._is_valid_decimal(score, self.get_lowest_numeric_score_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['lowestNumericScore'] = score", "response": "Sets the lowest numeric score."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclearing the lowest score.", "response": "def clear_lowest_numeric_score(self):\n        \"\"\"Clears the lowest score.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.grading.GradeSystemForm.clear_lowest_numeric_score\n        if (self.get_lowest_numeric_score_metadata().is_read_only() or\n                self.get_lowest_numeric_score_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['lowestNumericScore'] = self._lowest_numeric_score_default"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_numeric_score_increment_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['numeric_score_increment'])\n        metadata.update({'existing_decimal_values': self._my_map['numericScoreIncrement']})\n        return Metadata(**metadata)", "response": "Gets the metadata for the lowest numeric score increment"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_numeric_score_increment(self, increment):\n        # Implemented from template for osid.grading.GradeSystemForm.set_lowest_numeric_score\n        if self.get_numeric_score_increment_metadata().is_read_only():\n            raise errors.NoAccess()\n        try:\n            increment = float(increment)\n        except ValueError:\n            raise errors.InvalidArgument()\n        if not self._is_valid_decimal(increment, self.get_numeric_score_increment_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['numericScoreIncrement'] = increment", "response": "Sets the numeric score increment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclear the numeric score increment.", "response": "def clear_numeric_score_increment(self):\n        \"\"\"Clears the numeric score increment.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.grading.GradeSystemForm.clear_lowest_numeric_score\n        if (self.get_numeric_score_increment_metadata().is_read_only() or\n                self.get_numeric_score_increment_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['numericScoreIncrement'] = self._numeric_score_increment_default"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the metadata for the highest numeric score.", "response": "def get_highest_numeric_score_metadata(self):\n        \"\"\"Gets the metadata for the highest numeric score.\n\n        return: (osid.Metadata) - metadata for the highest numeric score\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['highest_numeric_score'])\n        metadata.update({'existing_decimal_values': self._my_map['highestNumericScore']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_highest_numeric_score(self, score):\n        # Implemented from template for osid.grading.GradeSystemForm.set_lowest_numeric_score\n        if self.get_highest_numeric_score_metadata().is_read_only():\n            raise errors.NoAccess()\n        try:\n            score = float(score)\n        except ValueError:\n            raise errors.InvalidArgument()\n        if not self._is_valid_decimal(score, self.get_highest_numeric_score_metadata()):\n            raise errors.InvalidArgument()\n        self._my_map['highestNumericScore'] = score", "response": "Sets the highest numeric score."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the highest numeric score.", "response": "def clear_highest_numeric_score(self):\n        \"\"\"Clears the highest numeric score.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.grading.GradeSystemForm.clear_lowest_numeric_score\n        if (self.get_highest_numeric_score_metadata().is_read_only() or\n                self.get_highest_numeric_score_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['highestNumericScore'] = self._highest_numeric_score_default"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_gradebook_column_id(self):\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['gradebookColumnId']):\n            raise errors.IllegalState('gradebook_column empty')\n        return Id(self._my_map['gradebookColumnId'])", "response": "Gets the Id of the GradebookColumn."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gradebook_column(self):\n        # Implemented from template for osid.learning.Activity.get_objective\n        if not bool(self._my_map['gradebookColumnId']):\n            raise errors.IllegalState('gradebook_column empty')\n        mgr = self._get_provider_manager('GRADING')\n        if not mgr.supports_gradebook_column_lookup():\n            raise errors.OperationFailed('Grading does not support GradebookColumn lookup')\n        lookup_session = mgr.get_gradebook_column_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_gradebook_view()\n        return lookup_session.get_gradebook_column(self.get_gradebook_column_id())", "response": "Gets the ``GradebookColumn``.\n\n        return: (osid.grading.GradebookColumn) - the ``GradebookColumn``\n        raise:  OperationFailed - unable to complete request\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_overridden_calculated_entry(self):\n        # Implemented from template for osid.resource.Resource.get_avatar_template\n        if not bool(self._my_map['overriddenCalculatedEntryId']):\n            raise errors.IllegalState('this GradeEntry has no overridden_calculated_entry')\n        mgr = self._get_provider_manager('GRADING')\n        if not mgr.supports_grade_entry_lookup():\n            raise errors.OperationFailed('Grading does not support GradeEntry lookup')\n        lookup_session = mgr.get_grade_entry_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        lookup_session.use_federated_gradebook_view()\n        osid_object = lookup_session.get_grade_entry(self.get_overridden_calculated_entry_id())\n        return osid_object", "response": "Gets the overridden entry this entry overrides."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_grade_id(self):\n        # Implemented from template for osid.learning.Activity.get_objective_id\n        if not bool(self._my_map['gradeId']):\n            raise errors.IllegalState('grade empty')\n        return Id(self._my_map['gradeId'])", "response": "Gets the grade Id in this entry in this entry"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_grade(self):\n        grade_system = self.get_gradebook_column().get_grade_system()\n\n        for grade in grade_system.get_grades():\n            if str(grade.ident) == self._my_map['gradeId']:\n                return grade\n        raise errors.IllegalState('gradeId does not exist in this GradeSystem')", "response": "Gets the grade in this entry if the grading system is based on grades."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_time_graded(self):\n        if not self.is_graded() or self.is_derived():\n            raise errors.IllegalState()\n        time_graded = self._my_map['timeGraded']\n        return DateTime(\n            year=time_graded.year,\n            month=time_graded.month,\n            day=time_graded.day,\n            hour=time_graded.hour,\n            minute=time_graded.minute,\n            second=time_graded.second,\n            microsecond=time_graded.microsecond)", "response": "Gets the time the gradeable object was graded."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the Id of the Agent that created this entry.", "response": "def get_grading_agent_id(self):\n        \"\"\"Gets the ``Id`` of the ``Agent`` that created this entry.\n\n        return: (osid.id.Id) - the ``Id`` of the ``Agent``\n        raise:  IllegalState - ``is_graded()`` is ``false`` or\n                ``is_derived()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not self.is_graded or self.is_derived():\n            raise errors.IllegalState()\n        return Id(self._my_map['gradingAgentId'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the metadata for the ignore flag for calculator", "response": "def get_ignored_for_calculations_metadata(self):\n        \"\"\"Gets the metadata for the ignore flag.\n\n        return: (osid.Metadata) - metadata for the ignore flag\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['ignored_for_calculations'])\n        metadata.update({'existing_boolean_values': self._my_map['ignoredForCalculations']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the ignore for calculations flag.", "response": "def set_ignored_for_calculations(self, ignore):\n        \"\"\"Sets the ignore for calculations flag.\n\n        arg:    ignore (boolean): the new ignore flag\n        raise:  InvalidArgument - ``ignore`` is invalid\n        raise:  NoAccess - ``ignore`` cannot be modified\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.set_group_template\n        if self.get_ignored_for_calculations_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_boolean(ignore):\n            raise errors.InvalidArgument()\n        self._my_map['ignoredForCalculations'] = ignore"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the ignore for calculations flag.", "response": "def clear_ignored_for_calculations(self):\n        \"\"\"Clears the ignore for calculations flag.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.clear_group_template\n        if (self.get_ignored_for_calculations_metadata().is_read_only() or\n                self.get_ignored_for_calculations_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['ignoredForCalculations'] = self._ignored_for_calculations_default"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the metadata for a grade.", "response": "def get_grade_metadata(self):\n        \"\"\"Gets the metadata for a grade.\n\n        return: (osid.Metadata) - metadata for the grade\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['grade'])\n        metadata.update({'existing_id_values': self._my_map['gradeId']})\n        return Metadata(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the grade. arg: grade_id (osid.id.Id): the new grade raise: InvalidArgument - ``grade_id`` is invalid or ``GradebookColumn.getGradeSystem().isBasedOnGrades()`` is ``false`` raise: NoAccess - ``grade_id`` cannot be modified raise: NullArgument - ``grade_id`` is ``null`` *compliance: mandatory -- This method must be implemented.*", "response": "def set_grade(self, grade_id):\n        \"\"\"Sets the grade.\n\n        arg:    grade_id (osid.id.Id): the new grade\n        raise:  InvalidArgument - ``grade_id`` is invalid or\n                ``GradebookColumn.getGradeSystem().isBasedOnGrades()``\n                is ``false``\n        raise:  NoAccess - ``grade_id`` cannot be modified\n        raise:  NullArgument - ``grade_id`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not self._grade_system.is_based_on_grades():\n            raise errors.InvalidArgument()\n        if self.get_grade_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_id(grade_id):\n            raise errors.InvalidArgument()\n        if not self._is_in_set(grade_id, self.get_grade_metadata()):\n            raise errors.InvalidArgument('Grade ID not in the acceptable set.')\n        self._my_map['gradeId'] = str(grade_id)\n        self._my_map['gradingAgentId'] = str(self._effective_agent_id)\n        self._my_map['timeGraded'] = DateTime.utcnow()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears the grade. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_grade(self):\n        \"\"\"Clears the grade.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if not self._grade_system.is_based_on_grades():\n            return  # do nothing, spec does not raise error\n        if (self.get_grade_metadata().is_read_only() or\n                self.get_grade_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['gradeId'] = self._grade_default\n        self._my_map['gradingAgentId'] = ''\n        self._my_map['timeGraded'] = None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_score_metadata(self):\n        # Implemented from template for osid.resource.ResourceForm.get_group_metadata_template\n        metadata = dict(self._mdata['score'])\n        metadata.update({'existing_decimal_values': self._my_map['score']})\n        return Metadata(**metadata)", "response": "Gets the metadata for a score."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_score(self, score):\n        if self._grade_system.is_based_on_grades():\n            raise errors.InvalidArgument()\n        if self.get_score_metadata().is_read_only():\n            raise errors.NoAccess()\n        if not self._is_valid_decimal(score, self.get_score_metadata()):\n            raise errors.InvalidArgument()\n        if not isinstance(score, Decimal):\n            score = Decimal(str(score))\n        if (self._grade_system.get_numeric_score_increment() and\n                score % self._grade_system.get_numeric_score_increment() != 0):\n            raise errors.InvalidArgument('score must be in increments of ' + str(self._score_increment))\n        self._my_map['score'] = float(score)\n        self._my_map['gradingAgentId'] = str(self._effective_agent_id)\n        self._my_map['timeGraded'] = DateTime.utcnow()", "response": "Sets the score.\n\n        arg:    score (decimal): the new score\n        raise:  InvalidArgument - ``score`` is invalid or\n                ``GradebookColumn.getGradeSystem().isBasedOnGrades()``\n                is ``true``\n        raise:  NoAccess - ``score`` cannot be modified\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the score. raise: NoAccess - ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true`` *compliance: mandatory -- This method must be implemented.*", "response": "def clear_score(self):\n        \"\"\"Clears the score.\n\n        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._grade_system.is_based_on_grades():\n            return  # do nothing, spec does not raise error\n        if (self.get_score_metadata().is_read_only() or\n                self.get_score_metadata().is_required()):\n            raise errors.NoAccess()\n        self._my_map['score'] = self._score_default\n        self._my_map['gradingAgentId'] = ''\n        self._my_map['timeGraded'] = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nignores entries flagged with ignoreForCalculation", "response": "def _get_entries_for_calculation(self):\n        \"\"\"Ignores entries flagged with ignoreForCalculation\"\"\"\n        mgr = self._get_provider_manager('Grading')  # what about the Proxy?\n        if not mgr.supports_gradebook_column_lookup():\n            raise errors.OperationFailed('Grading does not support GradebookColumn lookup')\n        gradebook_id = Id(self._my_map['assignedGradebookIds'][0])\n        lookup_session = mgr.get_grade_entry_lookup_session_for_gradebook(gradebook_id,\n                                                                          proxy=getattr(self, \"_proxy\", None))\n        entries = lookup_session.get_grade_entries_for_gradebook_column(self.get_gradebook_column_id())\n        return [e for e in entries if not e.is_ignored_for_calculations()]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake entries from self. _entries and returns a list of scores ( or output scores if based on grades", "response": "def _get_entry_scores(self):\n        \"\"\"Takes entries from self._entries and returns a list of scores (or\n        output scores, if based on grades)\"\"\"\n        if self.get_gradebook_column().get_grade_system().is_based_on_grades():\n            return [e.get_grade().get_output_score() for e in self._entries if e.is_graded()]\n        else:\n            return [e.get_score() for e in self._entries if e.is_graded()]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the mode of the score.", "response": "def get_mode(self):\n        \"\"\"Gets the mode of the score.\n\n        If this system is based on grades, the mode of the output score\n        is returned.\n\n        return: (decimal) - the median score\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # http://stackoverflow.com/questions/10797819/finding-the-mode-of-a-list-in-python\n        return max(set(self._entry_scores), key=self._entry_scores.count)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the root mean square of the score.", "response": "def get_rms(self):\n        \"\"\"Gets the root mean square of the score.\n\n        If this system is based on grades, the RMS of the output score\n        is returned.\n\n        return: (decimal) - the median score\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        return np.sqrt(np.mean(np.square(self._entry_scores)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the gradebook at this node.", "response": "def get_gradebook(self):\n        \"\"\"Gets the ``Gradebook`` at this node.\n\n        return: (osid.grading.Gradebook) - the gradebook represented by\n                this node\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self._lookup_session is None:\n            mgr = get_provider_manager('GRADING', runtime=self._runtime, proxy=self._proxy)\n            self._lookup_session = mgr.get_gradebook_lookup_session(proxy=getattr(self, \"_proxy\", None))\n        return self._lookup_session.get_gradebook(Id(self._my_map['id']))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_parent_gradebook_nodes(self):\n        parent_gradebook_nodes = []\n        for node in self._my_map['parentNodes']:\n            parent_gradebook_nodes.append(GradebookNode(\n                node._my_map,\n                runtime=self._runtime,\n                proxy=self._proxy,\n                lookup_session=self._lookup_session))\n        return GradebookNodeList(parent_gradebook_nodes)", "response": "Gets the parents of this gradebook."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_filter(filter_cls):\n    if filter_cls.name is None:\n        return\n    elif filter_cls.name in FILTER_REGISTRY:\n        raise RuntimeError(\n            \"Filter class already registered: {}\".format(filter_cls.name))\n    else:\n        FILTER_REGISTRY[filter_cls.name] = filter_cls", "response": "Register a filter class in the registry."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a filter from a string or an existing filter.", "response": "def build_filter(filter_or_string, *args, **kwargs):\n    \"\"\"\n    Overloaded filter construction. If ``filter_or_string`` is a string\n    we look up it's corresponding class in the filter registry and return it.\n    Otherwise, assume ``filter_or_string`` is an instance of a filter.\n\n    :return: :class:`~es_fluent.filters.Filter`\n    \"\"\"\n    if isinstance(filter_or_string, basestring):\n        # Names that start with `~` indicate a negated filter.\n        if filter_or_string.startswith('~'):\n            filter_name = filter_or_string[1:]\n            return ~FILTER_REGISTRY[filter_name](*args, **kwargs)\n        else:\n            filter_name = filter_or_string\n            return FILTER_REGISTRY[filter_name](*args, **kwargs)\n    else:\n        return filter_or_string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Options(**kwargs):\n     construct = GPDOptions #IMPORTANT!  Set this\n     names = construct._fields\n     d = {}\n     for name in names: d[name] = None #default values\n     for k,v in kwargs.iteritems():\n       if k in names: d[k] = v\n       else: raise ValueError('Error '+k+' is not a property of these options')\n     \"\"\"Create a set of options based on the inputs\"\"\"\n     return construct(**d)", "response": "A method for declaring options for the class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the Asset specified by its Id.", "response": "def get_asset(self, asset_id):\n        \"\"\"Gets the ``Asset`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Asset`` may have a different\n        ``Id`` than requested, such as the case where a duplicate ``Id``\n        was assigned to an ``Asset`` and retained for compatibility.\n\n        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset`` to\n                retrieve\n        return: (osid.repository.Asset) - the returned ``Asset``\n        raise:  NotFound - no ``Asset`` found with the given ``Id``\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(asset_id, 'repository').get_identifier())},\n                 **self._view_filter()))\n        return objects.Asset(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting an AssetList corresponding to the given IdList.", "response": "def get_assets_by_ids(self, asset_ids):\n        \"\"\"Gets an ``AssetList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the assets\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Assets`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set.\n\n        arg:    asset_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n        return: (osid.repository.AssetList) - the returned ``Asset\n                list``\n        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``asset_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in asset_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'repository').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.AssetList(sorted_result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget an AssetList corresponding to the given asset genus Type which does not include assets of types derived from the specified Type.", "response": "def get_assets_by_genus_type(self, asset_genus_type):\n        \"\"\"Gets an ``AssetList`` corresponding to the given asset genus ``Type`` which does not include assets of types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session.\n\n        arg:    asset_genus_type (osid.type.Type): an asset genus type\n        return: (osid.repository.AssetList) - the returned ``Asset\n                list``\n        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(asset_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.AssetList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all Assets in the current session.", "response": "def get_assets(self):\n        \"\"\"Gets all ``Assets``.\n\n        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session.\n\n        return: (osid.repository.AssetList) - a list of ``Assets``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.AssetList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_asset_content(self, asset_content_id):\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        asset_content_identifier = ObjectId(self._get_id(asset_content_id, 'repository').get_identifier())\n        result = collection.find_one(\n            dict({'assetContents._id': {'$in': [asset_content_identifier]}},\n                 **self._view_filter()))\n        # if a match is not found, NotFound exception will be thrown by find_one, so\n        # the below should always work\n        asset_content_map = [ac for ac in result['assetContents'] if ac['_id'] == asset_content_identifier][0]\n        return objects.AssetContent(osid_object_map=asset_content_map, runtime=self._runtime, proxy=self._proxy)", "response": "Gets the AssetContent specified by its Id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_asset_contents_by_ids(self, asset_content_ids):\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        object_id_list = [ObjectId(self._get_id(i, 'repository').get_identifier()) for i in asset_content_ids]\n\n        results = collection.find(\n            dict({'assetContents._id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        # if a match is not found, NotFound exception will be thrown by find_one, so\n        # the below should always work\n        asset_content_maps = [ac\n                              for asset in results\n                              for ac in asset['assetContents']\n                              for object_id in object_id_list\n                              if ac['_id'] == object_id]\n        return objects.AssetContentList(asset_content_maps, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an asset list corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_asset_contents_by_genus_type(self, asset_content_genus_type):\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        results = collection.find(\n            dict({'assetContents.genusTypeId': {'$in': [str(asset_content_genus_type)]}},\n                 **self._view_filter()))\n        # if a match is not found, NotFound exception will be thrown by find_one, so\n        # the below should always work\n        asset_content_maps = [ac\n                              for asset in results\n                              for ac in asset['assetContents']\n                              if ac['genusTypeId'] == str(asset_content_genus_type)]\n        return objects.AssetContentList(asset_content_maps, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an asset content list corresponding to the given asset content genus Type which does not include asset contents of types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_asset_contents_for_asset(self, asset_id):\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(asset_id, 'repository').get_identifier())},\n                 **self._view_filter()))\n        asset_content_maps = [ac for ac in result['assetContents']]\n        return objects.AssetContentList(asset_content_maps, runtime=self._runtime, proxy=self._proxy)", "response": "Gets an AssetList for the given asset."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_assets_by_query(self, asset_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in asset_query._query_terms:\n            if '$in' in asset_query._query_terms[term] and '$nin' in asset_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': asset_query._query_terms[term]['$in']}},\n                             {term: {'$nin': asset_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: asset_query._query_terms[term]})\n        for term in asset_query._keyword_terms:\n            or_list.append({term: asset_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('repository',\n                                             collection='Asset',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.AssetList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of Assets matching the given asset query."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assets_by_search(self, asset_query, asset_search):\n        # Implemented from template for\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        # Copied from osid.resource.ResourceQuerySession.get_resources_by_query_template\n        and_list = list()\n        or_list = list()\n        for term in asset_query._query_terms:\n            and_list.append({term: asset_query._query_terms[term]})\n        for term in asset_query._keyword_terms:\n            or_list.append({term: asset_query._keyword_terms[term]})\n        if asset_search._id_list is not None:\n            identifiers = [ObjectId(i.identifier) for i in asset_search._id_list]\n            and_list.append({'_id': {'$in': identifiers}})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        if asset_search.start is not None and asset_search.end is not None:\n            result = collection.find(query_terms)[asset_search.start:asset_search.end]\n        else:\n            result = collection.find(query_terms)\n        return searches.AssetSearchResults(result, dict(asset_query._query_terms), runtime=self._runtime)", "response": "Gets the search results matching the given search query."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_asset_form_for_create(self, asset_record_types):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in asset_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if asset_record_types == []:\n            obj_form = objects.AssetForm(\n                repository_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.AssetForm(\n                repository_id=self._catalog_id,\n                record_types=asset_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the asset form for creating new assets."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_asset(self, asset_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        if not isinstance(asset_form, ABCAssetForm):\n            raise errors.InvalidArgument('argument type is not an AssetForm')\n        if asset_form.is_for_update():\n            raise errors.InvalidArgument('the AssetForm is for update only, not create')\n        try:\n            if self._forms[asset_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('asset_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('asset_form did not originate from this session')\n        if not asset_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(asset_form._my_map)\n\n        self._forms[asset_form.get_id().get_identifier()] = CREATED\n        result = objects.Asset(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new Asset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate an existing asset.", "response": "def update_asset(self, asset_form):\n        \"\"\"Updates an existing asset.\n\n        arg:    asset_form (osid.repository.AssetForm): the form\n                containing the elements to be updated\n        raise:  IllegalState - ``asset_form`` already used in anupdate\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``asset_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_form`` did not originate from\n                ``get_asset_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        if not isinstance(asset_form, ABCAssetForm):\n            raise errors.InvalidArgument('argument type is not an AssetForm')\n        if not asset_form.is_for_update():\n            raise errors.InvalidArgument('the AssetForm is for update only, not create')\n        try:\n            if self._forms[asset_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('asset_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('asset_form did not originate from this session')\n        if not asset_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(asset_form._my_map)\n\n        self._forms[asset_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Asset(\n            osid_object_map=asset_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_asset(self, asset_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        if not isinstance(asset_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        asset_map = collection.find_one(\n            dict({'_id': ObjectId(asset_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.Asset(osid_object_map=asset_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(asset_id.get_identifier())})", "response": "Deletes an ``Asset``.\n\n        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset`` to\n                remove\n        raise:  NotFound - ``asset_id`` not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef alias_asset(self, asset_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=asset_id, equivalent_id=alias_id)", "response": "Adds an Id to an Asset for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting an asset content form for creating new assets.", "response": "def get_asset_content_form_for_create(self, asset_id, asset_content_record_types):\n        \"\"\"Gets an asset content form for creating new assets.\n\n        arg:    asset_id (osid.id.Id): the ``Id`` of an ``Asset``\n        arg:    asset_content_record_types (osid.type.Type[]): array of\n                asset content record types\n        return: (osid.repository.AssetContentForm) - the asset content\n                form\n        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` or\n                ``asset_content_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.learning.ActivityAdminSession.get_activity_form_for_create_template\n\n        if not isinstance(asset_id, ABCId):\n            raise errors.InvalidArgument('argument is not a valid OSID Id')\n        for arg in asset_content_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if asset_content_record_types == []:\n            # WHY are we passing repository_id = self._catalog_id below, seems redundant:\n            obj_form = objects.AssetContentForm(\n                repository_id=self._catalog_id,\n                asset_id=asset_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        else:\n            obj_form = objects.AssetContentForm(\n                repository_id=self._catalog_id,\n                record_types=asset_content_record_types,\n                asset_id=asset_id,\n                catalog_id=self._catalog_id,\n                runtime=self._runtime,\n                proxy=self._proxy)\n        obj_form._for_update = False\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new asset content for a given asset.", "response": "def create_asset_content(self, asset_content_form):\n        \"\"\"Creates new ``AssetContent`` for a given asset.\n\n        arg:    asset_content_form (osid.repository.AssetContentForm):\n                the form for this ``AssetContent``\n        return: (osid.repository.AssetContent) - the new\n                ``AssetContent``\n        raise:  IllegalState - ``asset_content_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``asset_content_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_content_form`` did not originate\n                from ``get_asset_content_form_for_create()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.create_asset_content_template\n        from dlkit.abstract_osid.repository.objects import AssetContentForm as ABCAssetContentForm\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        if not isinstance(asset_content_form, ABCAssetContentForm):\n            raise errors.InvalidArgument('argument type is not an AssetContentForm')\n        if asset_content_form.is_for_update():\n            raise errors.InvalidArgument('the AssetContentForm is for update only, not create')\n        try:\n            if self._forms[asset_content_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('asset_content_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('asset_content_form did not originate from this session')\n        if not asset_content_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        asset_content_form._my_map['_id'] = ObjectId()\n        asset_id = Id(asset_content_form._my_map['assetId']).get_identifier()\n        asset = collection.find_one(\n            {'$and': [{'_id': ObjectId(asset_id)},\n                      {'assigned' + self._catalog_name + 'Ids': {'$in': [str(self._catalog_id)]}}]})\n        asset['assetContents'].append(asset_content_form._my_map)\n        result = collection.save(asset)\n\n        self._forms[asset_content_form.get_id().get_identifier()] = CREATED\n        from .objects import AssetContent\n        return AssetContent(\n            osid_object_map=asset_content_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_asset_content_form_for_update(self, asset_content_id):\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.get_asset_content_form_for_update_template\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        from .objects import AssetContentForm\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        if not isinstance(asset_content_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        document = collection.find_one({'assetContents._id': ObjectId(asset_content_id.get_identifier())})\n        for sub_doc in document['assetContents']:  # There may be a MongoDB shortcut for this\n            if sub_doc['_id'] == ObjectId(asset_content_id.get_identifier()):\n                result = sub_doc\n        obj_form = AssetContentForm(\n            osid_object_map=result,\n            runtime=self._runtime,\n            proxy=self._proxy)\n        obj_form._for_update = True\n        self._forms[obj_form.get_id().get_identifier()] = not UPDATED\n        return obj_form", "response": "Gets the asset content form for updating an existing asset content."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate an existing asset content.", "response": "def update_asset_content(self, asset_content_form):\n        \"\"\"Updates an existing asset content.\n\n        arg:    asset_content_form (osid.repository.AssetContentForm):\n                the form containing the elements to be updated\n        raise:  IllegalState - ``asset_content_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``asset_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_content_form`` did not originate\n                from ``get_asset_content_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.update_asset_content_template\n        from dlkit.abstract_osid.repository.objects import AssetContentForm as ABCAssetContentForm\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        if not isinstance(asset_content_form, ABCAssetContentForm):\n            raise errors.InvalidArgument('argument type is not an AssetContentForm')\n        if not asset_content_form.is_for_update():\n            raise errors.InvalidArgument('the AssetContentForm is for update only, not create')\n        try:\n            if self._forms[asset_content_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('asset_content_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('asset_content_form did not originate from this session')\n        if not asset_content_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        asset_id = Id(asset_content_form._my_map['assetId']).get_identifier()\n        asset = collection.find_one(\n            {'$and': [{'_id': ObjectId(asset_id)},\n                      {'assigned' + self._catalog_name + 'Ids': {'$in': [str(self._catalog_id)]}}]})\n        index = 0\n        found = False\n        for i in asset['assetContents']:\n            if i['_id'] == ObjectId(asset_content_form._my_map['_id']):\n                asset['assetContents'].pop(index)\n                asset['assetContents'].insert(index, asset_content_form._my_map)\n                found = True\n                break\n            index += 1\n        if not found:\n            raise errors.NotFound()\n        try:\n            collection.save(asset)\n        except:  # what exceptions does mongodb save raise?\n            raise errors.OperationFailed()\n        self._forms[asset_content_form.get_id().get_identifier()] = UPDATED\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        from .objects import AssetContent\n\n        return AssetContent(\n            osid_object_map=asset_content_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting an asset content from an Asset.", "response": "def delete_asset_content(self, asset_content_id):\n        \"\"\"Deletes content from an ``Asset``.\n\n        arg:    asset_content_id (osid.id.Id): the ``Id`` of the\n                ``AssetContent``\n        raise:  NotFound - ``asset_content_id`` is not found\n        raise:  NullArgument - ``asset_content_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetAdminSession.delete_asset_content_template\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        from .objects import AssetContent\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        if not isinstance(asset_content_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        asset = collection.find_one({'assetContents._id': ObjectId(asset_content_id.get_identifier())})\n\n        index = 0\n        found = False\n        for i in asset['assetContents']:\n            if i['_id'] == ObjectId(asset_content_id.get_identifier()):\n                asset_content_map = asset['assetContents'].pop(index)\n            index += 1\n            found = True\n        if not found:\n            raise errors.OperationFailed()\n        AssetContent(\n            osid_object_map=asset_content_map,\n            runtime=self._runtime,\n            proxy=self._proxy)._delete()\n        collection.save(asset)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_asset_id_with_enclosure(self, enclosure_id):\n        mgr = self._get_provider_manager('REPOSITORY')\n        query_session = mgr.get_asset_query_session_for_repository(self._catalog_id, proxy=self._proxy)\n        query_form = query_session.get_asset_query()\n        query_form.match_enclosed_object_id(enclosure_id)\n        query_result = query_session.get_assets_by_query(query_form)\n        if query_result.available() > 0:\n            asset_id = query_result.next().get_id()\n        else:\n            create_form = self.get_asset_form_for_create([ENCLOSURE_RECORD_TYPE])\n            create_form.set_enclosed_object(enclosure_id)\n            asset_id = self.create_asset(create_form).get_id()\n        return asset_id", "response": "Create an Asset with an enclosed foreign object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering for notification of new assets of the given asset genus type.", "response": "def register_for_new_assets_by_genus_type(self, asset_genus_type):\n        \"\"\"Registers for notification of new assets of the given asset genus type.\n\n        ``AssetReceiver.newAssets()`` is invoked when an asset is\n        appears in this repository.\n\n        arg:    asset_genus_type (osid.type.Type): the genus type of the\n                ``Asset`` to monitor\n        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceNotificationSession.register_for_changed_resource\n        if not MONGO_LISTENER.receivers[self._ns][self._receiver]['u']:\n            MONGO_LISTENER.receivers[self._ns][self._receiver]['u'] = []\n        if isinstance(MONGO_LISTENER.receivers[self._ns][self._receiver]['u'], list):\n            MONGO_LISTENER.receivers[self._ns][self._receiver]['u'].append(asset_genus_type.get_identifier())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_for_deleted_asset(self, asset_id):\n        # Implemented from template for\n        # osid.resource.ResourceNotificationSession.register_for_deleted_resource\n        if not MONGO_LISTENER.receivers[self._ns][self._receiver]['d']:\n            MONGO_LISTENER.receivers[self._ns][self._receiver]['d'] = []\n        if isinstance(MONGO_LISTENER.receivers[self._ns][self._receiver]['d'], list):\n            MONGO_LISTENER.receivers[self._ns][self._receiver]['d'].append(asset_id.get_identifier())", "response": "Registers for notification of a deleted asset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the list of Asset Id s associated with a Repository.", "response": "def get_asset_ids_by_repository(self, repository_id):\n        \"\"\"Gets the list of ``Asset``  ``Ids`` associated with a ``Repository``.\n\n        arg:    repository_id (osid.id.Id): ``Id`` of the ``Repository``\n        return: (osid.id.IdList) - list of related asset ``Ids``\n        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for asset in self.get_assets_by_repository(repository_id):\n            id_list.append(asset.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assets_by_repository(self, repository_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_asset_lookup_session_for_repository(repository_id, proxy=self._proxy)\n        lookup_session.use_isolated_repository_view()\n        return lookup_session.get_assets()", "response": "Gets the list of Assets associated with a Repository."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_asset_ids_by_repositories(self, repository_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for asset in self.get_assets_by_repositories(repository_ids):\n            id_list.append(asset.get_id())\n        return IdList(id_list)", "response": "Gets the list of Asset Ids corresponding to a list of Repositories."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the list of Assets corresponding to a list of Repositories.", "response": "def get_assets_by_repositories(self, repository_ids):\n        \"\"\"Gets the list of ``Assets`` corresponding to a list of ``Repository`` objects.\n\n        arg:    repository_ids (osid.id.IdList): list of repository\n                ``Ids``\n        return: (osid.repository.AssetList) - list of assets\n        raise:  NullArgument - ``repository_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        asset_list = []\n        for repository_id in repository_ids:\n            asset_list += list(\n                self.get_assets_by_repository(repository_id))\n        return objects.AssetList(asset_list)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the list of Repository Ids mapped to an Asset.", "response": "def get_repository_ids_by_asset(self, asset_id):\n        \"\"\"Gets the list of ``Repository``  ``Ids`` mapped to an ``Asset``.\n\n        arg:    asset_id (osid.id.Id): ``Id`` of an ``Asset``\n        return: (osid.id.IdList) - list of repository ``Ids``\n        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bin_ids_by_resource\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_asset_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_repository_view()\n        asset = lookup_session.get_asset(asset_id)\n        id_list = []\n        for idstr in asset._my_map['assignedRepositoryIds']:\n            id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the list of Repositories mapped to an Asset.", "response": "def get_repositories_by_asset(self, asset_id):\n        \"\"\"Gets the list of ``Repository`` objects mapped to an ``Asset``.\n\n        arg:    asset_id (osid.id.Id): ``Id`` of an ``Asset``\n        return: (osid.repository.RepositoryList) - list of repositories\n        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_repository_lookup_session(proxy=self._proxy)\n        return lookup_session.get_repositories_by_ids(\n            self.get_repository_ids_by_asset(asset_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_assignable_repository_ids(self, repository_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.get_assignable_bin_ids\n        # This will likely be overridden by an authorization adapter\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_repository_lookup_session(proxy=self._proxy)\n        repositories = lookup_session.get_repositories()\n        id_list = []\n        for repository in repositories:\n            id_list.append(repository.get_id())\n        return IdList(id_list)", "response": "Gets a list of repositories including and under the given repository node in which any asset can be assigned."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef assign_asset_to_repository(self, asset_id, repository_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_repository_lookup_session(proxy=self._proxy)\n        lookup_session.get_repository(repository_id)  # to raise NotFound\n        self._assign_object_to_catalog(asset_id, repository_id)", "response": "Adds an existing Asset to a Repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves an Asset from a Repository.", "response": "def unassign_asset_from_repository(self, asset_id, repository_id):\n        \"\"\"Removes an ``Asset`` from a ``Repository``.\n\n        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset``\n        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        raise:  NotFound - ``asset_id`` or ``repository_id`` not found\n                or ``asset_id`` not assigned to ``repository_id``\n        raise:  NullArgument - ``asset_id`` or ``repository_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_repository_lookup_session(proxy=self._proxy)\n        lookup_session.get_repository(repository_id)  # to raise NotFound\n        self._unassign_object_from_catalog(asset_id, repository_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the list of assets mapped to the given Composition.", "response": "def get_composition_assets(self, composition_id):\n        \"\"\"Gets the list of assets mapped to the given ``Composition``.\n\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n        return: (osid.repository.AssetList) - list of assets\n        raise:  NotFound - ``composition_id`` not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetCompositionSession.get_composition_assets\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        composition = collection.find_one(\n            dict({'_id': ObjectId(composition_id.get_identifier())},\n                 **self._view_filter()))\n        if 'assetIds' not in composition:\n            raise errors.NotFound('no Assets are assigned to this Composition')\n        asset_ids = []\n        for idstr in composition['assetIds']:\n            asset_ids.append(Id(idstr))\n        mgr = self._get_provider_manager('REPOSITORY')\n        lookup_session = mgr.get_asset_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_repository_view()\n        return lookup_session.get_assets_by_ids(asset_ids)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a list of compositions including the given asset.", "response": "def get_compositions_by_asset(self, asset_id):\n        \"\"\"Gets a list of compositions including the given asset.\n\n        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        return: (osid.repository.CompositionList) - the returned\n                ``Composition list``\n        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.repository.AssetCompositionSession.get_compositions_by_asset\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'assetIds': {'$in': [str(asset_id)]}},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.CompositionList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an asset to a composition.", "response": "def add_asset(self, asset_id, composition_id):\n        \"\"\"Appends an asset to a composition.\n\n        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n        raise:  AlreadyExists - ``asset_id`` already part\n                ``composition_id``\n        raise:  NotFound - ``asset_id`` or ``composition_id`` not found\n        raise:  NullArgument - ``asset_id`` or ``composition_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # The asset found check may want to be run through _get_provider_manager\n        # so as to ensure access control:\n        from dlkit.abstract_osid.id.primitives import Id as ABCId\n        if not isinstance(asset_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        if (not isinstance(composition_id, ABCId) and\n                composition_id.get_identifier_namespace() != 'repository.Composition'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        if asset_id.get_identifier_namespace() != 'repository.Asset':\n            if asset_id.get_authority() != self._authority:\n                raise errors.InvalidArgument()\n            else:\n                mgr = self._get_provider_manager('REPOSITORY')\n                admin_session = mgr.get_asset_admin_session_for_repository(self._catalog_id, proxy=self._proxy)\n                asset_id = admin_session._get_asset_id_with_enclosure(asset_id)\n        collection = JSONClientValidated('repository',\n                                         collection='Asset',\n                                         runtime=self._runtime)\n        asset = collection.find_one({'_id': ObjectId(asset_id.get_identifier())})\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        composition = collection.find_one({'_id': ObjectId(composition_id.get_identifier())})\n        if 'assetIds' in composition:\n            if str(asset_id) not in composition['assetIds']:\n                composition['assetIds'].append(str(asset_id))\n        else:\n            composition['assetIds'] = [str(asset_id)]\n        collection.save(composition)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves the specified asset in front of a reference asset.", "response": "def move_asset_ahead(self, asset_id, composition_id, reference_id):\n        \"\"\"Reorders assets in a composition by moving the specified asset in front of a reference asset.\n\n        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n        arg:    reference_id (osid.id.Id): ``Id`` of the reference\n                ``Asset``\n        raise:  NotFound - ``asset_id`` or ``reference_id``  ``not found\n                in composition_id``\n        raise:  NullArgument - ``asset_id, reference_id`` or\n                ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (not isinstance(composition_id, ABCId) and\n                composition_id.get_identifier_namespace() != 'repository.Composition'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        composition_map, collection = self._get_composition_collection(composition_id)\n        composition_map['assetIds'] = move_id_ahead(asset_id, reference_id, composition_map['assetIds'])\n        collection.save(composition_map)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef move_asset_behind(self, asset_id, composition_id, reference_id):\n        if (not isinstance(composition_id, ABCId) and\n                composition_id.get_identifier_namespace() != 'repository.Composition'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        composition_map, collection = self._get_composition_collection(composition_id)\n        composition_map['assetIds'] = move_id_behind(asset_id, reference_id, composition_map['assetIds'])\n        collection.save(composition_map)", "response": "Moves the specified asset behind of a reference asset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreorder a set of assets in a composition.", "response": "def order_assets(self, asset_ids, composition_id):\n        \"\"\"Reorders a set of assets in a composition.\n\n        arg:    asset_ids (osid.id.Id[]): ``Ids`` for a set of\n                ``Assets``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n        raise:  NotFound - ``composition_id`` not found or, an\n                ``asset_id`` not related to ``composition_id``\n        raise:  NullArgument - ``instruction_ids`` or ``agenda_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (not isinstance(composition_id, ABCId) and\n                composition_id.get_identifier_namespace() != 'repository.Composition'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        composition_map, collection = self._get_composition_collection(composition_id)\n        composition_map['assetIds'] = order_ids(asset_ids, composition_map['assetIds'])\n        collection.save(composition_map)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove an Asset from a Composition.", "response": "def remove_asset(self, asset_id, composition_id):\n        \"\"\"Removes an ``Asset`` from a ``Composition``.\n\n        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n        raise:  NotFound - ``asset_id``  ``not found in composition_id``\n        raise:  NullArgument - ``asset_id`` or ``composition_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if (not isinstance(composition_id, ABCId) and\n                composition_id.get_identifier_namespace() != 'repository.Composition'):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        composition_map, collection = self._get_composition_collection(composition_id)\n        try:\n            composition_map['assetIds'].remove(str(asset_id))\n        except (KeyError, ValueError):\n            raise errors.NotFound()\n        collection.save(composition_map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_composition_collection(self, composition_id):\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        composition_map = collection.find_one({'_id': ObjectId(composition_id.get_identifier())})\n        if 'assetIds' not in composition_map:\n            raise errors.NotFound('no Assets are assigned to this Composition')\n        return composition_map, collection", "response": "Returns a Mongo Collection and Composition given a Composition Id"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the Composition specified by its Id.", "response": "def get_composition(self, composition_id):\n        \"\"\"Gets the ``Composition`` specified by its ``Id``.\n\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composiiton``\n        return: (osid.repository.Composition) - the composition\n        raise:  NotFound - ``composition_id`` not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resource\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        result = collection.find_one(\n            dict({'_id': ObjectId(self._get_id(composition_id, 'repository').get_identifier())},\n                 **self._view_filter()))\n        return objects.Composition(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_compositions_by_ids(self, composition_ids):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_ids\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        object_id_list = []\n        for i in composition_ids:\n            object_id_list.append(ObjectId(self._get_id(i, 'repository').get_identifier()))\n        result = collection.find(\n            dict({'_id': {'$in': object_id_list}},\n                 **self._view_filter()))\n        result = list(result)\n        sorted_result = []\n        for object_id in object_id_list:\n            for object_map in result:\n                if object_map['_id'] == object_id:\n                    sorted_result.append(object_map)\n                    break\n        return objects.CompositionList(sorted_result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a CompositionList corresponding to the given IdList."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_compositions_by_genus_type(self, composition_genus_type):\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources_by_genus_type\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        result = collection.find(\n            dict({'genusTypeId': str(composition_genus_type)},\n                 **self._view_filter())).sort('_id', DESCENDING)\n        return objects.CompositionList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a CompositionList corresponding to the given composition genus Type which does not include compositions of types derived from the specified Type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all Compositions in this repository.", "response": "def get_compositions(self):\n        \"\"\"Gets all ``Compositions``.\n\n        return: (osid.repository.CompositionList) - a list of\n                ``Compositions``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceLookupSession.get_resources\n        # NOTE: This implementation currently ignores plenary view\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        result = collection.find(self._view_filter()).sort('_id', DESCENDING)\n        return objects.CompositionList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_compositions_by_query(self, composition_query):\n        # Implemented from template for\n        # osid.resource.ResourceQuerySession.get_resources_by_query\n        and_list = list()\n        or_list = list()\n        for term in composition_query._query_terms:\n            if '$in' in composition_query._query_terms[term] and '$nin' in composition_query._query_terms[term]:\n                and_list.append(\n                    {'$or': [{term: {'$in': composition_query._query_terms[term]['$in']}},\n                             {term: {'$nin': composition_query._query_terms[term]['$nin']}}]})\n            else:\n                and_list.append({term: composition_query._query_terms[term]})\n        for term in composition_query._keyword_terms:\n            or_list.append({term: composition_query._keyword_terms[term]})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n            collection = JSONClientValidated('repository',\n                                             collection='Composition',\n                                             runtime=self._runtime)\n            result = collection.find(query_terms).sort('_id', DESCENDING)\n        else:\n            result = []\n        return objects.CompositionList(result, runtime=self._runtime, proxy=self._proxy)", "response": "Gets a list of Compositions matching the given composition query."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the search results matching the given search query.", "response": "def get_compositions_by_search(self, composition_query, composition_search):\n        \"\"\"Gets the search results matching the given search query using the given search.\n\n        arg:    composition_query (osid.repository.CompositionQuery):\n                the composition query\n        arg:    composition_search (osid.repository.CompositionSearch):\n                the composition search\n        return: (osid.repository.CompositionSearchResults) - the\n                composition search results\n        raise:  NullArgument - ``composition_query`` or\n                ``composition_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``composition_query`` or\n                ``composition_search`` is not of this service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        # Copied from osid.resource.ResourceQuerySession.get_resources_by_query_template\n        and_list = list()\n        or_list = list()\n        for term in composition_query._query_terms:\n            and_list.append({term: composition_query._query_terms[term]})\n        for term in composition_query._keyword_terms:\n            or_list.append({term: composition_query._keyword_terms[term]})\n        if composition_search._id_list is not None:\n            identifiers = [ObjectId(i.identifier) for i in composition_search._id_list]\n            and_list.append({'_id': {'$in': identifiers}})\n        if or_list:\n            and_list.append({'$or': or_list})\n        view_filter = self._view_filter()\n        if view_filter:\n            and_list.append(view_filter)\n        if and_list:\n            query_terms = {'$and': and_list}\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        if composition_search.start is not None and composition_search.end is not None:\n            result = collection.find(query_terms)[composition_search.start:composition_search.end]\n        else:\n            result = collection.find(query_terms)\n        return searches.CompositionSearchResults(result, dict(composition_query._query_terms), runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_composition_form_for_create(self, composition_record_types):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.get_resource_form_for_create_template\n        for arg in composition_record_types:\n            if not isinstance(arg, ABCType):\n                raise errors.InvalidArgument('one or more argument array elements is not a valid OSID Type')\n        if composition_record_types == []:\n            obj_form = objects.CompositionForm(\n                repository_id=self._catalog_id,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        else:\n            obj_form = objects.CompositionForm(\n                repository_id=self._catalog_id,\n                record_types=composition_record_types,\n                runtime=self._runtime,\n                effective_agent_id=self.get_effective_agent_id(),\n                proxy=self._proxy)\n        self._forms[obj_form.get_id().get_identifier()] = not CREATED\n        return obj_form", "response": "Gets the composition form for creating new compositions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_composition(self, composiiton_form):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.create_resource_template\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        if not isinstance(composiiton_form, ABCCompositionForm):\n            raise errors.InvalidArgument('argument type is not an CompositionForm')\n        if composiiton_form.is_for_update():\n            raise errors.InvalidArgument('the CompositionForm is for update only, not create')\n        try:\n            if self._forms[composiiton_form.get_id().get_identifier()] == CREATED:\n                raise errors.IllegalState('composiiton_form already used in a create transaction')\n        except KeyError:\n            raise errors.Unsupported('composiiton_form did not originate from this session')\n        if not composiiton_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        insert_result = collection.insert_one(composiiton_form._my_map)\n\n        self._forms[composiiton_form.get_id().get_identifier()] = CREATED\n        result = objects.Composition(\n            osid_object_map=collection.find_one({'_id': insert_result.inserted_id}),\n            runtime=self._runtime,\n            proxy=self._proxy)\n\n        return result", "response": "Creates a new Composition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating an existing composition.", "response": "def update_composition(self, composiiton_form):\n        \"\"\"Updates an existing composition.\n\n        arg:    composiiton_form (osid.repository.CompositionForm): the\n                form containing the elements to be updated\n        raise:  IllegalState - ``composition_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``composition_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``composition_form`` did not originate\n                from ``get_composition_form_for_update()``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.update_resource_template\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        if not isinstance(composiiton_form, ABCCompositionForm):\n            raise errors.InvalidArgument('argument type is not an CompositionForm')\n        if not composiiton_form.is_for_update():\n            raise errors.InvalidArgument('the CompositionForm is for update only, not create')\n        try:\n            if self._forms[composiiton_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('composiiton_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('composiiton_form did not originate from this session')\n        if not composiiton_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(composiiton_form._my_map)\n\n        self._forms[composiiton_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned:\n        return objects.Composition(\n            osid_object_map=composiiton_form._my_map,\n            runtime=self._runtime,\n            proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_composition(self, composition_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.delete_resource_template\n        collection = JSONClientValidated('repository',\n                                         collection='Composition',\n                                         runtime=self._runtime)\n        if not isinstance(composition_id, ABCId):\n            raise errors.InvalidArgument('the argument is not a valid OSID Id')\n        composition_map = collection.find_one(\n            dict({'_id': ObjectId(composition_id.get_identifier())},\n                 **self._view_filter()))\n\n        objects.Composition(osid_object_map=composition_map, runtime=self._runtime, proxy=self._proxy)._delete()\n        collection.delete_one({'_id': ObjectId(composition_id.get_identifier())})", "response": "Deletes a ``Composition``.\n\n        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition`` to remove\n        raise:  NotFound - ``composition_id`` not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef alias_composition(self, composition_id, alias_id):\n        # Implemented from template for\n        # osid.resource.ResourceAdminSession.alias_resources_template\n        self._alias_id(primary_id=composition_id, equivalent_id=alias_id)", "response": "Adds an Id to a Composition for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_composition_ids_by_repository(self, repository_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bin\n        id_list = []\n        for composition in self.get_compositions_by_repository(repository_id):\n            id_list.append(composition.get_id())\n        return IdList(id_list)", "response": "Gets the list of Composition Ids associated with a Repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_compositions_by_repository(self, repository_id):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bin\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_composition_lookup_session_for_repository(repository_id, proxy=self._proxy)\n        lookup_session.use_isolated_repository_view()\n        return lookup_session.get_compositions()", "response": "Gets the list of Compositions associated with a Repository."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the list of Composition Ids corresponding to a list of Repositories.", "response": "def get_composition_ids_by_repositories(self, repository_ids):\n        \"\"\"Gets the list of ``Composition``  ``Ids`` corresponding to a list of ``Repository`` objects.\n\n        arg:    repository_ids (osid.id.IdList): list of repository\n                ``Ids``\n        return: (osid.id.IdList) - list of composition ``Ids``\n        raise:  NullArgument - ``repository_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resource_ids_by_bins\n        id_list = []\n        for composition in self.get_compositions_by_repositories(repository_ids):\n            id_list.append(composition.get_id())\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_compositions_by_repositories(self, repository_ids):\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_resources_by_bins\n        composition_list = []\n        for repository_id in repository_ids:\n            composition_list += list(\n                self.get_compositions_by_repository(repository_id))\n        return objects.CompositionList(composition_list)", "response": "Gets the list of Compositions corresponding to a list of Repositories."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the list of repository Ids mapped to a Composition.", "response": "def get_repository_ids_by_composition(self, composition_id):\n        \"\"\"Gets the ``Repository``  ``Ids`` mapped to a ``Composition``.\n\n        arg:    composition_id (osid.id.Id): ``Id`` of a ``Composition``\n        return: (osid.id.IdList) - list of repository ``Ids``\n        raise:  NotFound - ``composition_id`` is not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_composition_lookup_session(proxy=self._proxy)\n        lookup_session.use_federated_repository_view()\n        lookup_session.use_unsequestered_composition_view()\n        composition = lookup_session.get_composition(composition_id)\n        id_list = []\n        if 'assignedRepositoryIds' in composition._my_map:\n            for idstr in composition._my_map['assignedRepositoryIds']:\n                id_list.append(Id(idstr))\n        return IdList(id_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the list of Repositories mapped to a Composition.", "response": "def get_repositories_by_composition(self, composition_id):\n        \"\"\"Gets the ``Repository`` objects mapped to a ``Composition``.\n\n        arg:    composition_id (osid.id.Id): ``Id`` of a ``Composition``\n        return: (osid.repository.RepositoryList) - list of repositories\n        raise:  NotFound - ``composition_id`` is not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinSession.get_bins_by_resource\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_repository_lookup_session(proxy=self._proxy)\n        return lookup_session.get_repositories_by_ids(\n            self.get_repository_ids_by_composition(composition_id))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding an existing Composition to a Repository.", "response": "def assign_composition_to_repository(self, composition_id, repository_id):\n        \"\"\"Adds an existing ``Composition`` to a ``Repository``.\n\n        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        raise:  AlreadyExists - ``composition_id`` already assigned to\n                ``repository_id``\n        raise:  NotFound - ``composition_id`` or ``repository_id`` not\n                found\n        raise:  NullArgument - ``composition_id`` or ``repository_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.assign_resource_to_bin\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_repository_lookup_session(proxy=self._proxy)\n        lookup_session.get_repository(repository_id)  # to raise NotFound\n        self._assign_object_to_catalog(composition_id, repository_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves a Composition from a Repository.", "response": "def unassign_composition_from_repository(self, composition_id, repository_id):\n        \"\"\"Removes ``Composition`` from a ``Repository``.\n\n        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        raise:  NotFound - ``composition_id`` or ``repository_id`` not\n                found or ``composition_id`` not assigned to\n                ``repository_id``\n        raise:  NullArgument - ``composition_id`` or ``repository_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.ResourceBinAssignmentSession.unassign_resource_from_bin\n        mgr = self._get_provider_manager('REPOSITORY', local=True)\n        lookup_session = mgr.get_repository_lookup_session(proxy=self._proxy)\n        lookup_session.get_repository(repository_id)  # to raise NotFound\n        self._unassign_object_from_catalog(composition_id, repository_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the Repository specified by its Id.", "response": "def get_repository(self, repository_id):\n        \"\"\"Gets the ``Repository`` specified by its ``Id``.\n\n        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Repository`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``Repository`` and retained\n        for compatibility.\n\n        arg:    repository_id (osid.id.Id): ``Id`` of the ``Repository``\n        return: (osid.repository.Repository) - the repository\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method is must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinLookupSession.get_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalog(catalog_id=repository_id)\n        collection = JSONClientValidated('repository',\n                                         collection='Repository',\n                                         runtime=self._runtime)\n        # Need to consider how to best deal with the \"phantom root\" catalog issue\n        if repository_id.get_identifier() == PHANTOM_ROOT_IDENTIFIER:\n            return self._get_phantom_root_catalog(cat_class=objects.Repository, cat_name='Repository')\n        try:\n            result = collection.find_one({'_id': ObjectId(self._get_id(repository_id, 'repository').get_identifier())})\n        except errors.NotFound:\n            # Try creating an orchestrated Repository.  Let it raise errors.NotFound()\n            result = self._create_orchestrated_cat(repository_id, 'repository', 'Repository')\n\n        return objects.Repository(osid_object_map=result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list of Repositories corresponding to the given IdList.", "response": "def get_repositories_by_ids(self, repository_ids):\n        \"\"\"Gets a ``RepositoryList`` corresponding to the given ``IdList``.\n\n        In plenary mode, the returned list contains all of the\n        repositories specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Repositories`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set.\n\n        arg:    repository_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n        return: (osid.repository.RepositoryList) - the returned\n                ``Repository list``\n        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``repository_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinLookupSession.get_bins_by_ids_template\n        # NOTE: This implementation currently ignores plenary view\n        # Also, this should be implemented to use get_Repository() instead of direct to database\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalogs_by_ids(catalog_ids=repository_ids)\n        catalog_id_list = []\n        for i in repository_ids:\n            catalog_id_list.append(ObjectId(i.get_identifier()))\n        collection = JSONClientValidated('repository',\n                                         collection='Repository',\n                                         runtime=self._runtime)\n        result = collection.find({'_id': {'$in': catalog_id_list}}).sort('_id', DESCENDING)\n\n        return objects.RepositoryList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of repositories corresponding to the given repository genus Type which does not include repositories of genus types derived from the specified Type.", "response": "def get_repositories_by_genus_type(self, repository_genus_type):\n        \"\"\"Gets a ``RepositoryList`` corresponding to the given repository genus ``Type`` which does not include repositories of types derived from the specified ``Type``.\n\n        In plenary mode, the returned list contains all known\n        repositories or an error results. Otherwise, the returned list\n        may contain only those repositories that are accessible through\n        this session.\n\n        arg:    repository_genus_type (osid.type.Type): a repository\n                genus type\n        return: (osid.repository.RepositoryList) - the returned\n                ``Repository list``\n        raise:  NullArgument - ``repository_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinLookupSession.get_bins_by_genus_type_template\n        # NOTE: This implementation currently ignores plenary view\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalogs_by_genus_type(catalog_genus_type=repository_genus_type)\n        collection = JSONClientValidated('repository',\n                                         collection='Repository',\n                                         runtime=self._runtime)\n        result = collection.find({\"genusTypeId\": str(repository_genus_type)}).sort('_id', DESCENDING)\n\n        return objects.RepositoryList(result, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of Repositories matching the given repository query.", "response": "def get_repositories_by_query(self, repository_query):\n        \"\"\"Gets a list of ``Repositories`` matching the given repository query.\n\n        arg:    repository_query (osid.repository.RepositoryQuery): the\n                repository query\n        return: (osid.repository.RepositoryList) - the returned\n                ``RepositoryList``\n        raise:  NullArgument - ``repository_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``repository_query`` is not of this\n                service\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinQuerySession.get_bins_by_query_template\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalogs_by_query(repository_query)\n        query_terms = dict(repository_query._query_terms)\n        collection = JSONClientValidated('repository',\n                                         collection='Repository',\n                                         runtime=self._runtime)\n        result = collection.find(query_terms).sort('_id', DESCENDING)\n\n        return objects.RepositoryList(result, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if this user can create a single Repository using the desired record types.", "response": "def can_create_repository_with_record_types(self, repository_record_types):\n        \"\"\"Tests if this user can create a single ``Repository`` using the desired record types.\n\n        While ``RepositoryManager.getRepositoryRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Repository``. Providing an empty array tests if a\n        ``Repository`` can be created with no records.\n\n        arg:    repository_record_types (osid.type.Type[]): array of\n                repository record types\n        return: (boolean) - ``true`` if ``Repository`` creation using\n                the specified ``Types`` is supported, ``false``\n                otherwise\n        raise:  NullArgument - ``repository_record_types`` is ``null``\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinAdminSession.can_create_bin_with_record_types\n        # NOTE: It is expected that real authentication hints will be\n        # handled in a service adapter above the pay grade of this impl.\n        if self._catalog_session is not None:\n            return self._catalog_session.can_create_catalog_with_record_types(catalog_record_types=repository_record_types)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_repository(self, repository_form):\n        # Implemented from template for\n        # osid.resource.BinAdminSession.update_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.update_catalog(catalog_form=repository_form)\n        collection = JSONClientValidated('repository',\n                                         collection='Repository',\n                                         runtime=self._runtime)\n        if not isinstance(repository_form, ABCRepositoryForm):\n            raise errors.InvalidArgument('argument type is not an RepositoryForm')\n        if not repository_form.is_for_update():\n            raise errors.InvalidArgument('the RepositoryForm is for update only, not create')\n        try:\n            if self._forms[repository_form.get_id().get_identifier()] == UPDATED:\n                raise errors.IllegalState('repository_form already used in an update transaction')\n        except KeyError:\n            raise errors.Unsupported('repository_form did not originate from this session')\n        if not repository_form.is_valid():\n            raise errors.InvalidArgument('one or more of the form elements is invalid')\n        collection.save(repository_form._my_map)  # save is deprecated - change to replace_one\n\n        self._forms[repository_form.get_id().get_identifier()] = UPDATED\n\n        # Note: this is out of spec. The OSIDs don't require an object to be returned\n        return objects.Repository(osid_object_map=repository_form._my_map, runtime=self._runtime, proxy=self._proxy)", "response": "Updates an existing repository."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef alias_repository(self, repository_id, alias_id):\n        # Implemented from template for\n        # osid.resource.BinLookupSession.alias_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.alias_catalog(catalog_id=repository_id, alias_id=alias_id)\n        self._alias_id(primary_id=repository_id, equivalent_id=alias_id)", "response": "Adds an Id to a repository for the purpose of creating compatibility."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_root_repositories(self):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_root_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_root_catalogs()\n        return RepositoryLookupSession(\n            self._proxy,\n            self._runtime).get_repositories_by_ids(list(self.get_root_repository_ids()))", "response": "Gets the root repositories in the repository hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_parent_repositories(self, repository_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_parent_catalogs(catalog_id=repository_id)\n        return self._hierarchy_session.has_parents(id_=repository_id)", "response": "Tests if the Repository has any parents."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_parent_of_repository(self, id_, repository_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_parent_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_parent_of_catalog(id_=id_, catalog_id=repository_id)\n        return self._hierarchy_session.is_parent(id_=repository_id, parent_id=id_)", "response": "Tests if an Id is a direct parent of a repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_parent_repository_ids(self, repository_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalog_ids(catalog_id=repository_id)\n        return self._hierarchy_session.get_parents(id_=repository_id)", "response": "Gets the parent Ids of the given repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_parent_repositories(self, repository_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_parent_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_parent_catalogs(catalog_id=repository_id)\n        return RepositoryLookupSession(\n            self._proxy,\n            self._runtime).get_repositories_by_ids(\n                list(self.get_parent_repository_ids(repository_id)))", "response": "Gets the parents of the given repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntests if an Id is an ancestor of a repository.", "response": "def is_ancestor_of_repository(self, id_, repository_id):\n        \"\"\"Tests if an ``Id`` is an ancestor of a repository.\n\n        arg:    id (osid.id.Id): an ``Id``\n        arg:    repository_id (osid.id.Id): the Id of a repository\n        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``repository_id,``  ``false`` otherwise\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n        *implementation notes*: If ``id`` not found return ``false``.\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_ancestor_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_ancestor_of_catalog(id_=id_, catalog_id=repository_id)\n        return self._hierarchy_session.is_ancestor(id_=id_, ancestor_id=repository_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if a repository has any children.", "response": "def has_child_repositories(self, repository_id):\n        \"\"\"Tests if a repository has any children.\n\n        arg:    repository_id (osid.id.Id): a repository ``Id``\n        return: (boolean) - ``true`` if the ``repository_id`` has\n                children, ``false`` otherwise\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.has_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.has_child_catalogs(catalog_id=repository_id)\n        return self._hierarchy_session.has_children(id_=repository_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_child_of_repository(self, id_, repository_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_child_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_child_of_catalog(id_=id_, catalog_id=repository_id)\n        return self._hierarchy_session.is_child(id_=repository_id, child_id=id_)", "response": "Tests if a node is a direct child of another."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_child_repository_ids(self, repository_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bin_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalog_ids(catalog_id=repository_id)\n        return self._hierarchy_session.get_children(id_=repository_id)", "response": "Gets the Ids of the children of the given repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the children of the given repository.", "response": "def get_child_repositories(self, repository_id):\n        \"\"\"Gets the children of the given repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` to query\n        return: (osid.repository.RepositoryList) - the children of the\n                repository\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_child_bins\n        if self._catalog_session is not None:\n            return self._catalog_session.get_child_catalogs(catalog_id=repository_id)\n        return RepositoryLookupSession(\n            self._proxy,\n            self._runtime).get_repositories_by_ids(\n                list(self.get_child_repository_ids(repository_id)))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_descendant_of_repository(self, id_, repository_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.is_descendant_of_bin\n        if self._catalog_session is not None:\n            return self._catalog_session.is_descendant_of_catalog(id_=id_, catalog_id=repository_id)\n        return self._hierarchy_session.is_descendant(id_=id_, descendant_id=repository_id)", "response": "Tests if an Id is a descendant of a repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the node Ids of the specified repository.", "response": "def get_repository_node_ids(self, repository_id, ancestor_levels, descendant_levels, include_siblings):\n        \"\"\"Gets a portion of the hierarchy for the given repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n        return: (osid.hierarchy.Node) - the specified repository node\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_node_ids\n        if self._catalog_session is not None:\n            return self._catalog_session.get_catalog_node_ids(\n                catalog_id=repository_id,\n                ancestor_levels=ancestor_levels,\n                descendant_levels=descendant_levels,\n                include_siblings=include_siblings)\n        return self._hierarchy_session.get_nodes(\n            id_=repository_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a portion of the hierarchy for the given repository.", "response": "def get_repository_nodes(self, repository_id, ancestor_levels, descendant_levels, include_siblings):\n        \"\"\"Gets a portion of the hierarchy for the given repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n        return: (osid.repository.RepositoryNode) - the specified\n                repository node\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchySession.get_bin_nodes\n        return objects.RepositoryNode(self.get_repository_node_ids(\n            repository_id=repository_id,\n            ancestor_levels=ancestor_levels,\n            descendant_levels=descendant_levels,\n            include_siblings=include_siblings)._my_map, runtime=self._runtime, proxy=self._proxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a root repository.", "response": "def add_root_repository(self, repository_id):\n        \"\"\"Adds a root repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n        raise:  AlreadyExists - ``repository_id`` is already in\n                hierarchy\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_root_catalog(catalog_id=repository_id)\n        return self._hierarchy_session.add_root(id_=repository_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove a root repository.", "response": "def remove_root_repository(self, repository_id):\n        \"\"\"Removes a root repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n        raise:  NotFound - ``repository_id`` not a root\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_root_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_root_catalog(catalog_id=repository_id)\n        return self._hierarchy_session.remove_root(id_=repository_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a child to a repository.", "response": "def add_child_repository(self, repository_id, child_id):\n        \"\"\"Adds a child to a repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n        raise:  AlreadyExists - ``repository_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``repository_id`` or ``child_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.add_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.add_child_catalog(catalog_id=repository_id, child_id=child_id)\n        return self._hierarchy_session.add_child(id_=repository_id, child_id=child_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_child_repository(self, repository_id, child_id):\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalog(catalog_id=repository_id, child_id=child_id)\n        return self._hierarchy_session.remove_child(id_=repository_id, child_id=child_id)", "response": "Removes a child from a repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove all children from a repository.", "response": "def remove_child_repositories(self, repository_id):\n        \"\"\"Removes all children from a repository.\n\n        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n        raise:  NotFound - ``repository_id`` not in hierarchy\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        # Implemented from template for\n        # osid.resource.BinHierarchyDesignSession.remove_child_bin_template\n        if self._catalog_session is not None:\n            return self._catalog_session.remove_child_catalogs(catalog_id=repository_id)\n        return self._hierarchy_session.remove_children(id_=repository_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_cron(self, client, event, seconds=\"*\", minutes=\"*\", hours=\"*\"):\n        for cron in self.crons:\n            if cron.event == event:\n                _log.warning(\"Cron '%s' is already registered.\", event)\n                return True\n\n        _log.info(\"Registering cron for '%s'.\", event)\n        cron = Cron(event, seconds, minutes, hours)\n        self.crons.append(cron)\n        return True", "response": "Add a cron entry to the list of cron entries."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove a cron entry by event name.", "response": "def remove_cron(self, client, event):\n        \"\"\"Remove a cron entry by event name.\"\"\"\n        for index, cron in enumerate(self.crons):\n            if cron.event == event:\n                _log.info(\"De-registering cron '%s'.\", event)\n                # Yes, we're modifying the list we're iterating over, but\n                # we immediate stop iterating so it's okay.\n                self.crons.pop(index)\n                break\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting the recipe execution.", "response": "def run(self):\n        \"\"\" Starts recipes execution. \"\"\"\n\n        self._prepare()\n\n        for recipe in self._recipes:\n            run_recipe = True\n\n            # Ask user whether to run current recipe if -y argument is not specified\n            if not self.arguments.yes:\n                run_recipe = pypro.console.ask_bool('Run %s.%s' % (recipe.module, recipe.name), \"yes\")\n\n            if run_recipe:\n                recipe.run(self, self.arguments)\n\n        if self.arguments.verbose:\n            pypro.console.out('Thanks for using pypro. Support this project at https://github.com/avladev/pypro')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the name of the recipe which is its class name without package.", "response": "def name(self):\n        \"\"\" Returns the recipe name which is its class name without package. \"\"\"\n        if not hasattr(self, '_name'):\n            self._name = re.search('[a-z]+\\.([a-z]+)\\.([a-z]+)', str(self.__class__), re.IGNORECASE).group(2)\n\n        return self._name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef module(self):\n        if not hasattr(self, '_module'):\n            self._module = re.search('[a-z]+\\.([a-z]+)\\.([a-z]+)', str(self.__class__), re.IGNORECASE).group(1)\n\n        return self._module", "response": "Returns the module name of the Recipe."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the recipe settings file which is locate in the recipe package. ini file which is located in the settings directory.", "response": "def settings(self):\n        \"\"\"\n        Loads the recipe settings file which is locate in:\n        ./settings/{recipe_package}.ini\n        \"\"\"\n        settings_file = os.path.join(os.getcwd(), 'settings', self.module.lower() + '.ini')\n\n        # Loads the settings file once.\n        if (not hasattr(self, '_settings') or self._settings is None) and os.path.isfile(settings_file):\n            config = ConfigParser.ConfigParser()\n            config.read(settings_file)\n\n            settings = dict(config._sections)\n            for key in settings:\n                settings[key] = dict(config.defaults(), **settings[key])\n                settings[key].pop('__name__', None)\n\n            self._settings = SettingsDict(self, settings.get(self.name, {}))\n\n        elif not hasattr(self, '_settings'):\n            self._settings = SettingsDict(self, {})\n\n        return self._settings"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreversing the given method between positive and negative.", "response": "def _reverse_rounding_method(method):\n        \"\"\"\n        Reverse meaning of ``method`` between positive and negative.\n        \"\"\"\n        if method is RoundingMethods.ROUND_UP:\n            return RoundingMethods.ROUND_DOWN\n        if method is RoundingMethods.ROUND_DOWN:\n            return RoundingMethods.ROUND_UP\n        if method is RoundingMethods.ROUND_HALF_UP:\n            return RoundingMethods.ROUND_HALF_DOWN\n        if method is RoundingMethods.ROUND_HALF_DOWN:\n            return RoundingMethods.ROUND_HALF_UP\n        if method in \\\n           (RoundingMethods.ROUND_TO_ZERO, RoundingMethods.ROUND_HALF_ZERO):\n            return method\n        raise BasesAssertError('unknown method')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_rational(\n       cls,\n       value,\n       to_base,\n       precision=None,\n       method=RoundingMethods.ROUND_DOWN\n    ):\n        \"\"\"\n        Convert rational value to a base.\n\n        :param Rational value: the value to convert\n        :param int to_base: base of result, must be at least 2\n        :param precision: number of digits in total or None\n        :type precision: int or NoneType\n        :param method: rounding method\n        :type method: element of RoundingMethods.METHODS()\n        :returns: the conversion result and its relation to actual result\n        :rtype: Radix * int\n        :raises BasesValueError: if to_base is less than 2\n\n        Complexity: Uncalculated.\n        \"\"\"\n        # pylint: disable=too-many-locals\n        if to_base < 2:\n            raise BasesValueError(to_base, \"to_base\", \"must be at least 2\")\n\n        if precision is not None and precision < 0:\n            raise BasesValueError(precision, \"precision\", \"must be at least 0\")\n\n        if value == 0:\n            non_repeating_part = [] if precision is None else precision * [0]\n            return (Radix(0, [], non_repeating_part, [], to_base), 0)\n\n        if value < 0:\n            sign = -1\n        else:\n            sign = 1\n\n        div_method = method\n\n        if sign == -1:\n            value = abs(value)\n            div_method = cls._reverse_rounding_method(method)\n\n        numerator = Nats.convert_from_int(value.numerator, to_base)\n        denominator = Nats.convert_from_int(value.denominator, to_base)\n\n        (integer_part, non_repeating_part, repeating_part, relation) = \\\n           NatDivision.division(\n              denominator,\n              numerator,\n              to_base,\n              precision,\n              div_method\n           )\n\n        relation = relation * sign\n\n        result = Radix(\n           sign,\n           integer_part,\n           non_repeating_part,\n           repeating_part,\n           to_base\n        )\n\n        if precision is not None:\n            (result, rel) = result.rounded(precision, method)\n            relation = relation if rel == 0 else rel\n\n        return (result, relation)", "response": "Convert a rational value to a base."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrounding value to an int according to method.", "response": "def round_to_int(value, method):\n        \"\"\"\n        Round ``value`` to an int according to ``method``.\n\n        :param Rational value: the value to round\n        :param method: the rounding method (of RoundingMethods.METHODS())\n\n        :returns: rounded value and relation of rounded value to actual value.\n        :rtype: (int * int)\n\n        Complexity: O(1)\n        \"\"\"\n        # pylint: disable=too-many-return-statements\n        if value.denominator == 1:\n            return (value.numerator, 0)\n\n        int_value = int(value)\n        if int_value < value:\n            (lower, upper) = (int_value, int_value + 1)\n        else:\n            (lower, upper) = (int_value - 1, int_value)\n\n        if method is RoundingMethods.ROUND_DOWN:\n            return (lower, -1)\n\n        if method is RoundingMethods.ROUND_UP:\n            return (upper, 1)\n\n        if method is RoundingMethods.ROUND_TO_ZERO:\n            return (upper, 1) if lower < 0 else (lower, -1)\n\n        delta = value - lower\n\n        if method is RoundingMethods.ROUND_HALF_UP:\n            return (upper, 1) if delta >= Fraction(1, 2) else (lower, -1)\n\n        if method is RoundingMethods.ROUND_HALF_DOWN:\n            return (lower, -1) if delta <= Fraction(1, 2) else (upper, 1)\n\n        if method is RoundingMethods.ROUND_HALF_ZERO:\n            if lower < 0:\n                return (upper, 1) if delta >= Fraction(1, 2) else (lower, -1)\n            return (lower, -1) if delta <= Fraction(1, 2) else (upper, 1)\n\n        raise BasesValueError(method, \"method\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate( # pylint: disable=too-many-arguments\n        cls,\n        sign,\n        integer_part,\n        non_repeating_part,\n        repeating_part,\n        base\n    ):\n        \"\"\"\n        Check if radix is valid.\n\n        :param int sign: -1, 0, or 1 as appropriate\n        :param integer_part: the part on the left side of the radix\n        :type integer_part: list of int\n        :param non_repeating_part: non repeating part on left side\n        :type non_repeating_part: list of int\n        :param repeating_part: repeating part\n        :type repeating_part: list of int\n        :param int base: base of the radix, must be at least 2\n\n        :returns: BasesValueError if invalid values\n        :rtype: BasesValueError or NoneType\n\n        Complexity: O(len(integer_part + non_repeating_part + repeating_part))\n        \"\"\"\n        if any(x < 0 or x >= base for x in integer_part):\n            return BasesValueError(\n               integer_part,\n               \"integer_part\",\n               \"values must be between 0 and %s\" % base\n            )\n        if any(x < 0 or x >= base for x in non_repeating_part):\n            return BasesValueError(\n               non_repeating_part,\n               \"non_repeating_part\",\n               \"values must be between 0 and %s\" % base\n            )\n        if any(x < 0 or x >= base for x in repeating_part):\n            return BasesValueError(\n               repeating_part,\n               \"repeating_part\",\n               \"values must be between 0 and %s\" % base\n            )\n        if base < 2:\n            return BasesValueError(base, \"base\", \"must be at least 2\")\n\n        if sign not in (-1, 0, 1) or sign is True or sign is False:\n            return BasesValueError(\n               sign,\n               \"sign\",\n               \"must be an int between -1 and 1\"\n            )\n\n        return None", "response": "Validate the radix and return a list of valid values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _repeat_length(cls, part):\n        repeat_len = len(part)\n        if repeat_len == 0:\n            return repeat_len\n\n        first_digit = part[0]\n        limit = repeat_len // 2 + 1\n        indices = (i for i in range(1, limit) if part[i] == first_digit)\n        for index in indices:\n            (quot, rem) = divmod(repeat_len, index)\n            if rem == 0:\n                first_chunk = part[0:index]\n                if all(first_chunk == part[x:x + index] \\\n                   for x in range(index, quot * index, index)):\n                    return index\n        return repeat_len", "response": "Returns the length of the repeated portions of part."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a string representation according to config.", "response": "def getString(self, config, relation=0):\n        \"\"\"\n        Return a representation of a Radix according to config.\n\n        :param DisplayConfig config: configuration\n        :param int relation: the relation of this value to actual value\n        \"\"\"\n        return String(config, self.base).xform(self, relation)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn this value as a Rational.", "response": "def as_rational(self):\n        \"\"\"\n        Return this value as a Rational.\n\n        :returns: this radix as a rational\n        :rtype: Rational\n        \"\"\"\n        (denominator, numerator) = \\\n           NatDivision.undivision(\n              self.integer_part,\n              self.non_repeating_part,\n              self.repeating_part,\n              self.base\n           )\n        result = Fraction(\n           Nats.convert_to_int(numerator, self.base),\n           Nats.convert_to_int(denominator, self.base)\n        )\n        return result * self.sign"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn value in base.", "response": "def in_base(self, base):\n        \"\"\"\n        Return value in ``base``.\n\n        :returns: Radix in ``base``\n        :rtype: Radix\n        :raises ConvertError: if ``base`` is less than 2\n        \"\"\"\n        if base == self.base:\n            return copy.deepcopy(self)\n        (result, _) = Radices.from_rational(self.as_rational(), base)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the given method is conditional toward zero.", "response": "def _conditional_toward_zero(method, sign):\n        \"\"\"\n        Whether to round toward zero.\n\n        :param method: rounding method\n        :type method: element of RoundingMethods.METHODS()\n        :param int sign: -1, 0, or 1 as appropriate\n\n        Complexity: O(1)\n        \"\"\"\n        return method is RoundingMethods.ROUND_HALF_ZERO or \\\n           (method is RoundingMethods.ROUND_HALF_DOWN and sign == 1) or \\\n           (method is RoundingMethods.ROUND_HALF_UP and sign == -1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _increment(sign, integer_part, non_repeating_part, base):\n        (carry, non_repeating_part) = \\\n           Nats.carry_in(non_repeating_part, 1, base)\n        (carry, integer_part) = \\\n           Nats.carry_in(integer_part, carry, base)\n        return Radix(\n           sign,\n           integer_part if carry == 0 else [carry] + integer_part,\n           non_repeating_part,\n           [],\n           base,\n           False\n        )", "response": "Return an increment radix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef roundFractional(cls, value, precision, method):\n        # pylint: disable=too-many-return-statements\n        # pylint: disable=too-many-branches\n\n        if precision < 0:\n            raise BasesValueError(\n               precision,\n               \"precision\",\n               \"must be at least 0\"\n            )\n\n        if method not in RoundingMethods.METHODS():\n            raise BasesValueError(\n               method,\n               \"method\",\n               \"must be one of RoundingMethod.METHODS()\"\n            )\n\n        if value.sign == 0:\n            return (Radix(0, [], precision * [0], [], value.base), 0)\n\n        digits = itertools.chain(\n           value.non_repeating_part,\n           itertools.cycle(value.repeating_part)\n        )\n        non_repeating_part = list(itertools.islice(digits, 0, precision))\n        non_repeating_part += (precision - len(non_repeating_part)) * [0]\n\n        truncated = lambda: Radix(\n           value.sign,\n           value.integer_part,\n           non_repeating_part,\n           [],\n           value.base,\n           False\n        )\n\n        incremented = lambda: cls._increment(\n           value.sign,\n           value.integer_part,\n           non_repeating_part,\n           value.base\n        )\n\n        if all(x == 0 for x in value.non_repeating_part[precision:]) and \\\n           value.repeating_part == []:\n            return (truncated(), 0)\n\n        if method is RoundingMethods.ROUND_TO_ZERO:\n            return (truncated(), -1 * value.sign)\n\n        if method is RoundingMethods.ROUND_DOWN:\n            return (truncated() if value.sign == 1 else incremented(), -1)\n\n        if method is RoundingMethods.ROUND_UP:\n            return (incremented() if value.sign == 1 else truncated(), 1)\n\n        non_repeating_remainder = value.non_repeating_part[precision:]\n        if non_repeating_remainder == []:\n            repeating_part = \\\n               list(itertools.islice(digits, len(value.repeating_part)))\n        else:\n            repeating_part = value.repeating_part[:]\n\n        remainder = Radix(\n           1,\n           [],\n           non_repeating_remainder,\n           repeating_part,\n           value.base\n        )\n        remainder_fraction = remainder.as_rational()\n        middle = Fraction(1, 2)\n        if remainder_fraction < middle:\n            return (truncated(), -1 * value.sign)\n        if remainder_fraction > middle:\n            return (incremented(), value.sign)\n\n        if cls._conditional_toward_zero(method, value.sign):\n            return (truncated(), -1 * value.sign)\n        return (incremented(), value.sign)", "response": "Round the radix to the specified number of digits after the radix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_next_property(self):\n        try:\n            next_object = self.next()\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except Exception:  # Need to specify exceptions here!\n            raise OperationFailed()\n        else:\n            return next_object", "response": "Gets the next property in this list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_edgegrid_client_settings():\n    '''Load Akamai EdgeGrid configuration\n\n    returns a (hostname, EdgeGridAuth) tuple from the following locations:\n\n    1. Values specified directly in the Django settings::\n        AKAMAI_CCU_CLIENT_SECRET\n        AKAMAI_CCU_HOST\n        AKAMAI_CCU_ACCESS_TOKEN\n        AKAMAI_CCU_CLIENT_TOKEN\n    2. An edgerc file specified in the AKAMAI_EDGERC_FILENAME settings\n    3. The default ~/.edgerc file\n\n    Both edgerc file load options will return the values from the \u201cCCU\u201d section\n    by default. This may be customized using the AKAMAI_EDGERC_CCU_SECTION setting.\n    '''\n\n    if getattr(settings, 'AKAMAI_CCU_CLIENT_SECRET', None):\n        # If the settings module has the values directly and they are not empty\n        # we'll use them without checking for an edgerc file:\n\n        host = settings.AKAMAI_CCU_HOST\n        auth = EdgeGridAuth(access_token=settings.AKAMAI_CCU_ACCESS_TOKEN,\n                            client_token=settings.AKAMAI_CCU_CLIENT_TOKEN,\n                            client_secret=settings.AKAMAI_CCU_CLIENT_SECRET)\n        return host, auth\n    else:\n        edgerc_section = getattr(settings, 'AKAMAI_EDGERC_CCU_SECTION', 'CCU')\n\n        edgerc_path = getattr(settings, 'AKAMAI_EDGERC_FILENAME', '~/.edgerc')\n        edgerc_path = os.path.expanduser(edgerc_path)\n\n        if os.path.isfile(edgerc_path):\n            edgerc = EdgeRc(edgerc_path)\n            host = edgerc.get(edgerc_section, 'host')\n            auth = EdgeGridAuth.from_edgerc(edgerc, section=edgerc_section)\n            return host, auth\n\n        raise InvalidAkamaiConfiguration('Cannot find Akamai client configuration!')", "response": "Load Akamai EdgeGrid configuration from settings module."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, urls):\n\n        if isinstance(urls, (list, tuple)):\n            self.urls.extend(urls)\n        elif isinstance(urls, basestring):\n            self.urls.append(urls)\n        elif isinstance(urls, QuerySet):\n            for obj in urls:\n                self.urls.append(obj.get_absolute_url())\n        elif hasattr(urls, 'get_absolute_url'):\n            self.urls.append(urls.get_absolute_url())\n        else:\n            raise TypeError(\"Don't know how to handle %r\" % urls)", "response": "Add the provided urls to this purge request\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsubmits a purge request to the CCU API and return the results of the purge request.", "response": "def purge(self):\n        \"\"\"Submit purge request(s) to the CCU API\n\n        Since a purge call may require multiple API requests and may trigger rate-limiting\n        this method uses a generator to provide the results of each request, allowing you to\n        communicate request progress or implement a custom rate-limiting response::\n\n            for url_batch, response in purge_request.purge():\n                if response.ok:\n                    # update progress\n                elif response.status_code == 507:\n                    # Rate-limiting. Do something?\n\n        If you simply want a function which blocks until all of the purge requests have been\n        issued, use `purge_all()`.\n\n        Both `purge()` and `purge_all()` will raise HTTP exceptions for any error response\n        other than rate-limiting.\n        \"\"\"\n\n        purge_url = urljoin('https://%s' % self.host, '/ccu/v3/%s/url/%s' % (self.action, self.network))\n\n        while self.urls:\n            # We'll accumulate\n            batch = []\n            batch_size = 0\n\n            while self.urls and batch_size < self.MAX_REQUEST_SIZE:\n                next_url = self.urls.pop()\n\n                if not isinstance(next_url, bytes):\n                    next_url = next_url.encode('utf-8')\n\n                batch.append(next_url)\n                batch_size += len(next_url)\n\n            if batch:\n                data = {'objects': batch}\n\n                logger.debug('Requesting Akamai purge %d URLs', len(batch))\n\n                response = requests.post(url=purge_url, auth=self.auth, data=json.dumps(data),\n                                         headers={'Content-Type': 'application/json'})\n\n                if not response.ok:\n                    # We'll return the current batch to the queue so they can be retried later:\n                    self.urls.extend(batch)\n\n                    # Raise an exception for errors other than rate-limiting:\n                    if response.status_code != 507:\n                        response.raise_for_status()\n\n                yield batch, response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef purge_all(self, rate_limit_delay=60):\n        '''Purge all pending URLs, waiting for API rate-limits if necessary!'''\n\n        for batch, response in self.purge():\n            if response.status_code == 507:\n                details = response.json().get('detail', '<response did not contain \"detail\">')\n                logger.info('Will retry request in %d seconds due to API rate-limit: %s',\n                            rate_limit_delay, details)\n                time.sleep(rate_limit_delay)", "response": "Purge all pending URLs waiting for API rate - limits!"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_metadata(self):\n        self._objective_bank_id_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'objective_bank_id'),\n            'element_label': 'Objective Bank Id',\n            'instructions': 'accepts a valid OSID Id string',\n            'required': False,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_id_values': [''],\n            'syntax': 'ID',\n            'id_set': []\n        }", "response": "Initialize metadata for objective bank id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear the objective bank Id", "response": "def clear_objective_bank_id(self):\n        \"\"\"stub\"\"\"\n        if (self.get_objective_bank_id_metadata().is_read_only() or\n                self.get_objective_bank_id_metadata().is_required()):\n            raise NoAccess()\n        self.my_osid_object_form._my_map['objectiveBankId'] = ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the item from the ItemLookupSession", "response": "def get_item(self, item_id):\n        \"\"\" see if this is a magic item id (i.e. questionId).\n        If so, grab the item and set the params.\n        If not, just pass through to the original Mongo ItemLookupSession\n        :param item_id:\n        :return:\n        \"\"\"\n        authority = item_id.authority\n        mgr = self._get_provider_manager('ASSESSMENT', local=True)\n        if self._proxy is not None:\n            ils = mgr.get_item_lookup_session(proxy=self._proxy)\n        else:\n            ils = mgr.get_item_lookup_session()\n        ils.use_federated_bank_view()\n        if authority == MAGIC_AUTHORITY:\n            magic_identifier = unquote(item_id.identifier)\n            params = json.loads(magic_identifier.split('?')[-1])\n            orig_identifier = magic_identifier.split('?')[0]\n            original_item_id = Id(\n                namespace=item_id.namespace,\n                authority=self._catalog.ident.authority,\n                identifier=orig_identifier\n            )\n            orig_item = ils.get_item(original_item_id)\n            orig_item.set_params(params)\n            return orig_item\n        else:\n            return ils.get_item(item_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the map of the object", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(CalculationInteractionQuestionFormRecord, self)._init_map()\n        QuestionTextFormRecord._init_map(self)\n        QuestionFilesFormRecord._init_map(self)\n        self.my_osid_object_form._my_map['text']['text'] = ''\n        self.my_osid_object_form._my_map['variables'] = \\\n            self._variables_metadata['default_object_values'][0]\n        self.my_osid_object_form._my_map['expression'] = \\\n            self._expression_metadata['default_string_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_metadata(self):\n        super(CalculationInteractionQuestionFormRecord, self)._init_metadata()\n        QuestionTextFormRecord._init_metadata(self)\n        QuestionFilesFormRecord._init_metadata(self)\n        self._variables_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'variables'),\n            'element_label': 'variables',\n            'instructions': 'Enter the variables',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': True,\n            'default_object_values': [{}],\n            'syntax': 'OBJECT',\n            'object_set': []\n        }\n        self._expression_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'expression'),\n            'element_label': 'expression',\n            'instructions': 'enter the expression',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 1024,\n            'string_set': []\n        }", "response": "Initializes the metadata for the assessment record."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_map(self):\n        DecimalValuesFormRecord._init_map(self)\n        IntegerValuesFormRecord._init_map(self)\n        TextAnswerFormRecord._init_map(self)\n        FilesAnswerFormRecord._init_map(self)\n        FeedbackAnswerFormRecord._init_map(self)\n        super(CalculationInteractionFeedbackAndFilesAnswerFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['toleranceMode'] = \\\n            self._tolerance_mode_metadata['default_string_values'][0]", "response": "call these all manually because non - cooperative"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the map of the record.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(MultiLanguageCalculationInteractionQuestionFormRecord, self)._init_map()\n        MultiLanguageQuestionFormRecord._init_map(self)\n        QuestionFilesFormRecord._init_map(self)\n        self.my_osid_object_form._my_map['variables'] = \\\n            self._variables_metadata['default_object_values'][0]\n        self.my_osid_object_form._my_map['expression'] = \\\n            self._expression_metadata['default_string_values'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_map(self):\n        DecimalValuesFormRecord._init_map(self)\n        IntegerValuesFormRecord._init_map(self)\n        TextAnswerFormRecord._init_map(self)\n        super(MultiLanguageCalculationInteractionFeedbackAndFilesAnswerFormRecord, self)._init_map()\n        self.my_osid_object_form._my_map['toleranceMode'] = \\\n            self._tolerance_mode_metadata['default_string_values'][0]", "response": "call these all manually because non - cooperative"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_metadata(self):\n        DecimalValuesFormRecord._init_metadata(self)\n        IntegerValuesFormRecord._init_metadata(self)\n        TextAnswerFormRecord._init_metadata(self)\n        super(MultiLanguageCalculationInteractionFeedbackAndFilesAnswerFormRecord, self)._init_metadata()\n        self._tolerance_mode_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'tolerance_mode'),\n            'element_label': 'tolerance_mode',\n            'instructions': 'enter the tolerance mode',\n            'required': True,\n            'read_only': False,\n            'linked': False,\n            'array': False,\n            'default_string_values': [{\n                'text': '',\n                'languageTypeId': str(DEFAULT_LANGUAGE_TYPE),\n                'scriptTypeId': str(DEFAULT_SCRIPT_TYPE),\n                'formatTypeId': str(DEFAULT_FORMAT_TYPE),\n            }],\n            'syntax': 'STRING',\n            'minimum_string_length': 0,\n            'maximum_string_length': 1024,\n            'string_set': []\n        }", "response": "Initialize metadata for the MultiLanguageCalculationInteractionFeedbackAndFilesAnswerFormRecord."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_relationships_for_source_on_date(self, source_id, from_, to):\n        # Implemented from azosid template for -\n        # osid.relationship.RelationshipLookupSession.get_relationships_for_source_on_date_template\n        if self._can('lookup'):\n            return self._provider_session.get_relationships_for_source_on_date(source_id, from_, to)\n        self._check_lookup_conditions()  # raises PermissionDenied\n        query = self._query_session.get_relationship_query()\n        query.match_source_id(source_id, match=True)\n        query.match_date(from_, to, match=True)\n        return self._try_harder(query)", "response": "Pass through to provider RelationshipLookupSession. get_relationships_for_source_on_date"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses through to provider RelationshipSearchSession. get_relationships_by_search", "response": "def get_relationships_by_search(self, relationship_query, relationship_search):\n        \"\"\"Pass through to provider RelationshipSearchSession.get_relationships_by_search\"\"\"\n        # Implemented from azosid template for -\n        # osid.resource.ResourceSearchSession.get_resources_by_search_template\n        if not self._can('search'):\n            raise PermissionDenied()\n        return self._provider_session.get_relationships_by_search(relationship_query, relationship_search)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_agency_view(self, session):\n        if self._agency_view == COMPARATIVE:\n            try:\n                session.use_comparative_agency_view()\n            except AttributeError:\n                pass\n        else:\n            try:\n                session.use_plenary_agency_view()\n            except AttributeError:\n                pass", "response": "Sets the underlying agency view to match current view"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite data to a file specified by filename_or_file_object.", "response": "def to_file(data, filename_or_file_object):\n    \"\"\"\n    Write ``data`` to a file specified by either filename of the file or an opened :class:`file` buffer.\n\n    :param data: Object to write to file\n    :param filename_or_file_object: filename/or opened file buffer to write to\n    :type filename_or_file_object: basestring|file\n    \"\"\"\n    if isinstance(filename_or_file_object, basestring):\n        file_ = open(filename_or_file_object, 'w')\n        we_opened = True\n    else:\n        file_ = filename_or_file_object\n        we_opened = False\n\n    try:\n        file_.write(dump(data))\n    finally:\n        if we_opened:\n            file_.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread data from the specified file.", "response": "def from_file(filename_or_file_object):\n    \"\"\"\n    Read data from the specified file.\n    :param filename_or_file_object: filename of the file or an opened :class:`file` buffer to that file\n    :type filename_or_file_object: basestring|file\n    :return:\n    \"\"\"\n    if isinstance(filename_or_file_object, basestring):\n        file_ = open(filename_or_file_object, 'r')\n        we_opened = True\n    else:\n        we_opened = False\n        file_ = filename_or_file_object\n\n    try:\n        data = load(file_.read())\n    finally:\n        if we_opened:\n            file_.close()\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an instance of the class from the file.", "response": "def from_file(cls, filename_or_file_object):\n        \"\"\"\n        Create new instance of the object from the file.\n        :param filename_or_file_object: the filename of the file to read from or already opened file buffer\n        :type filename_or_file_object: basestring|file\n        \"\"\"\n        object_ = from_file(filename_or_file_object)\n        if not isinstance(object_, cls):\n            raise ValueError('Expected to read {0!r} object, but got {1!r} instead'.format(cls, type(object_)))\n\n        return object_"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving the ownership tree of all editions of a piece given the hash.", "response": "def history(self, hash):\n        \"\"\"\n        Retrieve the ownership tree of all editions of a piece given the hash.\n\n        Args:\n            hash (str): Hash of the file to check. Can be created with the\n                :class:`File` class\n\n        Returns:\n            dict: Ownsership tree of all editions of a piece.\n\n        .. note:: For now we only support searching the blockchain by\n            the piece hash.\n\n        \"\"\"\n        txs = self._t.get(hash, max_transactions=10000)['transactions']\n        tree = defaultdict(list)\n        number_editions = 0\n\n        for tx in txs:\n            _tx = self._t.get(tx['txid'])\n            txid = _tx['txid']\n            verb_str = BlockchainSpider.check_script(_tx['vouts'])\n            verb = Spoolverb.from_verb(verb_str)\n            from_address, to_address, piece_address = BlockchainSpider._get_addresses(_tx)\n            timestamp_utc = _tx['time']\n            action = verb.action\n\n            edition_number = 0\n            if action != 'EDITIONS':\n                edition_number = verb.edition_number\n            else:\n                number_editions = verb.num_editions\n\n            tree[edition_number].append({'txid': txid,\n                                         'verb': verb_str,\n                                         'from_address': from_address,\n                                         'to_address': to_address,\n                                         'piece_address': piece_address,\n                                         'timestamp_utc': timestamp_utc,\n                                         'action': action,\n                                         'number_editions': number_editions,\n                                         'edition_number': edition_number})\n\n        # lets update the records with the number of editions of the piece since we do not know\n        # this information before the EDITIONS transaction\n        for edition, chain in tree.items():\n            [d.update({'number_editions': number_editions}) for d in chain]\n        return dict(tree)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef chain(tree, edition_number):\n        # return the chain for an edition_number sorted by the timestamp\n        return sorted(tree.get(edition_number, []), key=lambda d: d['timestamp_utc'])", "response": "Returns the list of ownsership of a particular edition number in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the script is valid and returns the op_return if one exists.", "response": "def check_script(vouts):\n        \"\"\"\n        Looks into the vouts list of a transaction\n        and returns the ``op_return`` if one exists.\n\n        Args;\n            vouts (list): List of outputs of a transaction.\n\n        Returns:\n            str: String representation of the ``op_return``.\n\n        Raises:\n            Exception: If no ``vout`` having a supported\n                verb (:attr:`supported_actions`) is found.\n\n        \"\"\"\n        for vout in [v for v in vouts[::-1] if v['hex'].startswith('6a')]:\n            verb = BlockchainSpider.decode_op_return(vout['hex'])\n            action = Spoolverb.from_verb(verb).action\n            if action in Spoolverb.supported_actions:\n                return verb\n        raise Exception(\"Invalid ascribe transaction\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck for the from to and piece addresses of a SPOOL transaction.", "response": "def _get_addresses(tx):\n        \"\"\"\n        Checks for the from, to, and piece address of a SPOOL transaction.\n\n        Args:\n            tx (dict): Transaction payload, as returned by\n                :meth:`transactions.Transactions.get()`.\n\n        .. note:: Formats as returned by JSON-RPC API\n            ``decoderawtransaction`` have yet to be supported.\n\n        Returns:\n            Tuple([str]): Sender, receiver, and piece addresses.\n\n        \"\"\"\n        from_address = set([vin['address'] for vin in tx['vins']])\n        if len(from_address) != 1:\n            raise InvalidTransactionError(\"Transaction should have inputs \" \\\n                                          \"from only one address {}\".format(from_address))\n\n        # order vouts. discard the last vout since it's the op_return\n        vouts = sorted(tx['vouts'], key=lambda d: d['n'])[:-1]\n        piece_address = vouts[0]['address']\n        to_address = vouts[-1]['address']\n        from_address = from_address.pop()\n\n        return from_address, to_address, piece_address"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_time_utc(time_utc_str):\n        dt = datetime.strptime(time_utc_str, TIME_FORMAT)\n        return int(calendar.timegm(dt.utctimetuple()))", "response": "Convert a string representation of the time into a Unix timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary representation of the object.", "response": "def list_perceel_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering a list of\n    :class: `crabpy.gateway.capakey.Perceel` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'sectie': obj.sectie,\n        'capakey': obj.capakey,\n        'percid': obj.percid\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary of items from a Gemeente object to json.", "response": "def item_gemeente_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering an object of\n    :class: `crabpy.gateway.capakey.Gemeente` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'naam': obj.naam,\n        'centroid': obj.centroid,\n        'bounding_box': obj.bounding_box\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary of a crabpy. gateway. capakey. Afdeling to json.", "response": "def item_afdeling_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering an object of\n    :class: `crabpy.gateway.capakey.Afdeling` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'naam': obj.naam,\n        'gemeente': {\n            'id': obj.gemeente.id,\n            'naam': obj.gemeente.naam\n        },\n        'centroid': obj.centroid,\n        'bounding_box': obj.bounding_box\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef item_sectie_adapter(obj, request):\n    return {\n        'id': obj.id,\n        'afdeling': {\n            'id': obj.afdeling.id,\n            'naam': obj.afdeling.naam,\n            'gemeente': {\n                'id': obj.afdeling.gemeente.id,\n                'naam': obj.afdeling.gemeente.naam\n            },\n        },\n        'centroid': obj.centroid,\n        'bounding_box': obj.bounding_box\n    }", "response": "Returns a dictionary of the items that are part of a crabpy. capakey. Sectie object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dictionary of items for the given object.", "response": "def item_perceel_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering an object of\n    :class: `crabpy.gateway.capakey.Perceel` to json.\n    \"\"\"\n    return {\n        'id': obj.id,\n        'sectie': {\n            'id': obj.sectie.id,\n            'afdeling': {\n                'id': obj.sectie.afdeling.id,\n                'naam': obj.sectie.afdeling.naam,\n                'gemeente': {\n                    'id': obj.sectie.afdeling.gemeente.id,\n                    'naam': obj.sectie.afdeling.gemeente.naam\n                },\n            },\n        },\n        'capakey': obj.capakey,\n        'percid': obj.percid,\n        'centroid': obj.centroid,\n        'bounding_box': obj.bounding_box\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the in1d events of two arrays.", "response": "def in1d_events(ar1, ar2):\n    \"\"\"\n    Does the same than np.in1d but uses the fact that ar1 and ar2 are sorted and the c++ library. Is therefore much much faster.\n\n    \"\"\"\n    ar1 = np.ascontiguousarray(ar1)  # change memory alignement for c++ library\n    ar2 = np.ascontiguousarray(ar2)  # change memory alignement for c++ library\n    tmp = np.empty_like(ar1, dtype=np.uint8)  # temporary result array filled by c++ library, bool type is not supported with cython/numpy\n    return analysis_functions.get_in1d_sorted(ar1, ar2, tmp)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_max_events_in_both_arrays(events_one, events_two):\n    events_one = np.ascontiguousarray(events_one)  # change memory alignement for c++ library\n    events_two = np.ascontiguousarray(events_two)  # change memory alignement for c++ library\n    event_result = np.empty(shape=(events_one.shape[0] + events_two.shape[0], ), dtype=events_one.dtype)\n    count = analysis_functions.get_max_events_in_both_arrays(events_one, events_two, event_result)\n    return event_result[:count]", "response": "Calculates the maximum count of events that exist in both arrays."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmap the cluster hits on events to cluster.", "response": "def map_cluster(events, cluster):\n    \"\"\"\n    Maps the cluster hits on events. Not existing hits in events have all values set to 0\n\n    \"\"\"\n    cluster = np.ascontiguousarray(cluster)\n    events = np.ascontiguousarray(events)\n    mapped_cluster = np.zeros((events.shape[0], ), dtype=dtype_from_descr(data_struct.ClusterInfoTable))\n    mapped_cluster = np.ascontiguousarray(mapped_cluster)\n    analysis_functions.map_cluster(events, cluster, mapped_cluster)\n    return mapped_cluster"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_events_in_both_arrays(events_one, events_two):\n    events_one = np.ascontiguousarray(events_one)  # change memory alignement for c++ library\n    events_two = np.ascontiguousarray(events_two)  # change memory alignement for c++ library\n    event_result = np.empty_like(events_one)\n    count = analysis_functions.get_events_in_both_arrays(events_one, events_two, event_result)\n    return event_result[:count]", "response": "Calculates the events that exist in both arrays."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hist_1d_index(x, shape):\n    if len(shape) != 1:\n        raise InvalidInputError('The shape has to describe a 1-d histogram')\n\n    # change memory alignment for c++ library\n    x = np.ascontiguousarray(x.astype(np.int32))\n    result = np.zeros(shape=shape, dtype=np.uint32)\n    analysis_functions.hist_1d(x, shape[0], result)\n    return result", "response": "Fast 1d histogram of 1D indices with C ++ inner loop optimization."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfast 2d histogram of 2D indices with C ++ inner loop optimization.", "response": "def hist_2d_index(x, y, shape):\n    \"\"\"\n    Fast 2d histogram of 2D indices with C++ inner loop optimization.\n    Is more than 2 orders faster than np.histogram2d().\n    The indices are given in x, y coordinates and have to fit into a histogram of the dimensions shape.\n    Parameters\n    ----------\n    x : array like\n    y : array like\n    shape : tuple\n        tuple with x,y dimensions: (x, y)\n\n    Returns\n    -------\n    np.ndarray with given shape\n\n    \"\"\"\n    if len(shape) != 2:\n        raise InvalidInputError('The shape has to describe a 2-d histogram')\n\n    # change memory alignment for c++ library\n    x = np.ascontiguousarray(x.astype(np.int32))\n    y = np.ascontiguousarray(y.astype(np.int32))\n    result = np.zeros(shape=shape, dtype=np.uint32).ravel()  # ravel hist in c-style, 3D --> 1D\n    analysis_functions.hist_2d(x, y, shape[0], shape[1], result)\n    return np.reshape(result, shape)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfast 3D histogram of 3D indices with C ++ inner loop optimization.", "response": "def hist_3d_index(x, y, z, shape):\n    \"\"\"\n    Fast 3d histogram of 3D indices with C++ inner loop optimization.\n    Is more than 2 orders faster than np.histogramdd().\n    The indices are given in x, y, z coordinates and have to fit into a histogram of the dimensions shape.\n    Parameters\n    ----------\n    x : array like\n    y : array like\n    z : array like\n    shape : tuple\n        tuple with x,y,z dimensions: (x, y, z)\n\n    Returns\n    -------\n    np.ndarray with given shape\n\n    \"\"\"\n    if len(shape) != 3:\n        raise InvalidInputError('The shape has to describe a 3-d histogram')\n    # change memory alignment for c++ library\n    x = np.ascontiguousarray(x.astype(np.int32))\n    y = np.ascontiguousarray(y.astype(np.int32))\n    z = np.ascontiguousarray(z.astype(np.int32))\n    result = np.zeros(shape=shape, dtype=np.uint32).ravel()  # ravel hist in c-style, 3D --> 1D\n    analysis_functions.hist_3d(x, y, z, shape[0], shape[1], shape[2], result)\n    return np.reshape(result, shape)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the number of cluster in every given event.", "response": "def get_n_cluster_in_events(event_numbers):\n    '''Calculates the number of cluster in every given event.\n    An external C++ library is used since there is no sufficient solution in python possible.\n    Because of np.bincount # BUG #225 for values > int32 and the different handling under 32/64 bit operating systems.\n\n    Parameters\n    ----------\n    event_numbers : numpy.array\n        List of event numbers to be checked.\n\n    Returns\n    -------\n    numpy.array\n        First dimension is the event number.\n        Second dimension is the number of cluster of the event.\n    '''\n    logging.debug(\"Calculate the number of cluster in every given event\")\n    event_numbers = np.ascontiguousarray(event_numbers)  # change memory alignement for c++ library\n    result_event_numbers = np.empty_like(event_numbers)\n    result_count = np.empty_like(event_numbers, dtype=np.uint32)\n    result_size = analysis_functions.get_n_cluster_in_events(event_numbers, result_event_numbers, result_count)\n    return np.vstack((result_event_numbers[:result_size], result_count[:result_size])).T"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimporting and returns class for full class path string.", "response": "def import_class(import_path, name=None):\n    \"\"\"\n    Imports and returns class for full class path string.\n    Ex. 'foo.bar.Bogus' -> <class 'foo.bar.Bogus'>\n    \"\"\"\n    if not name:\n        import_path, name = import_path.rsplit('.', 1)\n    mod = import_module(import_path)\n    try:\n        return getattr(mod, name)\n    except AttributeError as e:\n        raise ImportError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef substitute_all(sp_object, pairs):\n    if not isinstance(pairs, dict):\n        dict_pairs = dict(pairs)\n    else:\n        dict_pairs = pairs\n\n    # we recurse if the object was a matrix so we apply substitution to all elements\n    if isinstance(sp_object, sympy.Matrix):\n        return sp_object.applyfunc(lambda x: substitute_all(x, dict_pairs))\n\n    try:\n        expr = sp_object.xreplace(dict_pairs)\n\n    # in sympy 0.7.2, this would not work, so we do it manually\n    except Exception:\n        expr =  sp_object\n        for (a,b) in dict_pairs.items():\n            expr = sympy.Subs(expr, a, b)\n        expr = expr.doit()\n    return expr", "response": "Substitute all elements in a single expression with all elements in pairs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts value to a sympy. Matrix object if possible.", "response": "def to_sympy_matrix(value):\n    \"\"\"\n    Converts value to a `sympy.Matrix` object, if possible.\n    Leaves the value as `sympy.Matrix` if it already was\n    :param value: value to convert\n    :return:\n    :rtype: `sympy.Matrix`\n    \"\"\"\n    if isinstance(value, sympy.Matrix):\n        return value\n    try:\n        return sympy.Matrix(value)\n    except ValueError as original_exception:\n        if isinstance(value, list) and len(value) and all([not isinstance(x, list) for x in value]):\n            # Let's try to convert the contents into a list\n            # (this is required for 0.7.4 if we pass in a list of strings)\n            # See `test_creation_of_column_matrix_from_list_of_strings` test\n            list_of_lists_value = [[x] for x in value]\n            try:\n                m = sympy.Matrix(list_of_lists_value)\n                return m\n            except Exception:\n                raise original_exception\n        else:\n            raise original_exception"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_sympy_column_matrix(matrix):\n    matrix = to_sympy_matrix(matrix)\n    if matrix.cols == 1:\n        return matrix\n    elif matrix.rows == 1:\n        return matrix.T\n    else:\n        raise ValueError('Cannot convert {0!r} to a column matrix'.format(matrix))", "response": "Converts a sympy matrix to a column matrix"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sympy_expressions_equal(expr1, expr2):\n    # the simplified difference is equal to zero: same expressions\n    try:\n        difference = sympy.simplify(sympy.expand(expr1 - expr2))\n    except SympifyError:\n        # Doing sympy.simplify(expr1 - expr2) raises an error if expr1 or expr2 is a matrix (for sympy 0.7.2)\n        if isinstance(expr1, sympy.Matrix) or isinstance(expr2, sympy.Matrix):\n            return _sympy_matrices_equal(expr1, expr2)\n        else:\n            raise\n\n    # sympy 0.7.4 returns matrix of zeros for equal matrices\n    try:\n        difference = sum(difference)\n    except TypeError:\n        pass\n\n    return difference == 0", "response": "Compare two sympy expressions that are not necessarily expanded and return True if the expressions are similar False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assert_sympy_expressions_equal(expr1, expr2):\n    if not sympy_expressions_equal(expr1, expr2):\n        raise AssertionError(\"{0!r} != {1!r}\".format(expr1, expr2))", "response": "Assert that expr1 and expr2 are equal."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompare two sympy matrices that are not necessarily expanded.", "response": "def _sympy_matrices_equal(matrix_left, matrix_right):\n    \"\"\"\n    Compare two sympy matrices that are not necessarily expanded.\n    Calls `deep_compare_expressions` for each element in the matrices.\n\n    Private function. Use `sympy_expressions_equal`.\n    The former should be able to compare everything.\n\n    :param matrix_left:\n    :param matrix_right:\n    :return:\n    \"\"\"\n    if matrix_left.cols != matrix_right.cols or matrix_left.rows != matrix_right.rows:\n        return False\n\n    for expression_left, expression_right in zip(matrix_left, matrix_right):\n        if not sympy_expressions_equal(expression_left, expression_right):\n            return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncompares two expressions by replacing all symbols by a set of arbitrary expressions and return True if they are empirically equal False otherwise.", "response": "def sympy_empirical_equal(expr1, expr2):\n\n    \"\"\"\n    Compare long , complex, expressions by replacing all symbols by a set of arbitrary expressions\n\n    :param expr1: first expression\n    :param expr2: second expression\n    :return: True if expressions are empirically equal, false otherwise\n    \"\"\"\n\n    atoms_1 = expr1.atoms()\n    atoms_1 = [a for a in atoms_1 if isinstance(a,sympy.Symbol)]\n    atoms_2 = expr2.atoms()\n    atoms_2 = [a for a in atoms_2 if isinstance(a,sympy.Symbol)]\n\n\n    # lets us merge symbol in case one equation has more / different symbols\n    atoms = set(atoms_1 + atoms_2)\n\n\n    arbitrary_values = []\n    arbitrary_values.append([i * 7.1 for i in range(1,len(atoms)+1)])\n    arbitrary_values.append([i / 9.3 for i in range(1,len(atoms)+1)])\n    arbitrary_values.append([i ** 2 for i in range(1,len(atoms)+1)])\n\n    # test for arbitrary value. return false at the first failure\n    for av in arbitrary_values:\n        if not _eval_res_equal(expr1, expr2, atoms, av):\n            return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_absolute(self):\n        return self.namespace and self.ext and self.scheme and self.path", "response": "Checks that the URI is absolute."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nround the current quotient.", "response": "def _round(\n       cls,\n       quotient,\n       divisor,\n       remainder,\n       base,\n       method=RoundingMethods.ROUND_DOWN\n    ):\n        \"\"\"\n        Round the quotient.\n\n        :param quotient: current quotient\n        :type quotient: list of int\n        :param int divisor: the divisor\n        :param int remainder: the remainder\n        :param int base: the base\n        :param method: the rounding method\n        :raises BasesValueError:\n\n        :returns: carry-out digit, non_repeating and repeating parts\n        :rtype: tuple of int * list of int * list of int * int\n\n        Complexity: O(len(quotient))\n        \"\"\"\n        # pylint: disable=too-many-return-statements\n        # pylint: disable=too-many-arguments\n        if method not in RoundingMethods.METHODS():\n            raise BasesValueError(\n               method,\n               \"method\",\n               \"must be one of RoundingMethods.METHODS\"\n            )\n\n        if remainder == 0: # pragma: no cover\n            return (0, quotient, [], 0)\n\n        if method is RoundingMethods.ROUND_DOWN:\n            return (0, quotient, [], -1)\n        if method is RoundingMethods.ROUND_TO_ZERO:\n            return (0, quotient, [], -1)\n        if method is RoundingMethods.ROUND_UP:\n            (carry, quotient) = Nats.carry_in(quotient, 1, base)\n            return (carry, quotient, [], 1)\n\n        remainder = fractions.Fraction(remainder, divisor)\n        middle = fractions.Fraction(base, 2)\n        if remainder < middle:\n            return (0, quotient, [], -1)\n        if remainder > middle:\n            (carry, quotient) = Nats.carry_in(quotient, 1, base)\n            return (carry, quotient, [], 1)\n\n        if method is RoundingMethods.ROUND_HALF_UP:\n            (carry, quotient) = Nats.carry_in(quotient, 1, base)\n            return (carry, quotient, [], 1)\n        if method in \\\n           (RoundingMethods.ROUND_HALF_DOWN,\n            RoundingMethods.ROUND_HALF_ZERO):\n            return (0, quotient, [], -1)\n\n        raise BasesValueError( # pragma: no cover\n           method,\n           \"method\",\n           \"must be one of RoundingMethods.METHODS\"\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _divide(divisor, remainder, quotient, remainders, base, precision=None):\n        # pylint: disable=too-many-arguments\n\n        indices = itertools.count() if precision is None else range(precision)\n\n        for _ in indices:\n            if remainder == 0 or remainder in remainders:\n                break\n            remainders.append(remainder)\n            (quot, rem) = divmod(remainder, divisor)\n            quotient.append(quot)\n            if quot > 0:\n                remainder = rem * base\n            else:\n                remainder = remainder * base\n        return remainder", "response": "This function is used to divide a divisor and dividend into two parts of the base and quotient."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _fractional_division(\n       cls,\n       divisor,\n       remainder,\n       base,\n       precision=None,\n       method=RoundingMethods.ROUND_DOWN\n    ):\n        \"\"\"\n        Get the repeating and non-repeating part.\n\n        :param int divisor: the divisor\n        :param int remainder: the remainder\n        :param int base: the base\n        :param precision: maximum number of fractional digits\n        :type precision: int or NoneType\n        :param method: rounding method\n        :type method: element of RoundignMethods.METHODS\n\n        :returns: carry-out digit, non_repeating and repeating parts\n        :rtype: tuple of int * list of int * list of int * int\n\n        :raises BasesValueError:\n\n        Complexity: O(precision) if precision is not None else O(divisor)\n        \"\"\"\n        # pylint: disable=too-many-arguments\n        quotient = []\n        remainders = []\n        remainder = cls._divide(\n           divisor,\n           remainder * base,\n           quotient,\n           remainders,\n           base,\n           precision\n        )\n\n        if remainder == 0:\n            return (0, quotient, [], 0)\n        if remainder in remainders:\n            start = remainders.index(remainder)\n            return (0, quotient[:start], quotient[start:], 0)\n        return cls._round(\n           quotient,\n           divisor,\n           remainder,\n           base,\n           method\n        )", "response": "Internal function that returns the fractional divide of the base and remainder of the base and the remainder of the base."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the quotient and remainder :param int divisor: the divisor :param dividend: the divident :type dividend: sequence of int :param int remainder: initial remainder :param int base: the base :returns: quotient and remainder :rtype: tuple of (list of int) * int Complexity: O(log_{divisor}(quotient))", "response": "def _division(divisor, dividend, remainder, base):\n        \"\"\"\n        Get the quotient and remainder\n\n        :param int divisor: the divisor\n        :param dividend: the divident\n        :type dividend: sequence of int\n        :param int remainder: initial remainder\n        :param int base: the base\n\n        :returns: quotient and remainder\n        :rtype: tuple of (list of int) * int\n\n        Complexity: O(log_{divisor}(quotient))\n        \"\"\"\n        quotient = []\n        for value in dividend:\n            remainder = remainder * base + value\n            (quot, rem) = divmod(remainder, divisor)\n            quotient.append(quot)\n            if quot > 0:\n                remainder = rem\n        return (quotient, remainder)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the divisor and dividend that yield component parts.", "response": "def undivision(\n       cls,\n       integer_part,\n       non_repeating_part,\n       repeating_part,\n       base\n    ):\n        \"\"\"\n        Find divisor and dividend that yield component parts.\n\n        :param integer_part: the integer part\n        :type integer_part: list of int\n        :param non_repeating_part: the non_repeating_part\n        :type non_repeating_part: list of int\n        :param repeating_part: the repeating part\n        :type repeating_part: list of int\n        :param int base: the base\n\n        :returns: divisor and dividend in lowest terms\n        :rtype: tuple of list of int * list of int\n\n        Complexity: O(len(non_repeating_part + repeating_part + integer_part))\n        \"\"\"\n        if base < 2:\n            raise BasesValueError(base, \"base\", \"must be at least 2\")\n\n        if any(x < 0 or x >= base for x in integer_part):\n            raise BasesValueError(\n               integer_part,\n               \"integer_part\",\n               \"for all elements, e, 0 <= e < base required\"\n            )\n\n        if any(x < 0 or x >= base for x in non_repeating_part):\n            raise BasesValueError(\n               non_repeating_part,\n               \"non_repeating_part\",\n               \"for all elements, e, 0 <= e < base required\"\n            )\n\n        if any(x < 0 or x >= base for x in repeating_part):\n            raise BasesValueError(\n               repeating_part,\n               \"repeating_part\",\n               \"for all elements, e, 0 <= e < base required\"\n            )\n\n        shift_length = len(repeating_part)\n        frac_length = len(non_repeating_part)\n\n        top = fractions.Fraction(\n           Nats.convert_to_int(\n              integer_part + non_repeating_part + repeating_part,\n              base\n           ),\n           base ** frac_length\n        )\n\n        if shift_length == 0:\n            return (\n               Nats.convert_from_int(top.denominator, base),\n               Nats.convert_from_int(top.numerator, base)\n            )\n\n        bottom = fractions.Fraction(\n           Nats.convert_to_int(integer_part + non_repeating_part, base),\n           base ** frac_length\n        )\n        result = (top - bottom) / ((base ** shift_length) - 1)\n        return (\n           Nats.convert_from_int(result.denominator, base),\n           Nats.convert_from_int(result.numerator, base)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_catalog_lookup_session(self):\n        if not self.supports_catalog_lookup():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CatalogLookupSession(runtime=self._runtime)", "response": "Gets the catalog lookup session."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_catalog_query_session(self):\n        if not self.supports_catalog_query():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CatalogQuerySession(runtime=self._runtime)", "response": "Gets the catalog query session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the catalog administrative session for creating updating and deleting catalogs.", "response": "def get_catalog_admin_session(self, proxy):\n        \"\"\"Gets the catalog administrative session for creating, updating and deleting catalogs.\n\n        arg:    proxy (osid.proxy.Proxy): a proxy\n        return: (osid.cataloging.CatalogAdminSession) - a\n                ``CatalogAdminSession``\n        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_catalog_admin()`` is\n                ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_catalog_admin()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_catalog_admin():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CatalogAdminSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_catalog_hierarchy_session(self, proxy):\n        if not self.supports_catalog_hierarchy():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CatalogHierarchySession(proxy=proxy, runtime=self._runtime)", "response": "Gets the catalog hierarchy traversal session."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the catalog hierarchy design session.", "response": "def get_catalog_hierarchy_design_session(self, proxy):\n        \"\"\"Gets the catalog hierarchy design session.\n\n        arg:    proxy (osid.proxy.Proxy): proxy\n        return: (osid.cataloging.CatalogHierarchyDesignSession) - a\n                ``CatalogHierarchyDesignSession``\n        raise:  NullArgument - ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_catalog_hierarchy_design()``\n                is ``false``\n        *compliance: optional -- This method must be implemented if\n        ``supports_catalog_hierarchy_design()`` is ``true``.*\n\n        \"\"\"\n        if not self.supports_catalog_hierarchy_design():\n            raise errors.Unimplemented()\n        # pylint: disable=no-member\n        return sessions.CatalogHierarchyDesignSession(proxy=proxy, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_edxml_with_aws_urls(self):\n        edxml = self.get_text().text\n\n        soup = BeautifulSoup(edxml, 'xml').find('html')\n        if soup is None:\n            soup = BeautifulSoup('', 'xml')\n            soup.append(BeautifulSoup(edxml, 'html5lib'))\n\n        attrs = {\n            'draggable': ['icon'],\n            'drag_and_drop_input': ['img'],\n            'files': ['included_files'],\n            'img': ['src'],\n            'a': ['href'],\n            'script': ['src'],\n            'video': ['sub', 'youtube', 'youtube_id_1_0'],\n            'encoded_video': ['url']\n        }\n        # replace all file listings with an appropriate path...\n        for key, attributes in attrs.items():\n            for attr in attributes:\n                local_regex = re.compile('^repository.Asset')\n                search = {attr: local_regex}\n                tags = soup.find_all(**search)\n                for item in tags:\n                    asset_id = item[attr]\n                    asset_content = self._get_asset_content(Id(asset_id))\n                    item[attr] = asset_content.get_url()\n        if '<video>' in edxml:\n            return soup.find('video').prettify()\n        elif '<videoalpha' in edxml:\n            return soup.find('videoalpha').prettify()\n        elif '<discussion>' in edxml:\n            return soup.find('discussion').prettify()\n        else:\n            return soup.prettify()", "response": "get_edxml_with_aws_urls - returns the edxml with the aws urls"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the internal map of the fields.", "response": "def _init_map(self):\n        \"\"\"stub\"\"\"\n        super(edXAssetContentFormRecord, self)._init_map()\n        AssetContentTextFormRecord._init_map(self)\n        FilesFormRecord._init_map(self)\n        ProvenanceFormRecord._init_map(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the metadata for this asset content form record.", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        super(edXAssetContentFormRecord, self)._init_metadata()\n        AssetContentTextFormRecord._init_metadata(self)\n        FilesFormRecord._init_metadata(self)\n        ProvenanceFormRecord._init_metadata(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef regenerate_prefixes(self, *args):\n        nick = self.controller.client.user.nick\n        self.prefixes = set([\n            nick + \": \",\n            nick + \", \",\n            nick + \" - \",\n        ])\n        # Include lower-case versions as well, but not caps\n        self.prefixes.update([p.lower() for p in self.prefixes])\n        if self.sigil:\n            self.prefixes.add(self.sigil)", "response": "Regenerate the cache of command prefixes based on nick etc."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines whether this line is addressing us.", "response": "def check_for_interest(self, client, recipient, message):\n        \"\"\"Determine whether this line is addressing us.\"\"\"\n        for prefix in self.prefixes:\n            if message.startswith(prefix):\n                return True, message[len(prefix):]\n\n        # Don't require a prefix if addressed in PM.\n        # This comes after the prefix checks because\n        # if the user does include a prefix, we want\n        # to strip it, even in PM.\n        if not isinstance(recipient, Channel):\n            return True, message\n\n        return False, None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_command(self, string):\n        possible_command, _, rest = string.partition(\" \")\n        # Commands are case-insensitive, stored as lowercase\n        possible_command = possible_command.lower()\n        if possible_command not in self.commands:\n            return None, None\n\n        event = self.commands[possible_command][\"event\"]\n        args = shlex.split(rest.strip())\n        return event, args", "response": "Parse out any possible valid command from an input string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef waveform_image(mediafile, xy_size, outdir=None, center_color=None, outer_color=None, bg_color=None):\n    try:\n        import waveform\n    except ImportError, exc:\n        raise ImportError(\"%s [get it at https://github.com/superjoe30/PyWaveform]\" % exc)\n\n    outdir = outdir or os.path.dirname(mediafile)\n    outfile = os.path.join(outdir, os.path.splitext(os.path.basename(mediafile))[0] + \".png\")\n\n    with transcode.to_wav(mediafile) as wavfile:\n        # Draw using a gradient\n        waveform.draw(wavfile, outfile, xy_size, \n            bgColor=bg_color or WAVE_BG_COLOR,\n            fgGradientCenter=center_color or WAVE_CENTER_COLOR, \n            fgGradientOuter=outer_color or WAVE_OUTER_COLOR)\n\n    return outfile", "response": "Create a waveform image from audio data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef waveform_stack(mediafiles, xy_size, output=None, label_style=None, \n        center_color=None, outer_color=None, bg_color=None):\n    \"\"\" Create a stack of waveform images from audio data.\n        Return path to created image file.\n    \"\"\"\n    img_files = []\n    output = output or os.path.abspath(os.path.dirname(os.path.commonprefix(mediafiles)))\n    if os.path.isdir(output):\n        output = os.path.join(output, \"waveforms.jpg\")\n    cmd = [config.CMD_IM_MONTAGE] + shlex.split(label_style or WAVE_LABEL_STYLE)\n    cmd += [\"-tile\", \"1x%d\" % len(mediafiles), \"-geometry\", \"%dx%d\" % xy_size, \"-label\", \"%t\"]\n\n    try:\n        tempdir = tempfile.mktemp(__name__)\n        os.makedirs(tempdir) \n\n        for mediafile in sorted(mediafiles):\n            img_files.append(waveform_image(mediafile, xy_size, tempdir, center_color, outer_color, bg_color))\n\n        cmd.extend(img_files)\n        cmd.append(output)\n        subprocess.check_call(cmd, stdout=open(os.devnull, \"wb\"), stderr=subprocess.STDOUT)\n    finally:\n        if os.path.isdir(tempdir):\n            shutil.rmtree(tempdir, ignore_errors=True)\n\n    return output", "response": "Create a stack of waveform images from audio data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _main():\n    if len(sys.argv) <= 1:\n        print(\"Usage: python -m auvyon.imaging.waveforms <mediafile>...\")\n    else:\n        try:\n            print(\"Created %s\" % waveform_stack(sys.argv[1:], (640, 48)))\n        except subprocess.CalledProcessError, exc:\n            print(\"Conversion error: %s\" % exc)", "response": "Command line interface for testing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmangle the names tree.", "response": "def mangle(tree, toplevel=False):\n    \"\"\"Mangle names.\n\n    Args:\n        toplevel: defaults to False. Defines if global\n        scope should be mangled or not.\n    \"\"\"\n    sym_table = SymbolTable()\n    visitor = ScopeTreeVisitor(sym_table)\n    visitor.visit(tree)\n\n    fill_scope_references(tree)\n    mangle_scope_tree(sym_table.globals, toplevel)\n\n    mangler = NameManglerVisitor()\n    mangler.visit(tree)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the match value for the string", "response": "def _get_string_match_value(self, string, string_match_type):\n        \"\"\"Gets the match value\"\"\"\n        if string_match_type == Type(**get_type_data('EXACT')):\n            return string\n        elif string_match_type == Type(**get_type_data('IGNORECASE')):\n            return re.compile('^' + string, re.I)\n        elif string_match_type == Type(**get_type_data('WORD')):\n            return re.compile('.*' + string + '.*')\n        elif string_match_type == Type(**get_type_data('WORDIGNORECASE')):\n            return re.compile('.*' + string + '.*', re.I)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _add_match(self, match_key, match_value, match):\n        if match_key is None:\n            raise NullArgument()\n        if match is None:\n            match = True\n        if match:\n            inin = '$in'\n        else:\n            inin = '$nin'\n        if match_key in self._query_terms:\n            if inin in self._query_terms[match_key]:\n                self._query_terms[match_key][inin].append(match_value)\n            else:\n                self._query_terms[match_key][inin] = [match_value]\n        else:\n            self._query_terms[match_key] = {inin: [match_value]}", "response": "Adds a match key value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmatches a display text value", "response": "def _match_display_text(self, element_key, string, string_match_type, match):\n        \"\"\"Matches a display text value\"\"\"\n        if string is None or string_match_type is None:\n            raise NullArgument()\n        match_value = self._get_string_match_value(string, string_match_type)\n        self._add_match(element_key + '.text', match_value, match)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _match_minimum_decimal(self, match_key, decimal_value, match):\n        if decimal_value is None:\n            raise NullArgument()\n        if match is None:\n            match = True\n        if match:\n            gtelt = '$gte'\n        else:\n            gtelt = '$lt'\n        if match_key in self._query_terms:\n            self._query_terms[match_key][gtelt] = decimal_value\n        else:\n            self._query_terms[match_key] = {gtelt: decimal_value}", "response": "Matches a minimum decimal value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _match_maximum_decimal(self, match_key, decimal_value, match):\n        if decimal_value is None:\n            raise NullArgument()\n        if match is None:\n            match = True\n        if match:\n            ltegt = '$lte'\n        else:\n            ltegt = '$gt'\n        if match_key in self._query_terms:\n            self._query_terms[match_key][ltegt] = decimal_value\n        else:\n            self._query_terms[match_key] = {ltegt: decimal_value}", "response": "Matches a minimum decimal value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _filter_settings(settings, prefix):\n    ret = {}\n    for skey in settings.keys():\n        if skey.startswith(prefix):\n            key = skey[len(prefix):]\n            ret[key] = settings[skey]\n    return ret", "response": "Filter all settings to only return settings that start with a certain\n    prefix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_capakey(registry):\n    # argument might be a config or a request\n    regis = getattr(registry, 'registry', None)\n    if regis is None:\n        regis = registry\n\n    return regis.queryUtility(ICapakey)", "response": "Get the Capakey Gateway"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_crab(registry):\n    # argument might be a config or a request\n    regis = getattr(registry, 'registry', None)\n    if regis is None:\n        regis = registry\n\n    return regis.queryUtility(ICrab)", "response": "Get the Crab Gateway object from the specified Registry object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_route(config, name, pattern, *args, **kwargs):\n    config.add_route(name, pattern, *args, **kwargs)\n    GENERATE_ETAG_ROUTE_NAMES.add(name)", "response": "Add a pyramid route to the config."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a Tween that adds ETag headers and tells Pyramid to enable conditional responses where appropriate.", "response": "def conditional_http_tween_factory(handler, registry):\n    \"\"\"\n    Tween that adds ETag headers and tells Pyramid to enable \n    conditional responses where appropriate.\n    \"\"\"\n    settings = registry.settings if hasattr(registry, 'settings') else {}\n    if 'generate_etag_for.list' in settings:\n        route_names = settings.get('generate_etag_for.list').split()\n        GENERATE_ETAG_ROUTE_NAMES.update(route_names)\n\n    def conditional_http_tween(request):\n        response = handler(request)\n\n        if request.matched_route.name in GENERATE_ETAG_ROUTE_NAMES:\n\n            # If the Last-Modified header has been set, we want to enable the\n            # conditional response processing.\n            if response.last_modified is not None:\n                response.conditional_response = True\n\n            # We want to only enable the conditional machinery if either we\n            # were given an explicit ETag header by the view or we have a\n            # buffered response and can generate the ETag header ourself.\n            if response.etag is not None:\n                response.conditional_response = True\n            elif (isinstance(response.app_iter, Sequence) and\n                          len(response.app_iter) == 1) and response.body is not None:\n                response.conditional_response = True\n                response.md5_etag()\n\n        return response\n\n    return conditional_http_tween"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninclude crabpy_pyramid in this Pyramid application.", "response": "def includeme(config):\n    \"\"\"\n    Include `crabpy_pyramid` in this `Pyramid` application.\n\n    :param pyramid.config.Configurator config: A Pyramid configurator.\n    \"\"\"\n\n    settings = _parse_settings(config.registry.settings)\n    base_settings = _get_proxy_settings(settings)\n\n    # http caching tween\n    if not settings.get('etag_tween_disabled', False):\n        config.add_tween('crabpy_pyramid.conditional_http_tween_factory')\n\n    # create cache\n    root = settings.get('cache.file.root', '/tmp/dogpile_data')\n    if not os.path.exists(root):\n        os.makedirs(root)\n\n    capakey_settings = dict(_filter_settings(settings, 'capakey.'),\n                            **base_settings)\n    if 'include' in capakey_settings:\n        log.info(\"The 'capakey.include' setting is deprecated. Capakey will \"\n                 \"always be included.\")\n    log.info('Adding CAPAKEY Gateway.')\n    config.add_renderer('capakey_listjson', capakey_json_list_renderer)\n    config.add_renderer('capakey_itemjson', capakey_json_item_renderer)\n    _build_capakey(config.registry, capakey_settings)\n    config.add_request_method(get_capakey, 'capakey_gateway')\n    config.add_directive('get_capakey', get_capakey)\n    config.include('crabpy_pyramid.routes.capakey')\n    config.scan('crabpy_pyramid.views.capakey')\n\n    crab_settings = dict(_filter_settings(settings, 'crab.'), **base_settings)\n    if crab_settings['include']:\n        log.info('Adding CRAB Gateway.')\n        del crab_settings['include']\n        config.add_renderer('crab_listjson', crab_json_list_renderer)\n        config.add_renderer('crab_itemjson', crab_json_item_renderer)\n        _build_crab(config.registry, crab_settings)\n        config.add_directive('get_crab', get_crab)\n        config.add_request_method(get_crab, 'crab_gateway')\n        config.include('crabpy_pyramid.routes.crab')\n        config.scan('crabpy_pyramid.views.crab')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the assessment part list resulting from a search.", "response": "def get_assessment_parts(self):\n        \"\"\"Gets the ``AssessmentPartList`` resulting from a search.\n\n        return: (osid.assessment.authoring.AssessmentPartList) - the\n                assessment part list\n        raise:  IllegalState - list has already been retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.AssessmentPartList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the SequenceRuleList resulting from a search.", "response": "def get_sequence_rules(self):\n        \"\"\"Gets the ``SequenceRuleList`` resulting from a search.\n\n        return: (osid.assessment.authoring.SequenceRuleList) - the\n                sequence rule list\n        raise:  IllegalState - list has already been retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.SequenceRuleList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the distance landscape jointly generated from all the results.", "response": "def plot_distance_landscape_projection(self, x_axis, y_axis, ax=None, *args, **kwargs):\n        \"\"\"\n        Plots the distance landscape jointly-generated from all the results\n\n        :param x_axis: symbol to plot on x axis\n        :param y_axis: symbol to plot on y axis\n        :param ax: axis object to plot onto\n        :param args: arguments to pass to :func:`matplotlib.pyplot.contourf`\n        :param kwargs: keyword arguments to pass to :func:`matplotlib.pyplot.contourf`\n        :return:\n        \"\"\"\n\n        # Gather all x, y, z's to plot first as this would make the gradient landscape better\n        x_all, y_all, z_all = [], [], []\n        for result in self.results:\n            x, y, z = result.distance_landscape_as_3d_data(x_axis, y_axis)\n            x_all.extend(x)\n            y_all.extend(y)\n            z_all.extend(z)\n\n        # Now plot the contour for x_all, y_all and z_all\n        plot_contour(x_all, y_all, z_all, x_axis, y_axis, ax=ax, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot the trajectory projection on the specified x and y axes.", "response": "def plot_trajectory_projection(self, x_axis, y_axis,\n                                   *args, **kwargs):\n        \"\"\"\n        Plots trajectory projection on the specified x and y axes\n        See :meth:`InferenceResult.plot_trajectory_projection()` for information on the arguments and keyword arguments\n\n        :param x_axis: variable to be plotted on the x axis of the projection\n        :param y_axis: variable to be plotted on the y axis of the projection\n        :param args: arguments to be passed to :meth:`InferenceResult.plot_trajectory_projection()`\n        :param kwargs: keyword arguments to be passed to :meth:`InferenceResult.plot_trajectory_projection()`\n        \"\"\"\n        # Just plot all of the trajectories\n        for result in self.results:\n            result.plot_trajectory_projection(x_axis, y_axis,\n                                              *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef distance_landscape_as_3d_data(self, x_axis, y_axis):\n        if not self.distance_landscape:\n            raise Exception('No distance landscape returned. Re-run inference with return_distance_landscape=True')\n\n        index_x = self.parameter_index(x_axis)\n        index_y = self.parameter_index(y_axis)\n\n        x = []\n        y = []\n        z = []\n        for parameters, initial_conditions, distance in self.distance_landscape:\n            all_values = list(parameters) + list(initial_conditions)\n            x.append(all_values[index_x])\n            y.append(all_values[index_y])\n            z.append(distance)\n\n        return x, y, z", "response": "Returns the distance landscape as three - dimensional data for the specified projection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_distance_landscape_projection(self, x_axis, y_axis, ax=None, *args, **kwargs):\n        x, y, z = self.distance_landscape_as_3d_data(x_axis, y_axis)\n        plot_contour(x, y, z, x_axis, y_axis, ax=ax, *args, **kwargs)", "response": "Plots the projection of distance landscape onto the contourf plot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the inference result. solutions as a plottable 2d trajectory.", "response": "def solutions_as_2d_trajectories(self, x_axis, y_axis):\n        \"\"\"\n        Returns the :attr:`InferenceResult.solutions` as a plottable 2d trajectory.\n\n        :param x_axis: the variable to be on the x axis of projection\n        :param y_axis: the variable to be on the y axis of preojection\n        :return: a tuple x, y specifying lists of x and y coordinates of projection\n        \"\"\"\n        if not self.solutions:\n            raise Exception('No intermediate solutions returned. '\n                            'Re-run inference with return_intermediate_solutions=True')\n\n        index_x = self.parameter_index(x_axis)\n        index_y = self.parameter_index(y_axis)\n\n        x, y = [], []\n        for parameters, initial_conditions in self.solutions:\n            all_values = parameters + initial_conditions\n            x.append(all_values[index_x])\n            y.append(all_values[index_y])\n\n        return x, y"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the projection of the trajectory through the parameter space.", "response": "def plot_trajectory_projection(self, x_axis, y_axis,\n                                   legend=False, ax=None,\n                                   start_and_end_locations_only=False,\n                                   start_marker='bo',\n                                   end_marker='rx',\n                                   *args, **kwargs):\n        \"\"\"\n        Plots the projection of the trajectory through the parameter space the minimisation algorithm took.\n\n        Since parameter space is often high-dimensional and paper can realistically represent only two,\n        one needs to specify the ``x_axis``, and ``y_axis`` arguments with the variable names to project the\n        high-dimensional grid, on, i.e. ``x_axis='c_1'``, ``y_axis='c_4'``\n\n        :param x_axis: variable name (parameter or left hand side of equation) to project x axis onto\n        :type x_axis: str|:class:`~sympy.Symbol`\n        :param y_axis: variable name to project y axis onto\n        :type y_axis: str|:class:`~sympy.Symbol`\n        :param legend: Whether to display legend or not\n        :type legend: bool\n        :param ax: Axis to plot onto (defaults to :func:`matplotlib.pyplot.gca` if not set)\n        :param start_and_end_locations_only: If set to true, will not plot the trajectory, but only start and end parameter\n        :param start_marker: The marker to use for start of trajectory, defaults to blue circle\n        :param end_marker: The marker to use for end of trajectory, defaults to red x\n        :param args: Arguments to pass to :func:`matplotlib.pyplot.plot` function\n        :param kwargs: Keyword arguments to pass to :func:`matplotlib.pyplot.plot` function\n        \"\"\"\n\n        x, y = self.solutions_as_2d_trajectories(x_axis, y_axis)\n\n        plot_2d_trajectory(x, y,\n                           x_label=x_axis, y_label=y_axis,\n                           legend=legend,\n                           ax=ax,\n                           start_and_end_locations_only=start_and_end_locations_only,\n                           start_marker=start_marker,\n                           end_marker=end_marker,\n                           *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn dictionary representation of type.", "response": "def get_type_data(name):\n    \"\"\"Return dictionary representation of type.\n\n    Can be used to initialize primordium.type.primitives.Type\n\n    \"\"\"\n    name = name.upper()\n    try:\n        return {\n            'authority': 'birdland.mit.edu',\n            'namespace': 'coordinate format',\n            'identifier': name,\n            'domain': 'Coordinate Format Types',\n            'display_name': JEFFS_COORDINATE_FORMAT_TYPES[name] + ' Coordinate Format Type',\n            'display_label': JEFFS_COORDINATE_FORMAT_TYPES[name],\n            'description': ('The type for the ' +\n                            JEFFS_COORDINATE_FORMAT_TYPES[name] +\n                            ' Geographic coordinate format.')\n        }\n    except KeyError:\n        raise NotFound('CoordinateFormat Type: ' + name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_next_type(self):\n        import sys\n        from ..osid.osid_errors import IllegalState, OperationFailed\n        try:\n            next_item = self.next()\n        except StopIteration:\n            raise IllegalState('no more elements available in this list')\n        except:  # Need to specify exceptions here\n            raise OperationFailed()\n        else:\n            return next_item", "response": "Gets the next Type in this list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_next_types(self, n=None):\n        import sys\n        from ..osid.osid_errors import IllegalState, OperationFailed\n        if n > self.available():\n            # !!! This is not quite as specified (see method docs) !!!\n            raise IllegalState('not enough elements available in this list')\n        else:\n            next_list = []\n            x = 0\n            while x < n:\n                try:\n                    next_list.append(self.next())\n                except:  # Need to specify exceptions here\n                    raise OperationFailed()\n                x = x + 1\n            return next_list", "response": "Gets the next set of types in this list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_short_reads(vals):\n   (args,txome,seed,chunk) = vals\n   #fast forward some ammount\n   \"\"\"Emit the short reads first\"\"\"\n   txe = TranscriptomeEmitter(txome,TranscriptomeEmitter.Options(seed=seed))\n   if args.weights:\n      weights = {}\n      if args.weights[-3:]=='.gz': inf = gzip.open(args.weights)\n      else: inf = open(args.weights)\n      for line in inf:\n         f = line.rstrip().split(\"\\t\")\n         weights[f[0]] = float(f[1])\n      txs = {}\n      for tx in txome.transcripts: txs[tx.name] = tx.length\n      for name in weights:\n         weights[name] *= txs[name]\n      txe.set_weights_by_dict(weights)\n   else:\n      weights = {}\n      txs = {}\n      for tx in txome.transcripts: txs[tx.name] = tx.length\n      txe.set_weights_by_dict(weights)\n   reademit = ReadEmitter(txe)\n   shortreads = []\n   sp = args.short_read_insert_size\n   reademit.cutter.set_custom(sp[0],sp[1],sp[2])\n   if args.short_read_error_rate: \n      emfr = ErrorMakerFlatRate(rate=args.short_read_error_rate,rand=reademit.options.rand)\n      reademit.add_error_maker(emfr)\n   for i in range(0,chunk):\n      e = reademit.emit(args.short_read_length)\n      shortreads.append(e)\n   return shortreads", "response": "Emit the short reads first"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_image(self, conf, images, chain=None, parent_chain=None, made=None, ignore_deps=False, ignore_parent=False, pushing=False):\n        made = {} if made is None else made\n        chain = [] if chain is None else chain\n        parent_chain = [] if parent_chain is None else parent_chain\n\n        if conf.name in made:\n            return\n\n        if conf.name in chain and not ignore_deps:\n            raise BadCommand(\"Recursive dependency images\", chain=chain + [conf.name])\n\n        if conf.name in parent_chain and not ignore_parent:\n            raise BadCommand(\"Recursive FROM statements\", chain=parent_chain + [conf.name])\n\n        if conf.name not in images:\n            raise NoSuchImage(looking_for=conf.name, available=images.keys())\n\n        if not ignore_deps:\n            for dependency, image in conf.dependency_images():\n                self.make_image(images[dependency], images, chain=chain + [conf.name], made=made, pushing=pushing)\n\n        if not ignore_parent:\n            for dep in conf.commands.dependent_images:\n                if not isinstance(dep, six.string_types):\n                    self.make_image(dep, images, chain, parent_chain + [conf.name], made=made, pushing=pushing)\n\n        # Should have all our dependencies now\n        log.info(\"Making image for '%s' (%s)\", conf.name, conf.image_name)\n        cached = self.build_image(conf, pushing=pushing)\n        made[conf.name] = True\n        return cached", "response": "Make an image and return the cache entry"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding layers of images", "response": "def layered(self, images, only_pushable=False):\n        \"\"\"Yield layers of images\"\"\"\n        if only_pushable:\n            operate_on = dict((image, instance) for image, instance in images.items() if instance.image_index)\n        else:\n            operate_on = images\n\n        layers = Layers(operate_on, all_images=images)\n        layers.add_all_to_layers()\n        for layer in layers.layered:\n            buf = []\n            for image_name, image in layer:\n                if image.image_index:\n                    buf.append((image_name, image))\n            if buf:\n                yield buf"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes metadata for shuffle", "response": "def _init_metadata(self):\n        \"\"\"stub\"\"\"\n        self._shuffle_metadata = {\n            'element_id': Id(self.my_osid_object_form._authority,\n                             self.my_osid_object_form._namespace,\n                             'shuffle'),\n            'element_label': 'Shuffle',\n            'instructions': 'Shuffle parameters',\n            'required': True,\n            'read_only': False,\n            'linked': True,\n            'array': False,\n            'default_boolean_values': [True],\n            'syntax': 'BOOLEAN',\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _is_match(self, response, answer):\n        # TODO: this varies depending on question type\n        if self._only_generic_right_feedback():\n            return str(answer.genus_type) == str(RIGHT_ANSWER_GENUS)\n        elif self._is_multiple_choice():\n            return MultiChoiceItemRecord._is_match(self, response, answer)\n        elif self._is_image_sequence() or self._is_mw_sentence():\n            return OrderedChoiceItemRecord._is_match(self, response, answer)\n        elif self._is_numeric_response():\n            return CalculationInteractionItemRecord._is_match(self, response, answer)\n        elif self._is_fitb():\n            return MagicRandomizedInlineChoiceItemRecord._is_match(self, response, answer)\n        return False", "response": "For MC can call through to MultiChoice Item Record?"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_authorizations(self):\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.AuthorizationList(self._results, runtime=self._runtime)", "response": "Gets the authorization list resulting from the search."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the vault list resulting from the search.", "response": "def get_vaults(self):\n        \"\"\"Gets the vault list resulting from the search.\n\n        return: (osid.authorization.VaultList) - the vault list\n        raise:  IllegalState - list has already been retrieved\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        if self.retrieved:\n            raise errors.IllegalState('List has already been retrieved.')\n        self.retrieved = True\n        return objects.VaultList(self._results, runtime=self._runtime)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the grade associated with the knowledge dimension.", "response": "def get_knowledge_category(self):\n        \"\"\"Gets the grade associated with the knowledge dimension.\n\n        return: (osid.grading.Grade) - the grade\n        raise:  IllegalState - has_knowledge_category() is false\n        raise:  OperationFailed - unable to complete request\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if not self.has_knowledge_category():\n            raise IllegalState()\n        else:\n            return Grade(self._get_grade_map(self._my_map['knowledgeCategoryId'])),"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_cognitive_process(self):\n        if not self.has_cognitive_process():\n            raise IllegalState()\n        else:\n            return Grade(self._get_grade_map(self._my_map['cognitiveProcessId'])),", "response": "Gets the grade associated with the cognitive process."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_assessment(self, assessment_id=None):\n        if assessment_id is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['assessment_id'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(assessment_id, metadata, array=False):\n            self._my_map['assessmentId'] = str(assessment_id)\n        else:\n            raise InvalidArgument", "response": "Sets the assessment.\n\n        arg:    assessmentId (osid.id.Id): the new assessment\n        raise:  INVALID_ARGUMENT - assessmentId is invalid\n        raise:  NoAccess - assessmentId cannot be modified\n        raise:  NullArgument - assessmentId is null\n        compliance: mandatory - This method must be implemented."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the cognitive process.", "response": "def set_cognitive_process(self, grade_id=None):\n        \"\"\"Sets the cognitive process.\n\n        arg:    gradeId (osid.id.Id): the new cognitive process\n        raise:  INVALID_ARGUMENT - gradeId is invalid\n        raise:  NoAccess - gradeId cannot be modified\n        raise:  NullArgument - gradeId is null\n        compliance: mandatory - This method must be implemented.\n\n        \"\"\"\n        if grade_id is None:\n            raise NullArgument()\n        metadata = Metadata(**settings.METADATA['cognitive_process_id'])\n        if metadata.is_read_only():\n            raise NoAccess()\n        if self._is_valid_input(grade_id, metadata, array=False):\n            self._my_map['cognitiveProcessId'] = str(grade_id)\n        else:\n            raise InvalidArgument"}
