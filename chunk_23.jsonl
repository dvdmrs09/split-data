{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compartments(M, normalize=True):\n\n    if not type(M) is np.ndarray:\n        M = np.array(M)\n\n    if M.shape[0] != M.shape[1]:\n        raise ValueError(\"Matrix is not square.\")\n\n    if normalize:\n        N = normalize_dense(M)\n    else:\n        N = np.copy(M)\n\n    from sklearn.decomposition import PCA\n\n    pca = PCA(n_components=2)\n    PC1, PC2 = pca.fit_transform(N).T\n    return PC1, PC2", "response": "A B compartment analysis on a normalized contact map."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_intra(M, contigs):\n\n    N = np.copy(M)\n    n = len(N)\n\n    assert n == len(contigs)\n\n    # Naive implmentation for now\n    for (i, j) in itertools.product(range(n), range(n)):\n        if contigs[i] == contigs[j]:\n            N[i, j] = 0\n\n    return N", "response": "Remove intrachromosomal contacts from a contact map given a list attributing each position\n    to a given chromosome."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef positions_to_contigs(positions):\n\n    contig_labels = np.zeros_like(positions)\n\n    contig_index = 0\n    for i, p in enumerate(positions):\n        if p == 0:\n            contig_index += 1\n        contig_labels[i] = contig_index\n\n    return contig_labels", "response": "Label contigs according to relative positions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef contigs_to_positions(contigs, binning=10000):\n\n    positions = np.zeros_like(contigs)\n\n    index = 0\n    for _, chunk in itertools.groubpy(contigs):\n        l = len(chunk)\n        positions[index : index + l] = np.arange(list(chunk)) * binning\n        index += l\n\n    return positions", "response": "Build positions from contig labels and binning parameter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsplitting a labeled matrix with multiple chromosomes into unlabeled single - chromosome matrices.", "response": "def split_matrix(M, contigs):\n    \"\"\"Split multiple chromosome matrix \n\n    Split a labeled matrix with multiple chromosomes\n    into unlabeled single-chromosome matrices. Inter chromosomal\n    contacts are discarded.\n\n    Parameters\n    ----------\n    M : array_like\n        The multiple chromosome matrix to be split\n    contigs : list or array_like\n        The list of contig labels\n    \"\"\"\n\n    index = 0\n    for _, chunk in itertools.groubpy(contigs):\n        l = len(chunk)\n        yield M[index : index + l, index : index + l]\n        index += l"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do(self, method, url, url_params={}, query_params={}, request_params={}):\n        _url = url.format(**url_params).lstrip(\"/\")\n        _endpoint = self.endpoint.format(path=_url)\n        _headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n\n        request_params = BacklogClient.remove_mb4(request_params)\n\n        resp = None\n\n        method = method.lower().strip()\n        query_params.update({\"apiKey\": self.api_key})\n        if method == \"get\":\n            resp = requests.get(_endpoint, params=query_params)\n        elif method == \"patch\":\n            resp = requests.patch(\n                _endpoint, params=query_params, data=request_params, headers=_headers)\n        elif method == \"post\":\n            resp = requests.post(\n                _endpoint, params=query_params, data=request_params, headers=_headers)\n        elif method == \"delete\":\n            resp = requests.delete(\n                _endpoint, params=query_params, data=request_params, headers=_headers)\n        else:\n            raise Exception(\"Unsupported Method\")\n\n        if resp.status_code >= 400:\n            raise Exception(resp, resp.text)\n\n        if resp.status_code == 204:\n            # 204 NO_CONTENT is blank response\n            # used in star\n            return None\n\n        return resp.json()", "response": "This method is used to make a request to the Unreal - Time API."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all activities for a project.", "response": "def project_activities(self, project_id_or_key, extra_query_params={}):\n        \"\"\"\n        client = BacklogClient(\"your_space_name\", \"your_api_key\")\n        client.project_activities(\"YOUR_PROJECT\")\n        client.project_activities(\"YOUR_PROJECT\", {\"activityTypeId[]\": [1, 2],})\n        \"\"\"\n        return self.do(\"get\", \"projects/{project_id_or_key}/activities\",\n                       url_params={\"project_id_or_key\": project_id_or_key},\n                       query_params=extra_query_params,\n                       )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a version of the current project.", "response": "def create_version(self, project_id_or_key, version_name, extra_request_params={}):\n        \"\"\"\n        client = BacklogClient(\"your_space_name\", \"your_api_key\")\n\n        client.create_version(\"YOUR_PROJECT\",\n                              \"VERSION_NAME\",\n                              {\"description\": \"version description\"})\n        \"\"\"\n        request_params = extra_request_params\n        request_params[\"name\"] = version_name\n        return self.do(\"POST\", \"projects/{project_id_or_key}/versions\",\n                       url_params={\"project_id_or_key\": project_id_or_key},\n                       request_params=request_params,\n                       )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating a version of a project.", "response": "def update_version(self, project_id_or_key, version_id, version_name, extra_request_params={}):        \n        \"\"\"\n        client = BacklogClient(\"your_space_name\", \"your_api_key\")\n        client.update_version(\"YOUR_PROJECT\",\n                              3,\n                              \"VERSION_NAME\"\n                              {\"description\": \"updated description\",\n                               \"archived\": \"true\"})\n        \"\"\"\n        \n        request_params = extra_request_params\n        request_params[\"name\"] = version_name\n        return self.do(\"PATCH\", \"projects/{project_id_or_key}/versions/{version_id}\",\n                       url_params={\"project_id_or_key\": project_id_or_key,\n                                   \"version_id\": version_id},\n                       request_params=request_params,\n                       )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all comments for a given issue.", "response": "def issue_comments(self, issue_id_or_key, extra_query_params={}):\n        \"\"\"\n        client = BacklogClient(\"your_space_name\", \"your_api_key\")\n        client.issue_comments(\"YOUR_PROJECT-999\")\n        \"\"\"\n        return self.do(\"GET\", \"issues/{issue_id_or_key}/comments\",\n                        url_params={\"issue_id_or_key\": issue_id_or_key},\n                        query_params=extra_query_params\n                        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_issue(self, project_id, summary, issue_type_id, priority_id, extra_request_params={}):\n        request_params = extra_request_params\n        request_params[\"projectId\"] = project_id\n        request_params[\"summary\"] = summary\n        request_params[\"issueTypeId\"] = issue_type_id\n        request_params[\"priorityId\"] = priority_id\n\n        return self.do(\"POST\", \"issues\",\n                       request_params=request_params,\n                       )", "response": "Create a new issue."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a comment to an existing issue.", "response": "def add_issue_comment(self, issue_id_or_key, content, extra_request_params={}):\n        \"\"\"\n        client = BacklogClient(\"your_space_name\", \"your_api_key\")\n        client.add_issue_comment(\"YOUR_PROJECT-999\", u\"or ... else e.\")\n        \"\"\"\n        request_params = extra_request_params\n        request_params[\"content\"] = content\n        return self.do(\"POST\", \"issues/{issue_id_or_key}/comments\",\n                       url_params={\"issue_id_or_key\": issue_id_or_key},\n                       request_params=request_params,\n                       )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_activities(self, user_id, extra_query_params={}):\n        return self.do(\"GET\", \"users/{user_id}/activities\",\n                       url_params={\"user_id\": user_id},\n                       query_params=extra_query_params)", "response": "Get all user activities for a user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user_stars(self, user_id, extra_query_params={}):\n        return self.do(\"GET\", \"users/{user_id}/stars\",\n                       url_params={\"user_id\": user_id},\n                       query_params=extra_query_params)", "response": "Get the user s list of stars."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_stars_count(self, user_id, extra_query_params={}):\n        return self.do(\"GET\", \"users/{user_id}/stars/count\",\n                       url_params={\"user_id\": user_id},\n                       query_params=extra_query_params)", "response": "Get the number of stars for a user."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates wiki with new content", "response": "def update_wiki(self, wiki_id, extra_request_params={}):\n        \"\"\"\n        client = BacklogClient(\"your_space_name\", \"your_api_key\")\n        client.update_wiki(3, {\"name\": \"test\", \"content\": \"content test\", \"mailNotify\": \"true\"})\n        \"\"\"\n        request_params = extra_request_params\n        return self.do(\"PATCH\", \"wikis/{wiki_id}\", url_params={\"wiki_id\": wiki_id}, request_params=request_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlocates the leftmost value exactly equal to x.", "response": "def find_index(array, x):\n    \"\"\"\n    Locate the leftmost value exactly equal to x.\n\n    :type array: list\n    :param array: an iterable object that support inex\n\n    :param x: a comparable value\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u8fd4\u56de\u7b2c\u4e00\u4e2a\u503c\u7b49\u4e8ex\u7684\u5143\u7d20\u7684\u7d22\u5f15\u3002\n    \"\"\"\n    i = bisect.bisect_left(array, x)\n    if i != len(array) and array[i] == x:\n        return i\n    raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_lt(array, x):\n    i = bisect.bisect_left(array, x)\n    if i:\n        return array[i - 1]\n    raise ValueError", "response": "Find rightmost value less than x."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_le(array, x):\n    i = bisect.bisect_right(array, x)\n    if i:\n        return array[i - 1]\n    raise ValueError", "response": "Find the rightmost value less than or equal to x."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the first value greater than x.", "response": "def find_gt(array, x):\n    \"\"\"\n    Find leftmost value greater than x.\n\n    :type array: list\n    :param array: an iterable object that support inex\n\n    :param x: a comparable value\n\n    Example::\n\n        >>> find_gt([0, 1, 2, 3], 0.5)\n        1\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u5bfb\u627e\u6700\u5c0f\u7684\u5927\u4e8ex\u7684\u6570\u3002\n    \"\"\"\n    i = bisect.bisect_right(array, x)\n    if i != len(array):\n        return array[i]\n    raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the leftmost item greater than or equal to x.", "response": "def find_ge(array, x):\n    \"\"\"\n    Find leftmost item greater than or equal to x.\n\n    :type array: list\n    :param array: an iterable object that support inex\n\n    :param x: a comparable value\n\n    Example::\n\n        >>> find_ge([0, 1, 2, 3], 1.0)\n        1\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u5bfb\u627e\u6700\u5c0f\u7684\u5927\u4e8e\u7b49\u4e8ex\u7684\u6570\u3002\n    \"\"\"\n    i = bisect.bisect_left(array, x)\n    if i != len(array):\n        return array[i]\n    raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_nearest(sorted_list, x):\n    if x <= sorted_list[0]:\n        return sorted_list[0]\n    elif x >= sorted_list[-1]:\n        return sorted_list[-1]\n    else:\n        lower = find_le(sorted_list, x)\n        upper = find_ge(sorted_list, x)\n        if (x - lower) > (upper - x):\n            return upper\n        else:\n            return lower", "response": "Find the nearest item of x from sorted array."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_last_true(sorted_list, true_criterion):\n\n    # exam first item, if not true, then impossible to find result\n    if not true_criterion(sorted_list[0]):\n        raise ValueError\n\n    # exam last item, if true, it is the one.\n    if true_criterion(sorted_list[-1]):\n        return sorted_list[-1]\n\n    lower, upper = 0, len(sorted_list) - 1\n\n    index = int((lower + upper) / 2.0)\n    while 1:\n        if true_criterion(sorted_list[index]):\n            if true_criterion(sorted_list[index + 1]):\n                lower = index\n                index = int((index + upper) / 2.0)\n            else:\n                return index\n        else:\n            upper = index\n            index = int((lower + index) / 2.0)", "response": "This function will find the last true item in a list that is not in the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_x_tick(axis,\n                  major_locator=None,\n                  major_formatter=None,\n                  minor_locator=None,\n                  minor_formatter=None):\n    \"\"\"Set x axis's format.\n\n    This method is designed for time axis.\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u8bbe\u7f6eX\u8f74\u683c\u5f0f\u3002\n    \"\"\"\n    if major_locator:\n        axis.xaxis.set_major_locator(major_locator)\n    if major_formatter:\n        axis.xaxis.set_major_formatter(major_formatter)\n    if minor_locator:\n        axis.xaxis.set_minor_locator(minor_locator)\n    if minor_formatter:\n        axis.xaxis.set_minor_formatter(minor_formatter)\n\n    axis.autoscale_view()\n    plt.setp(axis.xaxis.get_majorticklabels(), rotation=90)\n    plt.setp(axis.xaxis.get_minorticklabels(), rotation=90)\n    axis.grid()", "response": "Set x axis s format."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets line legend. **\u4e2d\u6587\u6587\u6863** \u8bbe\u7f6e\u56fe\u4f8b\u3002", "response": "def set_legend(axis, lines, legend):\n    \"\"\"Set line legend.\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u8bbe\u7f6e\u56fe\u4f8b\u3002\n    \"\"\"\n    try:\n        if legend:\n            axis.legend(lines, legend)\n    except Exception as e:\n        raise ValueError(\"invalid 'legend', Error: %s\" % e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets maximum value of an array. Automatically ignore invalid data.", "response": "def get_max(array):\n    \"\"\"Get maximum value of an array. Automatically ignore invalid data.\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u83b7\u5f97\u6700\u5927\u503c\u3002\n    \"\"\"\n    largest = -np.inf\n    for i in array:\n        try:\n            if i > largest:\n                largest = i\n        except:\n            pass\n    if np.isinf(largest):\n        raise ValueError(\"there's no numeric value in array!\")\n    else:\n        return largest"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_min(array):\n    smallest = np.inf\n    for i in array:\n        try:\n            if i < smallest:\n                smallest = i\n        except:\n            pass\n    if np.isinf(smallest):\n        raise ValueError(\"there's no numeric value in array!\")\n    else:\n        return smallest", "response": "Get minimum value of an array. Automatically ignore invalid data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_yAxis_limit(y, lower=0.05, upper=0.2):\n    smallest = get_min(y)\n    largest = get_max(y)\n    gap = largest - smallest\n    if gap >= 0.000001:\n        y_min = smallest - lower * gap\n        y_max = largest + upper * gap\n    else:\n        y_min = smallest - lower * abs(smallest)\n        y_max = largest + upper * abs(largest)\n    return y_min, y_max", "response": "Find optimal y_min and y_max that guarantee enough space for legend and \n    plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a figure instance.", "response": "def create_figure(width=20, height=10):\n    \"\"\"Create a figure instance.\n\n    :params width: figure width\n    :params height: figure height\n    \"\"\"\n    figure = plt.figure(figsize=(width, height))\n    axis = figure.add_subplot(1, 1, 1)\n    return figure, axis"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_time_series(x, y,\n                     linewidth=1, linestyle=\"-\",\n                     xlabel=None, ylabel=None,\n                     x_major_locattor=None, x_major_formatter=None,\n                     x_minor_locattor=None, x_minor_formatter=None,\n                     title=None, legend=None, cycol=None):\n    \"\"\"\n    :param x: time array or tuple\n    :param y: time array or tuple\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u4e3a\u65f6\u95f4\u5e8f\u5217\u6570\u636e\u753b\u56fe\u3002\n    \"\"\"\n    x, y = preprocess_x_y(x, y)\n    if cycol is None:\n        cycol = cycle(\"brgcmyk\")\n    plt.close(\"all\")\n    figure, axis = create_figure()\n\n    lines = list()\n    for time, value in zip(x, y):\n        lines.append(axis.plot(time, value,\n                               lw=linewidth, ls=linestyle, c=next(cycol))[0])\n\n    format_x_tick(axis,\n                  x_major_locattor, x_major_formatter,\n                  x_minor_locattor, x_minor_formatter,)\n\n    y_min, y_max = get_yAxis_limit(\n        np.array(y).flatten(),\n        lower=0.05,\n        upper=0.1 * len(x),\n    )\n    set_ylim(axis, y_min, y_max)\n\n    set_title_xlabel_ylabel(axis, title, xlabel, ylabel)\n\n    set_legend(axis, lines, legend)\n\n    return plt", "response": "Plot a series of time values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes a task with the provided input parameters and return the output as a JSON string.", "response": "def execute(input_params, engine, cwd=None):\n    \"\"\"\n    Execute a task with the provided input parameters\n\n    :param input_params: Python dictionary containg all input parameters.\n                         This will be converted to JSON before being passed\n                         to the task engine.\n    :param engine: String specifying Task Engine type to run (ENVI, IDL, etc.)\n    :param cwd: Optionally specify the current working directory to be used\n                when spawning the task engine.\n    :return: A python dictionary representing the results JSON string generated\n             by the Task Engine.\n    \"\"\"\n\n    try:\n        taskengine_exe = config.get('engine')\n    except NoConfigOptionError:\n        raise TaskEngineNotFoundError(\n            \"Task Engine config option not set.\" +\n            \"\\nPlease verify the 'engine' configuration setting.\")\n\n    if not os.path.exists(taskengine_exe):\n        raise TaskEngineNotFoundError(\n            \"Task Engine executable not found.\" +\n            \"\\nPlease verify the 'engine' configuration setting.\")\n\n    # Get any arguments for the taskengine\n    engine_args = None\n    try:\n        engine_args = config.get('engine-args')\n    except NoConfigOptionError:\n        pass\n\n    # Get environment overrides if they exist\n    environment = None\n    config_environment = config.get_environment()\n    if config_environment:\n        environment = os.environ.copy()\n        environment.update(config_environment)\n\n    # Build up the args vector for popen\n    args = [taskengine_exe, engine]\n    if engine_args:\n        args.append(engine_args)\n\n    # Hide the Console Window on Windows OS\n    startupinfo = None\n    if sys.platform.startswith('win'):\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n    input_json = json.dumps(input_params)\n    process = Popen(args,\n                    stdout=PIPE,\n                    stdin=PIPE,\n                    stderr=PIPE,\n                    cwd=cwd,\n                    env=environment,\n                    startupinfo=startupinfo)\n    # taskengine output is in UTF8.  Encode/Decode to UTF8                \n    stdout, stderr = process.communicate(input=input_json.encode('utf-8'))\n    if process.returncode != 0:\n        if stderr != '':\n            raise TaskEngineExecutionError(stderr.decode('utf-8'))\n        else:\n            raise TaskEngineExecutionError(\n                'Task Engine exited with code: ' + str(process.returncode))\n    else:\n        return json.loads(stdout.decode('utf-8'), object_pairs_hook=OrderedDict)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, wrappers=[\"\", \"\"]):\n        '''\n        run the lilypond script on the hierarchy class\n\n        :param wrappers: this is useful for testing: use wrappers to put something around the outputted \"lilypond string\" from the hierarchy class.\n        For example if you're testing a pitch, you might put \\relative c {} around the note so that lilypond handles it properly without causing an error\n\n        :return: doesn't return anything, side effect that a PDF should be created.\n        '''\n        opened_file = open(self.lyfile, 'w')\n        lilystring = self.piece_obj.toLily()\n        opened_file.writelines(\n            wrappers[0] +\n            \"\\\\version \\\"2.18.2\\\" \\n\" +\n            lilystring +\n            wrappers[1])\n        opened_file.close()\n        # subprocess.Popen(['sudo', self.lily_script,\" --output=\" +\n        #     self.folder, self.lyfile])\n        os.system(self.lily_script +\n                  \" --loglevel=WARNING --output=\" +\n                  self.folder + \" \" + self.lyfile\n                  )", "response": "run the lilypond script on the hierarchy class"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef extract_subnetworks(\n    partition_file,\n    network_file,\n    output_dir,\n    max_cores=DEFAULT_MAX_CORES,\n    max_size_matrix=DEFAULT_MAX_SIZE_MATRIX,\n    saturation_threshold=DEFAULT_SATURATION_THRESHOLD,\n):\n    \"\"\"Extract bin subnetworks from the main network\n\n    Identify bins, extract subnets, draws the adjacency matrices,\n    saves it all in a specified output directory.\n\n    Parameters\n    ----------\n    partition_file : file, str or pathlib.Path\n        The file containing, for each chunk, the communities it was\n        assigned to at each iteration.\n    network_file : file, str or pathlib.Path\n        The file containing the network in sparse (edge list) format\n    output_dir : str or pathlib.Path\n        The output directory to write the subnetworks into.\n    max_cores : int, optional\n        The maximum number of bins to extract. Default is 100.\n    max_size_matrix : int, optional\n        When rendering contact maps for each bin, the maximum size for the\n        matrix. Default is 2000.\n    saturation_threshold : float, optional\n        When rendering contact maps for each bin, the percentile value over\n        which the color map should be saturated. Default is 80.\n    \"\"\"\n\n    logger.info(\"Loading partition...\")\n    data_chunks = np.loadtxt(partition_file, usecols=(1,), dtype=np.int32)\n\n    logger.info(\"Loading network...\")\n    network = np.loadtxt(network_file, dtype=np.int32)\n    cores = data_chunks\n\n    core_network = np.copy(network)\n\n    core_network[:, 0] = cores[network[:, 0]]\n    core_network[:, 1] = cores[network[:, 1]]\n\n    n = np.amax(cores) + 1\n\n    def extract(network_to_keep, filename):\n\n        subnetwork = np.copy(network[network_to_keep])\n        subnetwork[:, 0] -= 1\n        subnetwork[:, 1] -= 1\n\n        np.savetxt(filename, subnetwork, fmt=\"%i\")\n\n        return subnetwork\n\n    def draw(subnetwork, filename):\n\n        try:\n            # Numpy array format\n            row = subnetwork[:, 0]\n            col = subnetwork[:, 1]\n            data = subnetwork[:, 2]\n        except TypeError:\n            # Scipy sparse format\n            row = subnetwork.row\n            col = subnetwork.col\n            data = subnetwork.data\n\n        row_indices = stats.rankdata(\n            np.concatenate((row, col)), method=\"dense\"\n        )\n        col_indices = stats.rankdata(\n            np.concatenate((col, row)), method=\"dense\"\n        )\n        data = np.concatenate((data, data))\n\n        # print(\"Row length: {}, col length: {}, data length: {}\"\n        #       \"\".format(len(row_indices), len(col_indices), len(data)))\n\n        unique_row = np.unique(row)\n        unique_col = np.unique(col)\n\n        # print(\"Network shape: {},{}\".format(len(unique_row),\n        #                                     len(unique_col)))\n\n        size = len(np.unique(np.concatenate((unique_row, unique_col)))) + 1\n        # print(\"Size of matrix to draw: {}\".format(size))\n\n        try:\n            sparse_subnet = sparse.coo_matrix(\n                (data, (row_indices, col_indices)), shape=(size, size)\n            )\n            binning_factor = (size // max_size_matrix) + 1\n            binned_subnet = hcs.bin_sparse(\n                sparse_subnet, subsampling_factor=binning_factor\n            )\n            dense_subnet = binned_subnet.todense()\n\n            diagonal = np.diag(np.diag(dense_subnet))\n            normed_subnet = hcs.normalize_dense(dense_subnet - diagonal)\n\n            vmax = np.percentile(normed_subnet, saturation_threshold)\n\n            spaceless_pdf_plot_maker(normed_subnet, filename, vmax=vmax)\n\n        except MemoryError:\n            logger.warning(\n                \"Warning, couldn't save matrix due to memory issues\"\n            )\n\n    def extract_and_draw(network_to_keep, filename_text, filename_image):\n\n        subnetwork = extract(network_to_keep, filename=filename_text)\n        draw(subnetwork, filename=filename_image)\n\n    #   Extract and draw subnetworks for chosen cores and draw 2D arrays\n    global_network_indices_list = []\n\n    for i in range(1, n):\n\n        if i > max_cores:\n            break\n\n        # print(\"Bin {}:\".format(i))\n        network_to_keep_1 = core_network[:, 0] == i\n        network_to_keep_2 = core_network[:, 1] == i\n\n        network_to_keep = network_to_keep_1 * network_to_keep_2\n\n        nonzero_indices, = np.nonzero(network_to_keep)\n        global_network_indices_list += nonzero_indices.tolist()\n\n        subnetwork_file = os.path.join(\n            output_dir, \"subnetwork_core_{}.dat\".format(i)\n        )\n\n        image_name = os.path.join(output_dir, \"core_{}.eps\".format(i))\n\n        extract_and_draw(\n            network_to_keep=network_to_keep,\n            filename_text=subnetwork_file,\n            filename_image=image_name,\n        )", "response": "Extract bin subnetworks from the main network and save them in a specified output directory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extract_fasta(\n    partition_file,\n    fasta_file,\n    output_dir,\n    chunk_size=DEFAULT_CHUNK_SIZE,\n    max_cores=DEFAULT_MAX_CORES,\n):\n\n    \"\"\"Extract sequences from bins\n\n    Identify bins, extract chunks belonging to each bins and gather them\n    in a single FASTA file.\n\n    Parameters\n    ----------\n    partition_file : file, str or pathlib.Path\n        The file containing, for each chunk, the communities it was\n        assigned to at each iteration.\n    fasta_file : file, str or pathlib.Path\n        The initial assembly from which chunks were initialized.\n    output_dir : str or pathlib.Path\n        The output directory to write the FASTA chunks into.\n    chunk_size : int, optional\n        The size of the chunks (in bp) used in the pipeline. Default is 1000.\n    max_cores : int, optional\n        How many bins to extract FASTA sequences from. Default is 100.\n    \"\"\"\n\n    genome = {\n        record.id: record.seq for record in SeqIO.parse(fasta_file, \"fasta\")\n    }\n\n    data_chunks = list(\n        zip(*np.genfromtxt(partition_file, usecols=(0, 1), dtype=None))\n    )\n\n    chunk_names = np.array(data_chunks[0], dtype=object)\n    cores = np.array(data_chunks[1])\n    for core in set(cores):\n        if core > max_cores:\n            continue\n        chunks_to_keep = chunk_names[cores == core]\n        core_name = \"core_{}.fa\".format(core)\n\n        core_file = os.path.join(output_dir, core_name)\n\n        with open(core_file, \"w\") as core_handle:\n            for name in chunks_to_keep:\n                fields = name.split(\"_\")\n                header_name = \"_\".join(fields[:-1])\n                chunk = int(fields[-1])\n\n                pos_start = chunk * chunk_size\n                pos_end = min(\n                    (chunk + 1) * chunk_size, len(genome[header_name])\n                )\n\n                sequence = str(genome[header_name][pos_start:pos_end])\n\n                core_handle.write(\">{}\\n\".format(name))\n                core_handle.write(\"{}\\n\".format(sequence))", "response": "Extract sequences from a set of bins and produce a single FASTA file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_fasta(fasta_file, output_dir):\n\n    \"\"\"Merge chunks into complete FASTA bins\n\n    Merge bin chunks by appending consecutive chunks to one another.\n\n    Parameters\n    ----------\n    fasta_file : file, str or pathlib.Path\n        The FASTA file containing the chunks to merge.\n    output_dir : str or pathlib.Path\n        The output directory to write the merged FASTA bin into.\n    \"\"\"\n\n    #   First, define some functions for ordering chunks and detecting\n    #   consecutive chunk sequences\n\n    def chunk_lexicographic_order(chunk):\n        \"\"\"A quick callback to sort chunk ids lexicographically\n        (first on original names alphabetically, then on relative\n        position on the original contig)\n        \"\"\"\n        chunk_fields = chunk.split(\"_\")\n        chunk_name = chunk_fields[:-1]\n        chunk_id = chunk_fields[-1]\n        return (chunk_name, int(chunk_id))\n\n    def are_consecutive(chunk1, chunk2):\n        if None in {chunk1, chunk2}:\n            return False\n        else:\n            ord1 = chunk_lexicographic_order(chunk1)\n            ord2 = chunk_lexicographic_order(chunk2)\n            return (ord1[0] == ord2[0]) and (ord1[1] == ord2[1] + 1)\n\n    def consecutiveness(key_chunk_pair):\n        \"\"\"A callback for the groupby magic below\n        \"\"\"\n        key, chunk = key_chunk_pair\n        chunk_name, chunk_id = chunk_lexicographic_order(chunk)\n        return (chunk_name, chunk_id - key)\n\n    #   Read chunks and sort them\n    genome = {\n        record.id: record.seq for record in SeqIO.parse(fasta_file, \"fasta\")\n    }\n\n    sorted_ids = sorted(genome, key=chunk_lexicographic_order)\n\n    #   Identify consecutive ranges and merge them\n    new_genome = dict()\n    for _, g in itertools.groupby(enumerate(sorted_ids), consecutiveness):\n        chunk_range = map(operator.itemgetter(1), g)\n        first_chunk = next(chunk_range)\n        my_sequence = genome[first_chunk]\n        my_chunk = None\n        while \"Reading chunk range\":\n            try:\n                my_chunk = next(chunk_range)\n                my_sequence += genome[my_chunk]\n            except StopIteration:\n                break\n\n        try:\n            last_chunk_id = my_chunk.split(\"_\")[-1]\n        except AttributeError:\n            last_chunk_id = \"\"\n\n        if last_chunk_id:\n            new_chunk_id = \"{}_{}\".format(first_chunk, last_chunk_id)\n        else:\n            new_chunk_id = first_chunk\n        new_genome[new_chunk_id] = my_sequence\n\n    #   Write the result\n    base_name = \".\".join(os.path.basename(fasta_file).split(\".\")[:-1])\n    output_name = \"{}_merged.fa\".format(base_name)\n    merged_core_file = os.path.join(output_dir, output_name)\n    with open(merged_core_file, \"w\") as output_handle:\n        for my_id in sorted(new_genome, key=chunk_lexicographic_order):\n            output_handle.write(\">{}\\n\".format(my_id))\n            output_handle.write(\"{}\\n\".format(new_genome[my_id]))", "response": "Merge chunks into complete FASTA bin."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def _asyncio_send(loop, req, *, timeout=10, max_redirects=10):\n    if not any(h.lower() == 'user-agent' for h in req.headers):\n        req = req.with_headers({'User-Agent': _ASYNCIO_USER_AGENT})\n    url = urllib.parse.urlsplit(\n        req.url + '?' + urllib.parse.urlencode(req.params))\n    open_ = partial(asyncio.open_connection, url.hostname, loop=loop)\n    connect = open_(443, ssl=True) if url.scheme == 'https' else open_(80)\n    reader, writer = await connect\n    try:\n        headers = '\\r\\n'.join([\n            '{} {} HTTP/1.1'.format(req.method, url.path + '?' + url.query),\n            'Host: ' + url.hostname,\n            'Connection: close',\n            'Content-Length: {}'.format(len(req.content or b'')),\n            '\\r\\n'.join(starmap('{}: {}'.format, req.headers.items())),\n        ])\n        writer.write(b'\\r\\n'.join([headers.encode('latin-1'),\n                                   b'', req.content or b'']))\n        response_bytes = BytesIO(\n            await asyncio.wait_for(reader.read(), timeout=timeout))\n    finally:\n        writer.close()\n    resp = HTTPResponse(_SocketAdaptor(response_bytes),\n                        method=req.method, url=req.url)\n    resp.begin()\n    status = resp.getcode()\n    if 300 <= status < 400 and 'Location' in resp.headers and max_redirects:\n        new_url = urllib.parse.urljoin(req.url, resp.headers['Location'])\n        return await _asyncio_send(\n            loop, req.replace(url=new_url),\n            timeout=timeout,\n            max_redirects=max_redirects-1)\n    return Response(status, content=resp.read(), headers=resp.headers)", "response": "A rudimentary HTTP client using asyncio."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef console(loop, log):\n    parser = argparse.ArgumentParser(description=console.__doc__)\n    parser.add_argument('--host', default='127.0.0.1', help='IP or FQDN of AVR')\n    parser.add_argument('--port', default='14999', help='Port of AVR')\n    parser.add_argument('--verbose', '-v', action='count')\n\n    args = parser.parse_args()\n\n    if args.verbose:\n        level = logging.DEBUG\n    else:\n        level = logging.INFO\n\n    logging.basicConfig(level=level)\n\n    def log_callback(message):\n        \"\"\"Receives event callback from Anthem Protocol class.\"\"\"\n        log.info('Callback invoked: %s' % message)\n\n    host = args.host\n    port = int(args.port)\n\n    log.info('Connecting to Anthem AVR at %s:%i' % (host, port))\n\n    conn = yield from anthemav.Connection.create(\n        host=host, port=port, loop=loop, update_callback=log_callback)\n\n    log.info('Power state is '+str(conn.protocol.power))\n    conn.protocol.power = True\n    log.info('Power state is '+str(conn.protocol.power))\n\n    yield from asyncio.sleep(10, loop=loop)\n\n    log.info('Panel brightness (raw) is '+str(conn.protocol.panel_brightness))\n    log.info('Panel brightness (text) is '+str(conn.protocol.panel_brightness_text))", "response": "Connect to receiver and show events as they occur."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrap to call console with a loop.", "response": "def monitor():\n    \"\"\"Wrapper to call console with a loop.\"\"\"\n    log = logging.getLogger(__name__)\n    loop = asyncio.get_event_loop()\n    asyncio.ensure_future(console(loop, log))\n    loop.run_forever()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_object(cls, data):\n    if issubclass(cls, Object):\n        self = object.__new__(cls)\n        self._data = data\n    else:\n        self = data\n    return self", "response": "Creates an API object of class cls setting its _data to\n    data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef String(length=None, **kwargs):\n    return Property(\n        length=length,\n        types=stringy_types,\n        convert=to_string,\n        **kwargs\n    )", "response": "A string valued property with max. length."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef InstanceOf(cls, **kwargs):\n    return Property(types=cls, load=cls.load, **kwargs)", "response": "A property that is an instance of cls."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ListOf(cls, **kwargs):\n\n    def _list_load(value):\n        return [cls.load(d) for d in value]\n\n    return Property(types=list, load=_list_load, default=list, **kwargs)", "response": "A property that is a list of cls."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check(self, obj, value, errors):\n        fieldname = \"%s.%s\" % (type(obj).__name__, self._name)\n\n        if value is None:\n            if not self._null:\n                errors.append(\"%s may not be 'null'\" % fieldname)\n\n            # If None, just leave. The rest of checks don't make any sense.\n            return\n\n        for has_error in [self._has_wrong_type, self._has_wrong_length,\n                          self._is_not_one_of, self._has_subproblems]:\n            if has_error(fieldname, value, errors):\n                break", "response": "Check if value is valid this property in the entity obj. Appends validation results to errors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a named dimension to this entity.", "response": "def add_dimension(self, name, data=None):\n        \"\"\"Add a named dimension to this entity.\"\"\"\n        self.dimensions.add(name)\n        if data is None:\n            valobj = self.__dimtype__()\n        else:\n            valobj = make_object(self.__dimtype__, data)\n        self._data[name] = valobj\n        setattr(self, name, valobj)\n        return valobj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the data into a : class : ~mwtab. mwtab. MWTabFile instance.", "response": "def read(self, filehandle):\n        \"\"\"Read data into a :class:`~mwtab.mwtab.MWTabFile` instance.\n\n        :param filehandle: file-like object.\n        :type filehandle: :py:class:`io.TextIOWrapper`, :py:class:`gzip.GzipFile`,\n                          :py:class:`bz2.BZ2File`, :py:class:`zipfile.ZipFile`\n        :return: None\n        :rtype: :py:obj:`None`\n        \"\"\"\n        input_str = filehandle.read()\n        mwtab_str = self._is_mwtab(input_str)\n        json_str = self._is_json(input_str)\n\n        if not input_str:\n            pass\n        elif json_str:\n            self.update(json_str)\n        elif mwtab_str:\n            self._build_mwtabfile(mwtab_str)\n        else:\n            raise TypeError(\"Unknown file format\")\n\n        self.study_id = self[\"METABOLOMICS WORKBENCH\"].get(\"STUDY_ID\")\n        self.analysis_id = self[\"METABOLOMICS WORKBENCH\"].get(\"ANALYSIS_ID\")\n        self.header = self[\"METABOLOMICS WORKBENCH\"].get(\"HEADER\")\n\n        filehandle.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites the data into file.", "response": "def write(self, filehandle, file_format):\n        \"\"\"Write :class:`~mwtab.mwtab.MWTabFile` data into file.\n\n        :param filehandle: file-like object.\n        :type filehandle: :py:class:`io.TextIOWrapper`\n        :param str file_format: Format to use to write data: `mwtab` or `json`.\n        :return: None\n        :rtype: :py:obj:`None`\n        \"\"\"\n        try:\n            if file_format == \"json\":\n                json_str = self._to_json()\n                filehandle.write(json_str)\n            elif file_format == \"mwtab\":\n                mwtab_str = self._to_mwtab()\n                filehandle.write(mwtab_str)\n            else:\n                raise TypeError(\"Unknown file format.\")\n        except IOError:\n            raise IOError('\"filehandle\" parameter must be writable.')\n        filehandle.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a MWTabFile instance from a string in mwtab format.", "response": "def _build_mwtabfile(self, mwtab_str):\n        \"\"\"Build :class:`~mwtab.mwtab.MWTabFile` instance.\n\n        :param mwtab_str: String in `mwtab` format.\n        :type mwtab_str: :py:class:`str` or :py:class:`bytes`\n        :return: instance of :class:`~mwtab.mwtab.MWTabFile`.\n        :rtype: :class:`~mwtab.mwtab.MWTabFile`\n        \"\"\"\n        mwtab_file = self\n        lexer = tokenizer(mwtab_str)\n        token = next(lexer)\n\n        while token.key != \"!#ENDFILE\":\n            if token.key.startswith(\"#\"):\n                name = token.key[1:]\n                section = self._build_block(lexer)\n                if section:\n                    mwtab_file[name] = section\n            token = next(lexer)\n        return mwtab_file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild individual text block of MWTabFile instance.", "response": "def _build_block(self, lexer):\n        \"\"\"Build individual text block of :class:`~mwtab.mwtab.MWTabFile` instance.\n\n        :param lexer: instance of the mwtab tokenizer.\n        :type lexer: :func:`~mwtab.tokenizer.tokenizer`\n        :return: Section dictionary.\n        :rtype: :py:class:`collections.OrderedDict`\n        \"\"\"\n        section = OrderedDict()\n        token = next(lexer)\n\n        while not token.key.startswith(\"#ENDSECTION\"):\n\n            if token.key.startswith(\"SUBJECT_SAMPLE_FACTORS\"):\n                header = token._fields[1:]\n                values = token[1:]\n                section.setdefault(\"SUBJECT_SAMPLE_FACTORS\", [])\n                section[\"SUBJECT_SAMPLE_FACTORS\"].append(OrderedDict(zip(header, values)))\n\n            elif token.key.endswith(\"_START\"):\n                section_key = token.key\n                section.setdefault(section_key, OrderedDict())\n                data = []\n\n                token = next(lexer)\n                header = list(token.value)\n\n                while not token.key.endswith(\"_END\"):\n                    if token.key == \"Samples\":\n                        header[0] = \"metabolite_name\"\n                        section[section_key][token.key] = list(token.value[1:])\n                    elif token.key == \"Factors\":\n                        section[section_key][token.key] = list(token.value[1:])\n                    elif token.key in (\"metabolite_name\", \"Bin range(ppm)\"):\n                        section[section_key][\"Fields\"] = list(token.value)\n                    else:\n                        data.append(OrderedDict(zip(header, token.value)))\n\n                    token = next(lexer)\n                section[section_key][\"DATA\"] = data\n\n            elif token.key.endswith(\"_RESULTS_FILE\"):\n                if len(token) == 4:\n                    key, value, extrakey, extravalue = token\n                    section[key] = OrderedDict([(key, value), (extrakey, extravalue)])\n                else:\n                    key, value = token\n                    section[key] = value\n\n            else:\n                key, value, = token\n                if key in section:\n                    section[key] += \"\\n{}\".format(value)\n                else:\n                    section[key] = value\n            token = next(lexer)\n        return section"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint the current state of the object into a file or stdout.", "response": "def print_file(self, f=sys.stdout, file_format=\"mwtab\"):\n        \"\"\"Print :class:`~mwtab.mwtab.MWTabFile` into a file or stdout.\n\n        :param io.StringIO f: writable file-like stream.\n        :param str file_format: Format to use: `mwtab` or `json`.\n        :param f: Print to file or stdout.\n        :param int tw: Tab width.\n        :return: None\n        :rtype: :py:obj:`None`\n        \"\"\"\n        if file_format == \"mwtab\":\n            for key in self:\n                if key == \"SUBJECT_SAMPLE_FACTORS\":\n                    print(\"#SUBJECT_SAMPLE_FACTORS:         \\tSUBJECT(optional)[tab]SAMPLE[tab]FACTORS(NAME:VALUE pairs separated by |)[tab]Additional sample data\", file=f)\n                elif key == \"METABOLOMICS WORKBENCH\":\n                    print(self.header, file=f)\n                else:\n                    print(\"#{}\".format(key), file=f)\n\n                self.print_block(key, f=f, file_format=file_format)\n            print(\"#END\", file=f)\n\n        elif file_format == \"json\":\n            print(self._to_json(), file=f)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints a block of data into a file or stdout.", "response": "def print_block(self, section_key, f=sys.stdout, file_format=\"mwtab\"):\n        \"\"\"Print `mwtab` section into a file or stdout.\n\n        :param str section_key: Section name.\n        :param io.StringIO f: writable file-like stream.\n        :param str file_format: Format to use: `mwtab` or `json`.\n        :return: None\n        :rtype: :py:obj:`None`\n        \"\"\"\n        if file_format == \"mwtab\":\n            for key, value in self[section_key].items():\n                if section_key == \"METABOLOMICS WORKBENCH\" and key not in (\"VERSION\", \"CREATED_ON\"):\n                    continue\n\n                if key in (\"VERSION\", \"CREATED_ON\"):\n                    cw = 20 - len(key)\n                elif key in (\"SUBJECT_SAMPLE_FACTORS\", ):\n                    cw = 33 - len(key)\n                else:\n                    cw = 30 - len(key)\n\n                if \"\\n\" in value:\n                    for line in value.split(\"\\n\"):\n                        print(\"{}{}{}\\t{}\".format(self.prefixes.get(section_key, \"\"), key, cw * \" \", line), file=f)\n\n                elif key == \"SUBJECT_SAMPLE_FACTORS\":\n                    for factor in value:\n                        print(\"{}{}\\t{}\".format(key, cw * \" \", \"\\t\".join(factor.values())), file=f)\n\n                elif key.endswith(\":UNITS\"):\n                    print(\"{}\\t{}\".format(key, value), file=f)\n\n                elif key.endswith(\"_RESULTS_FILE\"):\n                    if isinstance(value, dict):\n                        print(\"{}{}               \\t{}\\t{}:{}\".format(self.prefixes.get(section_key, \"\"),\n                                                                      *[i for pair in value.items() for i in pair]), file=f)\n                    else:\n                        print(\"{}{}{}\\t{}\".format(self.prefixes.get(section_key, \"\"), key, cw * \" \", value), file=f)\n\n                elif key.endswith(\"_START\"):\n                    start_key = key\n                    end_key = \"{}{}\".format(start_key[:-5], \"END\")\n                    print(start_key, file=f)\n\n                    for data_key in value:\n                        if data_key in (\"Samples\", \"Factors\"):\n                            print(\"{}\\t{}\".format(data_key, \"\\t\".join(self[section_key][key][data_key])), file=f)\n\n                        elif data_key in (\"Fields\", ):\n                            print(\"{}\".format(\"\\t\".join(self[section_key][key][data_key])), file=f)\n\n                        elif data_key == \"DATA\":\n                            for data in self[section_key][key][data_key]:\n                                print(\"\\t\".join(data.values()), file=f)\n\n                    print(end_key, file=f)\n                else:\n                    print(\"{}{}{}\\t{}\".format(self.prefixes.get(section_key, \"\"), key, cw * \" \", value), file=f)\n\n        elif file_format == \"json\":\n            print(json.dumps(self[section_key], sort_keys=False, indent=4), file=f)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _to_mwtab(self):\n        mwtab_str = io.StringIO()\n        self.print_file(mwtab_str)\n        return mwtab_str.getvalue()", "response": "Save NMR - STAR file in mwtab formatted string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if input string is in mwTab format.", "response": "def _is_mwtab(string):\n        \"\"\"Test if input string is in `mwtab` format.\n\n        :param string: Input string.\n        :type string: :py:class:`str` or :py:class:`bytes`\n        :return: Input string if in mwTab format or False otherwise.\n        :rtype: :py:class:`str` or :py:obj:`False`\n        \"\"\"\n        if isinstance(string, str):\n            lines = string.split(\"\\n\")\n        elif isinstance(string, bytes):\n            lines = string.decode(\"utf-8\").split(\"\\n\")\n        else:\n            raise TypeError(\"Expecting <class 'str'> or <class 'bytes'>, but {} was passed\".format(type(string)))\n\n        lines = [line for line in lines if line]\n        header = lines[0]\n\n        if header.startswith(\"#METABOLOMICS WORKBENCH\"):\n            return \"\\n\".join(lines)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _is_json(string):\n        try:\n            if isinstance(string, bytes):\n                json_str = json.loads(string.decode(\"utf-8\"), object_pairs_hook=OrderedDict)\n            elif isinstance(string, str):\n                json_str = json.loads(string, object_pairs_hook=OrderedDict)\n            else:\n                raise TypeError(\"Expecting <class 'str'> or <class 'bytes'>, but {} was passed\".format(type(string)))\n            return json_str\n        except ValueError:\n            return False", "response": "Test if input string is in JSON format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching trace ids by service and span name.", "response": "def getTraceIdsBySpanName(self, service_name, span_name, end_ts, limit, order):\n    \"\"\"\n    Fetch trace ids by service and span name.\n    Gets \"limit\" number of entries from before the \"end_ts\".\n\n    Span name is optional.\n    Timestamps are in microseconds.\n\n    Parameters:\n     - service_name\n     - span_name\n     - end_ts\n     - limit\n     - order\n    \"\"\"\n    self.send_getTraceIdsBySpanName(service_name, span_name, end_ts, limit, order)\n    return self.recv_getTraceIdsBySpanName()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches trace ids by service name.", "response": "def getTraceIdsByServiceName(self, service_name, end_ts, limit, order):\n    \"\"\"\n    Fetch trace ids by service name.\n    Gets \"limit\" number of entries from before the \"end_ts\".\n\n    Timestamps are in microseconds.\n\n    Parameters:\n     - service_name\n     - end_ts\n     - limit\n     - order\n    \"\"\"\n    self.send_getTraceIdsByServiceName(service_name, end_ts, limit, order)\n    return self.recv_getTraceIdsByServiceName()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching trace ids with a particular annotation. Gets \"limit\" number of entries from before the \"end_ts\". When requesting based on time based annotations only pass in the first parameter, \"annotation\" and leave out the second \"value\". If looking for a key-value binary annotation provide both, \"annotation\" is then the key in the key-value. Timestamps are in microseconds. Parameters: - service_name - annotation - value - end_ts - limit - order", "response": "def getTraceIdsByAnnotation(self, service_name, annotation, value, end_ts, limit, order):\n    \"\"\"\n    Fetch trace ids with a particular annotation.\n    Gets \"limit\" number of entries from before the \"end_ts\".\n\n    When requesting based on time based annotations only pass in the first parameter, \"annotation\" and leave out\n    the second \"value\". If looking for a key-value binary annotation provide both, \"annotation\" is then the\n    key in the key-value.\n\n    Timestamps are in microseconds.\n\n    Parameters:\n     - service_name\n     - annotation\n     - value\n     - end_ts\n     - limit\n     - order\n    \"\"\"\n    self.send_getTraceIdsByAnnotation(service_name, annotation, value, end_ts, limit, order)\n    return self.recv_getTraceIdsByAnnotation()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getTracesByIds(self, trace_ids, adjust):\n    self.send_getTracesByIds(trace_ids, adjust)\n    return self.recv_getTracesByIds()", "response": "This method is used to get the full traces associated with the given trace ids."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getTraceTimelinesByIds(self, trace_ids, adjust):\n    self.send_getTraceTimelinesByIds(trace_ids, adjust)\n    return self.recv_getTraceTimelinesByIds()", "response": "This method returns the trace timelines associated with the given trace ids."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getTraceSummariesByIds(self, trace_ids, adjust):\n    self.send_getTraceSummariesByIds(trace_ids, adjust)\n    return self.recv_getTraceSummariesByIds()", "response": "This method is used to fetch trace summaries for the given trace ids."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getTraceCombosByIds(self, trace_ids, adjust):\n    self.send_getTraceCombosByIds(trace_ids, adjust)\n    return self.recv_getTraceCombosByIds()", "response": "Get a list of traces by IDs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setTraceTimeToLive(self, trace_id, ttl_seconds):\n    self.send_setTraceTimeToLive(trace_id, ttl_seconds)\n    self.recv_setTraceTimeToLive()", "response": "Sets the TTL of a trace."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getDependencies(self, start_time, end_time):\n    self.send_getDependencies(start_time, end_time)\n    return self.recv_getDependencies()", "response": "This method returns the aggregate representation of all services paired with every service they call in to."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a time stamp, server service name, and rpc name, fetch all of the client services calling in paired with the lists of every span duration (list<i64>) from the server to client. The lists of span durations include information on call counts and mean/stdDev/etc of call durations. The three arguments specify epoch time in microseconds, server side service name and rpc name. The return maps contains the key - client_service_name and value - list<span_durations>. Parameters: - time_stamp - service_name - rpc_name", "response": "def getSpanDurations(self, time_stamp, service_name, rpc_name):\n    \"\"\"\n    Given a time stamp, server service name, and rpc name, fetch all of the client services calling in paired\n    with the lists of every span duration (list<i64>) from the server to client. The lists of span durations\n    include information on call counts and mean/stdDev/etc of call durations.\n\n    The three arguments specify epoch time in microseconds, server side service name and rpc name. The return maps\n    contains the key - client_service_name and value - list<span_durations>.\n\n    Parameters:\n     - time_stamp\n     - service_name\n     - rpc_name\n    \"\"\"\n    self.send_getSpanDurations(time_stamp, service_name, rpc_name)\n    return self.recv_getSpanDurations()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a time stamp, server service name, and rpc name, fetch all of the client services calling in paired with the lists of every trace Ids (list<i64>) from the server to client. The three arguments specify epoch time in microseconds, server side service name and rpc name. The return maps contains the key - client_service_name and value - list<trace_id>. Parameters: - time_stamp - service_name - rpc_name", "response": "def getServiceNamesToTraceIds(self, time_stamp, service_name, rpc_name):\n    \"\"\"\n    Given a time stamp, server service name, and rpc name, fetch all of the client services calling in paired\n    with the lists of every trace Ids (list<i64>) from the server to client.\n\n    The three arguments specify epoch time in microseconds, server side service name and rpc name. The return maps\n    contains the key - client_service_name and value - list<trace_id>.\n\n    Parameters:\n     - time_stamp\n     - service_name\n     - rpc_name\n    \"\"\"\n    self.send_getServiceNamesToTraceIds(time_stamp, service_name, rpc_name)\n    return self.recv_getServiceNamesToTraceIds()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef discover_datasources(datastore_str):\n    \n    datastore = DataStore(datastore_str)\n    datasources=[]\n    for ds in datastore.get_datasources():\n        datasources.append({'text':ds.name, 'type':ds.type, 'id':ds.getHash(), 'leaf': True})\n    return datasources", "response": "Discover the datasources contained in the datastore"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef discover_datasource_columns(datastore_str, datasource_id):\n    datastore = DataStore(datastore_str)\n    datasource = datastore.get_datasource(datasource_id)\n    if datasource.type != \"RASTER\":\n        return datasource.list_columns()\n    else:\n        return []", "response": "Find the datasource s columns and return them as a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_column_type(self,column):\n        ctype = column.GetType()\n        if ctype in [ogr.OFTInteger, ogr.OFTReal]:\n            return 'numeric'\n        else:\n            return 'string'", "response": "Return numeric if the column is of type integer or\n        real otherwise return string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_default_mapfile_excerpt(self):\n            \n        layerobj = self._get_layer_stub()\n        classobj = mapscript.classObj() \n        layerobj.insertClass(classobj)\n        styleobj = self._get_default_style()\n        classobj.insertStyle(styleobj)\n        \n        return mapserializer.layerobj_to_dict(layerobj,None)", "response": "Create and return a MapFile LAYER block."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a minimal mapscript layerobj with no styling", "response": "def _get_layer_stub(self):\n        \"\"\" builds a minimal mapscript layerobj, with no styling \"\"\"\n        layerobj = mapscript.layerObj()\n        layerobj.name = self.name\n        layerobj.status = mapscript.MS_ON\n        projection = self.ogr_layer.GetSpatialRef()\n        featureIdColumn = self._get_featureId_column()\n        if featureIdColumn is not None and featureIdColumn != '' :\n            layerobj.metadata.set('gml_featureid', featureIdColumn)\n        if projection is not None:\n            layerobj.setProjection(projection.ExportToProj4())\n        if self.datastore.connection_type == \"directory\":\n            #append the extension to the shapefile until mapserver bug 2895 is fixed\n            datastr = os.path.normpath(self.datastore.datastore_str + \"/\" + self.name)\n            if os.path.exists(datastr+'.shp'):\n                datastr = datastr+'.shp'\n            elif os.path.exists(datastr+'.SHP'):\n                datastr = datastr+'.SHP'\n            layerobj.data = datastr\n        elif self.datastore.connection_type == \"postgis\":\n            layerobj.connectiontype = mapscript.MS_POSTGIS\n            #remove the leading \"PG:\" from the connection string\n            layerobj.connection = self.datastore.datastore_str[3:].strip()\n            if featureIdColumn is not None and featureIdColumn != '' :\n                layerobj.data = \"%s from %s using unique %s\" %(\n                    self.ogr_layer.GetGeometryColumn(),\n                    self.name,\n                    featureIdColumn)\n            else:\n                layerobj.data = \"%s from %s\"%(self.ogr_layer.GetGeometryColumn(),self.name)\n        else:\n            raise RuntimeError(\"unsupported connection type\")\n        if self.type == 'POINT':\n            layerobj.type = mapscript.MS_LAYER_POINT\n        elif self.type == 'POLYGON':\n            layerobj.type = mapscript.MS_LAYER_POLYGON\n        else:\n            layerobj.type = mapscript.MS_LAYER_LINE\n        return layerobj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_app(global_conf, full_stack=True, **app_conf):\n    # Configure the Pylons environment\n    load_environment(global_conf, app_conf)\n\n    # The Pylons WSGI app\n    app = PylonsApp()\n    \n    # CUSTOM MIDDLEWARE HERE (filtered by error handling middlewares)\n    # Authentication middleware\n    app = AuthMiddleware(app)\n\n    # Routing/Session/Cache Middleware\n    app = RoutesMiddleware(app, config['routes.map'])\n    app = SessionMiddleware(app, config)\n    app = CacheMiddleware(app, config)\n    \n    if asbool(full_stack):\n        # Handle Python exceptions\n        app = ErrorHandler(app, global_conf, **config['pylons.errorware'])\n\n        # Display error documents for 401, 403, 404 status codes (and\n        # 500 when debug is disabled)\n        if asbool(config['debug']):\n            app = StatusCodeRedirect(app)\n        else:\n            app = StatusCodeRedirect(app, [400, 401, 403, 404, 500])\n\n    # Establish the Registry for this application\n    app = RegistryManager(app)\n\n    # Static files (If running in production, and Apache or another web \n    # server is handling this static content, remove the following 2 lines)\n    static_app = StaticURLParser(config['pylons.paths']['static_files'])\n    app = Cascade([static_app, app])\n\n    return app", "response": "Create a Pylons WSGI application and return it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reelect_app(self, request, app):\n\n        # disconnect app explicitly to break possibly existing connection\n        app.disconnect()\n        endpoints_size = len(app.locator.endpoints)\n\n        # try x times, where x is the number of different endpoints in app locator.\n        for _ in xrange(0, endpoints_size + 1):\n            # last chance to take app from common pool\n            if len(app.locator.endpoints) == 0:\n                request.logger.info(\n                    \"giving up on connecting to dist-info hosts, falling back to common pool processing\")\n                app = yield self.proxy.reelect_app(request, app)\n                raise gen.Return(app)\n\n            try:\n                # always create new locator to prevent locking as we do connect with timeout\n                # however lock can be still held during TCP timeout\n                locator = Locator(endpoints=app.locator.endpoints)\n                request.logger.info(\"connecting to locator %s\", locator.endpoints[0])\n\n                # first try to connect to locator only on remote host with timeout\n                yield gen.with_timeout(self.service_connect_timeout, locator.connect())\n                request.logger.debug(\"connected to locator %s for %s\", locator.endpoints[0], app.name)\n                app = Service(app.name, locator=locator, timeout=RESOLVE_TIMEOUT)\n\n                # try to resolve and connect to application itself\n                yield gen.with_timeout(self.service_connect_timeout, app.connect())\n                request.logger.debug(\"connected to application %s via %s\", app.name, app.endpoints)\n            except gen.TimeoutError:\n                # on timeout try next endpoint first\n                request.logger.warning(\"timed out while connecting to application\")\n                continue\n            except ServiceError as err:\n                request.logger.warning(\"got error while resolving app - %s\", err)\n                if err.category in LOCATORCATEGORY and err.code == ESERVICENOTAVAILABLE:\n                    # if the application is down - also try next endpoint\n                    continue\n                else:\n                    raise err\n            finally:\n                # drop first endpoint to start next connection from different endpoint\n                # we do this, as default logic of connection attempts in locator do not fit here\n                app.locator.endpoints = app.locator.endpoints[1:]\n            # return connected app\n            raise gen.Return(app)\n        raise PluginApplicationError(42, 42, \"could not connect to application\")", "response": "try to connect to the same application on differnet host from dist - info"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a single entity from Wikidata.", "response": "def wikidata_get(identifier):\n    \"\"\"\n        https://www.wikidata.org/wiki/Special:EntityData/P248.json\n    \"\"\"\n    url = 'https://www.wikidata.org/wiki/Special:EntityData/{}.json'.format(identifier)\n    #logging.info(url)\n    return json.loads(requests.get(url).content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wikidata_search(query, lang=\"zh\", output_lang=\"en\",  searchtype=\"item\",  max_result=1):\n    query = any2unicode(query)\n    params = {\n        \"action\":\"wbsearchentities\",\n        \"search\": query,\n        \"format\":\"json\",\n        \"language\":lang,\n        \"uselang\":output_lang,\n        \"type\":searchtype\n    }\n    urlBase = \"https://www.wikidata.org/w/api.php?\"\n    url = urlBase + urllib.urlencode(any2utf8(params))\n    #logging.info(url)\n    r = requests.get(url)\n    results = json.loads(r.content).get(\"search\",[])\n    #logging.info(items)\n\n    property_list = [\n        {\"name\":\"name\", \"alternateName\":[\"label\"]},\n        {\"name\":\"url\", \"alternateName\":[\"concepturi\"]},\n        {\"name\":\"identifier\", \"alternateName\":[\"id\"]},\n        {\"name\":\"description\"},\n    ]\n    items = []\n    ret = {\"query\": query, \"itemList\":items}\n    for result in results[0:max_result]:\n        #logging.info(result)\n        item = json_dict_copy(result, property_list)\n        items.append(item)\n    return ret", "response": "Search the Wikidata API for the given query."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wikipedia_search(query, lang=\"en\", max_result=1):\n    query = any2unicode(query)\n    params = {\n        \"action\":\"opensearch\",\n        \"search\": query,\n        \"format\":\"json\",\n        #\"formatversion\":2,\n        #\"namespace\":0,\n        \"suggest\":\"true\",\n        \"limit\": 10\n    }\n    urlBase = \"https://{}.wikipedia.org/w/api.php?\".format(lang)\n    url = urlBase + urllib.urlencode(any2utf8(params))\n    #logging.info(url)\n    r = requests.get(url)\n    jsonData = json.loads(r.content)\n    #logging.info(jsonData)\n\n    items = []\n    ret = {\"query\":query, \"itemList\":items}\n    for idx, label in enumerate(jsonData[1][0:max_result]):\n        description = jsonData[2][idx]\n        url = jsonData[3][idx]\n\n        item = {\n            \"name\": label,\n            \"description\":description,\n            \"url\": url,\n        }\n        items.append(item)\n\n    return ret", "response": "Search the Wikipedia page for items."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pip(filename):\n    '''Parse pip requirement file and transform it to setuptools requirements'''\n    path = join('requirements', filename)\n    return [line for line in open(path).readlines() if not line.startswith('-e')]", "response": "Parse pip requirement file and transform it to setuptools requirements"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef RedirectDemo(handler, t):\n    # t.say (\"One moment please.\")\n    t.redirect(SIP_PHONE)\n    json = t.RenderJson()\n    logging.info (\"RedirectDemo json: %s\" % json)\n    handler.response.out.write(json)", "response": "Redirecting to another number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef TransferDemo(handler, t):\n    t.say (\"One moment please.\")\n    t.transfer(MY_PHONE)\n    t.say(\"Hi. I am a robot\")\n    json = t.RenderJson()\n    logging.info (\"TransferDemo json: %s\" % json)\n    handler.response.out.write(json)", "response": "Demo for transfering to another number"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _custom_response_edit(self, method, url, headers, body, response):\n        if self.get_implementation().is_mock():\n            delay = self.get_setting(\"MOCKDATA_DELAY\", 0.0)\n            time.sleep(delay)\n            self._edit_mock_response(method, url, headers, body, response)", "response": "This method allows a service to edit a response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef postURL(self, url, headers={}, body=None):\n        return self._load_resource(\"POST\", url, headers, body)", "response": "Request a URL using the HTTP method POST."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrequesting a URL using the HTTP method PUT.", "response": "def putURL(self, url, headers, body=None):\n        \"\"\"\n        Request a URL using the HTTP method PUT.\n        \"\"\"\n        return self._load_resource(\"PUT\", url, headers, body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrequests a URL using the HTTP method PATCH.", "response": "def patchURL(self, url, headers, body):\n        \"\"\"\n        Request a URL using the HTTP method PATCH.\n        \"\"\"\n        return self._load_resource(\"PATCH\", url, headers, body)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a ConnectionPool instance of given host.", "response": "def create_pool(self):\n        \"\"\"\n        Return a ConnectionPool instance of given host\n        :param socket_timeout:\n            socket timeout for each connection in seconds\n        \"\"\"\n\n        service = self.dao.service_name()\n\n        ca_certs = self.dao.get_setting(\"CA_BUNDLE\",\n                                        \"/etc/ssl/certs/ca-bundle.crt\")\n        cert_file = self.dao.get_service_setting(\"CERT_FILE\", None)\n        host = self.dao.get_service_setting(\"HOST\")\n        key_file = self.dao.get_service_setting(\"KEY_FILE\", None)\n        max_pool_size = int(self.dao.get_service_setting(\"POOL_SIZE\", 10))\n        socket_timeout = int(self.dao.get_service_setting(\"TIMEOUT\", 2))\n        verify_https = self.dao.get_service_setting(\"VERIFY_HTTPS\")\n\n        if verify_https is None:\n            verify_https = True\n\n        kwargs = {\n            \"retries\": Retry(total=1, connect=0, read=0, redirect=1),\n            \"timeout\": socket_timeout,\n            \"maxsize\": max_pool_size,\n            \"block\": True,\n        }\n\n        if key_file is not None and cert_file is not None:\n            kwargs[\"key_file\"] = key_file\n            kwargs[\"cert_file\"] = cert_file\n\n        if urlparse(host).scheme == \"https\":\n            kwargs[\"ssl_version\"] = self.dao.get_service_setting(\n                \"SSL_VERSION\", ssl.PROTOCOL_TLSv1)\n            if verify_https:\n                kwargs[\"cert_reqs\"] = \"CERT_REQUIRED\"\n                kwargs[\"ca_certs\"] = ca_certs\n\n        return connection_from_url(host, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_schema_loader(self, strict=False):\n        return functools.partial(schema.load_schema, version=self.version,\n                                 strict=strict)", "response": "Gets a closure for schema. load_schema with the correct version"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconfiguring the Pylons environment via the pylons. config object", "response": "def load_environment(global_conf, app_conf):\n    \"\"\"Configure the Pylons environment via the ``pylons.config``\n    object\n    \"\"\"\n    # Pylons paths\n    root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    paths = dict(root=root,\n                 controllers=os.path.join(root, 'controllers'),\n                 static_files=os.path.join(root, 'public'),\n                 templates=[os.path.join(root, 'templates')])\n\n    # Initialize config with the basic options\n    config.init_app(global_conf, app_conf, package='studio', paths=paths)\n\n    # Defines custom config parameters\n    config['resources_dir'] = os.path.join(root, 'resources')\n    # path to mapserver dir containing default fonts and symbols\n    config['mapserver_dir'] = os.path.join(config['resources_dir'], 'mapserver')\n    # path to default directory datastore\n    config['default_datastore_dir'] = os.path.join(config['resources_dir'], 'default_datastore')\n    # path to the template including the <script> tags\n    config['js_tmpl'] = os.path.join(paths['templates'][0], 'index.html')\n\n    # Convert the debug variable from the config to a boolean value\n    config['debug'] = asbool(config['debug'])\n\n    config['routes.map'] = make_map()\n    config['pylons.app_globals'] = app_globals.Globals()\n    config['pylons.h'] = studio.lib.helpers\n\n    # Create the Mako TemplateLookup, with the default auto-escaping\n    config['pylons.app_globals'].mako_lookup = TemplateLookup(\n        directories=paths['templates'],\n        error_handler=handle_mako_error,\n        module_directory=os.path.join(app_conf['cache_dir'], 'templates'),\n        input_encoding='utf-8', output_encoding='utf-8',\n        imports=['from webhelpers.html import escape'],\n        default_filters=['escape'])\n    \n    # Setup SQLAlchemy database engine\n    engine = engine_from_config(config, 'sqlalchemy.')\n    init_model(engine)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_map():\n    map = Mapper(directory=config['pylons.paths']['controllers'],\n                 always_scan=config['debug'], explicit=True)\n    map.minimization = False\n    \n    # The ErrorController route (handles 404/500 error pages); it should\n    # likely stay at the top, ensuring it can always be resolved\n    map.connect('/error/{action}', controller='error')\n    map.connect('/error/{action}/{id}', controller='error')\n\n    # CUSTOM ROUTES HERE\n\n    # mapfiles routes\n    map.connect('/mapfiles/default', controller='mapfiles', action='get_default_mapfile') \n    map.resource('MapFiles','mapfiles') \n    map.connect('/mapfiles/{id}/symbols', controller='mapfiles', action='get_symbols')\n    map.connect('/mapfiles/{id}/fonts', controller='mapfiles', action='get_fonts')\n    map.connect('/mapfiles/{id}/download', controller='mapfiles', action='download_mapfile') \n    map.connect('/mapfiles/{id}/wms', controller='mapfiles', action='wms_proxy') \n\n    # datastores routes\n    map.resource('DataStores', 'datastores')\n\n    # datasources routes\n    map.connect('/datastores/{datastore_id}/datasources',\n                controller='datasources', conditions={'method': ['POST']}, action='create')\n    map.connect('/datastores/{datastore_id}/datasources',\n                controller='datasources', action='index')\n    map.connect('/datastores/{datastore_id}/datasources/{datasource_id}',\n                controller='datasources', action='show')\n    map.connect('/datastores/{datastore_id}/datasources/{datasource_id}/columns',\n                controller='datasources', action='showcolumns')\n    map.connect('/datastores/{datastore_id}/datasources/{datasource_id}/mapfile',\n                controller='datasources', action='showmapfile')\n\n    # layertemplates routes\n    map.resource('LayerTemplates', 'layertemplates')\n\n    # auth routes\n    map.connect('/signin', controller='main', action='signin')\n    map.connect('/signout', controller='main', action='signout')\n\n    # default route for root ;)\n    map.connect('/', controller='main', action='index')\n    map.connect('/layout.js', controller='main', action='layout')\n\n    map.connect('/{controller}/{action}')\n    map.connect('/{controller}/{action}/{id}')\n\n\n    return map", "response": "Create and configure and return the routes Mapper"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding the nodes that are not in the tree.", "response": "def _uptrace(nodelist, node):\n    '''\n    \ub178\ub4dc\ub97c \uc0c1\ud5a5 \ucd94\uc801\ud55c\ub2e4.\n\n    \ud604 \ub178\ub4dc\ub85c\ubd80\ud130 \uc870\uc0c1 \ub178\ub4dc\ub4e4\uc744 \ucc28\ub840\ub85c \uc21c\ud68c\ud558\uba70 \ubc18\ud658\ud55c\ub2e4.\n    \ub8e8\ud2b8 \ub178\ub4dc\ub294 \uc81c\uc678\ud55c\ub2e4.\n    '''\n\n    if node.parent_index is None:\n        return\n    parent = nodelist[node.parent_index]\n    for x in _uptrace(nodelist, parent):\n        yield x\n    yield node"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndecorates f to run inside the directory where setup.py resides.", "response": "def setup_dir(f):\n    ''' Decorate f to run inside the directory where setup.py resides.\n    '''\n    setup_dir = os.path.dirname(os.path.abspath(__file__))\n\n    def wrapped(*args, **kwargs):\n        with chdir(setup_dir):\n            return f(*args, **kwargs)\n\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef feedback_form(context):\n    user = None\n    url = None\n    if context.get('request'):\n        url = context['request'].path\n        if context['request'].user.is_authenticated():\n            user = context['request'].user\n    return {\n        'form': FeedbackForm(url=url, user=user),\n        'background_color': FEEDBACK_FORM_COLOR,\n        'text_color': FEEDBACK_FORM_TEXTCOLOR,\n        'text': FEEDBACK_FORM_TEXT,\n    }", "response": "Template tag to render a feedback form."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\njoins the items to be selected and inserts the current table name", "response": "def select(self, *itms):\n        \"\"\"Joins the items to be selected and inserts the current table name\"\"\"\n        if not itms:\n            itms = ['*']\n        self.terms.append(\"select %s from %s\" % (', '.join(itms), self.table))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _in(self, *lst):\n        self.terms.append('in (%s)' % ', '.join(['\"%s\"' % x for x in lst]))\n        return self", "response": "Build out the in clause. Using _in due to shadowing for in"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompiles the query to be passed to Yahoo YQL", "response": "def compile(self):\n        \"\"\"Take all of the 'parts' components and build the complete query to be passed\n           to Yahoo YQL\"\"\"\n        cs = \"\"\n        for term in self.terms:\n            if cs:\n                cs += \" \"\n            cs += term\n        self.compiled_str = urllib.parse.quote(cs)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        self.compile()\n\n        s = \"%s&format=%s\" % (self.compiled_str, self.format)\n        s = \"%s%s&env=%s\" % (self.endpoint, s, urllib.parse.quote(self.store))\n\n        self.conn.request(\"GET\", s)\n        r = self.conn.getresponse()\n        r = r.read().decode('UTF-8')\n        if self.format is \"json\":\n            return json.loads(r)\n        else:\n            return r", "response": "Execute the query inside of self. compiled_str. This method returns a JSON\n           object for easy manipulation unless another format is specified."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates filenames. :param tuple sources: Sequence of strings representing path to file(s). :return: Path to file(s). :rtype: :py:class:`str`", "response": "def _generate_filenames(sources):\n    \"\"\"Generate filenames.\n\n    :param tuple sources: Sequence of strings representing path to file(s).\n    :return: Path to file(s).\n    :rtype: :py:class:`str`\n    \"\"\"\n    for source in sources:\n        if os.path.isdir(source):\n            for path, dirlist, filelist in os.walk(source):\n                for fname in filelist:\n                    if GenericFilePath.is_compressed(fname):\n                        if VERBOSE:\n                            print(\"Skipping compressed file: {}\".format(os.path.abspath(fname)))\n                        continue\n                    else:\n                        yield os.path.join(path, fname)\n\n        elif os.path.isfile(source):\n            yield source\n\n        elif source.isdigit():\n            analysis_id = \"AN{}\".format(source.zfill(6))\n            url = MWREST.format(analysis_id)\n            yield url\n\n        elif GenericFilePath.is_url(source):\n            yield source\n\n        else:\n            raise TypeError(\"Unknown file source.\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _generate_handles(filenames):\n    for fname in filenames:\n        path = GenericFilePath(fname)\n        for filehandle, source in path.open():\n            yield filehandle, source\n            filehandle.close()", "response": "Open a sequence of filenames one at a time producing file objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a generator that yields file instances.", "response": "def read_files(*sources, **kwds):\n    \"\"\"Construct a generator that yields file instances.\n\n    :param sources: One or more strings representing path to file(s).\n    \"\"\"\n    filenames = _generate_filenames(sources)\n    filehandles = _generate_handles(filenames)\n    for fh, source in filehandles:\n        try:\n            f = mwtab.MWTabFile(source)\n            f.read(fh)\n\n            if kwds.get('validate'):\n                validator.validate_file(mwtabfile=f,\n                                        section_schema_mapping=mwschema.section_schema_mapping,\n                                        validate_samples=True,\n                                        validate_factors=True)\n            yield f\n\n            if VERBOSE:\n                print(\"Processed file: {}\".format(os.path.abspath(source)))\n\n        except Exception as e:\n            if VERBOSE:\n                print(\"Error processing file: \", os.path.abspath(source), \"\\nReason:\", e)\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if path represents compressed file.", "response": "def is_compressed(path):\n        \"\"\"Test if path represents compressed file(s).\n\n        :param str path: Path to file(s).\n        :return: String specifying compression type if compressed, \"\" otherwise.\n        :rtype: :py:class:`str`\n        \"\"\"\n        if path.endswith(\".zip\"):\n            return \"zip\"\n        elif path.endswith(\".tar.gz\"):\n            return \"tar.gz\"\n        elif path.endswith(\".tar.bz2\"):\n            return \"tar.bz2\"\n        elif path.endswith(\".gz\"):\n            return \"gz\"\n        elif path.endswith(\".bz2\"):\n            return \"bz2\"\n        elif path.endswith(\".tar\"):\n            return \"tar\"\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_url(path):\n        try:\n            parse_result = urlparse(path)\n            return all((parse_result.scheme, parse_result.netloc, parse_result.path))\n        except ValueError:\n            return False", "response": "Test if path represents a valid url string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef AuthMiddleware(app):\n    # url_for mustn't be used here because AuthMiddleware is built once at startup,\n    # url path can be reconstructed only on http requests (based on environ)\n    basic_redirect_form = BasicRedirectFormPlugin(login_form_url=\"/signin\",\n                                                  login_handler_path=\"/login\",\n                                                  post_login_url=\"/\",\n                                                  logout_handler_path=\"/logout\",\n                                                  post_logout_url=\"/signin\",\n                                                  rememberer_name=\"cookie\")\n\n    return setup_sql_auth(\n            app,\n            user_class = model.User,\n            group_class = model.Group,\n            permission_class = model.Permission,\n            dbsession = model.meta.Session,\n            form_plugin = basic_redirect_form,\n            cookie_secret = config['cookie_secret'],\n            translations = {\n                'user_name': 'login',\n                'users': 'users',\n                'group_name': 'name',\n                'groups': 'groups',\n                'permission_name': 'name',\n                'permissions': 'permissions',\n                'validate_password': 'validate_password'},\n            )", "response": "Add authentication and authorization middleware to the app."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the full path to the given path.", "response": "def _get_full_path(self, path, environ):\n        \"\"\"\n        Return the full path to ``path`` by prepending the SCRIPT_NAME.\n        \n        If ``path`` is a URL, do nothing.\n        \n        \"\"\"\n        if path.startswith('/'):\n            path = environ.get('SCRIPT_NAME', '') + path\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _replace_qs(self, url, qs):\n        url_parts = list(urlparse(url))\n        url_parts[4] = qs\n        return urlunparse(url_parts)", "response": "Replace the query string of url with qs and return the new URL."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef storeTopAnnotations(self, service_name, annotations):\n    self.send_storeTopAnnotations(service_name, annotations)\n    self.recv_storeTopAnnotations()", "response": "Stores the given annotations for the specified service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstore the given annotations in the specified service.", "response": "def storeTopKeyValueAnnotations(self, service_name, annotations):\n    \"\"\"\n    Parameters:\n     - service_name\n     - annotations\n    \"\"\"\n    self.send_storeTopKeyValueAnnotations(service_name, annotations)\n    self.recv_storeTopKeyValueAnnotations()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(self):\n        with open(storage.config_file, 'w') as cfg:\n            yaml.dump(self.as_dict(), cfg, default_flow_style=False)\n\n        storage.refresh()", "response": "write the current settings to the config file"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef params(**kwargs):\n\n    # Types that we'll all for as 'tuple' params\n    TUPLE_TYPES = tuple, set, frozenset, list\n    if (sys.version_info > (3, 0)):\n        VALID_TYPES = int, float, str, bool\n    else:\n        VALID_TYPES = int, float, str, unicode, bool\n\n    class ParamValidator(object):\n        # name\n        param_name = None  # the name of the param in the request, e.g. 'user_id' (even if we pass 'user' to the Fn)\n\n        # type\n        param_type = None\n\n        # method - explicitly allow a certain method. If both are false we'll use defaults\n        allow_GET = False\n        allow_POST = False\n\n        # value validators\n        gt = None\n        gte = None\n        lt = None\n        lte = None\n        eq = None\n\n        # optional\n        optional = False\n        default = None\n\n        # multiple vals\n        many = False\n\n        # django models only\n        deferred = True\n        field = 'id'\n\n        def __init__(self, arg_name, **kwargs):\n            self.param_name = arg_name\n            for k, v in kwargs.items():\n                setattr(self, k, v)\n\n        def check_type(self, param):\n            \"\"\" Check that the type of param is valid, or raise an Exception. This doesn't take self.many into account. \"\"\"\n            valid_type = True\n            if isinstance(self.param_type, TUPLE_TYPES):\n                if not param in self.param_type:\n                    raise Exception('invalid option \"%s\": Must be one of: %s' % (param, self.param_type))\n            else:\n                if self.param_type == int:\n                    param = int(param)\n                elif self.param_type == float:\n                    param = float(param)\n                elif self.param_type == str:\n                    assert(isinstance(param, (str, unicode)))\n                    param = unicode(param)\n                elif self.param_type == bool:\n                    param = str(param).lower()  # bool isn't case sensitive\n                    if param in TRUE_VALUES:\n                        param = True\n                    elif param in FALSE_VALUES:\n                        param = False\n                    else:\n                        raise Exception('%s is not a valid bool: must be one of: %s', param, TRUE_VALUES + FALSE_VALUES)\n                elif hasattr(self.param_type, '_default_manager'):  # isinstance(django.models.Model) doesn't seem to work, but this is a good tell\n                    query_set = self.param_type.objects\n                    if self.deferred:\n                        query_set = query_set.only('id')\n                    param = query_set.get(**{self.field: param})\n                else:\n                    valid_type = False\n            if not valid_type:\n                raise Exception(\"Invalid param type: %s\" % self.param_type.____name__)\n            return param\n\n        def check_value(self, param):\n            \"\"\" Check that a single value is lt/gt/etc. Doesn't take self.many into account. \"\"\"\n            val = None\n            if self.param_type == int or self.param_type == float:\n                val = param\n            elif self.param_type == str:\n                val = len(param)\n            if val:\n                try:\n                    if self.eq and val != self.eq:\n                        raise Exception(\"must be less than %s!\" % self.eq)\n                    else:\n                        if self.lt and val >= self.lt:\n                            raise Exception(\"must be less than %s!\" % self.lt)\n                        if self.lte and val > self.lte:\n                            raise Exception(\"must be less than or equal to %s!\" % self.lte)\n                        if self.gt and val <= self.gt:\n                            raise Exception(\"must be greater than %s!\" % self.gt)\n                        if self.gte and val < self.gte:\n                            raise Exception(\"must be greater than or equal to %s!\" % self.gte)\n                except Exception as e:\n                    msg = str(e)\n                    msg = (\"Length \" if self.param_type == str else 'Value ') + msg\n                    raise Exception(msg)\n\n    validators = {}\n\n    for k, v in kwargs.items():\n        parts = k.split('__')\n        param_key = parts[0]\n\n        if not param_key in validators:\n            validators[param_key] = ParamValidator(param_key)\n        obj = validators[param_key]\n\n        if (len(parts) == 1):\n            # set type\n            if not hasattr(v, '_default_manager'):  # django model\n                if not isinstance(v, TUPLE_TYPES) and not v in VALID_TYPES:\n                    raise Exception(\"Invalid type for %s: %s is not a valid type\" % (k, v))\n            obj.param_type = v\n        else:\n            # we only are interested in the last part, since the only thing that can be multipart is __length__eq (etc) and 'length' is not important\n            last_part = parts[-1]\n\n            if last_part == 'method':\n                if isinstance(v, TUPLE_TYPES):\n                    for method in v:\n                        if method == 'GET':\n                            obj.allow_GET = True\n                        elif method == 'POST':\n                            obj.allow_POST = True\n                        else:\n                            raise Exception('Invalid value for __method: \"%s\"' % method)\n                else:\n                    if v == 'GET':\n                        obj.allow_GET = True\n                    elif v == 'POST':\n                        obj.allow_POST = True\n                    else:\n                        raise Exception('Invalid value for __method: \"%s\"' % v)\n                continue\n\n            if last_part == 'name':\n                obj.param_name = v\n                continue\n\n            BOOL_PARTS = 'deferred', 'optional', 'many'\n            if last_part in BOOL_PARTS:\n                assert(isinstance(v, bool))\n                setattr(obj, last_part, v)\n                continue\n\n            NUM_PARTS = 'gt', 'gte', 'lt', 'lte', 'eq'\n            if last_part in NUM_PARTS:\n                assert(isinstance(v, int) or isinstance(v, float))\n                setattr(obj, last_part, v)\n                continue\n\n            if last_part == 'default':\n                obj.optional = True\n                obj.default = v\n                continue\n\n            if last_part == 'field':\n                assert(isinstance(last_part, str))\n                obj.field = v\n                continue\n\n            raise Exception(\"Invalid option: '__%s' in param '%s'\" % (last_part, k))\n\n    def _params(fn):\n\n        @wraps(fn)\n        def wrapped_request_fn(first_arg, *args, **kwargs):\n\n            if len(args) == 0:\n                request = first_arg  # request function is a top-level function\n            else:\n                request = args[0]  # request fn is a method, first_arg is 'self'\n\n            request_method = request.META['REQUEST_METHOD']\n            default_param_method = 'POST' if request_method == 'POST' or request_method == 'PUT' else 'GET'\n            # Validate the params\n            for arg_name, validator in validators.items():\n                param_name = validator.param_name\n\n                # what methods are allowed?\n                use_default_methods = not validator.allow_GET and not validator.allow_POST\n                allow_GET = (default_param_method == 'GET') if use_default_methods else validator.allow_GET\n                allow_POST = (default_param_method == 'POST') if use_default_methods else validator.allow_POST\n\n                # find the param\n                param = None\n                if allow_POST:\n                    param = request.DATA.get(param_name, None)\n                    param_type = 'POST'\n                if not param and allow_GET:\n                    param = request.GET.get(param_name, None)\n                    param_type = 'GET'\n\n                try:\n                    # optional/default\n                    if param is None:  # but not False, because that's a valid boolean param\n                        if not validator.optional:\n                            raise Exception('Param is missing')\n                        else:\n                            kwargs[arg_name] = validator.default\n                            continue\n\n                    # check type, value\n                    if validator.many:\n                        if param_type == 'GET':\n                            params = str(param).split(',')\n                        else:\n                            params = param if isinstance(param, list) else (param,)\n                        params = [validator.check_type(p) for p in params]\n                        [validator.check_value(p) for p in params]\n                    else:\n                        param = validator.check_type(param)\n                        validator.check_value(param)\n\n                except Exception as e:\n                    return Response({'error': 'Invalid param \"%s\": %s' % (param_name, str(e))}, status=status.HTTP_400_BAD_REQUEST)\n\n                kwargs[arg_name] = params if validator.many else param\n\n            return fn(first_arg, *args, **kwargs)\n        return wrapped_request_fn\n    return _params", "response": "Request fn decorator that builds up a list of params and automatically returns a 400 if they are invalid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef shorten(self, url, custom_url = None, log_stat = False):\n        '''\n            Shorten an URL using `is.gd - v.gd url shortener service <http://is.gd/developers.php>`_.\n            \n            :param url: URL that had to be shortened\n            :type url: str.\n            \n            :param custom_url: if specified, the url generated will be http://is.gd/<custom_url> (or http://v.gd/<custom_url>).\n            \n                Please note that if this custom url is unavailable (because it is already used, for example), a :class:`gdshortener.GDShortURLError` will be raised\n            \n            :type custom_url: str.\n            :param log_stat: States if the generated url has statistical analisys attached.\n                If the stats are enabled, a special url will show the stats on this shortened url. This special url is returned as second parameters of this function.\n                \n                Please notice that a stat enabled shorten url counts double in .gd rate exceeding monitor system.\n                \n                More information on `.gd FAQ <http://is.gd/faq.php#stats>`_ and `.gd rate limit <http://is.gd/usagelimits.php>`_.\n            :type log_stat: bool.\n            :returns:  (str,str) -- Shortened URL obtained by .gd service and Stat URL if requested (otherwhise is ``None``).\n            :raises: **IOError** when timeout with .gd service occurs\n            \n                **ValueError** if .gd response is malformed\n                \n                :class:`gdshortener.GDMalformedURLError` if the URL provided for shortening is malformed\n                \n                :class:`gdshortener.GDShortURLError` if the custom URL requested is not available\n                \n                :class:`gdshortener.GDRateLimitError` if the request rate is exceeded for .gd service\n                \n                :class:`gdshortener.GDGenericError` in case of generic error from .gd service (mainteinance)\n            \n        ''' \n        if url is None or not isinstance(url, basestring) or len(url.strip()) == 0:\n            raise GDMalformedURLError('The URL that had to be shorten must be a non empty string')\n        # Build data to post\n        data = {\n                'format':   'json',\n                'url':      url,\n                'logstats': 1 if log_stat else 0\n                }\n        if custom_url is not None and isinstance(custom_url, basestring) and len(custom_url.strip()) > 0:\n            data['shorturl'] = custom_url\n        opener = urllib2.build_opener()\n        headers = { 'User-Agent' : self._user_agent }\n        req = urllib2.Request(\"{0}/create.php\".format(self.shortener_url), urllib.urlencode(data), headers)\n        f_desc = opener.open(req, timeout = self._timeout)\n        response = json.loads(f_desc.read())\n        if 'shorturl' in response:\n            # Success!\n            return (str(response['shorturl']), None if not log_stat else '{0}/stats.php?url={1}'.format(self.shortener_url, str(response['shorturl'])[str(response['shorturl']).rindex('/') + 1:]))\n        else:\n            # Error\n            error_code = int(response['errorcode'])\n            error_description = str(response['errormessage'])\n            if error_code == 1:\n                raise GDMalformedURLError(error_description)\n            if error_code == 2:\n                raise GDShortURLError(error_description)\n            if error_code == 3:\n                raise GDRateLimitError(error_description)\n            if error_code == 4:\n                raise GDGenericError(error_description)", "response": "Shorten an url using is. gd - url shortener service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_bind_param(self, value, dialect):\n        if value is not None:\n            value = simplejson.dumps(value)\n        return value", "response": "convert value from python object to json"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_result_value(self, value, dialect):\n        if value is not None:\n            value = simplejson.loads(value)\n        return value", "response": "convert value from json to python object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves leading and trailing blank lines from a docstring.", "response": "def trim_docstring(docstring):\n    \"\"\"Taken from http://www.python.org/dev/peps/pep-0257/\"\"\"\n    if not docstring:\n        return ''\n\n    # Convert tabs to spaces (following the normal Python rules)\n    # and split into a list of lines:\n    lines = docstring.expandtabs().splitlines()\n\n    # Determine minimum indentation (first line doesn't count):\n    indent = maxsize\n    for line in lines[1:]:\n        stripped = line.lstrip()\n        if stripped:\n            indent = min(indent, len(line) - len(stripped))\n\n    # Remove indentation (first line is special):\n    lines[0] = lines[0].strip()\n    if indent < maxsize:\n        index = 1\n        for line in lines[1:]:\n            lines[index] = line[indent:].rstrip()\n            index += 1\n\n    # Strip off trailing and leading blank lines:\n    while lines and not lines[-1]:\n        del lines[-1]\n    while lines and not lines[0]:\n        del lines[0]\n\n    # Return a single string:\n    return '\\n'.join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds the brief module info from a file", "response": "def getBriefModuleInfoFromFile(fileName):\n    \"\"\"Builds the brief module info from file\"\"\"\n    modInfo = BriefModuleInfo()\n    _cdmpyparser.getBriefModuleInfoFromFile(modInfo, fileName)\n    modInfo.flush()\n    return modInfo"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getBriefModuleInfoFromMemory(content):\n    modInfo = BriefModuleInfo()\n    _cdmpyparser.getBriefModuleInfoFromMemory(modInfo, content)\n    modInfo.flush()\n    return modInfo", "response": "Builds the brief module info from memory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nproviding a name for display purpose respecting the alias", "response": "def getDisplayName(self):\n        \"\"\"Provides a name for display purpose respecting the alias\"\"\"\n        if self.alias == \"\":\n            return self.name\n        return self.name + \" as \" + self.alias"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getDisplayName(self):\n        displayName = self.name\n        if self.arguments:\n            displayName += \"(\" + \", \".join(self.arguments) + \")\"\n        return displayName", "response": "Provides a name for display purpose"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef niceStringify(self, level):\n        out = level * \"    \" + \\\n            \"Function[\" + str(self.keywordLine) + \\\n            \":\" + str(self.keywordPos) + \\\n            \":\" + self._getLPA() + \\\n            \":\" + str(self.colonLine) + \\\n            \":\" + str(self.colonPos) + \\\n            \"]: '\" + self.name + \"'\"\n        if self.isAsync:\n            out += \" (async)\"\n        if self.returnAnnotation is not None:\n            out += \" -> '\" + self.returnAnnotation + \"'\"\n        for item in self.arguments:\n            out += '\\n' + level * \"    \" + \"Argument: '\" + str(item) + \"'\"\n        for item in self.decorators:\n            out += '\\n' + level * \"    \" + str(item)\n        if self.docstring is not None:\n            out += '\\n' + level * \"    \" + str(self.docstring)\n        for item in self.functions:\n            out += '\\n' + item.niceStringify(level + 1)\n        for item in self.classes:\n            out += '\\n' + item.niceStringify(level + 1)\n        return out", "response": "Returns a string representation of the current object with new lines and shifts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprovide a name for display purpose", "response": "def getDisplayName(self):\n        \"\"\"Provides a name for display purpose\"\"\"\n        displayName = self.name + \"(\"\n        if self.isAsync:\n            displayName = \"async \" + displayName\n        first = True\n        for arg in self.arguments:\n            if first:\n                displayName += str(arg)\n                first = False\n            else:\n                displayName += \", \" + str(arg)\n        displayName += \")\"\n        if self.returnAnnotation is not None:\n            displayName += ' -> ' + self.returnAnnotation\n        return displayName"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nflushing the collected information", "response": "def flush(self):\n        \"\"\"Flushes the collected information\"\"\"\n        self.__flushLevel(0)\n        if self.__lastImport is not None:\n            self.imports.append(self.__lastImport)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmerge the found objects to the required level", "response": "def __flushLevel(self, level):\n        \"\"\"Merge the found objects to the required level\"\"\"\n        objectsCount = len(self.objectsStack)\n\n        while objectsCount > level:\n            lastIndex = objectsCount - 1\n            if lastIndex == 0:\n                # We have exactly one element in the stack\n                if self.objectsStack[0].__class__.__name__ == \"Class\":\n                    self.classes.append(self.objectsStack[0])\n                else:\n                    self.functions.append(self.objectsStack[0])\n                self.objectsStack = []\n                break\n\n            # Append to the previous level\n            if self.objectsStack[lastIndex].__class__.__name__ == \"Class\":\n                self.objectsStack[lastIndex - 1].classes. \\\n                    append(self.objectsStack[lastIndex])\n            else:\n                self.objectsStack[lastIndex - 1].functions. \\\n                    append(self.objectsStack[lastIndex])\n\n            del self.objectsStack[lastIndex]\n            objectsCount -= 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _onGlobal(self, name, line, pos, absPosition, level):\n        # level is ignored\n        for item in self.globals:\n            if item.name == name:\n                return\n        self.globals.append(Global(name, line, pos, absPosition))", "response": "Memorizes a global variable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmemorizing an imported item", "response": "def _onWhat(self, name, line, pos, absPosition):\n        \"\"\"Memorizes an imported item\"\"\"\n        self.__lastImport.what.append(ImportWhat(name, line, pos, absPosition))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _onClassAttribute(self, name, line, pos, absPosition, level):\n        # A class must be on the top of the stack\n        attributes = self.objectsStack[level].classAttributes\n        for item in attributes:\n            if item.name == name:\n                return\n        attributes.append(ClassAttribute(name, line, pos, absPosition))", "response": "Memorizes a class attribute"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmemorizes a class instance attribute", "response": "def _onInstanceAttribute(self, name, line, pos, absPosition, level):\n        \"\"\"Memorizes a class instance attribute\"\"\"\n        # Instance attributes may appear in member functions only so we already\n        # have a function on the stack of objects. To get the class object one\n        # more step is required so we -1 here.\n        attributes = self.objectsStack[level - 1].instanceAttributes\n        for item in attributes:\n            if item.name == name:\n                return\n        attributes.append(InstanceAttribute(name, line, pos, absPosition))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _onDecorator(self, name, line, pos, absPosition):\n        # A class or a function must be on the top of the stack\n        d = Decorator(name, line, pos, absPosition)\n        if self.__lastDecorators is None:\n            self.__lastDecorators = [d]\n        else:\n            self.__lastDecorators.append(d)", "response": "Memorizes a function or a class decorator"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _onArgument(self, name, annotation):\n        self.objectsStack[-1].arguments.append(Argument(name, annotation))", "response": "Memorizes a function argument"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _onError(self, message):\n        self.isOK = False\n        if message.strip() != \"\":\n            self.errors.append(message)", "response": "Memorizies a parser error message"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _onLexerError(self, message):\n        self.isOK = False\n        if message.strip() != \"\":\n            self.lexerErrors.append(message)", "response": "Memorizes a lexer error message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef index(self, format='html'):\n        # url('datastores')\n        results = meta.Session.query(DataStore)\n        serialized_datastores = [{'id': ds.id, 'text': ds.name, 'href': h.url_for(controller=\"datastores\", action=\"show\", id=ds.id), 'type': ds.type} for ds in results]\n        # prevent JSON Array Cross-site Exploits (XSRF/CSRF)\n        return {'datastores': serialized_datastores}", "response": "GET / datastores : All items in the collection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self):\n        # url('datastores')\n        content = request.environ['wsgi.input'].read(int(request.environ['CONTENT_LENGTH']))\n        content = content.decode('utf8')\n        content = simplejson.loads(content)\n        new = DataStore(content['name'],\n                        content['type'],\n                        content['ogrstring'])\n        results = meta.Session.add(new)\n        meta.Session.commit()\n        response.status = 201", "response": "POST / datastores : Create a new item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, id):\n        # url('DataStores', id=ID)\n        content = request.environ['wsgi.input'].read(int(request.environ['CONTENT_LENGTH']))\n        content = content.decode('utf8')\n        content = simplejson.loads(content)        \n        result = meta.Session.query(DataStore).get(id)\n        result.name = content['name']\n        result.type = content['type']\n        result.ogrstring = content['ogrstring']\n        meta.Session.commit()\n        response.status = 201", "response": "PUT / datastores / id : Update an existing item."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, id):\n        # url('DataStores', id=ID)\n        result = meta.Session.query(DataStore).get(id)\n        meta.Session.delete(result)\n        meta.Session.commit()\n\n        response.status = 204\n        # remove content-type from response headers so that webtest won't get confused\n        # http://groups.google.com/group/pylons-discuss/browse_thread/thread/1267650386ae521b\n        del response.headers['content-type']", "response": "DELETE / datastores / id : Delete an existing item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting / datastores / id : Show a specific item.", "response": "def show(self, id):\n        \"\"\"GET /datastores/id: Show a specific item.\"\"\"\n        # url('DataStores', id=ID)\n        datastore = meta.Session.query(DataStore).get(id)\n\n        # do not raise RuntimeError from discover_datasources\n        # if in \"test\" mode\n        try:\n            datasources = discover_datasources(datastore.ogrstring)\n        except RuntimeError:\n            if \"test\" in request.params:\n                datasources = None\n            else:\n                raise\n\n        result = datastore.to_json()\n        result['datasources'] = datasources\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the auth settings for accessing MyAnimeList through its official API from a given username and password.", "response": "def init_auth(username, password):\n    \"\"\"Initializes the auth settings for accessing MyAnimeList\n    through its official API from a given username and password.\n    :param username Your MyAnimeList account username.\n    :param password Your MyAnimeList account password.\n    :return A tuple containing your credentials.\n    \"\"\"\n    username = username.strip()\n    password = password.strip()\n    credentials = (username, password)\n    if helpers.verif_auth(credentials, header):\n        return credentials\n    else:\n        raise ValueError(constants.INVALID_CREDENTIALS)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_auth_from_file(filename):\n    with open(filename) as auth_file:\n        lines = auth_file.read().splitlines()\n        lines = [line.strip() for line in lines if len(line) != 0]\n        if len(lines) == 2:\n            credentials = (lines[0], lines[1])\n        elif len(lines) == 1:\n            user_pass = lines[0].split()\n            credentials = (user_pass[0], user_pass[1])\n        elif len(lines) == 0 or len(lines) > 2:\n            raise ValueError(constants.INVALID_AUTH_FILE)\n\n        if helpers.verif_auth(credentials, header):\n            return credentials\n        else:\n            raise ValueError(constants.INVALID_CREDENTIALS)", "response": "Initializes the auth settings for accessing MyAnimelist through its\n    official API from a given file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches MyAnimeList for a given keyword and returns a list of all items that match the given keywords.", "response": "def search(query, medium, credentials):\n    \"\"\"Searches MyAnimeList for a [medium] matching the keyword(s) given by query.\n    :param query  The keyword(s) to search with.\n    :param medium Anime or manga (tokens.Medium.ANIME or tokens.Medium.MANGA).\n    :return A list of all items that are of type [medium] and match the\n             given keywords, or, an empty list if none matched.\n    :raise ValueError For bad arguments.\n    \"\"\"\n    helpers.check_creds(credentials, header)\n    if len(query) == 0:\n        raise ValueError(constants.INVALID_EMPTY_QUERY)\n    api_query = helpers.get_query_url(medium, query)\n    if api_query is None:\n        raise ValueError(constants.INVALID_MEDIUM)\n    search_resp = requests.get(api_query, auth=credentials, headers=header)\n    if search_resp is None or search_resp.status_code == 204: # is there a better way to do this...\n        return []\n    query_soup = BeautifulSoup(search_resp.text, 'lxml')\n    if medium == tokens.Medium.ANIME:\n        entries = query_soup.anime\n        if entries is None:\n            return helpers.reschedule(search, constants.DEFAULT_WAIT_SECS, query,\n                                      medium, credentials)\n\n        return [objects.Anime(entry) for entry in entries.findAll('entry')]\n    elif medium == tokens.Medium.MANGA:\n        entries = query_soup.manga\n        if entries is None:\n            return helpers.reschedule(search, constants.DEFAULT_WAIT_SECS, query,\n                                      medium)\n        return [objects.Manga(entry) for entry in entries.findAll('entry')]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching MyAnimeList for an anime with the given id.", "response": "def search_id(id, medium, credentials):\n    \"\"\"Grabs the [medium] with the given id from MyAnimeList as a [medium]\n    object.\n    :param id     The id of the [medium].\n    :param medium Anime or manga (tokens.Medium.ANIME or tokens.Medium.MANGA).\n    :return The [medium] object with id requested, or None if no such [medium]\n            exists.\n    :raise ValueError For bad arguments.\n    \"\"\"\n    helpers.check_creds(credentials, header)\n    if id <= 0 or not float(id).is_integer():\n        raise ValueError(constants.INVALID_ID)\n    scrape_query = helpers.get_scrape_url(id, medium)\n    if scrape_query is None:\n        raise ValueError(constants.INVALID_MEDIUM)\n    search_resp = requests.get(scrape_query, headers=header)\n    scrape_soup = BeautifulSoup(search_resp.text, 'html.parser')\n    #inspect element on an anime page, you'll see where this scrape is\n    #coming from.\n    query = scrape_soup.find('span', {'itemprop':'name'})\n    if query is None:\n        return helpers.reschedule(search_id, constants.DEFAULT_WAIT_SECS, id,\n                                  medium)\n    matches = search(query.text, medium, credentials)\n    index = [match.id for match in matches].index(str(id))\n    if index != -1:\n        return matches[index]\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(data, id, medium, credentials):\n    _op(data, id, medium, tokens.Operations.ADD, credentials)", "response": "Adds the data for the given id and data to the user s [ mediumList ]."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the data for the given id and data on the user s [ mediumList ].", "response": "def update(data, id, medium, credentials):\n    \"\"\"Updates the [medium] with the given id and data on the user's [medium]List.\n    :param data   The data for the [medium] to update.\n    :param id     The id of the data to update.\n    :param medium Anime or manga (tokens.Medium.ANIME or tokens.Medium.MANGA).\n    :raise ValueError For bad arguments.\n    \"\"\"\n    _op(data, id, medium, tokens.Operations.UPDATE, credentials)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(data, id, medium, credentials):\n    _op(data, id, medium, tokens.Operations.DElETE, credentials)", "response": "Delete the data for the given id and data from the user s [ mediumList ]."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_blank(medium):\n    if medium == tokens.Medium.ANIME:\n        return objects.AnimeData()\n    elif medium == tokens.Medium.MANGA:\n        return objects.MangaData()\n    else:\n        return None", "response": "Returns a [ medium ]Data object for filling before calling spice. add or spice. update or spice. delete."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a MediumList object for the given user.", "response": "def get_list(medium, user, credentials):\n    \"\"\"Returns a MediumList (Anime or Manga depends on [medium]) of user.\n    If user is not given, the username is taken from the initialized auth\n    credentials.\n    :param medium Anime or manga (tokens.Medium.Anime or tokens.Medium.Manga)\n    :param user   The user whose list should be grabbed. May use credentials[0].\n    \"\"\"\n    helpers.check_creds(credentials, header)\n    list_url = helpers.get_list_url(medium, user)\n    #for some reason, we don't need auth.\n    list_resp = requests.get(list_url, headers=header)\n    if constants.TOO_MANY_REQUESTS in list_resp.text:\n        return helpers.reschedule(get_list, constants.DEFAULT_WAIT_SECS, medium,\n                                  user)\n\n    list_soup = BeautifulSoup(list_resp.text, 'lxml')\n    return objects.MediumList(medium, list_soup)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef document(self):\n        resp = request.environ.get('pylons.original_response')\n        content = literal(resp.body) or cgi.escape(request.GET.get('message'))\n        page = error_document_template % \\\n            dict(prefix=request.environ.get('SCRIPT_NAME', ''),\n                 code=cgi.escape(request.GET.get('code', str(resp.status_int))),\n                 message=content)\n        return page", "response": "Render the error document"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nserve the file at the specified path", "response": "def _serve_file(self, path):\n        \"\"\"Call Paste's FileApp (a WSGI application) to serve the file\n        at the specified path\n        \"\"\"\n        static = PkgResourcesParser('pylons', 'pylons')\n        request.environ['PATH_INFO'] = '/%s' % path\n        return static(request.environ, self.start_response)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gen_mapname():\n    filepath = None\n    while (filepath is None) or (os.path.exists(os.path.join(config['mapfiles_dir'], filepath))):\n        filepath = '%s.map' % _gen_string()\n    return filepath", "response": "Generate a uniq mapfile pathname."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef config_content(self, command, vars):\n        settable_vars = [\n                var('db_url', 'Database url for sqlite, postgres or mysql', \n                    default='sqlite:///%(here)s/studio.db'),\n                var('ms_url','Url to the mapserv CGI',\n                    default='http://localhost/cgi-bin/mapserv'),\n                var('admin_password','Password for default admin user',\n                    default=secret.secret_string(length=8))\n        ]\n\n        for svar in settable_vars:\n            if command.interactive:\n                prompt = 'Enter %s' % svar.full_description()\n                response = command.challenge(prompt, svar.default, svar.should_echo)\n                vars[svar.name] = response\n            else:\n                if not vars.has_key(svar.name):\n                    vars[svar.name] = svar.default\n\n        vars['cookie_secret'] = secret.secret_string()\n\n        # call default pylons install\n        return super(StudioInstaller, self).config_content(command, vars)", "response": "Called by self. write_config this returns the text content for the config file given the variables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninterpolating definitions from the top - level definitions key into the top - level schema key. This is performed in a cut - down way similar to JSON schema.", "response": "def _resolve_definitions(self, schema, definitions):\n        \"\"\"Interpolates definitions from the top-level definitions key into the\n        schema. This is performed in a cut-down way similar to JSON schema.\n        \"\"\"\n        if not definitions:\n            return schema\n\n        if not isinstance(schema, dict):\n            return schema\n\n        ref = schema.pop('$ref', None)\n        if ref:\n            path = ref.split('/')[2:]\n            definition = definitions\n            for component in path:\n                definition = definitions[component]\n\n            if definition:\n                # Only update specified fields\n                for (key, val) in six.iteritems(definition):\n                    if key not in schema:\n                        schema[key] = val\n\n        for key in six.iterkeys(schema):\n            schema[key] = self._resolve_definitions(schema[key], definitions)\n\n        return schema"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a serializer for a particular type.", "response": "def _get_serializer(self, _type):\n        \"\"\"Gets a serializer for a particular type. For primitives, returns the\n        serializer from the module-level serializers.\n        For arrays and objects, uses the special _get_T_serializer methods to\n        build the encoders and decoders.\n        \"\"\"\n        if _type in _serializers:  # _serializers is module level\n            return _serializers[_type]\n        # array and object are special types\n        elif _type == 'array':\n            return self._get_array_serializer()\n        elif _type == 'object':\n            return self._get_object_serializer()\n\n        raise ValueError('Unknown type: {}'.format(_type))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the encoder and decoder functions for an array. Uses the items key to build the encoders and decoders for the specified type.", "response": "def _get_array_serializer(self):\n        \"\"\"Gets the encoder and decoder for an array. Uses the 'items' key to\n        build the encoders and decoders for the specified type.\n        \"\"\"\n        if not self._items:\n            raise ValueError('Must specify \\'items\\' for \\'array\\' type')\n\n        field = SchemaField(self._items)\n\n        def encode(value, field=field):\n            if not isinstance(value, list):\n                value = [value]\n\n            return [field.encode(i) for i in value]\n\n        def decode(value, field=field):\n            return [field.decode(i) for i in value]\n\n        return (encode, decode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the encoder and decoder for an object.", "response": "def _get_object_serializer(self):\n        \"\"\"Gets the encoder and decoder for an object. Uses the 'properties'\n        key to build the encoders and decoders for the specified types,\n        mapping them to their specified names and parameters. These include:\n            * default  (Default: None)\n            * required (Default: true)\n            * readonly (Default: false)\n            * update   (Default: true)\n            * altname  (Default: None)\n        \"\"\"\n        if not self._properties:\n            raise ValueError('Must specify \\'properties\\' for \\'object\\' type')\n\n        fields = {}\n        for (name, definition) in six.iteritems(self._properties):\n            fields[name] = SchemaField(definition)\n\n        # Allow intraspection of field information via `fields` property\n        self._object_fields = fields\n\n        def get_pyname(name, field):\n            return (field._altname if field._altname else name)\n\n        def encode(value, fields=fields):\n            \"\"\"Encode an object (dictionary) for the Opsview API. Uses the\n            altname for each field schema if specified.\n            \"\"\"\n            if not isinstance(value, dict):\n                # This is gonna be quite clever... if we're given a value which\n                # ISNT a dictionary type, try and encode it anyway by finding\n                # the only field it can go in\n                required_fields = [\n                    (name, field) for (name, field) in six.iteritems(fields)\n                    if field._required\n                ]\n\n                mutable_fields = [\n                    (name, field) for (name, field) in six.iteritems(fields)\n                    if not field._readonly\n                ]\n\n                field = None\n                if len(required_fields) == 1:\n                    field = required_fields[0]\n                elif len(mutable_fields) == 1:\n                    field = mutable_fields[0]\n\n                if field:  # Success!\n                    pyname = get_pyname(field[0], field[1])\n                    value = {pyname: value}\n                else:\n                    raise ValueError('Expected object type but got: \\'{}\\''\n                                     .format(value))\n\n            encoded = {}\n            allowed_fields = []\n            for name, field in six.iteritems(fields):\n                if field._altname:\n                    allowed_fields.append(field._altname)\n                else:\n                    allowed_fields.append(name)\n\n            unknown_keys = [name for name in six.iterkeys(value)\n                            if name not in allowed_fields]\n\n            if unknown_keys and self._is_strict:\n                # Don't allow unknown keys for encoding if strict\n                raise ValueError('Unknown fields: \\'{}\\''\n                                 .format('\\', \\''.join(unknown_keys)))\n            else:\n                # Otherwise pass the values through as they were specified\n                for key in unknown_keys:\n                    encoded[key] = value[key]\n\n            for (key, field) in six.iteritems(fields):\n                # Only encode if the field has a default value or the field has\n                # actually been specified\n                pyname = (field._altname if field._altname else key)\n                if pyname in value or field._default is not None:\n                    encoded[key] = field.encode(value.get(pyname))\n                elif field._required:\n                    raise ValueError('Missing required field: \\'{}\\''\n                                     .format(pyname))\n\n            return encoded\n\n        def decode(value, fields=fields):\n            if not isinstance(value, dict):\n                raise ValueError('Cannot decode type {} as object'\n                                 .format(type(value)))\n            decoded = {}\n\n            unknown_keys = [k for k in six.iterkeys(value) if k not in fields]\n            if unknown_keys and self._is_strict:\n                raise ValueError('Unknown fields: \\'{}\\''.format(\n                    '\\', \\''.join(unknown_keys)\n                ))\n            else:\n                for key in unknown_keys:\n                    decoded[key] = value[key]\n\n            for (key, field) in six.iteritems(fields):\n                pyname = (field._altname if field._altname else key)\n                # Only decode if the field has actually been specified\n                if key in value:\n                    try:\n                        decoded[pyname] = field.decode(value.get(key))\n                    except ValueError as ex:\n                        print key\n                        raise\n\n            return decoded\n\n        return (encode, decode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encode(self, value):\n        if value is None and self._default is not None:\n            value = self._default\n\n        for encoder in self._encoders:\n            try:\n                return encoder(value)\n            except ValueError as ex:\n                pass\n\n        raise ValueError('Value \\'{}\\' is invalid. {}'\n                         .format(value, ex.message))", "response": "Encodes the value into a value in the appropriate encoder for this schema."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hierarchy_pos(links, root, width=1., vert_gap=0.2, vert_loc=0, xcenter=0.5, pos=None, parent=None, min_dx=0.03):\n    '''If there is a cycle that is reachable from root, then this will see infinite recursion.\n       G: the graph\n       root: the root node of current branch\n       width: horizontal space allocated for this branch - avoids overlap with other branches\n       vert_gap: gap between levels of hierarchy\n       vert_loc: vertical location of root\n       xcenter: horizontal location of root\n       pos: a dict saying where all nodes go if they have been assigned\n       parent: parent of this branch.'''\n    if pos is None:\n        pos = {root: (xcenter, vert_loc)}\n    else:\n        pos[root] = (xcenter, vert_loc)\n\n    neighbors = get_sandbox_neighbours(links, root)\n\n    if len(neighbors) != 0:\n        dx = max(width / len(neighbors), min_dx)\n        #nextx = xcenter - width / 2 - dx / 2\n        nextx = pos[root][0] - (len(neighbors) - 1) * dx / 2 - dx\n        \n        for neighbor in neighbors:\n            nextx += dx\n            pos = hierarchy_pos(links, neighbor, width=dx, vert_gap=vert_gap, \n                                vert_loc=vert_loc - vert_gap, xcenter=nextx, pos=pos, \n                                parent=root)\n    return pos", "response": "Returns a dict that represents the position of the root node in the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _compare_recursive(old, new):\n    if isinstance(new, dict):\n        for key in six.iterkeys(new):\n            try:\n                if _compare_recursive(old[key], new[key]):\n                    return True\n            except (KeyError, TypeError):\n                return True\n\n    elif isinstance(new, list) or isinstance(new, tuple):\n        for i, item in enumerate(new):\n            try:\n                if _compare_recursive(old[i], item):\n                    return True\n            except (IndexError, TypeError):\n                return True\n    else:\n        return old != new\n\n    return False", "response": "Deep comparison between objects ; assumes that new contains\n    user defined parameters so only keys which exist in old will be compared. Returns True if they differ otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pre_init(self, object_type):\n        # Internal Ansible function to load the arguments\n        pre_params = _load_params()\n\n        login_params = {}\n        for key in six.iterkeys(self.login_argument_spec):\n            if key not in pre_params or not pre_params[key]:\n                raise ValueError('Argument [%s] is required' % key)\n\n            login_params[key] = pre_params[key]\n\n        # Save a list of all the specified parameters so we know which null\n        # parameters to remove\n        self.specified_params = [k for k in six.iterkeys(pre_params)\n                                 if not k.startswith('_')]\n\n        # Save the manager as, for example `client.config.hostgroups`\n        client = OpsviewClient(**login_params)\n        self.manager = getattr(client.config, object_type)\n\n        # Build the argument spec with the necessary values\n        self.argspec = self._build_argspec()\n        self.argspec.update(self.login_argument_spec)\n        self.argspec.update(self.additional_argument_spec)", "response": "Internal method that loads the connection parameters and creates the manager and the argument spec."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild the ansible argument spec using the fields from the schema that are defined in the API.", "response": "def _build_argspec(self):\n        \"\"\"Builds the ansible argument spec using the fields from the schema\n        definition. It's the caller's responsibility to add any arguments which\n        are not defined in the schema (e.g. login parameters)\n        \"\"\"\n        fields = self.manager._schema.fields\n        argspec = {}\n\n        for (field_name, field) in six.iteritems(fields):\n            # Readonly fields are omitted, obviously\n            if field.get('readonly', False):\n                continue\n\n            argspec_field = {'required': field.get('required', False)}\n\n            # Set the name of the argument as the `altname` if it's specified.\n            # Otherwise, use the same name as the API does.\n            if field['altname']:\n                name = field['altname']\n            else:\n                name = field_name\n\n            argspec[name] = argspec_field\n\n        return argspec"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_object_params(self):\n        return {name: value for (name, value) in six.iteritems(self.params)\n                if (name not in self.additional_argument_spec and\n                    name not in self.login_argument_spec and\n                    (value is not None or name in self.specified_params))}", "response": "Returns all of the parameters that should be used to create or update a resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck whether the old object and new object are the same.", "response": "def _requires_update(self, old_object, new_object):\n        \"\"\"Checks whether the old object and new object differ; only checks\n        keys which exist in the new object\n        \"\"\"\n        old_encoded = self.manager._encode(old_object)\n        new_encoded = self.manager._encode(new_object)\n        return _compare_recursive(old_encoded, new_encoded)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef url2domain(url):\n    parsed_uri = urlparse.urlparse(url)\n    domain = '{uri.netloc}'.format(uri=parsed_uri)\n    domain = re.sub(\"^.+@\", \"\", domain)\n    domain = re.sub(\":.+$\", \"\", domain)\n    return domain", "response": "extract domain from url"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init_model(engine):\n    if meta.Session is None:\n        sm = orm.sessionmaker(autoflush=True, autocommit=False, bind=engine)\n\n        meta.engine = engine\n        meta.Session = orm.scoped_session(sm)", "response": "Call me before using any of the tables or classes in the model"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_prop(name, handler_get, handler_set):\n    global props_get, props_set\n    if handler_get:\n        props_get[name] = handler_get\n    if handler_set:\n        props_set[name] = handler_set", "response": "register a property handler\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef retrieve_prop(name):\n    handler_get, handler_set = None, None\n\n    if name in props_get:\n        handler_get = props_get[name]\n    if name in props_set:\n        handler_set = props_set[name]\n\n    return (name, handler_get, handler_set)", "response": "retrieve a property handler\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a QuerySet of Comment objects for the current resource.", "response": "def get_queryset(self):\n        '''\n        Parameters are already validated in the QuerySetPermission\n        '''\n        model_type = self.request.GET.get(\"type\")\n        pk = self.request.GET.get(\"id\")\n        content_type_model = ContentType.objects.get(model=model_type.lower())\n        Model = content_type_model.model_class()\n        model_obj = Model.objects.filter(id=pk).first()\n        return Comment.objects.filter_by_object(model_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extractall(archive, filename, dstdir):\n    \n    if zipfile.is_zipfile(archive):\n        z = zipfile.ZipFile(archive)\n        for name in z.namelist():\n            targetname = name\n            # directories ends with '/' (on Windows as well)\n            if targetname.endswith('/'):\n                targetname = targetname[:-1]\n\n            # don't include leading \"/\" from file name if present\n            if targetname.startswith(os.path.sep):\n                targetname = os.path.join(dstdir, targetname[1:])\n            else:\n                targetname = os.path.join(dstdir, targetname)                \n            targetname = os.path.normpath(targetname)\n\n            # Create all upper directories if necessary.    \n            upperdirs = os.path.dirname(targetname)\n            if upperdirs and not os.path.exists(upperdirs):\n                os.makedirs(upperdirs)\n\n            # directories ends with '/' (on Windows as well)\n            if not name.endswith('/'):\n                # copy file\n                file(targetname, 'wb').write(z.read(name))\n\n    elif tarfile.is_tarfile(archive):\n        tar = tarfile.open(archive)\n        tar.extractall(path=dstdir)\n    else:\n        # seems to be a single file, save it\n        shutil.copyfile(archive, os.path.join(dstdir, filename))", "response": "extracts a zip or tar file to dstdir"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_app(command, conf, vars):\n    load_environment(conf.global_conf, conf.local_conf)\n\n    # Merge and minify JavaScript code\n    input_file = config['js_tmpl']\n    public_dir = config['pylons.paths']['static_files']\n    output_file = os.path.join(public_dir, 'js', 'Studio', 'studio-all.js')\n    _merge_js(input_file, public_dir, output_file)\n    log.info('JavaScript successfully merged and minified in ' + output_file)\n\n    # Load the models\n    from studio.model import meta\n    meta.metadata.bind = meta.engine\n\n    filename = os.path.split(conf.filename)[-1]\n    if filename == 'test.ini':\n        # Permanently drop any existing tables\n        log.info(\"Dropping existing tables...\")\n        meta.metadata.drop_all(checkfirst=True)\n\n    # Create the tables if they aren't there already\n    meta.metadata.create_all(checkfirst=True)\n\n    # Create permissions\n    # datastores permissions\n    perm_create_update_datastores = model.Permission()\n    perm_create_update_datastores.name = 'create_update_datastores'\n    meta.Session.add(perm_create_update_datastores)\n    perm_view_datastores = model.Permission()\n    perm_view_datastores.name = 'view_datastores'\n    meta.Session.add(perm_view_datastores)\n    # datasources permissions\n    perm_view_datasources = model.Permission()\n    perm_view_datasources.name = 'view_datasources'\n    meta.Session.add(perm_view_datasources)\n    perm_create_datasources = model.Permission()\n    perm_create_datasources.name = 'create_datasources'\n    meta.Session.add(perm_create_datasources)\n    # mapfiles permissions\n    perm_create_update_mapfiles = model.Permission()\n    perm_create_update_mapfiles.name = 'create_update_mapfiles'\n    meta.Session.add(perm_create_update_mapfiles)\n    perm_view_mapfiles = model.Permission()\n    perm_view_mapfiles.name = 'view_mapfiles'\n    meta.Session.add(perm_view_mapfiles)\n    # layertemplates permissions\n    perm_create_update_layertemplates = model.Permission()\n    perm_create_update_layertemplates.name = 'create_update_layertemplates'\n    meta.Session.add(perm_create_update_layertemplates)\n    perm_view_layertemplates = model.Permission()\n    perm_view_layertemplates.name = 'view_layertemplates'\n    meta.Session.add(perm_view_layertemplates)\n\n    # Create group admin\n    admin_gp = model.Group()\n    admin_gp.name = 'admin'\n    admin_gp.permissions.append(perm_create_update_datastores)\n    admin_gp.permissions.append(perm_view_datastores)\n    admin_gp.permissions.append(perm_view_datasources)\n    admin_gp.permissions.append(perm_create_datasources)\n    admin_gp.permissions.append(perm_create_update_mapfiles)\n    admin_gp.permissions.append(perm_view_mapfiles)\n    admin_gp.permissions.append(perm_create_update_layertemplates)\n    admin_gp.permissions.append(perm_view_layertemplates)\n    meta.Session.add(admin_gp)\n\n    # Create group enduser\n    enduser_gp = model.Group()\n    enduser_gp.name = 'enduser'\n    enduser_gp.permissions.append(perm_view_datastores)\n    enduser_gp.permissions.append(perm_view_datasources)\n    enduser_gp.permissions.append(perm_create_update_mapfiles)\n    enduser_gp.permissions.append(perm_view_mapfiles)\n    enduser_gp.permissions.append(perm_create_update_layertemplates)\n    enduser_gp.permissions.append(perm_view_layertemplates)\n    meta.Session.add(enduser_gp)\n\n    # Create user admin\n    admin = model.User()\n    admin.name = 'Admin'\n    admin.login = 'admin'\n    admin.password = config['admin_password']\n    admin.groups.append(admin_gp)\n    meta.Session.add(admin)\n\n    if filename == 'test.ini':\n        # create enduser user for test purpose only\n        enduser = model.User()\n        enduser.name = 'Test User'\n        enduser.login = 'enduser'\n        enduser.password = 'password'\n        enduser.groups.append(enduser_gp)\n        meta.Session.add(enduser)\n\n    mfdir = config['mapfiles_dir']\n    if not os.path.exists(mfdir):\n        os.makedirs(mfdir, 0755)\n\n    if 'default_datastore_postgis' in config:\n        # Create default datastore\n        datastore = model.DataStore('default (postgis)', 'postgis', config['default_datastore_postgis'])\n        meta.Session.add(datastore)\n        meta.Session.flush()\n\n    if 'default_datastore_dir' in config:\n        # Create default datastore\n        datastore = model.DataStore('default (directory)', 'directory', config['default_datastore_dir'])\n        meta.Session.add(datastore)\n        meta.Session.flush()\n\n        # Create dummy mapfile\n        mapfile = create_default_mapfile()\n        dict = mapfile.to_dict()\n        ds = DataStore(datastore.ogrstring)\n        dsources = ds.get_datasources()\n        palette = QualitativePalette(len(dsources)).get_palette()\n        for dss in dsources:\n            if dss.type == 'RASTER':\n                print \"adding %s datasource\"%dss.name\n                l = _make_mapfile_layer(datastore.id,dss)\n                if 'projection' in l:\n                    dict['projection'] = l['projection']\n                dict['layers'].append(l)\n        for dss in dsources:\n            if dss.type == 'POLYGON':\n                print \"adding %s datasource\"%dss.name\n                color = palette.pop(0)\n                l = _make_mapfile_layer(datastore.id,dss)\n                if 'projection' in l:\n                    dict['projection'] = l['projection']\n                l['classes'][0]['styles'][0]['color']=color\n                dict['layers'].append(l)\n        for dss in dsources:\n            if dss.type == 'LINE':\n                print \"adding %s datasource\"%dss.name\n                color = palette.pop(0)\n                l = _make_mapfile_layer(datastore.id,dss)\n                if 'projection' in l:\n                    dict['projection'] = l['projection']\n                l['classes'][0]['styles'][0]['color']=color\n                dict['layers'].append(l)\n        for dss in dsources:\n            if dss.type == 'POINT':\n                print \"adding %s datasource\"%dss.name\n                color = palette.pop(0)\n                l = _make_mapfile_layer(datastore.id,dss)\n                if 'projection' in l:\n                    dict['projection'] = l['projection']\n                l['classes'][0]['styles'][0]['color']=color\n                dict['layers'].append(l)\n        if 'projection' not in dict:\n            dict['projection']=\"init=epsg:4326\"\n        mapfile.from_dict(dict)\n        mapfile.to_file(os.path.join(config['mapfiles_dir'], 'dummy_mapfile.map'))\n\n        # Create dummy_mapfile in db, owned by user 'admin'\n        map = model.Map('dummy_mapfile', 'dummy_mapfile.map', 1)\n        model.meta.Session.add(map)\n\n    # Commit the new objects into the database\n    meta.Session.commit()\n\n    log.info(\"Data successfully set up\")", "response": "Place any commands to setup studio here"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _merge_js(input_file, input_dir, output_file):\n    from studio.lib.buildjs import merge_js\n    merge_js.main(input_file, input_dir, output_file)", "response": "Merge the js files\n    and minify the code."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lcopt_bw2_setup(ecospold_path, overwrite=False, db_name=None):  # pragma: no cover\n\n    \"\"\"\n    Utility function to set up brightway2 to work correctly with lcopt.\n\n    It requires the path to the ecospold files containing the Ecoinvent 3.3 cutoff database.\n\n    If you don't have these files, log into `ecoinvent.org  <http://www.ecoinvent.org/login-databases.html>`_ and go to the Files tab\n\n    Download the file called ``ecoinvent 3.3_cutoff_ecoSpold02.7z``\n\n    Extract the file somewhere sensible on your machine, you might need to download `7-zip <http://www.7-zip.org/download.html>`_ to extract the files.\n\n    Make a note of the path of the folder that contains the .ecospold files, its probably ``<path/extracted/to>/datasets/``\n\n    Use this path (as a string) as the first parameter in this function\n\n    To overwrite an existing version, set overwrite=True\n    \"\"\"\n    default_ei_name = \"Ecoinvent3_3_cutoff\"\n\n    if db_name is None:\n        \n        db_name = DEFAULT_PROJECT_STEM + default_ei_name\n\n    if db_name in bw2.projects:\n        if overwrite:                                           \n            bw2.projects.delete_project(name=db_name, delete_dir=True)\n        else:\n            print('Looks like bw2 is already set up - if you want to overwrite the existing version run lcopt.utils.lcopt_bw2_setup in a python shell using overwrite = True')\n            return False\n\n    bw2.projects.set_current(db_name)\n    bw2.bw2setup()\n    ei = bw2.SingleOutputEcospold2Importer(fix_mac_path_escapes(ecospold_path), default_ei_name)\n    ei.apply_strategies()\n    ei.statistics()\n    ei.write_database()\n\n    return True", "response": "This function sets up brightway2 to work correctly with lcopt."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lcopt_bw2_autosetup(ei_username=None, ei_password=None, write_config=None, ecoinvent_version='3.3', ecoinvent_system_model = \"cutoff\", overwrite=False):  \n\n    \"\"\"\n    Utility function to automatically set up brightway2 to work correctly with lcopt.\n\n    It requires a valid username and password to login to the ecoinvent website.\n\n    These can be entered directly into the function using the keyword arguments `ei_username` and `ei_password` or entered interactively by using no arguments.\n    \n    `ecoinvent_version` needs to be a string representation of a valid ecoinvent database, at time of writing these are \"3.01\", \"3.1\", \"3.2\", \"3.3\", \"3.4\"\n\n    `ecoinvent_system_model` needs to be one of \"cutoff\", \"apos\", \"consequential\"\n\n    To overwrite an existing version, set overwrite=True\n    \"\"\"\n\n    ei_name = \"Ecoinvent{}_{}_{}\".format(*ecoinvent_version.split('.'), ecoinvent_system_model)\n\n    config = check_for_config()\n    # If, for some reason, there's no config file, write the defaults\n    if config is None:\n        config = DEFAULT_CONFIG\n        with open(storage.config_file, \"w\") as cfg:\n            yaml.dump(config, cfg, default_flow_style=False)\n\n    store_option = storage.project_type\n\n    # Check if there's already a project set up that matches the current configuration\n    \n    if store_option == 'single':\n\n        project_name = storage.single_project_name\n\n        if bw2_project_exists(project_name):\n            bw2.projects.set_current(project_name)\n            if ei_name in bw2.databases and overwrite == False:\n                #print ('{} is already set up'.format(ei_name))\n                return True\n\n    else: # default to 'unique'\n        project_name = DEFAULT_PROJECT_STEM + ei_name\n\n        if bw2_project_exists(project_name):\n            if overwrite:                                           \n                bw2.projects.delete_project(name=project_name, delete_dir=True)\n\n    auto_ecoinvent = partial(eidl.get_ecoinvent,db_name=ei_name, auto_write=True, version=ecoinvent_version, system_model=ecoinvent_system_model)\n\n    # check for a config file (lcopt_config.yml)\n\n    if config is not None:\n        if \"ecoinvent\" in config:\n            if ei_username is None:\n                ei_username = config['ecoinvent'].get('username')\n            if ei_password is None:\n                ei_password = config['ecoinvent'].get('password')\n            write_config = False\n\n    if ei_username is None:\n        ei_username = input('ecoinvent username: ')\n    if ei_password is None:\n        ei_password = getpass.getpass('ecoinvent password: ')\n    if write_config is None:\n        write_config = input('store username and password on this computer? y/[n]') in ['y', 'Y', 'yes', 'YES', 'Yes']\n\n    if write_config:\n\n        config['ecoinvent'] = {\n            'username': ei_username,\n            'password': ei_password\n        }\n        with open(storage.config_file, \"w\") as cfg:\n            yaml.dump(config, cfg, default_flow_style=False)\n\n    # no need to keep running bw2setup - we can just copy a blank project which has been set up before\n\n    if store_option == 'single':\n        if bw2_project_exists(project_name):\n            bw2.projects.set_current(project_name)\n        else:\n            \n            if not bw2_project_exists(DEFAULT_BIOSPHERE_PROJECT):\n                bw2.projects.set_current(project_name)\n                bw2.bw2setup()\n            else:\n                bw2.projects.set_current(DEFAULT_BIOSPHERE_PROJECT)\n                bw2.create_core_migrations()\n                bw2.projects.copy_project(project_name, switch=True)\n\n    else:    #if store_option == 'unique':\n\n        if not bw2_project_exists(DEFAULT_BIOSPHERE_PROJECT):\n            lcopt_biosphere_setup()\n        \n        bw2.projects.set_current(DEFAULT_BIOSPHERE_PROJECT)\n        bw2.create_core_migrations()\n        bw2.projects.copy_project(project_name, switch=True)\n            \n    if ei_username is not None and ei_password is not None:\n        auto_ecoinvent(username=ei_username, password=ei_password)\n    else:\n        auto_ecoinvent()\n\n    write_search_index(project_name, ei_name, overwrite=overwrite)\n\n    return True", "response": "Auto - set up brightway2 for a given ecoinvent database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef forwast_autodownload(FORWAST_URL):      \n\n    \"\"\"\n    Autodownloader for forwast database package for brightway. Used by `lcopt_bw2_forwast_setup` to get the database data. Not designed to be used on its own\n    \"\"\"\n    dirpath = tempfile.mkdtemp()\n    r = requests.get(FORWAST_URL)\n    z = zipfile.ZipFile(io.BytesIO(r.content))\n    z.extractall(dirpath)\n    return os.path.join(dirpath, 'forwast.bw2package')", "response": "Autodownloader for forwast database package for brightway."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lcopt_bw2_forwast_setup(use_autodownload=True, forwast_path=None, db_name=FORWAST_PROJECT_NAME, overwrite=False):        \n\n    \"\"\"\n    Utility function to set up brightway2 to work correctly with lcopt using the FORWAST database instead of ecoinvent\n\n    By default it'll try and download the forwast database as a .bw2package file from lca-net\n\n    If you've downloaded the forwast .bw2package file already you can set use_autodownload=False and forwast_path to point to the downloaded file\n\n    To overwrite an existing version, set overwrite=True\n    \"\"\"\n\n    if use_autodownload:\n        \n        forwast_filepath = forwast_autodownload(FORWAST_URL)\n\n    elif forwast_path is not None:\n\n        forwast_filepath = forwast_path\n\n    else:\n        raise ValueError('Need a path if not using autodownload')\n\n    if storage.project_type  == 'single':\n        db_name = storage.single_project_name\n        if bw2_project_exists(db_name):\n            bw2.projects.set_current(db_name)\n        else:\n            bw2.projects.set_current(db_name)\n            bw2.bw2setup()\n\n    else:\n    \n        if db_name in bw2.projects:\n            if overwrite:                                           \n                bw2.projects.delete_project(name=db_name, delete_dir=True)\n            else:\n                print('Looks like bw2 is already set up for the FORWAST database - if you want to overwrite the existing version run lcopt.utils.lcopt_bw2_forwast_setup in a python shell using overwrite = True')\n                return False\n\n        # no need to keep running bw2setup - we can just copy a blank project which has been set up before\n        if not bw2_project_exists(DEFAULT_BIOSPHERE_PROJECT):\n            lcopt_biosphere_setup()\n        \n        bw2.projects.set_current(DEFAULT_BIOSPHERE_PROJECT)\n        bw2.create_core_migrations()\n        bw2.projects.copy_project(db_name, switch=True)\n\n    bw2.BW2Package.import_file(forwast_filepath)\n\n    return True", "response": "Utility function to set up brightway2 forwast database"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the Samples and Factor identifiers across the file.", "response": "def _validate_samples_factors(mwtabfile, validate_samples=True, validate_factors=True):\n    \"\"\"Validate ``Samples`` and ``Factors`` identifiers across the file.\n\n    :param mwtabfile: Instance of :class:`~mwtab.mwtab.MWTabFile`.\n    :type mwtabfile: :class:`~mwtab.mwtab.MWTabFile`\n    :return: None\n    :rtype: :py:obj:`None`\n    \"\"\"\n    from_subject_samples = {i[\"local_sample_id\"] for i in mwtabfile[\"SUBJECT_SAMPLE_FACTORS\"][\"SUBJECT_SAMPLE_FACTORS\"]}\n    from_subject_factors = {i[\"factors\"] for i in mwtabfile[\"SUBJECT_SAMPLE_FACTORS\"][\"SUBJECT_SAMPLE_FACTORS\"]}\n\n    if validate_samples:\n\n        if \"MS_METABOLITE_DATA\" in mwtabfile:\n            from_metabolite_data_samples = set(mwtabfile[\"MS_METABOLITE_DATA\"][\"MS_METABOLITE_DATA_START\"][\"Samples\"])\n            assert from_subject_samples == from_metabolite_data_samples\n\n        if \"NMR_BINNED_DATA\" in mwtabfile:\n            from_nmr_binned_data_samples = set(mwtabfile[\"NMR_BINNED_DATA\"][\"NMR_BINNED_DATA_START\"][\"Fields\"][1:])\n            assert from_subject_samples == from_nmr_binned_data_samples\n\n    if validate_factors:\n\n        if \"MS_METABOLITE_DATA\" in mwtabfile:\n            from_metabolite_data_factors = set(mwtabfile[\"MS_METABOLITE_DATA\"][\"MS_METABOLITE_DATA_START\"][\"Factors\"])\n            assert from_subject_factors == from_metabolite_data_factors"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate entire MWTab formatted file.", "response": "def validate_file(mwtabfile, section_schema_mapping=section_schema_mapping, validate_samples=True, validate_factors=True):\n    \"\"\"Validate entire ``mwTab`` formatted file one section at a time.\n    \n    :param mwtabfile: Instance of :class:`~mwtab.mwtab.MWTabFile`.\n    :type mwtabfile: :class:`~mwtab.mwtab.MWTabFile`\n    :param dict section_schema_mapping: Dictionary that provides mapping between section name and schema definition.\n    :param validate_samples: Make sure that sample ids are consistent across file.\n    :type validate_samples: :py:obj:`True` or :py:obj:`False`  \n    :param validate_factors: Make sure that factors are consistent across file.\n    :type validate_factors: :py:obj:`True` or :py:obj:`False`\n    :return: Validated file.\n    :rtype: :py:class:`collections.OrderedDict`\n    \"\"\"\n    validated_mwtabfile = OrderedDict()\n\n    try:\n        _validate_samples_factors(mwtabfile, validate_samples, validate_factors)\n    except Exception:\n        raise\n\n    for section_key, section in mwtabfile.items():\n        try:\n            schema = section_schema_mapping[section_key]\n            section = validate_section(section=section, schema=schema)\n            validated_mwtabfile[section_key] = section\n        except Exception:\n            raise\n\n    return validated_mwtabfile"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef daemonize(self):\n        if self.userid:\n            uid = pwd.getpwnam(self.userid).pw_uid\n            os.seteuid(uid)\n        try:\n            pid = os.fork()\n            if pid > 0:\n                sys.exit(0)\n        except OSError as err:\n            sys.stderr.write(\"First fork failed: {0} ({1})\\n\".format(err.errno, err.strerror))\n            sys.exit(1)\n        # decouple from parent environment\n        os.chdir(\"/\")\n        os.setsid()\n        os.umask(0)\n\n        # Second fork\n\n        try:\n            pid = os.fork()\n            if pid > 0:\n                sys.exit(0)\n        except OSError as err:\n            sys.stderr.write(\"Second fork failed: {0} ({1})\\n\".format(err.errno, err.strerror))\n            sys.exit(1)\n\n        sys.stdout.flush()\n        sys.stderr.flush()\n        si = open(self.stdin, 'r')\n        so = open(self.stdout, 'w')\n        se = open(self.stderr, 'w')\n        os.dup2(si.fileno(), sys.stdin.fileno())\n        os.dup2(so.fileno(), sys.stdout.fileno())\n        os.dup2(se.fileno(), sys.stderr.fileno())\n\n        # write PID file\n        atexit.register(self.delpid)\n        pid = str(os.getpid())\n        open(self.pidfile, 'w').write(\"%s\\n\" % pid)", "response": "Double - fork magic"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets / datastores/{datastore_id}/datasources : Get all datasources within a given datastore.", "response": "def index(self, datastore_id=None):\n        \"\"\" GET /datastores/{datastore_id}/datasources: Get all\n            datasources within a given datastore.\"\"\"\n        datastore = self._get_datastore_by_id(datastore_id)\n        if datastore is None:\n            abort(404)\n        discovery_result = discover_datasources(datastore.ogrstring)\n        for datasource in discovery_result:\n            datasource['href'] = h.url_for(controller=\"datasources\", action=\"show\", datastore_id=datastore_id, datasource_id=datasource['id'])\n        # prevent JSON Array Cross-site Exploits (XSRF/CSRF)\n        return {'datasources': discovery_result}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, datastore_id=None):\n\n        datastore = self._get_ogrdatastore_by_id(datastore_id)\n        if not datastore:\n            abort(404)\n\n        # only \"directory\" datastores are supported at this point\n        if datastore.connection_type != 'directory':\n            abort(400)\n\n        # use mkstemp to store the file to avoid issues with\n        # NamedTemporaryFile that can't be open a second time\n        # on Windows. See:\n        # http://docs.python.org/library/tempfile.html#tempfile.NamedTemporaryFile\n        # \"Whether the name can be used to open the file a second time, while the\n        # named temporary file is still open, varies across platforms (it can be so\n        # used on Unix; it cannot on Windows NT or later).\n        fd, fn = mkstemp()\n        tmpfile = os.fdopen(fd, 'wb')\n        fieldstorage = request.POST['datasources']\n        shutil.copyfileobj(fieldstorage.file, tmpfile)\n        fieldstorage.file.close()\n        tmpfile.close()\n\n        extractall(fn,\n                   request.POST['datasources'].filename,\n                   datastore.datastore_str)\n\n        # we are reponsible for removing the temporary file\n        os.remove(fn)\n\n        response.status = 201", "response": "POST a new entry in the datastores folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets /datastores/{datastore_id}/datasources/{datasource_id}/columns: Get a specific datasource's columns within a given datastore.", "response": "def showcolumns(self, datastore_id=None, datasource_id=None):\n        \"\"\" GET /datastores/{datastore_id}/datasources/{datasource_id}/columns: Get a\n            specific datasource's columns within a given datastore. \"\"\"\n        datastore = self._get_datastore_by_id(datastore_id)\n        if datastore is None:\n            abort(404)\n        discovery_result = discover_datasource_columns(datastore.ogrstring, datasource_id)\n        if discovery_result is None:\n            abort(404)\n        # prevent JSON Array Cross-site Exploits (XSRF/CSRF)\n        return {\"columns\": discovery_result}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a specific MapFile LAYER .", "response": "def showmapfile(self,datastore_id=None, datasource_id=None):\n        \"\"\" GET /datastores/{datastore_id}/datasources/{datasource_id}/mapfile: Get\n            the JSON representation of a specific datasource's default MapFile LAYER\n            block. \"\"\"\n        datastore = self._get_datastore_by_id(datastore_id)\n        if datastore is None:\n            abort(404)\n        classification = None\n        if 'classification' in request.params and 'attribute' in request.params:\n            classification = {}\n            classification['type'] = request.params['classification']\n            classification['attribute'] = request.params['attribute']\n            if classification['type'] == \"quantile\":\n                classification['intervals'] = request.params['intervals']\n            \n            palette = {}\n            palette['type']='ramp'\n            if 'colortype' in request.params:\n                palette['type'] = request.params['colortype']\n            if 'startcolor' in request.params:\n                c = request.params['startcolor']\n                if c.startswith('#'):\n                    c = c[1:]\n                palette['startcolor'] = [int(c[0:2],16),int(c[2:4],16),int(c[4:6],16)]\n            if 'endcolor' in request.params:\n                c = request.params['endcolor']\n                if c.startswith('#'):\n                    c = c[1:]\n                palette['endcolor'] = [int(c[0:2],16),int(c[2:4],16),int(c[4:6],16)]\n            if 'interpolation' in request.params:\n                palette['interpolation'] = request.params['interpolation']\n            if 'theme' in request.params:\n                palette['theme'] = int(request.params['theme'])\n            classification['palette'] = palette\n\n        mapfile = get_mapfile(datastore.ogrstring, datasource_id, classification)\n        if 'metadata' not in mapfile:\n            mapfile['metadata']={}\n        mapfile['metadata']['datastoreid']=datastore_id\n        mapfile['metadata']['datasourceid']=datasource_id\n        if mapfile is None:\n            abort(404)\n        return mapfile"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the interpretation of the previously POSTed Tropo action.", "response": "def getInterpretation(self):\n        \"\"\"\n        Get the value of the previously POSTed Tropo action.\n        \"\"\"\n        actions = self._actions\n\n        if (type (actions) is list):\n            dict = actions[0]\n        else:\n            dict = actions\n        return dict['interpretation']"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ask(self, choices, **options):\n# # **Sun May 15 21:21:29 2011** -- egilchri\n\n        # Settng the voice in this method call has priority.\n\t# Otherwise, we can pick up the voice from the Tropo object,\n\t# if it is set there.\n        if hasattr (self, 'voice'):\n            if (not 'voice' in options):\n                options['voice'] = self.voice\n        \n# # **Sun May 15 21:21:29 2011** -- egilchri\n\n        self._steps.append(Ask(choices, **options).obj)", "response": "Sends a prompt to the user and optionally waits for a response."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef call (self, to, **options):\n        self._steps.append(Call (to, **options).obj)", "response": "Adds a call to the list of steps that can be performed on a specific Tropo site."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a conference to the list of conferences that can be used to talk to a specific line.", "response": "def conference(self, id, **options):\n        \"\"\"\n        This object allows multiple lines in separate sessions to be conferenced together so that the parties on each line can talk to each other simultaneously.\n        This is a voice channel only feature.\n        Argument: \"id\" is a String\n        Argument: **options is a set of optional keyword arguments.\n        See https://www.tropo.com/docs/webapi/conference\n        \"\"\"\n        self._steps.append(Conference(id, **options).obj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef message (self, say_obj, to, **options):\n        if isinstance(say_obj, basestring):\n            say = Say(say_obj).obj\n        else:\n            say = say_obj\n        self._steps.append(Message(say, to, **options).obj)", "response": "Shortcut method to create a session say something and hang up all in one step."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an event callback so that your application may be notified when a particular event occurs.", "response": "def on(self, event, **options):\n        \"\"\"\n        Adds an event callback so that your application may be notified when a particular event occurs.\n        Possible events are: \"continue\", \"error\", \"incomplete\" and \"hangup\".\n        Argument: event is an event\n        Argument: **options is a set of optional keyword arguments.\n        See https://www.tropo.com/docs/webapi/on\n        \"\"\"\n        if hasattr (self, 'voice'):\n          if (not 'voice' in options):\n            options['voice'] = self.voice\n\n\n        self._steps.append(On(event, **options).obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting recording the current session.", "response": "def startRecording(self, url, **options):\n        \"\"\"\n        Allows Tropo applications to begin recording the current session.\n        Argument: url is a string\n        Argument: **options is a set of optional keyword arguments.\n        See https://www.tropo.com/docs/webapi/startrecording\n        \"\"\"\n        self._steps.append(StartRecording(url, **options).obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transfer(self, to, **options):\n        self._steps.append(Transfer(to, **options).obj)", "response": "Transfers an already answered call to another destination phone number."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait(self, milliseconds, **options):\n      self._steps.append(Wait(milliseconds, **options).obj)", "response": "Wait for a given amount of time in milliseconds."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrender a Tropo object into a Json string.", "response": "def RenderJson(self, pretty=False):\n        \"\"\"\n        Render a Tropo object into a Json string.\n        \"\"\"\n        steps = self._steps\n        topdict = {}\n        topdict['tropo'] = steps\n        if pretty:\n            try:\n                json = jsonlib.dumps(topdict, indent=4, sort_keys=False)\n            except TypeError:\n                json = jsonlib.dumps(topdict)\n        else:\n            json = jsonlib.dumps(topdict)\n        return json"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbeautify XML string or path - to - file with text to beautified.", "response": "def xml(src, dest=False, shift=4):\n    \"\"\"Beautify XML\n\n    Args:\n        src: xml string or path-to-file with text to beautify (mandatory)\n        dest: path-to-file to save beautified xml string; if file doesn't exist\n              it is created automatically; (optional)\n              if this arg is skept function returns string\n        shift: can be either integer or string\n                1) if int - number of spaces in tab, for example shift=8\n                <a>\n                        <b></b>\n                </a>\n               2) if string - pattern, for example shift='....'\n                <a>\n                ....<b></b>\n                </a>\n\n    Returns: 1) beautified XML string if dest is not provided\n             2) length of saved file if dest is provided\n\n    Example:\n            xml('path/to/file.xml')\n            xml('path/to/file.xml', 'path/to/save/result.xml')\n            xml('path/to/file.xml', 8)\n            xml('path/to/file.xml', '____')\n            xml('path/to/file.xml', 'path/to/save/result.xml', 2)\n    \"\"\"\n    if not dest:\n        return _xml(_text(src)) # returns string\n    else:\n        if type(dest) is int:  # dest is skept, custom pattern provided at dist place\n            return _xml(_text(src), dest)\n        else:\n            with open(dest, 'w') as f2:\n                return f2.write(_xml(_text(src), shift))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef json(src, dest=False, shift=4):\n    if not dest:\n        return _json(_text(src)) # returns string\n    else:\n        if type(dest) is int:  # dest is skept, custom pattern provided at dist place\n            return _json(_text(src), dest)\n        else:\n            with open(dest, 'w') as f2:\n                return f2.write(_json(_text(src), shift))", "response": "Beautify JSON string src or path - to - file with text to beautified dest"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbeautify CSS string or path - to - file with text to beautified", "response": "def css(src, dest=False, shift=4):\n    \"\"\"Beautify CSS\n\n    Args:\n        src: css string or path-to-file with text to beautify (mandatory)\n        dest: path-to-file to save beautified css string; if file doesn't exist\n              it is created automatically; (optional)\n              if this arg is skept function returns string\n        shift: can be either integer or string\n                1) if int - number of spaces in tab, for example shift=8\n                <a>\n                        <b></b>\n                </a>\n               2) if string - pattern, for example shift='....'\n                <a>\n                ....<b></b>\n                </a>\n\n    Returns: 1) beautified XML string if dest is not provided\n             2) length of saved file if dest is provided\n\n    Example:\n            css('path/to/file.css')\n            css('path/to/file.css', 'path/to/save/result.css')\n            css('path/to/file.css', 8)\n            css('path/to/file.css', '____')\n            css('path/to/file.css', 'path/to/save/result.css', 2)\n    \"\"\"\n    if not dest: # all default\n        return _css(_text(src))\n    else:\n        if type(dest) is int:  #dest is skept, custom pattern provided at dist place\n            return _css(_text(src), dest)\n        else:\n            with open(dest, 'w') as f2:\n                return f2.write(_css(_text(src), shift))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _css_min(src, dest='', preserve_comments=True):\n\n    if dest == '': # all default\n        return _css_min_exec(_text(src))\n    else:\n        if type(dest) is bool:  #dest is skept, custom pattern provided at dist place\n            return _css_min_exec(_text(src), dest)\n        else:\n            with open(dest, 'w') as f2:\n                return f2.write(_css_min_exec(_text(src), preserve_comments))", "response": "Minify CSS string src to dest."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the value of the previously POSTed Tropo action.", "response": "def getValue(self):\n        \"\"\"\n        Get the value of the previously POSTed Tropo action.\n        \"\"\"\n        actions = self._actions\n\n        if (type (actions) is list):\n            dict = actions[0]\n        else:\n            dict = actions\n        return dict.get('value', 'NoValue')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getIndexedValue(self, index):\n        actions = self._actions\n\n        if (type (actions) is list):\n            dict = actions[index]\n        else:\n            dict = actions\n        return dict.get('value', 'NoValue')", "response": "Get the value of the indexed Tropo action."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the value of the named Tropo action.", "response": "def getNamedActionValue(self, name):\n        \"\"\"\n        Get the value of the named Tropo action.\n        \"\"\"\n        actions = self._actions\n\n        if (type (actions) is list):\n            for a in actions:\n                if a.get('name', 'NoValue') == name:\n                    dict =a\n        else:\n            dict = actions\n        return dict.get('value', 'NoValue')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an answer to the list of steps that will be executed when the Tropo API is started.", "response": "def answer (self, headers, **options):\n        \"\"\"\n        Places a call or sends an an IM, Twitter, or SMS message. To start a call, use the Session API headers tell Tropo headers launch your code.\n        Arguments: headers is a String.\n        Argument: **options is a set of optional keyword arguments.\n        See https://www.tropo.com/docs/webapi/answer\n        \"\"\"\n        self._steps.append(Answer (headers, **options).obj)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nforwarding an incoming call to another destination phone number before answering it.", "response": "def redirect(self, id, name, **options):\n        \"\"\"\n        Forwards an incoming call to another destination / phone number before answering it.\n        Argument: id is a String\n        Argument: name is a String\n        Argument: **options is a set of optional keyword arguments.\n        See https://www.tropo.com/docs/webapi/redirect\n        \"\"\"\n        self._steps.append(Redirect(id, name, **options).obj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generalLogSecurity(self, state, **options):\n      self._steps.append(GeneralLogSecurity(state).obj)", "response": "This method is called by the general log security step."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop_subprocess(pid):\n    if hasattr(os, \"kill\"):\n        import signal\n        os.kill(pid, signal.SIGTERM)\n    else:\n        import win32api\n        pid = win32api.OpenProcess(1, 0, pid)\n        win32api.TerminateProcess(pid, 0)\n    os.waitpid(pid, 0)", "response": "Stop a subprocess whose process id is pid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expr(self):\n        node = self.term()\n\n        while True:\n            token = self.current_token\n            if token.type == AND:\n                self.eat(AND)\n            elif token.type == OR:\n                self.eat(OR)\n            else:\n                break\n            node = Op(op=token, children=[node, self.term()])\n        return node", "response": "A term - level expression that returns a term - level expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef file2abspath(filename, this_file=__file__):\n    return os.path.abspath(\n        os.path.join(os.path.dirname(os.path.abspath(this_file)), filename))", "response": "generate absolute path for the given file and base dir"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef file2iter(filename, encoding='utf-8', comment_prefix=\"#\",\n              skip_empty_line=True):\n    \"\"\"\n        json stream parsing or line parsing\n    \"\"\"\n    ret = list()\n    visited = set()\n    with codecs.open(filename, encoding=encoding) as f:\n        for line in f:\n            line = line.strip()\n            # skip empty line\n            if skip_empty_line and len(line) == 0:\n                continue\n\n            # skip comment line\n            if comment_prefix and line.startswith(comment_prefix):\n                continue\n\n            yield line", "response": "yields all the lines in a file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef json2file(data, filename, encoding='utf-8'):\n    with codecs.open(filename, \"w\", encoding=encoding) as f:\n        json.dump(data, f, ensure_ascii=False, indent=4, sort_keys=True)", "response": "write json in canonical json format"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting lines to json stream", "response": "def lines2file(lines, filename, encoding='utf-8'):\n    \"\"\"\n        write json stream, write lines too\n    \"\"\"\n    with codecs.open(filename, \"w\", encoding=encoding) as f:\n        for line in lines:\n            f.write(line)\n            f.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite a list of items to a file", "response": "def items2file(items, filename, encoding='utf-8', modifier='w'):\n    \"\"\"\n        json array to file, canonical json format\n    \"\"\"\n    with codecs.open(filename, modifier, encoding=encoding) as f:\n        for item in items:\n            f.write(u\"{}\\n\".format(json.dumps(\n                item, ensure_ascii=False, sort_keys=True)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget value of property_path from a json object", "response": "def json_get(json_object, property_path, default=None):\n    \"\"\"\n        get value of property_path from a json object, e.g. person.father.name\n        * invalid path return None\n        * valid path (the -1 on path is an object), use default\n    \"\"\"\n    temp = json_object\n    for field in property_path[:-1]:\n        if not isinstance(temp, dict):\n            return None\n        temp = temp.get(field, {})\n    if not isinstance(temp, dict):\n        return None\n    return temp.get(property_path[-1], default)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a copy of the given json_object with the given list of properties.", "response": "def json_dict_copy(json_object, property_list, defaultValue=None):\n    \"\"\"\n        property_list = [\n            { \"name\":\"name\", \"alternateName\": [\"name\",\"title\"]},\n            { \"name\":\"birthDate\", \"alternateName\": [\"dob\",\"dateOfBirth\"] },\n            { \"name\":\"description\" }\n        ]\n    \"\"\"\n    ret = {}\n    for prop in property_list:\n        p_name = prop[\"name\"]\n        for alias in prop.get(\"alternateName\", []):\n            if json_object.get(alias) is not None:\n                ret[p_name] = json_object.get(alias)\n                break\n        if not p_name in ret:\n            if p_name in json_object:\n                ret[p_name] = json_object[p_name]\n            elif defaultValue is not None:\n                ret[p_name] = defaultValue\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef any2utf8(data):\n    if isinstance(data, dict):\n        ret = {}\n        for k, v in data.items():\n            k = any2utf8(k)\n            ret[k] = any2utf8(v)\n        return ret\n    elif isinstance(data, list):\n        return [any2utf8(x) for x in data]\n    elif isinstance(data, unicode):\n        return data.encode(\"utf-8\")\n    elif type(data) in [str, basestring]:\n        return data\n    elif type(data) in [int, float]:\n        return data\n    else:\n        logging.error(\"unexpected {} {}\".format(type(data), data))\n        return data", "response": "rewrite json object values ( unicode ) into utf - 8 encoded string\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprovides statistics for jsonld", "response": "def stat_jsonld(data, key=None, counter=None):\n    \"\"\"\n        provide statistics for jsonld, right now only count triples\n        see also https://json-ld.org/playground/\n        note:  attributes  @id @context do not contribute any triple\n    \"\"\"\n    if counter is None:\n        counter = collections.Counter()\n\n    if isinstance(data, dict):\n        ret = {}\n        for k, v in data.items():\n            stat_jsonld(v, k, counter)\n            counter[u\"p_{}\".format(k)] += 0\n        if key:\n            counter[\"triple\"] += 1\n            counter[u\"p_{}\".format(key)] +=1\n    elif isinstance(data, list):\n        [stat_jsonld(x, key, counter) for x in data]\n        if key in [\"tag\"]:\n            for x in data:\n                if isinstance(x, dict) and x.get(\"name\"):\n                    counter[u\"{}_{}\".format(key, x[\"name\"])] +=1\n                elif type(x) in [basestring, unicode]:\n                    counter[u\"{}_{}\".format(key, x)] +=1\n\n    else:\n        if key and key not in [\"@id\",\"@context\"]:\n            counter[\"triple\"] += 1\n            counter[u\"p_{}\".format(key)] +=1\n\n    return counter"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npicks a version from a routing group using a random value", "response": "def resolve_group_to_version(self, name, value=None):\n        \"\"\" Pick a version from a routing group using a random or provided value\n            A routing group looks like (weight, version):\n            {\"APP\": [[29431330, 'A'], [82426238, 'B'], [101760716, 'C'], [118725487, 'D'], [122951927, 'E']]}\n        \"\"\"\n        if name not in self.current_rg:\n            return name\n\n        routing_group = self.current_rg[name]\n        if len(routing_group) == 0:\n            self.logger.warning(\"empty rounting group %s\", name)\n            return name\n\n        value = value or random.randint(0, 1 << 32)\n        index = upper_bound(routing_group, value)\n        return routing_group[index if index < len(routing_group) else 0][1]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert(schema):\n    # pylint: disable=too-many-return-statements,too-many-branches\n    if isinstance(schema, vol.Schema):\n        schema = schema.schema\n\n    if isinstance(schema, Mapping):\n        val = []\n\n        for key, value in schema.items():\n            description = None\n            if isinstance(key, vol.Marker):\n                pkey = key.schema\n                description = key.description\n            else:\n                pkey = key\n\n            pval = convert(value)\n            pval['name'] = pkey\n            if description is not None:\n                pval['description'] = description\n\n            if isinstance(key, (vol.Required, vol.Optional)):\n                pval[key.__class__.__name__.lower()] = True\n\n                if key.default is not vol.UNDEFINED:\n                    pval['default'] = key.default()\n\n            val.append(pval)\n\n        return val\n\n    if isinstance(schema, vol.All):\n        val = {}\n        for validator in schema.validators:\n            val.update(convert(validator))\n        return val\n\n    if isinstance(schema, (vol.Clamp, vol.Range)):\n        val = {}\n        if schema.min is not None:\n            val['valueMin'] = schema.min\n        if schema.max is not None:\n            val['valueMax'] = schema.max\n        return val\n\n    if isinstance(schema, vol.Length):\n        val = {}\n        if schema.min is not None:\n            val['lengthMin'] = schema.min\n        if schema.max is not None:\n            val['lengthMax'] = schema.max\n        return val\n\n    if isinstance(schema, vol.Datetime):\n        return {\n            'type': 'datetime',\n            'format': schema.format,\n        }\n\n    if isinstance(schema, vol.In):\n        if isinstance(schema.container, Mapping):\n            return {\n                'type': 'select',\n                'options': list(schema.container.items()),\n            }\n        return {\n            'type': 'select',\n            'options': [(item, item) for item in schema.container]\n        }\n\n    if schema in (vol.Lower, vol.Upper, vol.Capitalize, vol.Title, vol.Strip):\n        return {\n            schema.__name__.lower(): True,\n        }\n\n    if isinstance(schema, vol.Coerce):\n        schema = schema.type\n\n    if schema in TYPES_MAP:\n        return {'type': TYPES_MAP[schema]}\n\n    raise ValueError('Unable to convert schema: {}'.format(schema))", "response": "Convert a voluptuous schema to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getheader(self, field, default=''):\n        if self.headers:\n            for header in self.headers:\n                if field.lower() == header.lower():\n                    return self.headers[header]\n\n        return default", "response": "Returns the HTTP response header field case insensitively"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isAlphanum(c):\n    return ((c >= 'a' and c <= 'z') or (c >= '0' and c <= '9') or\n            (c >= 'A' and c <= 'Z') or c == '_' or c == '$' or c == '\\\\' or (c is not None and ord(c) > 126));", "response": "Return True if the character is a letter digit underscore dollar sign or non - ASCII character."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the next character from stdin", "response": "def _get(self):\n        \"\"\"return the next character from stdin. Watch out for lookahead. If\n           the character is a control character, translate it to a space or\n           linefeed.\n        \"\"\"\n        c = self.theLookahead\n        self.theLookahead = None\n        if c == None:\n            c = self.instream.read(1)\n        if c >= ' ' or c == '\\n':\n            return c\n        if c == '': # EOF\n            return '\\000'\n        if c == '\\r':\n            return '\\n'\n        return ' '"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the next character excluding comments. peek is used to see .", "response": "def _next(self):\n        \"\"\"get the next character, excluding comments. peek() is used to see\n           if a '/' is followed by a '/' or '*'.\n        \"\"\"\n        c = self._get()\n        if c == '/':\n            p = self._peek()\n            if p == '/':\n                c = self._get()\n                while c > '\\n':\n                    c = self._get()\n                return c\n            if p == '*':\n                c = self._get()\n                while 1:\n                    c = self._get()\n                    if c == '*':\n                        if self._peek() == '/':\n                            self._get()\n                            return ' '\n                    if c == '\\000':\n                        raise UnterminatedComment()\n\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndo something! What you do is determined by the argument: 1 Output A. Copy B to A. Get the next B. 2 Copy B to A. Get the next B. (Delete A). 3 Get the next B. (Delete B). action treats a string as a single character. Wow! action recognizes a regular expression if it is preceded by ( or , or =.", "response": "def _action(self, action):\n        \"\"\"do something! What you do is determined by the argument:\n           1   Output A. Copy B to A. Get the next B.\n           2   Copy B to A. Get the next B. (Delete A).\n           3   Get the next B. (Delete B).\n           action treats a string as a single character. Wow!\n           action recognizes a regular expression if it is preceded by ( or , or =.\n        \"\"\"\n        if action <= 1:\n            self._outA()\n\n        if action <= 2:\n            self.theA = self.theB\n            if self.theA == \"'\" or self.theA == '\"':\n                while 1:\n                    self._outA()\n                    self.theA = self._get()\n                    if self.theA == self.theB:\n                        break\n                    if self.theA <= '\\n':\n                        raise UnterminatedStringLiteral()\n                    if self.theA == '\\\\':\n                        self._outA()\n                        self.theA = self._get()\n\n\n        if action <= 3:\n            self.theB = self._next()\n            if self.theB == '/' and (self.theA == '(' or self.theA == ',' or\n                                     self.theA == '=' or self.theA == ':' or\n                                     self.theA == '[' or self.theA == '?' or\n                                     self.theA == '!' or self.theA == '&' or\n                                     self.theA == '|'):\n                self._outA()\n                self._outB()\n                while 1:\n                    self.theA = self._get()\n                    if self.theA == '/':\n                        break\n                    elif self.theA == '\\\\':\n                        self._outA()\n                        self.theA = self._get()\n                    elif self.theA <= '\\n':\n                        raise UnterminatedRegularExpression()\n                    self._outA()\n                self.theB = self._next()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy the input to the output deleting the characters which are not insignificant to JavaScript.", "response": "def _jsmin(self):\n        \"\"\"Copy the input to the output, deleting the characters which are\n           insignificant to JavaScript. Comments will be removed. Tabs will be\n           replaced with spaces. Carriage returns will be replaced with linefeeds.\n           Most spaces and linefeeds will be removed.\n        \"\"\"\n        self.theA = '\\n'\n        self._action(3)\n\n        while self.theA != '\\000':\n            if self.theA == ' ':\n                if isAlphanum(self.theB):\n                    self._action(1)\n                else:\n                    self._action(2)\n            elif self.theA == '\\n':\n                if self.theB in ['{', '[', '(', '+', '-']:\n                    self._action(1)\n                elif self.theB == ' ':\n                    self._action(3)\n                else:\n                    if isAlphanum(self.theB):\n                        self._action(1)\n                    else:\n                        self._action(2)\n            else:\n                if self.theB == ' ':\n                    if isAlphanum(self.theA):\n                        self._action(1)\n                    else:\n                        self._action(3)\n                elif self.theB == '\\n':\n                    if self.theA in ['}', ']', ')', '+', '-', '\"', '\\'']:\n                        self._action(1)\n                    else:\n                        if isAlphanum(self.theA):\n                            self._action(1)\n                        else:\n                            self._action(3)\n                else:\n                    self._action(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting / layertemplates : All items in the collection.", "response": "def index(self, format='html'):\n        \"\"\"GET /layertemplates: All items in the collection.\"\"\"\n        # url('layertemplates')\n        lts = meta.Session.query(LayerTemplate)\n        # use following query for getting layertemplates owned by current user\n        #lts = self._get_lts_from_user(c.user)\n        serialized_lts = []\n        for lt in lts:\n            serialized_lts.append({\n                'id': lt.id,\n                'name': lt.name,\n                'comment': lt.comment,\n                \"href\": h.url_for(controller=\"layertemplates\", action=\"show\", id=lt.id)\n                })\n        # prevent JSON Array Cross-site Exploits (XSRF/CSRF)\n        return {'layertemplates': serialized_lts}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npost / layertemplates : Create a new item.", "response": "def create(self):\n        \"\"\"POST /layertemplates: Create a new item.\"\"\"\n        # url('layertemplates')\n        content = request.environ['wsgi.input'].read(int(request.environ['CONTENT_LENGTH']))\n        content = content.decode('utf8')\n        content = simplejson.loads(content)\n        lt = self._new_lt_from_user(content['name'], content['comment'], content['json'], c.user)\n        response.status = 201\n        href = h.url_for(controller=\"layertemplates\", action=\"show\", id=lt.id)\n        return {'name': lt.name, 'comment': lt.comment, 'id': lt.id, 'href': href}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, id):\n        # url('LayerTemplates', id=ID)\n        lt = meta.Session.query(LayerTemplate).get(id)\n        # use following query for getting a layertemplate owned by current user\n        #lt = self._get_lt_from_user_by_id(c.user, id)\n        if lt is None:\n            abort(404)\n        content = request.environ['wsgi.input'].read(int(request.environ['CONTENT_LENGTH']))\n        content = content.decode('utf8')\n        content = simplejson.loads(content)        \n        lt.name = content['name']\n        lt.comment = content['comment']\n        lt.json = content['json']\n        meta.Session.commit()\n        response.status = 201", "response": "PUT / layertemplates / id : Update an existing item."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes / layertemplates / id : Delete an existing item.", "response": "def delete(self, id):\n        \"\"\"DELETE /layertemplates/id: Delete an existing item.\"\"\"\n        # url('LayerTemplates', id=ID)\n        lt = meta.Session.query(LayerTemplate).get(id)\n        # use following query for getting a layertemplate owned by current user\n        #lt = self._get_lt_from_user_by_id(c.user, id)\n        if lt is None:\n            abort(404)\n        meta.Session.delete(lt)\n        meta.Session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show(self, id):\n        # url('LayerTemplates', id=ID)\n        lt = meta.Session.query(LayerTemplate).get(id)\n        # use following query for getting a layertemplate owned by current user\n        #lt = self._get_lt_from_user_by_id(c.user, id)\n        if lt is None:\n            abort(404)\n        return lt.to_json()", "response": "GET / layertemplates / id : Show a specific item."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_lts_from_user(self, user):\n        req = meta.Session.query(LayerTemplate).select_from(join(LayerTemplate, User))\n        return req.filter(User.login==user).all()", "response": "Get all layertemplates owned by a user from the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a layertemplate owned by a user from the database by lt_id.", "response": "def _get_lt_from_user_by_id(self, user, lt_id):\n        \"\"\" Get a layertemplate owned by a user from the database by lt_id. \"\"\"\n        req = meta.Session.query(LayerTemplate).select_from(join(LayerTemplate, User))\n        try:\n            return req.filter(and_(User.login==user, LayerTemplate.id==lt_id)).one()\n        except Exception, e:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encode(B):\n    B = array(B)\n\n    flatten = False\n    if len(B.shape) == 1:\n        flatten = True\n        B = B.reshape(1, -1)\n\n    if B.shape[1] != data_size:\n        raise ValueError('Data must be shaped as (4, ) or (-1, 4)')\n\n    C = dot(G, B.T).T % 2\n\n    if flatten:\n        C = C.flatten()\n\n    return C", "response": "Encode data using Hamming ( 7 4 ) code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode binary data using Hamming ( 7 4 ) code.", "response": "def decode(C):\n    \"\"\" Decode data using Hamming(7, 4) code.\n\n    E.g.:\n        decode([1, 0, 0, 0, 0, 1, 1])\n\n        encode([[1, 1, 0, 1, 0, 0, 1],\n                [0, 1, 0, 0, 1, 0, 1]])\n\n    :param array C: binary data to code (must be shaped as (7, ) or (-1, 7)).\n\n    \"\"\"\n    C = array(C)\n\n    flatten = False\n    if len(C.shape) == 1:\n        flatten = True\n        C = C.reshape(1, -1)\n\n    if C.shape[1] != msg_size:\n        raise ValueError('Data must be shaped as (7, ) or (-1, 7)')\n\n    if 1 in dot(H, C.T).T % 2:\n        raise ValueError('Incorrect code given as input.')\n\n    B = C[:, data_bits]\n\n    if flatten:\n        B = B.flatten()\n\n    return B"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef index(self):\n        maps = self._get_maps_from_user(c.user)\n        serialized_maps = []\n        for m in maps:\n            serialized_maps.append({\n                \"id\": m.id,\n                \"name\": m.name,\n                \"href\": h.url_for(controller=\"mapfiles\", action=\"show\", id=m.id),\n                'wmsproxyurl':h.url_for(controller='mapfiles', action='wms_proxy', id=m.id),\n                'wmsurl': \"%s?%s\" %(config['mapserver_url'], urlencode({'map':os.path.join(config['mapfiles_dir'], m.filepath)}))\n            })\n        # prevent JSON Array Cross-site Exploits (XSRF/CSRF)\n        return {'maps': serialized_maps}", "response": "GET / mapfiles : Get all mapfiles owned by the current user"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npost / mapfiles : Create a new item.", "response": "def create(self):\n        \"\"\"POST /mapfiles: Create a new item.\"\"\"\n        # get json content from POST request\n        content = request.environ['wsgi.input'].read(int(request.environ['CONTENT_LENGTH']))\n        #content = content.decode('utf8')   mapfile interface don't like unicode strings... bad...\n\n        # load mapfile\n        mapfile = Mapfile()\n        dict = simplejson.loads(content)\n        mapfile.from_dict(dict)\n\n        # create mapfile\n        mapname = mapfile.get_name()\n        map_pathname = h.gen_mapname()\n        mapfile.to_file(os.path.join(config['mapfiles_dir'], map_pathname))\n\n        # create map in db\n        map = self._new_map_from_user(c.user, mapname, map_pathname)\n\n        response.status = 201\n\n        href = h.url_for(controller=\"mapfiles\", action=\"show\", id=map.id)\n        wmsproxyurl = h.url_for(controller='mapfiles', action='wms_proxy', id=map.id)\n        wmsurl = \"%s?%s\" %(config['mapserver_url'], urlencode({'map':os.path.join(config['mapfiles_dir'], map.filepath)}))\n        return {'name': map.name, 'id': map.id, 'href': href, 'wmsurl': wmsurl, 'wmsproxyurl': wmsproxyurl}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, id):\n        map = self._get_map_from_user_by_id(c.user, id)\n        if map is None:\n            abort(404)\n\n        # get json content from PUT request\n        content = request.environ['wsgi.input'].read(int(request.environ['CONTENT_LENGTH']))\n        #content = content.decode('utf8')\n\n        # update mapfile\n        mapfile = Mapfile()\n        dict = simplejson.loads(content)\n        mapfile.from_dict(dict)\n        mapfile.to_file(os.path.join(config['mapfiles_dir'], map.filepath))\n        if mapfile.get_name() != map.name:\n            self._update_map(map, name=mapfile.get_name())\n\n        response.status = 201\n        return", "response": "PUT / mapfiles / id : Update an existing item."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete / mapfiles / id", "response": "def delete(self, id):\n        \"\"\"DELETE /mapfiles/id: Delete an existing mapfile owned by the current\n        user. Deletion of the map entry in db and remove mapfile from filesystem. \"\"\"\n        map = self._delete_map_from_user_by_id(c.user, id)\n        if map is None:\n            abort(404)\n        if os.path.exists(os.path.join(config['mapfiles_dir'], map.filepath)):\n            os.unlink(os.path.join(config['mapfiles_dir'], map.filepath))\n\n        response.status = 204\n        # remove content-type from response headers so that webtest won't get confused\n        # http://groups.google.com/group/pylons-discuss/browse_thread/thread/1267650386ae521b\n        del response.headers['content-type'] \n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show(self, id):\n        map = self._get_map_from_user_by_id(c.user, id)\n        if map is None:\n            abort(404)\n        mapfile = Mapfile()\n        mapfile.from_file(os.path.join(config['mapfiles_dir'], map.filepath))\n        return {\n            'map': mapfile.to_dict(),\n            'wmsproxyurl': h.url_for(controller='mapfiles', action='wms_proxy', id=id),\n            'wmsurl': \"%s?%s\" %(config['mapserver_url'], urlencode({'map':os.path.join(config['mapfiles_dir'], map.filepath)}))\n        }", "response": "GET / mapfiles / id : Get a specific mapfile owned by the current user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_map_from_user_by_id(self, user, map_id):\n        req = Session.query(Map).select_from(join(Map, User))\n        try:\n            return req.filter(and_(User.login==user, Map.id==map_id)).one()\n        except Exception, e:\n            return None", "response": "Get a mapfile owned by a user by a map_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all mapfiles owned by a user from the database.", "response": "def _get_maps_from_user(self, user):\n        \"\"\" Get mapfiles owned by a user from the database. \"\"\"\n        req = Session.query(Map).select_from(join(Map, User))\n        return req.filter(User.login==user).all()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete a mapfile entry from database.", "response": "def _delete_map_from_user_by_id(self, user, map_id):\n        \"\"\" Delete a mapfile entry from database. \"\"\"\n        map = self._get_map_from_user_by_id(user, map_id)\n        if map is None:\n            return None\n        Session.delete(map)\n        Session.commit()\n        return map"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update_map(self, map, name=None, filepath=None):\n        if name:\n            map.name = name\n        if filepath:\n            map.filepath = filepath\n        Session.commit()", "response": "Update a mapfile entry in the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new mapfile entry in database.", "response": "def _new_map_from_user(self, user, name, filepath):\n        \"\"\" Create a new mapfile entry in database. \"\"\"\n        map = Map(name, filepath)\n        map.user = Session.query(User).filter(User.login==user).one()\n        Session.add(map)\n        Session.commit()\n        return map"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self, url, urlparams=None):\n        for k,v in request.params.iteritems():\n            urlparams[k]=v\n        query = urlencode(urlparams)\n        full_url = url\n        if query:\n            if not full_url.endswith(\"?\"):\n                full_url += \"?\"\n            full_url += query\n\n        # build the request with its headers\n        req = urllib2.Request(url=full_url)\n        for header in request.headers:\n            if header.lower() == \"host\":\n                req.add_header(header, urlparse.urlparse(url)[1])\n            else:\n                req.add_header(header, request.headers[header])\n        res = urllib2.urlopen(req)\n\n        # add response headers\n        i = res.info()\n        response.status = res.code\n        got_content_length = False\n        for header in i:\n            # We don't support serving the result as chunked\n            if header.lower() == \"transfer-encoding\":\n                continue\n            if header.lower() == \"content-length\":\n                got_content_length = True\n            response.headers[header] = i[header]\n\n        # return the result\n        result = res.read()\n        res.close()\n\n        #if not got_content_length:\n        #    response.headers['content-length'] = str(len(result))\n        return result", "response": "Proxy the request to the url and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open_file(orig_file_path):\n    unquoted = unquote(orig_file_path)\n    paths = [\n        convert_to_platform_safe(orig_file_path),\n        \"%s/index.html\" % (convert_to_platform_safe(orig_file_path)),\n        orig_file_path,\n        \"%s/index.html\" % orig_file_path,\n        convert_to_platform_safe(unquoted),\n        \"%s/index.html\" % (convert_to_platform_safe(unquoted)),\n        unquoted,\n        \"%s/index.html\" % unquoted,\n        ]\n\n    file_path = None\n    handle = None\n    for path in paths:\n        try:\n            file_path = path\n            handle = open(path, \"rb\")\n            break\n        except IOError:\n            pass\n\n    return handle", "response": "Open a mock data file with the given file path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attempt_open_query_permutations(url, orig_file_path, is_header_file):\n    directory = dirname(convert_to_platform_safe(orig_file_path)) + \"/\"\n\n    # get all filenames in directory\n    try:\n        filenames = [f for f in os.listdir(directory)\n                     if isfile(join(directory, f))]\n    except OSError:\n        return\n\n    # ensure that there are not extra parameters on any files\n    if is_header_file:\n        filenames = [f for f in filenames if \".http-headers\" in f]\n        filenames = [f for f in filenames if\n                     _compare_file_name(orig_file_path + \".http-headers\",\n                                        directory,\n                                        f)]\n    else:\n        filenames = [f for f in filenames if \".http-headers\" not in f]\n        filenames = [f for f in filenames if _compare_file_name(orig_file_path,\n                                                                directory,\n                                                                f)]\n\n    url_parts = url.split(\"/\")\n    url_parts = url_parts[len(url_parts) - 1].split(\"?\")\n\n    base = url_parts[0]\n    params = url_parts[1]\n\n    params = params.split(\"&\")\n\n    # check to ensure that the base url matches\n    filenames = [f for f in filenames if f.startswith(base)]\n\n    params = [convert_to_platform_safe(unquote(p)) for p in params]\n\n    # ensure that all parameters are there\n    for param in params:\n        filenames = [f for f in filenames if param in f]\n\n    # if we only have one file, return it\n    if len(filenames) == 1:\n        path = join(directory, filenames[0])\n        return open_file(path)\n\n    # if there is more than one file, raise an exception\n    if len(filenames) > 1:\n        raise DataFailureException(url,\n                                   \"Multiple mock data files matched the \" +\n                                   \"parameters provided!\",\n                                   404)", "response": "Attempt to open a given mock data file with different permutations of the query parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lookup(self,value):\n        for k,v in self.iteritems():\n            if value == v:\n                return k\n        return None", "response": "lookup the first key in dict where value is name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprovide line pos and absPosition line as string", "response": "def _getLPA( self ):\n        \" Provides line, pos and absPosition line as string \"\n        return str( self.line ) + \":\" + \\\n               str( self.pos ) + \":\" + \\\n               str( self.absPosition )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getDisplayName( self ):\n        \" Provides a name for display purpose \"\n        displayName = self.name\n        if self.base:\n            displayName += \"( \" + \", \".join( self.base ) + \" )\"\n        return displayName", "response": "Provides a name for display purpose"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a string representation with new lines and shifts", "response": "def niceStringify( self ):\n        \" Returns a string representation with new lines and shifts \"\n\n        out = \"\"\n        if self.docstring is not None:\n            out += str( self.docstring )\n        if not self.encoding is None:\n            if out != \"\":\n                out += '\\n'\n            out += str( self.encoding )\n        for item in self.imports:\n            if out != \"\":\n                out += '\\n'\n            out += str( item )\n        for item in self.globals:\n            if out != \"\":\n                out += '\\n'\n            out += str( item )\n        for item in self.functions:\n            if out != \"\":\n                out += '\\n'\n            out += item.niceStringify( 0 )\n        for item in self.classes:\n            if out != \"\":\n                out += '\\n'\n            out += item.niceStringify( 0 )\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmemorize an alias for an import or an imported item", "response": "def _onAs( self, name ):\n        \" Memorizes an alias for an import or an imported item \"\n        if self.__lastImport.what:\n            self.__lastImport.what[ -1 ].alias = name\n        else:\n            self.__lastImport.alias = name\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _onDecorator( self, name, line, pos, absPosition ):\n        \" Memorizes a function or a class decorator \"\n        # A class or a function must be on the top of the stack\n        self.objectsStack[ -1 ].decorators.append(\n                                            Decorator( name, line, pos,\n                                                       absPosition ) )\n        return", "response": "Memorizes a function or a class decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmemorize a function / class / module docstring", "response": "def _onDocstring( self, docstr, line ):\n        \" Memorizes a function/class/module docstring \"\n        if self.objectsStack:\n            self.objectsStack[ -1 ].docstring = \\\n                                 Docstring( trim_docstring( docstr ), line )\n            return\n\n        self.docstring = Docstring( trim_docstring( docstr ), line )\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef comment_count(obj):\n    model_object = type(obj).objects.get(id=obj.id)\n    return model_object.comments.all().count()", "response": "returns the count of comments of an object"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn profile url of user", "response": "def profile_url(obj, profile_app_name, profile_model_name):\n    \"\"\" returns profile url of user \"\"\"\n    try:\n        content_type = ContentType.objects.get(\n            app_label=profile_app_name,\n            model=profile_model_name.lower()\n        )\n        profile = content_type.get_object_for_this_type(user=obj.user)\n        return profile.get_absolute_url()\n    except ContentType.DoesNotExist:\n        return \"\"\n    except AttributeError:\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn url of profile image of a user", "response": "def img_url(obj, profile_app_name, profile_model_name):\n    \"\"\" returns url of profile image of a user \"\"\"\n    try:\n        content_type = ContentType.objects.get(\n            app_label=profile_app_name,\n            model=profile_model_name.lower()\n        )\n    except ContentType.DoesNotExist:\n        return \"\"\n    except AttributeError:\n        return \"\"\n\n    Profile = content_type.model_class()\n    fields = Profile._meta.get_fields()\n    profile = content_type.model_class().objects.get(user=obj.user)\n    for field in fields:\n        if hasattr(field, \"upload_to\"):\n            return field.value_from_object(profile).url"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of comments related to a certain object and renders the appropriate template to view it", "response": "def get_comments(obj, request, oauth=False, paginate=False, cpp=10):\n    \"\"\"\n    Retrieves list of comments related to a certain object and renders\n    The appropriate template to view it\n    \"\"\"\n    model_object = type(obj).objects.get(id=obj.id)\n    comments = Comment.objects.filter_by_object(model_object)\n    comments_count = comments.count()\n    if paginate:\n        paginator = Paginator(comments, cpp)\n        page = request.GET.get('page')\n        try:\n            comments = paginator.page(page)\n        except PageNotAnInteger:\n            comments = paginator.page(1)\n        except EmptyPage:\n            comments = paginator.page(paginator.num_pages)\n\n    try:\n        profile_app_name = settings.PROFILE_APP_NAME\n        profile_model_name = settings.PROFILE_MODEL_NAME\n    except AttributeError:\n        profile_app_name = None\n        profile_model_name = None\n\n    try:\n        if settings.LOGIN_URL.startswith(\"/\"):\n            login_url = settings.LOGIN_URL\n        else:\n            login_url = \"/\" + settings.LOGIN_URL\n    except AttributeError:\n        login_url = \"\"\n\n    return {\n        \"commentform\": CommentForm(),\n        \"model_object\": obj,\n        \"user\": request.user,\n        \"comments\": comments,\n        # \"comments_count\": comments_count,\n        \"oauth\": oauth,\n        \"profile_app_name\": profile_app_name,\n        \"profile_model_name\": profile_model_name,\n        \"paginate\": paginate,\n        \"login_url\": login_url,\n        \"cpp\": cpp\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the instance as a. lcopt file", "response": "def save(self):\n        \"\"\"save the instance as a .lcopt file\"\"\"\n        if self.save_option == 'curdir':\n            model_path = os.path.join(\n                os.getcwd(),\n                '{}.lcopt'.format(self.name)\n            )\n        else: # default to appdir\n            model_path = os.path.join(\n                storage.model_dir,\n                '{}.lcopt'.format(self.name)\n            )\n        \n        model_path = fix_mac_path_escapes(model_path)\n\n        with open(model_path, 'wb') as model_file:\n            pickle.dump(self, model_file)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self, filename):\n        if filename[-6:] != \".lcopt\":\n            filename += \".lcopt\"\n        try:\n            savedInstance = pickle.load(open(\"{}\".format(filename), \"rb\"))\n        except FileNotFoundError:\n            savedInstance = pickle.load(open(fix_mac_path_escapes(os.path.join(storage.model_dir, \"{}\".format(filename))), \"rb\"))\n        \n        attributes = ['name',\n                      'database',\n                      'params',\n                      'production_params',\n                      'allocation_params',\n                      'ext_params',\n                      'matrix',\n                      'names',\n                      'parameter_sets',\n                      'model_matrices',\n                      'technosphere_matrices',\n                      'leontif_matrices',\n                      'external_databases',\n                      'parameter_map',\n                      'sandbox_positions',\n                      'ecoinventName',\n                      'biosphereName',\n                      'forwastName',\n                      'analysis_settings',\n                      'technosphere_databases',\n                      'biosphere_databases',\n                      'result_set',\n                      'evaluated_parameter_sets',\n                      'useForwast',\n                      'base_project_name',\n                      'save_option',\n                      'allow_allocation',\n                      'ecoinvent_version',\n                      'ecoinvent_system_model',\n                      ]\n\n        for attr in attributes:\n\n            if hasattr(savedInstance, attr):\n                setattr(self, attr, getattr(savedInstance, attr))\n            else:\n                pass\n                #print (\"can't set {}\".format(attr))\n\n        # use legacy save option if this is missing from the model\n        if not hasattr(savedInstance, 'save_option'):\n            setattr(self, 'save_option', LEGACY_SAVE_OPTION)\n\n        # figure out ecoinvent version and system model if these are missing from the model\n        if not hasattr(savedInstance, 'ecoinvent_version') or not hasattr(savedInstance, 'ecoinvent_system_model'):\n            \n            parts = savedInstance.ecoinventName.split(\"_\")\n            main_version = parts[0][-1]\n            sub_version = parts[1]\n            system_model = parts[2]\n\n            #print(parts)\n\n            setattr(self, 'ecoinvent_version', '{}.{}'.format(main_version, sub_version))\n            setattr(self, 'ecoinvent_system_model', system_model)", "response": "load data from a saved. lcopt file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_product (self, name, location='GLO', unit='kg', **kwargs):\n\n        \"\"\"\n        Create a new product in the model database\n        \"\"\"\n\n        new_product = item_factory(name=name, location=location, unit=unit, type='product', **kwargs)\n\n        if not self.exists_in_database(new_product['code']):\n            self.add_to_database(new_product)\n            #print ('{} added to database'.format(name))\n            return self.get_exchange(name)\n        else:\n            #print('{} already exists in this database'.format(name))\n            return False", "response": "Create a new product in the model database"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_process(self, name, exchanges, location='GLO', unit='kg'):\n\n        found_exchanges = []\n        for e in exchanges:\n\n            exc_name = e.pop('name', None)\n            exc_type = e.pop('type', None)\n\n            this_exchange = self.get_exchange(exc_name)\n            \n            if this_exchange is False:\n                my_unit = e.pop('unit', unit)\n                    \n                this_exchange = self.create_product(exc_name, location=location, unit=my_unit, **e)\n            \n            found_exchanges.append(exchange_factory(this_exchange, exc_type, 1, 1, '{} exchange of {}'.format(exc_type, exc_name)))\n            \n        new_process = item_factory(name=name, location=location, unit=unit, type='process', exchanges=found_exchanges)\n        \n        self.add_to_database(new_process)\n\n        self.parameter_scan()\n\n        return True", "response": "Create a new process in the model database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_input_link(self, process_code, input_code):\n\n        \"\"\"\n        Remove an input (technosphere or biosphere exchange) from a process, resolving all parameter issues\n        \"\"\"\n        # 1. find correct process\n        # 2. find correct exchange\n        # 3. remove that exchange\n        # 4. check for parameter conflicts?\n        # 4. run parameter scan to rebuild matrices?\n        \n        #print(process_code, input_code)\n        \n        process = self.database['items'][process_code]\n        exchanges = process['exchanges']\n        \n        initial_count = len(exchanges)\n        \n        new_exchanges = [e for e in exchanges if e['input'] != input_code]\n        \n        product_code = [e['input'] for e in exchanges if e['type'] == 'production'][0]\n        \n        #print(product_code)\n        \n        param_id = [k for k, v in self.params.items() if (v['from'] == input_code[1] and v['to'] == product_code[1])][0]\n        \n        #print (param_id)\n        \n        problem_functions = self.check_param_function_use(param_id)\n        \n        if len(problem_functions) != 0:\n            #print('the following functions have been removed:')\n            for p in problem_functions:\n                self.params[p[0]]['function'] = None\n                #print(p)\n\n        process['exchanges'] = new_exchanges\n\n        del self.params[param_id]\n\n        self.parameter_scan()\n\n        return initial_count - len(new_exchanges)", "response": "Remove an input link from a process"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unlink_intermediate(self, sourceId, targetId):\n        \n        source = self.database['items'][(self.database.get('name'), sourceId)]\n        target = self.database['items'][(self.database.get('name'), targetId)]\n\n        production_exchange = [x['input'] for x in source['exchanges'] if x['type'] == 'production'][0]\n\n        new_exchanges = [x for x in target['exchanges'] if x['input'] != production_exchange]\n\n        target['exchanges'] = new_exchanges\n\n        self.parameter_scan()\n\n        return True", "response": "Remove a link between two processes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nscan the database of the model instance to generate and expose parameters.", "response": "def parameter_scan(self):\n        \"\"\"\n        Scan the database of the model instance to generate and expose parameters.\n        \n        This is called by other functions when items are added/removed from the model, but can be run by itself if you like\n        \"\"\"\n        \n        #self.parameter_map = {}\n        #self.params = OrderedDict()\n\n        cr_list = []\n        items = self.database['items']\n        #print(items)\n\n        for key in items.keys():\n            i = items[key]\n            #print(i['name'], i['type'])\n            if i['type'] == 'product':\n                cr_list.append(i['code'])\n\n        no_products = len(cr_list)\n\n        self.names = [self.get_name(x) for x in cr_list]\n\n        self.matrix = np.zeros((no_products, no_products))\n        \n        for key in items.keys():\n            i = items[key]\n            if i['type'] == 'process':\n                inputs = []\n                #print(i['name'])\n                #print([(e['comment'], e['type']) for e in i['exchanges']])\n                for e in i['exchanges']:\n                    if e['type'] == 'production':\n                        col_code = cr_list.index(e['input'][1])\n                        if not 'p_{}_production'.format(col_code) in self.production_params:\n                            self.production_params['p_{}_production'.format(col_code)] = {\n                                'function': None,\n                                'description': 'Production parameter for {}'.format(self.get_name(e['input'][1])),\n                                'unit': self.get_unit(e['input'][1]),\n                                'from': e['input'],\n                                'from_name': self.get_name(e['input'][1]),\n                                'type': 'production',\n                            }\n                        if not 'p_{}_allocation'.format(col_code) in self.allocation_params:\n                            self.allocation_params['p_{}_allocation'.format(col_code)] = {\n                                'function': None,\n                                'description': 'Allocation parameter for {}'.format(self.get_name(e['input'][1])),\n                                'unit': \"% (as decimal)\", \n                                'from': e['input'],\n                                'from_name': self.get_name(e['input'][1]),\n                                'type': 'allocation',\n                            }\n\n                    elif e['type'] == 'technosphere':\n                        #print(cr_list)\n                        row_code = cr_list.index(e['input'][1])\n                        inputs.append((row_code, e['amount']))\n\n                for ip in inputs:\n                    self.matrix[(ip[0], col_code)] = ip[1]\n\n        param_check_list = []\n\n        for c, column in enumerate(self.matrix.T):\n            for r, i in enumerate(column):\n                if i > 0:\n                    p_from = cr_list[r]\n                    p_to = cr_list[c]\n                    coords = (r, c)\n\n                    from_item_type = self.database['items'][(self.database['name'], p_from)]['lcopt_type']\n                    #print('{}\\t| {} --> {}'.format(coords, self.get_name(p_from), self.get_name(p_to)))\n\n                    param_check_list.append('p_{}_{}'.format(coords[0], coords[1]))\n\n                    if not 'p_{}_{}'.format(coords[0], coords[1]) in self.params:\n                        self.params['p_{}_{}'.format(coords[0], coords[1])] = {\n                            'function': None,\n                            'normalisation_parameter': '(p_{}_production / p_{}_allocation)'.format(coords[1], coords[1]),\n                            'description': 'Input of {} to create {}'.format(self.get_name(p_from), self.get_name(p_to)),\n                            'coords': coords,\n                            'unit': self.get_unit(p_from),\n                            'from': p_from,\n                            'from_name': self.get_name(p_from),\n                            'to': p_to,\n                            'to_name': self.get_name(p_to),\n                            'type': from_item_type,\n                        }\n\n                    #elif 'normalisation_parameter' not in self.params['p_{}_{}'.format(coords[0], coords[1])].keys():\n                        #print(\"Adding normalisation_parameter to {}\".format('p_{}_{}'.format(coords[0], coords[1])))\n                        #self.params['p_{}_{}'.format(coords[0], coords[1])]['normalisation_parameter'] = '(p_{}_production / p_{}_allocation)'.format(coords[1], coords[1])\n                        \n                        #print('p_{}_{} already exists'.format(coords[0],coords[1]))\n\n                    else:\n                        pass  # print(\"SOMETHING WRONG HERE\\n{}\\n\".format(self.params['p_{}_{}'.format(coords[0], coords[1])]))\n\n                    # make sure the parameter is being normalised and allocated properly\n                    self.params['p_{}_{}'.format(coords[0], coords[1])]['normalisation_parameter'] = '(p_{}_production / p_{}_allocation)'.format(coords[1], coords[1])\n\n                    if not 'p_{}_{}'.format(coords[0], coords[1]) in self.parameter_map:\n                        self.parameter_map[(p_from, p_to)] = 'p_{}_{}'.format(coords[0], coords[1])\n\n        kill_list = []\n        for k in self.params.keys():\n            if k not in param_check_list:\n                #print(\"{} may be obsolete\".format(k))\n                kill_list.append(k)\n\n        for p in kill_list:\n            #print(\"deleting parameter {}\".format(p))\n            del self.params[p]\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_parameter_set_excel_file(self):\n        \n        parameter_sets = self.parameter_sets\n\n        p_set = []\n        filename = \"ParameterSet_{}_input_file.xlsx\".format(self.name)\n\n        if self.save_option == 'curdir':\n            base_dir = os.getcwd()\n        else:\n            base_dir = os.path.join(storage.simapro_dir, self.name.replace(\" \", \"_\"))\n\n        if not os.path.isdir(base_dir):\n            os.mkdir(base_dir)\n\n        p_set_name = os.path.join(base_dir, filename)\n\n        p = self.params\n        for k in p.keys():\n            if p[k]['function'] is None:\n                base_dict = {'id': k, 'name': p[k]['description'], 'unit': p[k]['unit']}\n\n                for s in parameter_sets.keys():\n                    base_dict[s] = parameter_sets[s][k]\n\n                p_set.append(base_dict)\n            else:\n                pass\n                #print(\"{} is determined by a function\".format(p[k]['description']))\n\n        for e in self.ext_params:\n            base_dict = {'id': '{}'.format(e['name']), 'type': 'external', 'name': e['description'], 'unit': ''}\n\n            for s in parameter_sets.keys():\n                    base_dict[s] = parameter_sets[s][e['name']]\n\n            p_set.append(base_dict)\n\n        df = pd.DataFrame(p_set)\n\n        with pd.ExcelWriter(p_set_name, engine='xlsxwriter') as writer:\n\n            ps_columns = [k for k in parameter_sets.keys()]\n            #print (ps_columns)\n            my_columns = ['name', 'unit', 'id']\n            \n            my_columns.extend(ps_columns)\n            #print (my_columns)\n\n            #print(df)\n\n            df.to_excel(writer, sheet_name=self.name, columns=my_columns, index=False, merge_cells=False)\n       \n        return p_set_name", "response": "Generate an Excel file containing the parameter sets in a format that can be used to import the simulation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a global parameter to the database that can be accessed by functions", "response": "def add_parameter(self, param_name, description=None, default=0, unit=None):\n        \"\"\"\n        Add a global parameter to the database that can be accessed by functions\n        \"\"\"\n\n        if description is None:\n            description = \"Parameter called {}\".format(param_name)\n\n        if unit is None:\n            unit = \"-\"\n        \n        name_check = lambda x: x['name'] == param_name\n        name_check_list = list(filter(name_check, self.ext_params))\n        if len(name_check_list) == 0:\n            self.ext_params.append({'name': param_name, 'description': description, 'default': default, 'unit': unit})\n        else:\n            print('{} already exists - choose a different name'.format(param_name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_parameters_as_df(self):\n        to_df = []\n\n        for i, e in enumerate(self.ext_params):\n            row = {}\n            row['id'] = e['name']\n            row['coords'] = \"n/a\"\n            row['description'] = e['description']\n            row['function'] = \"n/a\"\n\n            to_df.append(row)\n\n        for pk in self.params:\n            p = self.params[pk]\n            row = {}\n            row['id'] = pk\n            row['coords'] = p['coords']\n            row['description'] = p['description']\n            row['function'] = p['function']\n\n            to_df.append(row)\n\n        df = pd.DataFrame(to_df)\n        \n        return df", "response": "Lists the parameters in the model in a pandas dataframe"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimports an external database for use in lcopt", "response": "def import_external_db(self, db_file, db_type=None):\n        \"\"\"\n        Import an external database for use in lcopt\n\n        db_type must be one of ``technosphere`` or ``biosphere``\n\n        The best way to 'obtain' an external database is to 'export' it from brightway as a pickle file\n\n        e.g.::\n\n            import brightway2 as bw\n            bw.projects.set_current('MyModel')\n            db = bw.Database('MyDatabase')\n            db_as_dict = db.load()\n            import pickle\n            with open('MyExport.pickle', 'wb') as f:\n                pickle.dump(db_as_dict, f)\n\n        NOTE: The Ecoinvent cutoff 3.3 database and the full biosphere database are included in the lcopt model as standard - no need to import those\n\n        This can be useful if you have your own methods which require new biosphere flows that you want to analyse using lcopt\n\n        \"\"\"\n        \n        db = pickle.load(open(\"{}.pickle\".format(db_file), \"rb\"))\n        name = list(db.keys())[0][0]\n        new_db = {'items': db, 'name': name}\n        self.external_databases.append(new_db)\n\n        if db_type is None:             # Assume its a technosphere database\n            db_type = 'technosphere'\n\n        if db_type == 'technosphere':\n            self.technosphere_databases.append(name)\n        elif db_type == 'biosphere':\n            self.biosphere_databases.append(name)\n\n        else:\n            raise Exception\n            print (\"Database type must be 'technosphere' or 'biosphere'\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching external databases linked to your lcopt model.", "response": "def search_databases(self, search_term, location=None, markets_only=False, databases_to_search=None, allow_internal=False):\n\n        \"\"\"\n        Search external databases linked to your lcopt model.\n\n        To restrict the search to particular databases (e.g. technosphere or biosphere only) use a list of database names in the ``database_to_search`` variable\n        \"\"\"\n\n        dict_list = []\n\n        if allow_internal:\n            internal_dict = {}\n            for k, v in self.database['items'].items():\n                if v.get('lcopt_type') == 'intermediate':\n                    internal_dict[k] = v\n            \n            dict_list.append(internal_dict)\n\n        if databases_to_search is None:\n            #Search all of the databases available\n            #data = Dictionaries(self.database['items'], *[x['items'] for x in self.external_databases])\n            dict_list += [x['items'] for x in self.external_databases]\n        else:\n            #data = Dictionaries(self.database['items'], *[x['items'] for x in self.external_databases if x['name'] in databases_to_search])\n            dict_list += [x['items'] for x in self.external_databases if x['name'] in databases_to_search]\n\n        data = Dictionaries(*dict_list)\n        #data = Dictionaries(self.database['items'], *[x['items'] for x in self.external_databases if x['name'] in databases_to_search])\n\n        query = Query()\n\n        if markets_only:\n            market_filter = Filter(\"name\", \"has\", \"market for\")\n            query.add(market_filter)\n        \n        if location is not None:\n            location_filter = Filter(\"location\", \"is\", location)\n            query.add(location_filter)\n        \n        query.add(Filter(\"name\", \"ihas\", search_term))\n        \n        result = query(data)\n        \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexport the database as a SimaPro csv file.", "response": "def database_to_SimaPro_csv(self):\n\n        \"\"\"\n        Export the lcopt model as a SimaPro csv file.\n\n        The file will be called \"<ModelName>_database_export.csv\"\n        \"\"\"\n        self.parameter_scan()\n\n        csv_args = {}\n        csv_args['processes'] = []\n        db = self.database['items']\n        \n        product_filter = lambda x: db[x]['type'] == 'product'\n        process_filter = lambda x: db[x]['type'] == 'process'\n\n        processes = list(filter(process_filter, db))\n        products = list(filter(product_filter, db))\n\n        created_exchanges = []\n\n        project_input_params = []\n        project_calc_params = []\n\n        for k in processes:\n            item = db[k]\n\n            current = {}\n            current['name'] = item['name']\n            current['id'] = (self.name.replace(\" \", \"\") + \"XXXXXXXX\")[:8] + ('00000000000' + str(randint(1, 99999999999)))[-11:]\n            current['unit'] = item['unit']\n            current['exchanges'] = []\n            \n            process_params = []\n            \n            production_filter = lambda x: x['type'] == 'production'\n            \n            output_code = list(filter(production_filter, item['exchanges']))[0]['input'][1]\n            \n            for e in item['exchanges']:\n\n                if e['type'] == 'technosphere':\n                    this_exchange = {}\n\n                    this_code = e['input'][1]\n\n                    formatted_name = self.get_name(this_code)\n                    this_exchange['formatted_name'] = formatted_name\n                    \n                    param_key = (this_code,  output_code)\n                    #print(param_key)\n                    #param_check = (formatted_name, item['name'])\n                    this_param = self.parameter_map[param_key]\n                    \n                    process_params.append(this_param)\n                   \n                    this_exchange['amount'] = this_param \n\n                    this_exchange['unit'] = self.get_unit(this_code)\n\n                    current['exchanges'].append(this_exchange)\n\n                elif e['type'] == 'production':\n                    this_code = e['input'][1]\n                    name = self.get_name(this_code)\n                    current['output_name'] = name\n\n                    created_exchanges.append(name)\n                    \n                # process parameters\n                \n            for p in process_params:\n                if self.params[p]['function'] is None:\n                    project_input_params.append({'name': p, 'comment': self.params[p]['description']})\n                else:\n                    project_calc_params.append({'name': p, 'comment': self.params[p]['description'], 'formula': self.params[p]['function']})\n\n            csv_args['processes'].append(current)\n            \n        for k in products:\n            this_item = db[k]\n            this_name = this_item['name']\n            \n            if this_item['name'] in created_exchanges:\n                #print ('{} already created'.format(this_name))\n                pass\n            else:\n                #print ('Need to create {}'.format(this_name))\n                \n                current = {}\n                current['name'] = this_name\n                current['output_name'] = this_name\n                current['id'] = (self.name.replace(\" \", \"\") + \"XXXXXXXX\")[:8] + ('00000000000' + str(randint(1, 99999999999)))[-11:]\n                current['unit'] = this_item['unit']\n                #current['exchanges'] = []\n                \n                if 'ext_link' in this_item.keys():\n                    \n                    ext_link = this_item['ext_link']\n                    if ext_link[0] != self.database['name']:\n                        db_filter = lambda x: x['name'] == ext_link[0]\n                        extdb = list(filter(db_filter, self.external_databases))[0]['items']\n\n                        ext_item = extdb[ext_link]\n                        if ext_link[0] != self.biosphereName:\n                            ref_prod = ext_item['reference product']\n                            name = ext_item['name'].replace(\" \" + ref_prod, \"\")\n                            location = ext_item['location']\n                            system_model = \"Alloc Def\"\n                            process_type = \"U\"\n                            unit = unnormalise_unit(ext_item['unit'])\n\n                            simaPro_name = \"{} {{{}}}| {} | {}, {}\".format(ref_prod.capitalize(), location, name, system_model, process_type)\n\n                            #print ('{} has an external link to {}'.format(this_name, simaPro_name))\n                            \n                            current['exchanges'] = [{'formatted_name': simaPro_name, 'unit': unit, 'amount': 1}]\n                        else:\n                            #print('{} has a biosphere exchange - need to sort this out'.format(this_name))\n                            #print(ext_item)\n                            unit = unnormalise_unit(ext_item['unit'])\n                            formatted_name = ext_item['name']\n\n                            if 'air' in ext_item['categories']:\n                                current['air_emissions'] = [{'formatted_name': formatted_name, 'subcompartment': '', 'unit': unit, 'amount': 1, 'comment': 'emission of {} to air'.format(formatted_name)}]\n\n                            elif 'water' in ext_item['categories']:\n                                current['water_emissions'] = [{'formatted_name': formatted_name, 'subcompartment': '', 'unit': unit, 'amount': 1, 'comment': 'emission of {} to water'.format(formatted_name)}]\n\n                            elif 'soil' in ext_item['categories']:\n                                current['soil_emissions'] = [{'formatted_name': formatted_name, 'subcompartment': '', 'unit': unit, 'amount': 1, 'comment': 'emission of {} to soil'.format(formatted_name)}]\n\n                            else:\n                                print('{} has a biosphere exchange that isnt to air water or soil')\n                                print(ext_item)\n                        \n                    else:\n                        warnings.warn('{} has NO internal or external link - it is burden free'.format(this_name))\n                    \n                csv_args['processes'].append(current)\n                created_exchanges.append(this_name)\n            \n        #print(csv_args)\n        #print(created_exchanges)\n        \n        csv_args['project'] = {}\n        \n        #NOTE - currently external parameters can only be constants\n\n        csv_args['project']['calculated_parameters'] = project_calc_params\n        \n        #add the external parameters to the input parameter list        \n        for p in self.ext_params:\n            project_input_params.append({'name': p['name'], 'comment': p['description'], 'default': p['default']})\n        \n        csv_args['project']['input_parameters'] = project_input_params\n\n        #print (csv_args)\n\n        env = Environment(\n            loader=PackageLoader('lcopt', 'templates'),\n        )\n\n        filename = \"{}_database_export.csv\".format(self.name.replace(\" \", \"_\"))\n\n        csv_template = env.get_template('export.csv')\n        \n        output = csv_template.render(**csv_args)\n\n        if self.save_option == 'curdir':\n            base_dir = os.getcwd()\n        else:\n            base_dir = os.path.join(storage.simapro_dir, self.name.replace(\" \", \"_\"))\n\n        if not os.path.isdir(base_dir):\n            os.mkdir(base_dir)\n\n        efn = os.path.join(base_dir, filename)\n\n        with open(efn, \"w\") as f:\n            f.write(output)\n        \n        return efn"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexport the lcopt model in the native brightway 2 format returns name database and Bw2Database object", "response": "def export_to_bw2(self):\n        \"\"\"\n        Export the lcopt model in the native brightway 2 format\n\n        returns name, database\n\n        to use it to export, then import to brightway::\n\n            name, db = model.export_to_bw2()\n            import brightway2 as bw\n            bw.projects.set_current('MyProject')\n            new_db = bw.Database(name)\n            new_db.write(db)\n            new_db.process()\n\n        \"\"\"\n        my_exporter = Bw2Exporter(self)\n        name, bw2db = my_exporter.export_to_bw2()\n        return name, bw2db"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef analyse(self, demand_item, demand_item_code):\n        my_analysis = Bw2Analysis(self)\n        self.result_set = my_analysis.run_analyses(demand_item, demand_item_code, **self.analysis_settings)\n\n        return True", "response": "Run the analyis of the model\n            Doesn t return anything but creates a new item"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows resolve information about specified service.", "response": "def locate(name, **kwargs):\n    \"\"\"\n    Show resolve information about specified service.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('locate', **{\n        'name': name,\n        'locator': ctx.locator,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshow information about the requested routing group.", "response": "def routing(name, **kwargs):\n    \"\"\"\n    Show information about the requested routing group.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('routing', **{\n        'name': name,\n        'locator': ctx.locator,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef info(name, m, p, b, w, **kwargs):\n    m = (m << 1) & 0b010\n    p = (p << 2) & 0b100\n\n    # Brief disables all further flags.\n    if b:\n        flags = 0b000\n    else:\n        flags = m | p | 0b001\n\n    ctx = Context(**kwargs)\n    ctx.execute_action('info', **{\n        'node': ctx.repo.create_secure_service('node'),\n        'locator': ctx.locator,\n        'name': name,\n        'flags': flags,\n        'use_wildcard': w,\n        'timeout': ctx.timeout,\n    })", "response": "Show information about the cocaine - runtime."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noutputting runtime metrics collected from cocaine-runtime and its services. This command shows runtime metrics collected from cocaine-runtime and its services during their lifetime. There are four kind of metrics available: gauges, counters, meters and timers. \\b - Gauges - an instantaneous measurement of a value. - Counters - just a gauge for an atomic integer instance. - Meters - measures the rate of events over time (e.g., \"requests per second\"). In addition to the mean rate, meters also track 1-, 5-, and 15-minute moving averages. - Timers - measures both the rate that a particular piece of code is called and the distribution of its duration. Every metric in has a unique name, which is just a dotted-name string like \"connections.count\" or \"node.queue.size\". An output type can be configured using --type option. The default one results in plain formatting where there is only one depth level. As an alternative you can expanded the JSON tree by specifying --type=json option. The depth of the result tree depends on metric name which is split by dot symbol. The result output will be probably too large without any customization. To reduce this output there are custom filters, which can be specified using --query option. Technically it's a special metrics query language (MQL) which supports the following operations and functions: \\b - contains(<expr>, <expr>) - checks whether the result of second expression contains in the result of first expression. These expressions must resolve in strings. An output type of this function is bool. - name() - resolves in metric name. - type() - resolves in metric type (counter, meter, etc.). - tag(<expr>) - extracts custom metric tag and results in string. - && - combines several expressions in one, which applies when all of them apply. - || - combines several expressions in one, which applies when any of them apply. - == - compares two expressions for equality. - != - compares two expressions for an non-equality. - Also string literals (alphanumeric with dots) can be used as an expressions, for example \"name() == locator.connections.accepted\". Priorities can be specified using braces as in usual math expressions. The grammar for this query language is: \\b expr ::= term ((AND | OR) term)* term ::= factor ((EQ | NE) factor)* factor ::= func | literal | number | LPAREN expr RPAREN func ::= literal LPAREN expr (,expr)* RPAREN literal ::= alphanum | . number ::= <floating point number> An example of the query, which returns all meters (for all services) and the number of accepted connections for the Locator service: \"contains(type(), meter) || name() == locator.connections.accepted\".", "response": "def metrics(ty, query, query_type, **kwargs):\n    \"\"\"\n    Outputs runtime metrics collected from cocaine-runtime and its services.\n\n    This command shows runtime metrics collected from cocaine-runtime and its services during their\n    lifetime.\n    There are four kind of metrics available: gauges, counters, meters and timers.\n\n    \\b\n    - Gauges   - an instantaneous measurement of a value.\n    - Counters - just a gauge for an atomic integer instance.\n    - Meters   - measures the rate of events over time (e.g., \"requests per second\"). In addition\n      to the mean rate, meters also track 1-, 5-, and 15-minute moving averages.\n    - Timers   - measures both the rate that a particular piece of code is called and the\n      distribution of its duration.\n\n\n    Every metric in has a unique name, which is just a dotted-name string like \"connections.count\"\n    or \"node.queue.size\".\n\n    An output type can be configured using --type option. The default one results in plain\n    formatting where there is only one depth level.\n\n    As an alternative you can expanded the JSON tree by specifying --type=json option. The depth of\n    the result tree depends on metric name which is split by dot symbol.\n\n    The result output will be probably too large without any customization. To reduce this output\n    there are custom filters, which can be specified using --query option. Technically it's a\n    special metrics query language (MQL) which supports the following operations and functions:\n\n    \\b\n    - contains(<expr>, <expr>) - checks whether the result of second expression contains in the\n      result of first expression. These expressions must resolve in strings. An output type of this\n      function is bool.\n    - name() - resolves in metric name.\n    - type() - resolves in metric type (counter, meter, etc.).\n    - tag(<expr>) - extracts custom metric tag and results in string.\n    - && - combines several expressions in one, which applies when all of them apply.\n    - || - combines several expressions in one, which applies when any of them apply.\n    - == - compares two expressions for equality.\n    - != - compares two expressions for an non-equality.\n    - Also string literals (alphanumeric with dots) can be used as an expressions, for\n      example \"name() == locator.connections.accepted\".\n\n    Priorities can be specified using braces as in usual math expressions.\n\n    The grammar for this query language is:\n\n    \\b\n    expr    ::= term ((AND | OR) term)*\n    term    ::= factor ((EQ | NE) factor)*\n    factor  ::= func | literal | number | LPAREN expr RPAREN\n    func    ::= literal LPAREN expr (,expr)* RPAREN\n    literal ::= alphanum | .\n    number  ::= <floating point number>\n\n    An example of the query, which returns all meters (for all services) and the number of accepted\n    connections for the Locator\n    service: \"contains(type(), meter) || name() == locator.connections.accepted\".\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('metrics', **{\n        'metrics': ctx.repo.create_secure_service('metrics'),\n        'ty': ty,\n        'query': query,\n        'query_type': query_type,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow manifest content for an application.", "response": "def app_view(name, **kwargs):\n    \"\"\"\n    Show manifest content for an application.\n\n    If application is not uploaded, an error will be displayed.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('app:view', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef app_upload(path, name, manifest, package, docker_address, registry, manifest_only, **kwargs):\n    lower_limit = 120.0\n\n    ctx = Context(**kwargs)\n    if ctx.timeout < lower_limit:\n        ctx.timeout = lower_limit\n        log.info('shifted timeout to the %.2fs', ctx.timeout)\n\n    mutex_record = collections.namedtuple('mutex_record', 'value, name')\n    mutex = [\n        (mutex_record(path, 'PATH'), mutex_record(package, '--package')),\n        (mutex_record(package, '--package'), mutex_record(docker_address, '--docker')),\n        (mutex_record(package, '--package'), mutex_record(registry, '--registry')),\n    ]\n    for (f, s) in mutex:\n        if f.value and s.value:\n            click.echo('Wrong usage: option {} and {} are mutual exclusive, you can only use one'.\n                       format(f.name, s.name))\n            exit(os.EX_USAGE)\n\n    if manifest_only:\n        ctx.execute_action('app:upload-manual', **{\n            'storage': ctx.repo.create_secure_service('storage'),\n            'name': name,\n            'manifest': manifest,\n            'package': None,\n            'manifest_only': manifest_only,\n        })\n    elif package:\n        ctx.execute_action('app:upload-manual', **{\n            'storage': ctx.repo.create_secure_service('storage'),\n            'name': name,\n            'manifest': manifest,\n            'package': package\n        })\n    elif docker_address:\n        ctx.execute_action('app:upload-docker', **{\n            'storage': ctx.repo.create_secure_service('storage'),\n            'path': path,\n            'name': name,\n            'manifest': manifest,\n            'address': docker_address,\n            'registry': registry\n        })\n    else:\n        ctx.execute_action('app:upload', **{\n            'storage': ctx.repo.create_secure_service('storage'),\n            'path': path,\n            'name': name,\n            'manifest': manifest\n        })", "response": "Upload an application into the storage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport application Docker container.", "response": "def app_import(path, name, manifest, container_url, docker_address, registry, **kwargs):\n    \"\"\"\n    Import application Docker container.\n    \"\"\"\n    lower_limit = 120.0\n\n    ctx = Context(**kwargs)\n    if ctx.timeout < lower_limit:\n        ctx.timeout = lower_limit\n        log.info('shifted timeout to the %.2fs', ctx.timeout)\n\n    if container_url and docker_address:\n        ctx.execute_action('app:import-docker', **{\n            'storage': ctx.repo.create_secure_service('storage'),\n            'path': path,\n            'name': name,\n            'manifest': manifest,\n            'container': container_url,\n            'address': docker_address,\n            'registry': registry\n        })\n    else:\n        raise ValueError(\"both `container_url` and `docker_address` options must not be empty\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves application from storage.", "response": "def app_remove(name, **kwargs):\n    \"\"\"\n    Remove application from storage.\n\n    No error messages will display if specified application is not uploaded.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('app:remove', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart an application with specified profile.", "response": "def app_start(name, profile, **kwargs):\n    \"\"\"\n    Start an application with specified profile.\n\n    Does nothing if application is already running.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('app:start', **{\n        'node': ctx.repo.create_secure_service('node'),\n        'name': name,\n        'profile': profile\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstop application. This command is alias for ```cocaine-tool app stop```.", "response": "def app_pause(name, **kwargs):\n    \"\"\"\n    Stop application.\n\n    This command is alias for ```cocaine-tool app stop```.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('app:stop', **{\n        'node': ctx.repo.create_secure_service('node'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef app_restart(name, profile, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('app:restart', **{\n        'node': ctx.repo.create_secure_service('node'),\n        'locator': ctx.locator,\n        'name': name,\n        'profile': profile,\n    })", "response": "Restart application.\n\n    Executes ```cocaine-tool app pause``` and ```cocaine-tool app start``` sequentially.\n\n    It can be used to quickly change application profile."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef profile_view(name, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('profile:view', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })", "response": "Show profile configuration content."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a profile from the storage.", "response": "def profile_remove(name, **kwargs):\n    \"\"\"\n    Remove profile from the storage.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('profile:remove', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing configuration content for a specified runlist.", "response": "def runlist_view(name, **kwargs):\n    \"\"\"\n    Show configuration content for a specified runlist.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('runlist:view', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef runlist_upload(name, runlist, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('runlist:upload', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'runlist': runlist,\n    })", "response": "Upload a runlist into the storage."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef runlist_create(name, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('runlist:create', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })", "response": "Create runlist and upload it into the storage."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves runlist from the storage.", "response": "def runlist_remove(name, **kwargs):\n    \"\"\"\n    Remove runlist from the storage.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('runlist:remove', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding specified application with profile to the specified runlist.", "response": "def runlist_add_app(name, app, profile, force, **kwargs):\n    \"\"\"\n    Add specified application with profile to the specified runlist.\n\n    Existence of application or profile is not checked.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('runlist:add-app', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'app': app,\n        'profile': profile,\n        'force': force\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing crashlogs list for application.", "response": "def crashlog_list(name, day, **kwargs):\n    \"\"\"\n    Show crashlogs list for application.\n\n    Prints crashlog list in \"Unix Timestamp - UUID\" format.\n\n    Filtering by day accepts the following variants: today, yesterday, %d, %d-%m or %d-%m-%Y.\n    For example given today is a 06-12-2016 crashlogs for yesterday can be listed using:\n    `--day=yesterday`, `--day=5`, `--day=05-12` or `--day=05-12-2016`.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('crashlog:list', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'day_string': day,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef crashlog_view(name, timestamp, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('crashlog:view', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'timestamp': timestamp,\n    })", "response": "Show crashlog for a given application with specified timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef crashlog_removeall(name, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('crashlog:removeall', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })", "response": "Remove all crashlogs for application from the storage."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef crashlog_clean(name, timestamp, size, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('crashlog:clean', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'size': size,\n        'timestamp': timestamp,\n    })", "response": "Remove crashlogs with timestamp > TIMESTAMP."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef crashlog_cleanrange(from_day, up_to_day, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('crashlog:cleanwhen', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'from_day': from_day,\n        'to_day': up_to_day,\n    })", "response": "Remove all crashlogs from one date up to another."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshow available routing groups.", "response": "def group_list(**kwargs):\n    \"\"\"\n    Show available routing groups.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('group:list', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef group_view(name, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('group:view', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })", "response": "Show specified routing group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef group_create(name, content, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('group:create', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'content': content,\n    })", "response": "Create routing group.\n\n    You can optionally specify content for created routing group. It can be either direct JSON\n    expression in single quotes, or path to the json file with settings. Settings itself must be\n    key-value list, where `key` represents application name, and `value` represents its weight.\n\n    For example:\n\n    cocaine-tool group create -n new_group -c '{\n        \"app\": 1,\n        \"another_app\": 2\n    }'.\n\n    Warning: all application weights must be positive integers, total weight must be positive."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving routing group from the storage.", "response": "def group_remove(name, **kwargs):\n    \"\"\"\n    Remove routing group from the storage.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('group:remove', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrefreshing routing group. If the name option is empty, this command will refresh all groups.", "response": "def group_refresh(name, **kwargs):\n    \"\"\"\n    Refresh routing group.\n\n    If the name option is empty, this command will refresh all groups.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('group:refresh', **{\n        'locator': ctx.locator,\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npushing application with its weight into routing group.", "response": "def group_push(name, app, weight, **kwargs):\n    \"\"\"\n    Add application with its weight into the routing group.\n\n    Warning: application weight must be positive integer.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('group:app:add', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'app': app,\n        'weight': weight,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef group_pop(name, app, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('group:app:remove', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'app': app,\n    })", "response": "Removes application from a routing group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unicorn_edit(path, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.timeout = None\n    ctx.execute_action('unicorn:edit', **{\n        'unicorn': ctx.repo.create_secure_service('unicorn'),\n        'path': path,\n    })", "response": "Edit Unicorn node interactively."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshow information about the current Vicodyn application.", "response": "def vicodyn_info(**kwargs):\n    \"\"\"Vicodyn info\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.timeout = None\n    ctx.execute_action('vicodyn:info', **{\n        'vicodyn': ctx.repo.create_secure_service('vicodyn'),\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logging_list_loggers(**kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('logging:list_loggers', **{\n        'logging_service': ctx.repo.create_secure_service('logging'),\n    })", "response": "List all registered loggers."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves filter by filter id.", "response": "def logging_remove_filter(filter_id, **kwargs):\n    \"\"\"\n    Remove filter by filter id.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('logging:remove_filter', **{\n        'logging_service': ctx.repo.create_secure_service('logging'),\n        'filter_id': filter_id,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logging_list_filters(**kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('logging:list_filters', **{\n        'logging_service': ctx.repo.create_secure_service('logging'),\n    })", "response": "Lists all available filters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow available authorization groups.", "response": "def auth_list(**kwargs):\n    \"\"\"\n    Shows available authorization groups.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('auth:group:list', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef auth_create(name, token, force, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('auth:group:create', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'token': token,\n        'force': force,\n    })", "response": "Creates an authorization group."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nedit an authorization group.", "response": "def auth_edit(name, **kwargs):\n    \"\"\"\n    Interactively edits an authorization group.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.timeout = None\n    ctx.execute_action('auth:group:edit', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef auth_remove(name, drop, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('auth:group:remove', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'drop': drop,\n    })", "response": "Removes an authorization group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef auth_view(name, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('auth:group:view', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })", "response": "Shows an authorization group s content."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a member of an authorization group.", "response": "def auth_add(name, service, **kwargs):\n    \"\"\"\n    Adds a member of an authorization group.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('auth:group:members:add', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'service': service,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef access_grant(tp, name, cid, uid, perm, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:edit:grant', **{\n        'unicat': ctx.repo.create_secure_service('unicat'),\n        'tp': tp,\n        'name': name,\n        'cids': cid,\n        'uids': uid,\n        'perm': perm,\n    })", "response": "Grant access to a specific entity."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nshow collections with ACL. Shows collections with ACL.", "response": "def access_storage_list(**kwargs):\n    \"\"\"\n    Shows collections with ACL.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:storage:list', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows ACL for the specified collection.", "response": "def access_storage_view(name, **kwargs):\n    \"\"\"\n    Shows ACL for the specified collection.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:storage:view', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef access_storage_create(name, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:storage:create', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })", "response": "Creates new ACL for the specified collection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nediting ACL for the specified collection.", "response": "def access_storage_edit(name, cid, uid, perm, **kwargs):\n    \"\"\"\n    Edits ACL for the specified collection.\n\n    Creates if necessary.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:storage:edit', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n        'cids': cid,\n        'uids': uid,\n        'perm': perm,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef access_storage_rm(name, yes, **kwargs):\n    if name is None:\n        if not yes:\n            click.confirm('Are you sure you want to remove all ACL?', abort=True)\n\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:storage:rm', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n        'name': name,\n    })", "response": "Removes ACL for the specified collection."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef access_list(**kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:list', **{\n        'unicorn': ctx.repo.create_secure_service('unicorn'),\n    })", "response": "Shows services for which there are ACL specified."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows ACL for the specified service.", "response": "def access_view(name, **kwargs):\n    \"\"\"\n    Shows ACL for the specified service.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:view', **{\n        'unicorn': ctx.repo.create_secure_service('unicorn'),\n        'service': name,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef access_add(name, event, cid, uid, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('access:add', **{\n        'unicorn': ctx.repo.create_secure_service('unicorn'),\n        'service': name,\n        'event': event,\n        'cids': cid,\n        'uids': uid,\n    })", "response": "Add a record to the specified event authorization."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef keyring_view(**kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('keyring:view', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n    })", "response": "View saved public keys."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef keyring_update(cid, **kwargs):\n    ctx = Context(**kwargs)\n    ctx.execute_action('keyring:update', **{\n        'tvm': ctx.repo.create_secure_service('tvm'),\n        'cid': cid,\n    })", "response": "Updates the public key for a given client id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef keyring_remove(key, yes, **kwargs):\n    if key is None:\n        if not yes:\n            click.confirm('Are you sure you want to remove all keys?', abort=True)\n\n    ctx = Context(**kwargs)\n    ctx.execute_action('keyring:remove', **{\n        'key': key,\n        'storage': ctx.repo.create_secure_service('storage'),\n    })", "response": "Removes a public key from the keyring."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nedit interactively the keyring.", "response": "def keyring_edit(**kwargs):\n    \"\"\"\n    Edits interactively the keyring.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.timeout = None\n    ctx.execute_action('keyring:edit', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrefreshes the keyring in the cocaine - runtime.", "response": "def keyring_refresh(**kwargs):\n    \"\"\"\n    Refresh the keyring in the cocaine-runtime.\n    \"\"\"\n    ctx = Context(**kwargs)\n    ctx.execute_action('keyring:refresh', **{\n        'tvm': ctx.repo.create_secure_service('tvm'),\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsummarizing a person entity into a list of strings.", "response": "def summarize_entity_person(person):\n    \"\"\"\n        assume person entity using cnschma person vocabulary, http://cnschema.org/Person\n    \"\"\"\n    ret = []\n    value = person.get(\"name\")\n    if not value:\n        return False\n    ret.append(value)\n\n    prop = \"courtesyName\"\n    value = json_get_first_item(person, prop)\n    if value == u\"\u4e0d\u8be6\":\n        value = \"\"\n    if value:\n        ret.append(u'\u5b57{}'.format(value))\n\n    value = person.get(\"alternateName\")\n    if value:\n        #ret.append(u'\u522b\u540d{}'.format(value))\n        # Bugged\n        pass\n\n    prop = \"artName\"\n    value = json_get_first_item(person, prop)\n    if value:\n        ret.append(u'\u53f7{}'.format(value))\n\n    value = person.get(\"dynasty\")\n    if value:\n        ret.append(u'{}\u4eba'.format(value))\n\n    prop = \"ancestralHome\"\n    value = json_get_first_item(person, prop)\n    if value:\n        ret.append(u'\u7956\u7c4d{}'.format(value))\n\n    birth_date = person.get(\"birthDate\", \"\")\n    birth_place = person.get(\"birthPlace\", \"\")\n\n    # Special case for unknown birth date\n    if birth_date == u\"\u4e0d\u8be6\":\n        birth_date = \"\"\n\n    if birth_place:\n        ret.append(u'{}\u51fa\u751f\u4e8e{}'.format(birth_date, birth_place))\n    elif birth_date:\n        ret.append(u'{}\u51fa\u751f'.format(birth_date))\n\n    prop = \"nationality\"\n    nationality = json_get_first_item(person, prop)\n    prop = \"occupation\"\n    occupation = json_get_first_item(person, prop)\n    if occupation:\n        if nationality:\n            ret.append(u'{}{}'.format(nationality, occupation))\n        else:\n            ret.append(u'{}'.format(occupation))\n    elif nationality:\n        ret.append(u'{}\u4eba'.format(nationality))\n\n    prop = \"authorOf\"\n    value = json_get_list(person, prop)\n    if value:\n        logging.info(value)\n        value = u\"\u3001\".join(value)\n        ret.append(u'\u4e3b\u8981\u4f5c\u54c1\uff1a{}'.format(value) )\n\n    prop = \"accomplishment\"\n    value = json_get_list(person, prop)\n    if value:\n        value = u\"\u3001\".join(value)\n        if len(value) < 30:\n            # Colon is handled by text reading software\n            ret.append( u\"\u4e3b\u8981\u6210\u5c31\uff1a{}\".format(value) )\n\n    ret = u\"\uff0c\".join(ret)\n\n    # Make all commas Chinese\n    ret = ret.replace(u',', u'\uff0c')\n    ret = re.sub(u\"\uff0c+\", u\"\uff0c\", ret) # Removes repeat commas\n    # Handles periods at end\n    ret = re.sub(ur\"[\u3002\uff0c]+$\", u\"\", ret)\n\n    # Converts brackets to Chinese\n    ret = ret.replace(u'(', u'\uff08')\n    ret = ret.replace(u')', u'\uff09')\n    # Removes brackets and all contained info\n    ret = re.sub(ur\"\uff08[^\uff09]*\uff09\", u\"\", ret)\n\n    ret = u''.join([ret, u\"\u3002\"])\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef evaluate_parameter_sets(self):\n        #parameter_interpreter = ParameterInterpreter(self.modelInstance)\n        #parameter_interpreter.evaluate_parameter_sets()\n\n        self.parameter_interpreter = LcoptParameterSet(self.modelInstance)\n        self.modelInstance.evaluated_parameter_sets = self.parameter_interpreter.evaluated_parameter_sets\n        self.modelInstance.bw2_export_params = self.parameter_interpreter.bw2_export_params", "response": "This function takes the parameter sets of the model instance and evaluates any formulas using the parameter values for each parameter set in the model instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a parameter map which takes a tuple of the from and to codes and returns the parameter name for that exchange", "response": "def create_parameter_map(self):\n        \"\"\"\n        Creates a parameter map which takes a tuple of the exchange 'from' and exchange 'to' codes \n        and returns the parameter name for that exchange\n        \"\"\"\n        names = self.modelInstance.names\n        db = self.modelInstance.database['items']\n        parameter_map = {}\n        \n        def get_names_index(my_thing):\n            return[i for i, x in enumerate(names) if x == my_thing][0]\n        \n        for k, this_item in db.items():\n            if this_item['type'] == 'process':\n                production_id = [x['input'] for x in this_item['exchanges'] if x['type'] == 'production'][0]\n                input_ids = [x['input'] for x in this_item['exchanges'] if x['type'] == 'technosphere']\n                production_index = get_names_index(db[production_id]['name'])\n                input_indexes = [get_names_index(db[x]['name']) for x in input_ids]\n                parameter_ids = ['n_p_{}_{}'.format(x, production_index) for x in input_indexes]\n                parameter_map_items = {(input_ids[n], k): parameter_ids[n] for n, x in enumerate(input_ids)}\n                #check = [self.modelInstance.params[x]['description'] for x in parameter_ids]\n                #print(check)\n                #print(parameter_map_items)\n                parameter_map.update(parameter_map_items)\n                \n        self.parameter_map = parameter_map"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_config(override=None):\n\n    # Set location\n    config_path = os.path.expanduser('~') + '/.dbschema.yml'\n    if override:\n        config_path = override\n\n    # Check if the config file exists\n    check_exists(config_path)\n\n    # Load config\n    with open(config_path) as f:\n        # use safe_load instead load\n        config = yaml.safe_load(f)\n\n    return config", "response": "Get the config file"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if a file or a folder exists.", "response": "def check_exists(path, type='file'):\n    \"\"\" Check if a file or a folder exists \"\"\"\n\n    if type == 'file':\n        if not os.path.isfile(path):\n            raise RuntimeError('The file `%s` does not exist.' % path)\n    else:\n        if not os.path.isdir(path):\n            raise RuntimeError('The folder `%s` does not exist.' % path)\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a PostgreSQL or MySQL connection", "response": "def get_connection(engine, host, user, port, password, database, ssl={}):\n    \"\"\" Returns a PostgreSQL or MySQL connection \"\"\"\n\n    if engine == 'mysql':\n        # Connection\n        return get_mysql_connection(host, user, port, password, database, ssl)\n    elif engine == 'postgresql':\n        # Connection\n        return get_pg_connection(host, user, port, password, database, ssl)\n    else:\n        raise RuntimeError('`%s` is not a valid engine.' % engine)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_mysql_connection(host, user, port, password, database, ssl={}):\n\n    return pymysql.connect(host=host,\n                           user=user,\n                           port=port,\n                           password=password,\n                           db=database,\n                           charset='utf8mb4',\n                           cursorclass=pymysql.cursors.DictCursor,\n                           client_flag=pymysql.constants.CLIENT.MULTI_STATEMENTS,\n                           ssl=ssl\n                           )", "response": "Get a MySQL connection."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a PostgreSQL connection.", "response": "def get_pg_connection(host, user, port, password, database, ssl={}):\n    \"\"\" PostgreSQL connection \"\"\"\n\n    return psycopg2.connect(host=host,\n                            user=user,\n                            port=port,\n                            password=password,\n                            dbname=database,\n                            sslmode=ssl.get('sslmode', None),\n                            sslcert=ssl.get('sslcert', None),\n                            sslkey=ssl.get('sslkey', None),\n                            sslrootcert=ssl.get('sslrootcert', None),\n                            )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse input and return a list of SQL statements.", "response": "def parse_statements(queries_input, engine):\n    \"\"\" Parse input and return a list of SQL statements \"\"\"\n\n    queries = []\n    query = ''\n    sql_delimiter = ';'\n\n    # Possible delimiters used in PostgreSQL functions\n    postgres_func_delimiters = ['$$', '##']\n\n    # Split input by lines\n    lines = queries_input.strip().split('\\n')\n\n    for k, line in enumerate(lines):\n        # Strip line\n        line = line.strip()\n\n        # Skip empty lines and comments\n        if not line or line.startswith('--'):\n            continue\n\n        # Detect new SQL delimiter\n        if engine == 'mysql' and line.upper().startswith('DELIMITER '):\n            sql_delimiter = line.split()[1]\n            continue\n        elif engine == 'postgresql' and [delimiter for delimiter in postgres_func_delimiters if 'AS ' + delimiter in line.upper()]:\n            sql_delimiter = line.split()[-1]\n\n            # Ensure that we leave 'AS [DELIMITER]'\n            query += line + '\\n'\n\n            continue\n\n        # Statement is not finished\n        if sql_delimiter not in line and k != len(lines) - 1:\n            # Append line\n            query += line + '\\n'\n        else:  # Statement is finished\n            # Replace non default delimiter\n            if sql_delimiter != ';' and engine == 'mysql' and line.endswith(sql_delimiter):\n                line = line.replace(sql_delimiter, ';')\n\n            queries.append(query + line)\n            query = ''\n\n    return queries"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying a migration to the SQL server", "response": "def run_migration(connection, queries, engine):\n    \"\"\" Apply a migration to the SQL server \"\"\"\n\n    # Execute query\n    with connection.cursor() as cursorMig:\n        # Parse statements\n        queries = parse_statements(queries, engine)\n\n        for query in queries:\n            cursorMig.execute(query)\n        connection.commit()\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_migration(connection, basename):\n\n    # Prepare query\n    sql = \"INSERT INTO migrations_applied (name, date) VALUES (%s, NOW())\"\n\n    # Run\n    with connection.cursor() as cursor:\n        cursor.execute(sql, (basename,))\n        connection.commit()\n\n    return True", "response": "Save a migration in migrations_applied table"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete a migration in migrations_applied table", "response": "def delete_migration(connection, basename):\n    \"\"\" Delete a migration in `migrations_applied` table \"\"\"\n\n    # Prepare query\n    sql = \"DELETE FROM migrations_applied WHERE name = %s\"\n\n    # Run\n    with connection.cursor() as cursor:\n        cursor.execute(sql, (basename,))\n        connection.commit()\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets list of migrations already applied", "response": "def get_migrations_applied(engine, connection):\n    \"\"\" Get list of migrations already applied \"\"\"\n\n    try:\n        # Get cursor based on engine\n        if engine == 'postgresql':\n            cursor = connection.cursor(\n                cursor_factory=psycopg2.extras.RealDictCursor)\n        else:\n            cursor = connection.cursor()\n\n        sql = \"SELECT id, name, date FROM migrations_applied\"\n        cursor.execute(sql)\n        rows = cursor.fetchall()\n        # print (rows);\n        return rows\n    except psycopg2.ProgrammingError:\n        raise RuntimeError(\n            'The table `migrations_applied` is missing. Please refer to the project documentation at https://github.com/gabfl/dbschema.')\n    except pymysql.err.ProgrammingError:\n        raise RuntimeError(\n            'The table `migrations_applied` is missing. Please refer to the project documentation at https://github.com/gabfl/dbschema.')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply_migrations(engine, connection, path):\n\n    # Get migrations applied\n    migrations_applied = get_migrations_applied(engine, connection)\n    # print(migrationsApplied)\n\n    # Get migrations folder\n    for file in get_migrations_files(path):\n        # Set vars\n        basename = os.path.basename(os.path.dirname(file))\n\n        # Skip migrations if they are already applied\n        if is_applied(migrations_applied, basename):\n            continue\n\n        # Get migration source\n        source = get_migration_source(file)\n        # print (source);\n\n        # Run migration\n        run_migration(connection, source, engine)\n\n        # Save migration\n        save_migration(connection, basename)\n\n        # Log\n        print('   -> Migration `%s` applied' % (basename))\n\n    # Log\n    print(' * Migrations applied')\n\n    return True", "response": "Apply all migrations in chronological order"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the SSL options for the selected engine", "response": "def get_ssl(database):\n    \"\"\" Returns SSL options for the selected engine \"\"\"\n\n    # Set available keys per engine\n    if database['engine'] == 'postgresql':\n        keys = ['sslmode', 'sslcert', 'sslkey',\n                'sslrootcert', 'sslcrl', 'sslcompression']\n    else:\n        keys = ['ssl_ca', 'ssl_capath', 'ssl_cert', 'ssl_key',\n                'ssl_cipher', 'ssl_check_hostname']\n\n    # Loop thru keys\n    ssl = {}\n    for key in keys:\n        value = database.get(key, None)\n        if value is not None:\n            ssl[key] = value\n\n    return ssl"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply migrations to the current database.", "response": "def apply(config_override=None, tag_override=None, rollback=None, skip_missing=None):\n    \"\"\" Look thru migrations and apply them \"\"\"\n\n    # Load config\n    config = get_config(config_override)\n    databases = config['databases']\n\n    # If we are rolling back, ensure that we have a database tag\n    if rollback and not tag_override:\n        raise RuntimeError(\n            'To rollback a migration you need to specify the database tag with `--tag`')\n\n    for tag in sorted(databases):\n        # If a tag is specified, skip other tags\n        if tag_override and tag_override != tag:\n            continue\n\n        # Set vars\n        engine = databases[tag].get('engine', 'mysql')\n        host = databases[tag].get('host', 'localhost')\n        port = databases[tag].get('port', 3306)\n        user = databases[tag]['user']\n        password = databases[tag]['password']\n        db = databases[tag]['db']\n        path = add_slash(databases[tag]['path'])\n        pre_migration = databases[tag].get('pre_migration', None)\n        post_migration = databases[tag].get('post_migration', None)\n\n        # Check if the migration path exists\n        if skip_missing:\n            try:\n                check_exists(path, 'dir')\n            except RuntimeError:\n                continue\n        else:\n            check_exists(path, 'dir')\n\n        # Get database connection\n        connection = get_connection(\n            engine, host, user, port, password, db, get_ssl(databases[tag]))\n\n        # Run pre migration queries\n        if pre_migration:\n            run_migration(connection, pre_migration, engine)\n\n        if rollback:\n            print(' * Rolling back %s (`%s` on %s)' % (tag, db, engine))\n\n            rollback_migration(engine, connection, path, rollback)\n        else:\n            print(' * Applying migrations for %s (`%s` on %s)' %\n                  (tag, db, engine))\n\n            apply_migrations(engine, connection, path)\n\n        # Run post migration queries\n        if post_migration:\n            run_migration(connection, post_migration, engine)\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve the user associated with a request using HTTP Basic Authentication.", "response": "def resolve(self, authorization: http.Header):\n        \"\"\"\n        Determine the user associated with a request, using HTTP Basic Authentication.\n        \"\"\"\n        if authorization is None:\n            return None\n\n        scheme, token = authorization.split()\n        if scheme.lower() != 'basic':\n            return None\n\n        username, password = base64.b64decode(token).decode('utf-8').split(':')\n        user = authenticate(username=username, password=password)\n\n        return user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolve(self, authorization: http.Header):\n        from django_apistar.authentication.models import Token\n\n        if authorization is None:\n            return None\n\n        scheme, token = authorization.split()\n        if scheme.lower() != 'bearer':\n            return None\n\n        try:\n            user = Token.objects.get(key=token).user\n        except Token.DoesNotExist:\n            return None\n\n        return user", "response": "Resolves the user associated with a request using Token Authentication."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert(self):\n        if not os.path.exists(os.path.dirname(self.file_generator.to_path)):\n            dirname = os.path.dirname(self.file_generator.to_path)\n            if dirname:\n                os.makedirs(dirname)\n\n        if os.path.isdir(self.file_generator.from_path):\n            self._many_to_many()\n        elif os.path.isfile(self.file_generator.from_path) or fileio.GenericFilePath.is_url(self.file_generator.from_path):\n            if self.file_generator.from_path_compression in (\"zip\", \"tar\", \"tar.gz\", \"tar.bz2\"):\n                self._many_to_many()\n            elif self.file_generator.from_path_compression in (\"gz\", \"bz2\"):\n                self._one_to_one()\n            elif not self.file_generator.from_path_compression:\n                self._one_to_one()\n        elif self.file_generator.from_path.isdigit():\n            self._one_to_one()\n        else:\n            raise TypeError('Unknown input file format: \"{}\"'.format(self.file_generator.from_path))", "response": "Convert file from MWTab format to JSON format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _many_to_many(self):\n        if not self.file_generator.to_path_compression:\n            self._to_dir(self.file_generator)\n        elif self.file_generator.to_path_compression == \"zip\":\n            self._to_zipfile(self.file_generator)\n        elif self.file_generator.to_path_compression in (\"tar\", \"tar.gz\", \"tar.bz2\"):\n            self._to_tarfile(self.file_generator)\n        elif self.file_generator.to_path_compression in (\"gz\", \"bz2\"):\n            raise TypeError('Many-to-one conversion, cannot convert \"{}\" into \"{}\"'.format(self.file_generator.from_path,\n                                                                                           self.file_generator.to_path))\n        else:\n            raise TypeError('Unknown output file format: \"{}\"'.format(self.file_generator.to_path))", "response": "Perform many - to - many files conversion."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming one - to - one file conversion.", "response": "def _one_to_one(self):\n        \"\"\"Perform one-to-one file conversion.\n        :return: None\n        :rtype: :py:obj:`None`\n        \"\"\"\n        if not self.file_generator.to_path_compression:\n            self._to_textfile(self.file_generator)\n        elif self.file_generator.to_path_compression == \"gz\":\n            self._to_gzipfile(self.file_generator)\n        elif self.file_generator.to_path_compression == \"bz2\":\n            self._to_bz2file(self.file_generator)\n        elif self.file_generator.to_path_compression in (\"tar\", \"tar.gz\", \"tar.bz2\", \"zip\"):\n            raise TypeError('One-to-many conversion, cannot convert \"{}\" into \"{}\"'.format(self.file_generator.from_path,\n                                                                                           self.file_generator.to_path))\n        else:\n            raise TypeError('Unknown format: \"{}\"'.format(self.file_generator.to_path))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _to_dir(self, file_generator):\n        for f in file_generator:\n            outpath = self._output_path(f.source, file_generator.to_format)\n\n            if not os.path.exists(os.path.dirname(outpath)):\n                os.makedirs(os.path.dirname(outpath))\n\n            with open(outpath, mode=\"w\") as outfile:\n                f.write(outfile, file_generator.to_format)", "response": "Convert files to directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _to_zipfile(self, file_generator):\n        with zipfile.ZipFile(file_generator.to_path, mode=\"w\", compression=zipfile.ZIP_DEFLATED) as outfile:\n            for f in file_generator:\n                outpath = self._output_path(f.source, file_generator.to_format, archive=True)\n                outfile.writestr(outpath, f.writestr(file_generator.to_format))", "response": "Convert files to zip archive."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _to_tarfile(self, file_generator):\n        if file_generator.to_path_compression == \"tar\":\n            tar_mode = \"w\"\n        elif file_generator.to_path_compression == \"tar.gz\":\n            tar_mode = \"w:gz\"\n        elif file_generator.to_path_compression == 'tar.bz2':\n            tar_mode = \"w:bz2\"\n        else:\n            tar_mode = \"w\"\n\n        with tarfile.open(file_generator.to_path, mode=tar_mode) as outfile:\n            for f in file_generator:\n                outpath = self._output_path(f.source, file_generator.to_format, archive=True)\n                info = tarfile.TarInfo(outpath)\n                data = f.writestr(file_generator.to_format).encode()\n                info.size = len(data)\n                outfile.addfile(tarinfo=info, fileobj=io.BytesIO(data))", "response": "Convert files to tar archive."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _to_bz2file(self, file_generator):\n        with bz2.BZ2File(file_generator.to_path, mode=\"wb\") as outfile:\n            for f in file_generator:\n                outfile.write(f.writestr(file_generator.to_format).encode())", "response": "Convert file to bz2 - compressed file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert file to gzip - compressed file.", "response": "def _to_gzipfile(self, file_generator):\n        \"\"\"Convert file to gzip-compressed file.\n        :return: None\n        :rtype: :py:obj:`None`\n        \"\"\"\n        with gzip.GzipFile(file_generator.to_path, mode=\"wb\") as outfile:\n            for f in file_generator:\n                outfile.write(f.writestr(file_generator.to_format).encode())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _to_textfile(self, file_generator):\n        to_path = file_generator.to_path \\\n            if file_generator.to_path.endswith(file_generator.file_extension[file_generator.to_format]) \\\n            else file_generator.to_path + file_generator.file_extension[file_generator.to_format]\n\n        with open(to_path, mode=\"w\") as outfile:\n            for f in file_generator:\n                outfile.write(f.writestr(file_generator.to_format))", "response": "Convert file to regular text file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _output_path(self, input_path, to_format, archive=False):\n        indirpath, fname = os.path.split(os.path.abspath(os.path.normpath(input_path)))\n\n        commonprefix = os.path.commonprefix([os.path.abspath(self.file_generator.from_path),\n                                             os.path.abspath(indirpath)])\n\n        commonparts = commonprefix.split(os.sep)\n        inparts = indirpath.split(os.sep)\n        outparts = inparts[len(commonparts):]\n\n        if archive:\n            outdirpath = os.path.join(*outparts) if outparts else \"\"\n        else:\n            outdirpath = os.path.join(self.file_generator.to_path, *outparts)\n\n        return os.path.join(outdirpath, fname + self.file_generator.file_extension[to_format])", "response": "Construct an output path string from an input path string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef priority_compare(self, other):\n        pc = cmp(self.simplified, other.simplified)\n        if pc is 0:\n            if self.is_registered != other.is_registered:\n                # registered < unregistered\n                pc = -1 if self.is_registered else 1\n            elif self.platform != other.platform:\n                # generic < platform\n                pc = 1 if self.platform else -1\n            elif self.is_complete != other.is_complete:\n                # complete < incomplete\n                pc = -1 if self.is_complete else 1\n            elif self.is_obsolete != other.is_obsolete:\n                # current < obsolete\n                pc = 1 if self.is_obsolete else -1\n            if pc is 0 and self.is_obsolete and (self.use_instead != other.use_instead):\n                if self.use_instead is None:\n                    pc = -1\n                elif other.use_instead is None:\n                    pc = 1\n                else:\n                    pc = cmp(self.use_instead, other.use_instead)\n        return pc", "response": "Compares two MIME::Type objects to determine the priority of the two MIME::Types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of decoded URL values for this MIME::Type.", "response": "def urls(self):\n        \"\"\"\n        The decoded URL list for this MIME::Type.\n        The special URL value IANA will be translated into:\n          http://www.iana.org/assignments/media-types/<mediatype>/<subtype>\n        The special URL value RFC### will be translated into:\n          http://www.rfc-editor.org/rfc/rfc###.txt\n        The special URL value DRAFT:name will be\n        translated into:\n          https://datatracker.ietf.org/public/idindex.cgi?\n              command=id_detail&filename=<name>\n        The special URL value\n        LTSW will be translated\n        into:\n          http://www.ltsw.se/knbase/internet/<mediatype>.htp\n        The special\n        URL value\n        [token] will\n        be translated\n        into:\n          http://www.iana.org/assignments/contact-people.htm#<token>\n        These values will be accessible through #urls, which always returns an array.\n        \"\"\"\n        def _url(el):\n            if el == 'IANA':\n                return IANA_URL % (self.media_type, self.sub_type)\n            elif el == 'LTSW':\n                return LTSW_URL % self.media_type\n            match = re.compile('^\\{([^=]+)=([^\\}]+)\\}').match(el)\n            if match:\n                return match.group(1, 2)\n            match = re.compile('^\\[([^=]+)=([^\\]]+)\\]').match(el)\n            if match:\n                return [match.group(1), CONTACT_URL % match.group(2)]\n            for regex in REGEX_URLS:\n                match = re.compile(regex).match(el)\n                if match:\n                    return REGEX_URLS[regex] % match.group(1)\n            return el\n        return map(_url, self.url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsimplifies the content - type into a single entry.", "response": "def simplify(cls, content_type):\n        \"\"\"\n        The MIME types main- and sub-label can both start with <tt>x-</tt>,\n        which indicates that it is a non-registered name. Of course, after\n        registration this flag can disappear, adds to the confusing\n        proliferation of MIME types. The simplified string has the\n        <tt>x-</tt> removed and are translated to lowercase.\n        \"\"\"\n        matchdata = MEDIA_TYPE_RE.match(content_type)\n        if matchdata is None:\n            return None\n        wrap = lambda s: re.sub(UNREG_RE, '', s.lower())\n        (media_type, subtype) = matchdata.groups()\n        return '%s/%s' % (wrap(media_type), wrap(subtype))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_array(cls, content_type,\n                   extensions=[], encoding=None, system=None,\n                   is_obsolete=False, docs=None, url=None, is_registered=False):\n        \"\"\"\n        Creates a MIME::Type from an array in the form of:\n          [type-name, [extensions], encoding, system]\n        +extensions+, +encoding+, and +system+ are optional.\n          Type.from_array(\"application/x-ruby\", ['rb'], '8bit')\n          # Type.from_array([\"application/x-ruby\", ['rb'], '8bit'])\n        These are equivalent to:\n          type = Type('application/x-ruby')\n          type.extensions = ['rb']\n          type.encoding = '8bit'\n        \"\"\"\n        mt = cls(content_type)\n        mt.extensions = extensions\n        mt.encoding = encoding\n        mt.system = system\n        mt.is_obsolete = is_obsolete\n        mt.docs = docs\n        mt.url = url\n        mt.registered = is_registered\n        return mt", "response": "Creates a new MIME :: Type instance from an array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new MIME::Type instance from a hash.", "response": "def from_hash(cls, hash):\n        \"\"\"\n        Creates a MIME::Type from a hash. Keys are case-insensitive,\n        dashes may be replaced with underscores, and the internal\n        Symbol of the lowercase-underscore version can be used as\n        well. That is, Content-Type can be provided as content-type,\n        Content_Type, content_type, or :content_type.\n        Known keys are <tt>Content-Type</tt>,\n        <tt>Content-Transfer-Encoding</tt>, <tt>Extensions</tt>, and\n        <tt>System</tt>.\n          Type.from_hash({'Content-Type': 'text/x-yaml',\n                          'Content-Transfer-Encoding': '8bit',\n                          'System': 'linux',\n                          'Extensions': ['yaml', 'yml']})\n        This is equivalent to:\n          t = Type.new('text/x-yaml')\n          t.encoding = '8bit'\n          t.system = 'linux'\n          t.extensions = ['yaml', 'yml']\n        \"\"\"\n        wrap_key = lambda k: k.lower().replace('-', '_')\n        type_hash = dict([(wrap_key(k), v) for k, v in hash.items()])\n        mt = cls(type_hash['content_type'])\n        mt.extensions = type_hash.get('extensions', [])\n        mt.encoding = type_hash.get('encoding', 'default')\n        mt.system = type_hash.get('system')\n        mt.is_obsolete = type_hash.get('is_obsolete', False)\n        mt.docs = type_hash.get('docs')\n        mt.url = type_hash.get('url')\n        mt.registered = type_hash.get('is_registered', False)\n        return mt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new object from a MIME type.", "response": "def from_mime_type(cls, mime_type):\n        \"\"\"\n        Essentially a copy constructor.\n         Type.from_mime_type(plaintext)\n        is equivalent to:\n          t = Type.new(plaintext.content_type.dup)\n          t.extensions  = plaintext.extensions.dup\n          t.system      = plaintext.system.dup\n          t.encoding = plaintext.encoding.dup\n        \"\"\"\n        mt = cls(deepcopy(mime_type.content_type))\n        mt.extensions = map(deepcopy, mime_type.extensions)\n        mt.url = mime_type.url and map(deepcopy, mime_type.url) or None\n        mt.system = deepcopy(mime_type.system)\n        mt.encoding = deepcopy(mime_type.encoding)\n        mt.docs = deepcopy(mime_type.docs)\n\n        mt.is_obsolete = mime_type.is_obsolete\n        mt.registered = mime_type.is_registered\n        return mt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting action with specified options.", "response": "def execute_action(self, action_name, **options):\n        \"\"\"Execute action with specified options.\n\n        Tries to create action from its name and invokes it.\n\n        :param action_name: action name.\n        :param options: various action configuration.\n        \"\"\"\n        assert action_name in NG_ACTIONS, 'wrong action - {0}'.format(action_name)\n\n        action = NG_ACTIONS[action_name]\n        self.loop.run_sync(lambda: action.execute(**options), timeout=self.timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a list of dicts into an Excel file.", "response": "def json2excel(items, keys, filename, page_size=60000):\n    \"\"\" max_page_size is 65000 because we output old excel .xls format\n    \"\"\"\n    wb = xlwt.Workbook()\n    rowindex = 0\n    sheetindex = 0\n    for item in items:\n        if rowindex % page_size == 0:\n            sheetname = \"%02d\" % sheetindex\n            ws = wb.add_sheet(sheetname)\n            rowindex = 0\n            sheetindex += 1\n\n            colindex = 0\n            for key in keys:\n                ws.write(rowindex, colindex, key)\n                colindex += 1\n            rowindex += 1\n\n        colindex = 0\n        for key in keys:\n            v = item.get(key, \"\")\n            if type(v) == list:\n                v = ','.join(v)\n            if type(v) == set:\n                v = ','.join(v)\n            ws.write(rowindex, colindex, v)\n            colindex += 1\n        rowindex += 1\n\n    logging.debug(filename)\n    wb.save(filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a single file from an Excel file and return a dictionary of the objects.", "response": "def excel2json(filename, non_empty_col=-1, file_contents=None):\n    \"\"\"\n        http://www.lexicon.net/sjmachin/xlrd.html\n        non_empty_col is -1 to load all rows, when set to a none-empty value,\n        this function will skip rows having empty cell on that col.\n    \"\"\"\n\n    if file_contents:\n        workbook = xlrd.open_workbook(file_contents=file_contents)\n    else:\n        workbook = xlrd.open_workbook(filename)\n\n    start_row = 0\n    ret = collections.defaultdict(list)\n    fields = {}\n    for name in workbook.sheet_names():\n        sh = workbook.sheet_by_name(name)\n        headers = []\n        for col in range(len(sh.row(start_row))):\n            headers.append(sh.cell(start_row, col).value)\n\n        logging.info(u\"sheet={} rows={} cols={}\".format(\n            name, sh.nrows, len(headers)))\n        logging.info(json.dumps(headers, ensure_ascii=False))\n\n        fields[name] = headers\n\n        for row in range(start_row + 1, sh.nrows):\n            item = {}\n            rowdata = sh.row(row)\n            if len(rowdata) < len(headers):\n                msg = \"skip mismatched row {}\".format(\n                    json.dumps(rowdata, ensure_ascii=False))\n                logging.warning(msg)\n                continue\n\n            for col in range(len(headers)):\n                value = sh.cell(row, col).value\n                if type(value) in [unicode, basestring]:\n                    value = value.strip()\n                item[headers[col]] = value\n\n            if non_empty_col >= 0 and not item[headers[non_empty_col]]:\n                logging.debug(\"skip empty cell\")\n                continue\n\n            ret[name].append(item)\n        # stat\n        logging.info(u\"loaded {} {} (non_empty_col={})\".format(\n            filename, len(ret[name]), non_empty_col))\n    return {'data': ret, 'fields': fields}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks that the production parameters exist in the model instance.", "response": "def check_production_parameters_exist(self):\n        \"\"\" old versions of models won't have produciton parameters, leading to ZeroDivision errors and breaking things\"\"\"\n        for k, v in self.modelInstance.parameter_sets.items():\n            for p_id in self.modelInstance.production_params.keys():\n                if v.get(p_id):\n                    #print('{} already exists'.format(p_id))\n                    pass\n                else:\n                    #print('No production parameter called {} - setting it to 1'.format(p_id))\n                    v[p_id] = 1.0\n\n            for p_id in self.modelInstance.allocation_params.keys():\n                if v.get(p_id):\n                    #print('{} already exists'.format(p_id))\n                    pass\n                else:\n                    #print('No production parameter called {} - setting it to 1'.format(p_id))\n                    v[p_id] = 1.0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the JSON representation of a symbol", "response": "def _create_symbol(self, id, symbolobj):\n        \"\"\"Creates the JSON representation of a symbol\"\"\"\n        result = {'id': symbolobj.name, 'isPoint': False, 'isStroke': False, 'isFill': False}\n        matcher = Mapfile._SYMBOL_NAME_REGEXP.match(symbolobj.name)\n        if matcher:\n            result['name'] = matcher.group(2)\n            for c in matcher.group(1):\n                field = Mapfile._STYLE_CHAR2NAME[c]\n                result[field] = True\n        else:\n            result['name'] = symbolobj.name\n            result['isPoint'] = result['isStroke'] = result['isFill'] = True\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntranslate a unicode string with Hanyang - PUA codes to a Syllable - Initial - Peak - Final encoded unicode string.", "response": "def translate(pua, composed=True):\n    ''' Convert a unicode string with Hanyang-PUA codes\n    to a Syllable-Initial-Peak-Final encoded unicode string.\n\n    :param pua: a unicode string with Hanyang-PUA codes\n    :param composed: the result should be composed as possible (default True)\n    :return: Syllable-Initial-Peak-Final encoded unicode string\n    '''\n\n    from .encoder import PUAComposedEncoder\n    from .encoder import PUADecomposedEncoder\n\n    if composed:\n        JamoEncoder = PUAComposedEncoder\n    else:\n        JamoEncoder = PUADecomposedEncoder\n    encoder = JamoEncoder()\n    return encoder.encode(pua, final=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a list of Hanyang - PUA codes to a Syllable - Initial - Peak - Final encoded unicode string.", "response": "def codes2unicode(codes, composed=True):\n    ''' Convert Hanyang-PUA code iterable to Syllable-Initial-Peak-Final\n    encoded unicode string.\n\n    :param codes:\n        an iterable of Hanyang-PUA code\n    :param composed:\n        the result should be composed as much as possible (default True)\n    :return: Syllable-Initial-Peak-Final encoded unicode string\n    '''\n    pua = u''.join(unichr(code) for code in codes)\n    return translate(pua, composed=composed)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(self, len=1024):\n        'read up to len bytes and return them, or empty string on EOF'\n        return self._with_retry(\n                functools.partial(self._read_attempt, len),\n                self.gettimeout())", "response": "read up to len bytes and return them or empty string on EOF"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write(self, data):\n        'write data to the ssl channel and return the # of bytes transferred'\n        return self._with_retry(\n                functools.partial(self._sslobj.write, data),\n                self.gettimeout())", "response": "write data to the ssl channel and return the # of bytes transferred"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_handshake(self, timeout):\n        'perform a SSL/TLS handshake'\n        tout = _timeout(timeout)\n        if not self._blocking:\n            return self._sslobj.do_handshake()\n\n        while 1:\n            try:\n                return self._sslobj.do_handshake()\n            except ssl.SSLError, exc:\n                if exc.args[0] == ssl.SSL_ERROR_WANT_READ:\n                    self._wait_event(tout.now)\n                    continue\n                elif exc.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n                    self._wait_event(tout.now, write=True)\n                    continue\n                raise\n\n        self._wait_event(timeout)\n        self._sslobj.do_handshake()", "response": "perform a SSL / TLS handshake"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect(self, address):\n        'connects to the address and wraps the connection in an SSL context'\n        tout = _timeout(self.gettimeout())\n        while 1:\n            self._wait_event(tout.now, write=True)\n            err = self._connect(address, tout.now)\n            if err in (errno.EINPROGRESS, errno.EALREADY, errno.EWOULDBLOCK):\n                continue\n            if err:\n                raise socket.error(err, errno.errorcode[err])\n            return 0", "response": "connects to the address and wraps the connection in an SSL context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a file - like object that operates on the ssl connection", "response": "def makefile(self, mode='r', bufsize=-1):\n        'return a file-like object that operates on the ssl connection'\n        sockfile = gsock.SocketFile.__new__(gsock.SocketFile)\n        gfiles.FileBase.__init__(sockfile)\n        sockfile._sock = self\n        sockfile.mode = mode\n        if bufsize > 0:\n            sockfile.CHUNKSIZE = bufsize\n        return sockfile"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(cont, util, shell, argv=None):\n    cont.fetch_and_import(\"setup/python/setup.py\").run(cont,\n                                                       util,\n                                                       shell,\n                                                       argv)\n    cmake_cont = cont.fetch_and_import(\"setup/cmake/setup.py\").run(cont,\n                                                                   util,\n                                                                   shell,\n                                                                   argv)\n\n    # Now that the cmake container is set up, use its execute method\n    # to find out where cmake scripts are actually installed.\n    #\n    # The answer might be obvious from just using \"which\" on OS X and\n    # Linux, but on Windows, the binaries are symlinked into another\n    # directory - we need the true install location.\n    with cont.in_temp_cache_dir():\n        with open(\"cmroot.cmake\", \"w\") as root_script:\n            root_script.write(\"message (${CMAKE_ROOT})\")\n\n        install_path = bytearray()\n\n        def steal_output(process, outputs):\n            \"\"\"Steal output from container executor.\"\"\"\n            install_path.extend(outputs[1].read().strip())\n            return process.wait()\n\n        cmake_cont.execute(cont,\n                           steal_output,\n                           \"cmake\",\n                           \"-P\",\n                           root_script.name)\n\n        # If we're on linux, then the returned path is going to be\n        # relative to the container, so make that explicit, since we're\n        # not running the tests inside the container.\n        if platform.system() == \"Linux\":\n            root_fs_path_bytes = cmake_cont.root_fs_path()\n            install_path = os.path.join(root_fs_path_bytes.decode(\"utf-8\"),\n                                        install_path.decode(\"utf-8\")[1:])\n            install_path = os.path.normpath(install_path)\n        else:\n            install_path = install_path.decode(\"utf-8\")\n\n        util.overwrite_environment_variable(shell,\n                                            \"CMAKE_INSTALL_PATH\",\n                                            install_path)", "response": "Run cmake and return a list of cmake modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef length(self):\n\n        if not self.__length:\n            self.__length = self.__get_length()\n\n        return self.__length", "response": "Returns the length of the data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_content(pattern, string, tag='content'):\n    output = []\n    for match in re.finditer(pattern, string):\n        output.append(match.group(tag))\n    return output", "response": "Finds the content tag from a pattern in a provided string"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts a given regex pattern from a string", "response": "def extract(pattern, string, *, assert_equal=False, one=False,\n            condense=False, default=None, default_if_multiple=True,\n            default_if_none=True):\n    \"\"\"\n    Used to extract a given regex pattern from a string, given several options\n    \"\"\"\n\n    if isinstance(pattern, str):\n        output = get_content(pattern, string)\n    else:\n        # Must be a linear container\n        output = []\n        for p in pattern:\n            output += get_content(p, string)\n\n    output = process_output(output, one=one, condense=condense,\n                            default=default,\n                            default_if_multiple=default_if_multiple,\n                            default_if_none=default_if_none)\n\n    if assert_equal:\n        assert_output(output, assert_equal)\n    else:\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extractRuntime(runtime_dirs):\n    names = [str(item) for name in runtime_dirs for item in os.listdir(name)]\n    string = '\\n'.join(names)\n    result = extract(RUNTIME_PATTERN, string, condense=True)\n    return result", "response": "Used to find the correct static lib name to pass to gcc\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts the code to be run as a script after compilation", "response": "def extractAtCyther(string):\n    \"\"\"\n    Extracts the '@cyther' code to be run as a script after compilation\n    \"\"\"\n    if isinstance(string, str) and os.path.isfile(string):\n        with open(string) as file:\n            string = file.read()\n\n    found_pound = extract(POUND_PATTERN, string)\n    found_tripple = extract(TRIPPLE_PATTERN, string)\n    all_found = found_pound + found_tripple\n    code = '\\n'.join([item for item in all_found])\n\n    return code"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract a three digit standard format version number from a string.", "response": "def extractVersion(string, default='?'):\n    \"\"\"\n    Extracts a three digit standard format version number\n    \"\"\"\n    return extract(VERSION_PATTERN, string, condense=True, default=default,\n                   one=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncombine a jinja template with a secret. ini file", "response": "def render_secrets(\n        config_path,\n        secret_path,\n):\n    \"\"\"combine a jinja template with a secret .ini file\n\n    Args:\n        config_path (str): path to .cfg file with jinja templating\n        secret_path (str): path to .ini-like secrets file\n\n    Returns:\n        ProsperConfig: rendered configuration object\n\n    \"\"\"\n    with open(secret_path, 'r') as s_fh:\n        secret_ini = anyconfig.load(s_fh, ac_parser='ini')\n\n    with open(config_path, 'r') as c_fh:\n        raw_cfg = c_fh.read()\n\n    rendered_cfg = anytemplate.renders(raw_cfg, secret_ini, at_engine='jinja2')\n\n    p_config = ProsperConfig(config_path)\n    local_config = configparser.ConfigParser()\n    local_config.optionxform = str\n    local_config.read_string(rendered_cfg)\n\n    p_config.local_config = local_config\n\n    return p_config"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_value(\n        config,\n        section,\n        option,\n        jinja_pattern=JINJA_PATTERN,\n):\n    \"\"\"try to figure out if value is valid or jinja2 template value\n\n    Args:\n        config (:obj:`configparser.ConfigParser`): config object to read key from\n        section (str): name of section in configparser\n        option (str): name of option in configparser\n        jinja_pattern (:obj:`_sre.SRE_Pattern`): a `re.compile()` pattern to match on\n\n    Returns:\n        str: value if value, else None\n\n    Raises:\n        KeyError:\n        configparser.NoOptionError:\n        configparser.NoSectionError:\n\n    \"\"\"\n    value = config[section][option]\n    if re.match(jinja_pattern, value):\n        return None\n\n    return value", "response": "check if value is valid or jinja2 template value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the value of a key in the environment", "response": "def get_value_from_environment(\n        section_name,\n        key_name,\n        envname_pad=ENVNAME_PAD,\n        logger=logging.getLogger('ProsperCommon'),\n):\n    \"\"\"check environment for key/value pair\n\n    Args:\n        section_name (str): section name\n        key_name (str): key to look up\n        envname_pad (str): namespace padding\n        logger (:obj:`logging.logger`): logging handle\n\n    Returns:\n        str: value in environment\n\n    \"\"\"\n    var_name = '{pad}_{section}__{key}'.format(\n        pad=envname_pad,\n        section=section_name,\n        key=key_name\n    )\n\n    logger.debug('var_name=%s', var_name)\n    value = getenv(var_name)\n    logger.debug('env value=%s', value)\n\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngo and fetch the global and local configs from file and load them with configparser", "response": "def get_configs(\n        config_filepath,\n        local_filepath_override='',\n):\n    \"\"\"go and fetch the global/local configs from file and load them with configparser\n\n    Args:\n        config_filepath (str): path to config\n        local_filepath_override (str): secondary place to locate config file\n\n    Returns:\n        ConfigParser: global_config\n        ConfigParser: local_config\n\n    \"\"\"\n    global_config = read_config(config_filepath)\n\n    local_filepath = get_local_config_filepath(config_filepath, True)\n    if local_filepath_override:\n        local_filepath = local_filepath_override\n    local_config = read_config(local_filepath)\n\n    return global_config, local_config"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_config(\n        config_filepath,\n        logger=logging.getLogger('ProsperCommon'),\n):\n    \"\"\"fetch and parse config file\n\n    Args:\n        config_filepath (str): path to config file.  abspath > relpath\n        logger (:obj:`logging.Logger`): logger to catch error msgs\n\n    \"\"\"\n    config_parser = configparser.ConfigParser(\n        interpolation=ExtendedInterpolation(),\n        allow_no_value=True,\n        delimiters=('='),\n        inline_comment_prefixes=('#')\n    )\n    logger.debug('config_filepath=%s', config_filepath)\n\n    with open(config_filepath, 'r') as filehandle:\n        config_parser.read_file(filehandle)\n\n    return config_parser", "response": "fetch and parse config file\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(\n            self,\n            section_name,\n            key_name,\n    ):\n        \"\"\"Replicate configparser.get() functionality\n\n        Args:\n            section_name (str): section name in config\n            key_name (str): key name in config.section_name\n\n        Returns:\n            str: do not check defaults, only return local value\n\n        Raises:\n            KeyError: unable to find option in either local or global config\n\n        \"\"\"\n        value = None\n        try:\n            value = self.local_config.get(section_name, key_name)\n        except Exception as error_msg:\n            self.logger.warning(\n                '%s.%s not found in local config', section_name, key_name\n            )\n            try:\n                value = self.global_config.get(section_name, key_name)\n            except Exception as error_msg:\n                self.logger.error(\n                    '%s.%s not found in global config', section_name, key_name\n                )\n                raise KeyError('Could not find option in local/global config')\n\n        return value", "response": "Replicate configparser. get function"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_option(\n            self,\n            section_name,\n            key_name,\n            args_option=None,\n            args_default=None,\n    ):\n        \"\"\"evaluates the requested option and returns the correct value\n\n        Notes:\n            Priority order\n            1. args given at runtile\n            2. <config_file>_local.cfg -- untracked config with #SECRETS\n            3. <config_file>.cfg -- tracked 'master' config without #SECRETS\n            4. environment varabile\n            5. args_default -- function default w/o global config\n\n        Args:\n            section_name (str): section level name in config\n            key_name (str): key name for option in config\n            args_option (any): arg option given by a function\n            args_default (any): arg default given by a function\n\n        Returns:\n            str: appropriate response as per priority order\n\n        \"\"\"\n        if args_option != args_default and\\\n           args_option is not None:\n            self.logger.debug('-- using function args')\n            return args_option\n\n        section_info = section_name + '.' + key_name\n\n        option = None\n        try:\n            option = check_value(self.local_config, section_name, key_name)\n            self.logger.debug('-- using local config')\n            if option:\n                return option\n        except (KeyError, configparser.NoOptionError, configparser.NoSectionError):\n            self.logger.debug('`%s` not found in local config', section_info)\n\n        try:\n            option = check_value(self.global_config, section_name, key_name)\n            self.logger.debug('-- using global config')\n            if option:\n                return option\n        except (KeyError, configparser.NoOptionError, configparser.NoSectionError):\n            self.logger.warning('`%s` not found in global config', section_info)\n\n        env_option = get_value_from_environment(section_name, key_name, logger=self.logger)\n        if env_option:\n            self.logger.debug('-- using environment value')\n            return env_option\n\n        self.logger.debug('-- using default argument')\n        return args_default", "response": "evaluates the requested option and returns the correct value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef SetCredentials(api_username,api_passwd):\n\tglobal V2_API_USERNAME\n\tglobal V2_API_PASSWD\n\tglobal _V2_ENABLED\n\t_V2_ENABLED = True\n\tV2_API_USERNAME = api_username\n\tV2_API_PASSWD = api_passwd", "response": "Establish API username and password associated with APIv2 commands."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_session(username, password, default_endpoints=clc.defaults, cert=None):\n\tif cert is None:\n\t\tcert = API._ResourcePath('clc/cacert.pem')\n\n\tsession = requests.Session()\n\n\trequest = session.request(\n\t\t\"POST\",\n\t\t\"{}/v2/authentication/login\".format(default_endpoints.ENDPOINT_URL_V2),\n\t\tdata={\"username\": username, \"password\": password},\n\t\tverify=cert)\n\n\tdata = request.json()\n\n\tif request.status_code == 200:\n\t\ttoken = data['bearerToken']\n\t\talias = data['accountAlias']\n\t\tlocation = data['locationAlias']\n\telif request.status_code == 400:\n\t\traise Exception(\"Invalid V2 API login. {}\".format(data['message']))\n\telse:\n\t\traise Exception(\"Error logging into V2 API.  Response code {}. message {}\"\n\t\t\t\t\t    .format(request.status_code,data['message']))\n\n\treturn {'username': username,\n\t\t\t'password': password,\n\t\t\t'http_session': session,\n\t\t\t'token': token,\n\t\t\t'alias': alias,\n\t\t\t'location': location}", "response": "Start a session with the given parameters\n\tUse instead of SetCredentials."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates mean intensities of pixels in superpixels in the specified image.", "response": "def get_superpxl_intensities(im, suppxls):\n    \"\"\"Calculates mean intensities of pixels in superpixels\n    inputs:\n        im ... grayscale image, ndarray [MxN]\n        suppxls ... image with suppxls labels, ndarray -same shape as im\n    outputs:\n        suppxl_intens ... vector with suppxls mean intensities\n    \"\"\"\n    n_suppxl = np.int(suppxls.max() + 1)\n    suppxl_intens = np.zeros(n_suppxl)\n\n    for i in range(n_suppxl):\n        sup = suppxls == i\n        vals = im[np.nonzero(sup)]\n        try:\n            suppxl_intens[i] = np.mean(vals)\n        except:\n            suppxl_intens[i] = -1\n\n    return suppxl_intens"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef suppxl_ints2im(suppxls, suppxl_ints=None, im=None):\n\n    suppxl_ints_im = np.zeros(suppxls.shape)\n\n    if suppxl_ints is None and im is not None:\n        suppxl_ints = get_superpxl_intensities(im, suppxls)\n\n    for i in np.unique(suppxls):\n        sup = suppxls == i\n        val = suppxl_ints[i]\n        suppxl_ints_im[np.nonzero(sup)] = val\n\n    return suppxl_ints_im", "response": "Replaces superpixel labels with their mean value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_empty_suppxls(suppxls):\n    n_suppxls = np.int(suppxls.max() + 1)\n    new_supps = np.zeros(suppxls.shape, dtype=np.integer)\n    idx = 0\n    for i in range(n_suppxls):\n        sup = suppxls == i\n        if sup.any():\n            new_supps[np.nonzero(sup)] = idx\n            idx += 1\n    return new_supps", "response": "Remove empty superpixels from the image with suppxls labels."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_bbox(im):\n    '''\n    Returns bounding box in slicing-friendly format (i-min, i-xmax, j-min, j-max, k-min, k-max).\n    The fourth and fifth items are returned only if input image is 3D.\n    Parameters\n    ----------\n    im - input binary image\n\n    Returns\n    -------\n    indices - (i-min, i-xmax, j-min, j-max, k-min, k-max) in 3D case, (i-min, i-xmax, j-min, j-max) in 2D case.\n    '''\n    coords = np.nonzero(im)\n    inds = []\n    for i in coords:\n        i_min = i.min()\n        i_max = i.max()\n        inds.extend((i_min, i_max))\n\n    return inds", "response": "Returns bounding box of the image in slicing - friendly format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pyramid(image, scale=2, min_size=(30, 30), inter=None):\n    yield image\n    import cv2\n    if inter is None:\n        inter=cv2.INTER_AREA\n    # yield the original image\n\n    # keep looping over the pyramid\n    while True:\n        # compute the new dimensions of the image and resize it\n        w = int(image.shape[1] / scale)\n        image = resize(image, width=w, inter=inter)\n\n        # if the resized image does not meet the supplied minimum\n        # size, then stop constructing the pyramid\n        if image.shape[0] < min_size[1] or image.shape[1] < min_size[0]:\n            break\n\n        # yield the next image in the pyramid\n        yield image", "response": "Generates a generator of image pyramid."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a generator that produces a sliding window of the given size.", "response": "def sliding_window(image, step_size, window_size, mask=None, only_whole=True):\n    \"\"\"\n    Creates generator of sliding windows.\n    :param image: input image\n    :param step_size: number of pixels we are going to skip in both the (x, y) direction\n    :param window_size: the width and height of the window we are going to extract\n    :param mask: region of interest, if None it will slide through the whole image\n    :param only_whole: if True - produces only windows of the given window_size\n    :return: generator that produce upper left corner of the window, center of the window and the sliding window itself\n    \"\"\"\n    if mask is None:\n        mask = np.ones(image.shape, dtype=np.bool)\n    # slide a window across the image\n    for y in xrange(0, image.shape[0], step_size):\n        # c_y = y + window_size[1] / 2.\n        for x in xrange(0, image.shape[1], step_size):\n            # c_x = x + window_size[0] / 2.\n            # if c_x < mask.shape[1] and c_y < mask.shape[0] and mask[c_y, c_x]:\n            # yield the current window\n            end_x = x + window_size[0]\n            end_y = y + window_size[1]\n            if only_whole and (end_x > image.shape[1] or end_y > image.shape[0]):\n                continue\n            else:\n                mask_out = np.zeros(image.shape, dtype=np.bool)\n                mask_out[y:end_y, x:end_x] = True\n                yield (x, y, mask_out, image[y:end_y, x:end_x])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a generator that produces a sliding window of the given size.", "response": "def sliding_window_3d(image, step_size, window_size, mask=None, only_whole=True, include_last=False):\n    \"\"\"\n    Creates generator of sliding windows.\n    :param image: input image\n    :param step_size: number of pixels we are going to skip in both the (x, y) direction\n    :param window_size: the width and height of the window we are going to extract\n    :param mask: region of interest, if None it will slide through the whole image\n    :param only_whole: if True - produces only windows of the given window_size\n    :return: generator that produce upper left corner of the window, center of the window and the sliding window itself\n    \"\"\"\n    if not isinstance(step_size, tuple):\n        step_size = (step_size, step_size, step_size)\n    if image.ndim == 2:\n        image = np.expand_dims(image, 0)\n        window_size = (1, window_size[0], window_size[1])\n        if mask is not None:\n            mask = np.expand_dims(mask, 0)\n    if mask is None:\n        mask = np.ones(image.shape, dtype=np.bool)\n    # slide a window across the image\n    for z in xrange(0, image.shape[0], step_size[0]):\n        # c_z = z + window_size[0] / 2.\n        for y in xrange(0, image.shape[1], step_size[1]):\n            # c_y = y + window_size[2] / 2.\n            for x in xrange(0, image.shape[2], step_size[2]):\n                # c_x = x + window_size[1] / 2.\n                # if c_z < mask.shape[0] and c_x < mask.shape[2] and c_y < mask.shape[1] and mask[c_z, c_y, c_x]:\n                # yield the current window\n                end_x = x + window_size[1]\n                end_y = y + window_size[2]\n                end_z = z + window_size[0]\n                if only_whole and (end_z > image.shape[0] or end_x > image.shape[2] or end_y > image.shape[1]):\n                    # if only_whole:\n                    continue\n                    # elif include_last:\n                    #     mask_out = np.zeros(image.shape, dtype=np.bool)\n                    #     x = image.shape[2] - window_size[1]\n                    #     y = image.shape[1] - window_size[2]\n                    #     z = image.shape[0] - window_size[0]\n                    #     end_x = image.shape[2]\n                    #     end_y = image.shape[1]\n                    #     end_z = image.shape[0]\n                    #\n                    #     mask_out[z:end_z, y:end_y, x:end_x] = True\n                    #     yield (x, y, z, mask_out, image[z:end_z, y:end_y, x:end_x])\n                else:\n                    mask_out = np.zeros(image.shape, dtype=np.bool)\n                    mask_out[z:end_z, y:end_y, x:end_x] = True\n                    yield (x, y, z, mask_out, image[z:end_z, y:end_y, x:end_x])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef split_to_tiles(img, columns, rows):\n    # validate_image(img, number_tiles)\n\n    im_w, im_h = img.shape\n    # columns, rows = calc_columns_rows(number_tiles)\n    # extras = (columns * rows) - number_tiles\n    tile_w, tile_h = int(np.floor(im_w / columns)), int(np.floor(im_h / rows))\n\n    tiles = []\n    # number = 1\n    for pos_y in range(0, im_h - rows, tile_h):  # -rows for rounding error.\n        for pos_x in range(0, im_w - columns, tile_w):  # as above.\n            roi = (pos_x, pos_y, pos_x + tile_w, pos_y + tile_h)\n            # image = img.crop(area)\n            tile = img[roi[1]:roi[3], roi[0]:roi[2]]\n            # position = (int(floor(pos_x / tile_w)) + 1,\n            #             int(floor(pos_y / tile_h)) + 1)\n            # coords = (pos_x, pos_y)\n            # tile = Tile(image, number, position, coords)\n            tiles.append(tile)\n            # number += 1\n\n    return tuple(tiles)", "response": "Splits an image into a specified number of tiles."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_id(self,pid):\n        if self.type == 'KAF':\n            return self.node.set('pid',pid)\n        elif self.type == 'NAF':\n            return self.node.set('id',pid)", "response": "Set the property identifier associated with the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new property to the property layer.", "response": "def add_property(self,pid, label,term_span):\n        \"\"\"\n        Adds a new property to the property layer\n        @type pid: string\n        @param pid: property identifier\n        @type label: string\n        @param label: the label of the property\n        @type term_span: list\n        @param term_span: list of term identifiers\n        \"\"\"\n        new_property = Cproperty(type=self.type)\n        self.node.append(new_property.get_node())\n        ##Set the id\n        if pid is None:\n            ##Generate a new pid\n            existing_pids = [property.get_id() for property in self]\n            n = 0\n            new_pid = ''\n            while True:\n                new_pid = 'p'+str(n)\n                if new_pid not in existing_pids: break\n                n += 1\n            pid = new_pid\n        new_property.set_id(pid)\n        \n        new_property.set_type(label)\n        \n        new_ref = Creferences()\n        new_ref.add_span(term_span)\n        new_property.set_reference(new_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_kaf(self):\n        if self.type == 'NAF':\n            ##convert all the properties\n            for node in self.node.findall('properties/property'):\n                node.set('pid',node.get('id'))\n                del node.attrib['id']", "response": "Converts the element to NAF"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_naf(self):\n        if self.type == 'KAF':\n            ##convert all the properties\n            for node in self.node.findall('properties/property'):\n                node.set('id',node.get('pid'))\n                del node.attrib['pid']", "response": "Converts the element to NAF"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a new property to the property layer", "response": "def add_property(self,pid, label,term_span):\n        \"\"\"\n        Adds a new property to the property layer\n        @type pid: string\n        @param pid: property identifier\n        @type label: string\n        @param label: the label of the property\n        @type term_span: list\n        @param term_span: list of term identifiers\n        \"\"\"\n        node_prop = self.node.find('properties')\n        if node_prop is None:\n            properties = Cproperties(type=self.type)\n            self.node.append(properties.get_node())\n        else:\n            properties = Cproperties(node=node_prop,type=self.type)\n            \n        properties.add_property(pid, label,term_span)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_properties(self):\n        node_prop = self.node.find('properties')\n        if node_prop is not None:\n            obj_properties = Cproperties(node_prop,self.type)\n            for prop in obj_properties:\n                yield prop", "response": "Iterator that returns all the properties of the layuer\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the property layer if exists.", "response": "def remove_properties(self):\n        \"\"\"\n        Removes the property layer, if exists\n        \"\"\"\n        node_prop = self.node.find('properties')\n        if node_prop is not None:\n            self.node.remove(node_prop)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean_key(self):\n        key = self.cleaned_data[\"key\"]\n        gpg = get_gpg()\n        result = gpg.import_keys(key)\n        if result.count == 0:\n            raise forms.ValidationError(_(\"Invalid Key\"))\n        return key", "response": "Validate the key contains an email address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the term identifier of the current term.", "response": "def get_id(self):\n        \"\"\"\n        Returns the term identifier\n        @rtype: string\n        @return: the term identifier\n        \"\"\"\n        if self.type == 'NAF':\n            return self.node.get('id')\n        elif self.type == 'KAF':\n            return self.node.get('mid')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the identifier for the term", "response": "def set_id(self,i):\n        \"\"\"\n        Sets the identifier for the term\n        @type i: string\n        @param i: lemma identifier\n        \"\"\"\n        if self.type == 'NAF':\n            self.node.set('id',i)\n        elif self.type == 'KAF':\n            self.node.set('mid',i)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_external_reference(self,ext_ref):\n        ext_refs_node = self.node.find('externalReferences')\n        if ext_refs_node is None:\n            ext_refs_obj = CexternalReferences()\n            self.node.append(ext_refs_obj.get_node())\n        else:\n            ext_refs_obj = CexternalReferences(ext_refs_node)\n            \n        ext_refs_obj.add_external_reference(ext_ref)", "response": "Adds an external reference object to the markable\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_external_references(self):\n        for ext_ref_node in self.node.findall('externalReferences'):\n            ext_refs_obj = CexternalReferences(ext_ref_node)\n            for ref in ext_refs_obj:\n                yield ref", "response": "Iterator that returns all the external references of the markable\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the markable object for the supplied identifier", "response": "def get_markable(self,markable_id):\n        \"\"\"\n        Returns the markable object for the supplied identifier\n        @type markable_id: string\n        @param markable_id: term identifier\n        \"\"\"\n        if markable_id in self.idx:\n            return Cmarkable(self.idx[markable_id],self.type)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_mark(self, mark_id):\n        if mark_id in self.idx:\n            return Cmarkable(self.idx[mark_id], self.type)\n        else:\n            return None", "response": "Returns the markable object for the supplied identifier\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_external_reference(self,markable_id, external_ref):\n        if markable_id in self.idx:\n            markable_obj = Cterm(self.idx[markable_id],self.type)\n            markable_obj.add_external_reference(external_ref)\n        else:\n            print('{markable_id} not in self.idx'.format(**locals()))", "response": "Adds an external reference to the given markable"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves a list of markables from the layer.", "response": "def remove_markables(self,list_mark_ids):\n        \"\"\"\n        Removes a list of markables from the layer\n        @type list_term_ids: list\n        @param list_term_ids: list of markable identifiers to be removed  \n        \"\"\"\n        nodes_to_remove = set()\n        for markable in self:\n            if markable.get_id() in list_mark_ids:\n                nodes_to_remove.add(markable.get_node())\n                #For removing the previous comment\n                prv = markable.get_node().getprevious()\n                if prv is not None:\n                    nodes_to_remove.add(prv)\n        \n        for node in nodes_to_remove:\n            self.node.remove(node)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef learn_all_skill(level=60, master_level=0):\n    level = str(level)\n    bot.delay(1.0)\n    for i in range(31): # \u4e00\u517131\u4e2a\u6280\u80fd\n        bot.type_string(level)\n        bot.tab()\n        bot.up(n=2)\n        bot.down(n=master_level)\n        bot.tab()", "response": "\u5728\u6280\u80fd\u7f16\u8f91\u754c\u9762\u5b66\u4f1a\u6240\u6709\u7684\u6280\u80fd\u3002\u8fd0\u884c\u811a\u672c\u524d, \u5c06\u9f20\u6807\u653e\u5728\u7b2c\u4e00\u4e2a\u6280\u80fd\u7684\u6280\u80fd\u7b49\u7ea7\n    \u7684\u6570\u5b57\u4e0a, \u5e76\u9009\u4e2d\u6240\u6709\u6587\u672c\u3002\u7136\u540e\u8fd0\u884c\u6b64\u811a\u672c, \u5e76\u57281\u79d2\u5185\u5207\u56de\u5230\u4fee\u6539\u5668\u754c\u9762\u3002\n    \n    :param level: \u6280\u80fd\u7b49\u7ea7\n    :param master_level: \u4e13\u7cbe\u7b49\u7ea7, 0\u662f\u666e\u901a, 1\u662f\u4e13\u5bb6, 2\u662f\u5927\u5e08"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking an exponential back off getInfo call on an Earth Engine object", "response": "def getinfo(ee_obj, n=4):\n    \"\"\"Make an exponential back off getInfo call on an Earth Engine object\"\"\"\n    output = None\n    for i in range(1, n):\n        try:\n            output = ee_obj.getInfo()\n        except ee.ee_exception.EEException as e:\n            if 'Earth Engine memory capacity exceeded' in str(e):\n                logging.info('    Resending query ({}/10)'.format(i))\n                logging.debug('    {}'.format(e))\n                sleep(i ** 2)\n            else:\n                raise e\n\n        if output:\n            break\n\n    # output = ee_obj.getInfo()\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef constant_image_value(image, crs='EPSG:32613', scale=1):\n    return getinfo(ee.Image(image).reduceRegion(\n        reducer=ee.Reducer.first(), scale=scale,\n        geometry=ee.Geometry.Rectangle([0, 0, 10, 10], crs, False)))", "response": "Extract the output value from a calculation done with constant images"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract the output value from a calculation at a point", "response": "def point_image_value(image, xy, scale=1):\n    \"\"\"Extract the output value from a calculation at a point\"\"\"\n    return getinfo(ee.Image(image).reduceRegion(\n        reducer=ee.Reducer.first(), geometry=ee.Geometry.Point(xy),\n        scale=scale))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef point_coll_value(coll, xy, scale=1):\n    output = getinfo(coll.getRegion(ee.Geometry.Point(xy), scale=scale))\n\n    # Structure output to easily be converted to a Pandas dataframe\n    # First key is band name, second key is the date string\n    col_dict = {}\n    info_dict = {}\n    for i, k in enumerate(output[0][4:]):\n        col_dict[k] = i + 4\n        info_dict[k] = {}\n    for row in output[1:]:\n        date = datetime.datetime.utcfromtimestamp(row[3] / 1000.0).strftime(\n            '%Y-%m-%d')\n        for k, v in col_dict.items():\n            info_dict[k][date] = row[col_dict[k]]\n    return info_dict", "response": "Extract the output value from a calculation at a point"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the 0 UTC date for a date", "response": "def date_0utc(date):\n    \"\"\"Get the 0 UTC date for a date\n\n    Parameters\n    ----------\n    date : ee.Date\n\n    Returns\n    -------\n    ee.Date\n\n    \"\"\"\n    return ee.Date.fromYMD(date.get('year'), date.get('month'),\n                           date.get('day'))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_version(\n        here_path,\n        default_version=DEFAULT_VERSION,\n):\n    \"\"\"tries to resolve version number\n\n    Args:\n        here_path (str): path to project local dir\n        default_version (str): what version to return if all else fails\n\n    Returns:\n        str: semantic_version information for library\n\n    \"\"\"\n    if 'site-packages' in here_path:\n        # Running as dependency\n        return _version_from_file(here_path)\n\n    if os.environ.get('TRAVIS_TAG'):\n        # Running on Travis-CI: trumps all\n        if not TEST_MODE:  # pragma: no cover\n            return os.environ.get('TRAVIS_TAG').replace('v', '')\n        else:\n            warnings.warn(\n                'Travis detected, but TEST_MODE enabled',\n                exceptions.ProsperVersionTestModeWarning)\n\n    try:\n        current_tag = _read_git_tags(default_version=default_version)\n    except Exception:  # pragma: no cover\n        return _version_from_file(here_path)\n\n    # TODO: if #steps from tag root, increment minor\n    # TODO: check if off main branch and add name to prerelease\n\n    with open(os.path.join(here_path, 'version.txt'), 'w') as v_fh:\n        # save version info somewhere static\n        v_fh.write(current_tag)\n\n    return current_tag", "response": "tries to resolve version number from file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_git_tags(\n        default_version=DEFAULT_VERSION,\n        git_command=('git', 'tag'),\n):\n    \"\"\"tries to find current git tag\n\n    Notes:\n        git_command exposed for testing null case\n\n    Args:\n        default_version (str): what version to make\n        git_command (:obj:`list`): subprocess command\n\n    Retruns:\n        str: latest version found, or default\n\n    Warns:\n        exceptions.ProsperDefaultVersionWarning: git version not found\n\n    \"\"\"\n    try:\n        current_tags = check_output(git_command).splitlines()\n    except Exception:  # pragma: no cover\n        raise\n\n    if not current_tags[0]:\n        warnings.warn(\n            'Unable to resolve current version',\n            exceptions.ProsperDefaultVersionWarning)\n        return default_version\n\n    latest_version = semantic_version.Version(default_version)\n    for tag in current_tags:\n        tag_str = decode(tag, 'utf-8').replace('v', '')\n        try:\n            tag_ver = semantic_version.Version(tag_str)\n        except Exception:  # pragma: no cover\n            continue  # invalid tags ok, but no release\n\n        if tag_ver > latest_version:\n            latest_version = tag_ver\n\n    return str(latest_version)", "response": "Reads git tags and returns the latest version"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _configure_common(\n            self,\n            prefix,\n            fallback_level,\n            fallback_format,\n            handler_name,\n            handler,\n            custom_args=''\n    ):\n        \"\"\"commom configuration code\n\n        Args:\n            prefix (str): A prefix for the `log_level` and `log_format` keys to use with the config. #FIXME: Hacky, add separate sections for each logger config?\n            fallback_level (str): Fallback/minimum log level, for if config does not have one.\n            fallback_format (str): Fallback format for if it's not in the config.\n            handler_name (str): Handler used in debug messages.\n            handler (str): The handler to configure and use.\n            custom_args (str): special ID to include in messages\n\n        \"\"\"\n        ## Retrieve settings from config ##\n        log_level = self.config.get_option(\n            'LOGGING', prefix + 'log_level',\n            None, fallback_level\n        )\n        log_format_name = self.config.get_option(\n            'LOGGING', prefix + 'log_format',\n            None, None\n        )\n        log_format = ReportingFormats[log_format_name].value if log_format_name else fallback_format\n        log_format = log_format.format(custom_args=custom_args)  # should work even if no {custom_args}\n\n        ## Attach handlers/formatter ##\n        formatter = logging.Formatter(log_format)\n        handler.setFormatter(formatter)\n        handler.setLevel(log_level)\n        self.logger.addHandler(handler)\n        if not self.logger.isEnabledFor(logging.getLevelName(log_level)): # make sure logger level is not lower than handler level\n            self.logger.setLevel(log_level)\n\n        ## Save info about handler created ##\n        self.log_info.append(handler_name + ' @ ' + str(log_level))\n        self.log_handlers.append(handler)", "response": "Configure the common logging configuration for the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_default_logger(\n            self,\n            log_freq='midnight',\n            log_total=30,\n            log_level='INFO',\n            log_format=ReportingFormats.DEFAULT.value,\n            custom_args=''\n    ):\n        \"\"\"default logger that every Prosper script should use!!\n\n        Args:\n            log_freq (str): TimedRotatingFileHandle_str -- https://docs.python.org/3/library/logging.handlers.html#timedrotatingfilehandler\n            log_total (int): how many log_freq periods between log rotations\n            log_level (str): minimum desired log level https://docs.python.org/3/library/logging.html#logging-levels\n            log_format (str): format for logging messages https://docs.python.org/3/library/logging.html#logrecord-attributes\n            custom_args (str): special ID to include in (ALL) messages\n\n        \"\"\"\n        ## Override defaults if required ##\n        log_freq  = self.config.get_option(\n            'LOGGING', 'log_freq',\n            None, log_freq\n        )\n        log_total = self.config.get_option(\n            'LOGGING', 'log_total',\n            None, log_total\n        )\n\n        ## Set up log file handles/name ##\n        log_filename = self.log_name + '.log'\n        log_abspath = path.join(self.log_path, log_filename)\n        general_handler = TimedRotatingFileHandler(\n            log_abspath,\n            when=log_freq,\n            interval=1,\n            backupCount=int(log_total)\n        )\n\n        self._configure_common(\n            '',\n            log_level,\n            log_format,\n            'default',\n            general_handler,\n            custom_args=custom_args\n        )", "response": "Configure the default logger that every Prosper script should use!!"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconfiguring debug logger for stdout messages.", "response": "def configure_debug_logger(\n            self,\n            log_level='DEBUG',\n            log_format=ReportingFormats.STDOUT.value,\n            custom_args=''\n    ):\n        \"\"\"debug logger for stdout messages.  Replacement for print()\n\n        Note:\n            Will try to overwrite minimum log level to enable requested log_level\n\n        Args:\n            log_level (str): desired log level for handle https://docs.python.org/3/library/logging.html#logging-levels\n            log_format (str): format for logging messages https://docs.python.org/3/library/logging.html#logrecord-attributes\n            custom_args (str): special ID to include in messages\n\n        \"\"\"\n        self._configure_common(\n            'debug_',\n            log_level,\n            log_format,\n            'Debug',\n            logging.StreamHandler(),\n            custom_args=custom_args\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure the discord logger for sending messages to the Hipchat server.", "response": "def configure_discord_logger(\n            self,\n            discord_webhook=None,\n            discord_recipient=None,\n            log_level='ERROR',\n            log_format=ReportingFormats.PRETTY_PRINT.value,\n            custom_args=''\n    ):\n        \"\"\"logger for sending messages to Discord.  Easy way to alert humans of issues\n\n        Note:\n            Will try to overwrite minimum log level to enable requested log_level\n            Will warn and not attach hipchat logger if missing webhook key\n            Learn more about webhooks: https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks\n\n        Args:\n            discord_webhook (str): discord room webhook (full URL)\n            discord_recipient (`str`:<@int>, optional): user/group to notify\n            log_level (str): desired log level for handle https://docs.python.org/3/library/logging.html#logging-levels\n            log_format (str): format for logging messages https://docs.python.org/3/library/logging.html#logrecord-attributes\n            custom_args (str): special ID to include in messages\n\n        \"\"\"\n        # Override defaults if required #\n        discord_webhook = self.config.get_option(\n            'LOGGING', 'discord_webhook',\n            None, discord_webhook\n        )\n        discord_recipient = self.config.get_option(\n            'LOGGING', 'discord_recipient',\n            None, discord_recipient\n        )\n        log_level = self.config.get_option(\n            'LOGGING', 'discord_level',\n            None, log_level\n        )\n\n        # Actually build discord logging handler #\n        discord_obj = DiscordWebhook()\n        discord_obj.webhook(discord_webhook)\n\n        # vv TODO vv: Test review #\n        if discord_obj.can_query:\n            discord_handler = HackyDiscordHandler(\n                discord_obj,\n                discord_recipient\n            )\n            self._configure_common(\n                'discord_',\n                log_level,\n                log_format,\n                'Discord',\n                discord_handler,\n                custom_args=custom_args\n            )\n        else:\n            warnings.warn(\n                'Unable to execute webhook',\n                exceptions.WebhookCreateFailed\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef configure_slack_logger(\n            self,\n            slack_webhook=None,\n            log_level='ERROR',\n            log_format=ReportingFormats.SLACK_PRINT.value,\n            custom_args=''\n    ):\n        \"\"\"logger for sending messages to Slack.  Easy way to alert humans of issues\n\n        Note:\n            Will try to overwrite minimum log level to enable requested log_level\n            Will warn and not attach hipchat logger if missing webhook key\n            Learn more about webhooks: https://api.slack.com/docs/message-attachments\n        Args:\n            slack_webhook (str): slack bot webhook (full URL)\n            log_level (str): desired log level for handle https://docs.python.org/3/library/logging.html#logging-levels\n            log_format (str): format for logging messages https://docs.python.org/3/library/logging.html#logrecord-attributes\n            custom_args (str): special ID to include in messages\n\n        \"\"\"\n        # Override defaults if required #\n        slack_webhook = self.config.get_option(\n            'LOGGING', 'slack_webhook',\n            None, slack_webhook\n        )\n        log_level = self.config.get_option(\n            'LOGGING', 'slack_level',\n            None, log_level\n        )\n\n        # Actually build slack logging handler #\n        # vv TODO vv: Test review #\n        slack_handler = HackySlackHandler(\n            slack_webhook\n        )\n        self._configure_common(\n            'slack_',\n            log_level,\n            log_format,\n            'Slack',\n            slack_handler,\n            custom_args=custom_args\n        )", "response": "Configure slack logger for sending messages to Slack."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconfigure HipChat logger for sending messages to HipChat.", "response": "def configure_hipchat_logger(\n            self,\n            hipchat_webhook=None,\n            log_level='ERROR',\n            log_format=ReportingFormats.PRETTY_PRINT.value,\n            custom_args=''\n    ):\n        \"\"\"logger for sending messages to HipChat.  Easy way to alert humans of issues\n\n        Note:\n            Will try to overwrite minimum log level to enable requested log_level\n            Will warn and not attach hipchat logger if missing webhook key\n            Learn more about webhooks: https://yak.crowdstrike.com/addons/byo\n        Args:\n            hipchat_webhook (str): slack bot webhook (full URL)\n            log_level (str): desired log level for handle https://docs.python.org/3/library/logging.html#logging-levels\n            log_format (str): format for logging messages https://docs.python.org/3/library/logging.html#logrecord-attributes\n            custom_args (str): special ID to include in messages\n\n        \"\"\"\n        # Override defaults if required #\n        hipchat_webhook = self.config.get_option(\n            'LOGGING', 'hipchat_webhook',\n            None, hipchat_webhook\n        )\n        log_level = self.config.get_option(\n            'LOGGING', 'hipchat_level',\n            None, log_level\n        )\n\n        # Actually build HipChat logging handler #\n        # vv TODO vv: Test review #\n        try:\n            hipchat_handler = HackyHipChatHandler(\n                hipchat_webhook\n            )\n            self._configure_common(\n                'hipchat_',\n                log_level,\n                log_format,\n                'HipChat',\n                hipchat_handler,\n                custom_args=custom_args\n            )\n        except Exception as error_msg:\n            raise error_msg"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads object with webhook_url", "response": "def webhook(self, webhook_url):\n        \"\"\"Load object with webhook_url\n\n        Args:\n            webhook_url (str): full webhook url given by Discord 'create webhook' func\n\n        \"\"\"\n        if not webhook_url:\n            raise Exception('Url can not be None')\n\n        matcher = re.match(self.__webhook_url_format, webhook_url)\n        if not matcher:\n            raise Exception('Invalid url format, looking for: ' + self.__webhook_url_format)\n\n        self.api_keys(int(matcher.group(1)), matcher.group(2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef api_keys(self, serverid, api_key):\n        if serverid and api_key:\n            self.can_query = True # Yes, we _are_ (will be) configured\n        self.serverid = int(serverid)\n        self.api_key = api_key\n        self.webhook_url = self.__base_url + str(self.serverid) + '/' + self.api_key", "response": "Load object with id and API key pair."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls by the logging module to execute logging message", "response": "def emit(self, record):  # pragma: no cover\n        \"\"\"required classmethod for logging to execute logging message\"\"\"\n        if record.exc_text:\n            record.exc_text = '```python\\n{0}\\n```'.format(record.exc_text) # recast to code block\n        log_msg = self.format(record)\n        if len(log_msg) + self.alert_length > DISCORD_MESSAGE_LIMIT:\n            log_msg = log_msg[:(DISCORD_MESSAGE_LIMIT - DISCORD_PAD_SIZE)]\n\n        if self.alert_recipient and record.levelno == logging.CRITICAL:\n            log_msg = log_msg + '\\n' + str(self.alert_recipient)\n\n        self.send_msg_to_webhook(log_msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_msg_to_webhook(self, message):\n        payload = {\n            'content':message\n        }\n\n        header = {\n            'Content-Type':'application/json'\n        }\n\n        try:\n            request = requests.post(\n                self.api_url,\n                headers=header,\n                json=payload\n            )\n            request.raise_for_status()\n        except Exception as error_msg:  #pragma: no cover\n            warning_msg = (\n                'EXCEPTION: UNABLE TO COMMIT LOG MESSAGE' +\n                '\\n\\texception={0}'.format(repr(error_msg)) +\n                '\\n\\tmessage={0}'.format(message)\n            )\n            warnings.warn(\n                warning_msg,\n                exceptions.WebhookFailedEmitWarning\n            )", "response": "Sends a message to the webhook"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decorate(self, record):\n        attachments = {}\n        ## Set color\n        if record.levelno >= logging.ERROR:\n            attachments['color'] = 'warning' #builtin\n        if record.levelno >= logging.CRITICAL:\n            attachments['color'] = 'danger' #builtin\n\n        ## Log text\n        attach_text = '{levelname}: {name} {module}.{funcName}:{lineno}'.format(\n            levelname=record.levelname,\n            name=record.name,\n            module=record.module,\n            funcName=record.funcName,\n            lineno=record.lineno\n        )\n        attachments['text'] = attach_text\n        attachments['fallback'] = attach_text\n        return attachments", "response": "add slack - specific flourishes to responses\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_msg_to_webhook(self, json_payload, log_msg):\n        if SILENCE_OVERRIDE:  # pragma: no cover\n            return\n\n        payload = {\n            'text': log_msg,\n            'attachments':[json_payload]\n        }\n        header = {\n            'Content-Type':'application/json'\n        }\n\n        try:\n            request = requests.post(\n                self.webhook_url,\n                headers=header,\n                json=payload\n            )\n            request.raise_for_status()\n        except Exception as error_msg:  #pragma: no cover\n            warning_msg = (\n                'EXCEPTION: UNABLE TO COMMIT LOG MESSAGE' +\n                '\\n\\texception={0}'.format(repr(error_msg)) +\n                '\\n\\tmessage={0}'.format(log_msg)\n            )\n            warnings.warn(\n                warning_msg,\n                exceptions.WebhookFailedEmitWarning\n            )", "response": "Pushes a message to the Slack API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decorate(self, record):\n        color = 'gray'\n        if record.levelno == logging.WARNING:\n            color = 'yellow'\n        if record.levelno == logging.INFO:\n            color = 'green'\n        if record.levelno == logging.DEBUG:\n            color = 'gray'\n        if record.levelno >= logging.ERROR:\n            color = 'red'\n\n        notify = False\n        if record.levelno >= logging.ERROR:\n            nofiy = True\n\n        payload = {\n            'color': color,\n            'notify': notify,\n            'message_format': 'text'\n        }\n\n        return payload", "response": "Build up HipChat specific values for log record"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a log message to the webhook.", "response": "def send_msg_to_webhook(\n            self,\n            json_payload,\n            log_msg\n    ):\n        \"\"\"todo\"\"\"\n        if SILENCE_OVERRIDE:\n            return\n\n        params = {**json_payload, 'message': log_msg}\n        headers = {'Content-Type': 'application/json'}\n\n        try:\n            req = requests.post(\n                self.webhook_url,\n                headers=headers,\n                json=params\n            )\n            req.raise_for_status()\n        except Exception as error_msg:\n            warning_msg = (\n                'EXCEPTION: UNABLE TO COMMIT LOG MESSAGE' +\n                '\\n\\texception={0}'.format(repr(error_msg)) +\n                '\\n\\tmessage={0}'.format(log_msg)\n            )\n            warnings.warn(\n                warning_msg,\n                exceptions.WebhookFailedEmitWarning\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the list of Networks mapped to the account in the specified datacenter.", "response": "def GetNetworks(alias=None,location=None):\n\t\t\"\"\"Gets the list of Networks mapped to the account in the specified datacenter.\n\n\t\thttps://t3n.zendesk.com/entries/21024721-Get-Networks\n\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param location: datacenter where group resides.  If none will use account's primary datacenter\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tr = clc.v1.API.Call('post','Network/GetAccountNetworks', { 'AccountAlias': alias, 'Location': location })\n\t\tif int(r['StatusCode']) == 0:  return(r['Networks'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the details for a Network and its IP Addresses.", "response": "def GetNetworkDetails(network,alias=None,location=None):\n\t\t\"\"\"Gets the details for a Network and its IP Addresses.\n\n\t\thttps://t3n.zendesk.com/entries/21726312-Get-Network-Details\n\n\t\t:param network: network name\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param location: datacenter where group resides.  If none will use account's primary datacenter\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tr = clc.v1.API.Call('post','Network/GetNetworkDetails', { 'AccountAlias': alias, 'Location': location, 'Name': network })\n\t\tif int(r['StatusCode']) == 0:  return(r['NetworkDetails']['IPAddresses'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_variable_from_exception(exception, variable_name):\n    for frame in reversed(trace()):\n        try:\n            # From http://stackoverflow.com/a/9059407/6461688\n            frame_variable = frame[0].f_locals[variable_name]\n        except KeyError:\n            pass\n        else:\n            return frame_variable\n    else:\n        raise KeyError(\"Variable '%s' not in any stack frames\", variable_name)", "response": "Get the variable from the closest frame in the stack"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the key from the keyring and the Key and Address objects from the database", "response": "def force_delete_key(address):\n    \"\"\"\n    Delete the key from the keyring and the Key and Address objects from the\n    database\n    \"\"\"\n    address_object = Address.objects.get(address=address)\n    address_object.key.delete()\n    address_object.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __wrap_accepted_val(self, value):\n        if isinstance(value, tuple):\n            value = list(value)\n        elif not isinstance(value, list):\n            value = [value]\n        return value", "response": "Wrap accepted value in list if not wrapped."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nscan function for function and arguments.", "response": "def __scan_func(self, args_info):\n        \"\"\"Collect information about accepted arguments in following format:\n            (\n                (<argument name>, <accepted types and values>),\n                (<argument name>, <accepted types and values>),\n                ...\n            )\n\n        Args:\n            args_info (inspect.FullArgSpec): Information about function\n                arguments.\n        \"\"\"\n        # Process args.\n        for i, accepted_arg_vals in enumerate(self.accepted_arg_values):\n            # Wrap each accepted value in the list if yet not wrapped.\n            accepted_arg_vals = self.__wrap_accepted_val(accepted_arg_vals)\n            # Add default value (if exists) in list of accepted values.\n            if args_info.defaults:\n                def_range = len(args_info.defaults) - len(args_info.args[i:])\n                if def_range >= 0:\n                    self.optional_args.append(i)\n                    accepted_value = args_info.defaults[def_range]\n                    accepted_arg_vals.append(accepted_value)\n            # Try to detect current argument name.\n            if len(args_info.args) > i:\n                arg_name = args_info.args[i]\n            else:\n                arg_name = None\n                self.optional_args.append(i)\n            # Save info about current argument and his accepted values.\n            self.accepted_args.append((arg_name, accepted_arg_vals))\n        # Process kwargs.\n        for arg_name, accepted_arg_vals in self.accepted_kwargs_values.items():\n            # Wrap each accepted value in the list if yet not wrapped.\n            accepted_arg_vals = self.__wrap_accepted_val(accepted_arg_vals)\n            # Mark current argument as optional.\n            i = len(self.accepted_args)\n            self.optional_args.append(i)\n            # Save info about current argument and his accepted values.\n            self.accepted_args.append((arg_name, accepted_arg_vals))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __validate_args(self, func_name, args, kwargs):\n        from pyvalid.validators import Validator\n        for i, (arg_name, accepted_values) in enumerate(self.accepted_args):\n            if i < len(args):\n                value = args[i]\n            else:\n                if arg_name in kwargs:\n                    value = kwargs[arg_name]\n                elif i in self.optional_args:\n                    continue\n                else:\n                    raise InvalidArgumentNumberError(func_name)\n            is_valid = False\n            for accepted_val in accepted_values:\n                is_validator = (\n                    isinstance(accepted_val, Validator) or\n                    (\n                        isinstance(accepted_val, MethodType) and\n                        hasattr(accepted_val, '__func__') and\n                        isinstance(accepted_val.__func__, Validator)\n                    )\n                )\n                if is_validator:\n                    is_valid = accepted_val(value)\n                elif isinstance(accepted_val, type):\n                    is_valid = isinstance(value, accepted_val)\n                else:\n                    is_valid = value == accepted_val\n                if is_valid:\n                    break\n            if not is_valid:\n                ord_num = self.__ordinal(i + 1)\n                raise ArgumentValidationError(\n                    ord_num,\n                    func_name,\n                    value,\n                    accepted_values\n                )", "response": "Validate the arguments of the function func_name with the list of accepted values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __ordinal(self, num):\n        if 10 <= num % 100 < 20:\n            return str(num) + 'th'\n        else:\n            ord_info = {1: 'st', 2: 'nd', 3: 'rd'}.get(num % 10, 'th')\n            return '{}{}'.format(num, ord_info)", "response": "Returns the ordinal number of a given integer as a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a file from the local store.", "response": "def get_file(self, name, save_to, add_to_cache=True,\n                 force_refresh=False, _lock_exclusive=False):\n        \"\"\"Retrieves file identified by ``name``.\n\n           The file is saved as ``save_to``. If ``add_to_cache`` is ``True``,\n           the file is added to the local store. If ``force_refresh`` is\n           ``True``, local cache is not examined if a remote store is\n           configured.\n\n           If a remote store is configured, but ``name`` does not contain a\n           version, the local data store is not used, as we cannot guarantee\n           that the version there is fresh.\n\n           Local data store implemented in :class:`LocalDataStore` tries to not\n           copy the entire file to ``save_to`` if possible, but instead uses\n           hardlinking. Therefore you should not modify the file if you don't\n           want to totally blow something.\n\n           This method returns the full versioned name of the retrieved file.\n        \"\"\"\n\n        uname, version = split_name(name)\n\n        lock = None\n        if self.local_store:\n            lock = self.lock_manager.lock_for(uname)\n            if _lock_exclusive:\n                lock.lock_exclusive()\n            else:\n                lock.lock_shared()\n        else:\n            add_to_cache = False\n\n        t = time.time()\n        logger.debug('    downloading %s', name)\n        try:\n            if not self.remote_store or (version is not None\n                                         and not force_refresh):\n                try:\n                    if self.local_store and self.local_store.exists(name):\n                        return self.local_store.get_file(name, save_to)\n                except Exception:\n                    if self.remote_store:\n                        logger.warning(\"Error getting '%s' from local store\",\n                                name, exc_info=True)\n                    else:\n                        raise\n            if self.remote_store:\n                if not _lock_exclusive and add_to_cache:\n                    if lock:\n                        lock.unlock()\n                    return self.get_file(name, save_to, add_to_cache,\n                                         _lock_exclusive=True)\n                vname = self.remote_store.get_file(name, save_to)\n                if add_to_cache:\n                    self._add_to_cache(vname, save_to)\n                return vname\n            raise FiletrackerError(\"File not available: %s\" % name)\n        finally:\n            if lock:\n                lock.close()\n            logger.debug('    processed %s in %.2fs', name, time.time() - t)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a file identified by name in streaming mode.", "response": "def get_stream(self, name, force_refresh=False, serve_from_cache=False):\n        \"\"\"Retrieves file identified by ``name`` in streaming mode.\n\n           Works like :meth:`get_file`, except that returns a tuple\n           (file-like object, versioned name).\n\n           When both remote_store and local_store are present, serve_from_cache\n           can be used to ensure that the file will be downloaded and served\n           from a local cache. If a full version is specified and the file\n           exists in the cache a file will be always served locally.\n        \"\"\"\n\n        uname, version = split_name(name)\n\n        lock = None\n        if self.local_store:\n            lock = self.lock_manager.lock_for(uname)\n            lock.lock_shared()\n\n        try:\n            if not self.remote_store or (version is not None\n                                         and not force_refresh):\n                try:\n                    if self.local_store and self.local_store.exists(name):\n                        return self.local_store.get_stream(name)\n                except Exception:\n                    if self.remote_store:\n                        logger.warning(\"Error getting '%s' from local store\",\n                                       name, exc_info=True)\n                    else:\n                        raise\n            if self.remote_store:\n                if self.local_store and serve_from_cache:\n                    if version is None:\n                        version = self.remote_store.file_version(name)\n                        if version:\n                            name = versioned_name(uname, version)\n                    if force_refresh or not self.local_store.exists(name):\n                        (stream, vname) = self.remote_store.get_stream(name)\n                        name = self.local_store.add_stream(vname, stream)\n                    return self.local_store.get_stream(name)\n                return self.remote_store.get_stream(name)\n            raise FiletrackerError(\"File not available: %s\" % name)\n        finally:\n            if lock:\n                lock.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the newest available version number of the file.", "response": "def file_version(self, name):\n        \"\"\"Returns the newest available version number of the file.\n\n           If the remote store is configured, it is queried, otherwise\n           the local version is returned. It is assumed that the remote store\n           always has the newest version of the file.\n\n           If version is a part of ``name``, it is ignored.\n        \"\"\"\n\n        if self.remote_store:\n            return self.remote_store.file_version(name)\n        else:\n            return self.local_store.file_version(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef file_size(self, name, force_refresh=False):\n\n        uname, version = split_name(name)\n\n        t = time.time()\n        logger.debug('    querying size of %s', name)\n        try:\n            if not self.remote_store or (version is not None\n                                         and not force_refresh):\n                try:\n                    if self.local_store and self.local_store.exists(name):\n                        return self.local_store.file_size(name)\n                except Exception:\n                    if self.remote_store:\n                        logger.warning(\"Error getting '%s' from local store\",\n                                       name, exc_info=True)\n                    else:\n                        raise\n            if self.remote_store:\n                return self.remote_store.file_size(name)\n            raise FiletrackerError(\"File not available: %s\" % name)\n        finally:\n            logger.debug('    processed %s in %.2fs', name, time.time() - t)", "response": "Returns the size of the file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a file to the filetracker under the given name.", "response": "def put_file(self,\n                 name,\n                 filename,\n                 to_local_store=True,\n                 to_remote_store=True,\n                 compress_hint=True):\n        \"\"\"Adds file ``filename`` to the filetracker under the name ``name``.\n\n           If the file already exists, a new version is created. In practice\n           if the store does not support versioning, the file is overwritten.\n\n           The file may be added to local store only (if ``to_remote_store`` is\n           ``False``), to remote store only (if ``to_local_store`` is\n           ``False``) or both. If only one store is configured, the values of\n           ``to_local_store`` and ``to_remote_store`` are ignored.\n\n           Local data store implemented in :class:`LocalDataStore` tries to not\n           directly copy the data to the final cache destination, but uses\n           hardlinking. Therefore you should not modify the file in-place\n           later as this would be disastrous.\n\n           If ``compress_hint`` is set to False, file is compressed on\n           the server, instead of the client. This is generally not\n           recommended, unless you know what you're doing.\n        \"\"\"\n\n        if not to_local_store and not to_remote_store:\n            raise ValueError(\"Neither to_local_store nor to_remote_store set \"\n                             \"in a call to filetracker.Client.put_file\")\n\n        check_name(name)\n\n        lock = None\n        if self.local_store:\n            lock = self.lock_manager.lock_for(name)\n            lock.lock_exclusive()\n\n        try:\n            if (to_local_store or not self.remote_store) and self.local_store:\n                versioned_name = self.local_store.add_file(name, filename)\n            if (to_remote_store or not self.local_store) and self.remote_store:\n                versioned_name = self.remote_store.add_file(\n                        name, filename, compress_hint=compress_hint)\n        finally:\n            if lock:\n                lock.close()\n\n        return versioned_name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_file(self, name):\n        if self.local_store:\n            lock = self.lock_manager.lock_for(name)\n            lock.lock_exclusive()\n            try:\n                self.local_store.delete_file(name)\n            finally:\n                lock.close()\n        if self.remote_store:\n            self.remote_store.delete_file(name)", "response": "Deletes the file identified by name along with its metadata."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn list of all stored local files.", "response": "def list_local_files(self):\n        \"\"\"Returns list of all stored local files.\n\n            Each element of this list is of :class:`DataStore.FileInfoEntry`\n            type.\n        \"\"\"\n        result = []\n        if self.local_store:\n            result.extend(self.local_store.list_files())\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks all the things in the tree tree.", "response": "def check(operations, loud=False):\n    \"\"\"Check all the things\n\n    :param operations: The operations to check\n    :param loud: `True` if checkers should prettyprint their status to stderr. `False` otherwise.\n    :returns: A tuple of overall success, and a detailed execution log for all the operations\n\n    \"\"\"\n    if not CHECKERS:\n        load_checkers()\n    roll_call = []\n    everything_ok = True\n    if loud and operations:\n        title = \"Preflyt Checklist\"\n        sys.stderr.write(\"{}\\n{}\\n\".format(title, \"=\" * len(title)))\n    for operation in operations:\n        if operation.get('checker') not in CHECKERS:\n            raise CheckerNotFoundError(operation)\n        checker_cls = CHECKERS[operation['checker']]\n        args = {k: v for k, v in operation.items() if k != 'checker'}\n        checker = checker_cls(**args)\n        success, message = checker.check()\n        if not success:\n            everything_ok = False\n        roll_call.append({\"check\": operation, \"success\": success, \"message\": message})\n        if loud:\n            sys.stderr.write(\" {}\\n\".format(pformat_check(success, operation, message)))\n    return everything_ok, roll_call"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify(operations, loud=False):\n    everything_ok, roll_call = check(operations, loud=loud)\n    if not everything_ok:\n        raise CheckFailedException(roll_call)\n    return roll_call", "response": "Check all the things and be assertive about it\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnormalizing a number to range [ lower upper ) or [ lower upper ).", "response": "def normalize(num, lower=0, upper=360, b=False):\n    \"\"\"Normalize number to range [lower, upper) or [lower, upper].\n\n    Parameters\n    ----------\n    num : float\n        The number to be normalized.\n    lower : int\n        Lower limit of range. Default is 0.\n    upper : int\n        Upper limit of range. Default is 360.\n    b : bool\n        Type of normalization. Default is False. See notes.\n\n        When b=True, the range must be symmetric about 0.\n        When b=False, the range must be symmetric about 0 or ``lower`` must\n        be equal to 0.\n\n    Returns\n    -------\n    n : float\n        A number in the range [lower, upper) or [lower, upper].\n\n    Raises\n    ------\n    ValueError\n      If lower >= upper.\n\n    Notes\n    -----\n    If the keyword `b == False`, then the normalization is done in the\n    following way. Consider the numbers to be arranged in a circle,\n    with the lower and upper ends sitting on top of each other. Moving\n    past one limit, takes the number into the beginning of the other\n    end. For example, if range is [0 - 360), then 361 becomes 1 and 360\n    becomes 0. Negative numbers move from higher to lower numbers. So,\n    -1 normalized to [0 - 360) becomes 359.\n\n    When b=False range must be symmetric about 0 or lower=0.\n\n    If the keyword `b == True`, then the given number is considered to\n    \"bounce\" between the two limits. So, -91 normalized to [-90, 90],\n    becomes -89, instead of 89. In this case the range is [lower,\n    upper]. This code is based on the function `fmt_delta` of `TPM`.\n\n    When b=True range must be symmetric about 0.\n\n    Examples\n    --------\n    >>> normalize(-270,-180,180)\n    90.0\n    >>> import math\n    >>> math.degrees(normalize(-2*math.pi,-math.pi,math.pi))\n    0.0\n    >>> normalize(-180, -180, 180)\n    -180.0\n    >>> normalize(180, -180, 180)\n    -180.0\n    >>> normalize(180, -180, 180, b=True)\n    180.0\n    >>> normalize(181,-180,180)\n    -179.0\n    >>> normalize(181, -180, 180, b=True)\n    179.0\n    >>> normalize(-180,0,360)\n    180.0\n    >>> normalize(36,0,24)\n    12.0\n    >>> normalize(368.5,-180,180)\n    8.5\n    >>> normalize(-100, -90, 90)\n    80.0\n    >>> normalize(-100, -90, 90, b=True)\n    -80.0\n    >>> normalize(100, -90, 90, b=True)\n    80.0\n    >>> normalize(181, -90, 90, b=True)\n    -1.0\n    >>> normalize(270, -90, 90, b=True)\n    -90.0\n    >>> normalize(271, -90, 90, b=True)\n    -89.0\n    \"\"\"\n    if lower >= upper:\n        ValueError(\"lower must be lesser than upper\")\n    if not b:\n        if not ((lower + upper == 0) or (lower == 0)):\n            raise ValueError('When b=False lower=0 or range must be symmetric about 0.')\n    else:\n        if not (lower + upper == 0):\n            raise ValueError('When b=True range must be symmetric about 0.')\n\n    from math import floor, ceil\n    # abs(num + upper) and abs(num - lower) are needed, instead of\n    # abs(num), since the lower and upper limits need not be 0. We need\n    # to add half size of the range, so that the final result is lower +\n    # <value> or upper - <value>, respectively.\n    res = num\n    if not b:\n        res = num\n        if num > upper or num == lower:\n            num = lower + abs(num + upper) % (abs(lower) + abs(upper))\n        if num < lower or num == upper:\n            num = upper - abs(num - lower) % (abs(lower) + abs(upper))\n\n        res = lower if num == upper else num\n    else:\n        total_length = abs(lower) + abs(upper)\n        if num < -total_length:\n            num += ceil(num / (-2 * total_length)) * 2 * total_length\n        if num > total_length:\n            num -= floor(num / (2 * total_length)) * 2 * total_length\n        if num > upper:\n            num = total_length - num\n        if num < lower:\n            num = -total_length - num\n\n        res = num\n\n    res *= 1.0  # Make all numbers float, to be consistent\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a decimal number into sexagesimal representation.", "response": "def deci2sexa(deci, pre=3, trunc=False, lower=None, upper=None,\n              b=False, upper_trim=False):\n    \"\"\"Returns the sexagesimal representation of a decimal number.\n\n    Parameters\n    ----------\n    deci : float\n        Decimal number to be converted into sexagesimal. If `lower` and\n        `upper` are given then the number is normalized to the given\n        range before converting to sexagesimal.\n    pre : int\n        The last part of the sexagesimal number is rounded to these\n        many decimal places. This can be negative. Default is 3.\n    trunc : bool\n        If True then the last part of the sexagesimal number is\n        truncated and not rounded to `pre` decimal places. Default is\n        False.\n    lower : int\n        Lower bound of range to which number is to be normalized.\n    upper : int\n        Upper bound of range to which number is to be normalized.\n    b : bool\n        Affects type of normalization. See docstring for `normalize`.\n    upper_trim : bool\n        If `lower` and `upper` are given and this is True, then if the\n        first part of the sexagesimal number is equal to `upper`, it is\n        replaced with `lower` (value used is int(lower)). This converts numbers\n        such as \"24 00 00.000\" to \"00 00 00.000\". Default value is False.\n\n    Returns\n    -------\n    s : 4 element tuple; (int, int, int, float)\n        A tuple of sign and the three parts of the sexagesimal\n        number. Sign is 1 for positive and -1 for negative values. The\n        sign applies to the whole angle and not to any single part,\n        i.e., all parts are positive and the sign multiplies the\n        angle. The first and second parts of the sexagesimal number are\n        integers and the last part is a float.\n\n    Notes\n    -----\n    The given decimal number `deci` is converted into a sexagesimal\n    number. The last part of the sexagesimal number is rounded to `pre`\n    number of decimal points. If `trunc == True` then instead of\n    rounding, the last part is truncated.\n\n    If `lower` and `upper` are given then the number is normalized to\n    the given range before converting into sexagesimal format. The `b`\n    argument determines the type of normalization. See docstring of the\n    `normalize` function for details.\n\n    If `upper_trim` is True then, if after convertion to sexagesimal\n    the first part is equal to `upper`, it is replaced with `lower` (value used\n    is int(lower)). This is useful in cases where numbers such as \"24 00 00.00\"\n    needs to be converted into \"00 00 00.00\"\n\n    The returned sign, first element of tuple, applies to the whole\n    number and not just to a single part.\n\n    Examples\n    --------\n    >>> deci2sexa(-11.2345678)\n    (-1, 11, 14, 4.444)\n    >>> deci2sexa(-11.2345678, pre=5)\n    (-1, 11, 14, 4.44408)\n    >>> deci2sexa(-11.2345678, pre=4)\n    (-1, 11, 14, 4.4441)\n    >>> deci2sexa(-11.2345678, pre=4, trunc=True)\n    (-1, 11, 14, 4.444)\n\n    >>> deci2sexa(-11.2345678, pre=1)\n    (-1, 11, 14, 4.4)\n    >>> deci2sexa(-11.2345678, pre=0)\n    (-1, 11, 14, 4.0)\n    >>> deci2sexa(-11.2345678, pre=-1)\n    (-1, 11, 14, 0.0)\n\n    >>> x = 23+59/60.0+59.99999/3600.0\n\n    To 3 decimal places, this number is 24 or 0 hours.\n\n    >>> deci2sexa(x, pre=3, lower=0, upper=24, upper_trim=True)\n    (1, 0, 0, 0.0)\n    >>> deci2sexa(x, pre=3, lower=0, upper=24, upper_trim=False)\n    (1, 24, 0, 0.0)\n\n    To 5 decimal places, we get back the full value.\n\n    >>> deci2sexa(x, pre=5, lower=0, upper=24, upper_trim=True)\n    (1, 23, 59, 59.99999)\n\n    \"\"\"\n    if lower is not None and upper is not None:\n        deci = normalize(deci, lower=lower, upper=upper, b=b)\n\n    sign = 1\n    if deci < 0:\n        deci = abs(deci)\n        sign = -1\n\n    hd, f1 = divmod(deci, 1)\n    mm, f2 = divmod(f1 * 60.0, 1)\n    sf = f2 * 60.0\n\n    # Find the seconds part to required precision.\n    fp = 10 ** pre\n    if trunc:\n        ss, _ = divmod(sf * fp, 1)\n    else:\n        ss = round(sf * fp, 0)\n\n    ss = int(ss)\n\n    # If ss is 60 to given precision then update mm, and if necessary\n    # hd.\n    if ss == 60 * fp:\n        mm += 1\n        ss = 0\n    if mm == 60:\n        hd += 1\n        mm = 0\n\n    hd = int(hd)\n    mm = int(mm)\n    if lower is not None and upper is not None and upper_trim:\n        # For example 24h0m0s => 0h0m0s.\n        if hd == upper:\n            hd = int(lower)\n\n    if hd == 0 and mm == 0 and ss == 0:\n        sign = 1\n\n    ss /= float(fp)\n    # hd and mm parts are integer values but of type float\n    return (sign, hd, mm, ss)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sexa2deci(sign, hd, mm, ss, todeg=False):\n    divisors = [1.0, 60.0, 3600.0]\n    d = 0.0\n    # sexages[0] is sign.\n    if sign not in (-1, 1):\n        raise ValueError(\"Sign has to be -1 or 1.\")\n\n    sexages = [sign, hd, mm, ss]\n    for i, divis in zip(sexages[1:], divisors):\n        d += i / divis\n\n    # Add proper sign.\n    d *= sexages[0]\n\n    if todeg:\n        d = h2d(d)\n\n    return d", "response": "Combine sexagesimal components into a decimal number."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns sexagesimal string of given angle in degrees or hours.", "response": "def fmt_angle(val, s1=\" \", s2=\" \", s3=\"\", pre=3, trunc=False,\n              lower=None, upper=None, b=False, upper_trim=False):\n    \"\"\"Return sexagesimal string of given angle in degrees or hours.\n\n    Parameters\n    ----------\n    val : float\n        The angle (in degrees or hours) that is to be converted into a\n        sexagesimal string.\n    s1 : str\n        Character to be used between the first and second parts of the\n        the sexagesimal representation.\n    s2 : str\n        Character to be used between the second and third parts of the\n        the sexagesimal representation.\n    s3 : str\n        Character to be used after the third part of the sexagesimal\n        representation.\n    pre : int\n        The final part of the sexagesimal number is rounded to these\n        many decimal places. This can be negative.\n    trunc : bool\n        If True then the third part of the sexagesimal number is\n        truncated to `pre` decimal places, instead of rounding.\n    lower, upper : float\n        If `lower` and `upper` are given then the given value is\n        normalized into the this range before converting to sexagesimal\n        string.\n    b : bool\n        This affect how the normalization is performed. See notes. This\n        works exactly like that for the function `normalize()`.\n    upper_trim : bool\n        If `lower` and `upper` are given, then if the first part of the\n        sexagesimal number equals `upper`, it is replaced with\n        `lower`. For examples, \"12 00 00\" gets turned into \"00 00\n        00\".\n\n    See also\n    --------\n    normalize\n    deci2sexa\n\n    Examples\n    --------\n    >>> fmt_angle(12.348978659, pre=4, trunc=True)\n    '+12 20 56.3231'\n    >>> fmt_angle(12.348978659, pre=5)\n    '+12 20 56.32317'\n    >>> fmt_angle(12.348978659, s1='HH ', s2='MM ', s3='SS', pre=5)\n    '+12HH 20MM 56.32317SS'\n\n    >>> x = 23+59/60.0+59.99999/3600.0\n    >>> fmt_angle(x)\n    '+24 00 00.000'\n    >>> fmt_angle(x, lower=0, upper=24, upper_trim=True)\n    '+00 00 00.000'\n    >>> fmt_angle(x, pre=5)\n    '+23 59 59.99999'\n    >>> fmt_angle(-x, lower=0, upper=24, upper_trim=True)\n    '+00 00 00.000'\n    >>> fmt_angle(-x)\n    '-24 00 00.000'\n\n    \"\"\"\n    x = deci2sexa(val, pre=pre, trunc=trunc, lower=lower, upper=upper,\n                  upper_trim=upper_trim, b=b)\n\n    left_digits_plus_deci_point = 3 if pre > 0 else 2\n    p = \"{3:0\" + \"{0}.{1}\".format(pre + left_digits_plus_deci_point, pre) + \"f}\" + s3\n    p = \"{0}{1:02d}\" + s1 + \"{2:02d}\" + s2 + p\n\n    return p.format(\"-\" if x[0] < 0 else \"+\", *x[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a sexagesimal number and returns a dict containing the sexagesimal number and the sexagesimal number in the sexagesimal number.", "response": "def phmsdms(hmsdms):\n    \"\"\"Parse a string containing a sexagesimal number.\n\n    This can handle several types of delimiters and will process\n    reasonably valid strings. See examples.\n\n    Parameters\n    ----------\n    hmsdms : str\n        String containing a sexagesimal number.\n\n    Returns\n    -------\n    d : dict\n\n        parts : a 3 element list of floats\n            The three parts of the sexagesimal number that were\n            identified.\n        vals : 3 element list of floats\n            The numerical values of the three parts of the sexagesimal\n            number.\n        sign : int\n            Sign of the sexagesimal number; 1 for positive and -1 for\n            negative.\n        units : {\"degrees\", \"hours\"}\n            The units of the sexagesimal number. This is infered from\n            the characters present in the string. If it a pure number\n            then units is \"degrees\".\n\n    Examples\n    --------\n    >>> phmsdms(\"12\") == {\n    ... 'parts': [12.0, None, None],\n    ... 'sign': 1,\n    ... 'units': 'degrees',\n    ... 'vals': [12.0, 0.0, 0.0]\n    ... }\n    True\n\n    >>> phmsdms(\"12h\") == {\n    ... 'parts': [12.0, None, None],\n    ... 'sign': 1,\n    ... 'units': 'hours',\n    ... 'vals': [12.0, 0.0, 0.0]\n    ... }\n    True\n\n    >>> phmsdms(\"12d13m14.56\") == {\n    ... 'parts': [12.0, 13.0, 14.56],\n    ... 'sign': 1,\n    ... 'units': 'degrees',\n    ... 'vals': [12.0, 13.0, 14.56]\n    ... }\n    True\n\n    >>> phmsdms(\"12d13m14.56\") == {\n    ... 'parts': [12.0, 13.0, 14.56],\n    ... 'sign': 1,\n    ... 'units': 'degrees',\n    ... 'vals': [12.0, 13.0, 14.56]\n    ... }\n    True\n\n    >>> phmsdms(\"12d14.56ss\") == {\n    ... 'parts': [12.0, None, 14.56],\n    ... 'sign': 1,\n    ... 'units': 'degrees',\n    ... 'vals': [12.0, 0.0, 14.56]\n    ... }\n    True\n\n    >>> phmsdms(\"14.56ss\") == {\n    ... 'parts': [None, None, 14.56],\n    ... 'sign': 1,\n    ... 'units': 'degrees',\n    ... 'vals': [0.0, 0.0, 14.56]\n    ... }\n    True\n\n    >>> phmsdms(\"12h13m12.4s\") == {\n    ... 'parts': [12.0, 13.0, 12.4],\n    ... 'sign': 1,\n    ... 'units': 'hours',\n    ... 'vals': [12.0, 13.0, 12.4]\n    ... }\n    True\n\n    >>> phmsdms(\"12:13:12.4s\") == {\n    ... 'parts': [12.0, 13.0, 12.4],\n    ... 'sign': 1,\n    ... 'units': 'degrees',\n    ...  'vals': [12.0, 13.0, 12.4]\n    ... }\n    True\n\n    But `phmsdms(\"12:13mm:12.4s\")` will not work.\n\n    \"\"\"\n    units = None\n    sign = None\n    # Floating point regex:\n    # http://www.regular-expressions.info/floatingpoint.html\n    #\n    # pattern1: find a decimal number (int or float) and any\n    # characters following it upto the next decimal number.  [^0-9\\-+]*\n    # => keep gathering elements until we get to a digit, a - or a\n    # +. These three indicates the possible start of the next number.\n    pattern1 = re.compile(r\"([-+]?[0-9]*\\.?[0-9]+[^0-9\\-+]*)\")\n\n    # pattern2: find decimal number (int or float) in string.\n    pattern2 = re.compile(r\"([-+]?[0-9]*\\.?[0-9]+)\")\n\n    hmsdms = hmsdms.lower()\n    hdlist = pattern1.findall(hmsdms)\n\n    parts = [None, None, None]\n\n    def _fill_right_not_none():\n        # Find the pos. where parts is not None. Next value must\n        # be inserted to the right of this. If this is 2 then we have\n        # already filled seconds part, raise exception. If this is 1\n        # then fill 2. If this is 0 fill 1. If none of these then fill\n        # 0.\n        rp = reversed(parts)\n        for i, j in enumerate(rp):\n            if j is not None:\n                break\n        if i == 0:\n            # Seconds part already filled.\n            raise ValueError(\"Invalid string.\")\n        elif i == 1:\n            parts[2] = v\n        elif i == 2:\n            # Either parts[0] is None so fill it, or it is filled\n            # and hence fill parts[1].\n            if parts[0] is None:\n                parts[0] = v\n            else:\n                parts[1] = v\n\n    for valun in hdlist:\n        try:\n            # See if this is pure number.\n            v = float(valun)\n            # Sexagesimal part cannot be determined. So guess it by\n            # seeing which all parts have already been identified.\n            _fill_right_not_none()\n        except ValueError:\n            # Not a pure number. Infer sexagesimal part from the\n            # suffix.\n            if \"hh\" in valun or \"h\" in valun:\n                m = pattern2.search(valun)\n                parts[0] = float(valun[m.start():m.end()])\n                units = \"hours\"\n            if \"dd\" in valun or \"d\" in valun:\n                m = pattern2.search(valun)\n                parts[0] = float(valun[m.start():m.end()])\n                units = \"degrees\"\n            if \"mm\" in valun or \"m\" in valun:\n                m = pattern2.search(valun)\n                parts[1] = float(valun[m.start():m.end()])\n            if \"ss\" in valun or \"s\" in valun:\n                m = pattern2.search(valun)\n                parts[2] = float(valun[m.start():m.end()])\n            if \"'\" in valun:\n                m = pattern2.search(valun)\n                parts[1] = float(valun[m.start():m.end()])\n            if '\"' in valun:\n                m = pattern2.search(valun)\n                parts[2] = float(valun[m.start():m.end()])\n            if \":\" in valun:\n                # Sexagesimal part cannot be determined. So guess it by\n                # seeing which all parts have already been identified.\n                v = valun.replace(\":\", \"\")\n                v = float(v)\n                _fill_right_not_none()\n        if not units:\n            units = \"degrees\"\n\n    # Find sign. Only the first identified part can have a -ve sign.\n    for i in parts:\n        if i and i < 0.0:\n            if sign is None:\n                sign = -1\n            else:\n                raise ValueError(\"Only one number can be negative.\")\n\n    if sign is None:  # None of these are negative.\n        sign = 1\n\n    vals = [abs(i) if i is not None else 0.0 for i in parts]\n\n    return dict(sign=sign, units=units, vals=vals, parts=parts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pposition(hd, details=False):\n    # :TODO: split two angles based on user entered separator and process each part separately.\n    # Split at any character other than a digit, \".\", \"-\", and \"+\".\n    p = re.split(r\"[^\\d\\-+.]*\", hd)\n    if len(p) not in [2, 6]:\n        raise ValueError(\"Input must contain either 2 or 6 numbers.\")\n\n    # Two floating point numbers if string has 2 numbers.\n    if len(p) == 2:\n        x, y = float(p[0]), float(p[1])\n        if details:\n            numvals = 2\n            raw_x = p[0]\n            raw_y = p[1]\n    # Two sexagesimal numbers if string has 6 numbers.\n    elif len(p) == 6:\n        x_p = phmsdms(\" \".join(p[:3]))\n        x = sexa2deci(x_p['sign'], *x_p['vals'])\n        y_p = phmsdms(\" \".join(p[3:]))\n        y = sexa2deci(y_p['sign'], *y_p['vals'])\n        if details:\n            raw_x = x_p\n            raw_y = y_p\n            numvals = 6\n\n    if details:\n        result = dict(x=x, y=y, numvals=numvals, raw_x=raw_x,\n                      raw_y=raw_y)\n    else:\n        result = x, y\n\n    return result", "response": "Parse a string into angular position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sep(a1, b1, a2, b2):\n    # Tolerance to decide if the calculated separation is zero.\n    tol = 1e-15\n\n    v = CartesianVector.from_spherical(1.0, a1, b1)\n    v2 = CartesianVector.from_spherical(1.0, a2, b2)\n    d = v.dot(v2)\n    c = v.cross(v2).mod\n\n    res = math.atan2(c, d)\n\n    if abs(res) < tol:\n        return 0.0\n    else:\n        return res", "response": "Returns the angular separation between two points on a unit sphere."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bear(a1, b1, a2, b2):\n    # Find perpendicular to the plane containing the base and\n    # z-axis. Then find the perpendicular to the plane containing\n    # the base and the target. The angle between these two is the\n    # position angle or bearing of the target w.r.t the base. Check\n    # sign of the z component of the latter vector to determine\n    # quadrant: 1st and 2nd quadrants are +ve while 3rd and 4th are\n    # negative.\n    #\n    # Tolerance to decide if first is on the pole and also to decide if\n    # the calculated bearing is zero.\n    tol = 1e-15\n\n    v1 = CartesianVector.from_spherical(1.0, a1, b1)\n    v2 = CartesianVector.from_spherical(1.0, a2, b2)\n\n    # Z-axis\n    v0 = CartesianVector.from_spherical(r=1.0, alpha=0.0, delta=d2r(90.0))\n\n    if abs(v1.cross(v0).mod) < tol:\n        # The first point is on the pole. Bearing is undefined.\n        warnings.warn(\n            \"First point is on the pole. Bearing undefined.\")\n        return 0.0\n\n    # Vector perpendicular to great circle containing two points.\n    v12 = v1.cross(v2)\n\n    # Vector perpendicular to great circle containing base and\n    # Z-axis.\n    v10 = v1.cross(v0)\n\n    # Find angle between these two vectors.\n    dot = v12.dot(v10)\n    cross = v12.cross(v10).mod\n    x = math.atan2(cross, dot)\n\n    # If z is negative then we are in the 3rd or 4th quadrant.\n    if v12.z < 0:\n        x = -x\n\n    if abs(x) < tol:\n        return 0.0\n    else:\n        return x", "response": "Find the bearing and position angle between two points on a unit sphere."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nnormalizing angles of a point on a sphere. Parameters ---------- alpha: float The alpha (right ascension/longitude like) angle in degrees. delta: float The delta (declination/latitude like) angle in degrees. Returns ------- (alpha, delta): (float, float) Normalized alpha (degrees) and delta (degrees). Notes ----- This function converts given position on a sphere into the simplest normalized values, considering that the points are on a sphere. Input position Output position (180, 91) (0, 89) (180, -91) (0, -89) (0, 91) (180, 89) (0, -91) (180, -89) (120, 280) (120, -80) (h2d(25), 45) (225, 45) (h2d(-25), -45) (345, -45)", "response": "def normalize_sphere(alpha, delta):\n    \"\"\"Normalize angles of a point on a sphere.\n\n    Parameters\n    ----------\n    alpha: float\n        The alpha (right ascension/longitude like) angle in degrees.\n    delta: float\n        The delta (declination/latitude like) angle in degrees.\n\n    Returns\n    -------\n    (alpha, delta): (float, float)\n        Normalized alpha (degrees) and delta (degrees).\n\n    Notes\n    -----\n\n    This function converts given position on a sphere into the simplest\n    normalized values, considering that the points are on a sphere.\n\n    Input position        Output position\n\n    (180, 91)              (0, 89)\n    (180, -91)             (0, -89)\n    (0, 91)                (180, 89)\n    (0, -91)               (180, -89)\n    (120, 280)             (120, -80)\n\n    (h2d(25), 45)          (225, 45)\n    (h2d(-25), -45)        (345, -45)\n    \"\"\"\n    v = CartesianVector.from_spherical(r=1.0, alpha=d2r(alpha), delta=d2r(delta))\n    angles = v.normalized_angles\n    return r2d(angles[0]), r2d(angles[1])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_spherical(cls, r=1.0, alpha=0.0, delta=0.0):\n        x = r * math.cos(delta) * math.cos(alpha)\n        y = r * math.cos(delta) * math.sin(alpha)\n        z = r * math.sin(delta)\n        return cls(x=x, y=y, z=z)", "response": "Construct Cartesian vector from spherical coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the cross product of two sets of attributes.", "response": "def cross(self, v):\n        \"\"\"Cross product of two vectors.\n\n        Parameters\n        ----------\n        v : CartesianVector\n            The vector to take cross product with.\n\n        Returns\n        -------\n        v : CartesianVector\n            Cross product of this vector and the given vector.\n\n        \"\"\"\n        n = self.__class__()\n        n.x = self.y * v.z - self.z * v.y\n        n.y = - (self.x * v.z - self.z * v.x)\n        n.z = self.x * v.y - self.y * v.x\n\n        return n"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the modulus of vector.", "response": "def mod(self):\n        \"\"\"Modulus of vector.\"\"\"\n        return math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the angular spearation between objects in radians.", "response": "def sep(self, p):\n        \"\"\"Angular spearation between objects in radians.\n\n        Parameters\n        ----------\n        p : AngularPosition\n            The object to which the separation from the current object\n            is to be calculated.\n\n        Notes\n        -----\n        This method calls the function sep(). See its docstring for\n        details.\n\n        See also\n        --------\n        sep\n\n        \"\"\"\n        return sep(self.alpha.r, self.delta.r, p.alpha.r, p.delta.r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds position angle between objects in radians.", "response": "def bear(self, p):\n        \"\"\"Find position angle between objects, in radians.\n\n        Parameters\n        ----------\n        p : AngularPosition\n            The object to which bearing must be determined.\n\n        Notes\n        -----\n        This method calls the function bear(). See its docstring for\n        details.\n\n        See also\n        --------\n        bear\n\n        \"\"\"\n        return bear(self.alpha.r, self.delta.r, p.alpha.r, p.delta.r)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the object to KAF", "response": "def to_kaf(self):\n        \"\"\"\n        Converts the object to KAF (if it is NAF)\n        \"\"\"\n        if self.type == 'NAF':\n            self.type = 'KAF'\n            for node in self.__get_node_terms():\n                node.set('cid', node.get('id'))\n                del node.attrib['id']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the chunk object for the supplied identifier", "response": "def get_chunk(self, chunk_id):\n        \"\"\"\n        Returns the chunk object for the supplied identifier\n        @type chunk_id: string\n        @param chunk_id: chunk identifier\n        \"\"\"\n        if chunk_id in self.idx:\n            return Cchunk(self.idx[chunk_id], self.type)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a chunk object to the layer", "response": "def add_chunk(self, chunk_obj):\n        \"\"\"\n        Adds a chunk object to the layer\n        @type chunk_obj: L{Cchunk}\n        @param chunk_obj: the chunk object\n        \"\"\"\n        if chunk_obj.get_id() in self.idx:\n            raise ValueError(\"Chunk with id {} already exists!\"\n                             .format(chunk_obj.get_id()))\n        self.node.append(chunk_obj.get_node())\n        self.idx[chunk_obj.get_id()] = chunk_obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef display_col_dp(dp_list, attr_name):\n\n    print()\n    print(\"---------- {:s} ----------\".format(attr_name))\n    print([getattr(dp, attr_name) for dp in dp_list])", "response": "display a value assocciated with an attribute for each DataProperty instance in dp_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_compat_str(in_str):\n    assert isinstance(in_str, (bytes, str, unicode))\n    if not in_str:\n        return unicode()\n\n    # Chardet in Py2 works on str + bytes objects\n    if IS_PY2 and isinstance(in_str, unicode):\n        return in_str\n\n    # Chardet in Py3 works on bytes objects\n    if not IS_PY2 and not isinstance(in_str, bytes):\n        return in_str\n\n    # Detect the encoding now\n    enc = chardet.detect(in_str)\n\n    # Decode the object into a unicode object\n    out_str = in_str.decode(enc['encoding'])\n\n    # Cleanup: Sometimes UTF-16 strings include the BOM\n    if enc['encoding'] == \"UTF-16BE\":\n        # Remove byte order marks (BOM)\n        if out_str.startswith('\\ufeff'):\n            out_str = out_str[1:]\n\n    # Return the decoded string\n    return out_str", "response": "Try to guess encoding of str and decode it into a unicode object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_message_headers(msg_headers):\n    '''\n    Decode MIME encoded-word headers\n    https://en.wikipedia.org/wiki/MIME#Encoded-Word\n\n    :param msg_headers: Dictionary of message headers\n    :return: Dictionary of message headers\n    '''\n\n    headers_to_decode = ['from', 'reply-to', 'subject', 'to']\n\n    for item in headers_to_decode:\n        return_list = []\n        try:\n            # decode the header\n            decoded_header = pyzmail_decode_mail_header(msg_headers[item][0])\n            # add the header to a list as we want to return a list\n            return_list.append(decoded_header)\n            # replace the item in the dict with a decoded version\n            msg_headers[item] = return_list\n\n        except KeyError:\n            pass\n\n    return msg_headers", "response": "Decodes the message headers from the MIME encoded - word headers\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delay(self, dl=0):\n        if dl is None:\n            time.sleep(self.dl)\n        elif dl < 0:\n            sys.stderr.write(\n                \"delay cannot less than zero, this takes no effects.\\n\")\n        else:\n            time.sleep(dl)", "response": "Delay for dl seconds."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrights click at x y on screen for n times.", "response": "def right_click(self, x, y, n=1, pre_dl=None, post_dl=None):\n        \"\"\"Right click at ``(x, y)`` on screen for ``n`` times.\n        at begin.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u5728\u5c4f\u5e55\u7684 ``(x, y)`` \u5750\u6807\u5904\u53f3\u952e\u5355\u51fb ``n`` \u6b21\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.m.click(x, y, 2, n)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscrolling up n times.", "response": "def scroll_up(self, n, pre_dl=None, post_dl=None):\n        \"\"\"Scroll up ``n`` times.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u9f20\u6807\u6eda\u8f6e\u5411\u4e0a\u6eda\u52a8n\u6b21\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.m.scroll(vertical=n)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscrolling right n times.", "response": "def scroll_right(self, n, pre_dl=None, post_dl=None):\n        \"\"\"Scroll right ``n`` times.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u9f20\u6807\u6eda\u8f6e\u5411\u53f3\u6eda\u52a8n\u6b21(\u5982\u679c\u53ef\u80fd\u7684\u8bdd)\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.m.scroll(horizontal=n)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef move_to(self, x, y, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.m.move(x, y)\n        self.delay(post_dl)", "response": "Move mouse to x y"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndrag something from start_x start_y to end_x end_y", "response": "def drag_and_release(self, start_x, start_y, end_x, end_y, pre_dl=None, post_dl=None):\n        \"\"\"Drag something from (start_x, start_y) to (end_x, endy)\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u4ecestart\u7684\u5750\u6807\u5904\u9f20\u6807\u5de6\u952e\u5355\u51fb\u62d6\u66f3\u5230end\u7684\u5750\u6807\u5904\n        start, end\u662ftuple. \u683c\u5f0f\u662f(x, y)\n        \"\"\"\n        self.delay(pre_dl)\n        self.m.press(start_x, start_y, 1)\n        self.m.drag(end_x, end_y)\n        self.m.release(end_x, end_y, 1)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntapping a key on keyboard for n times with interval seconds of interval.", "response": "def tap_key(self, key_name, n=1, interval=0, pre_dl=None, post_dl=None):\n        \"\"\"Tap a key on keyboard for ``n`` times, with ``interval`` seconds of\n        interval. Key is declared by it's name\n\n        Example::\n\n            bot.tap_key(\"a\")\n            bot.tap_key(1)\n            bot.tap_key(\"up\")\n            bot.tap_key(\"space\")\n            bot.tap_key(\"enter\")\n            bot.tap_key(\"tab\")\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u4ee5 ``interval`` \u4e2d\u5b9a\u4e49\u7684\u9891\u7387\u6309\u4e0b\u67d0\u4e2a\u6309\u952e ``n`` \u6b21\u3002\u63a5\u53d7\u6309\u952e\u540d\u4f5c\u4e3a\u8f93\u5165\u3002\n        \"\"\"\n        key = self._parse_key(key_name)\n        self.delay(pre_dl)\n        self.k.tap_key(key, n, interval)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npresses enter key n times.", "response": "def enter(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        \"\"\"Press enter key n times.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309\u56de\u8f66\u952e/\u6362\u884c\u952e n \u6b21\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.enter_key, n, interval)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef backspace(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.backspace_key, n, interval)\n        self.delay(post_dl)", "response": "Press backspace key n times."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npresses white space key n times.", "response": "def space(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        \"\"\"Press white space key n times.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309\u7a7a\u683c\u952e n \u6b21\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.space_key, n)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npressing Fn key n times.", "response": "def fn(self, i, n=1, interval=0, pre_dl=None, post_dl=None):\n        \"\"\"Press Fn key n times.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309 Fn \u529f\u80fd\u952e n \u6b21\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.function_keys[i], n, interval)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tab(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.tab_key, n, interval)\n        self.delay(post_dl)", "response": "Tap n times with interval seconds of interval."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef up(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.up_key, n, interval)\n        self.delay(post_dl)", "response": "Press up key n times."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npressing down key n times.", "response": "def down(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        \"\"\"Press down key n times.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309\u4e0b\u65b9\u5411\u952e n \u6b21\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.down_key, n, interval)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef left(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.left_key, n, interval)\n        self.delay(post_dl)", "response": "Press left key n times\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npresses right key n times.", "response": "def right(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        \"\"\"Press right key n times.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309\u53f3\u65b9\u5411\u952e n \u6b21\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.right_key, n, interval)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.delete_key, n, interval)\n        self.delay(post_dl)", "response": "Presave delete key n times."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insert(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.insert_key, n, interval)\n        self.delay(post_dl)", "response": "Pres insert key n times.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309 insert \u952en\u6b21\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef home(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.home_key, n, interval)\n        self.delay(post_dl)", "response": "Preserve home key n times."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef end(self, n=1, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.tap_key(self.k.end_key, n, interval)\n        self.delay(post_dl)", "response": "Press end key n times."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef press_and_tap(self, press_key, tap_key, n=1, interval=0, pre_dl=None, post_dl=None):\n        press_key = self._parse_key(press_key)\n        tap_key = self._parse_key(tap_key)\n\n        self.delay(pre_dl)\n        self.k.press_key(press_key)\n        self.k.tap_key(tap_key, n, interval)\n        self.k.release_key(press_key)\n        self.delay(post_dl)", "response": "Press combination of two keys like Ctrl + C Alt + F4."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef press_two_and_tap(self,\n                          press_key1, press_key2, tap_key, n=1, interval=0, pre_dl=None, post_dl=None):\n        \"\"\"Press combination of three keys, like Ctrl + Shift + C, The tap key\n        could be tapped for multiple time.\n\n        Examples::\n\n            bot.press_and_tap(\"ctrl\", \"shift\", \"c\")\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309\u4e0b\u4e09\u4e2a\u952e\u7684\u7ec4\u5408\u952e\u3002\n        \"\"\"\n        press_key1 = self._parse_key(press_key1)\n        press_key2 = self._parse_key(press_key2)\n        tap_key = self._parse_key(tap_key)\n\n        self.delay(pre_dl)\n        self.k.press_key(press_key1)\n        self.k.press_key(press_key2)\n        self.k.tap_key(tap_key, n, interval)\n        self.k.release_key(press_key1)\n        self.k.release_key(press_key2)\n        self.delay(post_dl)", "response": "Press two keys like Ctrl + Shift + C and tap the key n times."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npresses Ctrl + C.", "response": "def ctrl_c(self, pre_dl=None, post_dl=None):\n        \"\"\"Press Ctrl + C, usually for copy.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309\u4e0b Ctrl + C \u7ec4\u5408\u952e, \u901a\u5e38\u7528\u4e8e\u590d\u5236\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.k.press_key(self.k.control_key)\n        self.k.tap_key(\"c\")\n        self.k.release_key(self.k.control_key)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ctrl_fn(self, i, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.press_key(self.k.control_key)\n        self.k.tap_key(self.k.function_keys[i])\n        self.k.release_key(self.k.control_key)\n        self.delay(post_dl)", "response": "Press Ctrl + Fn1 ~ 12 once."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npress Alt + Fn1 ~ 12 once.", "response": "def alt_fn(self, i, pre_dl=None, post_dl=None):\n        \"\"\"Press Alt + Fn1 ~ 12 once.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u6309\u4e0b Alt + Fn1 ~ 12 \u7ec4\u5408\u952e\u3002\n        \"\"\"\n        self.delay(pre_dl)\n        self.k.press_key(self.k.alt_key)\n        self.k.tap_key(self.k.function_keys[i])\n        self.k.release_key(self.k.alt_key)\n        self.delay(post_dl)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef shift_fn(self, i, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.press_key(self.k.shift_key)\n        self.k.tap_key(self.k.function_keys[i])\n        self.k.release_key(self.k.shift_key)\n        self.delay(post_dl)", "response": "Press Shift + Fn1 ~ 12 once."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef alt_tab(self, n=1, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.press_key(self.k.alt_key)\n        self.k.tap_key(self.k.tab_key, n=n, interval=0.1)\n        self.k.release_key(self.k.alt_key)\n        self.delay(post_dl)", "response": "Press Alt + Tab once usually for switching between windows."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef type_string(self, text, interval=0, pre_dl=None, post_dl=None):\n        self.delay(pre_dl)\n        self.k.type_string(text, interval)\n        self.delay(post_dl)", "response": "Enter strings.\n       . type_string"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn list of server objects populated if necessary.", "response": "def Servers(self,cached=True):\n\t\t\"\"\"Returns list of server objects, populates if necessary.\n\n\t\t>>> clc.v2.Servers([\"NY1BTDIPHYP0101\",\"NY1BTDIWEB0101\"]).Servers()\n\t\t[<clc.APIv2.server.Server object at 0x1065b0d50>, <clc.APIv2.server.Server object at 0x1065b0e50>]\n\t\t>>> print _[0]\n\t\tNY1BTDIPHYP0101\n\n\t\t\"\"\"\n\n\t\tif not hasattr(self,'_servers') or not cached:\n\t\t\tself._servers = []\n\t\t\tfor server in self.servers_lst:\n\t\t\t\tself._servers.append(Server(id=server,alias=self.alias,session=self.session))\n\n\t\treturn(self._servers)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _Operation(self,operation):\n\n\t\ttry:\n\t\t\treturn(clc.v2.Requests(clc.v2.API.Call('POST','operations/%s/servers/%s' % (self.alias,operation),\n\t\t\t                                       json.dumps(self.servers_lst),\n\t\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t\t   alias=self.alias,session=self.session))\n\t\texcept clc.APIFailedResponse as e:\n\t\t\t# Most likely a queue add error presented as a 400.  Let Requests parse this\n\t\t\treturn(clc.v2.Requests(e.response_json,alias=self.alias,session=self.session))", "response": "Execute specified operations task against one or more servers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Account(self):\n\n\t\treturn(clc.v2.Account(alias=self.alias,session=self.session))", "response": "Return account object for this server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning group object containing this server.", "response": "def Group(self):\n\t\t\"\"\"Return group object for group containing this server.\n\n\t\t>>> clc.v2.Server(\"CA3BTDICNTRLM01\").Group()\n\t\t<clc.APIv2.group.Group object at 0x10b07b7d0>\n\t\t>>> print _\n\t\tAnsible Managed Servers\n\n\t\t\"\"\"\n\n\t\treturn(clc.v2.Group(id=self.groupId,alias=self.alias,session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn disks object associated with server.", "response": "def Disks(self):\n\t\t\"\"\"Return disks object associated with server.\n\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").Disks()\n\t\t<clc.APIv2.disk.Disks object at 0x10feea190>\n\n\t\t\"\"\"\n\n\t\tif not self.disks:  self.disks = clc.v2.Disks(server=self,disks_lst=self.data['details']['disks'],session=self.session)\n\n\t\treturn(self.disks)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the PublicIPs object associated with the server.", "response": "def PublicIPs(self):\n\t\t\"\"\"Returns PublicIPs object associated with the server.\n\n\t\t\"\"\"\n\t\tif not self.public_ips:  self.public_ips = clc.v2.PublicIPs(server=self,public_ips_lst=self.ip_addresses,session=self.session)\n\n\t\treturn(self.public_ips)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef PriceUnits(self):\n\n\t\ttry:\n\t\t\tunits = clc.v2.API.Call('GET','billing/%s/serverPricing/%s' % (self.alias,self.name),session=self.session)\n\t\texcept clc.APIFailedResponse:\n\t\t\traise(clc.ServerDeletedException)\n\n\n\t\treturn({\n\t\t\t\t'cpu': units['cpu'],\n\t\t\t\t'memory': units['memoryGB'],\n\t\t\t\t'storage': units['storageGB'],\n\t\t\t\t'managed_os': units['managedOS'],\n\t\t\t})", "response": "Returns the hourly unit component prices for this server."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the total hourly price for the server.", "response": "def PriceHourly(self):\n\t\t\"\"\"Returns the total hourly price for the server.\n\n\t\tSums unit prices with unit volumes.\n\n\t\t>>> clc.v2.Server(\"NY1BTDIPHYP0101\").PriceHourly()\n\t\t0.02857\n\n\t\t\"\"\"\n\n\t\tunits = self.PriceUnits()\n\n\t\treturn(units['cpu']*self.cpu+units['memory']*self.memory+units['storage']*self.storage+units['managed_os'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the administrative credentials for this server.", "response": "def Credentials(self):\n\t\t\"\"\"Returns the administrative credentials for this server.\n\n\t\t>>> clc.v2.Server(\"NY1BTDIPHYP0101\").Credentials()\n\t\t{u'userName': u'administrator', u'password': u'dszkjh498s^'}\n\n\t\t\"\"\"\n\n\t\treturn(clc.v2.API.Call('GET','servers/%s/%s/credentials' % (self.alias,self.name),session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _Operation(self,operation):\n\n\t\ttry:\n\t\t\treturn(clc.v2.Requests(\n\t\t\t\tclc.v2.API.Call(\n\t\t\t\t\t'POST',\n\t\t\t\t\t'operations/%s/servers/%s' % (self.alias,operation),'[\"%s\"]' % self.id,\n\t\t\t\t\tsession=self.session),\n\t\t\t\talias=self.alias,\n\t\t\t\tsession=self.session))\n\t\texcept clc.APIFailedResponse as e:\n\t\t\t# Most likely a queue add error presented as a 400.  Let Requests parse this\n\t\t\treturn(clc.v2.Requests(e.response_json,alias=self.alias,session=self.session))", "response": "Execute specified operations task against one or more servers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ExecutePackage(self,package_id,parameters={}):\n\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('POST','operations/%s/servers/executePackage' % (self.alias),\n\t\t                                       json.dumps({'servers': [self.id], 'package': {'packageId': package_id, 'parameters': parameters}}),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.alias,\n\t\t\t\t\t\t\t   session=self.session))", "response": "Execute an existing Bluerprint package on the server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef AddNIC(self,network_id,ip=''):\n\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('POST','servers/%s/%s/networks' % (self.alias,self.id),\n\t\t                                       json.dumps({'networkId': network_id, 'ipAddress': ip}),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.alias,\n\t\t\t\t\t\t\t   session=self.session))", "response": "Add a NIC from the provided network to the server and if provided assign a provided IP address."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the NIC associated with the provided network from the server.", "response": "def RemoveNIC(self,network_id):\n\t\t\"\"\"Remove the NIC associated with the provided network from the server.\n\n\t\thttps://www.ctl.io/api-docs/v2/#servers-remove-secondary-network\n\n\t\tnetwork_id - ID associated with the network to remove\n\n        >>> network = clc.v2.Networks(location=\"VA1\").Get(\"10.128.166.0/24\")\n        >>> clc.v2.Server(alias='BTDI',id='WA1BTDIKRT06'). \\\n        \t\tRemoveNIC(network_id=network.id). \\\n        \t\tWaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\treturn(\n\t\t\tclc.v2.Requests(\n\t\t\t\tclc.v2.API.Call('DELETE','servers/%s/%s/networks/%s'\n\t\t\t\t\t% (self.alias,self.id,network_id),\n\t\t\t\t\tsession=self.session),\n\t\t\t  alias=self.alias,\n\t\t\t  session=self.session\n\t  ))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef CreateSnapshot(self,delete_existing=True,expiration_days=7):\n\n\t\tif len(self.data['details']['snapshots']):\n\t\t\tif delete_existing:  self.DeleteSnapshot()\n\t\t\telse:  raise(clc.CLCException(\"Snapshot already exists cannot take another\"))\n\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('POST','operations/%s/servers/createSnapshot' % (self.alias),\n\t\t\t\t\t\t\t\t\t\t\t   {'serverIds': self.id, 'snapshotExpirationDays': expiration_days},\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.alias,\n\t\t\t\t\t\t\t   session=self.session))", "response": "Create a snapshot of this server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving an existing Hypervisor level snapshot.", "response": "def DeleteSnapshot(self,names=None):\n\t\t\"\"\"Removes an existing Hypervisor level snapshot.\n\n\t\tSupply one or more snapshot names to delete them concurrently.\n\t\tIf no snapshot names are supplied will delete all existing snapshots.\n\n\t\t>>> clc.v2.Server(alias='BTDI',id='WA1BTDIKRT02').DeleteSnapshot().WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tif names is None:  names = self.GetSnapshots()\n\n\t\trequests_lst = []\n\t\tfor name in names:\n\t\t\tname_links = [obj['links'] for obj in self.data['details']['snapshots'] if obj['name']==name][0]\n\t\t\trequests_lst.append(\n\t\t\t\tclc.v2.Requests(\n\t\t\t\t\tclc.v2.API.Call('DELETE',\n\t\t\t\t\t\t[obj['href'] for obj in name_links if obj['rel']=='delete'][0],\n\t\t\t\t\t\tsession=self.session),\n\t\t\t\t\talias=self.alias,\n\t\t\t\t\tsession=self.session))\n\n\t\treturn(sum(requests_lst))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrestores an existing Hypervisor level snapshot.", "response": "def RestoreSnapshot(self,name=None):\n\t\t\"\"\"Restores an existing Hypervisor level snapshot.\n\n\t\tSupply snapshot name to restore\n\t\tIf no snapshot name is supplied will restore the first snapshot found\n\n\t\t>>> clc.v2.Server(alias='BTDI',id='WA1BTDIKRT02').RestoreSnapshot().WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tif not len(self.data['details']['snapshots']):  raise(clc.CLCException(\"No snapshots exist\"))\n\t\tif name is None:  name = self.GetSnapshots()[0]\n\n\t\tname_links = [obj['links'] for obj in self.data['details']['snapshots'] if obj['name']==name][0]\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('POST',\n\t\t\t\t\t\t\t\t\t\t\t   [obj['href'] for obj in name_links if obj['rel']=='restore'][0],\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.alias,\n\t\t\t\t\t\t\t   session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Create(name,template,group_id,network_id,cpu=None,memory=None,alias=None,password=None,ip_address=None,\n\t           storage_type=\"standard\",type=\"standard\",primary_dns=None,secondary_dns=None,\n\t\t\t   additional_disks=[],custom_fields=[],ttl=None,managed_os=False,description=None,\n\t\t\t   source_server_password=None,cpu_autoscale_policy_id=None,anti_affinity_policy_id=None,\n\t\t\t   packages=[],configuration_id=None,session=None):\n\t\t\"\"\"Creates a new server.\n\n\t\thttps://www.centurylinkcloud.com/api-docs/v2/#servers-create-server\n\n\t\tcpu and memory are optional and if not provided we pull from the default server size values associated with\n\t\tthe provided group_id.\n\n\t\tSet ttl as number of seconds before server is to be terminated.  Must be >3600\n\n\t\t>>> d = clc.v2.Datacenter()\n\t\t>>> clc.v2.Server.Create(name=\"api2\",cpu=1,memory=1,\n\t\t                         group_id=d.Groups().Get(\"Default Group\").id,\n\t                             template=d.Templates().Search(\"centos-6-64\")[0].id,\n\t\t\t\t\t\t         network_id=d.Networks().networks[0].id).WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tif not alias:  alias = clc.v2.Account.GetAlias(session=session)\n\t\tif not description:  description = name\n\n\t\tif type.lower() != \"baremetal\":\n\t\t\tif not cpu or not memory:\n\t\t\t\tgroup = clc.v2.Group(id=group_id,alias=alias,session=session)\n\n\t\t\tif not cpu and group.Defaults(\"cpu\"):\n\t\t\t\tcpu = group.Defaults(\"cpu\")\n\t\t\telif not cpu:\n\t\t\t\traise(clc.CLCException(\"No default CPU defined\"))\n\n\t\t\tif not memory and group.Defaults(\"memory\"):\n\t\t\t\tmemory = group.Defaults(\"memory\")\n\t\t\telif not memory:\n\t\t\t\traise(clc.CLCException(\"No default Memory defined\"))\n\n\t\tif type.lower() == \"standard\" and storage_type.lower() not in (\"standard\",\"premium\"):\n\t\t\traise(clc.CLCException(\"Invalid type/storage_type combo\"))\n\t\tif type.lower() == \"hyperscale\" and storage_type.lower() != \"hyperscale\":\n\t\t\traise(clc.CLCException(\"Invalid type/storage_type combo\"))\n\t\tif type.lower() == \"baremetal\":\n\t\t\ttype = \"bareMetal\"\n\n\t\tif ttl and ttl<=3600: raise(clc.CLCException(\"ttl must be greater than 3600 seconds\"))\n\n\t\tif ttl: ttl = clc.v2.time_utils.SecondsToZuluTS(int(time.time())+ttl)\n\n\t\t# TODO - validate custom_fields as a list of dicts with an id and a value key\n\t\t# TODO - validate template exists\n\t\t# TODO - validate additional_disks as a list of dicts with a path, sizeGB, and type (partitioned,raw) keys\n\t\t# TODO - validate addition_disks path not in template reserved paths\n\t\t# TODO - validate antiaffinity policy id set only with type=hyperscale\n\n\t\tpayload = {\n\t\t\t'name': name, 'description': description, 'groupId': group_id, 'primaryDNS': primary_dns, 'secondaryDNS': secondary_dns,\n\t\t\t'networkId': network_id, 'password': password, 'type': type, 'customFields': custom_fields\n\t\t}\n\n\t\tif type == 'bareMetal':\n\t\t\tpayload.update({'configurationId': configuration_id, 'osType': template})\n\t\telse:\n\t\t\tpayload.update({'sourceServerId': template, 'isManagedOS': managed_os, 'ipAddress': ip_address,\n\t\t\t\t'sourceServerPassword': source_server_password, 'cpu': cpu, 'cpuAutoscalePolicyId': cpu_autoscale_policy_id,\n\t\t\t\t'memoryGB': memory, 'storageType': storage_type, 'antiAffinityPolicyId': anti_affinity_policy_id,\n\t\t\t\t'additionalDisks': additional_disks, 'ttl': ttl, 'packages': packages})\n\n\t\treturn clc.v2.Requests(clc.v2.API.Call('POST','servers/%s' % (alias), json.dumps(payload), session=session),\n\t\t\t\t\t\t\t   alias=alias,\n\t\t\t\t\t\t\t   session=session)", "response": "Create a new server."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates one or more server clones.", "response": "def Clone(self,network_id,name=None,cpu=None,memory=None,group_id=None,alias=None,password=None,ip_address=None,\n\t          storage_type=None,type=None,primary_dns=None,secondary_dns=None,\n\t\t\t  custom_fields=None,ttl=None,managed_os=False,description=None,\n\t\t\t  source_server_password=None,cpu_autoscale_policy_id=None,anti_affinity_policy_id=None,\n\t\t\t  packages=[],count=1):\n\t\t\"\"\"Creates one or more clones of existing server.\n\n\t\thttps://www.centurylinkcloud.com/api-docs/v2/#servers-create-server\n\n\t\tSet ttl as number of seconds before server is to be terminated.\n\n\t\t* - network_id is currently a required parameter.  This will change to optional once APIs are available to\n\t\t    return the network id of self.\n\t\t* - if no password is supplied will reuse the password of self.  Is this the expected behavior?  Take note\n\t\t    there is no way to for a system generated password with this pattern since we cannot leave as None\n\t\t* - any DNS settings from self aren't propogated to clone since they are unknown at system level and\n\t\t    the clone process will touch them\n\t\t* - no change to the disk layout we will clone all\n\t\t* - clone will not replicate managed OS setting from self so this must be explicitly set\n\n\t\t>>> d = clc.v2.Datacenter()\n\t\t>>> clc.v2.Server(alias='BTDI',id='WA1BTDIAPI207').Clone(network_id=d.Networks().networks[0].id,count=2)\n\t\t0\n\n\t\t\"\"\"\n\n\t\tif not name:  name = re.search(\"%s(.+)\\d{2}$\" % self.alias,self.name).group(1)\n\t\t#if not description and self.description:  description = self.description\n\t\tif not cpu:  cpu = self.cpu\n\t\tif not memory:  memory = self.memory\n\t\tif not group_id:  group_id = self.group_id\n\t\tif not alias:  alias = self.alias\n\t\tif not source_server_password: source_server_password = self.Credentials()['password']\n\t\tif not password: password = source_server_password\t# is this the expected behavior?\n\t\tif not storage_type:  storage_type = self.storage_type\n\t\tif not type:  type = self.type\n\t\tif not storage_type:  storage_type = self.storage_type\n\t\tif not custom_fields and len(self.custom_fields): custom_fields = self.custom_fields\n\t\tif not description:  description = self.description\n\t\t# TODO - #if not cpu_autoscale_policy_id:  cpu_autoscale_policy_id =\n\t\t# TODO - #if not anti_affinity_policy_id:  anti_affinity_policy_id =\n\t\t# TODO - need to get network_id of self, not currently exposed via API :(\n\n\t\trequests_lst = []\n\t\tfor i in range(0,count):\n\t\t\trequests_lst.append(Server.Create( \\\n\t\t\t            name=name,cpu=cpu,memory=memory,group_id=group_id,network_id=network_id,alias=self.alias,\n\t\t\t\t\t\tpassword=password,ip_address=ip_address,storage_type=storage_type,type=type,\n\t\t\t\t\t\tprimary_dns=primary_dns,secondary_dns=secondary_dns,\n\t\t\t\t\t\tcustom_fields=custom_fields,ttl=ttl,managed_os=managed_os,description=description,\n                        source_server_password=source_server_password,cpu_autoscale_policy_id=cpu_autoscale_policy_id,\n\t\t\t\t\t\tanti_affinity_policy_id=anti_affinity_policy_id,packages=packages,\n\t\t\t\t\t\ttemplate=self.id,session=self.session))\n\n\t\treturn(sum(requests_lst))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting existing server to a template.", "response": "def ConvertToTemplate(self,visibility,description=None,password=None):\n\t\t\"\"\"Converts existing server to a template.\n\n\t\tvisibility is one of private or shared.\n\n\t\t>>> d = clc.v2.Datacenter()\n\t\t>>> clc.v2.Server(alias='BTDI',id='WA1BTDIAPI207').ConvertToTemplate(\"private\",\"my template\")\n\t\t0\n\n\t\t\"\"\"\n\n\t\tif visibility not in ('private','shared'):  raise(clc.CLCException(\"Invalid visibility - must be private or shared\"))\n\t\tif not password: password = self.Credentials()['password']\n\t\tif not description:  description = self.description\n\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('POST','servers/%s/%s/convertToTemplate' % (self.alias,self.id),\n\t\t\t\t\t\t\t\t\t\t\t   json.dumps({\"description\": description, \"visibility\": visibility, \"password\": password}),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.alias,\n\t\t\t\t\t\t\t   session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nchange existing server object.", "response": "def Change(self,cpu=None,memory=None,description=None,group_id=None):\n\t\t\"\"\"Change existing server object.\n\n\t\tOne more more fields can be set and method will return with a requests\n\t\tobject for all queued activities.  This is a convenience function - all\n\t\teach of these changes requires a seperate API call.  Some API calls are synchronous\n\t\t(e.g. changing group ID or password) while others are async.\n\n\t\t\"\"\"\n\n\t\tif group_id:  groupId = group_id\n\t\telse:  groupId = None\n\n\t\tpayloads = []\n\t\trequests = []\n\n\t\tfor key in (\"cpu\",\"memory\",\"description\",\"groupId\"):\n\t\t\tif locals()[key]:\n\t\t\t\trequests.append(clc.v2.Requests(clc.v2.API.Call('PATCH','servers/%s/%s' % (self.alias,self.id),\n\t\t\t\t                                                json.dumps([{\"op\": \"set\", \"member\": key, \"value\": locals()[key]}]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsession=self.session),\n\t\t\t\t\t\t\t\talias=self.alias,\n\t\t\t\t\t\t\t\tsession=self.session))\n\n\t\tif len(requests):  self.dirty = True\n\n\t\treturn(sum(requests))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange the password of the server.", "response": "def SetPassword(self,password):\n\t\t\"\"\"Request change of password.\n\n\t\tThe API request requires supplying the current password.  For this we issue a call\n\t\tto retrieve the credentials so note there will be an activity log for retrieving the\n\t\tcredentials associated with any SetPassword entry\n\n\t\t>>> s.SetPassword(\"newpassword\")\n\n\t\t\"\"\"\n\n\t\t# 0: {op: \"set\", member: \"password\", value: {current: \" r`5Mun/vT:qZ]2?z\", password: \"Savvis123!\"}}\n\t\tif self.data['status'] != \"active\":  raise(clc.CLCException(\"Server must be powered on to change password\"))\n\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('PATCH','servers/%s/%s' % (self.alias,self.id),\n\t\t                                       json.dumps([{\"op\": \"set\", \"member\": \"password\", \"value\": {\"current\": self.Credentials()['password'], \"password\": password}}]),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.alias,\n\t\t\t\t\t\t\t   session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Delete(self):\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('DELETE','servers/%s/%s' % (self.alias,self.id),session=self.session),alias=self.alias,session=self.session))", "response": "Delete server.\n\n\t\thttps://t3n.zendesk.com/entries/59220824-Delete-Server\n\n\t\t>>> clc.v2.Server(\"WA1BTDIAPI219\").Delete().WaitUntilComplete()\n\t\t0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Get(self,key):\n\n\t\tfor public_ip in self.public_ips:\n\t\t\tif public_ip.id == key:  return(public_ip)\n\t\t\telif key == public_ip.internal:  return(public_ip)", "response": "Get public_ip by providing either the public or internal IP address."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Add(self,ports,source_restrictions=None,private_ip=None):\n\n\t\tpayload = {'ports': []}\n\t\tfor port in ports:\n\t\t\tif 'port_to' in port:  payload['ports'].append({'protocol':port['protocol'], 'port':port['port'], 'portTo':port['port_to']})\n\t\t\telse:  payload['ports'].append({'protocol':port['protocol'], 'port':port['port']})\n\t\tif source_restrictions:  payload['sourceRestrictions'] = source_restrictions\n\t\tif private_ip:  payload['internalIPAddress'] = private_ip\n\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('POST','servers/%s/%s/publicIPAddresses' % (self.server.alias,self.server.id),\n\t\t                                       json.dumps(payload),session=self.session),\n\t\t                       alias=self.server.alias,session=self.session))", "response": "Add new public_ip.\n\n\t\tSpecify one or more ports using a list of dicts with the following keys:\n\n\t\t\tprotocol - TCP, UDP, or ICMP\n\t\t\tport - int 0-65534\n\t\t\tport_to - (optional) if specifying a range of ports then the rqange end.  int 0-65534\n\n\t\tOptionally specify one or more source restrictions using a list of dicts with the following keys:\n\n\t\t\tcidr - string with CIDR notation for the subnet (e.g. \"132.200.20.0/24\")\n\n\t\tprivate_ip is the existing private IP address to NAT to (optional)\n\n\t\t# New public IP with single port\n\t\t>>> p = clc.v2.Server(alias='BTDI',id='WA1BTDIX03').PublicIPs()\n\t\t>>> p.Add(ports=[{\"protocol\": \"TCP\",\"port\":5}]).WaitUntilComplete()\n\t\t0\n\n\t\t# New public IP with port range\n\t\t>>> p.Add([{\"protocol\": \"UDP\",\"port\":10,\"port_to\":50}]).WaitUntilComplete()\n\t\t0\n\n\t\t# Map existing private IP to single port\n\t\t>>> p.Add(ports=[{\"protocol\": \"TCP\",\"port\":22}],k\n\t\t          source_restrictions=[{'cidr': \"132.200.20.0/24\"}],\n\t\t\t\t  private_ip=\"10.80.148.13\").WaitUntilComplete()\n\t\t0\n\n\t\t* Note this API is subject to revision to make ports and source restrictions access to parallel\n\t\t  that used for accessors.\n\n\t\t* public_ips.public_ips will not be updated to reflect this addition. Recreate object after request completes\n\t\t  to access new info including getting the IP itself"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming a full load of all PublicIP metadata.", "response": "def _Load(self,cached=True):\n\t\t\"\"\"Performs a full load of all PublicIP metadata.\"\"\"\n\n\t\tif not self.data or not cached:\n\t\t\tself.data = clc.v2.API.Call('GET','servers/%s/%s/publicIPAddresses/%s' % (self.parent.server.alias,self.parent.server.id,self.id),\n\t\t\t\t\t\t\t\t\t\tsession=self.session)\n\n\t\t\t# build ports\n\t\t\tself.data['_ports'] = self.data['ports']\n\t\t\tself.data['ports'] = []\n\t\t\tfor port in self.data['_ports']:\n\t\t\t\tif 'portTo' in port:  self.ports.append(Port(self,port['protocol'],port['port'],port['portTo']))\n\t\t\t\telse:  self.ports.append(Port(self,port['protocol'],port['port']))\n\n\t\t\t# build source restriction\n\t\t\tself.data['_source_restrictions'] = self.data['sourceRestrictions']\n\t\t\tself.data['source_restrictions'] = []\n\t\t\tfor source_restriction in self.data['_source_restrictions']:\n\t\t\t\tself.source_restrictions.append(SourceRestriction(self,source_restriction['cidr']))\n\n\t\treturn(self.data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting public IP. >>> clc.v2.Server(\"WA1BTDIX01\").PublicIPs().public_ips[0].Delete().WaitUntilComplete() 0", "response": "def Delete(self):\n\t\t\"\"\"Delete public IP.\n\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").PublicIPs().public_ips[0].Delete().WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tpublic_ip_set = [{'public_ipId': o.id} for o in self.parent.public_ips if o!=self]\n\t\tself.parent.public_ips = [o for o in self.parent.public_ips if o!=self]\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('DELETE','servers/%s/%s/publicIPAddresses/%s' % (self.parent.server.alias,self.parent.server.id,self.id),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t                       alias=self.parent.server.alias,\n\t\t\t\t\t\t\t   session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the PublicIP definition to cloud.", "response": "def Update(self):\n\t\t\"\"\"Commit  current PublicIP definition to cloud.\n\n\t\tUsually called by the class to commit changes to port and source restriction policies.\n\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").PublicIPs().public_ips[0].Update().WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('PUT','servers/%s/%s/publicIPAddresses/%s' % (self.parent.server.alias,self.parent.server.id,self.id),\n\t\t\t\t\t\t                       json.dumps({'ports': [o.ToDict() for o in self.ports],\n\t\t\t\t\t\t\t\t\t\t\t               'sourceRestrictions': [o.ToDict() for o in self.source_restrictions] }),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.parent.server.alias,\n\t\t\t\t\t\t\t   session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding and commit a single port.", "response": "def AddPort(self,protocol,port,port_to=None):\n\t\t\"\"\"Add and commit a single port.\n\n\t\t# Add single port\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").PublicIPs().public_ips[0].AddPort(protocol='TCP',port='22').WaitUntilComplete()\n\t\t0\n\n\t\t# Add port range\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").PublicIPs().public_ips[0].AddPort(protocol='UDP',port='10000',port_to='15000').WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tself.ports.append(Port(self,protocol,port,port_to))\n\n\t\treturn(self.Update())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef AddPorts(self,ports):\n\n\t\tfor port in ports:\n\t\t\tif 'port_to' in port:  self.ports.append(Port(self,port['protocol'],port['port'],port['port_to']))\n\t\t\telse:  self.ports.append(Port(self,port['protocol'],port['port']))\n\n\t\treturn(self.Update())", "response": "Add ports to the list of ports."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding and commit a single source IP restriction policy.", "response": "def AddSourceRestriction(self,cidr):\n\t\t\"\"\"Add and commit a single source IP restriction policy.\n\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").PublicIPs().public_ips[0]\n\t\t\t\t.AddSourceRestriction(cidr=\"132.200.20.1/32\").WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tself.source_restrictions.append(SourceRestriction(self,cidr))\n\n\t\treturn(self.Update())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef AddSourceRestrictions(self,cidrs):\n\n\t\tfor cidr in cidrs:  self.source_restrictions.append(SourceRestriction(self,cidr))\n\n\t\treturn(self.Update())", "response": "Add one or more CIDR source restriction policies."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting this port and commit change to cloud.", "response": "def Delete(self):\n\t\t\"\"\"Delete this port and commit change to cloud.\n\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").PublicIPs().public_ips[0].ports[0].Delete().WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tself.public_ip.ports = [o for o in self.public_ip.ports if o!=self]\n\n\t\treturn(self.public_ip.Update())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Delete(self):\n\n\t\tself.public_ip.source_restrictions = [o for o in self.public_ip.source_restrictions if o!=self]\n\n\t\treturn(self.public_ip.Update())", "response": "Delete this source restriction and commit change to cloud."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tile_bbox(self, tile_indices):\n        (z, x, y) = tile_indices\n        topleft = (x * self.tilesize, (y + 1) * self.tilesize)\n        bottomright = ((x + 1) * self.tilesize, y * self.tilesize)\n        nw = self.unproject_pixels(topleft, z)\n        se = self.unproject_pixels(bottomright, z)\n        return nw + se", "response": "Returns the WGS84 bbox of the specified tile_indices"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unproject(self, xy):\n        (x, y) = xy\n        lng = x/EARTH_RADIUS * RAD_TO_DEG\n        lat = 2 * atan(exp(y/EARTH_RADIUS)) - pi/2 * RAD_TO_DEG\n        return (lng, lat)", "response": "Returns the coordinates from position in meters\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_entrypoint_output(json_encoder, handler_output):\n\n        response = {\n            'body': '',\n            'content_type': 'text/plain',\n            'headers': {},\n            'status_code': 200,\n            'body_encoding': 'text',\n        }\n\n        # if the type of the output is a string, just return that and 200\n        if isinstance(handler_output, str):\n            response['body'] = handler_output\n\n        # if it's a tuple of 2 elements, first is status second is body\n        elif isinstance(handler_output, tuple) and len(handler_output) == 2:\n            response['status_code'] = handler_output[0]\n\n            if isinstance(handler_output[1], str):\n                response['body'] = handler_output[1]\n            else:\n                response['body'] = json_encoder(handler_output[1])\n                response['content_type'] = 'application/json'\n\n        # if it's a dict, populate the response and set content type to json\n        elif isinstance(handler_output, dict) or isinstance(handler_output, list):\n            response['content_type'] = 'application/json'\n            response['body'] = json_encoder(handler_output)\n\n        # if it's a response object, populate the response\n        elif isinstance(handler_output, Response):\n            if isinstance(handler_output.body, dict):\n                response['body'] = json.dumps(handler_output.body)\n                response['content_type'] = 'application/json'\n            else:\n                response['body'] = handler_output.body\n                response['content_type'] = handler_output.content_type\n\n            response['headers'] = handler_output.headers\n            response['status_code'] = handler_output.status_code\n        else:\n            response['body'] = handler_output\n\n        if isinstance(response['body'], bytes):\n            response['body'] = base64.b64encode(response['body']).decode('ascii')\n            response['body_encoding'] = 'base64'\n\n        return response", "response": "Takes a handler output s type generates a response towards the entrypoint processor"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks architecture of target python", "response": "def check_python_architecture(pythondir, target_arch_str):\n    \"\"\"\n    functions check architecture of target python\n    \"\"\"\n    pyth_str = subprocess.check_output(\n        [pythondir + 'python', '-c',\n         'import platform; print platform.architecture()[0]'])\n    if pyth_str[:2] != target_arch_str:\n        raise Exception(\n            \"Wrong architecture of target python. Expected arch is\"\n            + target_arch_str)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading unzip and delete.", "response": "def downzip(url, destination='./sample_data/'):\n    \"\"\"\n    Download, unzip and delete.\n    \"\"\"\n\n    # url = \"http://147.228.240.61/queetech/sample-data/jatra_06mm_jenjatra.zip\"\n    logmsg = \"downloading from '\" + url + \"'\"\n    print(logmsg)\n    logger.debug(logmsg)\n    local_file_name = os.path.join(destination, 'tmp.zip')\n    urllibr.urlretrieve(url, local_file_name)\n    datafile = zipfile.ZipFile(local_file_name)\n    datafile.extractall(destination)\n    remove(local_file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(data_label=None, destination_dir=\".\"):\n    try:\n        os.mkdir(destination_dir)\n    except:\n        pass\n    if data_label is None:\n        data_label=data_urls.keys()\n\n    if type(data_label) == str:\n        data_label = [data_label]\n\n    for label in data_label:\n        # make all data:url have length 3\n        data_url = data_urls[label]\n        if type(data_url) == str:\n            # back compatibility\n            data_url = [data_url]\n        data_url.extend([None, None])\n        data_url = data_url[:3]\n        url, expected_hash, hash_path = data_url\n\n        if hash_path is None:\n            hash_path = label\n\n        try:\n            computed_hash = checksum(os.path.join(destination_dir, hash_path))\n        except:\n            # there is probably no checksumdir module\n            logger.warning(\"problem with sample_data.checksum()\")\n            computed_hash = None\n\n        logger.info(\"dataset '\" + label + \"'\")\n        logger.info(\"expected hash: '\" + str(expected_hash) + \"'\")\n        logger.info(\"computed hash: '\" + str(computed_hash) + \"'\")\n        if (computed_hash is not None) and (expected_hash == computed_hash):\n            logger.info(\"match ok - no download needed\")\n        else:\n            logger.info(\"downloading\")\n            downzip(url, destination=destination_dir)\n            logger.info(\"finished\")\n            downloaded_hash = checksum(os.path.join(destination_dir, hash_path))\n            logger.info(\"downloaded hash: '\" + str(downloaded_hash) + \"'\")\n            if downloaded_hash != expected_hash:\n                logger.warning(\"downloaded hash is different from expected hash\\n\" + \\\n                    \"expected hash: '\" + str(expected_hash) + \"'\\n\" + \\\n                    \"downloaded hash: '\" + str(downloaded_hash) + \"'\\n\")", "response": "Download sample data by label."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning checksum given by path. Wildcards can be used in check sum.", "response": "def checksum(path, hashfunc='md5'):\n    \"\"\"\n    Return checksum given by path. Wildcards can be used in check sum. Function is strongly\n    dependent on checksumdir package by 'cakepietoast'.\n\n    :param path:\n    :param hashfunc:\n    :return:\n    \"\"\"\n    import checksumdir\n    hash_func = checksumdir.HASH_FUNCS.get(hashfunc)\n    if not hash_func:\n        raise NotImplementedError('{} not implemented.'.format(hashfunc))\n\n    if os.path.isdir(path):\n        return checksumdir.dirhash(path, hashfunc=hashfunc)\n\n    hashvalues = []\n    path_list = glob.glob(path)\n    logger.debug(\"path_list \" + str(path_list))\n    for path in path_list:\n        if os.path.isfile(path):\n            hashvalues.append(checksumdir._filehash(path, hashfunc=hash_func))\n    logger.debug(str(hashvalues))\n    hash = checksumdir._reduce_hash(hashvalues, hashfunc=hash_func)\n    return hash"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef donut():\n    import numpy as np\n    segmentation = np.zeros([20, 30, 40])\n    # generate test data\n    segmentation[6:10, 7:24, 10:37] = 1\n    segmentation[6:10, 7, 10] = 0\n    segmentation[6:10, 23, 10] = 0\n    segmentation[6:10, 7, 36] = 0\n    segmentation[6:10, 23, 36] = 0\n    segmentation[2:18, 12:19, 18:28] = 2\n\n    data3d = segmentation * 100 + np.random.random(segmentation.shape) * 30\n    voxelsize_mm=[3,2,1]\n\n    datap = {\n        'data3d': data3d,\n        'segmentation': segmentation.astype(np.int8),\n        'voxelsize_mm': voxelsize_mm,\n        \"slab\": {\"donut\": 1, \"stick\": 2}\n    }\n    # io3d.write(datap, \"donut.pklz\")\n    return datap", "response": "Generate donut like shape with stick inside\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns anaconda or miniconda directory", "response": "def get_conda_path():\n    \"\"\"\n    Return anaconda or miniconda directory\n    :return: anaconda directory\n    \"\"\"\n\n    dstdir = ''\n    # try:\n    import subprocess\n    import re\n    # cond info --root work only for root environment\n    # p = subprocess.Popen(['conda', 'info', '--root'], stdout=subprocess.PIPE,  stderr=subprocess.PIPE)\n    p = subprocess.Popen(['conda', 'info', '-e'], stdout=subprocess.PIPE,  stderr=subprocess.PIPE)\n    out, err = p.communicate()\n\n    dstdir = out.strip()\n    dstdir = re.search(\"\\*(.*)\\n\", dstdir).group(1).strip()\n    # except:\n    #     import traceback\n    #     traceback.print_exc()\n\n    # import os.path as op\n    # conda_pth = op.expanduser('~/anaconda/bin')\n    # if not op.exists(conda_pth):\n    #     conda_pth = op.expanduser('~/miniconda/bin')\n    # return conda_pth\n    return dstdir"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Get(self,key):\n\n\t\tfor disk in self.disks:\n\t\t\tif disk.id == key:  return(disk)\n\t\t\telif key in disk.partition_paths:  return(disk)", "response": "Get a disk by providing mount point or partition path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches disk list by partial mount point or ID", "response": "def Search(self,key):\n\t\t\"\"\"Search disk list by partial mount point or ID\n\n\t\t\"\"\"\n\n\t\tresults = []\n\t\tfor disk in self.disks:\n\t\t\tif disk.id.lower().find(key.lower()) != -1:  results.append(disk)\n\t\t\t# TODO - search in list to match partial mount points\n\t\t\telif key.lower() in disk.partition_paths:  results.append(disk)\n\n\t\treturn(results)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding new disk to server.", "response": "def Add(self,size,path=None,type=\"partitioned\"):\n\t\t\"\"\"Add new disk.\n\n\t\tThis request will error if disk is protected and cannot be removed (e.g. a system disk)\n\n\t\t# Partitioned disk\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").Disks().Add(size=20,path=None,type=\"raw\").WaitUntilComplete()\n\t\t0\n\n\t\t# Raw disk\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").Disks().Add(size=20,path=None,type=\"raw\").WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tif type==\"partitioned\" and not path:  raise(clc.CLCException(\"Must specify path to mount new disk\"))\n\t\t# TODO - Raise exception if too many disks\n\t\t# TODO - Raise exception if too much total size (4TB standard, 1TB HS)\n\n\t\tdisk_set = [{'diskId': o.id, 'sizeGB': o.size} for o in self.disks]\n\t\tdisk_set.append({'sizeGB': size, 'type': type, 'path': path})\n\t\tself.disks.append(Disk(id=int(time.time()),parent=self,disk_obj={'sizeGB': size,'partitionPaths': [path]},session=self.session))\n\n\t\tself.size = size\n\t\tself.server.dirty = True\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('PATCH','servers/%s/%s' % (self.server.alias,self.server.id),\n\t\t                                       json.dumps([{\"op\": \"set\", \"member\": \"disks\", \"value\": disk_set}]),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.server.alias,\n\t\t\t\t\t\t\t   session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngrowing disk to the newly specified size.", "response": "def Grow(self,size):\n\t\t\"\"\"Grow disk to the newly specified size.\n\n\t\tSize must be less than 1024 and must be greater than the current size.\n\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").Disks().disks[2].Grow(30).WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tif size>1024:  raise(clc.CLCException(\"Cannot grow disk beyond 1024GB\"))\n\t\tif size<=self.size:  raise(clc.CLCException(\"New size must exceed current disk size\"))\n\t\t# TODO - Raise exception if too much total size (4TB standard, 1TB HS)\n\n\n\t\tdisk_set = [{'diskId': o.id, 'sizeGB': o.size} for o in self.parent.disks if o!=self]\n\t\tself.size = size\n\t\tdisk_set.append({'diskId': self.id, 'sizeGB': self.size})\n\t\tself.parent.server.dirty = True\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('PATCH','servers/%s/%s' % (self.parent.server.alias,self.parent.server.id),\n\t\t                                       json.dumps([{\"op\": \"set\", \"member\": \"disks\", \"value\": disk_set}]),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.parent.server.alias,\n\t\t\t\t\t\t\t   session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Delete(self):\n\n\t\tdisk_set = [{'diskId': o.id, 'sizeGB': o.size} for o in self.parent.disks if o!=self]\n\t\tself.parent.disks = [o for o in self.parent.disks if o!=self]\n\t\tself.parent.server.dirty = True\n\t\treturn(clc.v2.Requests(clc.v2.API.Call('PATCH','servers/%s/%s' % (self.parent.server.alias,self.parent.server.id),\n\t\t                                       json.dumps([{\"op\": \"set\", \"member\": \"disks\", \"value\": disk_set}]),\n\t\t\t\t\t\t\t\t\t\t\t   session=self.session),\n\t\t\t\t\t\t\t   alias=self.parent.server.alias,\n\t\t\t\t\t\t\t   session=self.session))", "response": "Delete disk.\n\n\t\tThis request will error if disk is protected and cannot be removed (e.g. a system disk)\n\n\t\t>>> clc.v2.Server(\"WA1BTDIX01\").Disks().disks[2].Delete().WaitUntilComplete()\n\t\t0"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsplits a name into unversioned name and version.", "response": "def split_name(name):\n    \"\"\"Splits a (possibly versioned) name into unversioned name and version.\n\n       Returns a tuple ``(unversioned_name, version)``, where ``version`` may\n       be ``None``.\n    \"\"\"\n    s = name.rsplit('@', 1)\n    if len(s) == 1:\n        return s[0], None\n    else:\n        try:\n            return s[0], int(s[1])\n        except ValueError:\n            raise ValueError(\"Invalid Filetracker filename: version must \"\n                             \"be int, not %r\" % (s[1],))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate SHA256 digest of a file.", "response": "def file_digest(source):\n    \"\"\"Calculates SHA256 digest of a file.\n\n    Args:\n        source: either a file-like object or a path to file\n    \"\"\"\n    hash_sha256 = hashlib.sha256()\n\n    should_close = False\n\n    if isinstance(source, six.string_types):\n        should_close = True\n        source = open(source, 'rb')\n\n    for chunk in iter(lambda: source.read(_BUFFER_SIZE), b''):\n        hash_sha256.update(chunk)\n\n    if should_close:\n        source.close()\n\n    return hash_sha256.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_xliff(entry_dict):\n    entries = \"\"\n    for key,value in entry_dict.iteritems():\n        entries+=create_trans_unit(key,value).strip()+\"\\n\"\n    xliff_str = get_head_xliff().strip()+\"\\n\"+entries+get_tail_xliff().strip()\n    return xliff_str", "response": "Generates a xliff file from a dictionary containing keys = ids\n    and values = strings"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the current value of the counter and then multiplies it by the current value of the counter by the current value of the counter and then increments the counter by factor.", "response": "def duration(self):\n        \"\"\"\n        Returns the current value of the counter and then multiplies it by\n        :attr:`factor`\n\n        :rtype: float\n        \"\"\"\n        d = self.for_attempt(self.cur_attempt)\n        self.cur_attempt += 1\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef for_attempt(self, attempt):\n        dur = float(self.min_ms * pow(self.factor, attempt))\n\n        if self.jitter:\n            dur = random.random() * (dur - self.min_ms) + self.min_ms\n\n        if dur > self.max_ms:\n            return to_seconds(self.max_ms)\n\n        return to_seconds(dur)", "response": "This method returns the duration in seconds for a specific attempt."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget alert by providing name ID or other unique key.", "response": "def Get(self,key):\n\t\t\"\"\"Get alert by providing name, ID, or other unique key.\n\n\t\tIf key is not unique and finds multiple matches only the first\n\t\twill be returned\n\t\t\"\"\"\n\n\t\tfor alert in self.alerts:\n\t\t\tif alert.id == key:  return(alert)\n\t\t\telif alert.name == key:  return(alert)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching alert list by providing partial name ID or other key.", "response": "def Search(self,key):\n\t\t\"\"\"Search alert list by providing partial name, ID, or other key.\n\n\t\t\"\"\"\n\n\t\tresults = []\n\t\tfor alert in self.alerts:\n\t\t\tif alert.id.lower().find(key.lower()) != -1:  results.append(alert)\n\t\t\telif alert.name.lower().find(key.lower()) != -1:  results.append(alert)\n\n\t\treturn(results)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlogging-in to retrieve bearer token and set default accoutn and location aliases.", "response": "def _Login():\n\t\t\"\"\"Login to retrieve bearer token and set default accoutn and location aliases.\"\"\"\n\t\tif not clc.v2.V2_API_USERNAME or not clc.v2.V2_API_PASSWD:\n\t\t\tclc.v1.output.Status('ERROR',3,'V2 API username and password not provided')\n\t\t\traise(clc.APIV2NotEnabled)\n\n\t\tsession = clc._REQUESTS_SESSION\n\t\tsession.headers['content-type'] = \"application/json\"\n\n\t\tr = session.request(\"POST\",\n                            \"%s/v2/%s\" % (clc.defaults.ENDPOINT_URL_V2,\"authentication/login\"),\n                            json={\"username\": clc.v2.V2_API_USERNAME, \"password\": clc.v2.V2_API_PASSWD},\n                            verify=API._ResourcePath('clc/cacert.pem'))\n\n\t\tif r.status_code == 200:\n\t\t\tclc._LOGIN_TOKEN_V2 = r.json()['bearerToken']\n\t\t\tclc.ALIAS = r.json()['accountAlias']\n\t\t\tclc.LOCATION = r.json()['locationAlias']\n\t\telif r.status_code == 400:\n\t\t\traise(Exception(\"Invalid V2 API login.  %s\" % (r.json()['message'])))\n\t\telse:\n\t\t\traise(Exception(\"Error logging into V2 API.  Response code %s. message %s\" % (r.status_code,r.json()['message'])))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting v2 API call.", "response": "def Call(method,url,payload=None,session=None,debug=False):\n\t\t\"\"\"Execute v2 API call.\n\n\t\t:param url: URL paths associated with the API call\n\t\t:param payload: dict containing all parameters to submit with POST call\n\n\t\t:returns: decoded API json result\n\t\t\"\"\"\n\t\tif session is not None:\n\t\t\ttoken = session['token']\n\t\t\thttp_session = session['http_session']\n\n\t\telse:\n\t\t\tif not clc._LOGIN_TOKEN_V2:\n\t\t\t\tAPI._Login()\n\t\t\ttoken = clc._LOGIN_TOKEN_V2\n\t\t\thttp_session = clc._REQUESTS_SESSION\n\n\t\tif payload is None:\n\t\t    payload = {}\n\n\t\t# If executing refs provided in API they are abs paths,\n\t\t# Else refs we build in the sdk are relative\n\t\tif url[0]=='/':  fq_url = \"%s%s\" % (clc.defaults.ENDPOINT_URL_V2,url)\n\t\telse:  fq_url = \"%s/v2/%s\" % (clc.defaults.ENDPOINT_URL_V2,url)\n\n\t\thttp_session.headers.update({'Authorization': \"Bearer %s\" % token})\n\n\t\tif isinstance(payload, basestring):  http_session.headers['content-type'] = \"Application/json\" # added for server ops with str payload\n\t\telse:  http_session.headers['content-type'] = \"application/x-www-form-urlencoded\"\n\n\t\tif method==\"GET\":\n\t\t\tr = http_session.request(method,fq_url,\n\t\t\t                     params=payload,\n\t\t\t\t\t\t\t\t verify=API._ResourcePath('clc/cacert.pem'))\n\t\telse:\n\t\t\tr = http_session.request(method,fq_url,\n\t\t\t                     data=payload,\n\t\t\t\t\t\t\t\t verify=API._ResourcePath('clc/cacert.pem'))\n\n\t\tif debug:\n\t\t\tAPI._DebugRequest(request=requests.Request(method,fq_url,data=payload,headers=http_session.headers).prepare(),\n\t\t\t                  response=r)\n\n\t\tif r.status_code>=200 and r.status_code<300:\n\t\t\ttry:\n\t\t\t\treturn(r.json())\n\t\t\texcept:\n\t\t\t\treturn({})\n\t\telse:\n\t\t\ttry:\n\t\t\t\te = clc.APIFailedResponse(\"Response code %s.  %s %s %s\" %\n\t\t\t\t                          (r.status_code,r.json()['message'],method,fq_url))\n\t\t\t\te.response_status_code = r.status_code\n\t\t\t\te.response_json = r.json()\n\t\t\t\te.response_text = r.text\n\t\t\t\traise(e)\n\t\t\texcept clc.APIFailedResponse:\n\t\t\t\traise\n\t\t\texcept:\n\t\t\t\te = clc.APIFailedResponse(\"Response code %s. %s. %s %s\" %\n\t\t\t\t                         (r.status_code,r.text,method,fq_url))\n\t\t\t\te.response_status_code = r.status_code\n\t\t\t\te.response_json = {}\t# or should this be None?\n\t\t\t\te.response_text = r.text\n\t\t\t\traise(e)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the external references of the element", "response": "def get_external_references(self):\n        \"\"\"\n        Returns the external references of the element\n        @rtype: L{CexternalReference}\n        @return: the external references (iterator)\n        \"\"\"\n        node = self.node.find('externalReferences')\n        if node is not None:\n            ext_refs = CexternalReferences(node)\n            for ext_ref in ext_refs:\n                yield ext_ref"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_external_reference(self,ext_ref):\n        #check if the externalreferences sublayer exist for the role, and create it in case\n        node_ext_refs = self.node.find('externalReferences')\n        ext_refs = None\n        if node_ext_refs == None:\n            ext_refs = CexternalReferences()\n            self.node.append(ext_refs.get_node())\n        else:\n            ext_refs = CexternalReferences(node_ext_refs)\n        \n        ext_refs.add_external_reference(ext_ref)", "response": "Adds an external reference to the role"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_external_references(self):\n        for ex_ref_node in self.node.findall('externalReferences'):\n            self.node.remove(ex_ref_node)", "response": "Removes any external references from the role"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves any external references on any of the roles in the predicate.", "response": "def remove_external_references_from_roles(self):\n        \"\"\"\n        Removes any external references on any of the roles from the predicate\n        \"\"\"\n        \n        for node_role in self.node.findall('role'):\n            role = Crole(node_role)\n            role.remove_external_references()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_roles(self, list_of_roles):\n        for role in list_of_roles:\n            role_node = role.get_node()\n            self.node.append(role_node)", "response": "Adds a list of roles to the predicate\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_role(self, role_obj):\n        role_node = role_obj.get_node()\n        self.node.append(role_node)", "response": "Adds a role to the predicate\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_external_reference_to_role(self,role_id,ext_ref):\n        node_role = self.map_roleid_node[role_id]\n        obj_role = Crole(node_role)\n        obj_role.add_external_reference(ext_ref)", "response": "Adds an external reference to a role identifier"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a predicate object to the layer.", "response": "def add_predicate(self, pred_obj):\n        \"\"\"\n        Adds a predicate object to the layer\n        @type pred_obj: L{Cpredicate}\n        @param pred_obj: the predicate object\n        \"\"\"\n        pred_id = pred_obj.get_id()\n        if not pred_id in self.idx:\n            pred_node = pred_obj.get_node()\n            self.node.append(pred_node)\n            self.idx[pred_id] = pred_node\n        else:\n            #FIXME we want new id rather than ignoring the element\n            print('Error: trying to add new element, but id has already been given')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef display_dp_matrix_attr(dp_matrix, attr_name):\n\n    print()\n    print(\"---------- {:s} ----------\".format(attr_name))\n    for dp_list in dp_matrix:\n        print([getattr(dp, attr_name) for dp in dp_list])", "response": "displays a value assocciated with an attribute for each DataProperty instance in the dp_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _doc(from_func):\n    '''copy doc from one function to another\n    use as a decorator eg::\n        \n        @_doc(file.tell)\n        def tell(..):\n            ...\n    '''\n    def decorator(to_func):\n        to_func.__doc__ = from_func.__doc__\n        return to_func\n    return decorator", "response": "copy doc from one function to another"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes the specified sql query and returns the cursor", "response": "def _query(self, sql, *args):\n      \"\"\" Executes the specified `sql` query and returns the cursor \"\"\"\n      if not self._con:\n          logger.debug((\"Open MBTiles file '%s'\") % self.filename)\n          self._con = sqlite3.connect(self.filename)\n          self._cur = self._con.cursor()\n      sql = ' '.join(sql.split())\n      logger.debug((\"Execute query '%s' %s\") % (sql, args))\n      try:\n          self._cur.execute(sql, *args)\n      except (sqlite3.OperationalError, sqlite3.DatabaseError) as e:\n          raise InvalidFormatError((\"%s while reading %s\") % (e, self.filename))\n      return self._cur"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_comment(self,c):\n        c = ' '+c.replace('-','').strip()+' '\n        self.node.insert(0,etree.Comment(c))", "response": "Sets the comment for the element\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_id(self,my_id):\n        if self.type == 'NAF':\n            self.node.set('id',my_id)\n        elif self.type == 'KAF':\n            self.node.set('oid',my_id)", "response": "Sets the opinion identifier of the class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the opinion layer to KAF", "response": "def to_kaf(self):\n        \"\"\"\n        Converts the opinion layer to KAF\n        \"\"\"\n        if self.type == 'NAF':\n            for node in self.__get_opinion_nodes():\n                node.set('oid',node.get('id'))\n                del node.attrib['id']"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the opinion layer to NAF", "response": "def to_naf(self):\n        \"\"\"\n        Converts the opinion layer to NAF\n        \"\"\"\n        if self.type == 'KAF':\n            for node in self.__get_opinion_nodes():\n                node.set('id',node.get('oid'))\n                del node.attrib['oid']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the opinion for the given opinion identifier from the set of available opinions.", "response": "def remove_this_opinion(self,opinion_id):\n        \"\"\"\n        Removes the opinion for the given opinion identifier\n        @type opinion_id: string\n        @param opinion_id: the opinion identifier to be removed\n        \"\"\"\n        for opi in self.get_opinions():\n            if opi.get_id() == opinion_id:\n                self.node.remove(opi.get_node())\n                break"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef GetAccountDetails(alias=None):\n\t\tif not alias:  alias = Account.GetAlias()\n\t\tr = clc.v1.API.Call('post','Account/GetAccountDetails',{'AccountAlias': alias})\n\t\tif r['Success'] != True: \n\t\t\tif clc.args:  clc.v1.output.Status('ERROR',3,'Error calling %s.   Status code %s.  %s' % ('Account/GetAccountDetails',r['StatusCode'],r['Message']))\n\t\t\traise Exception('Error calling %s.   Status code %s.  %s' % ('Account/GetAccountDetails',r['StatusCode'],r['Message']))\n\t\telif int(r['StatusCode']) == 0:  \n\t\t\tr['AccountDetails']['Status'] = Account.account_status_itos[r['AccountDetails']['Status']]\n\t\t\treturn(r['AccountDetails'])", "response": "Get account details dict associated with the provided alias."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all cloud locations available to the calling alias.", "response": "def GetLocations():\n\t\t\"\"\"Return all cloud locations available to the calling alias.\"\"\"\n\t\tr = clc.v1.API.Call('post','Account/GetLocations',{})\n\t\tif r['Success'] != True: \n\t\t\tif clc.args:  clc.v1.output.Status('ERROR',3,'Error calling %s.   Status code %s.  %s' % ('Account/GetLocations',r['StatusCode'],r['Message']))\n\t\t\traise Exception('Error calling %s.   Status code %s.  %s' % ('Account/GetLocations',r['StatusCode'],r['Message']))\n\t\telif int(r['StatusCode']) == 0:  \n\t\t\tclc.LOCATIONS = [x['Alias'] for x in r['Locations']]\n\t\t\treturn(r['Locations'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef GetAccounts(alias=None):\n\t\tif alias is not None:  payload = {'AccountAlias': alias}\n\t\telse:  payload = {}\n\t\tr = clc.v1.API.Call('post','Account/GetAccounts',payload)\n\t\tif int(r['StatusCode']) == 0:  \n\t\t\t# Assume first response is always the original account.  Not sure if this is reliable\n\t\t\tif not clc.ALIAS:  clc.ALIAS = r['Accounts'][0]['AccountAlias']\n\t\t\tif not clc.LOCATION:  clc.LOCATION = r['Accounts'][0]['Location']\n\n\t\t\treturn(r['Accounts'])", "response": "Return account inventory dict containing all subaccounts for the given alias. If None search from default alias."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assure_cache(project_path=None):\n\n    project_path = path(project_path, ISDIR)\n    cache_path = os.path.join(project_path, CACHE_NAME)\n\n    if not os.path.isdir(cache_path):\n        os.mkdir(cache_path)", "response": "Assure that a project directory has a cache folder."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef purge_project():\n    print('Current Directory: {}'.format(os.getcwd()))\n    directories = os.listdir(os.getcwd())\n    if CACHE_NAME in directories:\n        response = get_input(\"Would you like to delete the cache and\"\n                             \"everything in it? [y/n]: \", ('y', 'n'))\n        if response == 'y':\n            print(\"Listing local '__cythercache__':\")\n            cache_dir = os.path.join(os.getcwd(), \"__cythercache__\")\n            to_delete = []\n            contents = os.listdir(cache_dir)\n            if contents:\n                for filename in contents:\n                    print('\\t' + filename)\n                    filepath = os.path.join(cache_dir, filename)\n                    to_delete.append(filepath)\n            else:\n                print(\"\\tNothing was found in the cache\")\n\n            check_response = get_input(\"Delete all these files? (^)\"\n                                       \"[y/n]: \", ('y', 'n'))\n            if check_response == 'y':\n                for filepath in to_delete:\n                    os.remove(filepath)\n                os.rmdir(cache_dir)\n            else:\n                print(\"Skipping the deletion... all files are fine!\")\n        else:\n            print(\"Skipping deletion of the cache\")\n    else:\n        print(\"Couldn't find a cache file ('{}') in this \"\n              \"directory\".format(CACHE_NAME))", "response": "Purges a directory of anything cyther related"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef map(func, items, pool_size=10):\n    with OrderedPool(func, pool_size) as pool:\n        for count, item in enumerate(items):\n            pool.put(item)\n\n        for i in xrange(count + 1):\n            yield pool.get()", "response": "a parallelized work - alike to the built - in map function that returns a list of items from the items iterable."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart the pool s workers", "response": "def start(self):\n        \"start the pool's workers\"\n        for i in xrange(self.size):\n            scheduler.schedule(self._runner)\n        self._closing = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef close(self):\n        self._closing = True\n        for i in xrange(self.size):\n            self.inq.put(_STOP)", "response": "shut down the pool s workers\n            attribute"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self):\n        if self.closed:\n            raise PoolClosed()\n\n        result, succeeded = self.outq.get()\n        if not succeeded:\n            klass, exc, tb = result\n            raise klass, exc, tb\n        return result", "response": "retrieve a result from the pool"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close(self):\n        super(Pool, self).close()\n        for waiter, waketime in self.outq._waiters:\n            scheduler.schedule_exception(PoolClosed(), waiter)", "response": "shut down the pool s workers\n            attribute and raises a PoolClosed exception in any waiting coroutines still holding the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put(self, *args, **kwargs):\n        self.inq.put((self._putcount, (args, kwargs)))\n        self._putcount += 1", "response": "place a new item into the pool"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self):\n        if self.closed:\n            raise PoolClosed()\n\n        while self._getcount not in self._cache:\n            counter, result = self.outq.get()\n            self._cache[counter] = result\n\n        result, succeeded = self._cache.pop(self._getcount)\n        self._getcount += 1\n\n        if not succeeded:\n            klass, exc, tb = result\n            raise klass, exc, tb\n        return result", "response": "retrieve a result from the pool"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the entity object for the given entity identifier.", "response": "def get_entity(self,entity_id):\n        \"\"\"\n        Returns the entity object for the given entity identifier\n        @type entity_id: string\n        @param entity_id: the token identifier\n        @rtype: L{Centity}\n        @return: the entity object\n        \"\"\"  \n        entity_node = self.map_entity_id_to_node.get(entity_id)\n        if entity_node is not None:\n            return Centity(node=entity_node,type=self.type)\n        else:\n            for entity_node in self.__get_entity_nodes():\n                if self.type == 'NAF': \n                    label_id = 'id'\n                elif self.type == 'KAF': \n                    label_id = 'eid'\n                if entity_node.get(label_id) == entity_id:\n                    return Centity(node=entity_node, type=self.type)                                                                \n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_external_reference_to_entity(self,entity_id,ext_ref):\n        node_entity = self.map_entity_id_to_node.get(entity_id)\n        if node_entity is not None:\n            entity = Centity(node_entity,self.type)\n            entity.add_external_reference(ext_ref)\n        else:\n            print>>sys.stderr,'Trying to add a reference to the entity',entity_id,'but can not be found in this file'", "response": "Adds an external reference to an entity"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the layer from KAF to NAF", "response": "def to_kaf(self):\n        \"\"\"\n        Converts the layer from KAF to NAF\n        \"\"\"\n        if self.type == 'NAF':\n            for node in self.__get_entity_nodes():\n                node.set('eid',node.get('id'))\n                del node.attrib['id']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the layer from NAF to KAF", "response": "def to_naf(self):\n        \"\"\"\n        Converts the layer from NAF to KAF\n        \"\"\"\n        if self.type == 'KAF':\n            for node in self.__get_entity_nodes():\n                node.set('id',node.get('eid'))\n                del node.attrib['eid']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef updateImage(self, val):\n\n        # import ipdb\n        # ipdb.set_trace()\n\n        # Filtrovani\n\n        # Zjisteni jakou sigmu pouzit\n        if(self.firstRun == True and self.inputSigma >= 0):\n            sigma = np.round(self.inputSigma, 2)\n        elif self.interactivity:\n            sigma = np.round(self.ssigma.val, 2)\n        else:\n            sigma = np.round(self.inputSigma, 2)\n\n\n        # Prahovani (smin, smax)\n\n        # max_threshold = self.threshold_upper\n        # min_threshold = self.threshold\n\n        if self.interactivity:\n\n            self.smin.val = (np.round(self.smin.val, 2))\n            self.smin.valtext.set_text('{}'.format(self.smin.val))\n            self.smax.val = (np.round(self.smax.val, 2))\n            self.smax.valtext.set_text('{}'.format(self.smax.val))\n\n            self.threshold = self.smin.val\n            self.threshold_upper = self.smax.val\n\n            closeNum = int(np.round(self.sclose.val, 0))\n            openNum = int(np.round(self.sopen.val, 0))\n            self.sclose.valtext.set_text('{}'.format(closeNum))\n            self.sopen.valtext.set_text('{}'.format(openNum))\n\n        else:\n\n            closeNum = self.ICBinaryClosingIterations\n            openNum = self.ICBinaryOpeningIterations\n\n        # make_image_processing(sigma, min_threshold, max_threshold, closeNum, openNum, auto_method=self.)\n        self.imgFiltering, self.threshold = make_image_processing(data=self.data, voxelsize_mm=self.voxelsize_mm,\n                                                                  seeds=self.seeds, sigma_mm=sigma,\n                                                                  min_threshold=self.threshold,\n                                                                  max_threshold=self.threshold_upper, closeNum=closeNum,\n                                                                  openNum=openNum,\n                                                                  min_threshold_auto_method=self.auto_method,\n                                                                  fill_holes=self.fillHoles,\n                                                                  get_priority_objects=self.get_priority_objects,\n                                                                  nObj=self.nObj)\n        # Vykresleni dat\n        if (self.interactivity == True):\n            self.drawVisualization()\n\n        # Nastaveni kontrolnich hodnot\n        self.firstRun = False\n\n        garbage.collect()\n\n        self.debugInfo()", "response": "Update the image of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndrawing the midle slice of the data3d.", "response": "def __drawSegmentedSlice(self, ax, contour, i):\n        \"\"\"\n        Used for visualization of midle slice of the data3d\n        :param ax:\n        :param contour:\n        :param i:\n        :return:\n        \"\"\"\n        i = int(i)\n        ax.cla()\n        ax.imshow(self.data[i, :, :], cmap=self.cmap)\n\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        if contour is not None:\n            #ax.contour(contour[i, :, :])\n            logger.debug(\"type contour \" + str(type(contour)))\n            logger.debug(\"max contour \" + str(np.max(contour)))\n            logger.debug(\"min contour \" + str(np.min(contour)))\n            logger.debug(\"type contour \" + str(type(contour[i,:,:])))\n            logger.debug(\"max contour \" + str(np.max(contour[i,:,:])))\n            logger.debug(\"min contour \" + str(np.min(contour[i,:,:])))\n            contour_slice = contour[i, :, :]\n            if np.max(contour_slice) != np.min(contour_slice):\n                ax.contour(contour[i, :, :] + 1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a list of anti - affinity policies within a given account.", "response": "def GetAll(alias=None,location=None,session=None):\n\t\t\"\"\"Gets a list of anti-affinity policies within a given account.\n\n\t\thttps://t3n.zendesk.com/entries/44657214-Get-Anti-Affinity-Policies\n\n\t\t>>> clc.v2.AntiAffinity.GetAll()\n\t\t[<clc.APIv2.anti_affinity.AntiAffinity object at 0x10c65e910>, <clc.APIv2.anti_affinity.AntiAffinity object at 0x10c65ec90>]\n\n\t\t\"\"\"\n\t\tif not alias:  alias = clc.v2.Account.GetAlias(session=session)\n\n\t\tpolicies = []\n\t\tpolicy_resp = clc.v2.API.Call('GET','antiAffinityPolicies/%s' % alias,{},session=session)\n\t\tfor k in policy_resp:\n\t\t\tr_val = policy_resp[k]\n\t\t\tfor r in r_val:\n\t\t\t\tif r.get('location'):\n\t\t\t\t\tif location and r['location'].lower()!=location.lower():  continue\n\t\t\t\t\tservers = [obj['id'] for obj in r['links'] if obj['rel'] == \"server\"]\n\t\t\t\t\tpolicies.append(AntiAffinity(id=r['id'],name=r['name'],location=r['location'],servers=servers,session=session))\n\n\t\treturn(policies)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef GetLocation(location=None,alias=None,session=None):\n\t\tif not location:  location = clc.v2.Account.GetLocation(session=session)\n\n\t\treturn(AntiAffinity.GetAll(alias=alias,location=location,session=session))", "response": "Returns a list of anti - affinity policies within a specific location."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new anti - affinity policy within a given account.", "response": "def Create(name,alias=None,location=None,session=None):\n\t\t\"\"\"Creates a new anti-affinity policy within a given account.\n\n\t\thttps://t3n.zendesk.com/entries/45042770-Create-Anti-Affinity-Policy\n\n\t\t*TODO* Currently returning 400 error:\n\t\tclc.APIFailedResponse: Response code 400. . POST https://api.tier3.com/v2/antiAffinityPolicies/BTDI\n\n\t\t\"\"\"\n\n\t\tif not alias:  alias = clc.v2.Account.GetAlias(session=session)\n\t\tif not location:  location = clc.v2.Account.GetLocation(session=session)\n\n\t\tr = clc.v2.API.Call('POST','antiAffinityPolicies/%s' % alias,\n\t\t\t\t\t\t\tjson.dumps({'name': name, 'location': location}),\n\t\t\t\t\t\t\tsession=session)\n\t\treturn(AntiAffinity(id=r['id'],name=r['name'],location=r['location'],servers=[],session=session))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchanges the policy s name.", "response": "def Update(self,name):\n\t\t\"\"\"Change the policy's name.\n\n\t\thttps://t3n.zendesk.com/entries/45066480-Update-Anti-Affinity-Policy\n\n\t\t*TODO* - currently returning 500 error\n\n\t\t\"\"\"\n\n\t\tr = clc.v2.API.Call('PUT','antiAffinityPolicies/%s/%s' % (self.alias,self.id),{'name': name},session=self.session)\n\t\tself.name = name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Delete(self):\n\t\tr = clc.v2.API.Call('DELETE','antiAffinityPolicies/%s/%s' % (self.alias,self.id),{},session=self.session)", "response": "Delete an anti - affinity policy."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an _AbstractSyntaxTreeNode with some elements defaulted.", "response": "def _node(handler, single=None, multi=None):\n    \"\"\"Return an _AbstractSyntaxTreeNode with some elements defaulted.\"\"\"\n    return _AbstractSyntaxTreeNode(handler=handler,\n                                   single=(single if single else []),\n                                   multi=(multi if multi else []))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _recurse(node, *args, **kwargs):\n    node_name = node.__class__.__name__\n    try:\n        info_for_node = _NODE_INFO_TABLE[node_name]\n    except KeyError:\n        return\n\n    action = kwargs[info_for_node.handler]\n    depth = kwargs[\"depth\"]\n\n    # Invoke action if available\n    if action is not None:\n        action(node_name, node, depth)\n\n    # Recurse\n    recurse_kwargs = kwargs\n    kwargs[\"depth\"] = depth + 1\n\n    for single in info_for_node.single:\n        _recurse(getattr(node, single),\n                 *args,\n                 **recurse_kwargs)\n\n    for multi in info_for_node.multi:\n        for statement in getattr(node, multi):\n            _recurse(statement,\n                     *args,\n                     **recurse_kwargs)", "response": "Recursive print worker - recurses the AST and prints each node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a JSON dictionary to a SQL statement.", "response": "def json2sql(raw_json=None, **definition):  # pylint: disable=too-many-branches\n    \"\"\"Convert raw dictionary, JSON/YAML to SQL statement.\n\n    :param raw_json: raw JSON/YAML or file to convert to SQL statement\n    :type raw_json: str or file\n    :return: raw SQL statement\n    :rtype: str\n    \"\"\"\n    if raw_json and definition:\n        raise InputError(\"Cannot process dict and kwargs input at the same time\")\n\n    definition = load_input(raw_json or definition)\n    if not isinstance(definition, dict):\n        raise UnknownStatementError(\"Unknown statement parsed: %s (type: %s)\"\n                                    % (definition, type(definition)))\n\n    try:\n        statement = definition.pop('statement', None)\n        if statement is None:\n            raise NoStatementError(\"No statement provided\")\n\n        statement = statement.lower()\n\n        if statement == 'delete':\n            return delete2sql(definition)\n        elif statement == 'insert':\n            return insert2sql(definition)\n        elif statement == 'select':\n            return select2sql(definition)\n        elif statement == 'update':\n            return update2sql(definition)\n        elif statement == 'replace':\n            return replace2sql(definition)\n        else:\n            raise UnknownStatementError(\"Unknown statement provided '%s' in definition %s\"\n                                        % (statement, definition))\n    except Exception as exc:  # pylint: disable=broad-except\n        if isinstance(exc, Json2SqlError):\n            raise\n\n        raise Json2SqlInternalError(\"Internal json2sql error: %s\" % str(exc)) from exc\n\n    # Just to make Pylint happy :)\n    raise Json2SqlInternalError(\"Unreachable state reached\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_filename_filled_with_checked_labels(self, labels=None):\n        if labels is None:\n            labels = self.slab_wg.action_check_slab_ui()\n        string_labels = imma.get_nlabels(slab=self.slab_wg.slab, labels=labels, return_mode=\"str\")\n        filename = self.vtk_file.format(\n            \"-\".join(string_labels))\n        return filename", "response": "Fill used labels into filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef patched(module_name):\n    if module_name in _patchers:\n        return _patched_copy(module_name, _patchers[module_name])\n\n    # grab the unpatched version of the module for posterity\n    old_module = sys.modules.pop(module_name, None)\n\n    # apply all the standard library patches we have\n    saved = [(module_name, old_module)]\n    for name, patch in _patchers.iteritems():\n        new_mod = _patched_copy(name, patch)\n        saved.append((name, sys.modules.pop(name)))\n        sys.modules[name] = new_mod\n\n    try:\n        # import the requested module with patches in place\n        result = __import__(module_name, {}, {}, module_name.rsplit(\".\", 1)[0])\n    finally:\n        # put all the original modules back as they were\n        for name, old_mod in saved:\n            if old_mod is None:\n                sys.modules.pop(name, None)\n            else:\n                sys.modules[name] = old_mod\n\n    return result", "response": "import and return a named module with patches applied locally only\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a new contextmanager that patches modules in the specified order", "response": "def patched_context(*module_names, **kwargs):\n    \"\"\"apply emulation patches only for a specific context\n\n    :param module_names: var-args for the modules to patch, as in :func:`patch`\n    :param local:\n        if True, unpatching is done on every switch-out, and re-patching on\n        every switch-in, so that they are only applied for the one coroutine\n\n    :returns:\n        a contextmanager that patches on ``__enter__`` and unpatches on\n        ``__exit__``\n    \"\"\"\n    local = kwargs.pop('local', False)\n    if kwargs:\n        raise TypeError(\"patched_context() got an unexpected keyword \" +\n                        \"argument %r\" % kwargs.keys()[0])\n\n    patch(*module_names)\n    if local:\n        @scheduler.local_incoming_hook\n        @scheduler.local_outgoing_hook\n        def hook(direction, target):\n            {1: patch, 2: unpatch}[direction](*module_names)\n\n    yield\n\n    unpatch(*module_names)\n    if local:\n        scheduler.remove_local_incoming_hook(hook)\n        scheduler.remove_local_outgoing_hook(hook)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies monkey - patches to standard library modules in - place.", "response": "def patch(*module_names):\n    \"\"\"apply monkey-patches to stdlib modules in-place\n\n    imports the relevant modules and simply overwrites attributes on the module\n    objects themselves. those attributes may be functions, classes or other\n    attributes.\n\n    valid arguments are:\n\n    - __builtin__\n    - Queue\n    - fcntl\n    - os\n    - select\n    - signal\n    - socket\n    - ssl\n    - sys\n    - thread\n    - threading\n    - time\n    - zmq\n\n    with no arguments, patches everything it can in all of the above modules\n\n    :raises: ``ValueError`` if an unknown module name is provided\n\n    .. note::\n        lots more standard library modules can be made non-blocking by virtue\n        of patching some combination of the the above (because they only block\n        by using blocking functions defined elsewhere). a few examples:\n\n        - ``subprocess`` works cooperatively with ``os`` and ``select`` patched\n        - ``httplib``, ``urllib`` and ``urllib2`` will all operate\n          cooperatively with ``socket`` and ``ssl`` patched\n    \"\"\"\n    if not module_names:\n        module_names = _patchers.keys()\n\n    log.info(\"monkey-patching in-place (%d modules)\" % len(module_names))\n\n    for module_name in module_names:\n        if module_name not in _patchers:\n            raise ValueError(\"'%s' is not greenhouse-patchable\" % module_name)\n\n    for module_name in module_names:\n        if module_name in sys.modules:\n            module = sys.modules[module_name]\n        else:\n            module = __import__(\n                module_name, {}, {}, module_name.rsplit(\".\", 1)[0])\n        for attr, patch in _patchers[module_name].items():\n            setattr(module, attr, patch)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nundo monkey - patches to standard library modules", "response": "def unpatch(*module_names):\n    \"\"\"undo :func:`patch`\\es to standard library modules\n\n    this function takes one or more module names and puts back their patched\n    attributes to the standard library originals.\n\n    valid arguments are the same as for :func:`patch`.\n\n    with no arguments, undoes all monkeypatches that have been applied\n\n    :raises: ``ValueError`` if an unknown module name is provided\n    \"\"\"\n    if not module_names:\n        module_names = _standard.keys()\n\n    log.info(\"undoing monkey-patches in-place (%d modules)\" %\n             len(module_names))\n\n    for module_name in module_names:\n        if module_name not in _standard:\n            raise ValueError(\"'%s' is not greenhouse-patchable\" % module_name)\n\n    for module_name in module_names:\n        module = __import__(module_name, {}, {}, module_name.rsplit(\".\", 1)[0])\n        for attr, value in _standard[module_name].items():\n            setattr(module, attr, value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_json(data):\n\n        parsed_data = json.loads(data)\n        trigger = TriggerInfo(\n            parsed_data['trigger']['class'],\n            parsed_data['trigger']['kind'],\n        )\n\n        # extract content type, needed to decode body\n        content_type = parsed_data['content_type']\n\n        return Event(body=Event.decode_body(parsed_data['body'], content_type),\n                     content_type=content_type,\n                     trigger=trigger,\n                     fields=parsed_data.get('fields'),\n                     headers=parsed_data.get('headers'),\n                     _id=parsed_data['id'],\n                     method=parsed_data['method'],\n                     path=parsed_data['path'],\n                     size=parsed_data['size'],\n                     timestamp=datetime.datetime.utcfromtimestamp(parsed_data['timestamp']),\n                     url=parsed_data['url'],\n                     _type=parsed_data['type'],\n                     type_version=parsed_data['type_version'],\n                     version=parsed_data['version'])", "response": "Decode event encoded as JSON by processor"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef furtherArgsProcessing(args):\n    if isinstance(args, str):\n        unprocessed = args.strip().split(' ')\n        if unprocessed[0] == 'cyther':\n            del unprocessed[0]\n        args = parser.parse_args(unprocessed).__dict__\n    elif isinstance(args, argparse.Namespace):\n        args = args.__dict__\n    elif isinstance(args, dict):\n        pass\n    else:\n        raise CytherError(\n            \"Args must be a instance of str or argparse.Namespace, not '{}'\".format(\n                str(type(args))))\n\n    if args['watch']:\n        args['timestamp'] = True\n\n    args['watch_stats'] = {'counter': 0, 'errors': 0, 'compiles': 0,\n                           'polls': 0}\n    args['print_args'] = True\n\n    return args", "response": "Converts args and deals with incongruities that argparse couldn t handle\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef processFiles(args):\n    to_process = []\n\n    for filename in args['filenames']:\n        file = dict()\n\n        if args['include']:\n            file['include'] = INCLUDE_STRING + ''.join(\n                ['-I' + item for item in args['include']])\n        else:\n            file['include'] = INCLUDE_STRING\n\n        file['file_path'] = getPath(filename)\n        file['file_base_name'] = \\\n        os.path.splitext(os.path.basename(file['file_path']))[0]\n        file['no_extension'], file['extension'] = os.path.splitext(\n            file['file_path'])\n        if file['extension'] not in CYTHONIZABLE_FILE_EXTS:\n            raise CytherError(\n                \"The file '{}' is not a designated cython file\".format(\n                    file['file_path']))\n        base_path = os.path.dirname(file['file_path'])\n        local_build = args['local']\n        if not local_build:\n            cache_name = os.path.join(base_path, '__cythercache__')\n            os.makedirs(cache_name, exist_ok=True)\n            file['c_name'] = os.path.join(cache_name,\n                                          file['file_base_name']) + '.c'\n        else:\n            file['c_name'] = file['no_extension'] + '.c'\n        file['object_file_name'] = os.path.splitext(file['c_name'])[0] + '.o'\n        output_name = args['output_name']\n        if args['watch']:\n            file['output_name'] = file['no_extension']+DEFAULT_OUTPUT_EXTENSION\n        elif output_name:\n            if os.path.exists(output_name) and os.path.isfile(output_name):\n                file['output_name'] = output_name\n            else:\n                dirname = os.path.dirname(output_name)\n                if not dirname:\n                    dirname = os.getcwd()\n                if os.path.exists(dirname):\n                    file['output_name'] = output_name\n                else:\n                    raise CytherError('The directory specified to write'\n                                      'the output file in does not exist')\n        else:\n            file['output_name'] = file['no_extension']+DEFAULT_OUTPUT_EXTENSION\n\n        file['stamp_if_error'] = 0\n        to_process.append(file)\n    return to_process", "response": "Generates and error checks each file in the file list and processes the files."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a high level preset, it will construct the basic args to pass over. 'ninja', 'beast', 'minimal', 'swift'", "response": "def makeCommands(file):\n    \"\"\"\n    Given a high level preset, it will construct the basic args to pass over.\n    'ninja', 'beast', 'minimal', 'swift'\n    \"\"\"\n    commands = [['cython', '-a', '-p', '-o',\n                 file['c_name'], file['file_path']],\n                ['gcc', '-DNDEBUG', '-g', '-fwrapv', '-O3', '-Wall', '-Wextra',\n                 '-pthread', '-fPIC', '-c', file['include'], '-o',\n                 file['object_file_name'], file['c_name']],\n                ['gcc', '-g', '-Wall', '-Wextra', '-pthread', '-shared',\n                 RUNTIME_STRING, '-o', file['output_name'],\n                 file['object_file_name'], L_OPTION]]\n\n    return commands"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef collection(\n        et_model,\n        variable,\n        collections,\n        start_date,\n        end_date,\n        t_interval,\n        geometry,\n        **kwargs\n    ):\n    \"\"\"Generic OpenET Collection\n\n    Parameters\n    ----------\n    self :\n    et_model : {'ndvi', 'ssebop'}\n        ET model.\n    variable : str\n\n    collections : list\n        GEE satellite image collection IDs.\n    start_date : str\n        ISO format inclusive start date (i.e. YYYY-MM-DD).\n    end_date : str\n        ISO format exclusive end date (i.e. YYYY-MM-DD).\n    t_interval : {'daily', 'monthly', 'annual', 'overpass'}\n        Time interval over which to interpolate and aggregate values.\n        Selecting 'overpass' will return values only for the overpass dates.\n    geometry : ee.Geometry\n        The geometry object will be used to filter the input collections.\n    kwargs :\n\n    Returns\n    -------\n    ee.ImageCollection\n\n    Notes\n    -----\n    The following is just a basic framework for what needs to happen to\n        go from input parameters to an output image collection.\n    A lot of this might make more sense in the init function above.\n\n    \"\"\"\n\n    # Load the ET model\n    if et_model.lower() == 'ndvi':\n\n        # # DEADBEEF - Manually adding OpenET Model to system path\n        # # This will eventually be handled by import openet modules\n        # import os\n        # model_path = os.path.dirname(os.path.dirname(os.path.dirname(\n        #     os.path.abspath(os.path.realpath(__file__)))))\n        # print(model_path)\n        # sys.path.insert(0, os.path.join(model_path, 'openet-ndvi-test'))\n        # print(sys.path)\n\n        try:\n            import openet.ndvi as model\n        except ModuleNotFoundError:\n            print(\n                '\\nThe ET model {} could not be imported'.format(et_model) +\n                '\\nPlease ensure that the model has been installed')\n            return False\n        except Exception as e:\n            print('Unhandled Exception: {}'.format(e))\n            raise\n\n    elif et_model.lower() == 'ssebop':\n\n        # # DEADBEEF - Manually adding OpenET Models to system path\n        # # This will eventually be handled by import openet modules\n        # import os\n        # model_path = os.path.dirname(os.path.dirname(os.path.dirname(\n        #     os.path.abspath(os.path.realpath(__file__)))))\n        # print(model_path)\n        # sys.path.insert(0, os.path.join(model_path, 'openet-ssebop-test'))\n\n        try:\n            import openet.ssebop as model\n        except ModuleNotFoundError:\n            print(\n                '\\nThe ET model {} could not be imported'.format(et_model) +\n                '\\nPlease ensure that the model has been installed')\n            return False\n        except Exception as e:\n            print('Unhandled Exception: {}'.format(e))\n            raise\n\n    else:\n        # CGM - This could just be a value error exception\n        raise ValueError('unsupported et_model type')\n\n    variable_coll = model.collection(\n        variable,\n        collections,\n        start_date,\n        end_date,\n        t_interval,\n        geometry,\n        **kwargs\n    )\n    return variable_coll", "response": "Generic OpenET Collection object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_edges_as_list(self):\n        my_edges = []\n        for edge_node in self.__get_edge_nodes():\n            my_edges.append(Cedge(edge_node))\n        return my_edges", "response": "Iterator that returns all the edge objects\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a pretty - printed XML string for the Element.", "response": "def prettify(elem):\n    # from xml.etree.ElementTree import Element, SubElement, Comment, tostring\n    from xml.etree import ElementTree\n    from xml.dom import minidom\n    \"\"\"Return a pretty-printed XML string for the Element.\n    \"\"\"\n    rough_string = ElementTree.tostring(elem, 'utf-8')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent=\"  \")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new PVsm status file based on input vtk files.", "response": "def create_pvsm_file(vtk_files, pvsm_filename, relative_paths=True):\n    \"\"\"\n    Create paraview status file (.pvsm) based on input vtk files.\n    :param vtk_files:\n    :param pvsm_filename:\n    :param relative_paths:\n    :return:\n    \"\"\"\n    from xml.etree.ElementTree import Element, SubElement, Comment\n    import os.path as op\n\n    top = Element('ParaView')\n\n    comment = Comment('Generated for PyMOTW')\n    top.append(comment)\n\n    numberi = 4923\n    # vtk_file = \"C:\\Users\\miros\\lisa_data\\83779720_2_liver.vtk\"\n\n    sms = SubElement(top, \"ServerManagerState\", version=\"5.4.1\")\n    file_list = SubElement(sms, \"ProxyCollection\", name=\"sources\")\n    for vtk_file_orig in vtk_files:\n        numberi +=1\n        dir, vtk_file_head = op.split(vtk_file_orig)\n        if relative_paths:\n            vtk_file = vtk_file_head\n        else:\n            vtk_file = vtk_file_orig\n        number = str(numberi)\n        proxy1 = SubElement(sms, \"Proxy\", group=\"sources\", type=\"LegacyVTKFileReader\", id=number, servers=\"1\")\n        property = SubElement(proxy1, \"Property\", name=\"FileNameInfo\", id=number + \".FileNameInfo\", number_of_elements=\"1\")\n        element = SubElement(property, \"Element\", index=\"0\", value=vtk_file)\n        property2 = SubElement(proxy1, \"Property\", name=\"FileNames\", id=number + \".FileNames\", number_of_elements=\"1\")\n        pr2s1 = SubElement(property2, \"Element\", index=\"0\", value=vtk_file)\n        pr2s2 = SubElement(property2, \"Domain\", name=\"files\", id=number + \".FileNames.files\")\n\n    #     < Property\n    #     name = \"Opacity\"\n    #     id = \"8109.Opacity\"\n    #     number_of_elements = \"1\" >\n    #     < Element\n    #     index = \"0\"\n    #     value = \"0.28\" / >\n    #     < Domain\n    #     name = \"range\"\n    #     id = \"8109.Opacity.range\" / >\n    # < / Property >\n\n        fn1 = SubElement(file_list, \"Item\", id=number, name=vtk_file_head)\n\n    xml_str = prettify(top)\n    # logger.debug(xml_str)\n    with open(op.expanduser(pvsm_filename), \"w\") as file:\n        file.write(xml_str)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the parameters for the image resize", "response": "def set_resize_parameters(\n            self,\n            degrad=6,\n            labels=None,\n            resize_mm=None,\n            resize_voxel_number=None,\n\n    ):\n        \"\"\"\n        set_input_data() should be called before\n        :param degrad:\n        :param labels:\n        :param resize_mm:\n        :param resize_voxel_number:\n        :return:\n        \"\"\"\n        # from . import show_segmentation\n\n        logger.debug(\"set_resize_parameters(\\ndegrad={}, \\nlabels={}\\nresize_mm={}\\nresize_voxel_number={}\".format(\n            degrad, labels, resize_mm, resize_voxel_number\n        ))\n        degrad = int(degrad)\n\n        # import ipdb; ipdb.set_trace()\n        # return voxelsize_mm, degrad\n        self.degrad = degrad\n        self.labels = labels\n        segmentation = self._select_labels(self.segmentation, labels)\n\n        if resize_voxel_number is not None:\n            nvoxels = np.sum(segmentation > 0)\n            volume = nvoxels * np.prod(self.voxelsize_mm)\n            voxel_volume = volume / float(resize_voxel_number)\n            resize_mm = voxel_volume ** (1.0 / 3.0)\n        else:\n            resize_mm = np.mean(self.voxelsize_mm)\n        # self.working_voxelsize_mm = voxelsize_mm\n        # self.working_segmentation = segmentation\n        if np.sum(np.abs(self.resize_mm_1d - resize_mm)) != 0:\n            # resize parameter changed\n            self.resized_segmentation = None\n            self.resized_binar_segmentation = None\n\n        self.resize_mm_1d = resize_mm"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nselects binar labels based on input segmentation and labels.", "response": "def select_labels(self, labels=None):\n        \"\"\" Prepare binar segmentation based on input segmentation and labels.\n\n        :param labels:\n        :return:\n        \"\"\"\n        self._resize_if_required()\n        segmentation = self._select_labels(self.resized_segmentation, labels)\n        # logger.debug(\"select labels in show_segmentation {} sum {}\".format(labels, np.sum(segmentation)))\n        self.resized_binar_segmentation = segmentation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _select_labels(self, segmentation, labels=None):\n\n        logger.debug(\"select_labels() started with labels={}\".format(labels))\n        if self.slab is not None and labels is not None:\n            segmentation_out = select_labels(segmentation, labels, slab=self.slab)\n        else:\n            logger.warning(\"Nothing found for labels \" + str(labels))\n            un = np.unique(segmentation)\n            if len(un) < 2:\n                logger.error(\"Just one label found in input segmenation\")\n            segmentation_out = (segmentation > un[0]).astype(segmentation.dtype)\n        return segmentation_out", "response": "Select the labels from input segmentation"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _resize_if_required(self):\n        # orig_dtype = self.binar_segmentation.dtype\n\n        # if orig_dtype == np.bool:\n        #     segmentation = self.binar_segmentation.astype(np.int8)\n        # else:\n        #     segmentation = self.binar_segmentation\n        if self.resized_segmentation is None:\n            # segmentation = self.binar_segmentation\n            segmentation = self.segmentation\n\n            segmentation = segmentation[::self.degrad, ::self.degrad, ::self.degrad]\n            voxelsize_mm = self.voxelsize_mm * self.degrad\n\n            if self.resize_mm_1d is not None:\n                logger.debug(\"resize begin\")\n                new_voxelsize_mm = np.asarray([self.resize_mm_1d, self.resize_mm_1d, self.resize_mm_1d])\n                import imtools\n                prev_shape = segmentation.shape\n                segmentation = imtools.image_manipulation.resize_to_mm(segmentation, voxelsize_mm=voxelsize_mm,\n                                                                       new_voxelsize_mm=new_voxelsize_mm, order=0)\n                voxelsize_mm = new_voxelsize_mm\n                logger.debug(\"resize finished, old shape = {}, new shape = {}\".format(str(prev_shape), str(segmentation.shape)))\n                # logger.debug(\"segmentation min={}, max={}\".format(np.min(segmentation), np.max(segmentation)))\n            self.resized_segmentation = segmentation\n            self.resized_voxelsize_mm = voxelsize_mm", "response": "Internal method to resize the image of the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_mesh_file(\n            self,\n            labels=None,\n            ):\n        \"\"\" Make one mesh (vtk or stl) file\n\n        :param label: labels from prev use of set_labels are used if None\n\n        :return: filename of output file\n\n        Funkce vrac\u00ed trojrozm\u011brn\u00e9 porobn\u00e9 jako data['segmentation']\n        v data['slab'] je pops\u00e1no, co kter\u00e1 hodnota znamen\u00e1\n        \"\"\"\n\n        if labels is None:\n            labels=self.labels\n\n        strlabel = imma.get_nlabels(slab=self.slab, labels=labels, return_mode=\"str\")\n        if strlabel is list:\n            # if one file with {} in pattern is created\n            strlabel = \"-\".join(strlabel)\n        logger.debug(strlabel)\n        mesh_filename = self.output_file_pattern.format(strlabel)\n        logger.debug(mesh_filename)\n\n        self._resize_if_required()\n        # sed3.show_slices(self.resized_segmentation)\n\n        self.select_labels(labels)\n        # import sed3\n        # sed3.show_slices(self.binar_segmentation)\n\n        # _stats(self.segmentation)\n        # _stats(self.binar_segmentation)\n        _stats(self.resized_segmentation)\n\n        # import pdb; pdb.set_trace()\n        logger.debug(\"gen_mesh_from_voxels_mc() started\")\n        mesh_data = gen_mesh_from_voxels_mc(self.resized_binar_segmentation, self.resized_voxelsize_mm)\n        if self.smoothing:\n            mesh_data.coors = smooth_mesh(mesh_data)\n            # mesh_data.coors = seg2fem.smooth_mesh(mesh_data)\n\n        else:\n            pass\n            # mesh_data = gen_mesh_from_voxels_mc(segmentation, voxelsize_mm * 1.0e-2)\n            # mesh_data.coors +=\n        logger.debug(\"gen_mesh_from_voxels_mc() finished\")\n        pth, ext = op.splitext(mesh_filename)\n        if ext == \".stl\":\n            vtk_filename = mesh_filename + \".vtk\"\n        else:\n            vtk_filename = mesh_filename\n        mesh_data.write(vtk_filename)\n\n        if ext == \".stl\":\n            vtk2stl.vtk2stl(vtk_filename, mesh_filename)\n        return mesh_filename", "response": "Make one mesh file for a given set of voxels."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a template by providing name ID or other unique key.", "response": "def Get(self,key):\n\t\t\"\"\"Get template by providing name, ID, or other unique key.\n\n\t\tIf key is not unique and finds multiple matches only the first\n\t\twill be returned\n\t\t\"\"\"\n\n\t\tfor template in self.templates:\n\t\t\tif template.id == key:  return(template)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch template list by providing partial name ID or other key.", "response": "def Search(self,key):\n\t\t\"\"\"Search template list by providing partial name, ID, or other key.\n\n\t\t\"\"\"\n\n\t\tresults = []\n\t\tfor template in self.templates:\n\t\t\tif template.id.lower().find(key.lower()) != -1:  results.append(template)\n\t\t\telif template.name.lower().find(key.lower()) != -1:  results.append(template)\n\n\t\treturn(results)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef SecondsToZuluTS(secs=None):\n\n\tif not secs:  secs = int(time.time())\n\n\treturn(datetime.utcfromtimestamp(secs).strftime(\"%Y-%m-%dT%H:%M:%SZ\"))", "response": "Returns Zulu TS from unix time seconds."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing the DistanceClassifier from the provided training data and class labels.", "response": "def fit(self, features, classes):\n        \"\"\"Constructs the DistanceClassifier from the provided training data\n\n        Parameters\n        ----------\n        features: array-like {n_samples, n_features}\n            Feature matrix\n        classes: array-like {n_samples}\n            List of class labels for prediction\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        # class labels\n        classes = self.le.fit_transform(classes)\n\n        # group the data by class label\n        X = []\n        self.mu = []\n        self.Z = []\n        for i in np.unique(classes):\n            X.append(features[classes == i])\n            self.mu.append(np.mean(X[i],axis=0))\n            if self.d == 'mahalanobis':\n                self.Z.append(np.cov(X[i].transpose()))\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npredicts class outputs for an unlabelled feature set", "response": "def predict(self, features):\n        \"\"\"Predict class outputs for an unlabelled feature set\"\"\"\n\n        # get distance of features to class clusters\n        distances = [self._distance(x) for x in features]\n\n        # assign class label belonging to smallest distance\n        class_predict = [np.argmin(d) for d in distances]\n\n        return self.le.inverse_transform(class_predict)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _distance(self,x):\n        distance = np.empty([len(self.mu)])\n\n        for i in np.arange(len(self.mu)):\n            if self.d == 'mahalanobis' and self.is_invertible(self.Z[i]):\n                    distance[i] = (x - self.mu[i]).dot(np.linalg.inv(self.Z[i])).dot((x - self.mu[i]).transpose())\n            else:\n                distance[i] = (x - self.mu[i]).dot((x - self.mu[i]).transpose())\n\n        return distance", "response": "returns distance measures for features"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fit_predict(self, features, classes):\n        self.fit(features, classes)\n        return self.predict(features)", "response": "Convenience function that fits the provided data then predicts the class labels\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef score(self, features, classes, scoring_function=accuracy_score, **scoring_function_kwargs):\n        if not self.mu:\n            raise ValueError('The DistanceClassifier model must be fit before score() can be called')\n\n        return scoring_function(classes, self.predict(features), **scoring_function_kwargs)", "response": "Estimates the accuracy of the predictions from the constructed feature set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if Z is invertible", "response": "def is_invertible(self,X):\n        \"\"\"checks if Z is invertible\"\"\"\n        if len(X.shape) == 2:\n            return X.shape[0] == X.shape[1] and np.linalg.matrix_rank(X) == X.shape[0]\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the span object of the term", "response": "def get_span_ids(self):\n        \"\"\"\n        Returns the span object of the term\n        @rtype: List\n        @return: the term span as list of wf ids\n        \"\"\"\n        node_span = self.node.find('span')\n        if node_span is not None:\n            mySpan = Cspan(node_span)\n            span_ids = mySpan.get_span_ids()\n            return span_ids\n        else:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_span_from_ids(self, span_list):\n        this_span = Cspan()\n        this_span.create_from_ids(span_list)\n        self.node.append(this_span.get_node())", "response": "Sets the span for the term from list of ids"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_naf(self):\n        if self.type == 'KAF':\n            self.type = 'NAF'\n            for node in self.__get_node_terms():\n                node.set('id',node.get('tid'))\n                del node.attrib['tid']", "response": "Converts the object to NAF"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_term(self,term_id):\n        if term_id in self.idx:\n            return Cterm(self.idx[term_id],self.type)\n        else:\n            return None", "response": "Returns the term object for the supplied identifier"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a term object to the layer", "response": "def add_term(self,term_obj):\n        \"\"\"\n        Adds a term object to the layer\n        @type term_obj: L{Cterm}\n        @param term_obj: the term object\n        \"\"\"\n        if term_obj.get_id() in self.idx:\n            raise ValueError(\"Term with id {} already exists!\"\n                             .format(term_obj.get_id()))\n        self.node.append(term_obj.get_node())\n        self.idx[term_obj.get_id()] = term_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_external_reference(self,term_id, external_ref):\n        if term_id in self.idx:\n            term_obj = Cterm(self.idx[term_id],self.type)\n            term_obj.add_external_reference(external_ref)\n        else:\n            print('{term_id} not in self.idx'.format(**locals()))", "response": "Adds an external reference for the given term"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove a list of terms from the layer", "response": "def remove_terms(self,list_term_ids):\n        \"\"\"\n        Removes a list of terms from the layer\n        @type list_term_ids: list\n        @param list_term_ids: list of term identifiers to be removed  \n        \"\"\"\n        nodes_to_remove = set()\n        for term in self:\n            if term.get_id() in list_term_ids:\n                nodes_to_remove.add(term.get_node())\n                #For removing the previous comment\n                prv = term.get_node().getprevious()\n                if prv is not None:\n                    nodes_to_remove.add(prv)\n        \n        for node in nodes_to_remove:\n            self.node.remove(node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates widget with segmentation labels information used to select labels.", "response": "def init_slab(self, slab=None, segmentation=None, voxelsize_mm=None, show_ok_button=False):\n        \"\"\"\n        Create widget with segmentation labels information used to select labels.\n\n        :param slab: dict with label name and its id\n        :param segmentation: 3D label ndarray\n        :param voxelsize_mm: size of voxel in mm\n        :return:\n        \"\"\"\n        self.segmentation = segmentation\n        self.voxelsize_mm = voxelsize_mm\n\n        from . import show_segmentation\n        self.slab = show_segmentation.create_slab_from_segmentation(\n            self.segmentation, slab=slab)\n\n        if show_ok_button:\n            ok_button = QPushButton(\"Ok\")\n            ok_button.clicked.connect(self._action_ok_button)\n\n            self.superMainScrollLayout.addWidget(ok_button)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a deep list of all Servers for a given location.", "response": "def GetServers(location,group=None,alias=None,name_groups=False):\n\t\t\"\"\"Gets a deep list of all Servers for a given Hardware Group and its sub groups, or all Servers for a given location.\n\n\t\thttps://www.ctl.io/api-docs/v1/#server-getallservers\n\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param location: datacenter where group resides\n\t\t:param group: group name\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tpayload = {'AccountAlias': alias }\n\t\tif group:  payload['HardwareGroupUUID'] = clc.v1.Group.GetGroupUUID(group,alias,location)\n\t\telse:  payload['Location'] = location\n\n\t\ttry:\n\t\t\tr = clc.v1.API.Call('post','Server/GetAllServers', payload)\n\t\t\tif name_groups:  r['Servers'] = clc.v1.Group.NameGroups(r['Servers'],'HardwareGroupUUID')\n\t\t\tif int(r['StatusCode']) == 0:  return(r['Servers'])\n\t\texcept Exception as e:\n\t\t\tif str(e)==\"Hardware does not exist for location\":  return([])\n\t\t\telse:  raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a deep list of all Servers in all groups and datacenters.", "response": "def GetAllServers(alias=None,name_groups=False):\n\t\t\"\"\"Gets a deep list of all Servers in all groups and datacenters.\n\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tservers = []\n\t\tclc.v1.Account.GetLocations()\n\t\tfor location in clc.LOCATIONS:\n\t\t\ttry:\n\t\t\t\tr = clc.v1.API.Call('post','Server/GetAllServers', {'AccountAlias': alias, 'Location': location }, hide_errors=[5,] )\n\t\t\t\tif name_groups:  r['Servers'] = clc.v1.Group.NameGroups(r['Servers'],'HardwareGroupUUID')\n\t\t\t\tif int(r['StatusCode']) == 0:  servers += r['Servers']\n\t\t\texcept:\n\t\t\t\tpass\n\t\treturn(servers)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the list of Templates available to the account and location.", "response": "def GetTemplates(alias=None,location=None):\n\t\t\"\"\"Gets the list of Templates available to the account and location.\n\n\t\thttps://t3n.zendesk.com/entries/23102683-List-Available-Server-Templates\n\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param location: datacenter where group resides\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\n\t\tr = clc.v1.API.Call('post','Server/ListAvailableServerTemplates', { 'AccountAlias': alias, 'Location': location } )\n\t\treturn(r['Templates'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a template name return the unique OperatingSystem ID.", "response": "def GetTemplateID(alias,location,name):\n\t\t\"\"\"Given a template name return the unique OperatingSystem ID.\n\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param location: datacenter where group resides\n\t\t:param name: template name\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\n\t\tr = Server.GetTemplates(alias,location)\n\t\tfor row in r:\n\t\t\tif row['Name'].lower() == name.lower():  return(row['OperatingSystem'])\n\t\telse:\n\t\t\tif clc.args:  clc.v1.output.Status(\"ERROR\",3,\"Template %s not found in account %s datacenter %s\" % (name,alias,location))\n\t\t\traise Exception(\"Template not found\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new server.", "response": "def Create(name,template,cpu,ram,backup_level,group,alias=None,location=None,network='',description='',password=''):\n\t\t\"\"\"Gets the list of Templates available to the account and location.\n\n\t\thttps://www.centurylinkcloud.com/api-docs/v1/#server-create-server\n\n\t\t:param alias: short code for a particular account.  If None will use account's default alias\n\t\t:param location: datacenter where group resides.  If None will use account's default location\n\t\t:param name: server name up to 6 character string that' embedded in final server hostname\n\t\t:param template: template name for the server template to base build off\n\t\t:param cpu: int number of CPUs from 1-16\n\t\t:param ram: int RAM from 1-128\n\t\t:param backup_level: Standard or Premium\n\t\t:param group: name of group or group ID for server to belong to\n\t\t:param network: name of the network to which to deploy the server.  If your account has not yet been assigned a network, leave this blank and one will be assigned automatically\n\t\t:param description: optional description for the server.  If None the server name will be used.\n\t\t:param password: optional administrator password.  If None the system will generate one\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tif re.match(\"([a-zA-Z0-9]){32}\",group.replace(\"-\",\"\")):  groups_uuid = group\n\t\telse:  groups_uuid = clc.v1.Group.GetGroupUUID(group,alias,location)\n\n\t\tr = clc.v1.API.Call('post','Server/CreateServer', \n\t\t                    { 'AccountAlias': alias, 'LocationAlias': location, 'Description': description, 'Template': template,\n\t\t\t\t\t\t\t  'Alias': name, 'HardwareGroupUUID': groups_uuid, 'ServerType': 1, 'ServiceLevel': Server.backup_level_stoi[backup_level], \n\t\t\t\t\t\t\t  'Cpu': cpu, 'MemoryGB': ram, 'ExtraDriveGB': 0, 'Network': network, 'Password': password })\n\t\tif int(r['StatusCode']) == 0:  return(r)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting an existing server into a template.", "response": "def ConvertToTemplate(server,template,password=None,alias=None):\n\t\t\"\"\"Converts an existing server into a template.\n\n\t\thttp://www.centurylinkcloud.com/api-docs/v1/#server-convert-server-to-template\n\n\t\t:param server: source server to convert\n\t\t:param template: name of destination template\n\t\t:param password: source server password (optional - will lookup password if None)\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif password is None:  password = clc.v1.Server.GetCredentials([server,],alias)[0]['Password']\n\n\t\tr = clc.v1.API.Call('post','Server/ConvertServerToTemplate', \n\t\t                    { 'AccountAlias': alias, 'Name': server, 'Password': password, 'TemplateAlias': template })\n\t\treturn(r)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef RestoreServer(server,group,alias,location):\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tif re.match(\"([a-zA-Z0-9]){32}\",group.replace(\"-\",\"\")):  groups_uuid = group\n\t\telse:  groups_uuid = clc.v1.Group.GetGroupUUID(group,alias,location)\n\n\t\tr = clc.v1.API.Call('post','Server/RestoreServer', \n\t\t                    { 'AccountAlias': alias, 'Name': server, 'HardwareGroupUUID': groups_uuid })\n\t\tif int(r['StatusCode']) == 0:  return(r)", "response": "Restores an archived server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\narchives the specified servers.", "response": "def _ServerActions(action,alias,servers):\n\t\t\"\"\"Archives the specified servers.\n\n\t\t:param action: the server action url to exec against\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param servers: list of server names\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tresults = []\n\t\tfor server in servers:\n\t\t\tr = clc.v1.API.Call('post','Server/%sServer' % (action), {'AccountAlias': alias, 'Name': server })\n\t\t\tif int(r['StatusCode']) == 0:  results.append(r)\n\t\treturn(results)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GetDisks(server,alias=None,guest_names=True):\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\n\t\tr = clc.v1.API.Call('post','Server/ListDisks', { 'AccountAlias': alias, 'Name': server, 'QueryGuestDiskNames': guest_names } )\n\t\treturn(r['Disks'])", "response": "Returns list of disks configured for a particular server."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete the specified disk. https://www.ctl.io/api-docs/v1/#server-delete-disk :param alias: short code for a particular account. If None will use account's default alias :param server: server name :param scsi_bus_id: bus ID associated with disk :param scsi_device_id: disk ID associated with disk", "response": "def DeleteDisk(server,scsi_bus_id,scsi_device_id,alias=None):\n\t\t\"\"\"Deletes the specified disk.\n\n\t\thttps://www.ctl.io/api-docs/v1/#server-delete-disk\n\n\t\t:param alias: short code for a particular account.  If None will use account's default alias\n\t\t:param server: server name\n\t\t:param scsi_bus_id: bus ID associated with disk\n\t\t:param scsi_device_id: disk ID associated with disk\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\n\t\tr = clc.v1.API.Call('post','Server/DeleteDisk', \n\t\t                   {'AccountAlias': alias, 'Name': server, 'OverrideFailsafes': True,\n\t\t\t\t\t\t    'ScsiBusID': scsi_bus_id, 'ScsiDeviceID': scsi_device_id })\n\t\treturn(r)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_external_references(self):\n        for ext_ref_node in self.node.findall('externalRef'):\n            ext_refs_obj = CexternalReference(ext_ref_node)\n            for ref in ext_refs_obj:\n                yield ref", "response": "Iterate that returns all the external reference objects of the external references"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the identifier for the token", "response": "def set_id(self,this_id):\n        \"\"\"\n        Set the identifier for the token\n        @type this_id: string\n        @param this_id: the identifier\n        \"\"\"\n        if self.type == 'NAF':\n            return self.node.set('id',this_id)\n        elif self.type == 'KAF':\n            return self.node.set('wid',this_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the object to KAF", "response": "def to_kaf(self):\n        \"\"\"\n        Converts the object to KAF (if it is NAF)\n        \"\"\"\n        if self.type == 'NAF':\n            self.type = 'KAF'\n            for node in self.__get_wf_nodes():\n                node.set('wid',node.get('id'))\n                del node.attrib['id']"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the object to NAF", "response": "def to_naf(self):\n        \"\"\"\n        Converts the object to NAF\n        \"\"\"\n        if self.type == 'KAF':\n            self.type = 'NAF'\n            for node in self.__get_wf_nodes():\n                node.set('id',node.get('wid'))\n                del node.attrib['wid']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_wf(self,token_id):\n        wf_node = self.idx.get(token_id)\n        if wf_node is not None:\n            return Cwf(node=wf_node,type=self.type)\n        else:\n            for wf_node in self.__get_wf_nodes():\n                if self.type == 'NAF': label_id = 'id'\n                elif self.type == 'KAF': label_id = 'wid'\n                if wf_node.get(label_id) == token_id:\n                    return Cwf(node=wf_node, type=self.type)                                                                \n            return None", "response": "Returns the token object for the given token identifier"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a token object to the text layer.", "response": "def add_wf(self,wf_obj):\n        \"\"\"\n        Adds a token object to the text layer\n        @type wf_obj: L{Cwf}\n        @param wf_obj: token object\n        \"\"\"\n        if wf_obj.get_id() in self.idx:\n            raise ValueError(\"Text node (wf) with id {} already exists!\"\n                             .format(wf_obj.get_id()))\n        self.node.append(wf_obj.get_node())\n        self.idx[wf_obj.get_id()] = wf_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_tokens_of_sentence(self,sentence_id):\n        nodes_to_remove = set()\n        for wf in self:\n            if wf.get_sent() == sentence_id:\n                nodes_to_remove.add(wf.get_node())\n        \n        for node in nodes_to_remove:\n            self.node.remove(node)", "response": "Removes the tokens of the given sentence from the list of nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a daily ETa collection from ETo and ETf collections.", "response": "def daily(target_coll, source_coll, interp_days=32, interp_method='linear'):\n    \"\"\"Generate daily ETa collection from ETo and ETf collections\n\n    Parameters\n    ----------\n    target_coll : ee.ImageCollection\n        Source images will be interpolated to each target image time_start.\n        Target images should have a daily time step.  This will typically be\n        the reference ET (ETr) collection.\n    source_coll : ee.ImageCollection\n        Images that will be interpolated to the target image collection.\n        This will typically be the fraction of reference ET (ETrF) collection.\n    interp_days : int, optional\n        Number of days before and after each image date to include in the\n        interpolation (the default is 32).\n    interp_method : {'linear'}, optional\n        Interpolation method (the default is 'linear').\n\n    Returns\n    -------\n    ee.ImageCollection() of daily interpolated images\n\n    Raises\n    ------\n    ValueError\n        If `interp_method` is not a supported method.\n\n    \"\"\"\n\n    # # DEADBEEF - This module is assuming that the time band is already in\n    # #   the source collection.\n    # # Uncomment the following to add a time band here instead.\n    # def add_utc0_time_band(image):\n    #     date_0utc = utils.date_0utc(ee.Date(image.get('system:time_start')))\n    #     return image.addBands([\n    #         image.select([0]).double().multiply(0).add(date_0utc.millis())\\\n    #             .rename(['time'])])\n    # source_coll = ee.ImageCollection(source_coll.map(add_utc0_time_band))\n\n    if interp_method.lower() == 'linear':\n        def _linear(image):\n            \"\"\"Linearly interpolate source images to target image time_start(s)\n\n            Parameters\n            ----------\n            image : ee.Image.\n                The first band in the image will be used as the \"target\" image\n                and will be returned with the output image.\n\n            Returns\n            -------\n            ee.Image of interpolated values with band name 'src'\n\n            Notes\n            -----\n            The source collection images must have a time band.\n            This function is intended to be mapped over an image collection and\n                can only take one input parameter.\n\n            \"\"\"\n            target_image = ee.Image(image).select(0).double()\n            target_date = ee.Date(image.get('system:time_start'))\n\n            # All filtering will be done based on 0 UTC dates\n            utc0_date = utils.date_0utc(target_date)\n            # utc0_time = target_date.update(hour=0, minute=0, second=0)\\\n            #     .millis().divide(1000).floor().multiply(1000)\n            time_image = ee.Image.constant(utc0_date.millis()).double()\n\n            # Build nodata images/masks that can be placed at the front/back of\n            #   of the qm image collections in case the collections are empty.\n            bands = source_coll.first().bandNames()\n            prev_qm_mask = ee.Image.constant(ee.List.repeat(1, bands.length()))\\\n                .double().rename(bands).updateMask(0)\\\n                .set({\n                    'system:time_start': utc0_date.advance(\n                        -interp_days - 1, 'day').millis()})\n            next_qm_mask = ee.Image.constant(ee.List.repeat(1, bands.length()))\\\n                .double().rename(bands).updateMask(0)\\\n                .set({\n                    'system:time_start': utc0_date.advance(\n                        interp_days + 2, 'day').millis()})\n\n            # Build separate collections for before and after the target date\n            prev_qm_coll = source_coll.filterDate(\n                    utc0_date.advance(-interp_days, 'day'), utc0_date)\\\n                .merge(ee.ImageCollection(prev_qm_mask))\n            next_qm_coll = source_coll.filterDate(\n                    utc0_date, utc0_date.advance(interp_days + 1, 'day'))\\\n                .merge(ee.ImageCollection(next_qm_mask))\n\n            # Flatten the previous/next collections to single images\n            # The closest image in time should be on \"top\"\n            # CGM - Is the previous collection already sorted?\n            # prev_qm_image = prev_qm_coll.mosaic()\n            prev_qm_image = prev_qm_coll.sort('system:time_start', True).mosaic()\n            next_qm_image = next_qm_coll.sort('system:time_start', False).mosaic()\n\n            # DEADBEEF - It might be easier to interpolate all bands instead of\n            #   separating the value and time bands\n            # prev_value_image = ee.Image(prev_qm_image).double()\n            # next_value_image = ee.Image(next_qm_image).double()\n\n            # Interpolate all bands except the \"time\" band\n            prev_bands = prev_qm_image.bandNames()\\\n                .filter(ee.Filter.notEquals('item', 'time'))\n            next_bands = next_qm_image.bandNames() \\\n                .filter(ee.Filter.notEquals('item', 'time'))\n            prev_value_image = ee.Image(prev_qm_image.select(prev_bands)).double()\n            next_value_image = ee.Image(next_qm_image.select(next_bands)).double()\n            prev_time_image = ee.Image(prev_qm_image.select('time')).double()\n            next_time_image = ee.Image(next_qm_image.select('time')).double()\n\n            # Fill masked values with values from the opposite image\n            # Something like this is needed to ensure there are always two\n            #   values to interpolate between\n            # For data gaps, this will cause a flat line instead of a ramp\n            prev_time_mosaic = ee.Image(ee.ImageCollection.fromImages([\n                next_time_image, prev_time_image]).mosaic())\n            next_time_mosaic = ee.Image(ee.ImageCollection.fromImages([\n                prev_time_image, next_time_image]).mosaic())\n            prev_value_mosaic = ee.Image(ee.ImageCollection.fromImages([\n                next_value_image, prev_value_image]).mosaic())\n            next_value_mosaic = ee.Image(ee.ImageCollection.fromImages([\n                prev_value_image, next_value_image]).mosaic())\n\n            # Calculate time ratio of the current image between other cloud free images\n            time_ratio_image = time_image.subtract(prev_time_mosaic) \\\n                .divide(next_time_mosaic.subtract(prev_time_mosaic))\n\n            # Interpolate values to the current image time\n            interp_value_image = next_value_mosaic.subtract(prev_value_mosaic) \\\n                .multiply(time_ratio_image).add(prev_value_mosaic)\n\n            # CGM\n            # Should/can the target image be mapped to the interpolated image?\n            # Is there a clean way of computing ET here?\n            return interp_value_image \\\n                .addBands(target_image) \\\n                .set({\n                    'system:index': image.get('system:index'),\n                    'system:time_start': image.get('system:time_start'),\n                    # 'system:time_start': utc0_time,\n            })\n\n        interp_coll = ee.ImageCollection(target_coll.map(_linear))\n    # elif interp_method.lower() == 'nearest':\n    #     interp_coll = ee.ImageCollection(target_coll.map(_nearest))\n    else:\n        raise ValueError('invalid interpolation method: {}'.format(interp_method))\n\n    return interp_coll"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naggregating images by day without using joins", "response": "def aggregate_daily(image_coll, start_date=None, end_date=None,\n                    agg_type='mean'):\n    \"\"\"Aggregate images by day without using joins\n\n    The primary purpose of this function is to join separate Landsat images\n    from the same path into a single daily image.\n\n    Parameters\n    ----------\n    image_coll : ee.ImageCollection\n        Input image collection.\n    start_date :  date, number, string, optional\n        Start date.\n        Needs to be an EE readable date (i.e. ISO Date string or milliseconds).\n    end_date :  date, number, string, optional\n        Exclusive end date.\n        Needs to be an EE readable date (i.e. ISO Date string or milliseconds).\n    agg_type : {'mean'}, optional\n        Aggregation type (the default is 'mean').\n        Currently only a 'mean' aggregation type is supported.\n\n    Returns\n    -------\n    ee.ImageCollection()\n\n    Notes\n    -----\n    This function should be used to mosaic Landsat images from same path\n        but different rows.\n    system:time_start of returned images will be 0 UTC (not the image time).\n\n    \"\"\"\n    if start_date and end_date:\n        test_coll = image_coll.filterDate(ee.Date(start_date), ee.Date(end_date))\n    elif start_date:\n        test_coll = image_coll.filter(ee.Filter.greaterThanOrEquals(\n            'system:time_start', ee.Date(start_date).millis()))\n    elif end_date:\n        test_coll = image_coll.filter(ee.Filter.lessThan(\n            'system:time_start', ee.Date(end_date).millis()))\n    else:\n        test_coll = image_coll\n\n    # Build a list of dates in the image_coll\n    def get_date(time):\n        return ee.Date(ee.Number(time)).format('yyyy-MM-dd')\n\n    date_list = ee.List(test_coll.aggregate_array('system:time_start'))\\\n        .map(get_date).distinct().sort()\n\n    def aggregate_func(date_str):\n        start_date = ee.Date(ee.String(date_str))\n        end_date = start_date.advance(1, 'day')\n        agg_coll = image_coll.filterDate(start_date, end_date)\n\n        # if agg_type.lower() == 'mean':\n        agg_img = agg_coll.mean()\n        # elif agg_type.lower() == 'median':\n        #     agg_img = agg_coll.median()\n\n        return agg_img.set({\n            'system:index': start_date.format('yyyyMMdd'),\n            'system:time_start': start_date.millis(),\n            'date': start_date.format('yyyy-MM-dd'),\n        })\n\n    return ee.ImageCollection(date_list.map(aggregate_func))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naggregating images by day using joins.", "response": "def aggregate_daily_with_joins(image_coll, start_date, end_date,\n                               agg_type='mean'):\n    \"\"\"Aggregate images by day (using joins)\n\n    The primary purpose of this function is to join separate Landsat images\n    from the same path into a single daily image.\n\n    Parameters\n    ----------\n    image_coll : ee.ImageCollection\n        Input image collection.\n    start_date :  date, number, string\n        Start date.\n        Needs to be an EE readable date (i.e. ISO Date string or milliseconds).\n    end_date :  date, number, string\n        End date.\n        Needs to be an EE readable date (i.e. ISO Date string or milliseconds).\n    agg_type : {'mean'}, optional\n        Aggregation type (the default is 'mean').\n        Currently only a 'mean' aggregation type is supported.\n\n    Returns\n    -------\n    ee.ImageCollection()\n\n    Notes\n    -----\n    This function should be used to mosaic Landsat images from same path\n        but different rows.\n    system:time_start of returned images will be 0 UTC (not the image time).\n\n    \"\"\"\n    # Build a collection of time \"features\" to join to\n    # \"Flatten\" dates to 0 UTC time\n    if start_date and end_date:\n        date_list = ee.List.sequence(\n            ee.Date(start_date).millis(), ee.Date(end_date).millis(),\n            24 * 3600 * 1000)\n    # elif start_date:\n    #    end_date = ee.Date(ee.Image(image_coll.limit(\n    #        1, 'system:time_start', False).first()).get('system:time_start')\n    #    end_date = ee.Date(end_date.format('yyyy-MM-dd')).advance(1, 'day')\n    #    # end_date = ee.Date.fromYMD(end_date.get('year'), end_date.get('month'),\n    #    #                            end_date.get('day')).advance(1, 'day')\n    #    date_list = ee.List.sequence(\n    #        ee.Date(start_date).millis(), end_date.millis(), 24 * 3600 * 1000)\n    # elif end_date:\n    #    start_date = ee.Date(start_date.format('yyyy-MM-dd')).advance(1, 'day')\n    #    # start_date = ee.Date.fromYMD(\n    #    #     start_date.get('year'), start_date.get('month'),\n    #    #     start_date.get('day')).advance(1, 'day')\n    #    date_list = ee.List.sequence(\n    #        start_date.millis(), ee.Date(end_date).millis(), 24 * 3600 * 1000)\n    # else:\n    #    start_date = ee.Date(start_date.format('yyyy-MM-dd')).advance(1, 'day')\n    #    end_date = ee.Date(ee.Image(image_coll.limit(\n    #        1, 'system:time_start', False).first()).get('system:time_start')\n    #    end_date = ee.Date(end_date.format('yyyy-MM-dd')).advance(1, 'day')\n    #    date_list = ee.List.sequence(\n    #        ee.Date(start_date).millis(), ee.Date(end_date).millis(),\n    #        24 * 3600 * 1000)\n\n    def set_date(time):\n        return ee.Feature(None, {\n            'system:index': ee.Date(time).format('yyyyMMdd'),\n            'system:time_start': ee.Number(time).int64(),\n            'date': ee.Date(time).format('yyyy-MM-dd')})\n\n    # Add a date property to the image collection\n    def set_image_date(img):\n        return ee.Image(img.set({\n            'date': ee.Date(img.get('system:time_start')).format('yyyy-MM-dd')}))\n\n    join_coll = ee.FeatureCollection(\n        ee.Join.saveAll('join').apply(\n            ee.FeatureCollection(date_list.map(set_date)),\n            ee.ImageCollection(image_coll.map(set_image_date)),\n            ee.Filter.equals(leftField='date', rightField='date')))\n\n    def aggregate_func(ftr):\n        # The composite image time will be 0 UTC (not Landsat time)\n        agg_coll = ee.ImageCollection.fromImages(ftr.get('join'))\n\n        # if agg_type.lower() == 'mean':\n        agg_img = agg_coll.mean()\n        # elif agg_type.lower() == 'median':\n        #     agg_img = agg_coll.median()\n\n        return agg_img.set({\n            'system:index': ftr.get('system:index'),\n            'system:time_start': ftr.get('system:time_start'),\n            'date': ftr.get('date'),\n        })\n\n    return ee.ImageCollection(join_coll.map(aggregate_func))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_this_clink(self,clink_id):\n        for clink in self.get_clinks():\n            if clink.get_id() == clink_id:\n                self.node.remove(clink.get_node())\n                break", "response": "Removes the clink for the given clink identifier from the set of clinks in the set of active clinks."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets estimated costs for a group of servers.", "response": "def GetGroupEstimate(group,alias=None,location=None):\n        \"\"\"Gets estimated costs for a group of servers.\n\n        https://t3n.zendesk.com/entries/22423906-GetGroupEstimate\n\n        :param alias: short code for a particular account.  If none will use account's default alias\n        :param location: datacenter where group resides\n        :param group: group name\n        \"\"\"\n        if alias is None:  alias = clc.v1.Account.GetAlias()\n        if location is None:  location = clc.v1.Account.GetLocation()\n        group_uuid = clc.v1.Group.GetGroupUUID(group,alias,location)\n\n        r = clc.v1.API.Call('post','Billing/GetGroupEstimate',{'AccountAlias': alias, 'HardwareGroupUUID': group_uuid})\n        if int(r['StatusCode']) == 0:\n            return(r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the charges for groups and servers within a given account and for any date range.", "response": "def GetGroupSummaries(alias=None,date_start=None,date_end=None):\n        \"\"\"Gets the charges for groups and servers within a given account, and for any date range.\n\n        https://t3n.zendesk.com/entries/22423916-GetGroupSummaries\n\n        :param alias: short code for a particular account.  If none will use account's default alias\n        :param date_start: YYYY-MM-DD string for start date.  If None defaults to start of current month\n        :param date_end: YYYY-MM-DD string for end date.  If None defaults to current day of current month\n        \"\"\"\n        if alias is None:  alias = clc.v1.Account.GetAlias()\n        payload = {'AccountAlias': alias}\n        if date_start is not None:  payload['StartDate'] = date_start\n        if date_end is not None:  payload['EndDate'] = date_end\n\n        r = clc.v1.API.Call('post','Billing/GetGroupSummaries',payload)\n        if int(r['StatusCode']) == 0:\n                return(r['GroupTotals'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef GetServerEstimate(server,alias=None):\n        if alias is None:  alias = clc.v1.Account.GetAlias()\n        r = clc.v1.API.Call('post','Billing/GetServerEstimate',{'AccountAlias': alias, 'ServerName': server})\n        if int(r['StatusCode']) == 0:\n                return(r)", "response": "Gets the estimated monthly cost for a given server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndisplays the output of get_direct_config formatted nicely", "response": "def display_direct():\n    \"\"\"\n    Displays the output of 'get_direct_config', formatted nicely\n    \"\"\"\n\n    include_dirs, runtime_dirs, runtime = get_direct_config()\n    print(\"Include Search Dirs: {}\".format(include_dirs))\n    print(\"\\tContents: {}\\n\".format(get_dir_contents(include_dirs)))\n    print(\"Runtime Search Dirs: {}\".format(runtime_dirs))\n    print(\"\\tContents: {}\\n\".format(get_dir_contents(runtime_dirs)))\n    print(\"Runtime Libs: '{}'\".format(runtime))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getIncludeAndRuntime():\n    include_dirs, library_dirs = [], []\n\n    py_include = distutils.sysconfig.get_python_inc()\n    plat_py_include = distutils.sysconfig.get_python_inc(plat_specific=1)\n\n    include_dirs.append(py_include)\n    if plat_py_include != py_include:\n        include_dirs.append(plat_py_include)\n\n    if os.name == 'nt':\n        library_dirs.append(os.path.join(sys.exec_prefix, 'libs'))\n        include_dirs.append(os.path.join(sys.exec_prefix, 'PC'))\n\n        MSVC_VERSION = int(distutils.msvccompiler.get_build_version())\n        if MSVC_VERSION == 14:\n            library_dirs.append(os.path.join(sys.exec_prefix, 'PC', 'VS14',\n                                             'win32release'))\n        elif MSVC_VERSION == 9:\n            suffix = '' if PLATFORM == 'win32' else PLATFORM[4:]\n            new_lib = os.path.join(sys.exec_prefix, 'PCbuild')\n            if suffix:\n                new_lib = os.path.join(new_lib, suffix)\n            library_dirs.append(new_lib)\n        elif MSVC_VERSION == 8:\n            library_dirs.append(os.path.join(sys.exec_prefix, 'PC', 'VS8.0',\n                                             'win32release'))\n        elif MSVC_VERSION == 7:\n            library_dirs.append(os.path.join(sys.exec_prefix, 'PC', 'VS7.1'))\n        else:\n            library_dirs.append(os.path.join(sys.exec_prefix, 'PC', 'VC6'))\n\n    if os.name == 'os2':\n        library_dirs.append(os.path.join(sys.exec_prefix, 'Config'))\n\n    is_cygwin = sys.platform[:6] == 'cygwin'\n    is_atheos = sys.platform[:6] == 'atheos'\n    is_shared = distutils.sysconfig.get_config_var('Py_ENABLE_SHARED')\n    is_linux = sys.platform.startswith('linux')\n    is_gnu = sys.platform.startswith('gnu')\n    is_sunos = sys.platform.startswith('sunos')\n\n    if is_cygwin or is_atheos:\n        if sys.executable.startswith(os.path.join(sys.exec_prefix, \"bin\")):\n            library_dirs.append(os.path.join(sys.prefix, \"lib\", BASENAME,\n                                             \"config\"))\n        else:\n            library_dirs.append(os.getcwd())\n\n    if (is_linux or is_gnu or is_sunos) and is_shared:\n        if sys.executable.startswith(os.path.join(sys.exec_prefix, \"bin\")):\n            library_dirs.append(distutils.sysconfig.get_config_var('LIBDIR'))\n        else:\n            library_dirs.append(os.getcwd())\n\n    user_include = os.path.join(site.USER_BASE, \"include\")\n    user_lib = os.path.join(site.USER_BASE, \"lib\")\n    if os.path.isdir(user_include):\n        include_dirs.append(user_include)\n    if os.path.isdir(user_lib):\n        library_dirs.append(user_lib)\n\n    ret_object = (include_dirs, library_dirs)\n    _filter_non_existing_dirs(ret_object)\n\n    return ret_object", "response": "A function from distutils build_ext. py that was updated and changed to ACTUALLY WORK\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_priority_objects(data, nObj=1, seeds=None, seeds_multi_index=None, debug=False):\n\n    # Oznaceni dat.\n    # labels - oznacena data.\n    # length - pocet rozdilnych oznaceni.\n    if seeds is not None:\n        # logger.warning(\"'seeds' parameter is obsolete. Use 'seeds_multi_index' instead of it.\")\n        if numpy.array_equal(data.shape, numpy.asarray(seeds).shape):\n            seeds_multi_index = numpy.nonzero(seeds)\n        else:\n            if seeds_multi_index is None:\n                logger.debug(\"Seeds looks to be seeds_multi_index.\")\n                seeds_multi_index = seeds\n\n    dataLabels, length = scipy.ndimage.label(data)\n\n    logger.info('Olabelovano oblasti: ' + str(length))\n\n    logger.debug('data labels: ' + str(dataLabels))\n\n    # Uzivatel si nevybral specificke objekty.\n    if (seeds_multi_index is None):\n\n        logger.info('Vraceni bez seedu')\n        logger.debug('Objekty: ' + str(nObj))\n\n        # Zjisteni nejvetsich objektu.\n        arrayLabelsSum, arrayLabels = areaIndexes(dataLabels, length)\n        # Serazeni labelu podle velikosti oznacenych dat (prvku / ploch).\n        arrayLabelsSum, arrayLabels = selectSort(arrayLabelsSum, arrayLabels)\n\n        returning = None\n        label = 0\n        stop = nObj - 1\n\n        # Budeme postupne prochazet arrayLabels a postupne pridavat jednu\n        # oblast za druhou (od te nejvetsi - mimo nuloveho pozadi) dokud\n        # nebudeme mit dany pocet objektu (nObj).\n        while label <= stop:\n\n            if label >= len(arrayLabels):\n                break\n\n            if arrayLabels[label] != 0:\n                if returning is None:\n                    # \"Prvni\" iterace\n                    returning = data * (dataLabels == arrayLabels[label])\n                else:\n                    # Jakakoli dalsi iterace\n                    returning = returning + data * \\\n                        (dataLabels == arrayLabels[label])\n            else:\n                # Musime prodlouzit hledany interval, protoze jsme narazili na\n                # nulove pozadi.\n                stop = stop + 1\n\n            label = label + 1\n\n            if debug:\n                logger.debug(str(label - 1) + ': ' + str(returning))\n\n        if returning is None:\n            logger.info(\n                'Zadna validni olabelovana data! (DEBUG: returning == None)')\n\n        return returning\n\n    # Uzivatel si vybral specificke objekty (seeds != None).\n    else:\n\n        logger.info('Vraceni se seedy')\n\n        # Zalozeni pole pro ulozeni seedu\n        arrSeed = []\n        # Zjisteni poctu seedu.\n        stop = seeds_multi_index[0].size\n        tmpSeed = 0\n        dim = numpy.ndim(dataLabels)\n        for index in range(0, stop):\n            # Tady se ukladaji labely na mistech, ve kterych kliknul uzivatel.\n            if dim == 3:\n                # 3D data.\n                tmpSeed = dataLabels[\n                    seeds_multi_index[0][index], seeds_multi_index[1][index], seeds_multi_index[2][index]]\n            elif dim == 2:\n                # 2D data.\n                tmpSeed = dataLabels[seeds_multi_index[0][index], seeds_multi_index[1][index]]\n\n            # Tady opet pocitam s tim, ze oznaceni nulou pripada cerne oblasti\n            # (pozadi).\n            if tmpSeed != 0:\n                # Pokud se nejedna o pozadi (cernou oblast), tak se novy seed\n                # ulozi do pole \"arrSeed\"\n                arrSeed.append(tmpSeed)\n\n        # Pokud existuji vhodne labely, vytvori se nova data k vraceni.\n        # Pokud ne, vrati se \"None\" typ. { Deprecated: Pokud ne, vrati se cela\n        # nafiltrovana data, ktera do funkce prisla (nedojde k vraceni\n        # specifickych objektu). }\n        if len(arrSeed) > 0:\n\n            # Zbaveni se duplikatu.\n            arrSeed = list(set(arrSeed))\n            if debug:\n                logger.debug('seed list:' + str(arrSeed))\n\n            logger.info(\n                'Ruznych prioritnich objektu k vraceni: ' +\n                str(len(arrSeed))\n            )\n\n            # Vytvoreni vystupu - postupne pricitani dat prislunych specif.\n            # labelu.\n            returning = None\n            for index in range(0, len(arrSeed)):\n\n                if returning is None:\n                    returning = data * (dataLabels == arrSeed[index])\n                else:\n                    returning = returning + data * \\\n                        (dataLabels == arrSeed[index])\n\n                if debug:\n                    logger.debug((str(index)) + ':' + str(returning))\n\n            return returning\n\n        else:\n\n            logger.warning(\n                'Zadna validni data k vraceni - zadne prioritni objekty ' +\n                'nenalezeny (DEBUG: function getPriorityObjects:' +\n                str(len(arrSeed) == 0))\n            return None", "response": "Get N biggest objects from the selection or the object with seed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef selectSort(list1, list2):\n\n    length = len(list1)\n    for index in range(0, length):\n        min = index\n        for index2 in range(index + 1, length):\n            if list1[index2] > list1[min]:\n                min = index2\n        # Prohozeni hodnot hlavniho pole\n        list1[index], list1[min] = list1[min], list1[index]\n        # Prohozeni hodnot vedlejsiho pole\n        list2[index], list2[min] = list2[min], list2[index]\n\n    return list1, list2", "response": "select sort\n            Razeni 2 poli najednou list1 list2"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, filename='saved.ol.p'):\n        import dill as pickle\n        sv = {\n            # 'feature_function': self.feature_function,\n            'cl': self.cl\n\n        }\n        pickle.dump(sv, open(filename, \"wb\"))", "response": "Save the current state of the object to a pickle file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npredicts the segmentation with weight factor", "response": "def predict_w(self, data3d, voxelsize_mm, weight, label0=0, label1=1):\n        \"\"\"\n        segmentation with weight factor\n        :param data3d:\n        :param voxelsize_mm:\n        :param weight:\n        :return:\n        \"\"\"\n        scores = self.scores(data3d, voxelsize_mm)\n        out = scores[label1] > (weight * scores[label0])\n\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GetGroupUUID(group,alias=None,location=None):\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tr = Group.GetGroups(location,alias)\n\t\tfor row in r:\n\t\t\tif row['Name'] == group:  return(row['UUID'])\n\t\telse:\n\t\t\tif clc.args:  clc.v1.output.Status(\"ERROR\",3,\"Group %s not found in account %s datacenter %s\" % (group,alias,location))\n\t\t\traise Exception(\"Group not found\")", "response": "Given a group name return the unique group ID."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef NameGroups(data_arr,id_key):\n\t\tnew_data_arr = []\n\t\tfor data in data_arr:\n\t\t\ttry:\n\t\t\t\tdata_arr[id_key] = clc._GROUP_MAPPING[data[id_key]]\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\tnew_data_arr.append(data)\n\t\tif clc.args:  clc.v1.output.Status(\"ERROR\",2,\"Group name conversion not yet implemented\")\n\t\treturn(new_data_arr)", "response": "Get group name associated with ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all of alias groups in the given location.", "response": "def GetGroups(location=None,alias=None):\n\t\t\"\"\"Return all of alias' groups in the given location.\n\n\t\thttp://www.centurylinkcloud.com/api-docs/v2/#groups-get-group\n\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param location: datacenter where group resides\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tr = clc.v1.API.Call('post','Group/GetGroups',{'AccountAlias': alias, 'Location': location})\n\t\tfor group in r['HardwareGroups']:  clc._GROUP_MAPPING[group['UUID']] = group['Name']\n\t\tif int(r['StatusCode']) == 0:  return(r['HardwareGroups'])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Create(group,parent=None,description='',alias=None,location=None):\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tif description is None: description = ''\n\t\tif parent is None:  parent = \"%s Hardware\" % (location)\n\n\t\tparents_uuid = Group.GetGroupUUID(parent,alias,location)\n\n\t\tr = clc.v1.API.Call('post','Group/CreateHardwareGroup',\n\t\t                    {'AccountAlias': alias, 'ParentUUID': parents_uuid, 'Name': group, 'Description': description })\n\t\tif int(r['StatusCode']) == 0:  return(r['Group'])", "response": "Create a new group in the specified account."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _GroupActions(action,group,alias,location):\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tgroups_uuid = Group.GetGroupUUID(group,alias,location)\n\n\t\tr = clc.v1.API.Call('post','Group/%sHardwareGroup' % (action), {'UUID': groups_uuid, 'AccountAlias': alias })\n\t\treturn(r)", "response": "Applies group level actions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_endpoint_and_path(environ):\n    path = environ['PATH_INFO']\n    components = path.split('/')\n\n    if '..' in components:\n        raise HttpError('400 Bad Request', 'Path cannot contain \"..\".')\n\n    # Strip closing slash\n    if components and components[-1] == '':\n        components.pop()\n\n    # If path contained '//', get the segment after the last occurence\n    try:\n        first = _rindex(components, '') + 1\n    except ValueError:\n        first = 0\n\n    components = components[first:]\n\n    if len(components) == 0:\n        return '', ''\n    else:\n        return components[0], '/'.join(components[1:])", "response": "Extracts endpoint and path from the request URL."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main(server):\n\n    if 'REQUEST_METHOD' in os.environ:\n        start_cgi(server)\n\n    stdin_sock = socket.fromfd(0, socket.AF_UNIX, socket.SOCK_STREAM)\n    try:\n        stdin_sock.getpeername()\n    except socket.error as e:\n        if e.errno == errno.ENOTCONN:\n            start_fcgi(server)\n\n    start_standalone(server)", "response": "A convenience method for running WSGI - compatible HTTP\n       application as CGI FCGI or standalone."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef showSegmentation(\n        segmentation,\n        voxelsize_mm=np.ones([3, 1]),\n        degrad=4,\n        label=1,\n        smoothing=True\n        ):\n    \"\"\"\n    Funkce vrac\u00ed trojrozm\u011brn\u00e9 porobn\u00e9 jako data['segmentation']\n    v data['slab'] je pops\u00e1no, co kter\u00e1 hodnota znamen\u00e1\n    \"\"\"\n    labels = []\n\n    segmentation = segmentation[::degrad, ::degrad, ::degrad]\n\n    # import pdb; pdb.set_trace()\n    mesh_data = seg2fem.gen_mesh_from_voxels_mc(segmentation, voxelsize_mm*degrad)\n    if smoothing:\n        mesh_data.coors = seg2fem.smooth_mesh(mesh_data)\n    else:\n        mesh_data = seg2fem.gen_mesh_from_voxels_mc(segmentation, voxelsize_mm * 1.0e-2)\n        # mesh_data.coors +=\n    vtk_file = \"mesh_geom.vtk\"\n    mesh_data.write(vtk_file)\n    QApplication(sys.argv)\n    view = viewer.QVTKViewer(vtk_file)\n    view.exec_()\n\n    return labels", "response": "Show segmentation in a single file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pack(self):\n        block = bytearray(self.size)\n        self.pack_into(block)\n        return block", "response": "convenience function for packing the object into a byte array"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a member by name", "response": "def get_member(self, name):\n        \"\"\"return a member by *name*\"\"\"\n        for member in self.members:\n            if member.name == name:\n                return member\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npredicate indicating whether a block of memory includes a magic number", "response": "def encoded_class(block, offset=0):\n        \"\"\"\n        predicate indicating whether a block of memory includes a magic number\n        \"\"\"\n        if not block:\n            raise InvalidFileFormatNull\n\n        for key in __magicmap__:\n            if block.find(key, offset, offset + len(key)) > -1:\n                return __magicmap__[key]\n\n        raise InvalidFileFormat"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _copy_stream(src, dest, length=0):\n    if length == 0:\n        shutil.copyfileobj(src, dest)\n        return\n\n    bytes_left = length\n    while bytes_left > 0:\n        buf_size = min(_BUFFER_SIZE, bytes_left)\n        buf = src.read(buf_size)\n        dest.write(buf)\n        bytes_left -= buf_size", "response": "Similar to shutil. copyfileobj but supports limiting data size."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _read_stream_for_size(stream):\n    size = 0\n    while True:\n        buf = stream.read(_BUFFER_SIZE)\n        size += len(buf)\n        if not buf:\n            break\n    return size", "response": "Reads a stream discarding the data read and returns its size."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _path_exists(path):\n    return os.path.exists(path) or os.path.islink(path)", "response": "Checks if the path exists in the current virtual folder."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _exclusive_lock(path):\n    _create_file_dirs(path)\n    fd = os.open(path, os.O_WRONLY | os.O_CREAT, 0o600)\n\n    try:\n        retries_left = _LOCK_RETRIES\n        success = False\n\n        while retries_left > 0:\n            # try to acquire the lock in a loop\n            # because gevent doesn't treat flock as IO,\n            # so waiting here without yielding would get the worker killed\n            try:\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                success = True\n                break\n            except IOError as e:\n                if e.errno in [errno.EAGAIN, errno.EWOULDBLOCK]:\n                    # This yields execution to other green threads.\n                    gevent.sleep(_LOCK_SLEEP_TIME_S)\n                    retries_left -= 1\n                else:\n                    raise\n\n        if success:\n            yield\n        else:\n            raise ConcurrentModificationError(path)\n    finally:\n        if success:\n            fcntl.flock(fd, fcntl.LOCK_UN)\n        os.close(fd)", "response": "A simple wrapper for fcntl exclusive lock."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef store(self, name, data, version, size=0,\n              compressed=False, digest=None, logical_size=None):\n        \"\"\"Adds a new file to the storage.\n        \n        If the file with the same name existed before, it's not\n        guaranteed that the link for the old version will exist until\n        the operation completes, but it's guaranteed that the link\n        will never point to an invalid blob.\n\n        Args:\n            name: name of the file being stored.\n                May contain slashes that are treated as path separators.\n            data: binary file-like object with file contents. \n                Files with unknown length are supported for compatibility with\n                WSGI interface: ``size`` parameter should be passed in these\n                cases.\n            version: new file \"version\"\n                Link modification time will be set to this timestamp. If\n                the link exists, and its modification time is higher, the\n                file is not overwritten.\n            size: length of ``data`` in bytes\n                If not 0, this takes priority over internal ``data`` size.\n            compressed: whether ``data`` is gzip-compressed\n                If True, the compression is skipped, and file is written as-is.\n                Note that the current server implementation sends\n                'Content-Encoding' header anyway, mandating client to\n                decompress the file.\n            digest: SHA256 digest of the file before compression\n                If specified, the digest will not be computed again, saving\n                resources.\n            logical_size: if ``data`` is gzip-compressed, this parameter\n                has to be set to decompressed file size.\n        \"\"\"\n        with _exclusive_lock(self._lock_path('links', name)):\n            logger.debug('Acquired lock to link for %s.', name)\n            link_path = self._link_path(name)\n            if _path_exists(link_path) and _file_version(link_path) > version:\n                logger.info(\n                    'Tried to store older version of %s (%d < %d), ignoring.',\n                    name, version, _file_version(link_path))\n                return _file_version(link_path)\n\n            # data is managed by contents now, and shouldn't be used directly\n            with _InputStreamWrapper(data, size) as contents:\n                if digest is None or logical_size is None:\n                    contents.save()\n                    if compressed:\n                        # This shouldn't occur if the request came from a proper\n                        # filetracker client, so we don't care if it's slow.\n                        logger.warning(\n                            'Storing compressed stream without hints.')\n                        with gzip.open(\n                                contents.current_path, 'rb') as decompressed:\n                            digest = file_digest(decompressed)\n                        with gzip.open(\n                                contents.current_path, 'rb') as decompressed:\n                            logical_size = _read_stream_for_size(decompressed)\n                    else:\n                        digest = file_digest(contents.current_path)\n                        logical_size = os.stat(contents.current_path).st_size\n\n                blob_path = self._blob_path(digest)\n                \n                with _exclusive_lock(self._lock_path('blobs', digest)):\n                    logger.debug('Acquired lock for blob %s.', digest)\n                    digest_bytes = digest.encode()\n\n                    with self._db_transaction() as txn:\n                        logger.debug('Started DB transaction (adding link).')\n                        link_count = int(self.db.get(digest_bytes, 0, txn=txn))\n                        new_count = str(link_count + 1).encode()\n                        self.db.put(digest_bytes, new_count, txn=txn)\n\n                        if link_count == 0:\n                            self.db.put(\n                                    '{}:logical_size'.format(digest).encode(),\n                                    str(logical_size).encode(),\n                                    txn=txn)\n                        logger.debug('Commiting DB transaction (adding link).')\n\n                    logger.debug('Committed DB transaction (adding link).')\n\n                    # Create a new blob if this isn't a duplicate.\n                    if link_count == 0:\n                        logger.debug('Creating new blob.')\n                        _create_file_dirs(blob_path)\n\n                        if compressed:\n                            contents.save(blob_path)\n                        else:\n                            contents.save()\n                            with open(contents.current_path, 'rb') as raw,\\\n                                    gzip.open(blob_path, 'wb') as blob:\n                                shutil.copyfileobj(raw, blob)\n\n                logger.debug('Released lock for blob %s.', digest)\n\n            if _path_exists(link_path):\n                # Lend the link lock to delete().\n                # Note that DB lock has to be released in advance, otherwise\n                # deadlock is possible in concurrent scenarios.\n                logger.info('Overwriting existing link %s.', name)\n                self.delete(name, version, _lock=False)\n\n            _create_file_dirs(link_path)\n            rel_blob_path = os.path.relpath(blob_path,\n                                            os.path.dirname(link_path))\n            os.symlink(rel_blob_path, link_path)\n\n            logger.debug('Created link %s.', name)\n\n            lutime(link_path, version)\n            return version\n\n        logger.debug('Released lock for link %s.', name)", "response": "Stores a new file in the storage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove a file from the storage.", "response": "def delete(self, name, version, _lock=True):\n        \"\"\"Removes a file from the storage.\n\n        Args:\n             name: name of the file being deleted.\n                 May contain slashes that are treated as path separators.\n             version: file \"version\" that is meant to be deleted\n                 If the file that is stored has newer version than provided,\n                 it will not be deleted.\n             lock: whether or not to acquire locks\n                 This is for internal use only,\n                 normal users should always leave it set to True.\n        Returns whether or not the file has been deleted.\n        \"\"\"\n        link_path = self._link_path(name)\n        if _lock:\n            file_lock = _exclusive_lock(self._lock_path('links', name))\n        else:\n            file_lock = _no_lock()\n        with file_lock:\n            logger.debug('Acquired or inherited lock for link %s.', name)\n            if not _path_exists(link_path):\n                raise FiletrackerFileNotFoundError\n            if _file_version(link_path) > version:\n                logger.info(\n                    'Tried to delete newer version of %s (%d < %d), ignoring.',\n                    name, version, _file_version(link_path))\n                return False\n\n            digest = self._digest_for_link(name)\n\n            with _exclusive_lock(self._lock_path('blobs', digest)):\n                logger.debug('Acquired lock for blob %s.', digest)\n                should_delete_blob = False\n\n                with self._db_transaction() as txn:\n                    logger.debug('Started DB transaction (deleting link).')\n                    digest_bytes = digest.encode()\n                    link_count = self.db.get(digest_bytes, txn=txn)\n                    if link_count is None:\n                        raise RuntimeError(\"File exists but has no key in db\")\n\n                    link_count = int(link_count)\n                    if link_count == 1:\n                        logger.debug('Deleting last link to blob %s.', digest)\n                        self.db.delete(digest_bytes, txn=txn)\n                        self.db.delete(\n                                '{}:logical_size'.format(digest).encode(),\n                                txn=txn)\n                        should_delete_blob = True\n                    else:\n                        new_count = str(link_count - 1).encode()\n                        self.db.put(digest_bytes, new_count, txn=txn)\n                    logger.debug('Committing DB transaction (deleting link).')\n\n                logger.debug('Committed DB transaction (deleting link).')\n\n                os.unlink(link_path)\n                logger.debug('Deleted link %s.', name)\n                if should_delete_blob:\n                    os.unlink(self._blob_path(digest))\n\n            logger.debug('Released lock for blob %s.', digest)\n\n        logger.debug('Released (or gave back) lock for link %s.', name)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the version of the file with the given name.", "response": "def stored_version(self, name):\n        \"\"\"Returns the version of file `name` or None if it doesn't exist.\"\"\"\n        link_path = self._link_path(name)\n        if not _path_exists(link_path):\n            return None\n        return _file_version(link_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef logical_size(self, name):\n        digest = self._digest_for_link(name)\n        logical_size = self.db.get('{}:logical_size'.format(digest).encode())\n\n        if logical_size:\n            return int(logical_size.decode())\n        else:\n            raise RuntimeError(\n                    'Blob doesn\\'t have :logical_size in DB: try recovering')", "response": "Returns the logical size of the file name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self, new_path=None):\n        self.saved_in_temp = new_path is None\n        if new_path is None:\n            fd, new_path = tempfile.mkstemp()\n            os.close(fd)\n\n        if self.current_path:\n            shutil.move(self.current_path, new_path)\n        else:\n            with open(new_path, 'wb') as dest:\n                _copy_stream(self._data, dest, self._size)\n        self.current_path = new_path", "response": "Moves or creates the file with stream contents to a new location."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_kaf(self):\n\n        if self.type == 'NAF':\n            self.root.tag = 'KAF'\n            self.type = 'KAF'\n\n        ## Convert the header\n        if self.header is not None:\n            self.header.to_kaf()\n\n        ## Convert the token layer\n        if self.text_layer is not None:\n            self.text_layer.to_kaf()\n\n        ## Convert the term layer\n        if self.term_layer is not None:\n            self.term_layer.to_kaf()\n\n\n        ## Convert the chunk layer\n        if self.chunk_layer is not None:\n            self.chunk_layer.to_kaf()\n\n        ## Convert the entity layer\n        if self.entity_layer is not None:\n            self.entity_layer.to_kaf()\n\n        ## Convert the features layer\n        ## There is no feature layer defined in NAF, but we assumed\n        ## that is defined will be followin the same rules\n        if self.features_layer is not None:\n            self.features_layer.to_kaf()\n\n\n        ##Convert the opinion layer\n        if self.opinion_layer is not None:\n            self.opinion_layer.to_kaf()\n\n        ## Convert the constituency layer\n        ## This layer is exactly the same in KAF/NAF\n        if self.constituency_layer is not None:\n            self.constituency_layer.to_kaf()    #Does nothing...\n\n\n        ## Convert the dedepency layer\n        ## It is not defined on KAF so we assme both will be similar\n        if self.dependency_layer is not None:\n            self.dependency_layer.to_kaf()\n\n        if self.coreference_layer is not None:\n            self.coreference_layer.to_kaf()\n\n\n        ## Convert the temporalRelations layer\n        ## It is not defined on KAF so we assme both will be similar\n        if self.temporalRelations_layer is not None:\n            self.temporalRelations_layer.to_kaf()\n\n        ## Convert the causalRelations layer\n        ## It is not defined on KAF so we assme both will be similar\n        if self.causalRelations_layer is not None:\n            self.causalRelations_layer.to_kaf()\n\n        ## Convert the factualitylayer\n        ## It is not defined on KAF so we assme both will be similar\n        if self.factuality_layer is not None:\n            self.factuality_layer.to_kaf()\n\n\n        ## Convert the attribution_layer\n        ## It is not defined on KAF so we assme both will be similar\n        if self.attribution_layer is not None:\n            self.attribution_layer.to_kaf()", "response": "Converts a NAF object to KAF."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a KAF object to NAF.", "response": "def to_naf(self):\n        \"\"\"\n        Converts a KAF object to NAF (in memory). You will have to use the method dump later to save it as a new NAF file\n        \"\"\"\n        if self.type == 'KAF':\n            self.root.tag = self.type = 'NAF'\n\n        ## Convert the header\n        if self.header is not None:\n            self.header.to_naf()\n\n        ## Convert the token layer\n        if self.text_layer is not None:\n            self.text_layer.to_naf()\n\n\n        ## Convert the term layer\n        if self.term_layer is not None:\n            self.term_layer.to_naf()\n\n        ## Convert the chunk layer\n        if self.chunk_layer is not None:\n            self.chunk_layer.to_naf()\n\n        ## Convert the entity layer\n        if self.entity_layer is not None:\n            self.entity_layer.to_naf()\n\n        ## Convert the features layer\n        ## There is no feature layer defined in NAF, but we assumed\n        ## that is defined will be followin the same rules\n        if self.features_layer is not None:\n            self.features_layer.to_naf()\n\n\n        ##Convert the opinion layer\n        if self.opinion_layer is not None:\n            self.opinion_layer.to_naf()\n\n\n        ## Convert the constituency layer\n        ## This layer is exactly the same in KAF/NAF\n        if self.constituency_layer is not None:\n            self.constituency_layer.to_naf()    #Does nothing...\n\n\n        ## Convert the dedepency layer\n        ## It is not defined on KAF so we assume both will be similar\n        if self.dependency_layer is not None:\n            self.dependency_layer.to_naf()      #Does nothing...\n\n        if self.coreference_layer is not None:\n            self.coreference_layer.to_naf()\n\n        ## Convert the temporalRelations layer\n        ## It is not defined on KAF so we assume both will be similar\n        if self.temporalRelations_layer is not None:\n            self.temporalRelations_layer.to_naf()    #Does nothing...\n\n        ## Convert the causalRelations layer\n        ## It is not defined on KAF so we assume both will be similar\n        if self.causalRelations_layer is not None:\n            self.causalRelations_layer.to_naf()    #Does nothing...\n\n        ## Convert the factuality layer\n        ## It is not defined on KAF so we assume both will be similar\n        if self.factuality_layer is not None:\n            self.factuality_layer.to_naf()        #Does nothing...\n\n\n        ## Convert the markable layer\n        ## It is not defined on KAF so we assume both will be similar\n        if self.markable_layer is not None:\n            self.markable_layer.to_naf()        #Changes identifier attribute nothing else...\n\n\n        ## Convert the attribution_layer\n        ## It is not defined on KAF so we assme both will be similar\n        if self.attribution_layer is not None:\n            self.attribution_layer.to_naf()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_lps(self):\n        if self.header is not None:\n            for linguisticProcessor in self.header:\n                for lp in linguisticProcessor:\n                    yield lp", "response": "Iterator that returns all the lp objects from the header"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_properties(self):\n        if self.features_layer is not None:\n            for property in self.features_layer.get_properties():\n                yield propertyfound_entities.get(mention.string)", "response": "Returns all the properties of the features layer"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the text of the raw element or creates the layer if it does not exist.", "response": "def set_raw(self,text):\n        \"\"\"\n        Sets the text of the raw element (or creates the layer if does not exist)\n        @param text: text of the raw layer\n        @type text: string\n        \"\"\"\n        node_raw = self.root.find('raw')\n        if node_raw is None:\n            node_raw = etree.Element('raw')\n            self.root.insert(0,node_raw)\n        node_raw.text = etree.CDATA(text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndump the object to a file.", "response": "def dump(self,filename=None):\n        \"\"\"\n        Dumps the object to an output filename (or open file descriptor). The filename\n        parameter is optional, and if it is not provided, the standard output will be used\n        @type filename: string or file descriptor\n        @param filename: file where to dump the object (default standard output)\n        \"\"\"\n\n        if filename is None:\n            with io.BytesIO() as buffer:\n                self.dump(filename=buffer)\n                bytes = buffer.getvalue()\n                getattr(sys.stdout, 'buffer', sys.stdout).write(bytes)\n        else:\n            self.tree.write(filename,encoding='UTF-8',pretty_print=True,xml_declaration=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_entity_layer(self):\n        if self.entity_layer is not None:\n            this_node = self.entity_layer.get_node()\n            self.root.remove(this_node)\n            self.entity_layer = None\n        if self.header is not None:\n            self.header.remove_lp('entities')", "response": "Removes the entity layer of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_dependency_layer(self):\n        if self.dependency_layer is not None:\n            this_node = self.dependency_layer.get_node()\n            self.root.remove(this_node)\n            self.dependency_layer = self.my_dependency_extractor = None\n\n        if self.header is not None:\n            self.header.remove_lp('deps')", "response": "Removes the dependency layer of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove the temporalRelations layer from the object.", "response": "def remove_temporalRelations_layer(self):\n        \"\"\"\n        Removes the temporalRelations layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.temporalRelations_layer is not None:\n            this_node = self.temporalRelations_layer.get_node()\n            self.root.remove(this_node)\n            self.temporalRelations_layer = None\n\n        if self.header is not None:\n            self.header.remove_lp('temporalRelations')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the causalRelations layer from the object.", "response": "def remove_causalRelations_layer(self):\n        \"\"\"\n        Removes the causalRelations layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.causalRelations_layer is not None:\n            this_node = self.causalRelations_layer.get_node()\n            self.root.remove(this_node)\n            self.causalRelations_layer = None\n\n        if self.header is not None:\n            self.header.remove_lp('causalRelations')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_factualitylayer_layer(self):\n        if self.factuality_layer is not None:\n            this_node = self.factuality_layer.get_node()\n            self.root.remove(this_node)\n            self.factuality_layer = None\n\n        if self.header is not None:\n            self.header.remove_lp('factualitylayer')", "response": "Removes the factualitylayer layer from the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves the factualities layer from the object.", "response": "def remove_factualities_layer(self, lp_remove=True):\n        \"\"\"\n        Removes the factualities layer (the new version) (if exists) of the object (in memory)\n        \"\"\"\n        if self.factuality_layer is not None:\n            this_node = self.factuality_layer.get_node()\n            self.root.remove(this_node)\n            self.factuality_layer = None\n\n        if self.header is not None and lp_remove:\n            self.header.remove_lp('factualities')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove the constituency layer from the object.", "response": "def remove_constituency_layer(self):\n        \"\"\"\n        Removes the constituency layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.constituency_layer is not None:\n            this_node = self.constituency_layer.get_node()\n            self.root.remove(this_node)\n        if self.header is not None:\n            self.header.remove_lp('constituents')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the opinion layer from the object.", "response": "def remove_opinion_layer(self):\n        \"\"\"\n        Removes the opinion layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.opinion_layer is not None:\n            this_node = self.opinion_layer.get_node()\n            self.root.remove(this_node)\n            self.opinion_layer = None\n\n        if self.header is not None:\n            self.header.remove_lp('opinions')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the properties of the object.", "response": "def remove_properties(self):\n        \"\"\"\n        Removes the property layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.features_layer is not None:\n            self.features_layer.remove_properties()\n\n        if self.header is not None:\n            self.header.remove_lp('features')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the term layer of the object from the term layer list.", "response": "def remove_term_layer(self):\n        \"\"\"\n        Removes the term layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.term_layer is not None:\n            this_node = self.term_layer.get_node()\n            self.root.remove(this_node)\n            self.term_layer = None\n\n        if self.header is not None:\n            self.header.remove_lp('terms')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the chunk layer of the object.", "response": "def remove_chunk_layer(self):\n        \"\"\"\n        Removes the chunk layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.chunk_layer is not None:\n            this_node = self.chunk_layer.get_node()\n            self.root.remove(this_node)\n            self.chunk_layer = None\n\n        if self.header is not None:\n            self.header.remove_lp('chunks')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the attribution layer from the object.", "response": "def remove_attribution_layer(self):\n        \"\"\"\n        Removes the attribution layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.attribution_layer is not None:\n            this_node = self.attribution_layer.get_node()\n            self.root.remove(this_node)\n            self.attribution_layer = None\n\n        if self.header is not None:\n            self.header.remove_lp('attribution')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the text layer of the object.", "response": "def remove_text_layer(self):\n        \"\"\"\n        Removes the text layer (if exists) of the object (in memory)\n        \"\"\"\n        if self.text_layer is not None:\n            this_node = self.text_layer.get_node()\n            self.root.remove(this_node)\n            self.text_layer = None\n\n        if self.header is not None:\n            self.header.remove_lp('text')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_coreference_layer(self):\n        if self.coreference_layer is not None:\n            this_node = self.coreference_layer.get_node()\n            self.root.remove(this_node)\n        if self.header is not None:\n            self.header.remove_lp('coreferences')", "response": "Removes the constituency layer of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_markable_layer(self):\n        if self.markable_layer is not None:\n            this_node = self.markable_layer.get_node()\n            self.root.remove(this_node)\n        if self.header is not None:\n            self.header.remove_lp('markables')", "response": "Removes the markable layer from the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_factualitylayer_to_factualities(self):\n        if self.factuality_layer is not None:\n            this_node = self.factuality_layer.get_node()\n            if this_node.tag == 'factualitylayer':\n                new_node = Cfactualities()\n                #create dictionary from token ids to the term ids\n                token2term = {}\n                for t in self.get_terms():\n                    s = t.get_span()\n                    for w in s.get_span_ids():\n                        token2term[w] = t.get_id()\n                fnr = 0\n                for fv in self.get_factvalues():\n                    fnr += 1\n                    conf = fv.get_confidence()\n                    wid = fv.get_id()\n                    tid = token2term.get(wid)\n                    fnode = Cfactuality()\n                    #set span with tid as element\n                    fspan = Cspan()\n                    fspan.add_target_id(tid)\n                    fnode.set_span(fspan)\n                    #add factVal element with val, resource = factbank, + confidence if present\n                    fVal = Cfactval()\n                    fVal.set_resource('factbank')\n                    fVal.set_value(fv.get_prediction())\n                    if conf:\n                        fVal.set_confidence(conf)\n                    fnode.set_id('f' + str(fnr))\n                    fnode.add_factval(fVal)\n                    new_node.add_factuality(fnode)\n                self.root.remove(this_node)\n                self.root.append(new_node.get_node())\n                self.factuality_layer = new_node", "response": "Converts information from factuality layer in old representation to factuality representation"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a constituency extractor object for the given locale.", "response": "def get_constituency_extractor(self):\n        \"\"\"\n        Returns a constituency extractor object\n        @rtype: L{Cconstituency_extractor}\n        @return: a constituency extractor object\n        \"\"\"\n\n        if self.constituency_layer is not None:    ##Otherwise there are no constituens\n            if self.my_constituency_extractor is None:\n                self.my_constituency_extractor = Cconstituency_extractor(self)\n            return self.my_constituency_extractor\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dependency extractor object for the current object.", "response": "def get_dependency_extractor(self):\n        \"\"\"\n        Returns a dependency extractor object\n        @rtype: L{Cdependency_extractor}\n        @return: a dependency extractor object\n        \"\"\"\n        if self.dependency_layer is not None:    #otherwise there are no dependencies\n            if self.my_dependency_extractor is None:\n                self.my_dependency_extractor = Cdependency_extractor(self)\n            return self.my_dependency_extractor\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a token to the text layer.", "response": "def add_wf(self,wf_obj):\n        \"\"\"\n        Adds a token to the text layer\n        @type wf_obj: L{Cwf}\n        @param wf_obj: the token object\n        \"\"\"\n        if self.text_layer is None:\n            self.text_layer = Ctext(type=self.type)\n            self.root.append(self.text_layer.get_node())\n        self.text_layer.add_wf(wf_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_wf(self, text, sent, offset, id=None, length=None):\n        if id is None:\n            n = 1 if self.text_layer is None else len(self.text_layer.idx) + 1\n            id = \"w{n}\".format(**locals())\n        if length is None:\n            length = len(text)\n        new_token = Cwf(type=self.type)\n        new_token.set_id(id)\n        new_token.set_length(str(length))\n        new_token.set_offset(str(offset))\n        new_token.set_sent(str(sent))\n        new_token.set_text(text)\n        self.add_wf(new_token)\n        return new_token", "response": "Create a new wordform for this token and add it to the text layer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a term to the term layer", "response": "def add_term(self,term_obj):\n        \"\"\"\n        Adds a term to the term layer\n        @type term_obj: L{Cterm}\n        @param term_obj: the term object\n        \"\"\"\n        if self.term_layer is None:\n            self.term_layer = Cterms(type=self.type)\n            self.root.append(self.term_layer.get_node())\n        self.term_layer.add_term(term_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a chunk to the chunk layer", "response": "def add_chunk(self,chunk_obj):\n        \"\"\"\n        Adds a chunk to the chunk layer\n        @type chunk_obj: L{Cchunk}\n        @param chunk_obj: the chunk object\n        \"\"\"\n        if self.chunk_layer is None:\n            self.chunk_layer = Cchunks(type=self.type)\n            self.root.append(self.chunk_layer.get_node())\n        self.chunk_layer.add_chunk(chunk_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new term and add it to the term layer", "response": "def create_term(self, lemma, pos, morphofeat, tokens, id=None):\n        \"\"\"\n        Create a new term and add it to the term layer\n        @type lemma: string\n        @param lemma: The lemma of the term\n        @type pos: string\n        @param pos: The postrag(rst letter) of the POS attribute\n        @type morphofeat: string\n        @param morphofeat: The morphofeat (full morphological features) of the term\n        @type tokens: sequence of L{Cwf}\n        @param tokens: the token(s) that this term describes\n        @type id: string\n        @param id: the id of the term, if not given an id tXXX will be created\n        \"\"\"\n        if id is None:\n            n = 1 if self.term_layer is None else len(self.term_layer.idx) + 1\n            id = \"t{n}\".format(**locals())\n        new_term = Cterm(type=self.type)\n        new_term.set_id(id)\n        new_term.set_lemma(lemma)\n        new_term.set_pos(pos)\n        new_term.set_morphofeat(morphofeat)\n        new_span = Cspan()\n        for token in tokens:\n            new_span.add_target_id(token.get_id())\n        new_term.set_span(new_span)\n        self.add_term(new_term)\n        return new_term"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_markable(self,markable_obj):\n        if self.markable_layer is None:\n            self.markable_layer = Cmarkables(type=self.type)\n            self.root.append(self.markable_layer.get_node())\n        self.markable_layer.add_markable(markable_obj)", "response": "Adds a markable to the markable layer"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_opinion(self,opinion_obj):\n        if self.opinion_layer is None:\n            self.opinion_layer = Copinions()\n            self.root.append(self.opinion_layer.get_node())\n        self.opinion_layer.add_opinion(opinion_obj)", "response": "Adds an opinion to the opinion layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a statement to the attribution layer.", "response": "def add_statement(self,statement_obj):\n        \"\"\"\n        Adds a statement to the attribution layer\n        @type statement_obj: L{Cstatement}\n        @param statement_obj: the statement object\n        \"\"\"\n        if self.attribution_layer is None:\n            self.attribution_layer = Cattribution()\n            self.root.append(self.attribution_layer.get_node())\n        self.attribution_layer.add_statement(statement_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_predicate(self, predicate_obj):\n        if self.srl_layer is None:\n            self.srl_layer = Csrl()\n            self.root.append(self.srl_layer.get_node())\n        self.srl_layer.add_predicate(predicate_obj)", "response": "Adds a predicate to the semantic layer\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_timex(self, time_obj):\n        if self.timex_layer is None:\n            self.timex_layer = CtimeExpressions()\n            self.root.append(self.timex_layer.get_node())\n        self.timex_layer.add_timex(time_obj)", "response": "Adds a timex entry to the time layer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_header(self,header):\n        self.header = header\n        self.root.insert(0,header.get_node())", "response": "Sets the header of the object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a linguistic processor to the header.", "response": "def add_linguistic_processor(self, layer, my_lp):\n        \"\"\"\n        Adds a linguistic processor to the header\n        @type my_lp: L{Clp}\n        @param my_lp: linguistic processor object\n        @type layer: string\n        @param layer: the layer to which the processor is related to\n        \"\"\"\n        if self.header is None:\n            self.header = CHeader(type=self.type)\n            self.root.insert(0,self.header.get_node())\n        self.header.add_linguistic_processor(layer,my_lp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_linguistic_processor(self, layer, name, version, **kwargs):\n        lp = Clp(name=name, version=version, **kwargs)\n        self.add_linguistic_processor(layer, lp)\n        return lp", "response": "Create a new linguistic processor element and add it to the header\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_dependency(self,my_dep):\n        if self.dependency_layer is None:\n            self.dependency_layer = Cdependencies()\n            self.root.append(self.dependency_layer.get_node())\n        self.dependency_layer.add_dependency(my_dep)", "response": "Adds a dependency object to the dependency layer"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_dependency(self, _from, to, function, comment=None):\n        new_dependency = Cdependency()\n        new_dependency.set_from(_from)\n        new_dependency.set_to(to)\n        new_dependency.set_function(function)\n        if comment:\n            new_dependency.set_comment(comment)\n        self.add_dependency(new_dependency)\n        return new_dependency", "response": "Create a new dependency object and add it to the dependency layer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_tlink(self,my_tlink):\n        if self.temporalRelations_layer is None:\n            self.temporalRelations_layer = CtemporalRelations()\n            self.root.append(self.temporalRelations_layer.get_node())\n        self.temporalRelations_layer.add_tlink(my_tlink)", "response": "Adds a tlink to the temporalRelations layer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a predAnch to the temporalRelations layer.", "response": "def add_predicateAnchor(self,my_predAnch):\n        \"\"\"\n        Adds a predAnch to the temporalRelations layer\n        @type my_predAnch: L{CpredicateAnchor}\n        @param my_predAnch: predicateAnchor object\n        \"\"\"\n        if self.temporalRelations_layer is None:\n            self.temporalRelations_layer = CtemporalRelations()\n            self.root.append(self.temporalRelations_layer.get_node())\n        self.temporalRelations_layer.add_predicateAnchor(my_predAnch)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_clink(self,my_clink):\n        if self.causalRelations_layer is None:\n            self.causalRelations_layer = CcausalRelations()\n            self.root.append(self.causalRelations_layer.get_node())\n        self.causalRelations_layer.add_clink(my_clink)", "response": "Adds a clink to the causalRelations layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_factuality(self,my_fact):\n        if self.factuality_layer is None:\n            self.factuality_layer = Cfactualities()\n            self.root.append(self.factuality_layer.get_node())\n        self.factuality_layer.add_factuality(my_fact)", "response": "Adds a factuality to the factuality layer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_entity(self,entity):\n        if self.entity_layer is None:\n            self.entity_layer = Centities(type=self.type)\n            self.root.append(self.entity_layer.get_node())\n        self.entity_layer.add_entity(entity)", "response": "Adds an entity to the entity layer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new entity and add it to the entities layer", "response": "def create_entity(self, entity_type, term_ids, id=None):\n        \"\"\"\n        Create a new (named) entity and add it to the entities layer\n        @type entity_type: string\n        @param entity_type: The type of the entity\n        @type term_ids: list\n        @param term_ids: list of term ids\n        @type id: string\n        @param id: optional id of the entity\n        \"\"\"\n        new_entity = Centity(type=self.type)\n        if id is None:\n            n = 1 if self.entity_layer is None else len(self.entity_layer.map_entity_id_to_node) + 1\n            id = \"e{n}\".format(**locals())\n        new_entity.set_id(id)\n        new_entity.set_type(entity_type)\n        references = Creferences()\n        references.add_span(term_ids)\n        new_entity.add_reference(references)\n        self.add_entity(new_entity)\n        return new_entity"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an coreference to the coreference layer", "response": "def add_coreference(self, coreference):\n        \"\"\"\n        Adds an coreference to the coreference layer\n        @type coreference: L{Ccoreference}\n        @param coreference: the coreference object\n        \"\"\"\n        if self.coreference_layer is None:\n            self.coreference_layer = Ccoreferences(type=self.type)\n            self.root.append(self.coreference_layer.get_node())\n        self.coreference_layer.add_coreference(coreference)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new coreference object and add it to the coreferences layer", "response": "def create_coreference(self, coref_type, term_ids, id=None):\n        \"\"\"\n        Create a new coreference object and add it to the coreferences layer\n        @type coref_type: string\n        @param coref_type: type of the coreference object\n        @type term_ids: list\n        @param term_ids: list of term ids\n        @type id: string\n        @param id: optional id of the entity\n        \"\"\"\n        if id is None:\n            if self.coreference_layer is None:\n                i = 1\n            else:\n                corefs = (l for l in self.coreference_layer.get_corefs() if l.get_type == coref_type)\n                i = len(list(corefs)) + 1\n            id = \"co{coref_type}{i}\".format(**locals())\n\n        new_coref = Ccoreference(type=self.type)\n        new_coref.set_id(id)\n        new_coref.set_type(coref_type)\n        new_coref.add_span(term_ids)\n        self.add_coreference(new_coref)\n        return new_coref"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a constituency tree to the constituency layer", "response": "def add_constituency_tree(self,my_tree):\n        \"\"\"\n        Adds a constituency tree to the constituency layer\n        @type my_tree: L{Ctree}\n        @param my_tree: the constituency tree object\n        \"\"\"\n        if self.constituency_layer is None:\n            self.constituency_layer = Cconstituency()\n            self.root.append(self.constituency_layer.get_node())\n        self.constituency_layer.add_tree(my_tree)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a property to the property layer", "response": "def add_property(self,label,term_span,pid=None):\n        \"\"\"\n        Adds a property to the property layer\n        @type label: string\n        @param label: the type of property\n        @type term_span: list\n        @param term_span: list of term ids\n        @type pid: string\n        @param pid: the identifier for the property (use None to automatically generate one)\n        \"\"\"\n        if self.features_layer is None:\n            self.features_layer = Cfeatures(type=self.type)\n            self.root.append(self.features_layer.get_node())\n        self.features_layer.add_property(pid, label,term_span)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_dict_tokens_for_termid(self, term_id):\n        if self.dict_tokens_for_tid is None:\n            self.dict_tokens_for_tid = {}\n            for term in self.get_terms():\n                self.dict_tokens_for_tid[term.get_id()] = term.get_span().get_span_ids()\n\n        return self.dict_tokens_for_tid.get(term_id,[])", "response": "Returns the dict of tokens ids that are the span of the term specified\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmap a list of token ids to the corresponding term ids", "response": "def map_tokens_to_terms(self,list_tokens):\n        \"\"\"\n        Maps a list of token ids to the corresponding term ids\n        @type list_tokens: list\n        @param list_tokens: list of token identifiers\n        @rtype: list\n        @return: list of term idenfitiers\n        \"\"\"\n        if self.terms_for_token is None:\n            self.terms_for_token = {}\n            for term in self.get_terms():\n                termid = term.get_id()\n                token_ids = term.get_span().get_span_ids()\n                for tokid in token_ids:\n                    if tokid not in self.terms_for_token:\n                        self.terms_for_token[tokid] = [termid]\n                    else:\n                        self.terms_for_token[tokid].append(termid)\n\n        ret = set()\n        for my_id in list_tokens:\n            term_ids = self.terms_for_token.get(my_id,[])\n            ret |= set(term_ids)\n        return sorted(list(ret))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an external reference to the given term identifier", "response": "def add_external_reference_to_term(self,term_id, external_ref):\n        \"\"\"\n        Adds an external reference to the given term identifier\n        @type term_id: string\n        @param term_id: the term identifier\n        @param external_ref: an external reference object\n        @type external_ref: L{CexternalReference}\n        \"\"\"\n        if self.term_layer is not None:\n            self.term_layer.add_external_reference(term_id, external_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an external reference to the given role identifier in the SRL layer.", "response": "def add_external_reference_to_role(self,role_id,external_ref):\n        \"\"\"\n        Adds an external reference to the given role identifier in the SRL layer\n        @type role_id: string\n        @param role_id: the role identifier\n        @param external_ref: an external reference object\n        @type external_ref: L{CexternalReference}\n        \"\"\"\n        if self.srl_layer is not None:\n            self.srl_layer.add_external_reference_to_role(role_id,external_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving all external references present in the term layer", "response": "def remove_external_references_from_srl_layer(self):\n        \"\"\"\n        Removes all external references present in the term layer\n        \"\"\"\n        if self.srl_layer is not None:\n            for pred in self.srl_layer.get_predicates():\n                pred.remove_external_references()\n                pred.remove_external_references_from_roles()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an external reference to the given entity identifier in the entity layer.", "response": "def add_external_reference_to_entity(self,entity_id, external_ref):\n        \"\"\"\n        Adds an external reference to the given entity identifier in the entity layer\n        @type entity_id: string\n        @param entity_id: the entity identifier\n        @param external_ref: an external reference object\n        @type external_ref: L{CexternalReference}\n        \"\"\"\n        if self.entity_layer is not None:\n            self.entity_layer.add_external_reference_to_entity(entity_id,external_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read(self, size=-1):\n        chunksize = size < 0 and self.CHUNKSIZE or min(self.CHUNKSIZE, size)\n\n        buf = self._rbuf\n        buf.seek(0, os.SEEK_END)\n        collected = buf.tell()\n\n        while 1:\n            if size >= 0 and collected >= size:\n                # we have read enough already\n                break\n\n            output = self._read_chunk(chunksize)\n            if output is None:\n                continue\n\n            if not output:\n                # nothing more to read\n                break\n\n            collected += len(output)\n            buf.write(output)\n\n        # get rid of the old buffer\n        rc = buf.getvalue()\n        buf.seek(0)\n        buf.truncate()\n\n        if size >= 0:\n            # leave the overflow in the buffer\n            buf.write(rc[size:])\n            return rc[:size]\n        return rc", "response": "read a number of bytes from the file and return it as a string"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading from the file until a newline is encountered", "response": "def readline(self, max_len=-1):\n        \"\"\"read from the file until a newline is encountered\n\n        .. note::\n\n            this method will block if there isn't already a full line available\n            from the data source\n\n        :param max_len: stop reading a single line after this many bytes\n        :type max_len: int\n\n        :returns:\n            a string of the line it read from the file, including the newline\n            at the end\n        \"\"\"\n        buf = self._rbuf\n        newline, chunksize = self.NEWLINE, self.CHUNKSIZE\n        buf.seek(0)\n\n        text = buf.read()\n        if len(text) >= max_len >= 0:\n            buf.seek(0)\n            buf.truncate()\n            buf.write(text[max_len:])\n            return text[:max_len]\n\n        while text.find(newline) < 0:\n            text = self._read_chunk(chunksize)\n            if text is None:\n                text = ''\n                continue\n            if buf.tell() + len(text) >= max_len >= 0:\n                text = buf.getvalue() + text\n                buf.seek(0)\n                buf.truncate()\n                buf.write(text[max_len:])\n                return text[:max_len]\n            if not text:\n                break\n            buf.write(text)\n        else:\n            # found a newline\n            rc = buf.getvalue()\n            index = rc.find(newline) + len(newline)\n\n            buf.seek(0)\n            buf.truncate()\n            buf.write(rc[index:])\n            return rc[:index]\n\n        # hit the end of the file, no more newlines\n        rc = buf.getvalue()\n        buf.seek(0)\n        buf.truncate()\n        return rc"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, data):\n        while data:\n            went = self._write_chunk(data)\n            if went is None:\n                continue\n            data = data[went:]", "response": "write data into the file at the descriptor s current\n            position"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwaiting on our events", "response": "def _wait_event(self, reading):\n        \"wait on our events\"\n        with self._registered(reading, not reading):\n            (self._readable if reading else self._writable).wait()\n\n        if scheduler.state.interrupted:\n            raise IOError(errno.EINTR, \"interrupted system call\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a cooperating greenhouse file from an existing file descriptor", "response": "def fromfd(cls, fd, mode='rb', bufsize=-1):\n        \"\"\"create a cooperating greenhouse file from an existing descriptor\n\n        :param fd: the file descriptor to wrap in a new file object\n        :type fd: int\n        :param mode: the file mode\n        :type mode: str\n        :param bufsize:\n            the size of read buffer to use. 0 indicates unbuffered, and < 0\n            means use the system default. defaults to -1\n\n        :returns: a new :class:`File` object connected to the descriptor\n        \"\"\"\n        fp = object.__new__(cls)  # bypass __init__\n        fp._rbuf = StringIO()\n        fp.encoding = None\n        fp.mode = mode\n        fp._fileno = fd\n        fp._closed = False\n\n        cls._add_flags(fd, cls._mode_to_flags(mode))\n        fp._set_up_waiting()\n\n        return fp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning whether the file is connected to a tty or not", "response": "def isatty(self):\n        \"return whether the file is connected to a tty or not\"\n        try:\n            return os.isatty(self._fileno)\n        except OSError, e:\n            raise IOError(*e.args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef seek(self, position, modifier=0):\n        os.lseek(self._fileno, position, modifier)\n\n        # clear out the buffer\n        buf = self._rbuf\n        buf.seek(0)\n        buf.truncate()", "response": "move the cursor to a different location"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the file descriptor s position relative to the file s beginning", "response": "def tell(self):\n        \"get the file descriptor's position relative to the file's beginning\"\n        with _fdopen(os.dup(self._fileno)) as fp:\n            return fp.tell()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfits the classifier with labels y and observations X", "response": "def fit(self, labels, samples, pstates):\n        \"\"\"\n        Fit the classifier with labels y and observations X\n        \"\"\"\n        assert len(labels) == len(samples) == len(pstates)\n\n        for label in set(labels):\n            label_samples = [s for l,s in zip(labels, samples) if l == label]\n            label_pstates = [p for l,p in zip(labels, pstates) if l == label]\n\n            pohmm = self.pohmm_factory()\n            pohmm.fit(label_samples, label_pstates)\n            self.pohmms[label] = pohmm\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfits the classifier with labels y and DataFrames dfs and return the classifier.", "response": "def fit_df(self, labels, dfs, pstate_col=PSTATE_COL):\n        \"\"\"\n        Fit the classifier with labels y and DataFrames dfs\n        \"\"\"\n        assert len(labels) == len(dfs)\n\n        for label in set(labels):\n            label_dfs = [s for l,s in zip(labels, dfs) if l == label]\n\n            pohmm = self.pohmm_factory()\n            pohmm.fit_df(label_dfs, pstate_col=pstate_col)\n            self.pohmms[label] = pohmm\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npredicts the class label of X", "response": "def predict(self, sample, pstates):\n        \"\"\"\n        Predict the class label of X\n        \"\"\"\n        scores = {}\n        for label, pohmm in self.pohmms.items():\n            scores[label] = pohmm.score(sample, pstates)\n        max_score_label = max(scores.items(), key=itemgetter(1))[0]\n        return max_score_label, scores"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef predict_df(self, df, pstate_col=PSTATE_COL):\n        scores = {}\n        for label, pohmm in self.pohmms.items():\n            scores[label] = pohmm.score_df(df, pstate_col=pstate_col)\n        max_score_label = max(scores.items(), key=itemgetter(1))[0]\n        return max_score_label, scores", "response": "Predict the class label of DataFrame df"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndump configfile to stdout so users can edit their own", "response": "def dump_config(self):  # pragma: no cover\n        \"\"\"dumps configfile to stdout so users can edit/implement their own\"\"\"\n        with open(self.config_path, 'r') as cfg_fh:\n            base_config = cfg_fh.read()\n\n        print(base_config)\n        exit(2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_secrets(self, secret_path):\n        self._config = p_config.render_secrets(self.config_path, secret_path)", "response": "load secrets into config object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logger(self):\n        if self._logger:\n            return self._logger\n        else:\n            log_builder = p_logging.ProsperLogger(\n                self.PROGNAME,\n                self.config.get_option('LOGGING', 'log_path'),\n                config_obj=self.config\n            )\n\n            if self.verbose:\n                log_builder.configure_debug_logger()\n            else:\n                id_string = '({platform}--{version})'.format(\n                    platform=platform.node(),\n                    version=self.VERSION\n                )\n                if self.config.get_option('LOGGING', 'discord_webhook'):\n                    log_builder.configure_discord_logger(\n                        custom_args=id_string\n                    )\n                if self.config.get_option('LOGGING', 'slack_webhook'):\n                    log_builder.configure_slack_logger(\n                        custom_args=id_string\n                    )\n                if self.config.get_option('LOGGING', 'hipchat_webhook'):\n                    log_builder.configure_hipchat_logger(\n                        custom_args=id_string\n                    )\n\n            self._logger = log_builder.get_logger()\n            return self._logger", "response": "uses global logger for logging"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nuses global config for cfg", "response": "def config(self):\n        \"\"\"uses \"global config\" for cfg\"\"\"\n        if self._config:\n            return self._config\n        else:\n            self._config = p_config.ProsperConfig(self.config_path)\n            return self._config"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef notify_launch(self, log_level='ERROR'):\n        if not self.debug:\n            self.logger.log(\n                logging.getLevelName(log_level),\n                'LAUNCHING %s -- %s', self.PROGNAME, platform.node()\n            )\n        flask_options = {\n            key: getattr(self, key) for key in OPTION_ARGS\n        }\n        flask_options['host'] = self.get_host()\n\n        self.logger.info('OPTIONS: %s', flask_options)", "response": "logs launcher message before startup"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract cloud mask from the Landsat Collection 1 TOA band.", "response": "def landsat_c1_toa_cloud_mask(input_img, snow_flag=False, cirrus_flag=False,\n                              cloud_confidence=2, shadow_confidence=3,\n                              snow_confidence=3, cirrus_confidence=3):\n    \"\"\"Extract cloud mask from the Landsat Collection 1 TOA BQA band\n\n    Parameters\n    ----------\n    input_img : ee.Image\n        Image from a Landsat Collection 1 TOA collection with a BQA band\n        (e.g. LANDSAT/LE07/C01/T1_TOA).\n    snow_flag : bool\n        If true, mask snow pixels (the default is False).\n    cirrus_flag : bool\n        If true, mask cirrus pixels (the default is False).\n        Note, cirrus bits are only set for Landsat 8 (OLI) images.\n    cloud_confidence : int\n        Minimum cloud confidence value (the default is 2).\n    shadow_confidence : int\n        Minimum cloud confidence value (the default is 3).\n    snow_confidence : int\n        Minimum snow confidence value (the default is 3).  Only used if\n        snow_flag is True.\n    cirrus_confidence : int\n        Minimum cirrus confidence value (the default is 3).  Only used if\n        cirrus_flag is True.\n\n    Returns\n    -------\n    ee.Image\n\n    Notes\n    -----\n    Output image is structured to be applied directly with updateMask()\n        i.e. 0 is cloud, 1 is cloud free\n\n    Assuming Cloud must be set to check Cloud Confidence\n\n    Bits\n        0:     Designated Fill\n        1:     Terrain Occlusion (OLI) / Dropped Pixel (TM, ETM+)\n        2-3:   Radiometric Saturation\n        4:     Cloud\n        5-6:   Cloud Confidence\n        7-8:   Cloud Shadow Confidence\n        9-10:  Snow/Ice Confidence\n        11-12: Cirrus Confidence (Landsat 8 only)\n\n    Confidence values\n        00: \"Not Determined\", algorithm did not determine the status of this\n            condition\n        01: \"No\", algorithm has low to no confidence that this condition exists\n            (0-33 percent confidence)\n        10: \"Maybe\", algorithm has medium confidence that this condition exists\n            (34-66 percent confidence)\n        11: \"Yes\", algorithm has high confidence that this condition exists\n            (67-100 percent confidence)\n\n    References\n    ----------\n    https://landsat.usgs.gov/collectionqualityband\n\n    \"\"\"\n    qa_img = input_img.select(['BQA'])\n    cloud_mask = qa_img.rightShift(4).bitwiseAnd(1).neq(0)\\\n        .And(qa_img.rightShift(5).bitwiseAnd(3).gte(cloud_confidence))\\\n        .Or(qa_img.rightShift(7).bitwiseAnd(3).gte(shadow_confidence))\n    if snow_flag:\n        cloud_mask = cloud_mask.Or(\n            qa_img.rightShift(9).bitwiseAnd(3).gte(snow_confidence))\n    if cirrus_flag:\n        cloud_mask = cloud_mask.Or(\n            qa_img.rightShift(11).bitwiseAnd(3).gte(cirrus_confidence))\n\n    # Set cloudy pixels to 0 and clear to 1\n    return cloud_mask.Not()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract cloud mask from the Landsat Collection 1 SR image collection with a pixel_qa band and a cloud confidence value.", "response": "def landsat_c1_sr_cloud_mask(input_img, cloud_confidence=3, snow_flag=False):\n    \"\"\"Extract cloud mask from the Landsat Collection 1 SR pixel_qa band\n\n    Parameters\n    ----------\n    img : ee.Image\n        Image from a Landsat Collection 1 SR image collection with a pixel_qa\n        band (e.g. LANDSAT/LE07/C01/T1_SR).\n    cloud_confidence : int\n        Minimum cloud confidence value (the default is 3).\n    snow_flag : bool\n        If true, mask snow pixels (the default is False).\n\n    Returns\n    -------\n    ee.Image\n\n    Notes\n    -----\n    Output image is structured to be applied directly with updateMask()\n        i.e. 0 is cloud, 1 is cloud free\n\n    Assuming Cloud must be set to check Cloud Confidence\n\n    Bits\n        0: Fill\n        1: Clear\n        2: Water\n        3: Cloud Shadow\n        4: Snow\n        5: Cloud\n        6-7: Cloud Confidence\n\n    Confidence values\n        00: \"None\"\n        01: \"Low\"\n        10: \"Medium\"\n        11: \"High\"\n\n    References\n    ----------\n    https://landsat.usgs.gov/landsat-surface-reflectance-quality-assessment\n\n    \"\"\"\n    qa_img = input_img.select(['pixel_qa'])\n    cloud_mask = qa_img.rightShift(5).bitwiseAnd(1).neq(0)\\\n        .And(qa_img.rightShift(6).bitwiseAnd(3).gte(cloud_confidence))\\\n        .Or(qa_img.rightShift(3).bitwiseAnd(1).neq(0))\n    if snow_flag:\n        cloud_mask = cloud_mask.Or(qa_img.rightShift(4).bitwiseAnd(1).neq(0))\n\n    # Set cloudy pixels to 0 and clear to 1\n    return cloud_mask.Not()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sentinel2_toa_cloud_mask(input_img):\n    qa_img = input_img.select(['QA60'])\n    cloud_mask = qa_img.rightShift(10).bitwiseAnd(1).neq(0)\\\n        .Or(qa_img.rightShift(11).bitwiseAnd(1).neq(0))\n\n    # Set cloudy pixels to 0 and clear to 1\n    return cloud_mask.Not()", "response": "Extract cloud mask from Sentinel 2 TOA QA60 band"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search_file(pattern, file_path):\n    try:\n        with open(file_path) as file:\n            string = file.read()\n    except PermissionError:\n        return []\n\n    matches = re.findall(pattern, string)\n\n    return matches", "response": "Search a given file for the regex pattern given as pattern"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncrawl through directories like os.walk, but use a 'breadth first' approach (os.walk uses 'depth first')", "response": "def breadth(dirs):\n    \"\"\"\n    Crawl through directories like os.walk, but use a 'breadth first' approach\n    (os.walk uses 'depth first')\n    \"\"\"\n    while dirs:\n        next_dirs = []\n        print(\"Dirs: '{}'\".format(dirs))\n        for d in dirs:\n            next_dirs = []\n            try:\n                for name in os.listdir(d):\n                    p = os.path.join(d, name)\n                    if os.path.isdir(p):\n                        print(p)\n                        next_dirs.append(p)\n            except PermissionError as nallowed:\n                print(nallowed)\n        dirs = next_dirs\n        if dirs:\n            yield dirs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind a given target in the file system.", "response": "def find(init, start=None, one=False, is_exec=False, content=None,\n         parallelize=True, workers=None):\n    \"\"\"\n    Finds a given 'target' (filename string) in the file system\n    \"\"\"\n    base_start, target, suffix = _find_init(init, start)\n\n    def _condition(file_path, dirpath, filenames):\n        if target in filenames or is_exec and os.access(file_path, os.X_OK):\n            if not suffix or has_suffix(dirpath, suffix):\n                if not content or search_file(content, file_path):\n                    return True\n        return False\n\n    starting_points, watch_dirs, excludes = _get_starting_points(base_start)\n    disintegrated_excludes = [disintegrate(e) for e in excludes]\n\n    def _filter(dirnames, dirpath):\n        if disintegrate(dirpath) in watch_dirs:\n            for e in disintegrated_excludes:\n                if e[-1] in dirnames:\n                    if disintegrate(dirpath) == e[:-1]:\n                        dirnames.remove(e[-1])\n\n    def _fetch(top):\n        results = []\n        for dirpath, dirnames, filenames in os.walk(top, topdown=True):\n            # This if-statement is designed to save time\n            _filter(dirnames, dirpath)\n\n            file_path = os.path.normpath(os.path.join(dirpath, target))\n            if _condition(file_path, dirpath, filenames):\n                results.append(file_path)\n        return results\n\n    st = time()\n    if parallelize:\n        unzipped_results = distribute(_fetch, starting_points, workers=workers)\n    else:\n        unzipped_results = [_fetch(point) for point in base_start]\n    et = time()\n    #print(et - st)\n\n    zipped_results = [i for item in unzipped_results for i in item]\n    processed_results = process_output(zipped_results, one=one)\n\n    return processed_results"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_encodings():\n    stdout_encoding = sys.stdout.encoding if sys.stdout.encoding else 'utf-8'\n    stderr_encoding = sys.stderr.encoding if sys.stderr.encoding else 'utf-8'\n    return stdout_encoding, stderr_encoding", "response": "Returns the system encoding and stderr encoding for a single node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef call(commands, *, print_result=False, raise_exception=False,\n         print_commands=False):\n    \"\"\"\n    Will call a set of commands and wrangle the output how you choose\n    \"\"\"\n    if isinstance(commands, str):\n        commands = commands.split()\n\n    if not (isinstance(commands, tuple) or\n            isinstance(commands, list)):\n        raise ValueError(\"Function 'call' does not accept a 'commands'\"\n                         \"argument of type '{}'\".format(type(commands)))\n\n    if raise_exception:\n        print_result = False\n    try:\n        process = subprocess.Popen(commands,\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n        if print_commands:\n            _print_commands(commands)\n\n    except:\n        # TODO Why couldn't we just do 'except Exception as output'\n        output = traceback.format_exc()\n        result = Result(1, stderr=output)\n        if print_result and not raise_exception:\n            print(output, file=sys.stderr)\n\n    else:\n        result = _extract_output(process, print_result, raise_exception)\n\n    if raise_exception and (result.returncode == 1):\n        message = \"An error occurred in an external process:\\n\\n{}\"\n        raise Exception(message.format(result.getStderr()))\n    return result", "response": "Calls a set of commands and returns the output of the process."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef multiCall(*commands, dependent=True, bundle=False,\n              print_result=False, print_commands=False):\n    \"\"\"\n    Calls the function 'call' multiple times, given sets of commands\n    \"\"\"\n    results = []\n    dependent_failed = False\n\n    for command in commands:\n        if not dependent_failed:\n            response = call(command, print_result=print_result,\n                            print_commands=print_commands)\n            # TODO Will an error ever return a code other than '1'?\n            if (response.returncode == 1) and dependent:\n                dependent_failed = True\n        else:\n            response = None\n        results.append(response)\n\n    if bundle:\n        result = Result()\n        for response in results:\n            if not response:\n                continue\n            elif response.returncode == 1:\n                result.returncode = 1\n\n            result.extendInformation(response)\n        processed_response = result\n    else:\n        processed_response = results\n\n    return processed_response", "response": "Calls the function call multiple times given sets of commands"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the combined output of stdout and stderr", "response": "def getOutput(self):\n        \"\"\"\n        Returns the combined output of stdout and stderr\n        \"\"\"\n        output = self.stdout\n        if self.stdout:\n            output += '\\r\\n'\n        output += self.stderr\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extendInformation(self, response):\n        if response.stdout:\n            self.stdout += '\\r\\n' + response.stdout\n        if response.stderr:\n            self.stderr += '\\r\\n' + response.stderr", "response": "This extends the stdout and stderr by the response s stdout and stderr."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwaiting on a combination of zeromq sockets normal sockets and fds returning a list of two - tuples each one with the event mask that was detected on the inmask and outmask.", "response": "def wait_socks(sock_events, inmask=1, outmask=2, timeout=None):\n    \"\"\"wait on a combination of zeromq sockets, normal sockets, and fds\n\n    .. note:: this method can block\n\n        it will return once there is relevant activity on any of the\n        descriptors or sockets, or the timeout expires\n\n    :param sock_events:\n        two-tuples, the first item is either a zeromq socket, a socket, or a\n        file descriptor, and the second item is a mask made up of the inmask\n        and/or the outmask bitwise-ORd together\n    :type sock_events: list\n    :param inmask: the mask to use for readable events (default 1)\n    :type inmask: int\n    :param outmask: the mask to use for writable events (default 2)\n    :type outmask: int\n    :param timeout: the maximum time to block before raising an exception\n    :type timeout: int, float or None\n\n    :returns:\n        a list of two-tuples, each has one of the first elements from\n        ``sock_events``, the second element is the event mask of the activity\n        that was detected (made up on inmask and/or outmask bitwise-ORd\n        together)\n    \"\"\"\n    results = []\n    for sock, mask in sock_events:\n        if isinstance(sock, zmq.backend.Socket):\n            mask = _check_events(sock, mask, inmask, outmask)\n            if mask:\n                results.append((sock, mask))\n    if results:\n        return results\n\n    fd_map = {}\n    fd_events = []\n    for sock, mask in sock_events:\n        if isinstance(sock, zmq.backend.Socket):\n            fd = sock.getsockopt(zmq.FD)\n        elif isinstance(sock, int):\n            fd = sock\n        else:\n            fd = sock.fileno()\n\n        fd_map[fd] = sock\n        fd_events.append((fd, mask))\n\n    while 1:\n        started = time.time()\n        active = descriptor.wait_fds(fd_events, inmask, outmask, timeout)\n        if not active:\n            # timed out\n            return []\n\n        results = []\n        for fd, mask in active:\n            sock = fd_map[fd]\n            if isinstance(sock, zmq.backend.Socket):\n                mask = _check_events(sock, mask, inmask, outmask)\n                if not mask:\n                    continue\n            results.append((sock, mask))\n\n        if results:\n            return results\n\n        timeout -= time.time() - started"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_this_factuality(self,factuality_id):\n        for fact in self.get_factualities():\n            if fact.get_id() == factuality_id:\n                self.node.remove(fact.get_node())\n                break", "response": "Removes the factuality for the given factuality identifier."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a factuality element with a specific id from the layer.", "response": "def remove_factuality(self, fid):\n        \"\"\"\n        Removes a factuality element with a specific id from the layer\n        \"\"\"\n        for node_pre in self.node.findall('factuality'):\n            if node_pre.get('id') == fid:\n                self.node.remove(node_pre)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the factvalue for the given factvalue identifier", "response": "def remove_this_factvalue(self,factvalue_id):\n        \"\"\"\n        Removes the factvalue for the given factvalue identifier\n        @type factvalue_id: string\n        @param factvalue_id: the factvalue identifier to be removed\n        \"\"\"\n        for fact in self.get_factvalues():\n            if fact.get_id() == factvalue_id:\n                self.node.remove(fact.get_node())\n                break"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds version to either url or headers depending on protocol.", "response": "def _add_version_to_request(self, url, headers, version):\n        \"\"\"Adds version to either url or headers, depending on protocol.\"\"\"\n        if self._has_capability(SERVER_REQUIRES_VERSION_HEADER):\n            new_headers = headers.copy()\n            new_headers['Last-Modified'] = email.utils.formatdate(version)\n            return url, new_headers\n        else:\n            url_params = {\n                'last_modified': email.utils.formatdate(version)\n            }\n            new_url = url + \"?\" + urlencode(url_params)\n            return new_url, headers"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _protocol_version(self):\n        if hasattr(self, '_protocol_ver'):\n            return self._protocol_ver\n\n        response = requests.get(self.base_url + '/version/')\n\n        if response.status_code == 404:\n            server_versions = {1}\n        elif response.status_code == 200:\n            server_versions = set(response.json()['protocol_versions'])\n            if not server_versions:\n                raise FiletrackerError(\n                        'Server hasn\\'t reported any supported protocols')\n        else:\n            response.raise_for_status()\n\n        common_versions = _SUPPORTED_VERSIONS.intersection(server_versions)\n        if not common_versions:\n            raise FiletrackerError(\n                    'Couldn\\'t agree on protocol version: client supports '\n                    '{}, server supports {}.'\n                    .format(_PROTOCOL_CAPABILITIES, server_versions))\n\n        self._protocol_ver = max(common_versions)\n        print('Settled for protocol version {}'.format(self._protocol_ver))\n\n        return self._protocol_ver", "response": "Returns the protocol version that should be used."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart cleaning cache in infinite loop.", "response": "def run(self):\n        \"\"\"Starts cleaning cache in infinite loop.\n        \"\"\"\n        logger.info(\"Starting daemon.\")\n        while True:\n            try:\n                self._scan_disk()\n                do_cleaning, delete_from_index = self._analyze_file_index()\n                if do_cleaning:\n                    self._clean_cache(delete_from_index)\n            except Exception:\n                logger.exception(\"Following exception occurred:\")\n            sleeping_until_time = datetime.datetime.now() + self.scan_interval\n            logger.info(\"Sleeping until %s.\", sleeping_until_time)\n            time.sleep(self.scan_interval.total_seconds())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnormalizing a path name to be work with.", "response": "def normalize(path_name, override=None):\n    \"\"\"\n    Prepares a path name to be worked with. Path name must not be empty. This\n    function will return the 'normpath'ed path and the identity of the path.\n    This function takes an optional overriding argument for the identity.\n\n    ONLY PROVIDE OVERRIDE IF:\n        1) YOU AREWORKING WITH A FOLDER THAT HAS AN EXTENSION IN THE NAME\n        2) YOU ARE MAKING A FILE WITH NO EXTENSION\n    \"\"\"\n\n    identity = identify(path_name, override=override)\n    new_path_name = os.path.normpath(os.path.expanduser(path_name))\n\n    return new_path_name, identity"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef identify(path_name, *, override=None, check_exists=True, default=ISDIR):\n\n    head, tail = os.path.split(path_name)\n\n    if check_exists and os.path.exists(path_name):\n        if os.path.isfile(path_name):\n            if override == ISDIR:\n                raise ValueError(\"Cannot override a path as a directory if it \"\n                                 \"is a file that already exists\")\n            result = ISFILE\n        elif os.path.isdir(path_name):\n            if override == ISFILE:\n                raise ValueError(\"Cannot override a path as a file if it is \"\n                                 \"a directory that already exists\")\n            result = ISDIR\n        else:\n            raise Exception(\"Path exists but isn't a file or a directory...\")\n    elif not tail:\n        if override == ISFILE:\n            raise ValueError(\"Cannot interpret a path with a slash at the end \"\n                             \"to be a file\")\n        result = ISDIR\n    elif has_ext(tail, if_all_ext=True):\n        if override is None:\n            result = ISFILE\n        else:\n            result = override\n    else:\n        if override is None:\n            result = default\n        else:\n            result = override\n\n    return result", "response": "Identify the type of a given path name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef join_ext(name, extension):\n    if extension[0] == EXT:\n        ret = name + extension\n    else:\n        ret = name + EXT + extension\n    return ret", "response": "Joins a given name with an extension."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine if the given path name has an extension.", "response": "def has_ext(path_name, *, multiple=None, if_all_ext=False):\n    \"\"\"\n    Determine if the given path name has an extension\n    \"\"\"\n    base = os.path.basename(path_name)\n    count = base.count(EXT)\n\n    if not if_all_ext and base[0] == EXT and count != 0:\n        count -= 1\n\n    if multiple is None:\n        return count >= 1\n    elif multiple:\n        return count > 1\n    else:\n        return count == 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an extension from the given path name.", "response": "def get_ext(path_name, *, if_all_ext=False):\n    \"\"\"\n    Get an extension from the given path name. If an extension cannot be found,\n    it will return an empty string\n    \"\"\"\n    if has_ext(path_name):\n        return os.path.splitext(path_name)[EXTENSION]\n    elif if_all_ext and has_ext(path_name, if_all_ext=True):\n        return os.path.splitext(path_name)[NAME]\n    else:\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_dir(path_name, *, greedy=False, override=None, identity=None):\n    if identity is None:\n        identity = identify(path_name, override=override)\n\n    path_name = os.path.normpath(path_name)\n\n    if greedy and identity == ISDIR:\n        return path_name\n    else:\n        return os.path.dirname(path_name)", "response": "Gets the directory path of the given path name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the name par of the path name given. By name I mean the basename of the file s path such as C:/test. o", "response": "def get_name(path_name, *, ext=True, override=None, identity=None):\n    \"\"\"\n    Gets the name par of the path name given. By 'name' I mean the basename of\n    a filename's path, such as 'test.o' in the path: 'C:/test/test.o'\n    \"\"\"\n    if identity is None:\n        identity = identify(path_name, override=override)\n\n    if identity == ISFILE:\n        if ext:\n            r = os.path.basename(path_name)\n        else:\n            r = os.path.splitext(os.path.basename(path_name))[NAME]\n    else:\n        r = ''\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the available drive names on the system. Always returns a list.", "response": "def get_system_drives():\n    \"\"\"\n    Get the available drive names on the system. Always returns a list.\n    \"\"\"\n    drives = []\n    if os.name == 'nt':\n        import ctypes\n        bitmask = ctypes.windll.kernel32.GetLogicalDrives()\n        letter = ord('A')\n        while bitmask > 0:\n            if bitmask & 1:\n                name = chr(letter) + ':' + os.sep\n                if os.path.isdir(name):\n                    drives.append(name)\n            bitmask >>= 1\n            letter += 1\n    else:\n        current_drive = get_drive(os.getcwd())\n        if current_drive:\n            drive = current_drive\n        else:\n            drive = os.sep\n        drives.append(drive)\n\n    return drives"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_suffix(path_name, suffix):\n    if isinstance(suffix, str):\n        suffix = disintegrate(suffix)\n\n    components = disintegrate(path_name)\n\n    for i in range(-1, -(len(suffix) + 1), -1):\n        if components[i] != suffix[i]:\n            break\n    else:\n        return True\n    return False", "response": "Determines if path_name has at least suffix of at least suffix."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a path to a node.", "response": "def path(path_name=None, override=None, *, root=None, name=None, ext=None,\n         inject=None, relpath=None, reduce=False):\n    \"\"\"\n    Path manipulation black magic\n    \"\"\"\n    path_name, identity, root = _initialize(path_name, override, root, inject)\n    new_name = _process_name(path_name, identity, name, ext)\n    new_directory = _process_directory(path_name, identity, root, inject)\n    full_path = os.path.normpath(os.path.join(new_directory, new_name))\n    if APPEND_SEP_TO_DIRS and not new_name and full_path[-1] != os.sep:\n        full_path += os.sep\n    final_path = _format_path(full_path, root, relpath, reduce)\n    return final_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new File object with the specified path applied to it.", "response": "def path(self, **kwargs):\n        \"\"\"\n        Returns a different object with the specified changes applied to\n        it. This object is not changed in the process.\n        \"\"\"\n        new_path = path(self.getPath(), **kwargs)\n        return File(new_path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the given FileInfo object is out of date.", "response": "def isOutDated(self, output_file):\n        \"\"\"\n        Figures out if Cyther should compile the given FileInfo object by\n        checking the both of the modified times\n        \"\"\"\n        if output_file.exists():\n            source_time = self.getmtime()\n            output_time = output_file.getmtime()\n            return source_time > output_time\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if the file has been modified since given a numerical time", "response": "def isUpdated(self):\n        \"\"\"\n        Figures out if the file had previously errored and hasn't\n        been fixed since given a numerical time\n        \"\"\"\n        modified_time = self.getmtime()\n        valid = modified_time > self.__stamp\n        return valid"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getVersionString():\n    version_string = None\n    try:\n        version_string = subprocess.check_output(['git', 'describe'])\n    except:\n        logger.warning('Command \"git describe\" is not working')\n\n    if version_string == None:  # noqa\n        try:\n            path_to_version = os.path.join(path_to_script,\n                                           '../.git/refs/heads/master')\n            with file(path_to_version) as f:\n                version_string = f.read()\n        except:\n            logger.warning('Problem with reading file \".git/refs/heads/master\"')\n\n    if version_string == None:  # noqa\n        try:\n            path_to_version = os.path.join(path_to_script, '../__VERSION__')\n            with file(path_to_version) as f:\n                version_string = f.read()\n            path_to_version = path_to_version + \\\n                              '  version number is created manually'\n\n        except:\n            logger.warning('Problem with reading file \"__VERSION__\"')\n\n    return version_string", "response": "Function returns string with version information."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the translations requested by the user.", "response": "def get_translations(self, status=None):\n        '''\n            Returns the translations requested by the user\n        '''\n        if status is not None:\n            result = self.api_call('translation/?status=%s' % status)\n        else:\n            result = self.api_call('translation/')\n        if result.status_code == 200:\n            translations_json = json.loads(result.content)[\"objects\"]\n            translations = [Translation(**tj) for tj in translations_json]\n        else:\n            log.critical(\n                'Error status when fetching translation from server: {'\n                '}!'.format(\n                    result.status_code))\n            translations = []\n        return translations"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_translation(self, uid):\n        '''\n            Returns a translation with the given id\n        '''\n        result = self.api_call('translation/{}/'.format(uid))\n        if result.status_code == 200:\n            translation = Translation(**json.loads(result.content))\n        else:\n            log.critical(\n                'Error status when fetching translation from server: {'\n                '}!'.format(\n                    result.status_code))\n            raise ValueError(result.content)\n        return translation", "response": "Returns a translation with the given id\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef upgrade_mt_translation(self, uid, properties=None):\n        api_url = self.api_url\n        uri = 'mt_translation/{}/'.format(uid)\n        url = \"{}{}\".format(api_url, uri)\n        data = {\"status\": \"upgrade\", \"properties\": properties}\n        return requests.patch(url, headers=self.headers, data=json.dumps(data))", "response": "This method is used to upgrade the MT translation for a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the language pairs available on unbabel", "response": "def get_language_pairs(self, train_langs=None):\n        '''\n            Returns the language pairs available on unbabel\n        '''\n        if train_langs is None:\n            result = self.api_call('language_pair/')\n        else:\n            result = self.api_call(\n                'language_pair/?train_langs={}'.format(train_langs))\n        try:\n            langs_json = json.loads(result.content)\n            if 'error' in langs_json:\n                return []\n            languages = [LangPair(Language(\n                shortname=lang_json[\"lang_pair\"][\"source_language\"][\n                    \"shortname\"],\n                name=lang_json[\"lang_pair\"][\"source_language\"][\"name\"]),\n                Language(shortname=lang_json[\"lang_pair\"][\n                    \"target_language\"][\"shortname\"],\n                         name=lang_json[\"lang_pair\"][\n                             \"target_language\"][\"name\"])\n            ) for lang_json in langs_json[\"objects\"]]\n        except Exception, e:\n            log.exception(\"Error decoding get language pairs\")\n            raise e\n        return languages"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_tones(self):\n        '''\n            Returns the tones available on unbabel\n        '''\n        result = self.api_call('tone/')\n        tones_json = json.loads(result.content)\n        tones = [Tone(name=tone_json[\"tone\"][\"name\"],\n                      description=tone_json[\"tone\"][\"description\"])\n                 for tone_json in tones_json[\"objects\"]]\n        return tones", "response": "Returns the tones available on unbabel\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the topics available on unbabel", "response": "def get_topics(self):\n        '''\n            Returns the topics available on unbabel\n        '''\n        result = self.api_call('topic/')\n        topics_json = json.loads(result.content)\n        topics = [Topic(name=topic_json[\"topic\"][\"name\"])\n                  for topic_json in topics_json[\"objects\"]]\n        return topics"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rand(self, unique_pstates, random_state=None):\n        self._init_pstates(unique_pstates)\n        self._init_random(random_state=random_state)\n        self._compute_marginals()\n        return self", "response": "Randomize the POHMM parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfits the model to obtain the log probability of the observation and the partial state states.", "response": "def fit(self, obs, pstates, unique_pstates=None):\n        \"\"\"\n        Estimate model parameters.\n        \"\"\"\n        obs = [np.array(o) for o in obs]\n        pstates = [np.array(p) for p in pstates]\n\n        # List or array of observation sequences\n        assert len(obs) == len(pstates)\n        assert obs[0].ndim == 2\n        assert pstates[0].ndim == 1\n\n        if unique_pstates is not None:\n            self._init_pstates(unique_pstates)\n        else:\n            self._init_pstates(list(set(np.concatenate(pstates))))\n\n        # Map the partial states to a unique index\n        pstates_idx = [np.array([self.e[p] for p in seq]) for seq in pstates]\n\n        if self.init_method == 'rand':\n            self._init_random()\n        elif self.init_method == 'obs':\n            self._init_from_obs(obs, pstates_idx)\n\n        self._init_pstate_freqs(pstates_idx)\n        self._smooth()\n\n        logprob = []\n        for i in range(self.max_iter):\n            # Expectation step\n            stats = self._initialize_sufficient_statistics()\n            curr_logprob = 0\n            for obs_i, pstates_idx_i in zip(obs, pstates_idx):\n                framelogprob = self._compute_log_likelihood(obs_i, pstates_idx_i)\n                lpr, fwdlattice = self._do_forward_pass(framelogprob, pstates_idx_i)\n                bwdlattice = self._do_backward_pass(framelogprob, pstates_idx_i)\n                gamma = fwdlattice + bwdlattice\n                posteriors = np.exp(gamma.T - logsumexp(gamma, axis=1)).T\n                curr_logprob += lpr\n\n                self._accumulate_sufficient_statistics(stats, obs_i,\n                                                       pstates_idx_i, framelogprob, posteriors, fwdlattice, bwdlattice)\n\n            logprob.append(curr_logprob)\n            self.logprob_ = curr_logprob\n\n            # Check for convergence.\n            self.n_iter_performed_ = i\n            if i > 0:\n                self.logprob_delta = logprob[-1] - logprob[-2]\n                if self.logprob_delta < self.thresh:\n                    break\n\n            # Maximization step\n            self._do_mstep(stats)\n\n            # Mix the parameters\n            self._smooth()\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the log probability under the model.", "response": "def score(self, obs, pstates):\n        \"\"\"\n        Compute the log probability under the model.\n        \"\"\"\n        pstates_idx = np.array([self.e[p] for p in pstates])\n        framelogprob = self._compute_log_likelihood(obs, pstates_idx)\n        logprob, _ = self._do_forward_pass(framelogprob, pstates_idx)\n        return logprob"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the log probability of each event under the model.", "response": "def score_events(self, obs, pstates):\n        \"\"\"\n        Compute the log probability of each event under the model.\n        \"\"\"\n        pstates_idx = np.array([self.e[p] for p in pstates])\n\n        framelogprob = self._compute_log_likelihood(obs, pstates_idx)\n        _, fwdlattice = self._do_forward_pass(framelogprob, pstates_idx)\n        L = logsumexp(fwdlattice, axis=1)\n        return np.concatenate([L[[0]], np.diff(L)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npredicts the next observation for the next observation in the given pstates.", "response": "def predict(self, obs, pstates, next_pstate=None):\n        \"\"\"\n        Predict the next observation\n        \"\"\"\n        assert len(obs) == len(pstates)\n        pstates_idx = np.array([self.e[ei] for ei in pstates])\n        next_pstate_idx = self.e[next_pstate]\n\n        if len(obs) == 0:\n            # No history, use the starting probas\n            next_hstate_prob = self.startprob[next_pstate_idx]\n        else:\n            # With a history, determine the hidden state posteriors using\n            # the last posteriors and transition matrix\n            framelogprob = self._compute_log_likelihood(obs, pstates_idx)\n            _, fwdlattice = self._do_forward_pass(framelogprob, pstates_idx)\n\n            next_hstate_prob = np.zeros(self.n_hidden_states)\n\n            alpha_n = fwdlattice[-1]\n            vmax = alpha_n.max(axis=0)\n            alpha_n = np.exp(alpha_n - vmax)\n            alpha_n = alpha_n / alpha_n.sum()\n\n            trans = self.transmat[pstates_idx[-1], next_pstate_idx]\n\n            for i in range(self.n_hidden_states):\n                next_hstate_prob[i] = np.sum([alpha_n[j] * trans[j, i] for j in range(self.n_hidden_states)])\n\n        assert next_hstate_prob.sum() - 1 < TOLERANCE\n\n        # Make the prediction\n        prediction = np.array(\n            [self.expected_value(feature, pstate=next_pstate, hstate_prob=next_hstate_prob) for feature in\n             self.emission_name])\n\n        # next_hstate = np.argmax(next_hstate_prob)\n        # prediction = np.array(\n        #     [self.expected_value(feature, pstate=next_pstate, hstate=next_hstate) for feature in\n        #      self.emission_name])\n\n        return prediction"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fit_df(self, dfs, pstate_col=PSTATE_COL):\n        obs_cols = list(self.emission_name)\n        obs = [df[df.columns.difference([pstate_col])][obs_cols].values for df in dfs]\n        pstates = [df[pstate_col].values for df in dfs]\n        return self.fit(obs, pstates)", "response": "Convenience function to fit a model from a list of dataframes"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndetermines the expected value of a particular feature.", "response": "def expected_value(self, feature=None, pstate=None, hstate=None, pstate_prob=None, hstate_prob=None):\n        \"\"\"\n        Determine the joint maximum likelihood estimate\n        \"\"\"\n        # Use the first feature by default\n        if feature is None:\n            feature = self.emission_name[0]\n\n        # Will default to marginal pstate if pstate is unknown or None\n        pstate_idx = self.e[pstate]\n\n        if pstate is not None and pstate_prob is not None:\n            raise Exception('Must provide either pstate or pstate_proba but not both')\n\n        if hstate is not None and hstate_prob is not None:\n            raise Exception('Must provide either hstate or hstate_proba but not both')\n\n        # Marginalize pstate using the steady state probas\n        if pstate_prob is None:\n            pstate_prob = self.pstate_steadyprob\n\n        # Marginalize hstate using the steady state probas\n        if hstate_prob is None:\n            hstate_prob = self.steadyprob[pstate_idx]\n\n        if pstate is None and hstate is None:\n            # Marginalize both pstate and hstate\n            w = (pstate_prob[:, np.newaxis] * hstate_prob).flatten()\n\n            if self.emission_name_distr[feature] == 'lognormal':\n                return np.sum(w * expected_lognormal(self.emission[feature]['logsigma'].flatten(),\n                                                     self.emission[feature]['logmu'].flatten()))\n            elif self.emission_name_distr[feature] == 'normal':\n                return np.sum(w * expected_normal(self.emission[feature]['mu'].flatten(),\n                                                  self.emission[feature]['sigma'].flatten()))\n        elif hstate is None:\n            # Marginalize hstate\n            if self.emission_name_distr[feature] == 'lognormal':\n                return np.sum(hstate_prob * expected_lognormal(self.emission[feature]['logsigma'][pstate_idx, :],\n                                                               self.emission[feature]['logmu'][pstate_idx, :]))\n            elif self.emission_name_distr[feature] == 'normal':\n                return np.sum(hstate_prob * expected_normal(self.emission[feature]['mu'][pstate_idx, :],\n                                                            self.emission[feature]['sigma'][pstate_idx, :]))\n\n        elif pstate is None:\n            # Marginalize pstate\n            if self.emission_name_distr[feature] == 'lognormal':\n                return np.sum(pstate_prob * expected_lognormal(self.emission[feature]['logsigma'][:, hstate],\n                                                               self.emission[feature]['logmu'][:, hstate]))\n            elif self.emission_name_distr[feature] == 'normal':\n                return np.sum(pstate_prob * expected_normal(self.emission[feature]['mu'][:, hstate],\n                                                            self.emission[feature]['sigma'][:, hstate]))\n        else:\n            if self.emission_name_distr[feature] == 'lognormal':\n                return expected_lognormal(self.emission[feature]['logsigma'][pstate_idx, hstate],\n                                          self.emission[feature]['logmu'][pstate_idx, hstate])\n            elif self.emission_name_distr[feature] == 'normal':\n                return expected_normal(self.emission[feature]['mu'][pstate_idx, hstate],\n                                       self.emission[feature]['sigma'][pstate_idx, hstate])\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_prev_sonorus(self):\n        prev = self.get_prev_letter()\n        if not prev:\n            return\n        if not (self.is_consonant() and prev.is_consonant()):\n            return\n        if self.is_sonorus() and self.is_paired_consonant():\n            if self._get_sound(False) != '\u0432':\n                prev.set_sonorus(True)\n            return\n        if self.is_deaf():\n            prev.set_sonorus(False)\n            return", "response": "Sets the previous sonorus flag for the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_prev_hard(self):\n        prev = self.get_prev_letter()\n        if not prev:\n            return\n        if not prev.is_consonant():\n            return\n        if self.is_softener(prev):\n            prev.set_hard(False)\n        elif self.letter in self.vovels_set_hard:\n            prev.set_hard(True)", "response": "\u0412\u044b\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0442\u0432\u0451\u0440\u0434\u043e\u0441\u0442\u0438/\u043c\u044f\u0433\u043a\u043e\u0441\u0442\u0438, \u0434\u043b\u044f \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0445 \u0441\u043e\u0433\u043b\u0430\u0441\u043d\u044b\u0445."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the current instance is after the exchange.", "response": "def is_after_acc(self):\n        \"\"\"\n        \u0411\u0443\u043a\u0432\u0430 \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0433\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u0443\u0434\u0430\u0440\u0435\u043d\u0438\u044f.\n        \"\"\"\n        prev = self._prev_letter()\n        while True:\n            if not prev:\n                return False\n            if prev.is_shock():\n                return True\n            prev = prev._prev_letter()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_prev_letter(self):\n        prev = self._prev_letter()\n        while True:\n            if not prev:\n                return prev\n            if prev.letter in prev.marks:\n                prev = prev._prev_letter()\n                continue\n            return prev", "response": "Returns the previous letter."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the first available variant for this item.", "response": "def get_variant(self, return_deaf):\n        \"\"\"\n        \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0431\u0443\u043a\u0432\u044b.\n\n        :return_deaf:\n            True - \u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0433\u043b\u0443\u0445\u043e\u0439 \u0432\u0430\u0440\u0438\u0430\u043d\u0442. \u0415\u0441\u043b\u0438 False - \u0437\u0432\u043e\u043d\u043a\u0438\u0439.\n        \"\"\"\n        return_deaf = bool(return_deaf)\n        for variants in self.sonorus_deaf_pairs:\n            if self.__letter in variants:\n                return variants[return_deaf]\n        return self.__letter"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_paired_consonant(self):\n        if not self.is_consonant():\n            return False\n        for variants in self.sonorus_deaf_pairs:\n            if self.letter in variants:\n                return True\n        return False", "response": "Returns True if this is a consonant."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_sonorus(self):\n        if not self.is_consonant():\n            return False\n        if self.letter in self.forever_sonorus:\n            return True\n        if self.letter in self.forever_deaf:\n            return False\n        if self.__forsed_sonorus:\n            return True\n        if self.__forsed_sonorus is False:\n            return False\n        for son, _ in self.sonorus_deaf_pairs:\n            if self.letter == son:\n                return True\n        return False", "response": "Return True if the user is a sonorus."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the user is a deaf.", "response": "def is_deaf(self):\n        \"\"\"\n        \u0413\u043b\u0443\u0445\u0430\u044f \u043b\u0438 \u0441\u043e\u0433\u043b\u0430\u0441\u043d\u0430\u044f.\n        \"\"\"\n        if not self.is_consonant():\n            return False\n        if self.letter in self.forever_deaf:\n            return True\n        if self.letter in self.forever_sonorus:\n            return False\n        if self.__forsed_sonorus:\n            return False\n        if self.__forsed_sonorus is False:\n            return True\n        for _, df in self.sonorus_deaf_pairs:\n            if self.letter == df:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if the string ends with the current character.", "response": "def end(self, string):\n        \"\"\"\n        \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442, \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0431\u0443\u043a\u0432 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u043e\u0439.\n        \u0421\u043a\u0430\u043d \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0441\u044f, \u0431\u0435\u0437 \u0443\u0447\u0451\u0442\u0430 \u0442\u0435\u043a\u0443\u0449\u0435\u0439.\n        \"\"\"\n        prev = self._prev_letter()\n        for s in reversed(string):\n            if prev.letter != s:\n                return False\n            if not prev:\n                return False\n            prev = prev._prev_letter()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if the current locale is softener", "response": "def is_softener(self, let):\n        \"\"\"\n        \u042f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u0441\u0438\u043c\u0432\u043e\u043b \u0441\u043c\u044f\u0433\u0447\u0430\u044e\u0449\u0438\u043c.\n\n        :let: \u041e\u0431\u044a\u0435\u043a\u0442 \u0431\u0443\u043a\u0432\u044b, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043f\u044b\u0442\u0430\u0435\u043c\u0441\u044f \u0441\u043c\u044f\u0433\u0447\u0438\u0442\u044c.\n        \"\"\"\n        if let.letter in let.forever_hard:\n            return False\n        if not let.is_consonant():\n            return False\n        if self.letter in self.vovels_set_soft:\n            return True\n        if self.letter == '\u044c':\n            return True\n        if self.is_soft() and (let.letter in \"\u0434\u0437\u043d\u0441\u0442\"):\n            return True\n        if self.letter == '\u044a':\n            if self.end(\"\u0440\u0430\u0437\") or self.end(\"\u0438\u0437\") or self.end(\"\u0441\"):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(args=None):\n    if args is None:\n        args = sys.argv[1:]\n\n    if not args:\n        args = ['-h']\n\n    namespace = parser.parse_args(args)\n    entry_function = namespace.func\n    del namespace.func\n    kwargs = namespace.__dict__\n    return entry_function(**kwargs)", "response": "Entry point for cyther - script generated by setup. py on installation\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving user data from LDAP server.", "response": "def get_ldap_users(self):\n        \"\"\"Retrieve user data from LDAP server.\"\"\"\n        if (not self.conf_LDAP_SYNC_USER):\n            return (None, None)\n        user_keys = set(self.conf_LDAP_SYNC_USER_ATTRIBUTES.keys())\n        user_keys.update(self.conf_LDAP_SYNC_USER_EXTRA_ATTRIBUTES)\n        uri_users_server, users = self.ldap_search(self.conf_LDAP_SYNC_USER_FILTER, user_keys, self.conf_LDAP_SYNC_USER_INCREMENTAL, self.conf_LDAP_SYNC_USER_FILTER_INCREMENTAL)\n        logger.debug(\"Retrieved %d users from %s LDAP server\" % (len(users), uri_users_server))\n        return (uri_users_server, users)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync_ldap_users(self, ldap_users):\n        model = get_user_model()\n\n        #Load total User starts\n        self.stats_user_total = len(ldap_users)\n\n        list_profiles = []\n        #Load extra profiles. This way we don't even need a callback. The same code is used to populate both auth_user and user_profile\n        for list_profile in self.conf_LDAP_SYNC_USER_EXTRA_PROFILES:\n            list_profiles.append((list_profile, apps.get_model(list_profile)))\n\n        if not model._meta.get_field(self.conf_LDAP_SYNC_USERNAME_FIELD).unique:\n            raise ImproperlyConfigured(\"Field '%s' must be unique\" % self.conf_LDAP_SYNC_USERNAME_FIELD)\n\n        actualProgress = 0\n\n        for cname, attributes in ldap_users:\n            defaults = {}\n            actualProgress += 1\n            if (self.conf_LDAP_SYNC_USER_SHOW_PROGRESS and ((100 * actualProgress // self.stats_user_total) > (100 * (actualProgress - 1) // self.stats_user_total))):\n                logger.info(\"AD User Sync: Processed %d/%d users (%d\" % (actualProgress, self.stats_user_total, (100 * actualProgress) // self.stats_user_total) + \"%)\")\n            try:\n                for name, attribute in attributes.items():\n                    try:\n                        if ((name.lower() == 'thumbnailphoto') or (name.lower() == 'jpegphoto') or (name.lower() == 'thumbnaillogo')):\n                            defaults[self.conf_LDAP_SYNC_USER_ATTRIBUTES[name]] = attribute[0]\n                        else:\n                            defaults[self.conf_LDAP_SYNC_USER_ATTRIBUTES[name]] = attribute[0].decode('utf-8')\n                    except KeyError:\n                        pass\n                    except UnicodeDecodeError:\n                        raise ImproperlyConfigured('Error in attribute ' + name + ' ' + str(attribute))\n            except AttributeError:\n                # In some cases attributes is a list instead of a dict; skip these invalid users\n                continue\n\n            try:\n                username = defaults[self.conf_LDAP_SYNC_USERNAME_FIELD].lower()\n            except KeyError:\n                logger.warning(\"User is missing a required attribute '%s'\" % self.conf_LDAP_SYNC_USERNAME_FIELD)\n                continue\n\n            #Don't import users if they are in LDAP_SYNC_USER_EXEMPT_FROM_SYNC settings\n            if (username in self.conf_LDAP_SYNC_USER_EXEMPT_FROM_SYNC):\n                logger.debug(\"Skip importing user %s, it appears in LDAP_SYNC_USER_EXEMPT_FROM_SYNC list\" % username)\n                continue\n\n            kwargs = {\n                self.conf_LDAP_SYNC_USERNAME_FIELD + '__iexact': username,\n                'defaults': defaults,\n            }\n\n            ### Users Disable\n            #Check disable bit \n            user_account_control = int(attributes[self.ATTRIBUTE_DISABLED][0].decode('utf-8'))\n            user_is_disabled = (user_account_control and ((user_account_control & self.FLAG_UF_ACCOUNT_DISABLE) == self.FLAG_UF_ACCOUNT_DISABLE))\n            if user_is_disabled:\n                try:\n                    #If disabled, we need to check if the user already exists on Django\n                    user = model.objects.get(**{self.conf_LDAP_SYNC_USERNAME_FIELD + '__iexact': username,})\n                    if (not user):\n                        #Ignore disabled users, we won't import it, only update it\n                        continue\n                except Exception as e:\n                    #Ignore disabled users, we won't import it, only update it\n                    continue\n                else:\n                    #If the user already exists on Django we'll run the callbacks\n                    if (self.conf_LDAP_SYNC_REMOVED_USER_CALLBACKS):\n                        self.stats_user_deleted += 1\n                    for path in self.conf_LDAP_SYNC_REMOVED_USER_CALLBACKS:\n                        logger.debug(\"Calling %s for user %s\" % (path, username))\n                        callback = import_string(path)\n                        callback(user)\n            ### User creation and sinchronization\n            updated = False\n            try:\n                if user_is_disabled:\n                    created = False\n                    #reload it because it may be deleted\n                    user = model.objects.get(**{self.conf_LDAP_SYNC_USERNAME_FIELD + '__iexact': username,})\n                else:\n                    user, created = model.objects.get_or_create(**kwargs)\n            except (ObjectDoesNotExist) as e:\n                if (user_is_disabled):\n                    continue\n                else:\n                    raise e\n            except (IntegrityError, DataError) as e:\n                logger.error(\"Error creating user %s: %s\" % (username, e))\n                self.stats_user_errors += 1\n            else:\n                user_updated = False\n                if created:\n                    logger.debug(\"Created user %s\" % username)\n                    self.stats_user_added += 1\n                    user.set_unusable_password()\n                else:\n                    for name, attr in defaults.items():\n                        current_attr = getattr(user, name, None)\n                        if current_attr != attr:\n                            setattr(user, name, attr)\n                            if (not user_updated):\n                                user_updated = True\n                    if user_updated:\n                        logger.debug(\"Updated user %s\" % username)\n                        updated = True\n\n                for path in self.conf_LDAP_SYNC_USER_CALLBACKS:\n                    callback = import_string(path)\n                    callback(user, attributes, created, user_updated)\n\n                try:\n                    if (created or user_updated):\n                        user.save()\n                except Exception as e:\n                    logger.error(\"Error saving user %s: %s\" % (username, e))\n                    self.stats_user_errors += 1\n                ### LDAP Sync Membership\n                if (self.conf_LDAP_SYNC_GROUP_MEMBERSHIP):\n                    membership_uri, ldap_membership = self.get_ldap_user_membership(attributes[self.conf_LDAP_SYNC_GROUP_MEMBERSHIP_DN_FIELD][0].decode('utf-8'))\n                    if ldap_membership:\n                        self.sync_ldap_user_membership(user, ldap_membership)\n            #Profile creation and update.\n            for name_profile, profile_model in list_profiles:\n                try:\n                    profile, created = profile_model.objects.get_or_create(user=user)  # ,  **kwargs )\n                except (IntegrityError, DataError) as e:\n                    logger.error(\"Error creating profile %s for user %s: %s\" % (name_profile, username, e))\n                    self.stats_user_errors += 1\n                else:\n                    profile_updated = False\n                    if (created):\n                        logger.debug(\"Created profile '%s' for user '%s'\" % (name_profile, username))\n                        #profile.save()\n                    for unchanged_name, attr in attributes.items():\n                        name = unchanged_name\n                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"lower\"):\n                            name = unchanged_name.lower()\n                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"upper\"):\n                            name = unchanged_name.upper()\n\n                        try:\n                            if ((name.lower() != 'thumbnailphoto') and (name.lower() != 'jpegphoto') and (name.lower() != 'thumbnaillogo') ):\n                                current_attr = getattr(profile, name)\n                                new_value = ''\n                                if (isinstance(attr, list)):\n                                    for val in attr:\n                                        new_value += val.decode(\"utf8\") + self.conf_LDAP_SYNC_MULTIVALUE_SEPARATOR\n                                    if (new_value != \"\"):\n                                        new_value = new_value[:-len(self.conf_LDAP_SYNC_MULTIVALUE_SEPARATOR)]\n                                else:\n                                    new_value = attr\n                                if current_attr != new_value:\n                                    setattr(profile, name, new_value)\n                                    #logger.debug(\"Updated profile %s: Attribute %s from '%s' to '%s' - '%s'\" % (username,name, current_attr, new_value, attr))\n                                    profile_updated = True\n                            else:\n                                if (isinstance(attr, list)):\n                                    newthumbPhoto = attr[0]\n                                else:\n                                    newthumbPhoto = attr\n                                actualPhoto = None\n                                try:\n                                    if (name.lower() == 'thumbnailphoto'):\n                                        if (not self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE):\n                                            actualPhoto = profile.thumbnailPhoto.read()\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"lower\"):\n                                            actualPhoto = profile.thumbnailphoto.read()\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"upper\"):\n                                            actualPhoto = profile.THUMBNAILPHOTO.read()\n                                    elif (name.lower() == 'thumbnaillogo'):\n                                        if (not self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE):\n                                            actualPhoto = profile.thumbnailLogo.read()\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"lower\"):\n                                            actualPhoto = profile.thumbnaillogo.read()\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"upper\"):\n                                            actualPhoto = profile.THUMBNAILLOGO.read()                                            \n                                    else:\n                                        if (not self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE):\n                                            actualPhoto = profile.jpegPhoto.read()\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"lower\"):\n                                            actualPhoto = profile.jpegphoto.read()\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"upper\"):\n                                            actualPhoto = profile.JPEGPHOTO.read()\n                                except Exception as e:\n                                    pass\n                                if (actualPhoto != newthumbPhoto):\n                                    #Saving thumbnailphoto\n                                    #logger.debug(\"Photo in \"+username+\" are different... \")\n                                    photo_name = self.conf_LDAP_SYNC_USER_THUMBNAILPHOTO_NAME\n                                    #we don't format because I don't know if username it's being used at all\n                                    photo_name = photo_name.replace('{username}', username)\n                                    photo_name = photo_name.replace('{uuid4}', str(uuid.uuid4()))\n                                    photo_name = datetime.now().strftime(photo_name)\n                                    if (name.lower() == 'thumbnailphoto'):\n                                        if (not self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE):\n                                            if (actualPhoto):\n                                                profile.thumbnailPhoto.delete()\n                                            profile.thumbnailPhoto.save(name=photo_name, content=ContentFile(newthumbPhoto))\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"lower\"):\n                                            if (actualPhoto):\n                                                profile.thumbnailphoto.delete()\n                                            profile.thumbnailphoto.save(name=photo_name, content=ContentFile(newthumbPhoto))\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"upper\"):\n                                            if (actualPhoto):\n                                                profile.THUMBNAILPHOTO.delete()\n                                            profile.THUMBNAILPHOTO.save(name=photo_name, content=ContentFile(newthumbPhoto))\n                                    elif (name.lower() == 'thumbnaillogo'):\n                                        if (not self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE):\n                                            if (actualPhoto):\n                                                profile.thumbnailLogo.delete()\n                                            profile.thumbnailLogo.save(name=photo_name, content=ContentFile(newthumbPhoto))\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"lower\"):\n                                            if (actualPhoto):\n                                                profile.thumbnaillogo.delete()\n                                            profile.thumbnaillogo.save(name=photo_name, content=ContentFile(newthumbPhoto))\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"upper\"):\n                                            if (actualPhoto):\n                                                profile.THUMBNAILLOGO.delete()\n                                            profile.THUMBNAILLOGO.save(name=photo_name, content=ContentFile(newthumbPhoto))                                            \n                                    else:\n                                        if (not self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE):\n                                            if (actualPhoto):\n                                                profile.jpegPhoto.delete()\n                                            profile.jpegPhoto.save(name=photo_name, content=ContentFile(newthumbPhoto))\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"lower\"):\n                                            if (actualPhoto):\n                                                profile.jpegphoto.delete()\n                                            profile.jpegphoto.save(name=photo_name, content=ContentFile(newthumbPhoto))\n                                        if (self.conf_LDAP_SYNC_USER_CHANGE_FIELDCASE == \"upper\"):\n                                            if (actualPhoto):\n                                                profile.JPEGPHOTO.delete()\n                                            profile.JPEGPHOTO.save(name=photo_name, content=ContentFile(newthumbPhoto))\n                                    profile_updated = True\n                                else:\n                                    pass\n                                    #logger.debug(\"Photo \"+username+\" are equal\")\n                        except AttributeError:\n                            pass\n                            #logger.debug(\"Ignore Attribute %s on profile '%s'\" % (name, name_profile))\n                    if profile_updated:\n                        logger.debug(\"Updated profile %s on user %s\" % (name_profile, username))\n                        updated = True\n                    if (created or profile_updated):\n                        try:\n                            profile.save()\n                        except Exception as e:\n                            logger.error(\"Error saving profile %s for user %s: %s\" % (name_profile, username, e))\n                            self.stats_user_errors += 1\n                    #profile.save()\n                    #If either user record or any profile record is changed, we'll mark it as updated.\n            if (updated):\n                self.stats_user_updated += 1\n\n        logger.info(\"Users are synchronized\")", "response": "Synchronize LDAP users with local user model."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves groups from LDAP server.", "response": "def get_ldap_groups(self):\n        \"\"\"Retrieve groups from LDAP server.\"\"\"\n        if (not self.conf_LDAP_SYNC_GROUP):\n            return (None, None)\n        uri_groups_server, groups = self.ldap_search(self.conf_LDAP_SYNC_GROUP_FILTER, self.conf_LDAP_SYNC_GROUP_ATTRIBUTES.keys(), self.conf_LDAP_SYNC_GROUP_INCREMENTAL, self.conf_LDAP_SYNC_GROUP_FILTER_INCREMENTAL)\n        logger.debug(\"Retrieved %d groups from %s LDAP server\" % (len(groups), uri_groups_server))\n        return (uri_groups_server, groups)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sync_ldap_groups(self, ldap_groups):\n        groupname_field = 'name'\n        self.stats_group_total = len(ldap_groups)\n\n        for cname, ldap_attributes in ldap_groups:\n            defaults = {}\n            try:\n                for name, attribute in ldap_attributes.items():\n                    defaults[self.conf_LDAP_SYNC_GROUP_ATTRIBUTES[name]] = attribute[0].decode('utf-8')\n            except AttributeError:\n                # In some cases attrs is a list instead of a dict; skip these invalid groups\n                continue\n\n            try:\n                groupname = defaults[groupname_field]\n            except KeyError:\n                logger.warning(\"Group is missing a required attribute '%s'\" % groupname_field)\n                self.stats_group_errors += 1\n                continue\n\n            kwargs = {\n                groupname_field + '__iexact': groupname,\n                'defaults': defaults,\n            }\n            try:\n                group, created = Group.objects.get_or_create(**kwargs)\n            except (IntegrityError, DataError) as e:\n                logger.error(\"Error creating group %s: %s\" % (groupname, e))\n                self.stats_group_errors += 1\n            else:\n                if created:\n                    self.stats_group_added += 1\n                    logger.debug(\"Created group %s\" % groupname)\n\n        logger.info(\"Groups are synchronized\")", "response": "Synchronize LDAP groups with local group model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_ldap_user_membership(self, user_dn):\n        #Escape parenthesis in DN\n        membership_filter = self.conf_LDAP_SYNC_GROUP_MEMBERSHIP_FILTER.replace('{distinguishedName}', user_dn.replace('(', \"\\(\").replace(')', \"\\)\"))\n        try:\n            uri, groups = self.ldap_search(membership_filter, self.conf_LDAP_SYNC_GROUP_ATTRIBUTES.keys(), False, membership_filter)\n        except Exception as e:\n            logger.error(\"Error reading membership: Filter %s, Keys %s\" % (membership_filter, str(self.conf_LDAP_SYNC_GROUP_ATTRIBUTES.keys())))\n            return None\n        #logger.debug(\"AD Membership: Retrieved %d groups for user '%s'\" % (len(groups), user_dn))\n        return (uri, groups)", "response": "Retrieve LDAP user membership from LDAP server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sync_ldap_user_membership(self, user, ldap_groups):\n        groupname_field = 'name'\n        actualGroups = user.groups.values_list('name', flat=True)\n        user_Membership_total = len(ldap_groups)\n        user_Membership_added = 0\n        user_Membership_deleted = 0\n        user_Membership_errors = 0\n\n        ldap_groups += self.conf_LDAP_SYNC_GROUP_MEMBERSHIP_ADD_DEFAULT\n\n        ldap_name_groups = []\n\n        for cname, ldap_attributes in ldap_groups:\n            defaults = {}\n            try:\n                for name, attribute in ldap_attributes.items():\n                    defaults[self.conf_LDAP_SYNC_GROUP_ATTRIBUTES[name]] = attribute[0].decode('utf-8')\n            except AttributeError:\n                # In some cases attrs is a list instead of a dict; skip these invalid groups\n                continue\n\n            try:\n                groupname = defaults[groupname_field]\n                ldap_name_groups.append(groupname)\n            except KeyError:\n                logger.warning(\"Group is missing a required attribute '%s'\" % groupname_field)\n                user_Membership_errors += 1\n                continue\n            if (groupname not in actualGroups):\n                kwargs = {\n                    groupname_field + '__iexact': groupname,\n                    'defaults': defaults,\n                }\n\n                #Adding Group Membership\n                try:\n                    if (self.conf_LDAP_SYNC_GROUP_MEMBERSHIP_CREATE_IF_NOT_EXISTS):\n                        group, created = Group.objects.get_or_create(**kwargs)\n                    else:\n                        group = Group.objects.get(name=groupname)\n                        created = False\n                except (ObjectDoesNotExist):\n                    #Doesn't exist and not autocreate groups, we pass the error\n                    continue\n                except (IntegrityError, DataError) as e:\n                    logger.error(\"Error creating group %s: %s\" % (groupname, e))\n                    user_Membership_errors += 1\n                else:\n                    if created:\n                        logger.debug(\"Created group %s\" % groupname)\n                    #Now well assign the user\n                    group.user_set.add(user)\n                    user_Membership_added += 1\n        #Default Primary Group: Temporary is fixed\n\n\n        #removing group membership\n        for check_group in actualGroups:\n            if (check_group not in ldap_name_groups):\n                group = Group.objects.get(name=check_group)\n                group.user_set.remove(user)\n                user_Membership_deleted += 1\n\n        if ((user_Membership_deleted > 0) or (user_Membership_added > 0)):\n            group.save()\n            logger.info(\"Group membership for user %s synchronized: %d Added, %d Removed\" % (user.username, user_Membership_added, user_Membership_deleted))\n        #Return statistics\n        self.stats_membership_total += user_Membership_total\n        self.stats_membership_added += user_Membership_added\n        self.stats_membership_deleted += user_Membership_deleted\n        self.stats_membership_errors += user_Membership_errors", "response": "Synchronize LDAP membership to Django membership"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch LDAP server with the provided filter and attributes.", "response": "def ldap_search(self, filter, attributes, incremental, incremental_filter):\n        \"\"\"\n        Query the configured LDAP server with the provided search filter and\n        attribute list.\n        \"\"\"\n        for uri in self.conf_LDAP_SYNC_BIND_URI:\n            #Read record of this uri\n            if (self.working_uri == uri):\n                adldap_sync = self.working_adldap_sync\n                created = False\n            else:\n                adldap_sync, created = ADldap_Sync.objects.get_or_create(ldap_sync_uri=uri)\n\n            if ((adldap_sync.syncs_to_full > 0) and incremental):\n                filter_to_use = incremental_filter.replace('?', self.whenchanged.strftime(self.conf_LDAP_SYNC_INCREMENTAL_TIMESTAMPFORMAT))\n                logger.debug(\"Using an incremental search. Filter is:'%s'\" % filter_to_use)\n            else:\n                filter_to_use = filter\n\n            ldap.set_option(ldap.OPT_REFERRALS, 0)\n            #ldap.set_option(ldap.OPT_NETWORK_TIMEOUT, 10)\n            l = PagedLDAPObject(uri)\n            l.protocol_version = 3\n\n            if (uri.startswith('ldaps:')):\n                l.set_option(ldap.OPT_X_TLS, ldap.OPT_X_TLS_DEMAND)\n                l.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_DEMAND)\n                l.set_option(ldap.OPT_X_TLS_DEMAND, True)\n            else:\n                l.set_option(ldap.OPT_X_TLS, ldap.OPT_X_TLS_NEVER)\n                l.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_NEVER)\n                l.set_option(ldap.OPT_X_TLS_DEMAND, False)\n            try:\n                l.simple_bind_s(self.conf_LDAP_SYNC_BIND_DN, self.conf_LDAP_SYNC_BIND_PASS)\n            except ldap.LDAPError as e:\n                logger.error(\"Error connecting to LDAP server %s : %s\" % (uri, e))\n                continue\n\n            results = l.paged_search_ext_s(self.conf_LDAP_SYNC_BIND_SEARCH, ldap.SCOPE_SUBTREE, filter_to_use, attrlist=attributes, serverctrls=None)\n            l.unbind_s()\n            if (self.working_uri is None):\n                self.working_uri = uri\n                self.conf_LDAP_SYNC_BIND_URI.insert(0, uri)\n                self.working_adldap_sync = adldap_sync\n\n            return (uri, results)  # Return both the LDAP server URI used and the request. This is for incremental sync purposes\n        #if not connected correctly, raise error\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef paged_search_ext_s(self, base, scope, filterstr='(objectClass=*)', attrlist=None, attrsonly=0,\n                           serverctrls=None, clientctrls=None, timeout=-1, sizelimit=0):\n        \"\"\"\n        Behaves exactly like LDAPObject.search_ext_s() but internally uses the\n        simple paged results control to retrieve search results in chunks.\n        \"\"\"\n        req_ctrl = SimplePagedResultsControl(True, size=self.conf_LDAP_SYNC_BIND_PAGESIZE, cookie='')\n\n        # Send first search request\n        msgid = self.search_ext(base, ldap.SCOPE_SUBTREE, filterstr, attrlist=attrlist,\n                                serverctrls=(serverctrls or []) + [req_ctrl])\n        results = []\n\n        while True:\n            rtype, rdata, rmsgid, rctrls = self.result3(msgid)\n            results.extend(rdata)\n            # Extract the simple paged results response control\n            pctrls = [c for c in rctrls if c.controlType == SimplePagedResultsControl.controlType]\n\n            if pctrls:\n                if pctrls[0].cookie:\n                    # Copy cookie from response control to request control\n                    req_ctrl.cookie = pctrls[0].cookie\n                    msgid = self.search_ext(base, ldap.SCOPE_SUBTREE, filterstr, attrlist=attrlist,\n                                            serverctrls=(serverctrls or []) + [req_ctrl])\n                else:\n                    break\n\n        return results", "response": "This method is used to retrieve search results in chunks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sliver_reader(filename_end_mask=\"*[0-9].mhd\", sliver_reference_dir=\"~/data/medical/orig/sliver07/training/\", read_orig=True, read_seg=False):\n    sliver_reference_dir = op.expanduser(sliver_reference_dir)\n    orig_fnames = glob.glob(sliver_reference_dir + \"*orig\" +  filename_end_mask)\n    ref_fnames = glob.glob(sliver_reference_dir + \"*seg\"+ filename_end_mask)\n\n    orig_fnames.sort()\n    ref_fnames.sort()\n    output = []\n    for i in range(0, len(orig_fnames)):\n        oname = orig_fnames[i]\n        rname = ref_fnames[i]\n        vs_mm = None\n        ref_data= None\n        orig_data = None\n        if read_orig:\n            orig_data, metadata = io3d.datareader.read(oname)\n            vs_mm = metadata['voxelsize_mm']\n        if read_seg:\n            ref_data, metadata = io3d.datareader.read(rname)\n            vs_mm = metadata['voxelsize_mm']\n\n        import re\n        numeric_label = re.search(\".*g(\\d+)\", oname).group(1)\n        out = (numeric_label, vs_mm, oname, orig_data, rname, ref_data)\n        yield out", "response": "Generator for reading sliver data from directory structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_gunicorn_config(\n        _gunicorn_config_path='',\n):\n    \"\"\"makes gunicorn.conf file for launching in docker\n\n    Notes:\n        https://sebest.github.io/post/protips-using-gunicorn-inside-a-docker-image/\n        renders gunicorn.config (python) file in running dir\n        looks for GUNICORN_{option} in environment vars\n    Args:\n        _gunicorn_config_path (str): TEST HOOK, path to dump file\n\n    \"\"\"\n    gunicorn_py = '''\"\"\"AUTOGENERATED BY: prosper.common.flask_utils:gunicorn_config\nBased off: https://sebest.github.io/post/protips-using-gunicorn-inside-a-docker-image/\n\"\"\"\nfrom os import environ\n\nfor key, value in environ.items():\n    if key.startswith('GUNICORN_'):\n        gunicorn_key = key.split('_', 1)[1].lower()\n        locals()[gunicorn_key] = value\n\n'''\n\n    gunicorn_file = 'gunicorn.conf'\n    if _gunicorn_config_path:\n        gunicorn_file = _gunicorn_config_path\n\n    with open(gunicorn_file, 'w') as gunicorn_cfg:\n        gunicorn_cfg.write(gunicorn_py)", "response": "creates gunicorn. conf file for launching in docker\n"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_arguments():\n    parser = argparse.ArgumentParser(description=\"CMake AST Dumper\")\n    parser.add_argument(\"filename\", nargs=1, metavar=(\"FILE\"),\n                        help=\"read FILE\")\n    return parser.parse_args()", "response": "Return a parser context result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _print_details(extra=None):\n    def print_node_handler(name, node, depth):\n        \"\"\"Standard printer for a node.\"\"\"\n        line = \"{0}{1} {2} ({3}:{4})\".format(depth,\n                                             (\" \" * depth),\n                                             name,\n                                             node.line,\n                                             node.col)\n        if extra is not None:\n            line += \" [{0}]\".format(extra(node))\n\n        sys.stdout.write(line + \"\\n\")\n\n    return print_node_handler", "response": "Return a function that prints node details."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_print(filename):\n    with open(filename) as cmake_file:\n        body = ast.parse(cmake_file.read())\n\n        word_print = _print_details(lambda n: \"{0} {1}\".format(n.type,\n                                                               n.contents))\n        ast_visitor.recurse(body,\n                            while_stmnt=_print_details(),\n                            foreach=_print_details(),\n                            function_def=_print_details(),\n                            macro_def=_print_details(),\n                            if_block=_print_details(),\n                            if_stmnt=_print_details(),\n                            elseif_stmnt=_print_details(),\n                            else_stmnt=_print_details(),\n                            function_call=_print_details(lambda n: n.name),\n                            word=word_print)", "response": "Print the AST of filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the event to triggered after calling this method", "response": "def set(self):\n        \"\"\"set the event to triggered\n\n        after calling this method, all greenlets waiting on the event will be\n        rescheduled, and calling :meth:`wait` will not block until\n        :meth:`clear` has been called\n        \"\"\"\n        self._is_set = True\n        scheduler.state.awoken_from_events.update(self._waiters)\n        del self._waiters[:]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait(self, timeout=None):\n        if self._is_set:\n            return False\n\n        current = compat.getcurrent()  # the waiting greenlet\n\n        waketime = None if timeout is None else time.time() + timeout\n        if timeout is not None:\n            scheduler.schedule_at(waketime, current)\n\n        self._waiters.append(current)\n        scheduler.state.mainloop.switch()\n\n        if timeout is not None:\n            if not scheduler._remove_timer(waketime, current):\n                scheduler.state.awoken_from_events.discard(current)\n                if current in self._waiters:\n                    self._waiters.remove(current)\n                return True\n\n        return False", "response": "pause the current coroutine until the event is set"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef acquire(self, blocking=True):\n        current = compat.getcurrent()\n        if self._owner is current:\n            self._count += 1\n            return True\n        if self._locked and not blocking:\n            return False\n        if self._locked:\n            self._waiters.append(compat.getcurrent())\n            scheduler.state.mainloop.switch()\n        else:\n            self._locked = True\n            self._owner = current\n        self._count = 1\n        return True", "response": "acquire ownership of the lock."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef release(self):\n        if not self._locked or self._owner is not compat.getcurrent():\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        self._count -= 1\n        if self._count == 0:\n            self._owner = None\n            if self._waiters:\n                waiter = self._waiters.popleft()\n                self._locked = True\n                self._owner = waiter\n                scheduler.state.awoken_from_events.add(waiter)\n            else:\n                self._locked = False\n                self._owner = None", "response": "release one ownership of the lock more\n        than once"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwait for the current lock to be woken up by the condition", "response": "def wait(self, timeout=None):\n        \"\"\"wait to be woken up by the condition\n\n        .. note::\n\n            this method will block the current coroutine until a :meth:`notify`\n            wakes it back up.\n\n        :raises:\n            `RuntimeError` if the underlying lock hasn't been\n            :meth:`acquired <Lock.acquire>`\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n\n        current = compat.getcurrent()\n\n        waketime = None if timeout is None else time.time() + timeout\n        if timeout is not None:\n            scheduler.schedule_at(waketime, current)\n        self._waiters.append((current, waketime))\n\n        self._lock.release()\n        scheduler.state.mainloop.switch()\n        self._lock.acquire()\n\n        if timeout is not None:\n            timedout = not scheduler._remove_timer(waketime, current)\n            if timedout:\n                self._waiters.remove((current, waketime))\n            return timedout\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwaking one or more waiting greenlets", "response": "def notify(self, num=1):\n        \"\"\"wake one or more waiting greenlets\n\n        :param num: the number of waiters to wake (default 1)\n        :type num: int\n\n        :raises:\n            `RuntimeError` if the underlying lock hasn't been\n            :meth:`acquired <Lock.acquire>`\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        for i in xrange(min(num, len(self._waiters))):\n            scheduler.state.awoken_from_events.add(self._waiters.popleft()[0])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef notify_all(self):\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        scheduler.state.awoken_from_events.update(x[0] for x in self._waiters)\n        self._waiters.clear()", "response": "wake all waiting greenlets"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef acquire(self, blocking=True):\n        if self._value:\n            self._value -= 1\n            return True\n        if not blocking:\n            return False\n        self._waiters.append(compat.getcurrent())\n        scheduler.state.mainloop.switch()\n        return True", "response": "decrement the counter blocking if it is already at 0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef release(self):\n        \"increment the counter, waking up a waiter if there was any\"\n        if self._waiters:\n            scheduler.state.awoken_from_events.add(self._waiters.popleft())\n        else:\n            self._value += 1", "response": "increment the counter waking up a waiter if there was any"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start(self):\n        if self._started:\n            raise RuntimeError(\"thread already started\")\n\n        def run():\n            try:\n                self.run(*self._args, **self._kwargs)\n            except SystemExit:\n                # only shut down the thread, not the whole process\n                pass\n            finally:\n                self._deactivate()\n\n        self._glet = scheduler.greenlet(run)\n        self._ident = id(self._glet)\n        scheduler.schedule(self._glet)\n        self._activate()", "response": "start the greenlet that runs this thread s function\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef join(self, timeout=None):\n        if not self._started:\n            raise RuntimeError(\"cannot join thread before it is started\")\n        if compat.getcurrent() is self._glet:\n            raise RuntimeError(\"cannot join current thread\")\n        self._finished.wait(timeout)", "response": "block until this thread terminates the current thread"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cancel(self):\n        done = self.finished.is_set()\n        self.finished.set()\n        return not done", "response": "attempt to prevent the timer from ever running its function\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget an item from the queue", "response": "def get(self, block=True, timeout=None):\n        \"\"\"get an item out of the queue\n\n        .. note::\n\n            if `block` is ``True`` (the default) and the queue is\n            :meth`empty`, this method will block the current coroutine until\n            something has been :meth:`put`.\n\n        :param block:\n            whether to block if there is no data yet available (default\n            ``True``)\n        :type block: bool\n        :param timeout:\n            the maximum time in seconds to block waiting for data. with the\n            default of ``None``, can wait indefinitely. this is unused if\n            `block` is ``False``.\n        :type timeout: int, float or None\n\n        :raises:\n            :class:`Empty` if there is no data in the queue and block is\n            ``False``, or `timeout` expires\n\n        :returns: something that was previously :meth:`put` in the queue\n        \"\"\"\n        if not self._data:\n            if not block:\n                raise Empty()\n\n            current = compat.getcurrent()\n\n            waketime = None if timeout is None else time.time() + timeout\n            if timeout is not None:\n                scheduler.schedule_at(waketime, current)\n            self._waiters.append((current, waketime))\n\n            scheduler.state.mainloop.switch()\n\n            if timeout is not None:\n                if not scheduler._remove_timer(waketime, current):\n                    self._waiters.remove((current, waketime))\n                    raise Empty()\n\n        if self.full() and self._waiters:\n            scheduler.schedule(self._waiters.popleft()[0])\n\n        return self._get()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nputs an item into the queue.", "response": "def put(self, item, block=True, timeout=None):\n        \"\"\"put an item into the queue\n\n        .. note::\n\n            if the queue was created with a `maxsize` and it is currently\n            :meth:`full`, this method will block the calling coroutine until\n            another coroutine :meth:`get`\\ s an item.\n\n        :param item: the object to put into the queue, can be any type\n        :param block:\n            whether to block if the queue is already :meth:`full` (default\n            ``True``)\n        :type block: bool\n        :param timeout:\n            the maximum time in seconds to block waiting. with the default of\n            ``None``, it can wait indefinitely. this is unused if `block` is\n            ``False``.\n        :type timeout: int, float or None\n\n        :raises:\n            :class:`Full` if the queue is :meth:`full` and `block` is\n            ``False``, or if `timeout` expires.\n        \"\"\"\n        if self.full():\n            if not block:\n                raise Full()\n\n            current = compat.getcurrent()\n\n            waketime = None if timeout is None else time.time() + timeout\n            if timeout is not None:\n                scheduler.schedule_at(waketime, current)\n            self._waiters.append((current, waketime))\n\n            scheduler.state.mainloop.switch()\n\n            if timeout is not None:\n                if not scheduler._remove_timer(waketime, current):\n                    self._waiters.remove((current, waketime))\n                    raise Full()\n\n        if self._waiters and not self.full():\n            scheduler.schedule(self._waiters.popleft()[0])\n\n        if not self._open_tasks:\n            self._jobs_done.clear()\n        self._open_tasks += 1\n\n        self._put(item)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef task_done(self):\n        if not self._open_tasks:\n            raise ValueError(\"task_done() called too many times\")\n        self._open_tasks -= 1\n        if not self._open_tasks:\n            self._jobs_done.set()", "response": "mark that a job is done"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef increment(self):\n        \"increment the counter, and wake anyone waiting for the new value\"\n        self._count += 1\n        waiters = self._waiters.pop(self._count, [])\n        if waiters:\n            scheduler.state.awoken_from_events.update(waiters)", "response": "increment the counter and wake anyone waiting for the new value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wait(self, until=0):\n        if self._count != until:\n            self._waiters.setdefault(until, []).append(compat.getcurrent())\n            scheduler.state.mainloop.switch()", "response": "wait until the count has reached a particular number\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_callback(connection):\n    while 1:\n        state = connection.poll()\n\n        if state == extensions.POLL_OK:\n            break\n        elif state == extensions.POLL_READ:\n            descriptor.wait_fds([(connection.fileno(), 1)])\n        elif state == extensions.POLL_WRITE:\n            descriptor.wait_fds([(connection.fileno(), 2)])\n        else:\n            raise psycopg2.OperationalError(\"Bad poll result: %r\" % state)", "response": "wait for a coroutine to complete"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef GetUserDetails(user, alias=None):\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tr = clc.v1.API.Call('post','User/GetUserDetails',{'AccountAlias': alias, 'UserName': user })\n\t\tif int(r['StatusCode']) == 0:  \n\t\t\tr['UserDetails']['Roles'] = User._UserRoleList_itos(r['UserDetails']['Roles'])\n\t\t\treturn(r['UserDetails'])", "response": "Get details of a specific user associated with a given account."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all of users assigned to a given account.", "response": "def GetUsers(alias=None):\n\t\t\"\"\"Gets all of users assigned to a given account.\n\t\t\n\t\thttps://t3n.zendesk.com/entries/22427662-GetUsers\n\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tr = clc.v1.API.Call('post','User/GetUsers',{'AccountAlias': alias})\n\t\tif int(r['StatusCode']) == 0:  \n\t\t\treturn(r['Users'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating existing user in a given account.", "response": "def UpdateUser(user, email, first_name, last_name, roles,alias=None):\n\t\t\"\"\"Update existing user within a given account.\n\t\t\n\t\thttps://t3n.zendesk.com/entries/22454018-UpdateUser\n\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param user: user name, which is typically an email address\n\t\t:param email: email address.  Password credentials are emailed to this address on account creation\n\t\t:param first_name: first name\n\t\t:param last_name: surname\n\t\t:param roles: list of roles (ServerAdministrator, BillingManager, DNSManager, AccountAdministrator,  AccountViewer, NetworkManager, SecurityManager, ServerOperator)\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tpayload = {'AccountAlias': alias, 'Roles': [] }\n\t\tif user is not None:  payload['UserName'] = user\n\t\tif email is not None:  payload['EmailAddress'] = email\n\t\tif first_name is not None:  payload['FirstName'] = first_name\n\t\tif last_name is not None:  payload['LastName'] = last_name\n\t\tif roles is not None:\n\t\t\tfor role in roles:  payload['Roles'].append(User.user_role_stoi[role])\n\t\tr = clc.v1.API.Call('post','User/UpdateUser',payload)\n\t\tif int(r['StatusCode']) == 0:  \n\t\t\tr['UserDetails']['Roles'] = User._UserRoleList_itos(r['UserDetails']['Roles'])\n\t\t\treturn(r['UserDetails'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the dependency path from the term to the root node", "response": "def get_path_to_root(self,termid):\n        \"\"\"\n        Returns the dependency path from the term to the root\n        @type termid: string\n        @param termid: the term identifier\n        @rtype: list\n        @return: list of dependency relations\n        \"\"\"        \n        # Get the sentence for the term\n        root = None\n        sentence = self.sentence_for_termid.get(termid)\n        \n        if sentence is None:    #try with the top node\n            top_node = self.top_relation_for_term.get(termid)\n            if top_node is not None:\n                root = top_node[1]\n            else:\n                return None\n        else:\n            if sentence in self.root_for_sentence:\n                root = self.root_for_sentence[sentence]\n            else:\n                ##There is no root for this sentence\n                return None\n        # In this point top_node should be properly set\n        path = self.get_shortest_path(termid, root)\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the complete list of dependents and embedded dependents of a certain term.", "response": "def get_full_dependents(self, term_id, relations, counter = 0):\n        \"\"\"\n        Returns the complete list of dependents and embedded dependents of a certain term.\n        \"\"\"\n        counter += 1\n        deps = self.relations_for_term\n        if term_id in deps and len(deps.get(term_id)) > 0:\n            for dep in deps.get(term_id):\n                if not dep[1] in relations:\n                    relations.append(dep[1])\n                    if dep[1] in deps:\n                        deprelations = self.get_full_dependents(dep[1], relations, counter)\n                        for deprel in deprelations:\n                            if not deprel in relations:\n                                relations.append(deprel)\n\n        return relations"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getDirsToInclude(string):\n    dirs = []\n    a = string.strip()\n    obj = a.split('-')\n\n    if len(obj) == 1 and obj[0]:\n        for module in obj:\n            try:\n                exec('import {}'.format(module))\n            except ImportError:\n                raise FileNotFoundError(\"The module '{}' does not\"\n                                        \"exist\".format(module))\n            try:\n                dirs.append('-I{}'.format(eval(module).get_include()))\n            except AttributeError:\n                print(NOT_NEEDED_MESSAGE.format(module))\n    return dirs", "response": "Given a string of module names it will return the include directories essential to their compilation as long as the module has the conventional\n    get_include function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npurge any configs found in the current directory or the user s home directory.", "response": "def purge_configs():\n    \"\"\"\n    These will delete any configs found in either the current directory or the\n    user's home directory\n    \"\"\"\n    user_config = path(CONFIG_FILE_NAME, root=USER)\n    inplace_config = path(CONFIG_FILE_NAME)\n\n    if os.path.isfile(user_config):\n        os.remove(user_config)\n\n    if os.path.isfile(inplace_config):\n        os.remove(inplace_config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_config_file():\n    local_config_name = path(CONFIG_FILE_NAME)\n    if os.path.isfile(local_config_name):\n        return local_config_name\n    else:\n        user_config_name = path(CONFIG_FILE_NAME, root=USER)\n        if os.path.isfile(user_config_name):\n            return user_config_name\n        else:\n            return None", "response": "Returns the path to the config file if found in either the current working directory or the user s home directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the config data structure that is supposed to exist in the form CONFIG_VALID CONFIG_DATA", "response": "def get_config():\n    \"\"\"\n    Get the config data structure that is supposed to exist in the form:\n        (Status, Data)\n    \"\"\"\n    config_path = find_config_file()\n    if not config_path:\n        return CONFIG_NOT_FOUND, None\n\n    try:\n        config_data = read_config_file(config_path)\n    except Exception as error:\n        return CONFIG_NOT_VALID, error\n\n    return CONFIG_VALID, config_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes the data necessary to construct a functional config file.", "response": "def make_config_data(*, guided):\n    \"\"\"\n    Makes the data necessary to construct a functional config file\n    \"\"\"\n    config_data = {}\n    config_data[INCLUDE_DIRS_KEY] = _make_include_dirs(guided=guided)\n    config_data[RUNTIME_DIRS_KEY] = _make_runtime_dirs(guided=guided)\n    config_data[RUNTIME_KEY] = _make_runtime()\n\n    return config_data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_config_file(guided=False):\n    config_path = _make_config_location(guided=guided)\n\n    config_data = make_config_data(guided=guided)\n\n    write_config_file(config_path, config_data)", "response": "Create a config file for the current language."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates the data for the current node.", "response": "def generate_configurations(*, guided=False, fresh_start=False, save=False):\n    \"\"\"\n    If a config file is found in the standard locations, it will be loaded and\n    the config data would be retuned. If not found, then generate the data on\n    the fly, and return it\n    \"\"\"\n\n    if fresh_start:\n        purge_configs()\n\n    loaded_status, loaded_data = get_config()\n    if loaded_status != CONFIG_VALID:\n        if save:\n            make_config_file(guided=guided)\n            status, config_data = get_config()\n        else:\n            config_data = make_config_data(guided=guided)\n    else:\n        config_data = loaded_data\n\n    return config_data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef info(self):\n        url = \"queues/%s\" % (self.name,)\n        result = self.client.get(url)\n\n        return result['body']['queue']", "response": "Execute an HTTP request to get details on a queue and return it."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear(self):\n        url = \"queues/%s/messages\" % self.name\n        result = self.client.delete(url = url,\n                                    body = json.dumps({}),\n                                    headers={'Content-Type': 'application/json'})\n\n        return result['body']", "response": "Executes an HTTP request to clear all contents of a queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self,  message_id, reservation_id=None, subscriber_name=None):\n        url = \"queues/%s/messages/%s\" % (self.name, message_id)\n        qitems = {}\n        if reservation_id is not None:\n            qitems['reservation_id'] = reservation_id\n        if subscriber_name is not None:\n            qitems['subscriber_name'] = subscriber_name\n        body = json.dumps(qitems)\n\n        result = self.client.delete(url=url, body=body,\n                                    headers={'Content-Type': 'application/json'})\n\n        return result['body']", "response": "Delete a reserved message from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting an HTTP request to delete multiple messages from the queue.", "response": "def delete_multiple(self, ids=None, messages=None):\n        \"\"\"Execute an HTTP request to delete messages from queue.\n\n        Arguments:\n        ids -- A list of messages id to be deleted from the queue.\n        messages -- Response to message reserving.\n        \"\"\"\n        url = \"queues/%s/messages\" % self.name\n\n        items = None\n        if ids is None and messages is None:\n             raise Exception('Please, specify at least one parameter.')\n        if ids is not None:\n           items = [{'id': item} for item in ids]\n        if messages is not None:\n           items = [{'id': item['id'], 'reservation_id': item['reservation_id']} for item in\n                 messages['messages']]\n\n        data = json.dumps({'ids': items})\n\n        result = self.client.delete(url=url, body=data,\n                                    headers={'Content-Type': 'application/json'})\n        return result['body']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post(self, *messages):\n        url = \"queues/%s/messages\" % self.name\n\n        msgs = [{'body': msg} if isinstance(msg, basestring) else msg\n                for msg in messages]\n        data = json.dumps({'messages': msgs})\n\n        result = self.client.post(url=url, body=data,\n                                  headers={'Content-Type': 'application/json'})\n\n        return result['body']", "response": "Executes an HTTP request to create a message on the queue. Returns the JSON response."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves Messages from the queue and reserves it.", "response": "def reserve(self, max=None, timeout=None, wait=None, delete=None):\n        \"\"\"Retrieves Messages from the queue and reserves it.\n\n        Arguments:\n        max -- The maximum number of messages to reserve. Defaults to 1.\n        timeout -- Timeout in seconds.\n        wait -- Time to long poll for messages, in seconds. Max is 30 seconds. Default 0.\n        delete -- If true, do not put each message back on to the queue after reserving. Default false.\n        \"\"\"\n        url = \"queues/%s/reservations\" % self.name\n        qitems = {}\n        if max is not None:\n            qitems['n'] = max\n        if timeout is not None:\n            qitems['timeout'] = timeout\n        if wait is not None:\n            qitems['wait'] = wait\n        if delete is not None:\n            qitems['delete'] = delete\n        body = json.dumps(qitems)\n\n        response = self.client.post(url, body=body,\n                                    headers={'Content-Type': 'application/json'})\n\n        return response['body']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef touch(self, message_id, reservation_id, timeout=None):\n        url = \"queues/%s/messages/%s/touch\" % (self.name, message_id)\n        qitems = {'reservation_id': reservation_id}\n        if timeout is not None:\n            qitems['timeout'] = timeout\n        body = json.dumps(qitems)\n\n        response = self.client.post(url, body=body,\n                                    headers={'Content-Type': 'application/json'})\n\n        return response['body']", "response": "Touching a reserved message extends its timeout to the duration specified when the message was created."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreleasing a locked message.", "response": "def release(self, message_id, reservation_id, delay=0):\n        \"\"\"Release locked message after specified time. If there is no message with such id on the queue.\n\n        Arguments:\n        message_id -- The ID of the message.\n        reservation_id -- Reservation Id of the message.\n        delay -- The time after which the message will be released.\n        \"\"\"\n        url = \"queues/%s/messages/%s/release\" % (self.name, message_id)\n        body = {'reservation_id': reservation_id}\n        if delay > 0:\n            body['delay'] = delay\n        body = json.dumps(body)\n\n        response = self.client.post(url, body=body,\n                                    headers={'Content-Type': 'application/json'})\n\n        return response['body']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef queues(self, page=None, per_page=None, previous=None, prefix=None):\n        options = {}\n        if page is not None:\n            raise Exception('page param is deprecated!')\n        if per_page is not None:\n            options['per_page'] = per_page\n        if previous is not None:\n            options['previous'] = previous\n        if prefix is not None:\n            options['prefix'] = prefix\n\n        query = urlencode(options)\n        url = 'queues'\n        if query != '':\n            url = \"%s?%s\" % (url, query)\n        result = self.client.get(url)\n\n        return [queue['name'] for queue in result['body']['queues']]", "response": "Execute an HTTP request to get a list of queues and return it."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the timex object for the supplied timex_id", "response": "def get_timex(self, timex_id):\n        \"\"\"\n        Returns the timex object for the supplied identifier\n        @type timex_id: string\n        @param timex_id: timex identifier\n        \"\"\"\n        if timex_id in self.idx:\n            return Ctime(self.idx[timex_id])\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a timex object to the layer.", "response": "def add_timex(self, timex_obj):\n        \"\"\"\n        Adds a timex object to the layer.\n        @type timex_obj: L{Ctime}\n        @param timex_obj: the timex object\n        \"\"\"\n        timex_id = timex_obj.get_id()\n        #check if id is not already present\n        if not timex_id in self.idx:\n            \n            timex_node = timex_obj.get_node()\n            self.node.append(timex_node)\n            self.idx[timex_id] = timex_node\n        else:\n            #FIXME: what we want is that the element receives a new identifier that\n            #is not present in current element yet\n            print('Error: trying to add new element with existing identifier')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_timex3s(self, list_timex_ids):\n        nodes_to_remove = set()\n        for timex in self:\n            if timex.get_id() in list_timex_ids:\n                nodes_to_remove.add(timex.get_node())\n                #for removing the previous comment (expected the layer will look like termlayer)\n                prv = timex.get_node().getprevious()\n                if prv is not None:\n                    nodes_to_remove.add(prv)\n\n        for node in nodes_to_remove:\n            self.node.remove(node)", "response": "Removes a list of terms from the layer\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ensure_storage_format(root_dir):\n    if not os.path.isdir(os.path.join(root_dir, 'blobs')):\n        print('\"blobs/\" directory not found')\n        sys.exit(1)\n\n    if not os.path.isdir(os.path.join(root_dir, 'links')):\n        print('\"links/\" directory not found')\n        sys.exit(1)\n\n    if not os.path.isdir(os.path.join(root_dir, 'db')):\n        print('\"db/\" directory not found')\n        sys.exit(1)", "response": "Checks if the directory looks like a filetracker storage.\n    \n    Exits with error if it doesn t."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a stream discarding the data read and returns its size.", "response": "def _read_stream_for_size(stream, buf_size=65536):\n    \"\"\"Reads a stream discarding the data read and returns its size.\"\"\"\n    size = 0\n    while True:\n        buf = stream.read(buf_size)\n        size += len(buf)\n        if not buf:\n            break\n    return size"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the deepest phrase type for the term identifier and the list of subsumed by the same element.", "response": "def get_deepest_phrase_for_termid(self,termid):\n        \"\"\"\n        Returns the deepest phrase type for the term identifier and the list of subsumed by the same element\n        @type termid: string\n        @param termid: term identifier\n        @rtype: (string,list)\n        @return: the label and list of terms subsumed\n        \"\"\"\n        terminal_id = self.terminal_for_term.get(termid)\n        label = None\n        subsumed = []\n        if terminal_id is not None:\n            first_path = self.paths_for_terminal[terminal_id][0]\n            first_phrase_id = first_path[1]\n            label = self.label_for_nonter.get(first_phrase_id)\n            subsumed = self.terms_subsumed_by_nonter.get(first_phrase_id,[])\n        return label,sorted(list(subsumed))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_least_common_subsumer(self,from_tid,to_tid):\n        termid_from = self.terminal_for_term.get(from_tid)\n        termid_to = self.terminal_for_term.get(to_tid)\n        \n        path_from = self.paths_for_terminal[termid_from][0]\n        path_to = self.paths_for_terminal[termid_to][0]\n        common_nodes = set(path_from) & set(path_to)\n        if len(common_nodes) == 0:\n            return None\n        else:\n            indexes = []\n            for common_node in common_nodes:\n                index1 = path_from.index(common_node)\n                index2 = path_to.index(common_node)\n                indexes.append((common_node,index1+index2))\n            indexes.sort(key=itemgetter(1))\n            shortest_common = indexes[0][0]\n            return shortest_common", "response": "Returns the deepest common subsumer among two terms\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_path_for_termid(self,termid):\n        terminal_id = self.terminal_for_term.get(termid)\n        paths = self.paths_for_terminal[terminal_id]\n        labels = [self.label_for_nonter[nonter] for nonter in paths[0]]\n        return labels", "response": "This function returns the path and the list of phrase types from one term the root\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_deepest_subsumer(self,list_terms):\n        '''\n        Returns the labels of the deepest node that subsumes all the terms in the list of terms id's provided\n        '''\n        \n        #To store with how many terms every nonterminal appears\n        count_per_no_terminal = defaultdict(int)\n        \n        #To store the total deep of each noter for all the term ides (as we want the deepest)\n        total_deep_per_no_terminal = defaultdict(int)\n        for term_id in list_terms:\n            terminal_id = self.terminal_for_term.get(term_id)\n            path = self.paths_for_terminal[terminal_id][0]\n            print(term_id, path)\n            for c,noter in enumerate(path):\n                count_per_no_terminal[noter] += 1\n                total_deep_per_no_terminal[noter] += c\n                \n                \n        deepest_and_common = None\n        deepest = 10000\n        for noterid, this_total in total_deep_per_no_terminal.items():\n            if count_per_no_terminal.get(noterid,-1) == len(list_terms):    ##Only the nontarms that ocurr with all the term ids in the input\n                if this_total < deepest:\n                    deepest = this_total\n                    deepest_and_common = noterid\n                    \n        label = None\n        if deepest_and_common is not None:\n            label = self.label_for_nonter[deepest_and_common]\n        return deepest_and_common, label", "response": "Returns the labels of the deepest node that subsumes all the terms in the list of terms id s provided\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_chunks(self,chunk_type):\n        for nonter,this_type in self.label_for_nonter.items():\n            if this_type == chunk_type:\n                subsumed = self.terms_subsumed_by_nonter.get(nonter)\n                if subsumed is not None:\n                    yield sorted(list(subsumed))", "response": "Returns the list of chunks for a certain type of entry in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_all_chunks_for_term(self,termid):\n        terminal_id = self.terminal_for_term.get(termid)\n        paths = self.paths_for_terminal[terminal_id]\n        for path in paths:\n            for node in path:\n                this_type = self.label_for_nonter[node]\n                subsumed =  self.terms_subsumed_by_nonter.get(node)\n                if subsumed is not None:\n                    yield this_type,sorted(list(subsumed))", "response": "Returns all the chunks in which the term is contained in the term."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef surface_density(segmentation, voxelsize_mm, aoi=None, sond_raster_mm=None):\n\n    axis = 0\n    if sond_raster_mm is None:\n        sond_raster_mm = voxelsize_mm\n    if aoi is None:\n        aoi = np.ones(segmentation.shape)\n\n    im_edg = find_edge(segmentation, axis=axis)\n    im_edg = im_edg * aoi\n    im_sond, aoi_sond = bufford_needle_sond(\n        im_edg, voxelsize_mm, sond_raster_mm, axis=axis, aoi=aoi)\n\n# isotropic fakir  - kubinova janacek\n    # est S = 2 \\frac{1}{n} \\sum_{i=1}^{n} \\frac{v}{l_i} \\cdot l_i\n\n# celkova delka sond\n    # n_needle = (im_sond.shape[1] * im_sond.shape[2])\n    # one_needle_l = im_sond.shape[0] * voxelsize_mm[0]\n    # length = n_needle * one_needle_l\n    length = np.sum(aoi_sond > 0) * voxelsize_mm[0]\n\n# inverse of the probe per unit volume v/l_i\n    # ippuv = (\n    #     (np.prod(sond_raster_mm) * im_sond.shape[axis])\n    #     /\n    #     (sond_raster_mm[axis] * im_sond.shape[axis])\n    # )\n# Pocet pruseciku\n    # Ii = np.sum(np.abs(im_sond))\n    Ii = np.sum(np.abs(im_sond))\n\n    # import sed3\n    # ed = sed3.sed3(im_sond)\n    # ed.show()\n\n    # Kubinova2001\n    # print \"Ii = \", Ii\n    Sv = 2.0 * Ii / length\n    # import ipdb; ipdb.set_trace() #  noqa BREAKPOINT\n\n    return Sv", "response": "Compute the surface density of the image."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _lookup_enum_in_ns(namespace, value):\n    for attribute in dir(namespace):\n        if getattr(namespace, attribute) == value:\n            return attribute", "response": "Look up the attribute of namespace corresponding to value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _is_word_type(token_type):\n    return token_type in [TokenType.Word,\n                          TokenType.QuotedLiteral,\n                          TokenType.UnquotedLiteral,\n                          TokenType.Number,\n                          TokenType.Deref]", "response": "Return true if this is a word - type token."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _is_in_comment_type(token_type):\n    return token_type in [TokenType.Comment,\n                          TokenType.Newline,\n                          TokenType.Whitespace,\n                          TokenType.RST,\n                          TokenType.BeginRSTComment,\n                          TokenType.BeginInlineRST,\n                          TokenType.EndInlineRST]", "response": "Return true if this kind of token can be inside a comment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn Single or Double depending on what kind of string this is.", "response": "def _get_string_type_from_token(token_type):\n    \"\"\"Return 'Single' or 'Double' depending on what kind of string this is.\"\"\"\n    return_value = None\n    if token_type in [TokenType.BeginSingleQuotedLiteral,\n                      TokenType.EndSingleQuotedLiteral]:\n        return_value = \"Single\"\n    elif token_type in [TokenType.BeginDoubleQuotedLiteral,\n                        TokenType.EndDoubleQuotedLiteral]:\n        return_value = \"Double\"\n\n    assert return_value is not None\n    return return_value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _make_header_body_handler(end_body_regex,\n                              node_factory,\n                              has_footer=True):\n    \"\"\"Utility function to make a handler for header-body node.\n\n    A header-body node is any node which has a single function-call\n    header and a body of statements inside of it\n    \"\"\"\n    def handler(tokens, tokens_len, body_index, function_call):\n        \"\"\"Handler function.\"\"\"\n        def _end_header_body_definition(token_index, tokens):\n            \"\"\"Header body termination function.\"\"\"\n            if end_body_regex.match(tokens[token_index].content):\n                try:\n                    if tokens[token_index + 1].type == TokenType.LeftParen:\n                        return True\n                except IndexError:\n                    raise RuntimeError(\"Syntax Error\")\n\n            return False\n\n        token_index, body = _ast_worker(tokens, tokens_len, body_index,\n                                        _end_header_body_definition)\n\n        extra_kwargs = {}\n\n        if has_footer:\n            # Handle footer\n            token_index, footer = _handle_function_call(tokens,\n                                                        tokens_len,\n                                                        token_index)\n            extra_kwargs = {\"footer\": footer}\n\n        return (token_index,\n                node_factory(header=function_call,\n                             body=body.statements,\n                             line=tokens[body_index].line,\n                             col=tokens[body_index].col,\n                             index=body_index,\n                             **extra_kwargs))\n\n    return handler", "response": "Utility function to make a handler for header - body nodes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _handle_if_block(tokens, tokens_len, body_index, function_call):\n    # First handle the if statement and body\n    next_index, if_statement = _IF_BLOCK_IF_HANDLER(tokens,\n                                                    tokens_len,\n                                                    body_index,\n                                                    function_call)\n    elseif_statements = []\n    else_statement = None\n    footer = None\n\n    # Keep going until we hit endif\n    while True:\n\n        # Back up a bit until we found out what terminated the if statement\n        # body\n        assert _RE_END_IF_BODY.match(tokens[next_index].content)\n\n        terminator = tokens[next_index].content.lower()\n        if terminator == \"endif\":\n            next_index, footer = _handle_function_call(tokens,\n                                                       tokens_len,\n                                                       next_index)\n            break\n\n        next_index, header = _handle_function_call(tokens,\n                                                   tokens_len,\n                                                   next_index)\n\n        if terminator == \"elseif\":\n            next_index, elseif_stmnt = _ELSEIF_BLOCK_HANDLER(tokens,\n                                                             tokens_len,\n                                                             next_index + 1,\n                                                             header)\n            elseif_statements.append(elseif_stmnt)\n        elif terminator == \"else\":\n            next_index, else_statement = _ELSE_BLOCK_HANDLER(tokens,\n                                                             tokens_len,\n                                                             next_index + 1,\n                                                             header)\n\n    assert footer is not None\n\n    return next_index, IfBlock(if_statement=if_statement,\n                               elseif_statements=elseif_statements,\n                               else_statement=else_statement,\n                               footer=footer,\n                               line=if_statement.line,\n                               col=if_statement.col,\n                               index=body_index)", "response": "Handle the if - blocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles function calls in the CMake tree.", "response": "def _handle_function_call(tokens, tokens_len, index):\n    \"\"\"Handle function calls, which could include a control statement.\n\n    In CMake, all control flow statements are also function calls, so handle\n    the function call first and then direct tree construction to the\n    appropriate control flow statement constructor found in\n    _FUNCTION_CALL_DISAMBIGUATE\n    \"\"\"\n    def _end_function_call(token_index, tokens):\n        \"\"\"Function call termination detector.\"\"\"\n        return tokens[token_index].type == TokenType.RightParen\n\n    # First handle the \"function call\"\n    next_index, call_body = _ast_worker(tokens, tokens_len,\n                                        index + 2,\n                                        _end_function_call)\n\n    function_call = FunctionCall(name=tokens[index].content,\n                                 arguments=call_body.arguments,\n                                 line=tokens[index].line,\n                                 col=tokens[index].col,\n                                 index=index)\n\n    # Next find a handler for the body and pass control to that\n    try:\n        handler = _FUNCTION_CALL_DISAMBIGUATE[tokens[index].content.lower()]\n    except KeyError:\n        handler = None\n\n    if handler:\n        return handler(tokens, tokens_len, next_index, function_call)\n    else:\n        return (next_index, function_call)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _scan_for_tokens(contents):\n    # Regexes are in priority order. Changing the order may alter the\n    # behavior of the lexer\n    scanner = re.Scanner([\n        # Things inside quotes\n        (r\"(?<![^\\s\\(])([\\\"\\'])(?:(?=(\\\\?))\\2.)*?\\1(?![^\\s\\)])\",\n         lambda s, t: (TokenType.QuotedLiteral, t)),\n        # Numbers on their own\n        (r\"(?<![^\\s\\(])-?[0-9]+(?![^\\s\\)\\(])\", lambda s, t: (TokenType.Number,\n                                                             t)),\n        # Left Paren\n        (r\"\\(\", lambda s, t: (TokenType.LeftParen, t)),\n        # Right Paren\n        (r\"\\)\", lambda s, t: (TokenType.RightParen, t)),\n        # Either a valid function name or variable name.\n        (r\"(?<![^\\s\\(])[a-zA-z_][a-zA-Z0-9_]*(?![^\\s\\)\\(])\",\n         lambda s, t: (TokenType.Word, t)),\n        # Variable dereference.\n        (r\"(?<![^\\s\\(])\\${[a-zA-z_][a-zA-Z0-9_]*}(?![^\\s\\)])\",\n         lambda s, t: (TokenType.Deref, t)),\n        # Newline\n        (r\"\\n\", lambda s, t: (TokenType.Newline, t)),\n        # Whitespace\n        (r\"\\s+\", lambda s, t: (TokenType.Whitespace, t)),\n        # The beginning of a double-quoted string, terminating at end of line\n        (r\"(?<![^\\s\\(\\\\])[\\\"]([^\\\"]|\\\\[\\\"])*$\",\n         lambda s, t: (TokenType.BeginDoubleQuotedLiteral, t)),\n        # The end of a double-quoted string\n        (r\"[^\\s]*(?<!\\\\)[\\\"](?![^\\s\\)])\",\n         lambda s, t: (TokenType.EndDoubleQuotedLiteral, t)),\n        # The beginning of a single-quoted string, terminating at end of line\n        (r\"(?<![^\\s\\(\\\\])[\\']([^\\']|\\\\[\\'])*$\",\n         lambda s, t: (TokenType.BeginSingleQuotedLiteral, t)),\n        # The end of a single-quoted string\n        (r\"[^\\s]*(?<!\\\\)[\\'](?![^\\s\\)])\",\n         lambda s, t: (TokenType.EndSingleQuotedLiteral, t)),\n        # Begin-RST Comment Block\n        (r\"#.rst:$\", lambda s, t: (TokenType.BeginRSTComment, t)),\n        # Begin Inline RST\n        (r\"#\\[=*\\[.rst:$\", lambda s, t: (TokenType.BeginInlineRST, t)),\n        # End Inline RST\n        (r\"#\\]=*\\]$\", lambda s, t: (TokenType.EndInlineRST, t)),\n        # Comment\n        (r\"#\", lambda s, t: (TokenType.Comment, t)),\n        # Catch-all for literals which are compound statements.\n        (r\"([^\\s\\(\\)]+|[^\\s\\(]*[^\\)]|[^\\(][^\\s\\)]*)\",\n         lambda s, t: (TokenType.UnquotedLiteral, t))\n    ])\n\n    tokens_return = []\n\n    lines = contents.splitlines(True)\n    lineno = 0\n    for line in lines:\n        lineno += 1\n        col = 1\n\n        tokens, remaining = scanner.scan(line)\n        if remaining != \"\":\n            msg = \"Unknown tokens found on line {0}: {1}\".format(lineno,\n                                                                 remaining)\n            raise RuntimeError(msg)\n\n        for token_type, token_contents in tokens:\n            tokens_return.append(Token(type=token_type,\n                                       content=token_contents,\n                                       line=lineno,\n                                       col=col))\n\n            col += len(token_contents)\n\n    return tokens_return", "response": "Scan a string for tokens and return immediate form tokens."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace a range of tokens with replacement.", "response": "def _replace_token_range(tokens, start, end, replacement):\n    \"\"\"For a range indicated from start to end, replace with replacement.\"\"\"\n    tokens = tokens[:start] + replacement + tokens[end:]\n    return tokens"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _is_really_comment(tokens, index):\n    if tokens[index].type == TokenType.Comment:\n        return True\n\n    # Really a comment in disguise!\n    try:\n        if tokens[index].content.lstrip()[0] == \"#\":\n            return True\n    except IndexError:\n        return False", "response": "Return true if the token at index is really a comment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn lines of tokens pasted together line by line.", "response": "def _paste_tokens_line_by_line(tokens, token_type, begin, end):\n    \"\"\"Return lines of tokens pasted together, line by line.\"\"\"\n    block_index = begin\n\n    while block_index < end:\n        rst_line = tokens[block_index].line\n        line_traversal_index = block_index\n        pasted = \"\"\n        try:\n            while tokens[line_traversal_index].line == rst_line:\n                pasted += tokens[line_traversal_index].content\n                line_traversal_index += 1\n        except IndexError:\n            assert line_traversal_index == end\n\n        last_tokens_len = len(tokens)\n        tokens = _replace_token_range(tokens,\n                                      block_index,\n                                      line_traversal_index,\n                                      [Token(type=token_type,\n                                             content=pasted,\n                                             line=tokens[block_index].line,\n                                             col=tokens[block_index].col)])\n        end -= last_tokens_len - len(tokens)\n        block_index += 1\n\n    return (block_index, len(tokens), tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _find_recorder(recorder, tokens, index):\n    if recorder is None:\n        # See if we can start recording something\n        for recorder_factory in _RECORDERS:\n            recorder = recorder_factory.maybe_start_recording(tokens,\n                                                              index)\n            if recorder is not None:\n                return recorder\n\n    return recorder", "response": "Given a current recorder and a token index try to find a recorder."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _compress_tokens(tokens):\n    recorder = None\n\n    def _edge_case_stray_end_quoted(tokens, index):\n        \"\"\"Convert stray end_quoted_literals to unquoted_literals.\"\"\"\n        # In this case, \"tokenize\" the matched token into what it would\n        # have looked like had the last quote not been there. Put the\n        # last quote on the end of the final token and call it an\n        # unquoted_literal\n        tokens[index] = Token(type=TokenType.UnquotedLiteral,\n                              content=tokens[index].content,\n                              line=tokens[index].line,\n                              col=tokens[index].col)\n\n    tokens_len = len(tokens)\n    index = 0\n\n    with _EdgeCaseStrayParens() as edge_case_stray_parens:\n        edge_cases = [\n            (_is_paren_type, edge_case_stray_parens),\n            (_is_end_quoted_type, _edge_case_stray_end_quoted),\n        ]\n\n        while index < tokens_len:\n\n            recorder = _find_recorder(recorder, tokens, index)\n\n            if recorder is not None:\n                # Do recording\n                result = recorder.consume_token(tokens, index, tokens_len)\n                if result is not None:\n                    (index, tokens_len, tokens) = result\n                    recorder = None\n\n            else:\n                # Handle edge cases\n                for matcher, handler in edge_cases:\n                    if matcher(tokens[index].type):\n                        handler(tokens, index)\n\n            index += 1\n\n    return tokens", "response": "Takes a list of tokens and returns a new list of all the tokens that are pasted together."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a string called contents for CMake tokens.", "response": "def tokenize(contents):\n    \"\"\"Parse a string called contents for CMake tokens.\"\"\"\n    tokens = _scan_for_tokens(contents)\n    tokens = _compress_tokens(tokens)\n    tokens = [token for token in tokens if token.type != TokenType.Whitespace]\n    return tokens"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a string called contents for an AST and return it.", "response": "def parse(contents, tokens=None):\n    \"\"\"Parse a string called contents for an AST and return it.\"\"\"\n    # Shortcut for users who are interested in tokens\n    if tokens is None:\n        tokens = [t for t in tokenize(contents)]\n\n    token_index, body = _ast_worker(tokens, len(tokens), 0, None)\n\n    assert token_index == len(tokens)\n    assert body.arguments == []\n\n    return ToplevelBody(statements=body.statements)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef maybe_start_recording(tokens, index):\n        if _is_really_comment(tokens, index):\n            return _CommentedLineRecorder(index, tokens[index].line)\n\n        return None", "response": "Return a new _CommentedLineRecorder when it is time to record."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconsume a token. Returns a tuple of (tokens, tokens_len, index) when consumption is completed and tokens have been merged together.", "response": "def consume_token(self, tokens, index, tokens_len):\n        \"\"\"Consume a token.\n\n        Returns a tuple of (tokens, tokens_len, index) when consumption is\n        completed and tokens have been merged together.\n        \"\"\"\n        finished = False\n\n        if tokens[index].line > self.line:\n            finished = True\n            end = index\n        elif index == tokens_len - 1:\n            finished = True\n            end = index + 1\n\n        if finished:\n            pasted_together_contents = \"\"\n            for i in range(self.begin, end):\n                pasted_together_contents += tokens[i].content\n\n            replacement = [Token(type=TokenType.Comment,\n                                 content=pasted_together_contents,\n                                 line=tokens[self.begin].line,\n                                 col=tokens[self.begin].col)]\n\n            tokens = _replace_token_range(tokens,\n                                          self.begin,\n                                          end,\n                                          replacement)\n\n            return (self.begin, len(tokens), tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new _RSTCommentBlockRecorder when its time to record.", "response": "def maybe_start_recording(tokens, index):\n        \"\"\"Return a new _RSTCommentBlockRecorder when its time to record.\"\"\"\n        if tokens[index].type == TokenType.BeginRSTComment:\n            return _RSTCommentBlockRecorder(index, tokens[index].line)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef consume_token(self, tokens, index, tokens_len):\n        if _is_really_comment(tokens, index):\n            self.last_line_with_comment = tokens[index].line\n\n        finished = False\n\n        if (not _is_in_comment_type(tokens[index].type) and\n                self.last_line_with_comment != tokens[index].line):\n            finished = True\n            end = index\n        elif index == (tokens_len - 1):\n            finished = True\n            end = index + 1\n\n        if finished:\n            return _paste_tokens_line_by_line(tokens,\n                                              TokenType.RST,\n                                              self.begin,\n                                              end)", "response": "Consume a token.\n\n        Returns a tuple of (tokens, tokens_len, index) when consumption is\n        completed and tokens have been merged together."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef maybe_start_recording(tokens, index):\n        if tokens[index].type == TokenType.BeginInlineRST:\n            return _InlineRSTRecorder(index)", "response": "Return a new _InlineRSTRecorder when its time to record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef consume_token(self, tokens, index, tokens_len):\n        del tokens_len\n\n        if tokens[index].type == TokenType.EndInlineRST:\n            return _paste_tokens_line_by_line(tokens,\n                                              TokenType.RST,\n                                              self.begin,\n                                              index + 1)", "response": "Consume a token.\n\n        Returns a tuple of (tokens, tokens_len, index) when consumption is\n        completed and tokens have been merged together."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef maybe_start_recording(tokens, index):\n        if _is_begin_quoted_type(tokens[index].type):\n            string_type = _get_string_type_from_token(tokens[index].type)\n            return _MultilineStringRecorder(index, string_type)\n\n        return None", "response": "Return a new _MultilineStringRecorder when its time to record."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef consume_token(self, tokens, index, tokens_len):\n        del tokens_len\n\n        consumption_ended = False\n\n        q_type = self.quote_type\n\n        begin_literal_type = getattr(TokenType,\n                                     \"Begin{0}QuotedLiteral\".format(q_type))\n        end_literal_type = getattr(TokenType,\n                                   \"End{0}QuotedLiteral\".format(q_type))\n\n        if (index != self.begin and\n                tokens[index].type == begin_literal_type):\n            # This is an edge case where a quote begins a line and matched\n            # as a quoted region beginning and a quoted region ending.\n            # Split the token before and after the quote, mark the\n            # quote character itself as an ending and insert both\n            # tokens back in, handling the ending afterwards.\n            assert _RE_QUOTE_TYPE.match(tokens[index].content[0])\n\n            # Mini-tokenize everything after the first token\n            line_tokens = _scan_for_tokens(tokens[index].content[1:])\n            end_type = getattr(TokenType,\n                               \"End{0}QuotedLiteral\".format(q_type))\n            replacement = [Token(type=end_type,\n                                 content=tokens[index].content[0],\n                                 line=tokens[index].line,\n                                 col=tokens[index].col)]\n\n            for after in line_tokens:\n                replacement.append(Token(type=after.type,\n                                         content=after.content,\n                                         line=(tokens[index].line +\n                                               after.line - 1),\n                                         col=(tokens[index].col +\n                                              after.col - 1)))\n\n            tokens = _replace_token_range(tokens,\n                                          index,\n                                          index + 1,\n                                          replacement)\n            consumption_ended = True\n\n        if tokens[index].type == end_literal_type:\n            consumption_ended = True\n\n        if consumption_ended:\n            end = index + 1\n            pasted = \"\"\n            for i in range(self.begin, end):\n                pasted += tokens[i].content\n\n            tokens = _replace_token_range(tokens, self.begin, end,\n                                          [Token(type=TokenType.QuotedLiteral,\n                                                 content=pasted,\n                                                 line=tokens[self.begin].line,\n                                                 col=tokens[self.begin].col)])\n\n            return (self.begin, len(tokens), tokens)", "response": "Consume a token.\n\n        Returns tuple of (tokens, tokens_len, index) when consumption is\n        completed and tokens have been merged together."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stratified_kfold(df, n_folds):\n    sessions = pd.DataFrame.from_records(list(df.index.unique())).groupby(0).apply(lambda x: x[1].unique())\n    sessions.apply(lambda x: np.random.shuffle(x))\n    folds = []\n    for i in range(n_folds):\n        idx = sessions.apply(lambda x: pd.Series(x[i * (len(x) / n_folds):(i + 1) * (len(x) / n_folds)]))\n        idx = pd.DataFrame(idx.stack().reset_index(level=1, drop=True)).set_index(0, append=True).index.values\n        folds.append(df.loc[idx])\n    return folds", "response": "Create stratified k - folds from an indexed dataframe"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the CMU dataset from row vectors into time and duration row observations", "response": "def preprocess(df):\n    \"\"\"Convert the CMU dataset from row vectors into time/duration row observations\"\"\"\n\n    def process_row(idx_row):\n        idx, row = idx_row\n\n        # press-press latency\n        tau = 1000 * row[4::3].astype(float).values\n        tau = np.r_[np.median(tau), tau]\n\n        # duration\n        duration = 1000 * row[3::3].astype(float).values\n\n        keyname = list('.tie5Roanl') + ['enter']\n\n        return pd.DataFrame.from_items([\n            ('user', [row['subject']] * 11),\n            ('session', [row['sessionIndex'] * 100 + row['rep']] * 11),\n            ('tau', tau),\n            ('duration', duration),\n            ('event', keyname)\n        ])\n\n    df = pd.concat(map(process_row, df.iterrows())).set_index(['user', 'session'])\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a 2 - state model with lognormal emissions and frequency smoothing", "response": "def keystroke_model():\n    \"\"\"Generates a 2-state model with lognormal emissions and frequency smoothing\"\"\"\n    model = Pohmm(n_hidden_states=2,\n                  init_spread=2,\n                  emissions=['lognormal', 'lognormal'],\n                  smoothing='freq',\n                  init_method='obs',\n                  thresh=1)\n    return model"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts a server that runs python interpreters on connections made to it", "response": "def run_backdoor(address, namespace=None):\n    \"\"\"start a server that runs python interpreters on connections made to it\n\n    .. note::\n\n        this function blocks effectively indefinitely -- it runs the listening\n        socket loop in the current greenlet. to keep the current greenlet free,\n        :func:`schedule<greenhouse.scheduler.schedule>` this function.\n\n    :param address:\n        the address on which to listen for backdoor connections, in the form of\n        a two-tuple ``(host, port)``\n    :type address: tuple\n    :param namespace:\n        the local namespace dict for the interpreter, or None to have each\n        connection create its own empty namespace\n    :type namespace: dict or None\n    \"\"\"\n    log.info(\"starting on %r\" % (address,))\n    serversock = io.Socket()\n    serversock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    serversock.bind(address)\n    serversock.listen(socket.SOMAXCONN)\n\n    while 1:\n        clientsock, address = serversock.accept()\n        log.info(\"connection received from %r\" % (address,))\n        scheduler.schedule(backdoor_handler, args=(clientsock, namespace))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef backdoor_handler(clientsock, namespace=None):\n    namespace = {} if namespace is None else namespace.copy()\n    console = code.InteractiveConsole(namespace)\n    multiline_statement = []\n    stdout, stderr = StringIO(), StringIO()\n\n    clientsock.sendall(PREAMBLE + \"\\n\" + PS1)\n\n    for input_line in _produce_lines(clientsock):\n        input_line = input_line.rstrip()\n        if input_line:\n            input_line = '\\n' + input_line\n        source = '\\n'.join(multiline_statement) + input_line\n        response = ''\n\n        with _wrap_stdio(stdout, stderr):\n            result = console.runsource(source)\n\n        response += stdout.getvalue()\n        err = stderr.getvalue()\n        if err:\n            response += err\n\n        if err or not result:\n            multiline_statement = []\n            response += PS1\n        else:\n            multiline_statement.append(input_line)\n            response += PS2\n\n        clientsock.sendall(response)", "response": "start an interactive python interpreter on a socket"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepare_params(self):\n        if self.options.resolve_fragment:\n            self.fragment_name = self.node.fragment_name.resolve(self.context)\n        else:\n            self.fragment_name = str(self.node.fragment_name)\n            # Remove quotes that surround the name\n            for char in '\\'\\\"':\n                if self.fragment_name.startswith(char) or self.fragment_name.endswith(char):\n                    if self.fragment_name.startswith(char) and self.fragment_name.endswith(char):\n                        self.fragment_name = self.fragment_name[1:-1]\n                        break\n                    else:\n                        raise ValueError('Number of quotes around the fragment name is incoherent')\n\n        self.expire_time = self.get_expire_time()\n\n        if self.options.versioning:\n            self.version = force_bytes(self.get_version())\n\n        self.vary_on = [template.Variable(var).resolve(self.context) for var in self.node.vary_on]", "response": "Prepare the parameters passed to the templatetag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the expire time passed to the templatetag. Must be None or an integer.", "response": "def get_expire_time(self):\n        \"\"\"\n        Return the expire time passed to the templatetag.\n        Must be None or an integer.\n        \"\"\"\n        try:\n            expire_time = self.node.expire_time.resolve(self.context)\n        except template.VariableDoesNotExist:\n            raise template.TemplateSyntaxError('\"%s\" tag got an unknown variable: %r' %\n                                               (self.node.nodename, self.node.expire_time.var))\n        try:\n            if expire_time is not None:\n                expire_time = str(expire_time)\n                if not expire_time.isdigit():\n                    raise TypeError\n                expire_time = int(expire_time)\n        except (ValueError, TypeError):\n            raise template.TemplateSyntaxError(\n                '\"%s\" tag got a non-integer (or None) timeout value: %r' % (\n                    self.node.nodename, expire_time\n                )\n            )\n\n        return expire_time"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the stringified version passed to the templatetag.", "response": "def get_version(self):\n        \"\"\"\n        Return the stringified version passed to the templatetag.\n        \"\"\"\n        if not self.node.version:\n            return None\n        try:\n            version = smart_str('%s' % self.node.version.resolve(self.context))\n        except template.VariableDoesNotExist:\n            raise template.TemplateSyntaxError('\"%s\" tag got an unknown variable: %r' %\n                                               (self.node.nodename, self.node.version.var))\n\n        return '%s' % version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hash_args(self):\n        return hashlib.md5(force_bytes(':'.join([urlquote(force_bytes(var)) for var in self.vary_on]))).hexdigest()", "response": "Take all the arguments passed after the fragment name and return a hashed version of the cache key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the arguments to be passed to the base cache key returned by get_base_cache_key.", "response": "def get_cache_key_args(self):\n        \"\"\"\n        Return the arguments to be passed to the base cache key returned by `get_base_cache_key`.\n        \"\"\"\n        cache_key_args = dict(\n            nodename=self.node.nodename,\n            name=self.fragment_name,\n            hash=self.hash_args(),\n        )\n        if self.options.include_pk:\n            cache_key_args['pk'] = self.get_pk()\n\n        return cache_key_args"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cache_set(self, to_cache):\n        self.cache.set(self.cache_key, to_cache, self.expire_time)", "response": "Set content into the cache"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef join_content_version(self, to_cache):\n        parts = [self.INTERNAL_VERSION]\n        if self.options.versioning:\n            parts.append(force_bytes(self.version))\n        parts.append(force_bytes(to_cache))\n\n        return self.VERSION_SEPARATOR.join(parts)", "response": "Join the version of the content to cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsplitting the content of the cached content into internal and internal versions.", "response": "def split_content_version(self):\n        \"\"\"\n        Remove and return the version(s) from the cached content. First the\n        internal version, and if versioning is activated, the template one.\n        And finally save the content, but only if all versions match.\n        The content saved is the encoded one (if \"compress\" or\n        \"compress_spaces\" options are on). By doing so, we avoid decoding if\n        the versions didn't match, to save some cpu cycles.\n        \"\"\"\n        try:\n            nb_parts = 2\n            if self.options.versioning:\n                nb_parts = 3\n\n            parts = self.content.split(self.VERSION_SEPARATOR, nb_parts - 1)\n            assert len(parts) == nb_parts\n\n            self.content_internal_version = parts[0]\n            if self.options.versioning:\n                self.content_version = parts[1]\n\n            self.content = parts[-1]\n        except Exception:\n            self.content = None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_content(self):\n        self.content = pickle.loads(zlib.decompress(self.content))", "response": "Decode the content from the cache to the final\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render_node(self):\n        self.content = self.node.nodelist.render(self.context)", "response": "Render the template and save the generated content"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender the template and save it to the cache.", "response": "def create_content(self):\n        \"\"\"\n        Render the template, apply options on it, and save it to the cache.\n        \"\"\"\n        self.render_node()\n\n        if self.options.compress_spaces:\n            self.content = self.RE_SPACELESS.sub(' ', self.content)\n\n        if self.options.compress:\n            to_cache = self.encode_content()\n        else:\n            to_cache = self.content\n\n        to_cache = self.join_content_version(to_cache)\n\n        try:\n            self.cache_set(to_cache)\n        except Exception:\n            if is_template_debug_activated():\n                raise\n            logger.exception('Error when saving the cached template fragment')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_content(self):\n\n        self.content = None\n\n        if not self.regenerate:\n            try:\n                self.content = self.cache_get()\n            except Exception:\n                if is_template_debug_activated():\n                    raise\n                logger.exception('Error when getting the cached template fragment')\n\n        try:\n\n            assert self.content\n\n            self.split_content_version()\n\n            assert self.content\n\n            if self.content_internal_version != self.INTERNAL_VERSION or (\n                    self.options.versioning and self.content_version != self.version):\n                self.content = None\n\n            assert self.content\n\n            if self.options.compress:\n                self.decode_content()\n\n        except Exception:\n            self.create_content()\n\n        self.content = smart_str(self.content)", "response": "This method loads the content of the template from the cache and stores it in the internal version and content in the internal version."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render(self):\n        try:\n            self.load_content()\n        except template.TemplateSyntaxError:\n            raise\n        except Exception:\n            if is_template_debug_activated():\n                raise\n            logger.exception('Error when rendering template fragment')\n            return ''\n\n        if self.partial or self.RAW_TOKEN_START not in self.content:\n            return self.content\n\n        return self.render_nocache()", "response": "Renders the content of the current fragment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dict with all the template tags and filters that are available.", "response": "def get_all_tags_and_filters_by_function():\n        \"\"\"\n        Return a dict with all the template tags (in the `tags` entry) and filters (in the\n        `filters` entry) that are available.\n        Both entries are a dict with the function as key, and a tuple with (library name, function\n        name) as value.\n        This is cached after the first call.\n        \"\"\"\n\n        libraries = get_template_libraries()\n\n        force = False\n\n        # We'll force the update of the cache if new libraries where added\n        if hasattr(CacheTag.get_all_tags_and_filters_by_function, '_len_libraries'):\n            if len(libraries) != CacheTag.get_all_tags_and_filters_by_function._len_libraries:\n                force = True\n\n        if force or not hasattr(CacheTag.get_all_tags_and_filters_by_function, '_cache'):\n            CacheTag.get_all_tags_and_filters_by_function._len_libraries = len(libraries)\n            available_tags = {}\n            available_filters = {}\n\n            for lib_name, lib in libraries.items():\n                available_tags.update(\n                    (function, (lib_name, tag_name))\n                    for tag_name, function\n                    in lib.tags.items()\n                )\n                available_filters.update(\n                    (function, (lib_name, filter_name))\n                    for filter_name, function\n                    in lib.filters.items()\n                )\n\n            CacheTag.get_all_tags_and_filters_by_function._cache = {\n                'tags': available_tags,\n                'filters': available_filters\n            }\n\n        return CacheTag.get_all_tags_and_filters_by_function._cache"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the templatetags module name for which the current class is used.", "response": "def get_templatetag_module(cls):\n        \"\"\"\n        Return the templatetags module name for which the current class is used.\n        It's used to render the nocache blocks by loading the correct module\n        \"\"\"\n        if cls not in CacheTag._templatetags_modules:\n            # find the library including the main templatetag of the current class\n            all_tags = cls.get_all_tags_and_filters_by_function()['tags']\n            CacheTag._templatetags_modules[cls] = all_tags[CacheTag._templatetags[cls]['cache']][0]\n        return CacheTag._templatetags_modules[cls]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render_nocache(self):\n        tmpl = template.Template(''.join([\n            # start by loading the cache library\n            template.BLOCK_TAG_START,\n            'load %s' % self.get_templatetag_module(),\n            template.BLOCK_TAG_END,\n            # and surround the cached template by \"raw\" tags\n            self.RAW_TOKEN_START,\n            self.content,\n            self.RAW_TOKEN_END,\n        ]))\n        return tmpl.render(self.context)", "response": "Render the nocache blocks of the content and return the whole nocache html"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_template_node_arguments(cls, tokens):\n        if len(tokens) < 3:\n            raise template.TemplateSyntaxError(\n                \"'%r' tag requires at least 2 arguments.\" % tokens[0])\n        return tokens[1], tokens[2], tokens[3:]", "response": "Return the arguments taken from the templatetag that will be used to the\n        Node class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering all needed templatetags with the given class.", "response": "def register(cls, library_register, nodename='cache', nocache_nodename='nocache'):\n        \"\"\"\n        Register all needed templatetags, with these parameters :\n            * library_register : the `register` object (result of\n                `template.Library()`) in your templatetag module\n            * nodename : the node to use for the cache templatetag (the default\n                is \"cache\")\n            * nocache_nodename : the node to use for the nocache templatetag\n        \"\"\"\n\n        if cls in CacheTag._templatetags:\n            raise RuntimeError('The adv-cache-tag class %s is already registered' % cls)\n\n        CacheTag._templatetags[cls] = {}\n\n        def templatetag_cache(parser, token):\n            \"\"\"\n            Return a new Node object for the main cache templatetag\n            \"\"\"\n            nodelist = parser.parse(('end%s' % nodename,))\n            parser.delete_first_token()\n            args = cls.get_template_node_arguments(token.contents.split())\n            return cls.Node(nodename, nodelist, *args)\n\n        library_register.tag(nodename, templatetag_cache)\n        CacheTag._templatetags[cls]['cache'] = templatetag_cache\n\n        def templatetag_raw(parser, token):\n            \"\"\"\n            Return a TextNode with all html not parsed, used for templatetags\n            that need to not be parsed : the `nocache` one and the `RAW` one,\n            used to surround cached html (to be not parsed again)\n            Based on http://www.holovaty.com/writing/django-two-phased-rendering/\n            \"\"\"\n\n            # Whatever is between {% nocache %} and {% endnocache %} will be preserved as\n            # raw, un-rendered template code.\n\n            text = []\n            parse_until = 'end%s' % token.contents\n            tag_mapping = {\n                TOKEN_TEXT: ('', ''),\n                TOKEN_VAR: ('{{', '}}'),\n                TOKEN_BLOCK: ('{%', '%}'),\n                TOKEN_COMMENT: ('{#', '#}'),\n            }\n            # By the time this template tag is called, the template system has already\n            # lexed the template into tokens. Here, we loop over the tokens until\n            # {% endraw %} and parse them to TextNodes. We have to add the start and\n            # end bits (e.g. \"{{\" for variables) because those have already been\n            # stripped off in a previous part of the template-parsing process.\n            while parser.tokens:\n                token = parser.next_token()\n                if token.token_type == TOKEN_BLOCK and token.contents == parse_until:\n                    return template.TextNode(''.join(text))\n                start, end = tag_mapping[token.token_type]\n                text.append('%s%s%s' % (start, token.contents, end))\n            parser.unclosed_block_tag(parse_until)\n\n        library_register.tag(cls.RAW_TOKEN, templatetag_raw)\n        CacheTag._templatetags[cls]['raw'] = templatetag_raw\n\n        def templatetag_nocache(parser, token):\n            \"\"\"\n            Return a TextNode with raw html from the `nocache` templatetag,\n            and surround it with `endRAW` and `RAW` (precisely\n            `cls.RAW_TOKEN_END` and `cls.RAW_TOKEN_START`).\n            So for\n                {% nocache %}foo{% endnocache %}\n            we get\n                {% endRAW... %}foo{% RAW... %}\n            When the main cache templatetag content will be loaded from cache,\n            it will be surrounded by the same templatetags, reversed.\n            So if at first we had\n                {% cache %}bar{% nocache %}foo{% endnocache %}baz{% endcache %}\n            The cached version will be\n                bar{% endRAW... %}foo{% RAW... %}baz\n            And the final html to be rendered will be\n                {% RAW... %}bar{% endRAW... %}foo{% RAW... %}baz{% endRAW... %}\n            And the html within `RAW` and `endRAW` will not be parsed, as wanted\n            \"\"\"\n\n            # We'll load in the no-cache part all template tags and filters loaded in the main\n            # template, to be able to use it when the no-cache will be rendered\n\n            all_tags_and_filters = cls.get_all_tags_and_filters_by_function()\n            available_tags = all_tags_and_filters['tags']\n            available_filters = all_tags_and_filters['filters']\n\n            needed = {}\n            current_module = cls.get_templatetag_module()\n\n            for function in parser.tags.values():\n                if function in available_tags:\n                    lib, name = available_tags[function]\n                    if lib == current_module:\n                        continue\n                    needed.setdefault(lib, set()).add(name)\n\n            for function in parser.filters.values():\n                if function in available_filters:\n                    lib, name = available_filters[function]\n                    if lib == current_module:\n                        continue\n                    needed.setdefault(lib, set()).add(name)\n\n            load_string = ''.join(\n                '%sload %s from %s%s' % (\n                    template.BLOCK_TAG_START,\n                    ' '.join(names),\n                    lib,\n                    template.BLOCK_TAG_END,\n                )\n                for lib, names in needed.items()\n            )\n\n            node = templatetag_raw(parser, token)\n            node.s = cls.RAW_TOKEN_END + load_string + node.s + cls.RAW_TOKEN_START\n            return node\n\n        library_register.tag(nocache_nodename, templatetag_nocache)\n        CacheTag._templatetags['nocache'] = templatetag_nocache"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef user_active_directory_deactivate(user, attributes, created, updated):\r\n    try:\r\n        user_account_control = int(attributes['userAccountControl'][0])\r\n        if user_account_control & 2:\r\n            user.is_active = False\r\n    except KeyError:\r\n        pass", "response": "Deactivate user accounts based on Active Directory s userAccountControl flags."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_contents_between(string, opener, closer):\n    opener_location = string.index(opener)\n    closer_location = string.index(closer)\n    content = string[opener_location + 1:closer_location]\n    return content", "response": "Get the contents of a string between two characters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that there are no whitespace in the given string. Will raise a ValueError if whitespace is detected.", "response": "def _check_whitespace(string):\n    \"\"\"\n    Make sure thre is no whitespace in the given string. Will raise a\n    ValueError if whitespace is detected\n    \"\"\"\n    if string.count(' ') + string.count('\\t') + string.count('\\n') > 0:\n        raise ValueError(INSTRUCTION_HAS_WHITESPACE)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that the characters in the string are valid definition sets.", "response": "def _check_enclosing_characters(string, opener, closer):\n    \"\"\"\n    Makes sure that the enclosing characters for a definition set make sense\n    1) There is only one set\n    2) They are in the right order (opening, then closing)\n    \"\"\"\n    opener_count = string.count(opener)\n    closer_count = string.count(closer)\n    total = opener_count + closer_count\n    if total > 2:\n        msg = MORE_THAN_ONE_SET.format(opener, closer)\n        raise ValueError(msg)\n    elif total == 1:\n        msg = INCOMPLETE_SET.format(opener, closer)\n        raise ValueError(msg)\n    elif opener_count > 1:\n        msg = INCORRECT_SET_CONSTITUENT.format(opener)\n        raise ValueError(msg)\n    elif closer_count > 1:\n        msg = INCORRECT_SET_CONSTITUENT.format(closer)\n        raise ValueError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking that the given parameters are not empty.", "response": "def _check_parameters(parameters, symbols):\n    \"\"\"\n    Checks that the parameters given are not empty. Ones with prefix symbols\n    can be denoted by including the prefix in symbols\n    \"\"\"\n    for param in parameters:\n        if not param:\n            raise ValueError(EMPTY_PARAMETER)\n        elif (param[0] in symbols) and (not param[1:]):\n            print(param)\n            raise ValueError(EMPTY_KEYWORD_PARAMETER)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_dependencies(string):\n    opener, closer = '(', ')'\n    _check_enclosing_characters(string, opener, closer)\n    if opener in string:\n        if string[0] != opener:\n            raise ValueError(DEPENDENCIES_NOT_FIRST)\n        ret = True\n    else:\n        ret = False\n    return ret", "response": "Checks the dependencies constructor."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks the building options to make sure that they are defined last after the task name and the dependencies of the task.", "response": "def _check_building_options(string):\n    \"\"\"\n    Checks the building options to make sure that they are defined last,\n    after the task name and the dependencies\n    \"\"\"\n    opener, closer = '{', '}'\n    _check_enclosing_characters(string, opener, closer)\n    if opener in string:\n        if string[-1] != closer:\n            raise ValueError(OPTIONS_NOT_LAST)\n        ret = True\n    else:\n        ret = False\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking the flow operator in the string and returns a boolean indicating if it is a valid one.", "response": "def _check_flow_operator(string):\n    \"\"\"\n    Checks the flow operator ('>') to make sure that it:\n    1) Is non empty\n    2) There is only one of them\n    \"\"\"\n    greater_than_count = string.count('>')\n    if greater_than_count > 1:\n        raise ValueError(MULTIPLE_FLOW_OPERATORS)\n    elif (string[0] == '>') or (string[-1] == '>'):\n        raise ValueError(FLOW_OPERATOR_ON_ENDS)\n    else:\n        if greater_than_count == 1:\n            ret = True\n        else:\n            ret = False\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_dependencies(string):\n    contents = _get_contents_between(string, '(', ')')\n    unsorted_dependencies = contents.split(',')\n    _check_parameters(unsorted_dependencies, ('?',))\n\n    buildable_dependencies = []\n    given_dependencies = []\n    for dependency in unsorted_dependencies:\n        if dependency[0] == '?':\n            given_dependencies.append(dependency[1:])\n        else:\n            buildable_dependencies.append(dependency)\n\n    string = string[string.index(')') + 1:]\n    return buildable_dependencies, given_dependencies, string", "response": "This function actually parses the dependencies into buildable_dependencies given_dependencies and string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_building_options(string):\n    contents = _get_contents_between(string, '{', '}')\n    unsorted_options = contents.split(',')\n    _check_parameters(unsorted_options, ('@', '/', '\\\\', '^'))\n\n    output_directory = None\n    output_format = None\n    building_directory = None\n    for option in unsorted_options:\n        if option[0] == '@':\n            if output_format:\n                raise ValueError(MULTIPLE_CONFLICTING_BUILD_OPTIONS)\n            output_format = option[1:]\n        elif option[0] in ('/', '\\\\'):\n            if output_directory:\n                raise ValueError(MULTIPLE_CONFLICTING_BUILD_OPTIONS)\n            output_directory = option[1:]\n        elif option[0] == '^':\n            if building_directory:\n                raise ValueError(MULTIPLE_CONFLICTING_BUILD_OPTIONS)\n            building_directory = option[1:]\n\n    string = string[:string.index('{')]\n    return output_directory, output_format, building_directory, string", "response": "Parses the build options from the string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn specified alias or if none the alias associated with the provided credentials.", "response": "def GetAlias(session=None):\n        \"\"\"Return specified alias or if none the alias associated with the provided credentials.\n\n        >>> clc.v2.Account.GetAlias()\n        u'BTDI'\n        \"\"\"\n        if session is not None:\n            return session['alias']\n\n        if not clc.ALIAS:  clc.v2.API._Login()\n        return(clc.ALIAS)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn specified location or if none the default location associated with the provided credentials and alias.", "response": "def GetLocation(session=None):\n        \"\"\"Return specified location or if none the default location associated with the provided credentials and alias.\n\n        >>> clc.v2.Account.GetLocation()\n        u'WA1'\n        \"\"\"\n        if session is not None:\n            return session['location']\n\n        if not clc.LOCATION:  clc.v2.API._Login()\n        return(clc.LOCATION)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the primary datacenter object associated with the account.", "response": "def PrimaryDatacenter(self):\n        \"\"\"Returns the primary datacenter object associated with the account.\n\n        >>> clc.v2.Account(alias='BTDI').PrimaryDatacenter()\n        <clc.APIv2.datacenter.Datacenter instance at 0x10a45ce18>\n        >>> print _\n        WA1\n\n        \"\"\"\n\n        return(clc.v2.Datacenter(alias=self.alias,location=self.data['primaryDataCenter'], session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_file(self, name, filename, compress_hint=True):\n        return self.add_stream(name, open(filename, 'rb'))", "response": "Adds a file to the store."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file(self, name, filename):\n        stream, vname = self.get_stream(name)\n        path, version = split_name(vname)\n\n        dir_path = os.path.dirname(filename)\n        if dir_path:\n            mkdir(dir_path)\n\n        with open(filename, 'wb') as f:\n            shutil.copyfileobj(stream, f)\n\n        return vname", "response": "Saves the content of file named name to filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef vt2vtk_file(vessel_tree, outfile, text_label=None, lc_all=\"C\"):\n\n    polyData = vt2polyData(vessel_tree, text_label=text_label)\n    if lc_all is not None:\n        import locale\n        locale.setlocale(locale.LC_ALL, 'C')\n    writer = vtk.vtkPolyDataWriter()\n    writer.SetFileName(outfile)\n    try:\n        writer.SetInputData(polyData)\n    except:\n        logger.warning(\"old vtk is used\")\n        writer.SetInput(polyData)\n    writer.Write()\n    return polyData", "response": "Convert a vessel tree to a vtk file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_this_tlink(self,tlink_id):\n        for tlink in self.get_tlinks():\n            if tlink.get_id() == tlink_id:\n                self.node.remove(tlink.get_node())\n                break", "response": "Removes the tlink for the given tlink identifier"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_this_predicateAnchor(self,predAnch_id):\n        for predAnch in self.get_predicateAnchors():\n            if predAnch.get_id() == predAnch_id:\n                self.node.remove(predAnch.get_node())\n                break", "response": "Removes the predicate anchor for the given predicate anchor identifier."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_fds(fd_events, inmask=1, outmask=2, timeout=None):\n    current = compat.getcurrent()\n    activated = {}\n    poll_regs = {}\n    callback_refs = {}\n\n    def activate(fd, event):\n        if not activated and timeout != 0:\n            # this is the first invocation of `activated` for a blocking\n            # `wait_fds` call, so re-schedule the blocked coroutine\n            scheduler.schedule(current)\n\n            # if there was a timeout then also have to pull\n            # the coroutine from the timed_paused structure\n            if timeout:\n                scheduler._remove_timer(waketime, current)\n\n        # in any case, set the event information\n        activated.setdefault(fd, 0)\n        activated[fd] |= event\n\n    for fd, events in fd_events:\n        readable = None\n        writable = None\n        if events & inmask:\n            readable = functools.partial(activate, fd, inmask)\n        if events & outmask:\n            writable = functools.partial(activate, fd, outmask)\n\n        callback_refs[fd] = (readable, writable)\n        poll_regs[fd] = scheduler._register_fd(fd, readable, writable)\n\n    if timeout:\n        # real timeout value, schedule ourself `timeout` seconds in the future\n        waketime = time.time() + timeout\n        scheduler.pause_until(waketime)\n    elif timeout == 0:\n        # timeout == 0, only pause for 1 loop iteration\n        scheduler.pause()\n    else:\n        # timeout is None, it's up to _hit_poller->activate to bring us back\n        scheduler.state.mainloop.switch()\n\n    for fd, reg in poll_regs.iteritems():\n        readable, writable = callback_refs[fd]\n        scheduler._unregister_fd(fd, readable, writable, reg)\n\n    if scheduler.state.interrupted:\n        raise IOError(errno.EINTR, \"interrupted system call\")\n\n    return activated.items()", "response": "wait for the first of a number of file descriptors to have activity on the file descriptors in fd_events"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding __version__ for making package", "response": "def get_version(package_name):\n    \"\"\"find __version__ for making package\n\n    Args:\n        package_name (str): path to _version.py folder (abspath > relpath)\n\n    Returns:\n        str: __version__ value\n\n    \"\"\"\n    module = 'prosper.' + package_name + '._version'\n    package = importlib.import_module(module)\n\n    version = package.__version__\n\n    return version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hack_find_packages(include_str):\n    new_list = [include_str]\n    for element in find_packages(include_str):\n        new_list.append(include_str + '.' + element)\n\n    return new_list", "response": "patches setuptools. find_packages issue\n\n    setuptools. find_packages doesn t work as intended\n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nslurping up all files in a directory for data_files section", "response": "def include_all_subfiles(*args):\n    \"\"\"Slurps up all files in a directory (non recursive) for data_files section\n\n    Note:\n        Not recursive, only includes flat files\n\n    Returns:\n        list: list of all non-directories in a file\n\n    \"\"\"\n    file_list = []\n    for path_included in args:\n        local_path = path.join(HERE, path_included)\n\n        for file in listdir(local_path):\n            file_abspath = path.join(local_path, file)\n            if path.isdir(file_abspath):    #do not include sub folders\n                continue\n            file_list.append(path_included + '/' + file)\n\n    return file_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwaits until all requests have completed.", "response": "def WaitUntilComplete(self,poll_freq=2,timeout=None):\n\t\t\"\"\"Poll until all request objects have completed.\n\n\t\tIf status is 'notStarted' or 'executing' continue polling.\n\t\tIf status is 'succeeded' then success\n\t\tElse log as error\n\n\t\tpoll_freq option is in seconds\n\n\t\tReturns an Int the number of unsuccessful requests.  This behavior is subject to change.\n\n\t\t>>> clc.v2.Server(alias='BTDI',id='WA1BTDIKRT02').PowerOn().WaitUntilComplete()\n\t\t0\n\n\t\t\"\"\"\n\n\t\tstart_time = time.time()\n\t\twhile len(self.requests):\n\t\t\tcur_requests = []\n\t\t\tfor request in self.requests:\n\t\t\t\tstatus = request.Status()\n\t\t\t\tif status in ('notStarted','executing','resumed','queued','running'): cur_requests.append(request)\n\t\t\t\telif status == 'succeeded': self.success_requests.append(request)\n\t\t\t\telif status in (\"failed\", \"unknown\"): self.error_requests.append(request)\n\n\t\t\tself.requests = cur_requests\n\t\t\tif self.requests > 0 and clc.v2.time_utils.TimeoutExpired(start_time, timeout):\n\t\t\t\traise clc.RequestTimeoutException('Timeout waiting for Requests: {0}'.format(self.requests[0].id),\n\t\t\t\t                                  self.requests[0].Status())\n\n\t\t\ttime.sleep(poll_freq)\t# alternately - sleep for the delta between start time and 2s\n\n\t\t# Is this the best approach?  Non-zero indicates some error.  Exception seems the wrong approach for\n\t\t# a partial failure\n\t\treturn(len(self.error_requests))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwait until the request is completed.", "response": "def WaitUntilComplete(self,poll_freq=2,timeout=None):\n\t\t\"\"\"Poll until status is completed.\n\n\t\tIf status is 'notStarted' or 'executing' continue polling.\n\t\tIf status is 'succeeded' return\n\t\tElse raise exception\n\n\t\tpoll_freq option is in seconds\n\n\t\t\"\"\"\n\t\tstart_time = time.time()\n\t\twhile not self.time_completed:\n\t\t\tstatus = self.Status()\n\t\t\tif status == 'executing':\n\t\t\t\tif not self.time_executed:  self.time_executed = time.time()\n\t\t\t\tif clc.v2.time_utils.TimeoutExpired(start_time, timeout):\n\t\t\t\t\traise clc.RequestTimeoutException('Timeout waiting for Request: {0}'.format(self.id), status)\n\n\t\t\telif status == 'succeeded':\n\t\t\t\tself.time_completed = time.time()\n\t\t\telif status in (\"failed\", \"resumed\" or \"unknown\"):\n\t\t\t\t# TODO - need to ID best reaction for resumed status (e.g. manual intervention)\n\t\t\t\tself.time_completed = time.time()\n\t\t\t\traise(clc.CLCException(\"%s %s execution %s\" % (self.context_key,self.context_val,status)))\n\n\t\t\ttime.sleep(poll_freq)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns server associated with this request.", "response": "def Server(self):\n\t\t\"\"\"Return server associated with this request.\n\n\t\t>>> d = clc.v2.Datacenter()\n\t\t>>> q = clc.v2.Server.Create(name=\"api2\",cpu=1,memory=1,group_id=d.Groups().Get(\"Default Group\").id,template=d.Templates().Search(\"centos-6-64\")[0].id,network_id=d.Networks().networks[0].id,ttl=4000)\n\t\t>>> q.WaitUntilComplete()\n\t\t0\n\t\t>>> q.success_requests[0].Server()\n\t\t<clc.APIv2.server.Server object at 0x1095a8390>\n\t\t>>> print _\n\t\tVA1BTDIAPI214\n\n\t\t\"\"\"\n\t\tif self.context_key == 'newserver':\n\t\t\tserver_id = clc.v2.API.Call('GET', self.context_val,session=self.session)['id']\n\t\t\treturn(clc.v2.Server(id=server_id,alias=self.alias,session=self.session))\n\t\telif self.context_key == 'server':\n\t\t\treturn(clc.v2.Server(id=self.context_val,alias=self.alias,session=self.session))\n\t\telse:  raise(clc.CLCException(\"%s object not server\" % self.context_key))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __get_header_with_auth(self):\n        auth_header = self.__get_header()\n        auth_header['Authorization'] = 'Bearer %s' % self.__token\n        token_renew_time = self.__auth_time + timedelta(seconds=self.TOKEN_DURATION_SECONDS)\n\n        if datetime.now() > token_renew_time:\n            token_max_time = self.__auth_time + timedelta(seconds=self.TOKEN_MAX_DURATION)\n            if datetime.now() < token_max_time:\n                self.__refresh_token()\n            else:\n                self.login()\n\n            auth_header['Authorization'] = 'Bearer %s' % self.__token\n\n        return auth_header", "response": "This private method returns the HTTP heder filled with the Authorization information with the user token."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef login(self):\n        auth_data = dict()\n        auth_data['apikey'] = self.api_key\n        auth_data['username'] = self.username\n        auth_data['userkey'] = self.account_identifier\n\n        auth_resp = requests_util.run_request('post', self.API_BASE_URL + '/login', data=json.dumps(auth_data),\n                                              headers=self.__get_header())\n\n        if auth_resp.status_code == 200:\n            auth_resp_data = self.parse_raw_response(auth_resp)\n            self.__token = auth_resp_data['token']\n            self.__auth_time = datetime.now()\n            self.is_authenticated = True\n        else:\n            raise AuthenticationFailedException('Authentication failed!')", "response": "This method performs the login on TheTVDB given the api key user name and account identifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches for a series in TheTVDB by either its name imdb_id or zap2it_id.", "response": "def search_series(self, name=None, imdb_id=None, zap2it_id=None):\n        \"\"\"\n        Searchs for a series in TheTVDB by either its name, imdb_id or zap2it_id.\n\n        :param name: the name of the series to look for\n        :param imdb_id: the IMDB id of the series to look for\n        :param zap2it_id: the zap2it id of the series to look for.\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n        arguments = locals()\n        optional_parameters = {'name': 'name', 'imdb_id': 'imdbId', 'zap2it_id': 'zap2itId'}\n\n        query_string = utils.query_param_string_from_option_args(optional_parameters, arguments)\n\n        raw_response = requests_util.run_request('get', '%s%s?%s' % (self.API_BASE_URL, '/search/series',\n                                                                     query_string),\n                                                 headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_series_actors(self, series_id):\n\n        raw_response = requests_util.run_request('get', self.API_BASE_URL + '/series/%d/actors' % series_id,\n                                                 headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)", "response": "Returns the information on the actors of a particular series given its TheTVDB id."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves all episodes for a particular series given its TheTVDB id. It retrieves a maximum of 100 results per page. :param series_id: The TheTVDB id of the series. :param page: The page number. If none is provided, 1 is used by default. :return: a python dictionary with either the result of the search or an error from TheTVDB.", "response": "def get_series_episodes(self, series_id, page=1):\n        \"\"\"\n        Retrieves all episodes for a particular series given its TheTVDB id. It retrieves a maximum of 100 results per\n        page.\n\n        :param series_id: The TheTVDB id of the series.\n        :param page: The page number. If none is provided, 1 is used by default.\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        raw_response = requests_util.run_request('get', self.API_BASE_URL + '/series/%d/episodes?page=%d' %\n                                                 (series_id, page), headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_series_episodes(self, series_id, episode_number=None, aired_season=None, aired_episode=None,\n                            dvd_season=None, dvd_episode=None, imdb_id=None, page=1):\n\n        \"\"\"\n        Retrieves all episodes for a particular series given its TheTVDB and filtered by additional optional details.\n\n        :param series_id: The TheTVDB id of the series.\n        :param episode_number: The optional absolute episode number.\n        :param aired_season: The optional aired season number.\n        :param aired_episode: The optional aired episode number.\n        :param dvd_season: The optional DVD season number.\n        :param dvd_episode: The optional DVD episode number.\n        :param imdb_id: The optional IMDB Id of the series.\n        :param page: The page number. If none is provided, 1 is used by default.\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        arguments = locals()\n        optional_parameters = {'episode_number': 'absoluteNumber', 'aired_season': 'airedSeason',\n                               'aired_episode': 'airedEpisode', 'dvd_season': 'dvdSeason', 'dvd_episode': 'dvdEpisode',\n                               'imdb_id': 'imdbId', 'page': 'page'}\n\n        query_string = utils.query_param_string_from_option_args(optional_parameters, arguments)\n\n        raw_response = requests_util.run_request('get', self.API_BASE_URL + '/series/%d/episodes/query?%s' %\n                                                 (series_id, query_string), headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)", "response": "This method returns all the episodes for a particular series given its TheTVDB and filtered by optional details."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve the url to images (posters, fanart) for the series, seasons and episodes of a series given its TheTVDB id and filtered by additional parameters. :param series_id: The TheTVDB id of the series. :param image_type: The optional type of image: posters, fanart, thumbnail, etc. :param resolution: The optional resolution: i.e. 1280x1024 :param sub_key: The optional subkey: graphical, text. :return: a python dictionary with either the result of the search or an error from TheTVDB.", "response": "def get_series_images(self, series_id, image_type=None, resolution=None, sub_key=None):\n        \"\"\"\n        Retrieves the url to images (posters, fanart) for the series, seasons and episodes of a series given its\n        TheTVDB id and filtered by additional parameters.\n\n        :param series_id: The TheTVDB id of the series.\n        :param image_type: The optional type of image: posters, fanart, thumbnail, etc.\n        :param resolution: The optional resolution: i.e. 1280x1024\n        :param sub_key: The optional subkey: graphical, text.\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        arguments = locals()\n        optional_parameters = {'image_type': 'keyType', 'resolution': 'resolution', 'sub_key': 'subKey'}\n\n        query_string = utils.query_param_string_from_option_args(optional_parameters, arguments)\n\n        if len(query_string):\n\n            raw_response = requests_util.run_request('get', self.API_BASE_URL + '/series/%d/images/query?%s' %\n                                                     (series_id, query_string), headers=self.__get_header_with_auth())\n            return self.parse_raw_response(raw_response)\n        else:\n            return self.__get_series_images(series_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_updated(self, from_time, to_time=None):\n\n        arguments = locals()\n        optional_parameters = {'to_time': 'toTime'}\n\n        query_string = 'fromTime=%s&%s' % (from_time,\n                                           utils.query_param_string_from_option_args(optional_parameters, arguments))\n\n        raw_response = requests_util.run_request('get', self.API_BASE_URL + '/uodated/query?%s' % query_string,\n                                                 headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)", "response": "Returns a list of series that have changed on TheTVDB since a provided from time parameter and optionally to an optional to time parameter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving information about the user currently using the API.", "response": "def get_user(self):\n        \"\"\"\n        Retrieves information about the user currently using the api.\n\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        return self.parse_raw_response(requests_util.run_request('get', self.API_BASE_URL + '/user',\n                                                                 headers=self.__get_header_with_auth()))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user_favorites(self):\n\n        return self.parse_raw_response(requests_util.run_request('get', self.API_BASE_URL + '/user/favorites',\n                                                                 headers=self.__get_header_with_auth()))", "response": "Retrieves the list of tv series the current user has flagged as favorite."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete the user s favorites list of the current user.", "response": "def delete_user_favorite(self, series_id):\n        \"\"\"\n        Deletes the series of the provided id from the favorites list of the current user.\n\n        :param series_id: The TheTVDB id of the series.\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        return self.parse_raw_response(requests_util.run_request('delete',\n                                                                 self.API_BASE_URL + '/user/favorites/%d' % series_id,\n                                                                 headers=self.__get_header_with_auth()))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __get_user_ratings(self):\n\n        return self.parse_raw_response(requests_util.run_request('get', self.API_BASE_URL + '/user/ratings',\n                                                                 headers=self.__get_header_with_auth()))", "response": "Returns a list of the ratings provided by the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user_ratings(self, item_type=None):\n\n        if item_type:\n            query_string = 'itemType=%s' % item_type\n\n            return self.parse_raw_response(\n                requests_util.run_request('get', self.API_BASE_URL + '/user/ratings/qeury?%s' % query_string,\n                                          headers=self.__get_header_with_auth()))\n        else:\n            return self.__get_user_ratings()", "response": "Returns a list of the ratings for the type of item provided for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_user_rating(self, item_type, item_id, item_rating):\n\n        raw_response = requests_util.run_request('put',\n                                                 self.API_BASE_URL + '/user/ratings/%s/%d/%d' %\n                                                 (item_type, item_id, item_rating),\n                                                 headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)", "response": "Adds the rating for the item indicated for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes the user rating of the current user.", "response": "def delete_user_rating(self, item_type, item_id):\n        \"\"\"\n        Deletes from the list of rating of the current user, the rating provided for the specified element type.\n\n        :param item_type: One of: series, episode, banner.\n        :param item_id: The TheTVDB Id of the item.\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        raw_response = requests_util.run_request('delete',\n                                                 self.API_BASE_URL + '/user/ratings/%s/%d' %\n                                                 (item_type, item_id), headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the full information of the episode with the given id.", "response": "def get_episode(self, episode_id):\n        \"\"\"\n        Returns the full information of the episode belonging to the Id provided.\n\n        :param episode_id: The TheTVDB id of the episode.\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        raw_response = requests_util.run_request('get', self.API_BASE_URL + '/episodes/%d' % episode_id,\n                                                 headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of all language options available in TheTVDB.", "response": "def get_languages(self):\n        \"\"\"\n        Returns a list of all language options available in TheTVDB.\n\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        raw_response = requests_util.run_request('get', self.API_BASE_URL + '/languages',\n                                                 headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves information about the language of the given id.", "response": "def get_language(self, language_id):\n        \"\"\"\n        Retrieves information about the language of the given id.\n\n        :param language_id: The TheTVDB Id of the language.\n        :return: a python dictionary with either the result of the search or an error from TheTVDB.\n        \"\"\"\n\n        raw_response = requests_util.run_request('get', self.API_BASE_URL + '/languages/%d' % language_id,\n                                                 headers=self.__get_header_with_auth())\n\n        return self.parse_raw_response(raw_response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nestablishes API key and password associated with APIv1 commands.", "response": "def SetCredentials(api_key,api_passwd):\n\t\"\"\"Establish API key and password associated with APIv1 commands.\"\"\"\n\tglobal V1_API_KEY\n\tglobal V1_API_PASSWD\n\tglobal _V1_ENABLED\n\t_V1_ENABLED = True\n\tV1_API_KEY = api_key\n\tV1_API_PASSWD = api_passwd"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalize(A, axis=None, inplace=False):\n    if not inplace:\n        A = A.copy()\n\n    A += np.finfo(float).eps\n    Asum = A.sum(axis)\n    if axis and A.ndim > 1:\n        # Make sure we don't divide by zero.\n        Asum[Asum == 0] = 1\n        shape = list(A.shape)\n        shape[axis] = 1\n        Asum.shape = shape\n    A /= Asum\n    return A", "response": "Normalizes the input array so that it sums to 1 along the prescribed axis."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a p - state transition matrix and h - state matrices to the full transation matrix", "response": "def ph2full(ptrans, htrans):\n    \"\"\"\n    Convert a p-state transition matrix and h-state matrices to the full transation matrix\n\n    The full transmat hase N=n_pstates*n_hstates states\n    \"\"\"\n    n_pstates = len(ptrans)\n    n_hstates = len(htrans[0, 0])\n    N = n_pstates * n_hstates\n    trans = np.zeros((N, N))\n    for pidx in range(n_pstates):\n        for hidx in range(n_hstates):\n            trans[pidx * n_hstates + hidx] = (ptrans[pidx, :, np.newaxis] * htrans[pidx, :, hidx]).flatten()\n\n    return trans"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a full transmat to the respective p - state and h - state transmats", "response": "def full2ph(trans, n_pstates):\n    \"\"\"\n    Convert a full transmat to the respective p-state and h-state transmats\n    \"\"\"\n    n_hstates = len(trans) / n_pstates\n\n    htrans = np.zeros((n_pstates, n_pstates, n_hstates, n_hstates))\n    for pidx1, pidx2 in product(range(n_pstates), range(n_pstates)):\n        idx1 = pidx1 * n_hstates\n        idx2 = pidx2 * n_hstates\n        htrans[pidx1, pidx2] = trans[idx1:idx1 + n_hstates, idx2:idx2 + n_hstates]\n\n    ptrans = normalize(htrans.sum(axis=-1).sum(axis=-1), axis=1)\n    htrans = normalize(htrans, axis=3)\n\n    return ptrans, htrans"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gen_stochastic_matrix(size, random_state=None):\n    if not type(size) is tuple:\n        size = (1, size)\n\n    assert len(size) == 2\n\n    n = random_state.uniform(size=(size[0], size[1] - 1))\n    n = np.concatenate([np.zeros((size[0], 1)), n, np.ones((size[0], 1))], axis=1)\n\n    A = np.diff(np.sort(n))\n    return A.squeeze()", "response": "Generate a unfiformly - random stochastic array or matrix"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef steadystate(A, max_iter=100):\n    P = np.linalg.matrix_power(A, max_iter)\n\n    # Determine the unique rows in A\n    v = []\n    for i in range(len(P)):\n        if not np.any([np.allclose(P[i], vi, ) for vi in v]):\n            v.append(P[i])\n\n    return normalize(np.sum(v, axis=0))", "response": "Empirically determine the steady state probabilities from a stochastic matrix A"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pipe():\n    r, w = os.pipe()\n    return File.fromfd(r, 'rb'), File.fromfd(w, 'wb')", "response": "create an inter - process communication pipe"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_id_head(self):\n        '''\n        Returns the id  of the target that is set as \"head\"\n        @rtype: string\n        @return: the target id (or None) of the head target\n        '''\n        id_head = None\n        for target_node in self:\n            if target_node.is_head():\n                id_head = target_node.get_id()\n                break\n        return id_head", "response": "Returns the id of the head target that is set as head target\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a new target to the span with the specified id", "response": "def add_target_id(self,this_id):\n        \"\"\"\n        Adds a new target to the span with the specified id\n        @type this_id: string\n        @param this_id: the id of the new target\n        \"\"\"\n        new_target = Ctarget()\n        new_target.set_id(this_id)\n        self.node.append(new_target.get_node())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_from_ids(self,list_ids):\n        for this_id in list_ids:\n            new_target = Ctarget()\n            new_target.set_id(this_id)\n            self.node.append(new_target.get_node())", "response": "Adds new targets to the span with the specified ids\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd new targets to the span that are defined in a list", "response": "def create_from_targets(self,list_targs):\n        \"\"\"\n        Adds new targets to the span that are defined in a list\n        @type list_targs: list\n        @param list_targs: list of Ctargets\n        \"\"\"\n        for this_target in list_targs:\n            self.node.append(this_target.get_node())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the statement object for the supplied identifier", "response": "def get_statement(self, statement_id):\n        \"\"\"\n        Returns the statement object for the supplied identifier\n        @type statement_id: string\n        @param statement_id: statement identifier\n        \"\"\"\n        if statement_id in self.idx:\n            return Cstatement(self.idx[statement_id], self.type)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a statement object to the layer.", "response": "def add_statement(self, statement_obj):\n        \"\"\"\n        Adds a statement object to the layer\n        @type statement_obj: L{Cstatement}\n        @param statement_obj: the statement object\n        \"\"\"\n        if statement_obj.get_id() in self.idx:\n            raise ValueError(\"Statement with id {} already exists!\"\n                             .format(statement_obj.get_id()))\n        self.node.append(statement_obj.get_node())\n        self.idx[statement_obj.get_id()] = statement_obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all available datacenters for the calling account.", "response": "def Datacenters(alias=None, session=None):\n\t\t\"\"\"Return all cloud locations available to the calling alias.\n\n\t\t>>> clc.v2.Datacenter.Datacenters(alias=None)\n\t\t[<clc.APIv2.datacenter.Datacenter instance at 0x101462fc8>, <clc.APIv2.datacenter.Datacenter instance at 0x101464320>]\n\n\t\t\"\"\"\n\t\tif not alias:  alias = clc.v2.Account.GetAlias(session=session)\n\n\t\tdatacenters = []\n\t\tfor r in clc.v2.API.Call('GET','datacenters/%s' % alias,{}, session=session):\n\t\t\tdatacenters.append(Datacenter(location=r['id'],name=r['name'],alias=alias,session=session))\n\n\t\treturn(datacenters)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns root group object for datacenter root group.", "response": "def RootGroup(self):\n\t\t\"\"\"Returns group object for datacenter root group.\n\n\t\t>>> clc.v2.Datacenter().RootGroup()\n\t\t<clc.APIv2.group.Group object at 0x105feacd0>\n\t\t>>> print _\n\t\tWA1 Hardware\n\n\t\t\"\"\"\n\n\t\treturn(clc.v2.Group(id=self.root_group_id,alias=self.alias,session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of email addresses for a given key.", "response": "def addresses_for_key(gpg, key):\r\n    \"\"\"\r\n    Takes a key and extracts the email addresses for it.\r\n    \"\"\"\r\n    return [address.split(\"<\")[-1].strip(\">\")\r\n            for address in gpg.list_keys().key_map[key['fingerprint']][\"uids\"]\r\n            if address]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef L(g,i):\n    g1 = g&(2**i)\n    if i:\n        n = Lwidth(i)\n        Ln = L(g,i-1)\n        if g1:\n            return Ln<<(2*n)           | Ln<<n | Ln\n        else:\n            return int('1'*n,2)<<(2*n) | Ln<<n | Ln\n    else:\n        if g1:\n            return int('000',2)\n        else:\n            return int('100',2)", "response": "recursively constructs L line for g"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef H(g,i):\n    g1 = g&(2**i)\n    if i:\n        n = Hwidth(i)\n        i=i-1\n        Hn = H(g,i)\n        if g1:\n            return Hn<<(2*n)           | Hn<<n     | Hn\n        else:\n            return int('1'*n,2)<<(2*n) | L(g,i)<<n | Hn\n    else:\n        if g1:\n            return int('111',2)\n        else:\n            return int('101',2)", "response": "recursively constructs H line for g ; i = 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs implications and intents based on Hg and gw.", "response": "def UV_H(Hg,gw):\n    \"\"\"\n    Constructs implications and intents based on H\n    gw = g width\n    Hg = H(g), g is the binary coding of the attribute set\n    UV = all non-trivial (!V\u2282U) implications U->V with UuV closed; in ternary coding (1=V,2=U)\n    K = all closed sets\n    \"\"\"\n    lefts = set()\n    K = []\n    UV = []\n    p = Hwidth(gw)\n    pp = 2**p\n    while p:\n        pp = pp>>1\n        p = p-1\n        if Hg&pp:\n            y = istr(p,3,gw)\n            yy = y.replace('1','0')\n            if yy not in lefts: \n                if y.find('1') == -1:#y\u2208{0,2}^n\n                    K.append(y)\n                else:\n                    UV.append(y)\n                    lefts.add(yy)\n    return (UV,K)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs ternary implication coding for a single A - column tree.", "response": "def B012(t,i):\n    \"\"\"\n    Constructs ternary implication coding (0=not there, 2=U, 1=V)\n    t is B column position\n    i = |M|-1 to 0\n    \"\"\"\n    if not i:\n        return \"1\"\n    nA = Awidth(i)\n    nB = Bwidth(i)\n    nBB = nB + nA\n    if t < nB:\n        return \"0\"+B012(t,i-1)\n    elif t < nBB:\n        return \"1\"+A012(t-nB,i-1)\n    else:\n        return \"2\"+B012(t-nBB,i-1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef UV_B(Bg,gw):\n    UV = []\n    p = Bwidth(gw)\n    pp = 2**p\n    while p:\n        pp = pp>>1\n        p = p-1\n        if Bg&pp:\n            uv = B012(p,gw-1)\n            UV.append(uv)\n    return UV", "response": "returns the implications UV based on Bg and gw"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the size of the implication basis for the size of the implication basis.", "response": "def omega(imps):\n    \"\"\"\n    Calculates a measure for the size of the implication basis: \\sum |U||V|\n    \"\"\"\n    if isinstance(imps,v_Us_dict):\n        return sum([omega(V) for U,V in imps.items()])#|V|=1\n    if isinstance(imps,list):\n        return sum([omega(x) for x in imps])\n    if isinstance(imps,str):\n        #imps = due[-1]\n        try:\n            U,V = imps.split(\"->\")\n            Us = U.split(\",\") if \",\" in U else U.split()\n            Vs = V.split(\",\") if \",\" in V else V.split()\n            res = len(Us)*len(Vs)\n            return res\n        except:\n            return 0\n    if isinstance(imps,int):\n        b=bin(imps)[2:]\n        res = len([x for x in b if x=='1'])\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef respects(g,imp):\n    if isinstance(g,str):\n        g = int(g,2)\n    if isinstance(imp,int):\n        imp = istr(imp,3,g.bit_length())\n    V = int(imp.replace('1','2').replace('2','1'),2)\n    U = int(imp.replace('1','0').replace('2','1'),2)\n    ginU = U&g == U\n    ginV = V&g == V\n    return not ginU or ginV", "response": "Returns True if g and imp are equal."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconstruct the LL context", "response": "def LL(n):\n    \"\"\"constructs the LL context\"\"\"\n    if (n<=0):return Context('0')\n    else:\n        LL1=LL(n-1)\n        r1 = C1(3**(n-1),2**(n-1)) - LL1 - LL1\n        r2 = LL1 - LL1 - LL1\n        return r1 + r2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef HH(n):\n    if (n<=0):return Context('1')\n    else:\n        LL1=LL(n-1)\n        HH1=HH(n-1)\n        r1 = C1(3**(n-1),2**(n-1)) - LL1 - HH1\n        r2 = HH1 - HH1 - HH1\n        return r1 + r2", "response": "constructs the HH context"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs the AA context", "response": "def AA(n):\n    \"\"\"constructs the AA context\"\"\"\n    if (n<=1):return Context('10\\n00')\n    else:\n        AA1=AA(n-1)\n        r1 = C1(2**(n-1),2**(n-1)) - AA1\n        r2 = AA1 - AA1\n        return r1 + r2"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs the BB context", "response": "def BB(n):\n    \"\"\"constructs the BB context\"\"\"\n    if (n<=1):return Context('0\\n1')\n    else:\n        BB1=BB(n-1)\n        AA1=AA(n-1)\n        r1 = C1((n-1)*2**(n-2),2**(n-1)) - AA1 - BB1\n        r2 = BB1 - C1(2**(n-1),2**(n-1)) - BB1;\n        return r1 + r2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the Koenig of the current set of resources.", "response": "def koenig(self):\n        \"\"\"\n        This needs to be L = contextg.v_Us_B()\n        \"\"\"\n        L = self\n        Y = L - (L*L)\n        while True:\n            Ybar = Y + ~Y\n            take = L - Ybar\n            if not len(take):\n                return Y\n            else:\n                ZZ = list(set(take)-set(Y))#use significant which is not in Y\n                if len(ZZ) > 0:\n                    v = ZZ[0]\n                    z=(v,take[v][0])\n                else:\n                    z = next(take.flatten())\n                Yzgen = Y**z\n                Y = (Y - Yzgen) + z"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef column(self, i): \n        return ''.join([str(digitat2(r,i)) for r in self])", "response": "from right return the column name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef UV_H(self):\n        h = reduce(lambda x,y:x&y,(H(g,self.width-1) for g in self))\n        return UV_H(h, self.width)", "response": "This function returns the H of the UV and UuV sets."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef UV_B(self):\n        h = reduce(lambda x,y:x&y,(B(g,self.width-1) for g in self))\n        return UV_B(h, self.width)", "response": "returns UV = all respected Ux in ternary coding"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the implications v : Us based on B", "response": "def v_Us_B(self):\n        \"\"\"\n        returns the implications {v:Us} based on B\n        This is L=\u222a min L_i in [1]_\n        \"\"\"\n        Bg = reduce(lambda x,y:x&y,(B(g,self.width-1) for g in self))\n        gw = self.width\n        return v_Us_dict(Bg, gw)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef greenlet(func, args=(), kwargs=None):\n    if args or kwargs:\n        def target():\n            return func(*args, **(kwargs or {}))\n    else:\n        target = func\n    return compat.greenlet(target, state.mainloop)", "response": "create a new greenlet from a function and arguments"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef schedule(target=None, args=(), kwargs=None):\n    if target is None:\n        def decorator(target):\n            return schedule(target, args=args, kwargs=kwargs)\n        return decorator\n    if isinstance(target, compat.greenlet) or target is compat.main_greenlet:\n        glet = target\n    else:\n        glet = greenlet(target, args, kwargs)\n    state.paused.append(glet)\n    return target", "response": "add a greenlet to the scheduler"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a greenlet to be run at a set time", "response": "def schedule_at(unixtime, target=None, args=(), kwargs=None):\n    \"\"\"insert a greenlet into the scheduler to be run at a set time\n\n    If provided a function, it is wrapped in a new greenlet\n\n    :param unixtime:\n        the unix timestamp at which the new greenlet should be started\n    :type unixtime: int or float\n    :param target: what to schedule\n    :type target: function or greenlet\n    :param args:\n        arguments for the function (only used if ``target`` is a function)\n    :type args: tuple\n    :param kwargs:\n        keyword arguments for the function (only used if ``target`` is a\n        function)\n    :type kwargs: dict or None\n\n    :returns: the ``target`` argument\n\n    This function can also be used as a decorator:\n\n    >>> @schedule_at(1296423834)\n    >>> def f():\n    ...     print 'hello from f'\n\n    and args/kwargs can also be preloaded:\n\n    >>> @schedule_at(1296423834, args=('world',))\n    >>> def f(name):\n    ...     print 'hello %s' % name\n    \"\"\"\n    if target is None:\n        def decorator(target):\n            return schedule_at(unixtime, target, args=args, kwargs=kwargs)\n        return decorator\n    if isinstance(target, compat.greenlet) or target is compat.main_greenlet:\n        glet = target\n    else:\n        glet = greenlet(target, args, kwargs)\n    state.timed_paused.insert(unixtime, glet)\n    return target"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninserting a greenlet into the scheduler to run after a set time", "response": "def schedule_in(secs, target=None, args=(), kwargs=None):\n    \"\"\"insert a greenlet into the scheduler to run after a set time\n\n    If provided a function, it is wrapped in a new greenlet\n\n    :param secs: the number of seconds to wait before running the target\n    :type unixtime: int or float\n    :param target: what to schedule\n    :type target: function or greenlet\n    :param args:\n        arguments for the function (only used if ``target`` is a function)\n    :type args: tuple\n    :param kwargs:\n        keyword arguments for the function (only used if ``target`` is a\n        function)\n    :type kwargs: dict or None\n\n    :returns: the ``target`` argument\n\n    This function can also be used as a decorator:\n\n    >>> @schedule_in(30)\n    >>> def f():\n    ...     print 'hello from f'\n\n    and args/kwargs can also be preloaded:\n\n    >>> @schedule_in(30, args=('world',))\n    >>> def f(name):\n    ...     print 'hello %s' % name\n    \"\"\"\n    return schedule_at(time.time() + secs, target, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef schedule_recurring(interval, target=None, maxtimes=0, starting_at=0,\n                       args=(), kwargs=None):\n    \"\"\"insert a greenlet into the scheduler to run regularly at an interval\n\n    If provided a function, it is wrapped in a new greenlet\n\n    :param interval: the number of seconds between invocations\n    :type interval: int or float\n    :param target: what to schedule\n    :type target: function or greenlet\n    :param maxtimes: if provided, do not run more than ``maxtimes`` iterations\n    :type maxtimes: int\n    :param starting_at:\n        the unix timestamp of when to schedule it for the first time (defaults\n        to the time of the ``schedule_recurring`` call)\n    :type starting_at: int or float\n    :param args: arguments for the function\n    :type args: tuple\n    :param kwargs: keyword arguments for the function\n    :type kwargs: dict or None\n\n    :returns: the ``target`` argument\n\n    This function can also be used as a decorator:\n\n    >>> @schedule_recurring(30)\n    >>> def f():\n    ...     print \"the regular 'hello' from f\"\n\n    and args/kwargs can also be preloaded:\n\n    >>> @schedule_recurring(30, args=('world',))\n    >>> def f(name):\n    ...     print 'the regular hello %s' % name\n    \"\"\"\n    starting_at = starting_at or time.time()\n\n    if target is None:\n        def decorator(target):\n            return schedule_recurring(\n                interval, target, maxtimes, starting_at, args, kwargs)\n        return decorator\n\n    func = target\n    if isinstance(target, compat.greenlet) or target is compat.main_greenlet:\n        if target.dead:\n            raise TypeError(\"can't schedule a dead greenlet\")\n        func = target.run\n\n    def run_and_schedule_one(tstamp, count):\n        # pass in the time scheduled instead of just checking\n        # time.time() so that delays don't add up\n        if not maxtimes or count < maxtimes:\n            tstamp += interval\n            func(*args, **(kwargs or {}))\n            schedule_at(tstamp, run_and_schedule_one,\n                        args=(tstamp, count + 1))\n\n    firstrun = starting_at + interval\n    schedule_at(firstrun, run_and_schedule_one, args=(firstrun, 0))\n\n    return target", "response": "schedule a greenlet to run at a specific interval"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nschedules a greenlet to have an exception raised in the target immediately", "response": "def schedule_exception(exception, target):\n    \"\"\"schedule a greenlet to have an exception raised in it immediately\n\n    :param exception: the exception to raise in the greenlet\n    :type exception: Exception\n    :param target: the greenlet that should receive the exception\n    :type target: greenlet\n    \"\"\"\n    if not isinstance(target, compat.greenlet):\n        raise TypeError(\"can only schedule exceptions for greenlets\")\n    if target.dead:\n        raise ValueError(\"can't send exceptions to a dead greenlet\")\n    schedule(target)\n    state.to_raise[target] = exception"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nschedule a greenlet to have an exception raised at a unix timestamp", "response": "def schedule_exception_at(unixtime, exception, target):\n    \"\"\"schedule a greenlet to have an exception raised at a unix timestamp\n\n    :param unixtime: when to raise the exception in the target\n    :type unixtime: int or float\n    :param exception: the exception to raise in the greenlet\n    :type exception: Exception\n    :param target: the greenlet that should receive the exception\n    :type target: greenlet\n    \"\"\"\n    if not isinstance(target, compat.greenlet):\n        raise TypeError(\"can only schedule exceptions for greenlets\")\n    if target.dead:\n        raise ValueError(\"can't send exceptions to a dead greenlet\")\n    schedule_at(unixtime, target)\n    state.to_raise[target] = exception"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef schedule_exception_in(secs, exception, target):\n    schedule_exception_at(time.time() + secs, exception, target)", "response": "schedule a greenlet receive an exception after a number of seconds"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nschedule a greenlet to be stopped immediately", "response": "def end(target):\n    \"\"\"schedule a greenlet to be stopped immediately\n\n    :param target: the greenlet to end\n    :type target: greenlet\n    \"\"\"\n    if not isinstance(target, compat.greenlet):\n        raise TypeError(\"argument must be a greenlet\")\n    if not target.dead:\n        schedule(target)\n        state.to_raise[target] = compat.GreenletExit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns all the exception handlers that are registered with the given exception class and traceback object", "response": "def handle_exception(klass, exc, tb, coro=None):\n    \"\"\"run all the registered exception handlers\n\n    the first 3 arguments to this function match the output of\n    ``sys.exc_info()``\n\n    :param klass: the exception klass\n    :type klass: type\n    :param exc: the exception instance\n    :type exc: Exception\n    :param tb: the traceback object\n    :type tb: Traceback\n    :param coro:\n        behave as though the exception occurred in this coroutine (defaults to\n        the current coroutine)\n    :type coro: greenlet\n\n    exception handlers run would be all those added with\n    :func:`global_exception_handler`, and any added for the relevant coroutine\n    with :func:`local_exception_handler`.\n    \"\"\"\n    if coro is None:\n        coro = compat.getcurrent()\n\n    replacement = []\n    for weak in state.local_exception_handlers.get(coro, ()):\n        func = weak()\n        if func is None:\n            continue\n\n        try:\n            func(klass, exc, tb)\n        except Exception:\n            continue\n\n        replacement.append(weak)\n\n    if replacement:\n        state.local_exception_handlers[coro][:] = replacement\n\n    replacement = []\n    for weak in state.global_exception_handlers:\n        func = weak()\n        if func is None:\n            continue\n\n        try:\n            func(klass, exc, tb)\n        except Exception:\n            continue\n\n        replacement.append(weak)\n\n    state.global_exception_handlers[:] = replacement"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a callback for when an exception goes uncaught in any greenlet", "response": "def global_exception_handler(handler):\n    \"\"\"add a callback for when an exception goes uncaught in any greenlet\n\n    :param handler:\n        the callback function. must be a function taking 3 arguments:\n\n        - ``klass`` the exception class\n        - ``exc`` the exception instance\n        - ``tb`` the traceback object\n    :type handler: function\n\n    Note also that the callback is only held by a weakref, so if all other refs\n    to the function are lost it will stop handling greenlets' exceptions\n    \"\"\"\n    if not hasattr(handler, \"__call__\"):\n        raise TypeError(\"exception handlers must be callable\")\n    log.info(\"setting a new global exception handler\")\n\n    state.global_exception_handlers.append(weakref.ref(handler))\n\n    return handler"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove a callback from the list of global exception handlers", "response": "def remove_global_exception_handler(handler):\n    \"\"\"remove a callback from the list of global exception handlers\n\n    :param handler:\n        the callback, previously added via :func:`global_exception_handler`,\n        to remove\n    :type handler: function\n\n    :returns: bool, whether the handler was found (and therefore removed)\n    \"\"\"\n    for i, cb in enumerate(state.global_exception_handlers):\n        cb = cb()\n        if cb is not None and cb is handler:\n            state.global_exception_handlers.pop(i)\n            log.info(\"removing a global exception handler\")\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef local_exception_handler(handler=None, coro=None):\n    if handler is None:\n        return lambda h: local_exception_handler(h, coro)\n\n    if not hasattr(handler, \"__call__\"):\n        raise TypeError(\"exception handlers must be callable\")\n\n    if coro is None:\n        coro = compat.getcurrent()\n\n    log.info(\"setting a new coroutine local exception handler\")\n\n    state.local_exception_handlers.setdefault(coro, []).append(\n        weakref.ref(handler))\n\n    return handler", "response": "add a callback function for when an exception occurs in a particular coroutine"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a callback from the list of exception handlers for a coroutine", "response": "def remove_local_exception_handler(handler, coro=None):\n    \"\"\"remove a callback from the list of exception handlers for a coroutine\n\n    :param handler: the callback to remove\n    :type handler: function\n    :param coro: the coroutine for which to remove the local handler\n    :type coro: greenlet\n\n    :returns: bool, whether the handler was found (and therefore removed)\n    \"\"\"\n    if coro is None:\n        coro = compat.getcurrent()\n\n    for i, cb in enumerate(state.local_exception_handlers.get(coro, [])):\n        cb = cb()\n        if cb is not None and cb is handler:\n            state.local_exception_handlers[coro].pop(i)\n            log.info(\"removing a coroutine local exception handler\")\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a callback to run in every switch between coroutines", "response": "def global_hook(handler):\n    \"\"\"add a callback to run in every switch between coroutines\n\n    :param handler:\n        the callback function, must be a function taking 2 arguments:\n\n        - the greenlet being switched from\n        - the greenlet being switched to\n\n        be aware that only a weak reference to this function will be held.\n    :type handler: function\n    \"\"\"\n    if not hasattr(handler, \"__call__\"):\n        raise TypeError(\"trace hooks must be callable\")\n\n    log.info(\"setting a new global hook callback\")\n    state.global_hooks.append(weakref.ref(handler))\n\n    return handler"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_global_hook(handler):\n    for i, cb in enumerate(state.global_hooks):\n        cb = cb()\n        if cb is not None and cb is handler:\n            state.global_hooks.pop(i)\n            log.info(\"removing a global hook callback\")\n            return True\n    return False", "response": "remove a callback from the list of global hooks"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef local_incoming_hook(handler=None, coro=None):\n    if handler is None:\n        return lambda h: local_incoming_hook(h, coro)\n\n    if not hasattr(handler, \"__call__\"):\n        raise TypeError(\"trace hooks must be callable\")\n\n    if coro is None:\n        coro = compat.getcurrent()\n\n    log.info(\"setting a coroutine incoming local hook callback\")\n\n    state.local_to_hooks.setdefault(coro, []).append(\n        weakref.ref(handler))\n\n    return handler", "response": "add a callback to run every time a greenlet is about to be switched into the local_incoming_hooks list"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_local_incoming_hook(handler, coro=None):\n    if coro is None:\n        coro = compat.getcurrent()\n\n    for i, cb in enumerate(state.local_to_hooks.get(coro, [])):\n        cb = cb()\n        if cb is not None and cb is handler:\n            log.info(\"removing a coroutine incoming local hook callback\")\n            state.local_to_hooks[coro].pop(i)\n            return True\n    return False", "response": "remove a callback from the incoming hooks for a particular coroutine"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a callback to run every time a greenlet is switched away from another greenlet", "response": "def local_outgoing_hook(handler=None, coro=None):\n    \"\"\"add a callback to run every time a greenlet is switched away from\n\n    :param handler:\n        the callback function, must be a function taking 2 arguments:\n\n        - an integer indicating whether it is being called as an incoming (1)\n          hook or as an outgoing (2) hook (in this case it will always be 2).\n        - the coroutine being switched from (in this case it is the one\n          indicated by the ``coro`` argument to ``local_outgoing_hook``.\n\n        Be aware that only a weak reference to this function will be held.\n    :type handler: function\n    :param coro:\n        the coroutine for which to apply the trace hook (defaults to current)\n    :type coro: greenlet\n    \"\"\"\n    if handler is None:\n        return lambda h: local_outgoing_hook(h, coro)\n\n    if not hasattr(handler, \"__call__\"):\n        raise TypeError(\"trace hooks must be callable\")\n\n    if coro is None:\n        coro = compat.getcurrent()\n\n    log.info(\"setting a coroutine local outgoing hook callback\")\n\n    state.local_from_hooks.setdefault(coro, []).append(\n        weakref.ref(handler))\n\n    return handler"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving a callback from the outgoing hooks for a particular coroutine", "response": "def remove_local_outgoing_hook(handler, coro=None):\n    \"\"\"remove a callback from the outgoing hooks for a particular coro\n\n    :param handler: the callback previously added via local_outgoing_hook\n    :type handler: function\n    :param coro: the coroutine for which the hook should be removed\n    :type coro: greenlet\n\n    :returns: bool, whether the handler was found and removed\n    \"\"\"\n    if coro is None:\n        coro = compat.getcurrent()\n\n    for i, cb in enumerate(state.local_from_hooks.get(coro, [])):\n        cb = cb()\n        if cb is not None and cb is handler:\n            log.info(\"removing a coroutine outgoing local hook callback\")\n            state.local_from_hooks[coro].pop(i)\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_ignore_interrupts(flag=True):\n    log.info(\"setting ignore_interrupts to %r\" % flag)\n    state.ignore_interrupts = bool(flag)", "response": "turn off EINTR - raised from emulated syscalls on interruption by signals\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace the scheduler s poller throwing away any pre - existing state", "response": "def reset_poller(poll=None):\n    \"\"\"replace the scheduler's poller, throwing away any pre-existing state\n\n    this is only really a good idea in the new child process after a fork(2).\n    \"\"\"\n    state.poller = poll or poller.best()\n    log.info(\"resetting fd poller, using %s\" % type(state.poller).__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute v1 API call.", "response": "def Call(method,url,payload,silent=False,hide_errors=[],session=None,recursion_cnt=0,debug=False):\n\t\t\"\"\"Execute v1 API call.\n\n\t\t:param url: URL paths associated with the API call\n\t\t:param payload: dict containing all parameters to submit with POST call\n\t\t:param hide_errors: list of API error codes to ignore.  These are not http error codes but returned from the API itself\n\t\t:param recursion_cnt: recursion counter.  This call is recursed if we experience a transient error\n\n\t\t:returns: decoded API json result\n\t\t\"\"\"\n\t\tif not clc._LOGIN_COOKIE_V1:  API._Login()\n\n\t\tif session is None:\n\t\t    session = clc._REQUESTS_SESSION\n\n\t\tsession.headers.update({'content-type': 'application/json'})\n\n\t\tr = session.request(method,\"%s%s/JSON\" % (clc.defaults.ENDPOINT_URL_V1,url),\n                             params=payload,\n                             cookies=clc._LOGIN_COOKIE_V1,\n                             verify=API._ResourcePath('clc/cacert.pem'))\n\n\t\tif debug:\n\t\t\tAPI._DebugRequest(request=requests.Request(method,\"%s%s/JSON\" % (clc.defaults.ENDPOINT_URL_V1,url),\n                              data=payload,headers=session.headers).prepare(),response=r)\n\n\t\ttry:\n\t\t\tif int(r.json()['StatusCode']) == 0:  \n\t\t\t\tif clc.args and not silent:  clc.v1.output.Status('SUCCESS',2,'%s' % (r.json()['Message']))\n\t\t\t\treturn(r.json())\n\t\t\telif int(r.json()['StatusCode']) in hide_errors:\n\t\t\t\treturn(r.json())\n\t\t\telif int(r.json()['StatusCode']) == 2:  \n\t\t\t\t# Account is deleted\n\t\t\t\t#raise clc.v1.Account.eletedException(r.json()['Message'])\n\t\t\t\tif clc.args and not silent:  clc.v1.output.Status('ERROR',3,'%s' % (r.json()['Message']))\n\t\t\t\traise Exception(r.json()['Message'])\n\t\t\telif int(r.json()['StatusCode']) == 5:  \n\t\t\t\t# Account or datacenter does not exist\n\t\t\t\traise clc.v1.AccountDoesNotExistException(r.json()['Message'])\n\t\t\telif int(r.json()['StatusCode']) == 100 and recursion_cnt<2:  \n\t\t\t\t# Not logged in - this is a transient failure\n\t\t\t\tclc._LOGIN_COOKIE_V1 = False\n\t\t\t\treturn(clc.v1.API.Call(method,url,payload,silent,hide_errors,recursion_cnt+1))\n\t\t\telif int(r.json()['StatusCode']) == 100:  \n\t\t\t\t# Not logged in - this keeps recurring - bail\n\t\t\t\traise clc.v1.AccountLoginException(r.json()['Message'])\n\t\t\telse:\n\t\t\t\tif clc.args and (not hide_errors or not silent):  clc.v1.output.Status('ERROR',3,'Error calling %s.   Status code %s.  %s' % (url,r.json()['StatusCode'],r.json()['Message']))\n\t\t\t\traise Exception('Error calling %s.   Status code %s.  %s' % (url,r.json()['StatusCode'],r.json()['Message']))\n\t\t#except clc.v1.Account.eletedException, clc.v1.Account.oginException:\n\t\texcept clc.CLCException:\n\t\t\traise\n\t\texcept:\n\t\t\tif clc.args and (not hide_errors or not silent):  clc.v1.output.Status('ERROR',3,'Error calling %s.  Server response %s' % (url,r.status_code))\n\t\t\t#print \"Request:  %s %s  params=%s\" % (method,\"%s%s/JSON\" % (clc.defaults.ENDPOINT_URL_V1,url),payload)\n\t\t\t#print \"Response: %s\" % (r.text)\n\t\t\t#print r.url\n\t\t\t#print url\n\t\t\t#print payload\n\t\t\t#print r.text\n\t\t\traise Exception('Error calling %s.  Server response %s' % (url,r.status_code))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a iterative container (list, tuple), this function will process its contents and condense if necessary. It also has functionality to try to assure that the output has only one item in it if desired. If this is not the case, then it will return a 'default' in place of the output, if specified.", "response": "def process_output(output, *, condense=False, one=False, default=None,\n                   default_if_multiple=True, default_if_none=True):\n    \"\"\"\n    Taking a iterative container (list, tuple), this function will process its\n    contents and condense if necessary. It also has functionality to try to\n    assure that the output has only one item in it if desired. If this is not\n    the case, then it will return a 'default' in place of the output, if\n    specified.\n    \"\"\"\n    if condense:\n        output = list(set(output))\n\n    if one:\n        if len(output) > 1:\n            if default and default_if_multiple:\n                output = default\n            else:\n                return MULTIPLE\n        elif len(output) == 1:\n            output = output[0]\n        else:\n            if default and default_if_none:\n                return default\n            else:\n                return NONE\n\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assert_output(output, assert_equal):\n    sorted_output = sorted(output)\n    sorted_assert = sorted(assert_equal)\n    if sorted_output != sorted_assert:\n        raise ValueError(ASSERT_ERROR.format(sorted_output, sorted_assert))", "response": "Check that two outputs have the same contents as one another."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_dict_to_file(file_path, obj):\n    lines = []\n    for key, value in obj.items():\n        lines.append(key + ':' + repr(value) + '\\n')\n\n    with open(file_path, 'w+') as file:\n        file.writelines(lines)\n\n    return None", "response": "Write a dictionary of string keys to a file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a dictionary of strings from a file", "response": "def read_dict_from_file(file_path):\n    \"\"\"\n    Read a dictionary of strings from a file\n    \"\"\"\n    with open(file_path) as file:\n        lines = file.read().splitlines()\n\n    obj = {}\n    for line in lines:\n        key, value = line.split(':', maxsplit=1)\n        obj[key] = eval(value)\n\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nask the user to input something on the terminal level check their response and ask again if they didn t answer correctly", "response": "def get_input(prompt, check, *, redo_prompt=None, repeat_prompt=False):\n    \"\"\"\n    Ask the user to input something on the terminal level, check their response\n    and ask again if they didn't answer correctly\n    \"\"\"\n    if isinstance(check, str):\n        check = (check,)\n\n    to_join = []\n    for item in check:\n        if item:\n            to_join.append(str(item))\n        else:\n            to_join.append(\"''\")\n\n    prompt += \" [{}]: \".format('/'.join(to_join))\n\n    if repeat_prompt:\n        redo_prompt = prompt\n    elif not redo_prompt:\n        redo_prompt = \"Incorrect input, please choose from {}: \" \\\n                      \"\".format(str(check))\n\n    if callable(check):\n        def _checker(r): return check(r)\n    elif isinstance(check, tuple):\n        def _checker(r): return r in check\n    else:\n        raise ValueError(RESPONSES_ERROR.format(type(check)))\n\n    response = input(prompt)\n    while not _checker(response):\n        print(response, type(response))\n        response = input(redo_prompt if redo_prompt else prompt)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_choice(prompt, choices):\n    print()\n    checker = []\n    for offset, choice in enumerate(choices):\n        number = offset + 1\n        print(\"\\t{}): '{}'\\n\".format(number, choice))\n        checker.append(str(number))\n\n    response = get_input(prompt, tuple(checker) + ('',))\n    if not response:\n        print(\"Exiting...\")\n        exit()\n\n    offset = int(response) - 1\n    selected = choices[offset]\n\n    return selected", "response": "Asks for a single choice out of multiple items and a prompt to ask the user with the user with the specified choices."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a list of batches of commands that meet all the dependencies for each command in the tasks list.", "response": "def generateBatches(tasks, givens):\n    \"\"\"\n    A function to generate a batch of commands to run in a specific order as to\n    meet all the dependencies for each command. For example, the commands with\n    no dependencies are run first, and the commands with the most deep\n    dependencies are run last\n    \"\"\"\n    _removeGivensFromTasks(tasks, givens)\n\n    batches = []\n    while tasks:\n        batch = set()\n        for task, dependencies in tasks.items():\n            if not dependencies:\n                batch.add(task)\n\n        if not batch:\n            _batchErrorProcessing(tasks)\n\n        for task in batch:\n            del tasks[task]\n\n        for task, dependencies in tasks.items():\n            for item in batch:\n                if item in dependencies:\n                    tasks[task].remove(item)\n\n        batches.append(batch)\n    return batches"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef query_param_string_from_option_args(a2q_dict, args_dict):\n\n    name_value_pairs = dict()\n    for ak in a2q_dict.keys():\n        value = args_dict[ak]\n        if value != None:\n            name_value_pairs[a2q_dict[ak]] = str(value)\n\n    return urllib.urlencode(name_value_pairs)", "response": "This function takes a dictionary of arguments to query string parameters and returns a query string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_str_content(content):\n    if not isinstance(content, str):\n        content = str(content.decode())\n    return content", "response": "In python3 + requests. Response. content returns bytes instead of ol'good str."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Get(self,key):\n\n\t\tfor group in self.groups:\n\t\t\tif group.id.lower() == key.lower():  return(group)\n\t\t\telif group.name.lower() == key.lower():  return(group)\n\t\t\telif group.description.lower() == key.lower():  return(group)\n\n\t\traise(clc.CLCException(\"Group not found\"))", "response": "Get group by providing name ID description or other unique key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching group list by providing partial name ID description or other key.", "response": "def Search(self,key):\n\t\t\"\"\"Search group list by providing partial name, ID, description or other key.\n\n\t\t>>> clc.v2.Datacenter().Groups().Search(\"Default Group\")\n\t\t[<clc.APIv2.group.Group object at 0x1065b0f50>, <clc.APIv2.group.Group object at 0x1065b0d10>]\n\n\t\t\"\"\"\n\n\t\tresults = []\n\t\tfor group in self.groups:\n\t\t\tif group.id.lower().find(key.lower()) != -1:  results.append(group)\n\t\t\telif group.name.lower().find(key.lower()) != -1:  results.append(group)\n\t\t\telif group.description.lower().find(key.lower()) != -1:  results.append(group)\n\n\t\treturn(results)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GetAll(root_group_id,alias=None,session=None):\n\t\tif not alias:  alias = clc.v2.Account.GetAlias(session=session)\n\n\t\tgroups = []\n\t\tfor r in clc.v2.API.Call('GET','groups/%s/%s' % (alias,root_group_id),{}, session=session)['groups']:\n\t\t\tgroups.append(Group(id=r['id'],alias=alias,group_obj=r,session=session))\n\n\t\treturn(groups)", "response": "Gets a list of groups within a given account."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreloading the group object to synchronize with cloud representation.", "response": "def Refresh(self):\n\t\t\"\"\"Reloads the group object to synchronize with cloud representation.\n\n\t\t>>> clc.v2.Group(\"wa-1234\").Refresh()\n\n\t\t\"\"\"\n\n\t\tself.dirty = False\n\t\tself.data = clc.v2.API.Call('GET','groups/%s/%s' % (self.alias,self.id), session=self.session)\n\n\t\tself.data['changeInfo']['createdDate'] = clc.v2.time_utils.ZuluTSToSeconds(self.data['changeInfo']['createdDate'])\n\t\tself.data['changeInfo']['modifiedDate'] = clc.v2.time_utils.ZuluTSToSeconds(self.data['changeInfo']['modifiedDate'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Defaults(self,key):\n\n\t\tif not hasattr(self,'defaults'):\n\t\t\tself.defaults = clc.v2.API.Call('GET','groups/%s/%s/defaults' % (self.alias,self.id), session=self.session)\n\t\ttry:\n\t\t\treturn(self.defaults[key]['value'])\n\t\texcept:\n\t\t\treturn(None)", "response": "Returns default configurations for resources deployed to this group."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a Groups object containing all child groups.", "response": "def Subgroups(self):\n\t\t\"\"\"Returns a Groups object containing all child groups.\n\n\t\t>>> clc.v2.Group(\"wa1-4416\").Subgroups()\n\t\t<clc.APIv2.group.Groups object at 0x105fa27d0>\n\n\t\t\"\"\"\n\n\t\treturn(Groups(alias=self.alias,groups_lst=self.data['groups'],session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Servers(self):\n\n\t\treturn(clc.v2.Servers(\n\t\t\talias=self.alias,\n\t\t\tservers_lst=[obj['id'] for obj in self.data['links'] if obj['rel']=='server'],\n\t\t\tsession=self.session))", "response": "Returns a new Servers object containing all servers within the group."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new group.", "response": "def Create(self,name,description=None):\n\t\t\"\"\"Creates a new group\n\n\t\t>>> clc.v2.Datacenter(location=\"WA1\").RootGroup().Create(\"Test3\",\"Description3\")\n\t\t<clc.APIv2.group.Group object at 0x10cc76c90>\n\t\t>>> print _\n\t\tTest5\n\n\t\t\"\"\"\n\n\t\tif not description:  description = name\n\n\t\tr = clc.v2.API.Call(\n\t\t\t'POST',\n\t\t\t'groups/%s' % (self.alias),\n\t\t\t{'name': name, 'description': description, 'parentGroupId': self.id},\n\t\t\tsession=self.session)\n\t\treturn(Group(id=r['id'],alias=self.alias,group_obj=r,session=self.session))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef static_urls_js():\n    if apps.is_installed('django.contrib.staticfiles'):\n        from django.contrib.staticfiles.storage import staticfiles_storage\n        static_base_url = staticfiles_storage.base_url\n    else:\n        static_base_url = PrefixNode.handle_simple(\"STATIC_URL\")\n    transpile_base_url = urljoin(static_base_url, 'js/transpile/')\n    return {\n        'static_base_url': static_base_url,\n        'transpile_base_url': transpile_base_url,\n        'version': LAST_RUN['version']\n    }", "response": "Add global variables to JavaScript about the location and latest version of the transpiled files."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef List(type='All'):\n\t\tr = clc.v1.API.Call('post','Queue/ListQueueRequests',{'ItemStatusType': Queue.item_status_type_map[type] })\n\t\tif int(r['StatusCode']) == 0:  return(r['Requests'])", "response": "List Queued Requests and their current status details."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the status of the specified Blueprint deployment.", "response": "def GetStatus(request_id,silent=False):\n\t\t\"\"\"Gets the status of the specified Blueprint deployment.\n\n\t\thttps://t3n.zendesk.com/entries/20345638-Get-Request-Status\n\n\t\t:param request_id: the Request ID returned by any of the operations which Queues an async request to perform any given task\n\t\t:param silent: optionally disable all status messages when run in CLI mode\n\t\t\"\"\"\n\t\tr = clc.v1.API.Call('post','Queue/GetRequestStatus',{'RequestID': request_id},silent=silent)\n\t\tif int(r['StatusCode']) == 0:  return(r['RequestDetails'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _Load(self,location):\n\n\t\t# https://api.ctl.io/v2-experimental/networks/ALIAS/WA1\n\t\tfor network in clc.v2.API.Call('GET','/v2-experimental/networks/%s/%s' % (self.alias,location),{},session=self.session):\n\t\t\tself.networks.append(Network(id=network['id'],alias=self.alias,network_obj=network,session=self.session))", "response": "Load all networks associated with the given location."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Get(self,key):\n\n\t\tfor network in self.networks:\n\t\t\ttry:\n\t\t\t\tif network.id == key:  return(network)\n\t\t\t\tif network.name == key:  return(network)\n\t\t\t\tif network.cidr == key:  return(network)\n\t\t\texcept:\n\t\t\t\t# We ignore malformed records with missing attributes\n\t\t\t\tpass", "response": "Get network by providing name ID or other unique key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Create(alias=None,location=None,session=None):\n\n\t\tif not alias:  alias = clc.v2.Account.GetAlias(session=session)\n\t\tif not location:  location = clc.v2.Account.GetLocation(session=session)\n\n\t\treturn clc.v2.Requests(\n\t\t\tclc.v2.API.Call('POST','/v2-experimental/networks/%s/%s/claim' % (alias, location),session=session),\n\t\t\talias=alias,\n\t\t\tsession=session)", "response": "Claims a new network within a given account."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Delete(self,location=None):\n\n\t\tif not location:  location = clc.v2.Account.GetLocation(session=self.session)\n\n\t\treturn clc.v2.API.Call('POST','/v2-experimental/networks/%s/%s/%s/release' % (self.alias, location, self.id),\n\t\t                       session=self.session)", "response": "Releases the calling network."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the attributes of a given Network.", "response": "def Update(self,name,description=None,location=None):\n\t\t\"\"\"Updates the attributes of a given Network via PUT.\n\n\t\thttps://www.ctl.io/api-docs/v2/#networks-update-network\n\n\t\t{\n      \"name\": \"VLAN for Development Servers\",\n      \"description\": \"Development Servers on 11.22.33.0/24\"\n\t\t}\n\n\t\tReturns a 204 and no content\n\t\t\"\"\"\n\n\t\tif not location:  location = clc.v2.Account.GetLocation(session=self.session)\n\n\t\tpayload = {'name': name}\n\t\tpayload['description'] = description if description else self.description\n\n\t\tr = clc.v2.API.Call('PUT','/v2-experimental/networks/%s/%s/%s' % (self.alias, location, self.id), payload, session=self.session)\n\n\t\tself.name = self.data['name'] = name\n\t\tif description: self.data['description'] = description"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreload the network object to synchronize with cloud representation.", "response": "def Refresh(self, location=None):\n\t\t\"\"\"Reloads the network object to synchronize with cloud representation.\n\n\t\t>>> clc.v2.Network(\"f58148729bd94b02ae8b652f5c5feba3\").Refresh()\n\n\t\tGET https://api.ctl.io/v2-experimental/networks/{accountAlias}/{dataCenter}/{Network}?ipAddresses=none|claimed|free|all\n\t\t\"\"\"\n\t\tif not location:  location = clc.v2.Account.GetLocation(session=self.session)\n\n\t\tnew_object = clc.v2.API.Call('GET','/v2-experimental/networks/%s/%s/%s' % (self.alias,location,self.id), session=self.session)\n\n\t\tif new_object:\n\t\t\tself.name = new_object['name']\n\t\t\tself.data = new_object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef install_build_requires(pkg_targets):\n\n    def pip_install(pkg_name, pkg_vers=None):\n        pkg_name_version = '%s==%s' % (pkg_name, pkg_vers) if pkg_vers else pkg_name\n        print '[WARNING] %s not found, attempting to install using a raw \"pip install\" call!' % pkg_name_version\n        subprocess.Popen('pip install %s' % pkg_name_version, shell=True).communicate()\n\n    def get_pkg_info(pkg):\n        \"\"\"Get package name and version given a build_requires element\"\"\"\n        pkg_name, pkg_vers = None, None\n        if '==' in pkg:\n            pkg_name, pkg_vers = pkg.split('==')\n        else:\n            pkg_name = pkg.replace('>', '').replace('<', '').split('=')[0]\n        return pkg_name, pkg_vers\n\n    for pkg in pkg_targets:\n        pkg_name, pkg_vers = get_pkg_info(pkg)\n        try:\n            pkg_name_version = '%s==%s' % (pkg_name, pkg_vers) if pkg_vers else pkg_name\n            if pkg_vers:\n                version = getattr(importlib.import_module(pkg_name), '__version__')\n                if version != pkg_vers:\n                    pip_install(pkg_name, pkg_vers)\n            else:\n                importlib.import_module(pkg_name)\n        except ImportError:\n            pip_install(pkg_name, pkg_vers)", "response": "Installs the build_requires list of the specified packages."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncueing the @cyther code execution procedure", "response": "def cueExtractAndRun(args, file):\n    \"\"\"\n    Cues the @cyther code execution procedure\n    \"\"\"\n    filename = file['file_path']\n    if args['execute']:\n        holla = run(filename)\n    else:\n        holla = run(filename, True)\n    return holla"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initiateCompilation(args, file):\n    ####commands = finalizeCommands(args, file)\n    commands = makeCommands(0, file)\n    if not args['concise'] and args['print_args']:\n        print_commands = bool(args['watch'])\n    response = multiCall(*commands, print_commands=print_commands)\n    return response", "response": "Initiate the entire compilation procedure\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cytherize(args, file):\n    if isOutDated(file):\n        if isUpdated(file):\n            response = initiateCompilation(args, file)\n        else:\n            response = {'returncode': WAIT_FOR_FIX, 'output': ''}\n    else:\n        if args['timestamp']:\n            response = {'returncode': SKIPPED_COMPILATION, 'output': ''}\n        else:\n            response = initiateCompilation(args, file)\n\n    ###########################################################################\n\n    time.sleep(INTERVAL)\n    if response['returncode'] == ERROR_PASSOFF:\n        file['stamp_if_error'] = time.time()\n        if args['watch']:\n            if len(args['filenames']) > 1:\n                output = \"Error in file: '{}'; Cyther will wait until it is\" \\\n                         \"fixed...\\n\".format(file['file_path'])\n            else:\n                output = \"Cyther will wait for you to fix this error before\" \\\n                         \"it tries to compile again...\\n\"\n        else:\n            output = \"Error in source file, see above\\n\"\n\n    elif response['returncode'] == SKIPPED_COMPILATION:\n        if not args['watch']:\n            output = 'Skipping compilation: source file not updated since' \\\n                     'last compile\\n'\n        else:\n            output = ''\n\n    elif response['returncode'] == WAIT_FOR_FIX:\n        output = ''\n\n    elif response['returncode'] == FINE:\n        if args['watch']:\n            if len(args['filenames']) > 1:\n                output = \"Compiled the file '{}'\\n\".format(file['file_path'])\n            else:\n                output = 'Compiled the file\\n'\n        else:\n            if not args['concise']:\n                output = 'Compilation complete\\n'\n            else:\n                output = ''\n\n    else:\n        raise CytherError(\"Unrecognized return value '{}'\"\n                          \"\".format(response['returncode']))\n\n    response['output'] += output\n\n    ###########################################################################\n\n    condition = response['returncode'] == SKIPPED_COMPILATION and not args[\n        'watch']\n    if (args['execute'] or args['timer']) and response[\n        'returncode'] == FINE or condition:\n        ret = cueExtractAndRun(args, file)\n        response['output'] += ret['output']\n\n    ###########################################################################\n\n    if args['watch']:\n        if response['returncode'] == FINE or response[\n            'returncode'] == ERROR_PASSOFF:\n            if response['returncode'] == FINE:\n                args['watch_stats']['compiles'] += 1\n            else:\n                args['watch_stats']['errors'] += 1\n            args['watch_stats']['counter'] += 1\n            response['output'] += \\\n                WATCH_STATS_TEMPLATE.format(args['watch_stats']['counter'],\n                                            args['watch_stats']['compiles'],\n                                            args['watch_stats']['errors'],\n                                            args['watch_stats']['polls'])\n        else:\n            args['watch_stats']['polls'] += 1\n\n    ###########################################################################\n\n    if args['watch']:\n        if response['returncode'] == 1:\n            print(response['output'] + '\\n')\n        else:\n            if response['output']:\n                print(response['output'])\n    else:\n        if response['returncode'] == 1:\n            if args['error']:\n                raise CytherError(response['output'])\n            else:\n                print(response['output'])\n        else:\n            print(response['output'])", "response": "This function is used by core to integrate all the pieces of information and to interface the user with the core. Compiles and cleans up the entire tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(path, timer=False, repeat=3, number=10000, precision=2):\n    code = extractAtCyther(path)\n    if not code:\n        output = \"There was no '@cyther' code collected from the \" \\\n                 \"file '{}'\\n\".format(path)\n        # TODO This should use a result, right?\n        return {'returncode': 0, 'output': output}\n\n    module_directory = os.path.dirname(path)\n    module_name = os.path.splitext(os.path.basename(path))[0]\n    setup_string = SETUP_TEMPLATE.format(module_directory, module_name, '{}')\n\n    if timer:\n        string = TIMER_TEMPLATE.format(setup_string, code, repeat,\n                                       number, precision, '{}')\n    else:\n        string = setup_string + code\n\n    script = os.path.join(os.path.dirname(__file__), 'script.py')\n    with open(script, 'w+') as file:\n        file.write(string)\n\n    response = call(['python', script])\n    return response", "response": "Runs the Cython script from the given file path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef core(args):\n    args = furtherArgsProcessing(args)\n\n    numfiles = len(args['filenames'])\n    interval = INTERVAL / numfiles\n    files = processFiles(args)\n    while True:\n        for file in files:\n            cytherize(args, file)\n        if not args['watch']:\n            break\n        else:\n            time.sleep(interval)", "response": "This function is the heart of Cyther. It will run the Cyther algorithm in a loop and return the base object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the timestamp of the linguistic processor", "response": "def set_timestamp(self,timestamp=None):\n        \"\"\"\n        Set the timestamp of the linguistic processor, set to None for the current time\n        @type timestamp:string\n        @param timestamp: version of the linguistic processor\n        \"\"\"\n        if timestamp is None:\n            import time\n            timestamp = time.strftime('%Y-%m-%dT%H:%M:%S%Z')\n        self.node.set('timestamp',timestamp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the begin timestamp of the linguistic processor", "response": "def set_beginTimestamp(self,btimestamp=None):\n        \"\"\"\n        Set the begin timestamp of the linguistic processor, set to None for the current time\n        @type btimestamp: string\n        @param btimestamp: version of the linguistic processor\n        \"\"\"\n        if btimestamp is None:\n            import time\n            btimestamp = time.strftime('%Y-%m-%dT%H:%M:%S%Z')\n        self.node.set('beginTimestamp',btimestamp)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the end timestamp of the linguistic processor", "response": "def set_endTimestamp(self,etimestamp=None):\n        \"\"\"\n        Set the end timestamp of the linguistic processor, set to None for the current time\n        @type etimestamp: string\n        @param etimestamp: version of the linguistic processor\n        \"\"\"\n        if etimestamp is None:\n            import time\n            etimestamp = time.strftime('%Y-%m-%dT%H:%M:%S%Z')\n        self.node.set('endTimestamp',etimestamp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_publicId(self,publicId):\n        '''\n        Sets the publicId to the public object\n        @param publicId: a publicId (title of article)\n        @type publicId: string\n        '''\n        publicObj = self.get_public()\n        if publicObj is not None:\n            publicObj.set_publicid(publicId)\n        else:\n            publicObj = Cpublic()\n            publicObj.set_publicid(publicId)\n            self.set_public(publicObj)", "response": "Sets the publicId to the public object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the uri to the public object", "response": "def set_uri(self, uri):\n        '''\n        Sets the uri to the public object\n        @param uri: a uri\n        @type uri: string\n        '''\n        publicObj = self.get_public()\n        if publicObj is not None:\n            publicObj.set_uri(uri)\n        else:\n            publicObj = Cpublic()\n            publicObj.set_uri(uri)\n            self.set_public(publicObj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_lp(self,layer):\n        for this_node in self.node.findall('linguisticProcessors'):\n            if this_node.get('layer') == layer:\n                self.node.remove(this_node)\n                break", "response": "Removes the linguistic processors for a given layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a linguistic processor to a certain layer.", "response": "def add_linguistic_processor(self, layer ,my_lp):\n        \"\"\"\n        Adds a linguistic processor to a certain layer\n        @type layer: string\n        @param layer: the name of the layer\n        @type my_lp: L{Clp}\n        @param my_lp: the linguistic processor\n        \"\"\"\n        ## Locate the linguisticProcessor element for taht layer\n        found_lp_obj = None\n        for this_lp in self.node.findall('linguisticProcessors'):\n            lp_obj = ClinguisticProcessors(this_lp)\n            if lp_obj.get_layer() == layer:\n                found_lp_obj = lp_obj\n                break\n        \n        if found_lp_obj is None:    #Not found\n            found_lp_obj = ClinguisticProcessors()\n            found_lp_obj.set_layer(layer)\n            self.add_linguistic_processors(found_lp_obj)\n            \n        found_lp_obj.add_linguistic_processor(my_lp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the fileDesc object or None if there is no such element", "response": "def get_fileDesc(self):\n        '''\n        Returns the fileDesc object or None if there is no such element\n        @return: the fileDesc object\n        @rtype: L{CfileDesc}\n        '''\n        node = self.node.find('fileDesc')\n        if node is not None:\n            return CfileDesc(node=node)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the public object or None if there is no such element", "response": "def get_public(self):\n        '''\n        Returns the public object or None if there is no such element\n        @return: the public object\n        @rtype: L{Cpublic}\n        '''\n        node = self.node.find('public')\n        if node is not None:\n            return Cpublic(node=node)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the status of a Blueprint Deployment.", "response": "def GetStatus(request_id,location=None,alias=None,silent=False):\n\t\t\"\"\"Gets the status of the specified Blueprint deployment.\n\n\t\thttps://t3n.zendesk.com/entries/20561586-Get-Deployment-Status\n\n\t\t:param request_id: the int ID of the Blueprint Deployment to retrieve status for.\n\t\t:param alias: short code for a particular account.  If none will use account's default alias\n\t\t:param location: datacenter where group resides\n\t\t:param silent: disable status output when executed within CLI runtime\n\t\t\"\"\"\n\t\tif alias is None:  alias = clc.v1.Account.GetAlias()\n\t\tif location is None:  location = clc.v1.Account.GetLocation()\n\t\tr = clc.v1.API.Call('post','Blueprint/GetBlueprintStatus',{'AccountAlias': alias, 'RequestID': request_id, 'LocationAlias': location },silent=silent)\n\t\tif int(r['StatusCode']) == 0:  return(r)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of Blueprint Packages filtered by classification and visibility.", "response": "def GetPackages(classification,visibility):\n\t\t\"\"\"Gets a list of Blueprint Packages filtered by classification and visibility.\n\n\t\thttps://t3n.zendesk.com/entries/20411357-Get-Packages\n\n\t\t:param classification: package type filter (System, Script, Software)\n\t\t:param visibility: package visibility filter (Public, Private, Shared)\n\t\t\"\"\"\n\t\tr = clc.v1.API.Call('post','Blueprint/GetPackages',\n\t\t\t\t\t\t\t{'Classification': Blueprint.classification_stoi[classification],'Visibility': Blueprint.visibility_stoi[visibility]})\n\t\tif int(r['StatusCode']) == 0:  return(r['Packages'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a list of all Blueprint Packages with a given classification.", "response": "def GetAllPackages(classification):\n\t\t\"\"\"Gets a list of all Blueprint Packages with a given classification.\n\n\t\thttps://t3n.zendesk.com/entries/20411357-Get-Packages\n\n\t\t:param classification: package type filter (System, Script, Software)\n\t\t\"\"\"\n\t\tpackages = []\n\t\tfor visibility in Blueprint.visibility_stoi.keys():\n\t\t\ttry:\n\t\t\t\tfor r in Blueprint.GetPackages(classification,visibility):  packages.append(dict(r.items()+{'Visibility':visibility}.items()))\n\t\t\texcept:\n\t\t\t\tpass\n\t\tif len(packages):  return(packages)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef PackageUpload(package,ftp_url):\n\t\t#o = urlparse.urlparse(ftp_url)\n\t\t# Very weak URL checking\n\t\t#if o.scheme.lower() != \"ftp\":  \n\t\t#\tclc.v1.output.Status('ERROR',2,'Invalid FTP URL')\n\t\t#\treturn\n\n\t\t# Confirm file exists \n\t\tif not os.path.isfile(package):\n\t\t\tclc.v1.output.Status('ERROR',2,'Package file (%s) not found' % (package))\n\t\t\treturn\n\n\t\tm = re.search(\"ftp://(?P<user>.+?):(?P<passwd>.+?)@(?P<host>.+)\",ftp_url)\n\t\ttry:\n\t\t\tftp = ftplib.FTP(m.group('host'),m.group('user'),m.group('passwd'))\n\t\t\tfile = open(package,'rb')   \n\t\t\tfilename = re.sub(\".*/\",\"\",package)\n\t\t\tftp.storbinary(\"STOR %s\" % (filename),file)\n\t\t\tfile.close()\n\t\t\tftp.quit()\n\t\t\tclc.v1.output.Status('SUCCESS',2,'Blueprint package %s Uploaded' % (filename))\n\t\texcept Exception as e:\n\t\t\tclc.v1.output.Status('ERROR',2,'FTP error %s: %s' % (ftp_url,str(e)))\n\n\t\treturn({})", "response": "Uploads specified zip file to cloud endpoint."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npublishes a Blueprint Package for use within the Blueprint Designer.", "response": "def PackagePublish(package,classification,visibility,os):\n\t\t\"\"\"Publishes a Blueprint Package for use within the Blueprint Designer.\n\n\t\thttps://t3n.zendesk.com/entries/20426453-Publish-Package\n\n\t\t:param package: path to zip file containing package.manifest and supporting scripts\n\t\t:param classification: package type (System, Script, Software)\n\t\t:param visibility: package visibility filter (Public, Private, Shared)\n\t\t:param os: list of ints containing Operating System template IDs\n\t\t\"\"\"\n\t\tr = clc.v1.API.Call('post','Blueprint/PublishPackage',\n\t\t\t\t\t\t\t{'Classification': Blueprint.classification_stoi[classification], 'Name': package, 'OperatingSystems': os, \n\t\t\t\t\t\t\t 'Visibility': Blueprint.visibility_stoi[visibility]})\n\t\tif int(r['StatusCode']) == 0:  return(r)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npublishing a Blueprint Package for use within the Blueprint Designer after interactive OS selection.", "response": "def PackagePublishUI(package,type,visibility):\n\t\t\"\"\"Publishes a Blueprint Package for use within the Blueprint Designer after interactive OS selection.\n\n\t\tInteractive selection of one or more operating systems by name.\n\n\t\t:param package: path to zip file containing package.manifest and supporting scripts\n\t\t:param classification: package type (System, Script, Software)\n\t\t:param visibility: package visibility filter (Public, Private, Shared)\n\t\t\"\"\"\n\t\t# fetch OS list\n\t\tlinux_lst = {'L': {'selected': False, 'Description': 'All Linux'}}\n\t\twindows_lst = {'W': {'selected': False, 'Description': 'All Windows'}}\n\t\tfor r in clc.v1.Server.GetTemplates():\n\t\t\tr['selected'] = False\n\t\t\tif re.search(\"Windows\",r['Description']):  windows_lst[str(r['OperatingSystem'])] = r\n\t\t\telif re.search(\"CentOS|RedHat|Ubuntu\",r['Description']):  linux_lst[str(r['OperatingSystem'])] = r\n\n\n\t\t# Get selections\n\t\tif os.name=='posix':\n\t\t\tscr = curses.initscr()\n\t\t\tcurses.cbreak(); \n\t\twhile True:\n\t\t\tif os.name=='posix':  c = Blueprint._DrawPublishPackageUIPosix(scr,linux_lst,windows_lst)\n\t\t\telse:  c = Blueprint._DrawPublishPackageUI(linux_lst,windows_lst)\n\t\t\tif c.lower() == 'q':  break\n\t\t\telif c.lower() == 'l':  \n\t\t\t\tfor l in linux_lst:  linux_lst[l]['selected'] = not linux_lst[l]['selected']\n\t\t\telif c.lower() == 'w':  \n\t\t\t\tfor l in windows_lst:  windows_lst[l]['selected'] = not windows_lst[l]['selected']\n\t\t\telif c in linux_lst:  linux_lst[c]['selected'] = not linux_lst[c]['selected']\n\t\t\telif c in windows_lst:  windows_lst[c]['selected'] = not windows_lst[c]['selected']\n\t\tif os.name=='posix':\n\t\t\tcurses.nocbreak(); curses.echo(); curses.endwin()\n\n\t\t# Extract selections\n\t\tids = []\n\t\tfor l in dict(linux_lst.items()+windows_lst.items()).values():\n\t\t\tif l['selected'] and 'OperatingSystem' in l:  ids.append(str(l['OperatingSystem']))\n\t\tclc.v1.output.Status('SUCCESS',2,'Selected operating system IDs: %s' % (\" \".join(ids)))\n\n\t\treturn(Blueprint.PackagePublish(package,type,visibility,ids))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the members of the archive as a list of RPMInfo objects. The list is the same order as the members in the archive.", "response": "def getmembers(self):\n        '''\n        Return the members of the archive as a list of RPMInfo objects. The\n        list has the same order as the members in the archive.\n        '''\n        if self._members is None:\n            self._members = _members = []\n            g = self.data_file\n            magic = g.read(2)\n            while magic:\n                if magic == b'07':\n                    magic += g.read(4)\n                    member = RPMInfo._read(magic, g)\n\n                    if member.name == 'TRAILER!!!':\n                        break\n\n                    if not member.isdir:\n                        _members.append(member)\n\n                magic = g.read(2)\n            return _members\n        return self._members"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getmember(self, name):\n        '''\n        Return an RPMInfo object for member `name'. If `name' can not be\n        found in the archive, KeyError is raised. If a member occurs more\n        than once in the archive, its last occurrence is assumed to be the\n        most up-to-date version.\n        '''\n        members = self.getmembers()\n        for m in members[::-1]:\n            if m.name == name:\n                return m\n\n        raise KeyError(\"member %s could not be found\" % name)", "response": "Return an RPMInfo object for the specified member name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts a member from the archive as a file object.", "response": "def extractfile(self, member):\n        '''\n        Extract a member from the archive as a file object. `member' may be\n        a filename or an RPMInfo object.\n        The file-like object is read-only and provides the following\n        methods: read(), readline(), readlines(), seek() and tell()\n        '''\n        if not isinstance(member, RPMInfo):\n            member = self.getmember(member)\n        return _SubFile(self.data_file, member.file_start, member.size)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the uncompressed raw CPIO data of the RPM archive.", "response": "def data_file(self):\n        \"\"\"Return the uncompressed raw CPIO data of the RPM archive.\"\"\"\n\n        if self._data_file is None:\n            fileobj = _SubFile(self._fileobj, self.data_offset)\n\n            if self.headers[\"archive_compression\"] == b\"xz\":\n                if not getattr(sys.modules[__name__], 'lzma', False):\n                    raise NoLZMAModuleError('lzma module not present')\n                self._data_file = lzma.LZMAFile(fileobj)\n            else:\n                self._data_file = gzip.GzipFile(fileobj=fileobj)\n\n        return self._data_file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads and parse input if needed.", "response": "def load_input(definition):\n    \"\"\"Load and parse input if needed.\n\n    :param definition: definition to use as an input (file, serialized JSON/YAML or dict)\n    :return: loaded input\n    :raises json2sql.ParsingInputError: when parsing fails\n    \"\"\"\n    if isinstance(definition, (str, io.TextIOWrapper)):\n        try:\n            definition = yaml.safe_load(definition)\n        except Exception as exc:\n            raise ParsingInputError(\"Unable to parse input: %s\" % str(exc))\n\n    return definition"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle general to SQL conversion.", "response": "def any2sql(func, definition_dict=None, **definition_kwargs):\n    \"\"\"Handle general to SQL conversion.\n\n    :param func: function to be called on the given definition\n    :param definition_dict: statement definition in dict\n    :param definition_kwargs: statement definition as kwargs\n    :return: raw SQL statement\n    \"\"\"\n    if definition_dict and definition_kwargs:\n        raise InputError(\"Cannot process dict and kwargs input at the same time\")\n\n    definition = load_input(definition_dict or definition_kwargs)\n\n    if definition.get('returning', '') == '*':\n        definition['returning'] = mosql_raw('*')\n\n    try:\n        result = func(**definition)\n    except (TypeError, AttributeError) as exc:\n        raise ClauseError(\"Clause definition error: %s\" % str(exc)) from exc\n    except Exception as exc:\n        import json2sql.errors as json2sql_errors\n\n        if exc.__class__.__name__ not in json2sql_errors.__dict__.keys():\n            raise json2sql_errors.Json2SqlInternalError(\"Unhandled error: %s\" % str(exc)) from exc\n        raise\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _expand_join(join_definition):\n    join_table_name = join_definition.pop('table')\n    join_func = getattr(mosql_query, join_definition.pop('join_type', 'join'))\n    return join_func(join_table_name, **join_definition)", "response": "Expand join definition to join call."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a SELECT statement that will be used as a filter.", "response": "def _construct_select_query(**filter_definition):\n    \"\"\"Return SELECT statement that will be used as a filter.\n\n    :param filter_definition: definition of a filter that should be used for SELECT construction\n    :return:\n    \"\"\"\n    table_name = filter_definition.pop('table')\n    distinct = filter_definition.pop('distinct', False)\n    select_count = filter_definition.pop('count', False)\n\n    if distinct and select_count:\n        raise UnsupportedDefinitionError('SELECT (DISTINCT ...) is not supported')\n\n    if select_count and 'select' in filter_definition:\n        raise UnsupportedDefinitionError('SELECT COUNT(columns) is not supported')\n\n    if 'joins' in filter_definition:\n        join_definitions = filter_definition.pop('joins')\n\n        if not isinstance(join_definitions, (tuple, list)):\n            join_definitions = (join_definitions,)\n\n        filter_definition['joins'] = []\n        for join_def in join_definitions:\n            filter_definition['joins'].append(_expand_join(join_def))\n\n    if 'where' in filter_definition:\n        for key, value in filter_definition['where'].items():\n            if is_filter_query(value):\n                # We can do it recursively here\n                sub_query = value.pop(DEFAULT_FILTER_KEY)\n                if value:\n                    raise ParsingInputError(\"Unknown keys for sub-query provided: %s\" % value)\n                filter_definition['where'][key] = mosql_raw('( {} )'.format(_construct_select_query(**sub_query)))\n            elif isinstance(value, str) and value.startswith('$') and QUERY_REFERENCE.fullmatch(value[1:]):\n                # Make sure we construct correct query with escaped table name and escaped column for sub-queries\n                filter_definition['where'][key] = mosql_raw('\"{}\"'.format('\".\"'.join(value[1:].split('.'))))\n\n    raw_select = select(table_name, **filter_definition)\n\n    if distinct:\n        # Note that we want to limit replace to the current SELECT, not affect nested ones\n        raw_select = raw_select.replace('SELECT', 'SELECT DISTINCT', 1)\n    if select_count:\n        # Note that we want to limit replace to the current SELECT, not affect nested ones\n        raw_select = raw_select.replace('SELECT *', 'SELECT COUNT(*)', 1)\n\n    return raw_select"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccepting a connection on the host and port of the socket", "response": "def accept(self):\n        \"\"\"accept a connection on the host/port to which the socket is bound\n\n        .. note::\n\n            if there is no connection attempt already queued, this method will\n            block until a connection is made\n\n        :returns:\n            a two-tuple of ``(socket, address)`` where the socket is connected,\n            and the address is the ``(ip_address, port)`` of the remote end\n        \"\"\"\n        with self._registered('re'):\n            while 1:\n                try:\n                    client, addr = self._sock.accept()\n                except socket.error, exc:\n                    if not self._blocking or exc[0] not in _BLOCKING_OP:\n                        raise\n                    sys.exc_clear()\n                    if self._readable.wait(self.gettimeout()):\n                        raise socket.timeout(\"timed out\")\n                    if scheduler.state.interrupted:\n                        raise IOError(errno.EINTR,\n                                \"interrupted system call\")\n                    continue\n                return type(self)(fromsock=client), addr"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect(self, address):\n        address = _dns_resolve(self, address)\n        with self._registered('we'):\n            while 1:\n                err = self._sock.connect_ex(address)\n                if not self._blocking or err not in _BLOCKING_OP:\n                    if err not in (0, errno.EISCONN):\n                        raise socket.error(err, errno.errorcode[err])\n                    return\n                if self._writable.wait(self.gettimeout()):\n                    raise socket.timeout(\"timed out\")\n                if scheduler.state.interrupted:\n                    raise IOError(errno.EINTR,\n                            \"interrupted system call\")", "response": "initiate a new connection to a remote socket"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the value of a given socket option the values for ``level`` and ``optname`` will usually come from constants in the standard library ``socket`` module. consult the unix manpage ``getsockopt(2)`` for more information. :param level: the level of the requested socket option :type level: int :param optname: the specific socket option requested :type optname: int :param buflen: the length of the buffer to use to collect the raw value of the socket option. if provided, the buffer is returned as a string and it is not parsed. :type buflen: int :returns: a string of the socket option's value", "response": "def getsockopt(self, level, optname, *args, **kwargs):\n        \"\"\"get the value of a given socket option\n\n        the values for ``level`` and ``optname`` will usually come from\n        constants in the standard library ``socket`` module. consult the unix\n        manpage ``getsockopt(2)`` for more information.\n\n        :param level: the level of the requested socket option\n        :type level: int\n        :param optname: the specific socket option requested\n        :type optname: int\n        :param buflen:\n            the length of the buffer to use to collect the raw value of the\n            socket option. if provided, the buffer is returned as a string and\n            it is not parsed.\n        :type buflen: int\n\n        :returns: a string of the socket option's value\n        \"\"\"\n        return self._sock.getsockopt(level, optname, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef makefile(self, mode='r', bufsize=-1):\n        f = SocketFile(self._sock, mode)\n        f._sock.settimeout(self.gettimeout())\n        return f", "response": "create a file - like object that wraps the socket connection\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef recvfrom(self, bufsize, flags=0):\n        with self._registered('re'):\n            while 1:\n                if self._closed:\n                    raise socket.error(errno.EBADF, \"Bad file descriptor\")\n                try:\n                    return self._sock.recvfrom(bufsize, flags)\n                except socket.error, exc:\n                    if not self._blocking or exc[0] not in _BLOCKING_OP:\n                        raise\n                    sys.exc_clear()\n                    if self._readable.wait(self.gettimeout()):\n                        raise socket.timeout(\"timed out\")\n                    if scheduler.state.interrupted:\n                        raise IOError(errno.EINTR, \"interrupted system call\")", "response": "receive data on a socket that isn t necessarily a 1 - 1 connection"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends data over the socket connection", "response": "def send(self, data, flags=0):\n        \"\"\"send data over the socket connection\n\n        .. note:: this method may block if the socket's send buffer is full\n\n        :param data: the data to send\n        :type data: str\n        :param flags:\n            flags for the send call. this has the same meaning as for\n            :meth:`recv`\n        :type flags: int\n\n        :returns:\n            the number of bytes successfully sent, which may not necessarily be\n            all the provided data\n        \"\"\"\n        with self._registered('we'):\n            while 1:\n                try:\n                    return self._sock.send(data)\n                except socket.error, exc:\n                    if exc[0] not in _CANT_SEND or not self._blocking:\n                        raise\n                    if self._writable.wait(self.gettimeout()):\n                        raise socket.timeout(\"timed out\")\n                    if scheduler.state.interrupted:\n                        raise IOError(errno.EINTR, \"interrupted system call\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sendall(self, data, flags=0):\n        sent = self.send(data, flags)\n        while sent < len(data):\n            sent += self.send(data[sent:], flags)", "response": "send data over the socket and keep sending until all goes\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the value of an option in a given socket level", "response": "def setsockopt(self, level, optname, value):\n        \"\"\"set the value of a given socket option\n\n        the values for ``level`` and ``optname`` will usually come from\n        constants in the standard library ``socket`` module. consult the unix\n        manpage ``setsockopt(2)`` for more information.\n\n        :param level: the level of the set socket option\n        :type level: int\n        :param optname: the specific socket option to set\n        :type optname: int\n        :param value: the value to set for the option\n        :type value: int\n        \"\"\"\n        return self._sock.setsockopt(level, optname, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the timeout for this specific socket", "response": "def settimeout(self, timeout):\n        \"\"\"set the timeout for this specific socket\n\n        :param timeout:\n            the number of seconds the socket's blocking operations should block\n            before raising a ``socket.timeout``\n        :type timeout: float or None\n        \"\"\"\n        if timeout is not None:\n            timeout = float(timeout)\n        self._timeout = timeout"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_version():\n    if not INSTALLED:\n        try:\n            with open('version.txt', 'r') as v_fh:\n                return v_fh.read()\n        except Exception:\n            warnings.warn(\n                'Unable to resolve package version until installed',\n                UserWarning\n            )\n            return '0.0.0'  #can't parse version without stuff installed\n\n    return p_version.get_version(HERE)", "response": "find current version information\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a list of term ids a new span in the references", "response": "def add_span(self,term_span):\n        \"\"\"\n        Adds a list of term ids a new span in the references\n        @type term_span: list\n        @param term_span: list of term ids\n        \"\"\"\n        new_span = Cspan()\n        new_span.create_from_ids(term_span)\n        self.node.append(new_span.get_node())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_span(self,span):\n        this_node = span.get_node()\n        self.node.remove(this_node)", "response": "Removes a specific span from the coref object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the coreference layer to KAF", "response": "def to_kaf(self):\n        \"\"\"\n        Converts the coreference layer to KAF\n        \"\"\"\n        if self.type == 'NAF':\n            for node_coref in self.__get_corefs_nodes():\n                node_coref.set('coid',node_coref.get('id'))\n                del node_coref.attrib['id']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_naf(self):\n        if self.type == 'KAF':\n            for node_coref in self.__get_corefs_nodes():\n                node_coref.set('id',node_coref.get('coid'))\n                del node_coref.attrib['coid']", "response": "Converts the coreference layer to NAF"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_coreference(self,coid):\n        for this_node in self.node.findall('coref'):\n            if this_node.get('id') == coid:\n                self.node.remove(this_node)\n                break", "response": "Removes the coreference with specific identifier\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vt2esofspy(vesseltree, outputfilename=\"tracer.txt\", axisorder=[0, 1, 2]):\n\n    if (type(vesseltree) == str) and os.path.isfile(vesseltree):\n        import io3d\n        vt = io3d.misc.obj_from_file(vesseltree)\n    else:\n        vt = vesseltree\n    print(vt['general'])\n    print(vt.keys())\n    vtgm = vt['graph']['microstructure']\n    lines = []\n    vs = vt['general']['voxel_size_mm']\n    sh = vt['general']['shape_px']\n\n    # switch axis\n    ax = axisorder\n\n    lines.append(\"#Tracer+\\n\")\n    lines.append(\"#voxelsize mm %f %f %f\\n\" % (vs[ax[0]], vs[ax[1]], vs[ax[2]]))\n    lines.append(\"#shape %i %i %i\\n\" % (sh[ax[0]], sh[ax[1]], sh[ax[2]]))\n    lines.append(str(len(vtgm) * 2)+\"\\n\")\n\n    i = 1\n    for id in vtgm:\n        # edge['']\n        try:\n            nda = vtgm[id]['nodeA_ZYX']\n            ndb = vtgm[id]['nodeB_ZYX']\n            lines.append(\"%i\\t%i\\t%i\\t%i\\n\" % (nda[ax[0]], nda[ax[1]], nda[ax[2]], i))\n            lines.append(\"%i\\t%i\\t%i\\t%i\\n\" % (ndb[ax[0]], ndb[ax[1]], ndb[ax[2]], i))\n            i += 1\n        except:\n            pass\n\n\n    lines.append(\"%i\\t%i\\t%i\\t%i\" % (0, 0, 0, 0))\n    lines[3] = str(i - 1) + \"\\n\"\n    with open(outputfilename, 'wt') as f:\n        f.writelines(lines)", "response": "exports vesseltree to esofspy format"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef constq_grun(v, v0, gamma0, q):\n    x = v / v0\n    return gamma0 * np.power(x, q)", "response": "calculate Gruneisen parameter for constant q"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates Debye temperature for constant q", "response": "def constq_debyetemp(v, v0, gamma0, q, theta0):\n    \"\"\"\n    calculate Debye temperature for constant q\n\n    :param v: unit-cell volume in A^3\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param q: logarithmic derivative of Gruneisen parameter\n    :param theta0: Debye temperature at 1 bar\n    :return: Debye temperature in K\n    \"\"\"\n    gamma = constq_grun(v, v0, gamma0, q)\n    if isuncertainties([v, v0, gamma0, q, theta0]):\n        theta = theta0 * unp.exp((gamma0 - gamma) / q)\n    else:\n        theta = theta0 * np.exp((gamma0 - gamma) / q)\n    return theta"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef constq_pth(v, temp, v0, gamma0, q, theta0, n, z, t_ref=300.,\n               three_r=3. * constants.R):\n    \"\"\"\n    calculate thermal pressure for constant q\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param q: logarithmic derivative of Gruneisen parameter\n    :param theta0: Debye temperature in K\n    :param n: number of atoms in a formula unit\n    :param z: number of formula unit in a unit cell\n    :param t_ref: reference temperature\n    :param three_r: 3R in case adjustment is needed\n    :return: thermal pressure in GPa\n    \"\"\"\n    v_mol = vol_uc2mol(v, z)\n    # x = v / v0\n    gamma = constq_grun(v, v0, gamma0, q)\n    theta = constq_debyetemp(v, v0, gamma0, q, theta0)\n    xx = theta / temp\n    debye = debye_E(xx)\n    if t_ref == 0.:\n        debye0 = 0.\n    else:\n        xx0 = theta / t_ref\n        debye0 = debye_E(xx0)\n    Eth0 = three_r * n * t_ref * debye0\n    Eth = three_r * n * temp * debye\n    delEth = Eth - Eth0\n    p_th = (gamma / v_mol * delEth) * 1.e-9\n    return p_th", "response": "calculate thermal pressure for constant q"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling an endpoint given the parameters", "response": "def call(self, parameters):\n        \"\"\" Call an endpoint given the parameters\n\n        :param parameters: Dictionary of parameters\n        :type parameters: dict\n        :rtype: text\n        \"\"\"\n        # DEV !\n        parameters = {\n            key: str(parameters[key]) for key in parameters if parameters[key] is not None\n        }\n        if self.inventory is not None and \"inv\" not in parameters:\n            parameters[\"inv\"] = self.inventory\n\n        request = requests.get(self.endpoint, params=parameters)\n        request.raise_for_status()\n        if request.encoding is None:\n            request.encoding = \"utf-8\"\n        return request.text"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves valid urn - references for a text", "response": "def getValidReff(self, urn, inventory=None, level=None):\n        \"\"\" Retrieve valid urn-references for a text\n\n        :param urn: URN identifying the text\n        :type urn: text\n        :param inventory: Name of the inventory\n        :type inventory: text\n        :param level: Depth of references expected\n        :type level: int\n        :return: XML Response from the API as string\n        :rtype: str\n        \"\"\"\n        return self.call({\n            \"inv\": inventory,\n            \"urn\": urn,\n            \"level\": level,\n            \"request\": \"GetValidReff\"\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a passage from the inventory", "response": "def getPassage(self, urn, inventory=None, context=None):\n        \"\"\" Retrieve a passage\n\n        :param urn: URN identifying the text's passage (Minimum depth : 1)\n        :type urn: text\n        :param inventory: Name of the inventory\n        :type inventory: text\n        :param context: Number of citation units at the same level of the citation hierarchy as the requested urn, immediately preceding and immediately following the requested urn to include in the reply\n        :type context: int\n        :rtype: str\n        \"\"\"\n        return self.call({\n            \"inv\": inventory,\n            \"urn\": urn,\n            \"context\": context,\n            \"request\": \"GetPassage\"\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getPassagePlus(self, urn, inventory=None, context=None):\n        return self.call({\n            \"inv\": inventory,\n            \"urn\": urn,\n            \"context\": context,\n            \"request\": \"GetPassagePlus\"\n        })", "response": "Retrieves a passage and information about it\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrequest metadata about a text or a collection of objects.", "response": "def getMetadata(self, objectId=None, **filters):\n        \"\"\" Request metadata about a text or a collection\n\n        :param objectId: Filter for some object identifier\n        :param filters: Kwargs parameters. URN and Inv are available\n        :return: GetCapabilities CTS API request response\n        \"\"\"\n        filters.update({\"urn\": objectId})\n        return self.getCapabilities(**filters)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves a text node from the API.", "response": "def getTextualNode(self, textId, subreference=None, prevnext=False, metadata=False):\n        \"\"\" Retrieve a text node from the API\n\n        :param textId: CtsTextMetadata Identifier\n        :param subreference: CapitainsCtsPassage Reference\n        :param prevnext: Retrieve graph representing previous and next passage\n        :param metadata: Retrieve metadata about the passage and the text\n        :return: GetPassage or GetPassagePlus CTS API request response\n        \"\"\"\n        if  subreference:\n            textId = \"{}:{}\".format(textId, subreference)\n\n        if prevnext or metadata:\n            return self.getPassagePlus(urn=textId)\n        else:\n            return self.getPassage(urn=textId)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves the siblings of a textual node", "response": "def getSiblings(self, textId, subreference):\n        \"\"\" Retrieve the siblings of a textual node\n\n        :param textId: CtsTextMetadata Identifier\n        :param reference: CapitainsCtsPassage Reference\n        :return: GetPrevNextUrn request response from the endpoint\n        \"\"\"\n        textId = \"{}:{}\".format(textId, subreference)\n        return self.getPrevNextUrn(urn=textId)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getReffs(self, textId, level=1, subreference=None):\n        depth = level\n        if subreference:\n            textId = \"{}:{}\".format(textId, subreference)\n        if subreference:\n            if isinstance(subreference, CtsReference):\n                depth += subreference.depth\n            else:\n                depth += (CtsReference(subreference)).depth\n        if level:\n            level = max(depth, level)\n        return self.getValidReff(urn=textId, level=level)", "response": "Retrieve the siblings of a textual node."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a diff into an iterator of Intervals.", "response": "def parse_intervals(diff_report):\n    \"\"\"\n    Parse a diff into an iterator of Intervals.\n    \"\"\"\n\n    for patch in diff_report.patch_set:\n        try:\n            old_pf = diff_report.old_file(patch.source_file)\n            new_pf = diff_report.new_file(patch.target_file)\n        except InvalidPythonFile:\n            continue\n\n        for hunk in patch:\n            for line in hunk:\n                if line.line_type == LINE_TYPE_ADDED:\n                    idx = line.target_line_no\n                    yield ContextInterval(new_pf.filename, new_pf.context(idx))\n                elif line.line_type == LINE_TYPE_REMOVED:\n                    idx = line.source_line_no\n                    yield ContextInterval(old_pf.filename, old_pf.context(idx))\n                elif line.line_type in (LINE_TYPE_EMPTY, LINE_TYPE_CONTEXT):\n                    pass\n                else:\n                    raise AssertionError(\"Unexpected line type: %s\" % line)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntrain an LSI model on a corpus of documnets.", "response": "def lsi(tokenize=None, iter_dics=None, ram=0.4, num_docs=5000, num_topics=200, num_tokens=1000000,\n        num_plots=4, local_path=DATA_PATH, suffix='', ngrams=2,\n        verbose=1, show=True, save=True, **kwargs):\n    \"\"\"Train an LSI model on a \"corpus\" of documnets, like tweets\n\n    Arguments:\n      tokenize (callable): Function that returns a sequence of tokens (str) when passed a document (str)\n      ram (float):         Portion of RAM to limit the document generator from consuming before StopIteration\n      num_docs (int):      Number of documents to limit the document generator to before StopIteration\n      num_topics (int):    See gensim.models.LsiModel, default: 200\n      chunksize (int):     See gensim.models.LsiModel, default: 10000\n      power_iters (int):   See gensim.models.LsiModel, default: None\n      extra_samples (int): See gensim.models.LsiModel, default: None\n\n    My process the document generator 3 times (internal tees maintained to \"reset\" the generator):\n\n    1. \"train\" Dictionary (Vocab): find set of unique tokens and assigned int IDs)\n    2. \"train\" TfidfModel transform: need global frequencies (by tokenizing docs from document generator) for DF (document freuency) part\n    3. \"train\" LsiModel transform: need to iterate through the word vectors which are generated afresh by retokenizing documents\n\n    TODO: GET RID OF UNUSED ARGS!\n          Does the order of documents affect the resulting PCA topics?\n          Are topics limited to 10 tokens in gensim?\n          Should matches/pairs follow one another?\n          Should nonmatching vocab be used at all?\n\n    >>> lsi(ram=0.1, num_docs=2, verbose=0)\n    <gensim.models.lsimodel.LsiModel object at ...>\n    \"\"\"\n    lsi_kwargs = {'num_topics': num_topics, 'onepass': True}\n    lsi_kwargs.update(kwargs)\n    if lsi_kwargs.get('onepass', True) and (lsi_kwargs.get('power_iters', None) or lsi_kwargs.get('extra_samples', None)):\n        lsi_kwargs['onepass'] = False\n    mem0 = psutil.virtual_memory()\n    tokenize = tokenize or Tokenizer(ngrams=ngrams)  # , stem='WordNet', lower=True)\n    tokenize('Dummy text to get tokenizer to load any data it needs.')\n    mem1_tokenizer = psutil.virtual_memory()\n    if verbose:\n        print('{} tokenizer used {}B'.format(tokenize, friendly(mem1_tokenizer.used - mem0.used)))\n    suffix = suffix or 'auto'\n    suffix = ('_' * (bool(suffix) and not suffix.startswith('_'))) + suffix\n    docgen_orig = (stringify(d) for d in iter_docs)\n    docgen_orig, docgen = tee_gen_limit(docgen_orig, limit=num_docs, ram=ram, interval=1000, verbose=verbose)  # 1st generator copy\n    mem2_gen = psutil.virtual_memory()\n    vocab = Vocab((tokenize(s) for s in docgen), prune_at=num_tokens)\n    mem3_vocab = psutil.virtual_memory()\n    if verbose:\n        print('Built vocabulary of {} unique words and used {}B of RAM. Total RAM used = {}B or {:.3%}'.format(\n              friendly(len(vocab)), friendly(mem3_vocab.used - mem2_gen.used), friendly(mem3_vocab.used - mem0.used),\n              1. * (mem3_vocab.total - mem3_vocab.available) / mem3_vocab.available))\n    if suffix == '_auto':\n        suffix = '_' + str(len(vocab)) + '_{}grams'.format(ngrams)\n    full_name = 'lsi' + suffix\n    if verbose and save:\n        print('Will save LsiModel under the name {}'.format(full_name))\n    tfidf = TfidfModel(dictionary=vocab)\n    mem4_tfidf = psutil.virtual_memory()\n    if verbose:\n        print('Built tfidf of {} docs and used {}B of RAM. Total RAM used = {}B or {:.4%}'.format(\n              friendly(tfidf.num_docs), friendly(mem4_tfidf.used - mem3_vocab.used), friendly(mem4_tfidf.used - mem0.used),\n              1. * (mem4_tfidf.total - mem4_tfidf.available) / mem4_tfidf.available))\n    docgen_orig, docgen = tee_gen_limit(docgen_orig, limit=num_docs, ram=ram, interval=1000, verbose=verbose)  # 2nd generator copy\n    lsi = LsiModel(tfidf[(vocab.doc2bow(tokenize(s)) for s in docgen_orig)], id2word=vocab, **lsi_kwargs)\n    mem5_lsi = psutil.virtual_memory()\n    if verbose:\n        print('Built LSI model: {} docs, {} terms, {} topics. '.format(\n            friendly(lsi.docs_processed), friendly(lsi.num_terms), friendly(lsi.num_topics)))\n        print('Used {}B of RAM. Total RAM: {}B or {:.4%}'.format(\n            friendly(mem5_lsi.used - mem4_tfidf.used), friendly(mem5_lsi.used - mem0.used),\n            1. * (mem5_lsi.total - mem5_lsi.available) / mem5_lsi.available))\n    # TODO: Consider marshaling the tokenizer and any other user-specified functions\n    #   Marshaling stores the bytecode for the tokenizer rather than just its fully-qualified name\n    #   This would prevent changes to the tokenizer code from causing previously pickled objects\n    #   to behave differently than when they were pickled.\n    if save:\n        try_preserve(lsi, name=full_name, local_path=local_path, ext='', verbose=verbose)\n        # TODO: set lsi.tfidf.vocab=None # already saved in lsi.id2word\n        try_preserve(tokenize, name=full_name + '_tokenizer', local_path=local_path, ext='.pickle', verbose=verbose)\n    return lsi"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchooses a string literal that can wrap our string.", "response": "def string_literal(content):\n    \"\"\"\n    Choose a string literal that can wrap our string.\n\n    If your string contains a ``\\'`` the result will be wrapped in ``\\\"``.\n    If your string contains a ``\\\"`` the result will be wrapped in ``\\'``.\n\n    Cannot currently handle strings which contain both ``\\\"`` and ``\\'``.\n    \"\"\"\n\n    if '\"' in content and \"'\" in content:\n        # there is no way to escape string literal characters in XPath\n        raise ValueError(\"Cannot represent this string in XPath\")\n\n    if '\"' in content:  # if it contains \" wrap it in '\n        content = \"'%s'\" % content\n    else:  # wrap it in \"\n        content = '\"%s\"' % content\n\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef element_id_by_label(browser, label):\n    label = ElementSelector(browser,\n                            str('//label[contains(., %s)]' %\n                                string_literal(label)))\n    if not label:\n        return False\n    return label.get_attribute('for')", "response": "Returns the ID of an element referenced by a label."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the XPath expression for the given field and attribute.", "response": "def field_xpath(field, attribute):\n    \"\"\"\n    Field helper functions to locate select, textarea, and the other\n    types of input fields (text, checkbox, radio)\n\n    :param field: One of the values 'select', 'textarea', 'option', or\n    'button-element' to match a corresponding HTML element (and to\n    match a <button> in the case of 'button-element'). Otherwise a\n    type to match an <input> element with a type=<field> attribute.\n\n    :param attribute: An attribute to be matched against, or 'value'\n    to match against the content within element being matched.\n    \"\"\"\n    if field in ['select', 'textarea']:\n        xpath = './/{field}[@{attr}=%s]'\n\n    elif field == 'button-role':\n        if attribute == 'value':\n            xpath = './/*[@role=\"button\"][contains(., %s)]'\n        else:\n            xpath = './/*[@role=\"button\"][@{attr}=%s]'\n\n    elif field == 'button-element':\n        field = 'button'\n        if attribute == 'value':\n            xpath = './/{field}[contains(., %s)]'\n        else:\n            xpath = './/{field}[@{attr}=%s]'\n\n    elif field == 'option':\n        xpath = './/{field}[@{attr}=%s]'\n\n    else:\n        xpath = './/input[@{attr}=%s][@type=\"{field}\"]'\n\n    return xpath.format(field=field, attr=attribute)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds a button with the given value.", "response": "def find_button(browser, value):\n    \"\"\"\n    Find a button with the given value.\n\n    Searches for the following different kinds of buttons:\n\n        <input type=\"submit\">\n        <input type=\"reset\">\n        <input type=\"button\">\n        <input type=\"image\">\n        <button>\n        <{a,p,div,span,...} role=\"button\">\n\n    Returns: an :class:`ElementSelector`\n    \"\"\"\n    field_types = (\n        'submit',\n        'reset',\n        'button-element',\n        'button',\n        'image',\n        'button-role',\n    )\n\n    return reduce(\n        operator.add,\n        (find_field_with_value(browser, field_type, value)\n         for field_type in field_types)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_field(browser, field_type, value):\n    return find_field_by_id(browser, field_type, value) + \\\n        find_field_by_name(browser, field_type, value) + \\\n        find_field_by_label(browser, field_type, value)", "response": "Locate an input field."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_field_by_id(browser, field_type, id):\n    return ElementSelector(\n        browser,\n        xpath=field_xpath(field_type, 'id') % string_literal(id),\n        filter_displayed=True,\n    )", "response": "Locate the control input with the given id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_field_by_name(browser, field_type, name):\n    return ElementSelector(\n        browser,\n        field_xpath(field_type, 'name') %\n        string_literal(name),\n        filter_displayed=True,\n    )", "response": "Locate the control input with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlocating the control input with the given value. Useful for buttons.", "response": "def find_field_by_value(browser, field_type, name):\n    \"\"\"\n    Locate the control input with the given ``value``. Useful for buttons.\n\n    :param browser: ``world.browser``\n    :param string field_type: a field type (i.e. `button`)\n    :param string name: ``value`` attribute\n\n    Returns: an :class:`ElementSelector`\n    \"\"\"\n    xpath = field_xpath(field_type, 'value') % string_literal(name)\n    elems = ElementSelector(\n        browser,\n        xpath=str(xpath),\n        filter_displayed=True,\n        filter_enabled=True,\n    )\n\n    # sort by shortest first (most closely matching)\n    if field_type in ('button-element', 'button-role'):\n        elems = sorted(elems, key=lambda elem: len(elem.text))\n    else:\n        elems = sorted(elems,\n                       key=lambda elem: len(elem.get_attribute('value')))\n\n    if elems:\n        elems = [elems[0]]\n\n    return ElementSelector(browser, elements=elems)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_field_by_label(browser, field_type, label):\n\n    return ElementSelector(\n        browser,\n        xpath=field_xpath(field_type, 'id') %\n        '//label[contains(., {0})]/@for'.format(\n            string_literal(label)),\n        filter_displayed=True,\n    )", "response": "Locate the control input that has a label pointing to it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef option_in_select(browser, select_name, option):\n\n    select = find_field(browser, 'select', select_name)\n    assert select, \"Cannot find a '{}' select.\".format(select_name)\n\n    try:\n        return select.find_element_by_xpath(str(\n            './/option[normalize-space(text())=%s]' % string_literal(option)))\n    except NoSuchElementException:\n        return None", "response": "Returns the Element specified by option in a select2 widget."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter elements by visibility and enabled status.", "response": "def filter(self, displayed=False, enabled=False):\n        \"\"\"\n        Filter elements by visibility and enabled status.\n\n        :param displayed: whether to filter out invisible elements\n        :param enabled: whether to filter out disabled elements\n\n        Returns: an :class:`ElementSelector`\n        \"\"\"\n\n        if self.evaluated:\n            # Filter elements one by one\n            result = self\n\n            if displayed:\n                result = ElementSelector(\n                    result.browser,\n                    elements=[e for e in result if e.is_displayed()]\n                )\n\n            if enabled:\n                result = ElementSelector(\n                    result.browser,\n                    elements=[e for e in result if e.is_enabled()]\n                )\n\n        else:\n            result = copy(self)\n            if displayed:\n                result.displayed = True\n            if enabled:\n                result.enabled = True\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching the elements from the browser.", "response": "def _select(self):\n        \"\"\"Fetch the elements from the browser.\"\"\"\n\n        for element in self.browser.find_elements_by_xpath(self.xpath):\n            if self.filter_displayed:\n                if not element.is_displayed():\n                    continue\n\n            if self.filter_enabled:\n                if not element.is_enabled():\n                    continue\n\n            yield element"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef authenticate(self) -> bool:\n        with IHCController._mutex:\n            if not self.client.authenticate(self._username, self._password):\n                return False\n            if self._ihcevents:\n                self.client.enable_runtime_notifications(\n                    self._ihcevents.keys())\n            return True", "response": "Authenticate and enable the registered notifications"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting runtime value with re - authenticate if needed", "response": "def get_runtime_value(self, ihcid: int):\n        \"\"\" Get runtime value with re-authenticate if needed\"\"\"\n        if self.client.get_runtime_value(ihcid):\n            return True\n        self.re_authenticate()\n        return self.client.get_runtime_value(ihcid)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset bool runtime value with re - authenticate if needed", "response": "def set_runtime_value_bool(self, ihcid: int, value: bool) -> bool:\n        \"\"\" Set bool runtime value with re-authenticate if needed\"\"\"\n        if self.client.set_runtime_value_bool(ihcid, value):\n            return True\n        self.re_authenticate()\n        return self.client.set_runtime_value_bool(ihcid, value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset integer runtime value with re - authenticate if needed", "response": "def set_runtime_value_int(self, ihcid: int, value: int) -> bool:\n        \"\"\" Set integer runtime value with re-authenticate if needed\"\"\"\n        if self.client.set_runtime_value_int(ihcid, value):\n            return True\n        self.re_authenticate()\n        return self.client.set_runtime_value_int(ihcid, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_runtime_value_float(self, ihcid: int, value: float) -> bool:\n        if self.client.set_runtime_value_float(ihcid, value):\n            return True\n        self.re_authenticate()\n        return self.client.set_runtime_value_float(ihcid, value)", "response": "Set float runtime value with re - authenticate if needed"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the ihc project and make sure controller is ready before", "response": "def get_project(self) -> str:\n        \"\"\" Get the ihc project and make sure controller is ready before\"\"\"\n        with IHCController._mutex:\n            if self._project is None:\n                if self.client.get_state() != IHCSTATE_READY:\n                    ready = self.client.wait_for_state_change(IHCSTATE_READY,\n                                                              10)\n                    if ready != IHCSTATE_READY:\n                        return None\n                self._project = self.client.get_project()\n        return self._project"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a callback to be called when a resource is added to the notofication queue.", "response": "def add_notify_event(self, resourceid: int, callback, delayed=False):\n        \"\"\" Add a notify callback for a specified resource id\n        If delayed is set to true the enable request will be send from the\n        notofication thread\n        \"\"\"\n        with IHCController._mutex:\n            if resourceid in self._ihcevents:\n                self._ihcevents[resourceid].append(callback)\n            else:\n                self._ihcevents[resourceid] = [callback]\n                if delayed:\n                    self._newnotifyids.append(resourceid)\n                else:\n                    if not self.client.enable_runtime_notification(resourceid):\n                        return False\n            if not self._notifyrunning:\n                self._notifythread.start()\n\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _notify_fn(self):\n        self._notifyrunning = True\n        while self._notifyrunning:\n            try:\n                with IHCController._mutex:\n                    # Are there are any new ids to be added?\n                    if self._newnotifyids:\n                        self.client.enable_runtime_notifications(\n                            self._newnotifyids)\n                        self._newnotifyids = []\n\n                changes = self.client.wait_for_resource_value_changes()\n                if changes is False:\n                    self.re_authenticate(True)\n                    continue\n                for ihcid in changes:\n                    value = changes[ihcid]\n                    if ihcid in self._ihcevents:\n                        for callback in self._ihcevents[ihcid]:\n                            callback(ihcid, value)\n            except Exception as exp:\n                self.re_authenticate(True)", "response": "The notify thread function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nauthenticating again after failure.", "response": "def re_authenticate(self, notify: bool=False) -> bool:\n        \"\"\"Authenticate again after failure.\n           Keep trying with 10 sec interval. If called from the notify thread\n           we will not have a timeout, but will end if the notify thread has\n           been cancled.\n           Will return True if authentication was successful.\n          \"\"\"\n        timeout = datetime.now() + \\\n            timedelta(seconds=self.reauthenticatetimeout)\n        while True:\n            if self.authenticate():\n                return True\n\n            if notify:\n                if not self._notifyrunning:\n                    return False\n            else:\n                if timeout and datetime.now() > timeout:\n                    return False\n            # wait before we try to authenticate again\n            time.sleep(self.retryinterval)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_lines(input_file,\n                   start=0,\n                   stop=float('inf')):\n    \"\"\"Generate (yield) lines in a gzipped file (*.txt.gz) one line at a time\"\"\"\n    with gzip.GzipFile(input_file, 'rU') as f:\n        for i, line in enumerate(f):\n            if i < start:\n                continue\n            if i >= stop:\n                break\n            yield line.rstrip()", "response": "Generator for generating lines in a gzipped file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef segment_shakespeare_works(input_file=PATH_SHAKESPEARE, verbose=False):\n    works = [{}]\n    meta = {}\n    j = 0\n    for i, line in enumerate(generate_lines(input_file=input_file)):\n        if 'title' not in meta:\n            match = RE_GUTEN_LINE.match(line)\n            if match:\n                meta['title'] = match.groups()[0]\n                meta['body_start'] = i\n            continue\n        if j >= len(works):\n            works += [{}]\n        if not len(works[j]):\n            match = RE_YEAR_LINE.match(line)\n            if match:\n                if verbose:\n                    print(\" year {:02d}, {}: {}\".format(j, i, match.group()))\n                works[j]['year'] = int(match.group())\n                works[j]['start'] = i\n        elif len(works[j]) == 2:\n            match = RE_TITLE_LINE.match(line)\n            if match:\n                if verbose:\n                    print(\"title {:02d}, {}: {}\".format(j, i, match.groups()[0]))\n                works[j]['title'] = match.groups()[0]\n                works[j]['title_lineno'] = i\n        elif len(works[j]) == 4:\n            match = RE_BY_LINE.match(line)\n            if match:\n                if verbose:\n                    print(\"   by {:02d}, {}: {}\".format(j, i, match.group()))\n                works[j]['by'] = match.groups()[2]\n                works[j]['by_lineno'] = i\n        elif len(works[j]) > 4:\n            match = RE_ACT_SCENE_LINE.match(line)\n            if match:\n                section_meta = {\n                    'start': i,\n                    'title': match.groups()[0],\n                    'act_roman': match.groups()[1].split()[-1],\n                    'act': int(DICT_ROMAN2INT[match.groups()[1].split()[-1]]),\n                    'scene': int(match.groups()[2].split()[-1]),\n                }\n                works[j]['sections'] = works[j].get('sections', []) + [section_meta]\n            else:\n                match = RE_THE_END.match(line)\n                if match and 'GUTENBERG' not in match.group().upper():\n                    if verbose:\n                        print(\" stop {:02d}, {}: {}\".format(j, i, match.group()))\n                    works[j]['stop'] = i\n                    j += 1\n    if not len(works[-1]):\n        works = works[:-1]\n    meta['volumes'] = works\n    return meta", "response": "Generate a list of _Complete Works of William Shakespeare_ objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_texts(self, metadata=None):\n        if metadata is None:\n            metadata = self.metadata\n        self.input_file = gzip.GzipFile(self.input_file_path)\n        volume_num = 0\n        with self.input_file as lines:\n            for lineno, line in enumerate(lines):\n                if volume_num >= len(self.book_meta['volumes']):\n                    raise StopIteration()\n                if lineno < self.book_meta['volumes'][volume_num]['start']:\n                    continue\n                if lineno < self.book_meta['volumes'][volume_num]['stop']:\n                    # act_num, scene_num = 0, 0  # FIXME: use self.book_meta['volumes'][volume_num]['sections']\n                    if metadata:\n                        # FIXME: use self.lemmatize\n                        toks = self.tokenize(line, lowercase=self.lowercase)\n                        yield (toks, (lineno,))\n                    else:\n                        toks = self.tokenize(line, lowercase=self.lowercase)\n                        yield toks\n                else:\n                    volume_num += 1", "response": "Iterate over the lines of The Complete Works of William Shakespeare."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dropna(df, nonnull_rows=100, nonnull_cols=50, nanstrs=('nan', 'NaN', ''), nullstr=''):\n    if 0 < nonnull_rows < 1:\n        nonnull_rows = int(nonnull_rows * len(df))\n    if 0 < nonnull_cols < 1:\n        nonnull_cols = int(nonnull_cols * len(df.columns))\n    for label in df.columns:\n        series = df[label].copy()\n        if series.dtype in (np.dtype('O'), np.dtype('U'), np.dtype('S')):\n            for nanstr in nanstrs:\n                series[series == nanstr] = np.nan\n            df[label] = series\n    # in iPython Notebook, try dropping with lower thresholds, checking column and row count each time\n    print('The raw table shape is {}'.format(df.shape))\n    df = df.dropna(axis=1, thresh=nonnull_rows)\n    print('After dropping columns with fewer than {} nonnull values, the table shape is {}'.format(nonnull_rows, df.shape))\n    df = df.dropna(axis=0, thresh=nonnull_cols)\n    print('After dropping rows with fewer than {} nonnull values, the table shape is {}'.format(nonnull_cols, df.shape))\n    for label in df.columns:\n        series = df[label].copy()\n        if series.dtype == np.dtype('O'):\n            nonnull_dtype = series.dropna(inplace=False).values.dtype\n            if nonnull_dtype == np.dtype('O'):\n                series[series.isnull()] = nullstr\n                df[label] = series\n            else:\n                df[label] = series.astype(nonnull_dtype)\n    return df", "response": "Drop columns and rows with too many NaNs and replace NaNs in columns of strings with ''"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize(df):\n    # in ipython notebook, explore and describe the DataFrame columns\n    print('Of the {} columns, {} are actually DataFrames'.format(len(df.columns), sum([not isinstance(df[col], pd.Series) for col in df.columns])))\n    # remove dataframes with only 2 columns and one is the _str of the other:\n    for col in df.columns:\n        if isinstance(df[col], pd.DataFrame):\n            print('Column {} is a {}-wide DataFrame'.format(col, len(df[col].columns)))\n            if df[col].columns[1] == df[col].columns[0] + '_str':\n                print('Column {} looks easy because it has sub-columns {}'.format(col, df[col].columns))\n                df[col] = df[col][df[col].columns[1]]\n            else:\n                try:\n                    assert(float(df[col].iloc[:, 0].max()) == float(df[col].iloc[:, 1].max()))\n                    df[col] = df[col].fillna(-1, inplace=False)\n                    series = pd.Series([int(Decimal(x)) for x in df[col].iloc[:, 1].values]).astype('int64').copy()\n                    del df[col]\n                    df[col] = series\n                    print('Finished converting column {} to type {}({})'.format(col, type(df[col]), df[col].dtype))\n                except:\n                    print_exc()\n\n    print('Of the {} columns, {} are still DataFrames after trying to convert both columns to long integers'.format(\n        len(df.columns), sum([not isinstance(df[col], pd.Series) for col in df.columns])))\n    return df", "response": "Flatten compound columns ( DataFrames within columns ) into top level columns"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode(df, encoding='utf8', verbosity=1):\n    if verbosity > 0:\n        # pbar_i = 0\n        pbar = progressbar.ProgressBar(maxval=df.shape[1])\n        pbar.start()\n    # encode strings as UTF-8 so they'll work in python2 and python3\n    for colnum, col in enumerate(df.columns):\n        if isinstance(df[col], pd.Series):\n            if verbosity:\n                pbar.update(colnum)\n            if df[col].dtype in (np.dtype('object'), np.dtype('U'), np.dtype('S')) and any(isinstance(obj, basestring) for obj in df[col]):\n                strmask = np.array([isinstance(obj, basestring) for obj in df[col]])\n                series = df[col].copy()\n                try:\n                    series[strmask] = np.char.encode(series[strmask].values.astype('U'))\n                except TypeError:\n                    print(\"Unable to convert {} elements starting at position {} in column {}\".format(\n                          sum(strmask), [i for i, b in enumerate(strmask) if b][:1], col))\n                    raise\n                except (UnicodeDecodeError, UnicodeEncodeError):\n                    try:\n                        series[strmask] = np.array([eval(s, {}, {}) for s in series[strmask]])\n                    # FIXME: do something different for unicode and decode errors\n                    except (SyntaxError, UnicodeDecodeError, UnicodeEncodeError):\n                        newseries = []\n                        for s in series[strmask]:\n                            try:\n                                newseries += [s.encode('utf8')]\n                            except:\n                                print(u'Had trouble encoding {} so used repr to turn it into {}'.format(s, repr(transcode_unicode(s))))\n                                # strip all unicode chars are convert to ASCII str\n                                newseries += [transcode_unicode(s)]\n                        # for dtype('U'): UnicodeDecodeError: 'ascii' codec can't decode byte 0xe2 in position 207: ordinal not in r\n                        series[strmask] = np.array(newseries).astype('O')\n                df[col] = series\n                # df[col] = np.array([x.encode('utf8') if isinstance(x, unicode) else x for x in df[col]])\n\n            # WARNING: this takes DAYS for only 100k tweets!\n            # series = df[col].copy()\n            # for i, value in series.iteritems():   \n\n            #     if isinstance(value, basestring):\n            #         series[i] = str(value.encode(encoding))\n            # df[col] = series\n    if verbosity:\n        pbar.finish()\n    return df", "response": "Encode each element of a dataframe in a single thread."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload all_tweets. csv and run normalize dropna encode before dumping to cleaned_tweets. csv. gz", "response": "def run(verbosity=1):\n    \"\"\"Load all_tweets.csv and run normalize, dropna, encode before dumping to cleaned_tweets.csv.gz\n\n    Many columns have \"mixed type\" to `read_csv` should set `low_memory` to False to ensure they're loaded accurately\n    >>> df2 = pd.read_csv(os.path.join(DATA_PATH, 'cleaned_tweets.csv.gz'), index_col='id', compression='gzip', quotechar='\"', quoting=pd.io.common.csv.QUOTE_NONNUMERIC, low_memory=False)\n    /home/hobs/.virtualenvs/twip/local/lib/python2.7/site-packages/IPython/core/interactiveshell.py:2723:\n    DtypeWarning: Columns (74,82,84,105,114,115,116,117,118,119,120,121,122,123,125,126,127,128,129,130,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,149,150,151,152,199,200,202,203,210,211,214,215,223,231,232,238) have mixed types. Specify dtype option on import or set low_memory=False.\n       interactivity=interactivity, compiler=compiler, result=result)\n    \"\"\"\n    filepath = os.path.join(DATA_PATH, 'all_tweets.csv')\n    # this should load 100k tweets in about a minute\n    # check the file size and estimate load time from that (see scritps/cat_tweets.py)\n    print('Loading tweets from {} (could take a minute or so)...'.format(filepath))\n    df = pd.read_csv(filepath, encoding='utf-8', engine='python')\n    if 'id' in df.columns:\n        df = df.set_index('id')\n    df = normalize(df)\n    df = dropna(df)\n    df = encode(df, verbosity=verbosity)\n    df = clean_labels(df)\n    df.to_csv(os.path.join(DATA_PATH, 'cleaned_tweets.csv.gz'), compression='gzip',\n              quotechar='\"', quoting=pd.io.common.csv.QUOTE_NONNUMERIC)\n    # the round-trip to disk cleans up encoding issues so encoding no longer needs to be specified on load\n    df = pd.read_csv(os.path.join(DATA_PATH, 'cleaned_tweets.csv.gz'), index_col='id', compression='gzip',\n                     quotechar='\"', quoting=pd.io.common.csv.QUOTE_NONNUMERIC, low_memory=False)\n    df.to_csv(os.path.join(DATA_PATH, 'cleaned_tweets.csv.gz'), compression='gzip',\n              quotechar='\"', quoting=pd.io.common.csv.QUOTE_NONNUMERIC)\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef data_worker(**kwargs):\n    if kwargs is not None:\n        if \"function\" in kwargs:\n            function = kwargs[\"function\"]\n        else:\n            Exception(\"Invalid arguments, no function specified\")\n        if \"input\" in kwargs:\n            input_queue = kwargs[\"input\"]\n        else:\n            Exception(\"Invalid Arguments, no input queue\")\n        if \"output\" in kwargs:\n            output_map = kwargs[\"output\"]\n        else:\n            Exception(\"Invalid Arguments, no output map\")\n        if \"token\" in kwargs:\n            argsdict = {\"quandl_token\": kwargs[\"token\"]}\n\n        else:\n            if \"Quandl\" in function.__module__:\n                Exception(\"Invalid Arguments, no Quandl token\")\n        if (\"source\" and \"begin\" and \"end\") in kwargs:\n            argsdict = {\"data_source\": kwargs[\"source\"], \"begin\": kwargs[\"begin\"], \"end\": kwargs[\"end\"]}\n        else:\n            if \"pandas.io.data\" in function.__module__:\n                Exception(\"Invalid Arguments, no pandas data source specified\")\n        if (\"source\" in kwargs) and ((\"begin\" and \"end\") not in kwargs):\n            argsdict = {\"data_source\": kwargs[\"source\"]}\n        else:\n            if \"pandas.io.data\" in function.__module__:\n                Exception(\"Invalid Arguments, no pandas data source specified\")\n    else:\n        Exception(\"Invalid Arguments\")\n\n    retries = 5\n    while not input_queue.empty():\n        data_key = input_queue.get()\n        get_data(function, data_key, output_map, retries, argsdict)", "response": "Function to be spawned concurrently"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfunction to download a dataframe from Yahoo Financial and return a dataframe", "response": "def get_data(data_get, data_key, output_map, retries_left, argdict):\n        \"\"\"\n        Function to use Python Pandas and / or Quandl to download a dataframe\n        Insert resulting dataframe into output map\n        \"\"\"\n        if retries_left <= 0:\n            print(data_key + \" Failed to download.\")\n            return\n\n        \"\"\"\n        Identify type of function to use, insert result into output map\n        \"\"\"\n        if \"Quandl\" in data_get.__module__:\n            output_map[data_key] = data_get(data_key, authtoken=argdict[\"quandl_token\"])\n            return\n\n        if \"pandas.io.data\" in data_get.__module__:\n            # Verify we are not dealing with options\n            if 'get_call_data' not in dir(data_get):\n                if (\"source\" and \"begin\" and \"end\") in argdict:\n                    try:\n                        output_map[data_key] = data_get(data_key, argdict[\"data_source\"], argdict[\"begin\"], argdict[\"end\"])\n                        return\n                    except:\n                        print(data_key + \" failed to download. Retrying up to \" + retries_left.__str__() + \" more times...\")\n                else:\n                    try:\n                        output_map[data_key] = data_get(data_key, argdict[\"data_source\"])\n                        return\n                    except:\n                        print(data_key + \" failed to download. Retrying up to \" + retries_left.__str__() + \" more times...\")\n            # Verify we are dealing with options\n            if 'get_call_data' in dir(data_get):\n                try:\n                    # Note options data will always be pulled from yahoo\n                    temp = data_get(data_key, 'yahoo')\n                    # For simplicities sake assume user wants all options data\n                    output_map[data_key] = temp.get_all_data()\n                    return\n                except:\n                    print(data_key + \" options failed to download. Retrying up to \" + retries_left.__str__() + \" more times...\")\n                    print(\"WARNING: If your version of Pandas is not up to date this may fail!\")\n\n        \"\"\"\n        Retry at random times progressively slower in case of failures when number of retries remaining gets low\n        \"\"\"\n        if (retries_left == 3):\n            time.sleep(randrange(0, 4))\n        if (retries_left == 2):\n            time.sleep(randrange(2, 6))\n        if (retries_left == 1):\n            time.sleep(randrange(5, 15))\n        get_data(data_get, data_key, output_map, (retries_left-1), argdict)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nworking through the keys to look up sequentially", "response": "def consume_keys(self):\n        \"\"\"\n        Work through the keys to look up sequentially\n        \"\"\"\n        print(\"\\nLooking up \" + self.input_queue.qsize().__str__() + \" keys from \" + self.source_name + \"\\n\")\n        self.data_worker(**self.worker_args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef consume_keys_asynchronous_processes(self):\n        print(\"\\nLooking up \" + self.input_queue.qsize().__str__() + \" keys from \" + self.source_name + \"\\n\")\n        jobs = multiprocessing.cpu_count()*4 if (multiprocessing.cpu_count()*4 < self.input_queue.qsize()) \\\n            else self.input_queue.qsize()\n\n        pool = multiprocessing.Pool(processes=jobs,  maxtasksperchild=10)\n        for x in range(jobs):\n            pool.apply(self.data_worker, [], self.worker_args)\n\n        pool.close()\n        pool.join()", "response": "This function is called by the process_input method to process the keys in the input queue asynchronously using multiple processes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef consume_keys_asynchronous_threads(self):\n        print(\"\\nLooking up \" + self.input_queue.qsize().__str__() + \" keys from \" + self.source_name + \"\\n\")\n        jobs = multiprocessing.cpu_count()*4 if (multiprocessing.cpu_count()*4 < self.input_queue.qsize()) \\\n            else self.input_queue.qsize()\n\n        pool = ThreadPool(jobs)\n\n        for x in range(jobs):\n            pool.apply(self.data_worker, [], self.worker_args)\n\n        pool.close()\n        pool.join()", "response": "This function is used to consume the keys asynchronously using multiple threads"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unpack(self, to_unpack):\n\n        # Python 3 lacks basestring type, work around below\n        try:\n            isinstance(to_unpack, basestring)\n        except NameError:\n            basestring = str\n\n        # Base Case\n        if isinstance(to_unpack, basestring):\n            self.input_queue.put(to_unpack)\n            return\n\n        for possible_key in to_unpack:\n            if isinstance(possible_key, basestring):\n                self.input_queue.put(possible_key)\n\n            elif sys.version_info >= (3, 0):\n                if isinstance(possible_key, collections.abc.Container) and not isinstance(possible_key, basestring):\n                    self.unpack(possible_key)\n                else:\n                    raise Exception(\"A type that is neither a string or a container was passed to unpack. \"\n                                    \"Aborting!\")\n\n            else:\n                if isinstance(possible_key, collections.Container) and not isinstance(possible_key, basestring):\n                    self.unpack(possible_key)\n                else:\n                    raise Exception(\"A type that is neither a string or a container was passed to unpack. \"\n                                    \"Aborting!\")", "response": "Unpacks the base class of the object to_unpack and returns the base class of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting data source to Quandl", "response": "def set_source_quandl(self, quandl_token):\n        \"\"\"\n        Set data source to Quandl\n        \"\"\"\n        self.data_worker = data_worker\n        self.worker_args = {\"function\": Quandl.get, \"input\": self.input_queue, \"output\": self.output_map,\n                            \"token\": quandl_token}\n        self.source_name = \"Quandl\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_source_google_finance(self):\n        self.data_worker = data_worker\n        self.worker_args = {\"function\": pandas.io.data.DataReader, \"input\": self.input_queue, \"output\": self.output_map,\n                            \"source\": 'google'}\n        self.source_name = \"Google Finance\"", "response": "Set data source to Google Finance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_source_yahoo_options(self):\n        self.data_worker = data_worker\n        self.worker_args = {\"function\": Options, \"input\": self.input_queue, \"output\": self.output_map,\n                            \"source\": 'yahoo'}\n        self.source_name = \"Yahoo Finance Options\"", "response": "Set data source to yahoo finance specifically to download financial options data\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_jquery(func):\n\n    @wraps(func)\n    def wrapped(browser, *args, **kwargs):\n        \"\"\"Run the function, loading jQuery if needed.\"\"\"\n\n        try:\n            return func(browser, *args, **kwargs)\n        except WebDriverException as ex:\n            if not is_jquery_not_defined_error(ex.msg):\n                raise\n\n            load_script(browser, JQUERY)\n\n            @wait_for\n            def jquery_available():\n                \"\"\"Assert that jQuery has loaded.\"\"\"\n                try:\n                    return browser.execute_script('return $')\n                except WebDriverException:\n                    raise AssertionError(\"jQuery is not loaded\")\n\n            jquery_available()\n\n            return func(browser, *args, **kwargs)\n\n    return wrapped", "response": "Decorator that ensures a function is run with jQuery loaded."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding a single HTML element using jQuery - style selectors.", "response": "def find_element_by_jquery(browser, selector):\n    \"\"\"Find a single HTML element using jQuery-style selectors.\"\"\"\n    elements = find_elements_by_jquery(browser, selector)\n    if not elements:\n        raise AssertionError(\"No matching element found.\")\n    if len(elements) > 1:\n        raise AssertionError(\"Multiple matching elements found.\")\n    return elements[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nasserting an element exists matching the given selector.", "response": "def check_element_by_selector(self, selector):\n    \"\"\"Assert an element exists matching the given selector.\"\"\"\n    elems = find_elements_by_jquery(world.browser, selector)\n    if not elems:\n        raise AssertionError(\"Expected matching elements, none found.\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nassert an element does not exist matching the given selector.", "response": "def check_no_element_by_selector(self, selector):\n    \"\"\"Assert an element does not exist matching the given selector.\"\"\"\n    elems = find_elements_by_jquery(world.browser, selector)\n    if elems:\n        raise AssertionError(\"Expected no matching elements, found {}.\".format(\n            len(elems)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait_for_element_by_selector(self, selector, seconds):\n\n    def assert_element_present():\n        \"\"\"Assert an element matching the given selector exists.\"\"\"\n        if not find_elements_by_jquery(world.browser, selector):\n            raise AssertionError(\"Expected a matching element.\")\n\n    wait_for(assert_element_present)(timeout=int(seconds))", "response": "Assert an element with the given selector exists within the given time\n    period."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef count_elements_exactly_by_selector(self, number, selector):\n    elems = find_elements_by_jquery(world.browser, selector)\n    number = int(number)\n    if len(elems) != number:\n        raise AssertionError(\"Expected {} elements, found {}\".format(\n            number, len(elems)))", "response": "Assert n elements exist matching the given selector."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfill in the form element matching the CSS selector.", "response": "def fill_in_by_selector(self, selector, value):\n    \"\"\"Fill in the form element matching the CSS selector.\"\"\"\n    elem = find_element_by_jquery(world.browser, selector)\n    elem.clear()\n    elem.send_keys(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsubmit the form matching the CSS selector.", "response": "def submit_by_selector(self, selector):\n    \"\"\"Submit the form matching the CSS selector.\"\"\"\n    elem = find_element_by_jquery(world.browser, selector)\n    elem.submit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the checkbox matching the CSS selector.", "response": "def check_by_selector(self, selector):\n    \"\"\"Check the checkbox matching the CSS selector.\"\"\"\n    elem = find_element_by_jquery(world.browser, selector)\n    if not elem.is_selected():\n        elem.click()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclicking the element matching the CSS selector.", "response": "def click_by_selector(self, selector):\n    \"\"\"Click the element matching the CSS selector.\"\"\"\n    # No need for separate button press step with selector style.\n    elem = find_element_by_jquery(world.browser, selector)\n    elem.click()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nnavigate to the href of the element matching the CSS selector.", "response": "def follow_link_by_selector(self, selector):\n    \"\"\"\n    Navigate to the href of the element matching the CSS selector.\n\n    N.B. this does not click the link, but changes the browser's URL.\n    \"\"\"\n    elem = find_element_by_jquery(world.browser, selector)\n    href = elem.get_attribute('href')\n    world.browser.get(href)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nasserting the option matching the CSS selector is selected.", "response": "def is_selected_by_selector(self, selector):\n    \"\"\"Assert the option matching the CSS selector is selected.\"\"\"\n    elem = find_element_by_jquery(world.browser, selector)\n    if not elem.is_selected():\n        raise AssertionError(\"Element expected to be selected.\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select_by_selector(self, selector):\n    option = find_element_by_jquery(world.browser, selector)\n    selectors = find_parents_by_jquery(world.browser, selector)\n    if not selectors:\n        raise AssertionError(\"No parent element found for the option.\")\n    selector = selectors[0]\n    selector.click()\n    sleep(0.3)\n    option.click()\n    if not option.is_selected():\n        raise AssertionError(\n            \"Option should have become selected after clicking it.\")", "response": "Select the option matching the CSS selector."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_filter_calculation(self):\n        inputs = {\n            'cif': self.inputs.cif,\n            'code': self.inputs.cif_filter,\n            'parameters': self.inputs.cif_filter_parameters,\n            'metadata': {\n                'options': self.inputs.options.get_dict(),\n            }\n        }\n\n        calculation = self.submit(CifFilterCalculation, **inputs)\n        self.report('submitted {}<{}>'.format(CifFilterCalculation.__name__, calculation.uuid))\n\n        return ToContext(cif_filter=calculation)", "response": "Run the CifFilterCalculation on the CifData input node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef inspect_filter_calculation(self):\n        try:\n            node = self.ctx.cif_filter\n            self.ctx.cif = node.outputs.cif\n        except exceptions.NotExistent:\n            self.report('aborting: CifFilterCalculation<{}> did not return the required cif output'.format(node.uuid))\n            return self.exit_codes.ERROR_CIF_FILTER_FAILED", "response": "Inspect the result of the CifFilterCalculation verifying that it produced a CifData output node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the CifSelectCalculation on the CifData output node of the CifFilterCalculation.", "response": "def run_select_calculation(self):\n        \"\"\"Run the CifSelectCalculation on the CifData output node of the CifFilterCalculation.\"\"\"\n        inputs = {\n            'cif': self.ctx.cif,\n            'code': self.inputs.cif_select,\n            'parameters': self.inputs.cif_select_parameters,\n            'metadata': {\n                'options': self.inputs.options.get_dict(),\n            }\n        }\n\n        calculation = self.submit(CifSelectCalculation, **inputs)\n        self.report('submitted {}<{}>'.format(CifSelectCalculation.__name__, calculation.uuid))\n\n        return ToContext(cif_select=calculation)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef inspect_select_calculation(self):\n        try:\n            node = self.ctx.cif_select\n            self.ctx.cif = node.outputs.cif\n        except exceptions.NotExistent:\n            self.report('aborting: CifSelectCalculation<{}> did not return the required cif output'.format(node.uuid))\n            return self.exit_codes.ERROR_CIF_SELECT_FAILED", "response": "Inspect the result of the CifSelectCalculation verifying that it produced a CifData output node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_cif_structure(self):\n        from aiida_codtools.workflows.functions.primitive_structure_from_cif import primitive_structure_from_cif\n\n        if self.ctx.cif.has_unknown_species:\n            self.ctx.exit_code = self.exit_codes.ERROR_CIF_HAS_UNKNOWN_SPECIES\n            self.report(self.ctx.exit_code.message)\n            return\n\n        if self.ctx.cif.has_undefined_atomic_sites:\n            self.ctx.exit_code = self.exit_codes.ERROR_CIF_HAS_UNDEFINED_ATOMIC_SITES\n            self.report(self.ctx.exit_code.message)\n            return\n\n        if self.ctx.cif.has_attached_hydrogens:\n            self.ctx.exit_code = self.exit_codes.ERROR_CIF_HAS_ATTACHED_HYDROGENS\n            self.report(self.ctx.exit_code.message)\n            return\n\n        parse_inputs = {\n            'cif': self.ctx.cif,\n            'parse_engine': self.inputs.parse_engine,\n            'site_tolerance': self.inputs.site_tolerance,\n            'symprec': self.inputs.symprec,\n        }\n\n        try:\n            structure, node = primitive_structure_from_cif.run_get_node(**parse_inputs)\n        except Exception:  # pylint: disable=broad-except\n            self.ctx.exit_code = self.exit_codes.ERROR_CIF_STRUCTURE_PARSING_FAILED\n            self.report(self.ctx.exit_code.message)\n            return\n\n        if node.is_failed:\n            self.ctx.exit_code = self.exit_codes(node.exit_status)  # pylint: disable=too-many-function-args\n            self.report(self.ctx.exit_code.message)\n        else:\n            self.ctx.structure = structure", "response": "Parse a StructureData from the cleaned CifData returned by the CifSelectCalculation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a Node of a given class and given value.", "response": "def get_input_node(cls, value):\n    \"\"\"Return a `Node` of a given class and given value.\n\n    If a `Node` of the given type and value already exists, that will be returned, otherwise a new one will be created,\n    stored and returned.\n\n    :param cls: the `Node` class\n    :param value: the value of the `Node`\n    \"\"\"\n    from aiida import orm\n\n    if cls in (orm.Bool, orm.Float, orm.Int, orm.Str):\n\n        result = orm.QueryBuilder().append(cls, filters={'attributes.value': value}).first()\n\n        if result is None:\n            node = cls(value).store()\n        else:\n            node = result[0]\n\n    elif cls is orm.Dict:\n        result = orm.QueryBuilder().append(cls, filters={'attributes': {'==': value}}).first()\n\n        if result is None:\n            node = cls(dict=value).store()\n        else:\n            node = result[0]\n\n    else:\n        raise NotImplementedError\n\n    return node"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nested_get(dictionary, keys):\n    return reduce(lambda d, k: d[k], keys, dictionary)", "response": "Get value in dictionary for nested keys"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbinding to filters form.", "response": "def bind(self, form):\n        \"\"\"Bind to filters form.\"\"\"\n        field = self.field(default=self.default, **self.field_kwargs)\n        form._fields[self.name] = field.bind(form, self.name, prefix=form._prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply(self, collection, data):\n        value = self.value(data)\n        if value is self.default:\n            return collection\n        return [o for o in collection if getattr(o, self.name, None) == value]", "response": "Filter collection by the value of the attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef human_filesize(i):\n    bytes = float(i)\n    if bytes < 1024:\n        return u\"%d Byte%s\" % (bytes, bytes != 1 and u\"s\" or u\"\")\n    if bytes < 1024 * 1024:\n        return u\"%.1f KB\" % (bytes / 1024)\n    if bytes < 1024 * 1024 * 1024:\n        return u\"%.1f MB\" % (bytes / (1024 * 1024))\n    return u\"%.1f GB\" % (bytes / (1024 * 1024 * 1024))", "response": "human - readable file size"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a datetime to a human readable representation with how old this entry is information", "response": "def dt2naturaltimesince(dt):\n    \"\"\"\n    datetime to a human readable representation with how old this entry is information\n    e.g.:\n        Jan. 27, 2016, 9:04 p.m. (31\u00a0minutes ago)\n    \"\"\"\n    date = defaultfilters.date(dt, _(\"DATETIME_FORMAT\"))\n    nt = humanize.naturaltime(dt)\n    return \"%s (%s)\" % (date, nt)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert nanoseconds to natural readable representation of the entry.", "response": "def ns2naturaltimesince(ns):\n    \"\"\"\n    nanoseconds to a human readable representation with how old this entry is information\n    e.g.:\n        Jan. 27, 2016, 9:04 p.m. (31\u00a0minutes ago)\n    \"\"\"\n    timestamp = ns / 1000000000\n    dt = datetime.datetime.utcfromtimestamp(timestamp)\n    return dt2naturaltimesince(dt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_config_path():\n    dir_path = (os.getenv('APPDATA') if os.name == \"nt\"\n                else os.path.expanduser('~'))\n    return os.path.join(dir_path, '.vtjp')", "response": "Put together the default configuration path based on OS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_config():\n    config = configparser.RawConfigParser(allow_no_value=True)\n    config.read(get_config_path())\n    if not config.has_section('credentials'):\n        config.add_section('credentials')\n        config.set('credentials', 'key', '')\n        config.set('credentials', 'secret', '')\n        write_config(config)\n    return config", "response": "Read configuration file and return it as a ConfigParser object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint json document as table", "response": "def print_table(document, *columns):\n    \"\"\" Print json document as table \"\"\"\n    headers = []\n    for _, header in columns:\n        headers.append(header)\n    table = []\n    for element in document:\n        row = []\n        for item, _ in columns:\n            if item in element:\n                row.append(element[item])\n            else:\n                row.append(None)\n        table.append(row)\n    print(tabulate.tabulate(table, headers))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef makeproperty(ns, cls=None, name=None, docstring='', descendant=True):\n        def get_property(self):\n            \"\"\"\n            A generic property getter.\n            \"\"\"\n            if cls is None:\n                xpath = '%s:%s' % (ns, name)\n            else:\n                xpath = '%s:%s' % (ns, cls.__name__)\n\n            xpath = self._node.xpath(xpath, namespaces=SLDNode._nsmap)\n            if len(xpath) == 1:\n                if cls is None:\n                    return xpath[0].text\n                else:\n                    elem = cls.__new__(cls)\n                    cls.__init__(elem, self, descendant=descendant)\n                    return elem\n            else:\n                return None\n\n        def set_property(self, value):\n            \"\"\"\n            A generic property setter.\n            \"\"\"\n            if cls is None:\n                xpath = '%s:%s' % (ns, name)\n            else:\n                xpath = '%s:%s' % (ns, cls.__name__)\n\n            xpath = self._node.xpath(xpath, namespaces=SLDNode._nsmap)\n            if len(xpath) == 1:\n                if cls is None:\n                    xpath[0].text = value\n                else:\n                    xpath[0] = value._node\n            else:\n                if cls is None:\n                    elem = self._node.makeelement('{%s}%s' % (SLDNode._nsmap[ns], name), nsmap=SLDNode._nsmap)\n                    elem.text = value\n                    self._node.append(elem)\n                else:\n                    self._node.append(value._node)\n\n        def del_property(self):\n            \"\"\"\n            A generic property deleter.\n            \"\"\"\n            if cls is None:\n                xpath = '%s:%s' % (ns, name)\n            else:\n                xpath = '%s:%s' % (ns, cls.__name__)\n\n            xpath = self._node.xpath(xpath, namespaces=SLDNode._nsmap)\n            if len(xpath) == 1:\n                self._node.remove(xpath[0])\n\n        return property(get_property, set_property, del_property, docstring)", "response": "This function creates a property on an instance of an SLDNode."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_or_create_element(self, ns, name):\n        if len(self._node.xpath('%s:%s' % (ns, name), namespaces=SLDNode._nsmap)) == 1:\n            return getattr(self, name)\n\n        return self.create_element(ns, name)", "response": "Attempt to get the only child element from this SLDNode and create it if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_element(self, ns, name):\n        elem = self._node.makeelement('{%s}%s' % (SLDNode._nsmap[ns], name), nsmap=SLDNode._nsmap)\n        self._node.append(elem)\n\n        return getattr(self, name)", "response": "Create an element as a child of this node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_cssparameter(self, name=None, value=None):\n        elem = self._node.makeelement('{%s}CssParameter' % SLDNode._nsmap['sld'], nsmap=SLDNode._nsmap)\n        self._node.append(elem)\n\n        if not (name is None or value is None):\n            elem.attrib['name'] = name\n            elem.text = value\n\n        return CssParameter(self, len(self._node) - 1)", "response": "Create a new style parameter node and attach it to the DOM."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nnormalize this node prior to validation. This is required, as the ogc:Filter node must come before any symbolizer nodes. The SLD is modified in place.", "response": "def normalize(self):\n        \"\"\"\n        Normalize this node prior to validation. This is required, as the\n        ogc:Filter node must come before any symbolizer nodes. The SLD\n        is modified in place.\n        \"\"\"\n        order = [\n            'sld:Title', 'ogc:Filter', 'sld:MinScaleDenominator',\n            'sld:MaxScaleDenominator', 'sld:PolygonSymbolizer',\n            'sld:LineSymbolizer', 'sld:TextSymbolizer', 'sld:PointSymbolizer']\n        for item in order:\n            xpath = self._node.xpath(item, namespaces=SLDNode._nsmap)\n            for xitem in xpath:\n                # move this to the end\n                self._node.remove(xitem)\n                self._node.append(xitem)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_filter(self, propname=None, comparitor=None, value=None):\n        if propname is None or comparitor is None or value is None:\n            return None\n\n        rfilter = self.create_element('ogc', 'Filter')\n        ftype = None\n        if comparitor == '==':\n            ftype = 'PropertyIsEqualTo'\n        elif comparitor == '<=':\n            ftype = 'PropertyIsLessThanOrEqualTo'\n        elif comparitor == '<':\n            ftype = 'PropertyIsLessThan'\n        elif comparitor == '>=':\n            ftype = 'PropertyIsGreaterThanOrEqualTo'\n        elif comparitor == '>':\n            ftype = 'PropertyIsGreaterThan'\n        elif comparitor == '!=':\n            ftype = 'PropertyIsNotEqualTo'\n        elif comparitor == '%':\n            ftype = 'PropertyIsLike'\n\n        if not ftype is None:\n            prop = PropertyCriterion(rfilter, ftype)\n            prop.PropertyName = propname\n            if not value is None:\n                prop.Literal = value\n            setattr(rfilter, ftype, prop)\n\n        return rfilter", "response": "Creates a new filter for this rule."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef normalize(self):\n        for i, rnode in enumerate(self._nodes):\n            rule = Rule(self, i - 1, descendant=False)\n            rule.normalize()", "response": "Normalize this node and all rules contained within. The SLD model is\n        modified in place."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new rule on this style.", "response": "def create_rule(self, title, symbolizer=None, MinScaleDenominator=None, MaxScaleDenominator=None):\n        \"\"\"\n        Create a L{Rule} object on this style. A rule requires a title and\n        symbolizer. If no symbolizer is specified, a PointSymbolizer will be\n        assigned to the rule.\n\n        @type       title: string\n        @param      title: The name of the new L{Rule}.\n        @type  symbolizer: L{Symbolizer} I{class}\n        @param symbolizer: The symbolizer type. This is the class object (as\n            opposed to a class instance) of the symbolizer to use.\n        @rtype: L{Rule}\n        @return: A newly created rule, attached to this FeatureTypeStyle.\n        \"\"\"\n        elem = self._node.makeelement('{%s}Rule' % SLDNode._nsmap['sld'], nsmap=SLDNode._nsmap)\n        self._node.append(elem)\n\n        rule = Rule(self, len(self._node) - 1)\n        rule.Title = title\n\n        if MinScaleDenominator is not None:\n            rule.MinScaleDenominator = MinScaleDenominator\n        if MaxScaleDenominator is not None:\n            rule.MaxScaleDenominator = MaxScaleDenominator\n\n        if symbolizer is None:\n            symbolizer = PointSymbolizer\n\n        sym = symbolizer(rule)\n        if symbolizer == PointSymbolizer:\n            gph = Graphic(sym)\n            mrk = Mark(gph)\n            mrk.WellKnownName = 'square'\n            fill = Fill(mrk)\n            fill.create_cssparameter('fill', '#ff0000')\n\n        elif symbolizer == LineSymbolizer:\n            stroke = Stroke(sym)\n            stroke.create_cssparameter('stroke', '#0000ff')\n\n        elif symbolizer == PolygonSymbolizer:\n            fill = Fill(sym)\n            fill.create_cssparameter('fill', '#AAAAAA')\n            stroke = Stroke(sym)\n            stroke.create_cssparameter('stroke', '#000000')\n            stroke.create_cssparameter('stroke-width', '1')\n\n        return rule"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(self):\n        self.normalize()\n\n        if self._node is None:\n            logging.debug('The node is empty, and cannot be validated.')\n            return False\n\n        if self._schema is None:\n            self._schema = XMLSchema(self._schemadoc)\n\n        is_valid = self._schema.validate(self._node)\n\n        for msg in self._schema.error_log:\n            logging.info('Line:%d, Column:%d -- %s', msg.line, msg.column, msg.message)\n\n        return is_valid", "response": "Validate the current SLD document against the SLD schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a named layer in this SLD.", "response": "def create_namedlayer(self, name):\n        \"\"\"\n        Create a L{NamedLayer} in this SLD.\n\n        @type  name: string\n        @param name: The name of the layer.\n        @rtype: L{NamedLayer}\n        @return: The named layer, attached to this SLD.\n        \"\"\"\n        namedlayer = self.get_or_create_element('sld', 'NamedLayer')\n        namedlayer.Name = name\n        return namedlayer"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing version of PyHardLinkBackup.", "response": "def cli(ctx):\n    \"\"\"PyHardLinkBackup\"\"\"\n    click.secho(\"\\nPyHardLinkBackup v%s\\n\" % PyHardLinkBackup.__version__, bg=\"blue\", fg=\"white\", bold=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlink helper files to given path", "response": "def helper(path):\n    \"\"\"\n    link helper files to given path\n    \"\"\"\n    if sys.platform.startswith(\"win\"):\n        # link batch files\n        src_path = os.path.join(PHLB_BASE_DIR, \"helper_cmd\")\n    elif sys.platform.startswith(\"linux\"):\n        # link shell scripts\n        src_path = os.path.join(PHLB_BASE_DIR, \"helper_sh\")\n    else:\n        print(\"TODO: %s\" % sys.platform)\n        return\n\n    if not os.path.isdir(src_path):\n        raise RuntimeError(\"Helper script path not found here: '%s'\" % src_path)\n\n    for entry in scandir(src_path):\n        print(\"_\" * 79)\n        print(\"Link file: '%s'\" % entry.name)\n        src = entry.path\n        dst = os.path.join(path, entry.name)\n        if os.path.exists(dst):\n            print(\"Remove old file '%s'\" % dst)\n            try:\n                os.remove(dst)\n            except OSError as err:\n                print(\"\\nERROR:\\n%s\\n\" % err)\n                continue\n\n        print(\"source.....: '%s'\" % src)\n        print(\"destination: '%s'\" % dst)\n        try:\n            os.link(src, dst)\n        except OSError as err:\n            print(\"\\nERROR:\\n%s\\n\" % err)\n            continue"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef backup(path, name=None):\n    from PyHardLinkBackup.phlb.phlb_main import backup\n\n    backup(path, name)", "response": "Start a Backup run"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef verify(backup_path, fast):\n    from PyHardLinkBackup.phlb.verify import verify_backup\n\n    verify_backup(backup_path, fast)", "response": "Verify a existing backup"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef literal_to_dict(value):\n    if isinstance(value, Literal):\n        if value.language is not None:\n            return {\"@value\": str(value), \"@language\": value.language}\n        return value.toPython()\n    elif isinstance(value, URIRef):\n        return {\"@id\": str(value)}\n    elif value is None:\n        return None\n    return str(value)", "response": "Transform an object value into a dict readable value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntransform a JSON + LD dictionary into a RDFLib object", "response": "def dict_to_literal(dict_container: dict):\n    \"\"\" Transforms a JSON+LD PyLD dictionary into\n    an RDFLib object\"\"\"\n    if isinstance(dict_container[\"@value\"], int):\n        return dict_container[\"@value\"],\n    else:\n        return dict_container[\"@value\"], dict_container.get(\"@language\", None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the filepath to backup this file.", "response": "def set_src_filepath(self, src_dir_path):\n        \"\"\"\n        Set one filepath to backup this file.\n        Called for every file in the source directory.\n\n        :argument src_dir_path: filesystem_walk.DirEntryPath() instance\n        \"\"\"\n        log.debug(\"set_src_filepath() with: '%s'\", src_dir_path)\n        self.abs_src_filepath = src_dir_path.resolved_path\n        log.debug(\" * abs_src_filepath: %s\" % self.abs_src_filepath)\n\n        if self.abs_src_filepath is None:\n            log.info(\"Can't resolve source path: %s\", src_dir_path)\n            return\n\n        self.sub_filepath = self.abs_src_filepath.relative_to(self.abs_src_root)\n        log.debug(\" * sub_filepath: %s\" % self.sub_filepath)\n\n        self.sub_path = self.sub_filepath.parent\n        log.debug(\" * sub_path: %s\" % self.sub_path)\n\n        self.filename = self.sub_filepath.name\n        log.debug(\" * filename: %s\" % self.filename)\n\n        self.abs_dst_path = Path2(self.abs_dst_root, self.sub_path)\n        log.debug(\" * abs_dst_path: %s\" % self.abs_dst_path)\n\n        self.abs_dst_filepath = Path2(self.abs_dst_root, self.sub_filepath)\n        log.debug(\" * abs_dst_filepath: %s\" % self.abs_dst_filepath)\n\n        self.abs_dst_hash_filepath = Path2(\"%s%s%s\" % (self.abs_dst_filepath, os.extsep, phlb_config.hash_name))\n        log.debug(\" * abs_dst_hash_filepath: %s\" % self.abs_dst_hash_filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cryptodome_encrypt(cipher_factory, plaintext, key, iv):\n    encryptor = cipher_factory(key, iv)\n    return encryptor.encrypt(plaintext)", "response": "Use a Pycryptodome cipher factory to encrypt data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _cryptodome_decrypt(cipher_factory, ciphertext, key, iv):\n    decryptor = cipher_factory(key, iv)\n    return decryptor.decrypt(ciphertext)", "response": "Use a Pycryptodome cipher factory to decrypt data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cryptography_encrypt(cipher_factory, plaintext, key, iv):\n    encryptor = cipher_factory(key, iv).encryptor()\n    return encryptor.update(plaintext) + encryptor.finalize()", "response": "Use a cryptography cipher factory to encrypt data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing a cryptography cipher factory to decrypt data.", "response": "def _cryptography_decrypt(cipher_factory, ciphertext, key, iv):\n    \"\"\"Use a cryptography cipher factory to decrypt data.\n\n    :param cipher_factory: Factory callable that builds a cryptography Cipher\n        instance based on the key and IV\n    :type cipher_factory: callable\n    :param bytes ciphertext: Ciphertext data to decrypt\n    :param bytes key: Encryption key\n    :param bytes IV: Initialization vector\n    :returns: Decrypted plaintext\n    :rtype: bytes\n    \"\"\"\n    decryptor = cipher_factory(key, iv).decryptor()\n    return decryptor.update(ciphertext) + decryptor.finalize()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generic_encrypt(cipher_factory_map, plaintext, key, iv):\n    if backend is None:\n        raise PysnmpCryptoError('Crypto backend not available')\n\n    return _ENCRYPT_MAP[backend](cipher_factory_map[backend],\n                                 plaintext, key, iv)", "response": "Encrypt data using the available backend."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generic_decrypt(cipher_factory_map, ciphertext, key, iv):\n    if backend is None:\n        raise PysnmpCryptoError('Crypto backend not available')\n\n    return _DECRYPT_MAP[backend](cipher_factory_map[backend],\n                                 ciphertext, key, iv)", "response": "This function will decrypt data using the available backend."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prepare_disks(self, disks_name):\r\n        fstab = '/etc/fstab'\r\n        for disk in tqdm(disks_name.split(',')):\r\n            sudo('umount /dev/{0}'.format(disk), warn_only=True)\r\n            if sudo('mkfs.xfs -f /dev/{0}'.format(disk), warn_only=True).failed:\r\n                sudo('apt-get update')\r\n                sudo('apt-get -y install xfsprogs')\r\n                sudo('mkfs.xfs -f /dev/{0}'.format(disk))\r\n            sudo('mkdir -p /srv/node/{0}'.format(disk))\r\n            files.append(\r\n                fstab, '/dev/{0} /srv/node/{1} xfs noatime,nodiratime,nobarrier,logbufs=8 0 2'.format(disk, disk), use_sudo=True)\r\n            sudo('mount /srv/node/{0}'.format(disk))", "response": "format disks to xfs and mount it"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps HTTPConnection.request. On exception it calls exception_fn with the exception object. If exception_fn is None, it re-raises the exception. If notimeout is True, create a new connection (regardless of self.reuseconnection setting) that uses the global default timeout for sockets (usually None).", "response": "def request(self,\n                method,\n                path,\n                body=None,\n                headers={},\n                exception_fn=None,\n                notimeout=False,\n                verify=True):\n        \"\"\"Wraps HTTPConnection.request. On exception it calls exception_fn\n        with the exception object. If exception_fn is None, it re-raises the\n        exception. If notimeout is True, create a new connection (regardless of\n        self.reuseconnection setting) that uses the global default timeout for\n        sockets (usually None).\"\"\"\n        # This needs to be done first because self.session may be None\n        if not self.reuseconnection or notimeout:\n            self.close()\n            self.session = Session()\n\n        allheaders = headers\n        allheaders.update(self.session.headers)\n\n        try:\n            if self.curldebug:\n                # output request as a curl call\n                def escape(s):\n                    \"\"\"escape single quotes for bash\"\"\"\n                    return s.replace(\"'\", \"'\\\\''\")\n\n                self.log.debug(\n                    \"curl '{1}{2}' -X {3} -m {4} {5} {6}\".format(\n                        'https' if self.https else 'http',\n                        self.host,\n                        path,\n                        method,\n                        self.httptimeout,\n                        ' '.join(['-H \\'{0}: {1}\\''.format(escape(h), escape(allheaders[h]))\n                                  for h in allheaders]),\n                        '' if body is None else '-d \\'' + escape(body) + '\\''))\n            else:\n                self.log.debug(\"%s %s\\nHost: %s\\nHeaders: %s\" % (\n                    method,\n                    path,\n                    self.host,\n                    allheaders))\n                if body is not None:\n                    self.log.debug(\"Body: %s\" % body)\n            URI = self.host + path\n            prepped = self.session.prepare_request(\n                Request(method, URI, data=body, headers=headers)\n            )\n\n            response = self.session.send(\n                prepped,\n                verify=verify,\n                timeout=None if notimeout else self.httptimeout\n            )\n            return response.text, response\n\n        except Exception:\n            self.close()\n            ex = sys.exc_info()[1]\n            if exception_fn is not None:\n                exception_fn(ex)\n            else:\n                raise ex"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_file(cls, file_path):\n        with open(os.path.abspath(file_path), 'rt') as f:\n            s = Sudoku(f.read().strip())\n        return s", "response": "Load a Sudoku from file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_from_string(string_input):\n        # Check if comment line is present.\n        read_lines = list(filter(None, string_input.split('\\n')))\n        if read_lines[0].startswith('#'):\n            comment = read_lines.pop(0)\n        else:\n            comment = ''\n\n        if len(read_lines) > 1:\n            # Assume that Sudoku is defined over several rows.\n            order = int(math.sqrt(len(read_lines)))\n        else:\n            # Sudoku is defined on one line.\n            order = int(math.sqrt(math.sqrt(len(read_lines[0]))))\n            read_lines = filter(lambda x: len(x) == (order ** 2), [read_lines[0][i:(i + order ** 2)] for\n                                i in utils.range_(len(read_lines[0])) if i % (order ** 2) == 0])\n        matrix = utils.get_list_of_lists(\n            order ** 2, order ** 2, fill_with=0)\n\n        for i, line in enumerate(read_lines):\n            line = line.strip()\n            for j, value in enumerate(line):\n                if value.isdigit() and int(value):\n                    matrix[i][j] = int(value)\n                else:\n                    matrix[i][j] = 0\n        return order, comment, matrix", "response": "Parses a Sudoku instance from a string containing the Sudoku."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef row_iter(self):\n        for k in utils.range_(self.side):\n            yield self.row(k)", "response": "Get an iterator over all rows in the Sudoku"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef col_iter(self):\n        for k in utils.range_(self.side):\n            yield self.col(k)", "response": "Get an iterator over all columns in the Sudoku"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef box(self, row, col):\n        box = []\n        box_i = (row // self.order) * self.order\n        box_j = (col // self.order) * self.order\n        for i in utils.range_(box_i, box_i + self.order):\n            for j in utils.range_(box_j, box_j + self.order):\n                box.append(self[i][j])\n        return box", "response": "Get the values of the box pertaining to the specified row and column of the Sudoku"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef box_iter(self):\n        for i in utils.range_(self.order):\n            for j in utils.range_(self.order):\n                yield self.box(i * 3, j * 3)", "response": "Get an iterator over all boxes in the Sudoku"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_cell(self, i, j, value):\n        bool_tests = [\n            value in self._possibles[i][j],\n            value in self._poss_rows[i],\n            value in self._poss_cols[j],\n            value in self._poss_box[(i // self.order) * self.order + (j // self.order)],\n            value not in self.row(i),\n            value not in self.col(j),\n            value not in self.box(i, j)\n        ]\n\n        if all(bool_tests):\n            self[i][j] = value\n        else:\n            raise SudokuHasNoSolutionError(\"This value cannot be set here!\")", "response": "Set a cell s value with a series of safety checks"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsolving the Sudoku. :param verbose: If the steps used for solving the Sudoku should be printed. Default is `False` :type verbose: bool :param allow_brute_force: If Dancing Links Brute Force method should be used if necessary. Default is `True` :type allow_brute_force: bool", "response": "def solve(self, verbose=False, allow_brute_force=True):\n        \"\"\"Solve the Sudoku.\n\n        :param verbose: If the steps used for solving the Sudoku\n                        should be printed. Default is `False`\n        :type verbose: bool\n        :param allow_brute_force: If Dancing Links Brute Force method\n                                  should be used if necessary. Default is `True`\n        :type allow_brute_force: bool\n\n        \"\"\"\n        while not self.is_solved:\n            # Update possibles arrays.\n            self._update()\n\n            # See if any position can be singled out.\n            singles_found = False or self._fill_naked_singles() or self._fill_hidden_singles()\n\n            # If singles_found is False, then no new uniquely defined cells were found\n            # and this solver cannot solve the Sudoku. We either use brute force or throw an error.\n            # Else, if singles_found is True, run another iteration to see if new singles have shown up.\n            if not singles_found:\n                if allow_brute_force:\n                    solution = None\n                    try:\n                        dlxs = DancingLinksSolver(copy.deepcopy(self._matrix))\n                        solutions = dlxs.solve()\n                        solution = next(solutions)\n                        more_solutions = next(solutions)\n                    except StopIteration as e:\n                        if solution is not None:\n                            self._matrix = solution\n                        else:\n                            raise SudokuHasNoSolutionError(\"Dancing Links solver could not find any solution.\")\n                    except Exception as e:\n                        raise SudokuHasNoSolutionError(\"Brute Force method failed.\")\n                    else:\n                        # We end up here if the second `next(solutions)` works,\n                        # i.e. if multiple solutions exist.\n                        raise SudokuHasMultipleSolutionsError(\"This Sudoku has multiple solutions!\")\n                    self.solution_steps.append(\"BRUTE FORCE - Dancing Links\")\n                    break\n                else:\n                    print(self)\n                    raise SudokuTooDifficultError(\"This Sudoku requires more advanced methods!\")\n        if verbose:\n            print(\"Sudoku solved in {0} iterations!\\n{1}\".format(len(self.solution_steps), self))\n            for step in self.solution_steps:\n                print(step)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlook for naked singles i. e. cells with ony one possible value.", "response": "def _fill_naked_singles(self):\n        \"\"\"Look for naked singles, i.e. cells with ony one possible value.\n\n        :return: If any Naked Single has been found.\n        :rtype: bool\n\n        \"\"\"\n        simple_found = False\n        for i in utils.range_(self.side):\n            for j in utils.range_(self.side):\n                if self[i][j] > 0:\n                    continue\n                p = self._possibles[i][j]\n                if len(p) == 1:\n                    self.set_cell(i, j, list(p)[0])\n                    self.solution_steps.append(self._format_step(\"NAKED\", (i, j), self[i][j]))\n                    simple_found = True\n                elif len(p) == 0:\n                    raise SudokuHasNoSolutionError(\"Error made! No possible value for ({0},{1})!\".format(i + 1, j + 1))\n\n        return simple_found"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _fill_hidden_singles(self):\n        for i in utils.range_(self.side):\n            box_i = (i // self.order) * self.order\n            for j in utils.range_(self.side):\n                box_j = (j // self.order) * self.order\n                # Skip if this cell is determined already.\n                if self[i][j] > 0:\n                    continue\n\n                # Look for hidden single in rows.\n                p = self._possibles[i][j]\n                for k in utils.range_(self.side):\n                    if k == j:\n                        continue\n                    p = p.difference(self._possibles[i][k])\n                if len(p) == 1:\n                    # Found a hidden single in a row!\n                    self.set_cell(i, j, p.pop())\n                    self.solution_steps.append(self._format_step(\"HIDDEN-ROW\", (i, j), self[i][j]))\n                    return True\n\n                # Look for hidden single in columns\n                p = self._possibles[i][j]\n                for k in utils.range_(self.side):\n                    if k == i:\n                        continue\n                    p = p.difference(self._possibles[k][j])\n                if len(p) == 1:\n                    # Found a hidden single in a column!\n                    self.set_cell(i, j, p.pop())\n                    self.solution_steps.append(self._format_step(\"HIDDEN-COL\", (i, j), self[i][j]))\n                    return True\n\n                # Look for hidden single in box\n                p = self._possibles[i][j]\n                for k in utils.range_(box_i, box_i + self.order):\n                    for kk in utils.range_(box_j, box_j + self.order):\n                        if k == i and kk == j:\n                            continue\n                        p = p.difference(self._possibles[k][kk])\n                if len(p) == 1:\n                    # Found a hidden single in a box!\n                    self.set_cell(i, j, p.pop())\n                    self.solution_steps.append(self._format_step(\"HIDDEN-BOX\", (i, j), self[i][j]))\n                    return True\n\n        return False", "response": "Look for hidden singles i. e. cells with only one unique possible value in row column or box."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a dict representation of a json object generate a DTSCollection object.", "response": "def parse(cls, resource, direction=\"children\", **additional_parameters) -> \"DtsCollection\":\n        \"\"\" Given a dict representation of a json object, generate a DTS Collection\n\n        :param resource:\n        :type resource: dict\n        :param direction: Direction of the hydra:members value\n        :return: DTSCollection parsed\n        :rtype: DtsCollection\n        \"\"\"\n\n        data = jsonld.expand(resource)\n        if len(data) == 0:\n            raise JsonLdCollectionMissing(\"Missing collection in JSON\")\n        data = data[0]\n\n        obj = cls(\n            identifier=resource[\"@id\"],\n            **additional_parameters\n        )\n\n        obj._parse_metadata(data)\n        obj._parse_members(data, direction=direction, **additional_parameters)\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_member(\n            cls,\n            obj: dict,\n            collection: \"DtsCollection\",\n            direction: str,\n            **additional_parameters) -> List[\"DtsCollection\"]:\n        \"\"\" Parse the member value of a Collection response\n        and returns the list of object while setting the graph\n        relationship based on `direction`\n\n        :param obj: PyLD parsed JSON+LD\n        :param collection: Collection attached to the member property\n        :param direction: Direction of the member (children, parent)\n        \"\"\"\n        members = []\n\n        for member in obj.get(str(_hyd.member), []):\n            subcollection = cls.parse(member, **additional_parameters)\n            if direction == \"children\":\n                subcollection.parents.update({collection})\n            members.append(subcollection)\n\n        return members", "response": "Parses the member value of a Collection response and returns the list of objects while setting the graph\n        relationship based on the direction"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncopying current_context into lines down until lineno.", "response": "def _filldown(self, lineno):\n        \"\"\"\n        Copy current_context into `lines` down up until lineno\n        \"\"\"\n        if self.line > lineno:\n            # XXX decorated functions make us jump backwards.\n            # understand this more\n            return\n\n        self.lines.extend(\n            self.current_context for _ in range(self.line, lineno))\n        self.line = lineno"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_section(self, node):\n        self._filldown(node.lineno)\n\n        # push a new context onto stack\n        self.context.append(node.name)\n        self._update_current_context()\n\n        for _ in map(self.visit, iter_child_nodes(node)):\n            pass\n\n        # restore current context\n        self.context.pop()\n        self._update_current_context()", "response": "Add a section to the current context."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _module_name(filename):\n\n        absfile = os.path.abspath(filename)\n        match = filename\n\n        for base in [''] + sys.path:\n            base = os.path.abspath(base)\n            if absfile.startswith(base):\n                match = absfile[len(base):]\n                break\n\n        return SUFFIX_RE.sub('', match).lstrip('/').replace('/', '.')", "response": "Try to find a module name for a file path by stripping off a prefix found in sys. modules."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a PythonFile from a dotted module name like a. b. c", "response": "def from_modulename(cls, module_name):\n        \"\"\"\n        Build a PythonFile given a dotted module name like a.b.c\n        \"\"\"\n        # XXX make this more robust (pyc files? zip archives? etc)\n        slug = module_name.replace('.', '/')\n        paths = [slug + '.py', slug + '/__init__.py']\n\n        # always search from current directory\n        for base in [''] + sys.path:\n            for path in paths:\n                fullpath = os.path.join(base, path)\n                if os.path.exists(fullpath):\n                    return cls(fullpath, prefix=module_name)\n        else:\n            raise ValueError(\"Module not found: %s\" % module_name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the 1 - offset right - open range of lines spanned by a particular context name.", "response": "def context_range(self, context):\n        \"\"\"\n        Return the 1-offset, right-open range of lines spanned by\n        a particular context name.\n\n        Parameters\n        ----------\n        context : str\n\n        Raises\n        ------\n        ValueError, if context is not present in the file.\n        \"\"\"\n        if not context.startswith(self.prefix):\n            context = self.prefix + '.' + context\n\n        lo = hi = None\n        for idx, line_context in enumerate(self.lines, 1):\n\n            # context is hierarchical -- context spans itself\n            # and any suffix.\n            if line_context.startswith(context):\n                lo = lo or idx\n                hi = idx\n\n        if lo is None:\n            raise ValueError(\"Context %s does not exist in file %s\" %\n                             (context, self.filename))\n\n        return lo, hi + 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the context for a given line number.", "response": "def context(self, line):\n        \"\"\"\n        Return the context for a given 1-offset line number.\n        \"\"\"\n        # XXX due to a limitation in Visitor,\n        # non-python code after the last python code\n        # in a file is not added to self.lines, so we\n        # have to guard against IndexErrors.\n        idx = line - 1\n        if idx >= len(self.lines):\n            return self.prefix\n        return self.lines[idx]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef discover_filename(label, scopes=None):\n    '''\n    Check the filesystem for the existence of a .plist file matching the job label.\n    Optionally specify one or more scopes to search (default all).\n\n    :param label: string\n    :param scope: tuple or list or oneOf(USER, USER_ADMIN, DAEMON_ADMIN, USER_OS, DAEMON_OS)\n    '''\n    if scopes is None:\n        scopes = [k for k in PLIST_LOCATIONS]\n    elif not isinstance(scopes, (list, tuple)):\n        scopes = (scopes, )\n    for thisscope in scopes:\n        plistfilename = compute_filename(label, thisscope)\n        if os.path.isfile(plistfilename):\n            return plistfilename\n    return None", "response": "Find the filename of a. plist file matching the given label."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting the given property list to the appropriate file on disk and returns the absolute filename.", "response": "def write(label, plist, scope=USER):\n    '''\n    Writes the given property list to the appropriate file on disk and returns\n    the absolute filename.\n\n    :param plist: dict\n    :param label: string\n    :param scope: oneOf(USER, USER_ADMIN, DAEMON_ADMIN, USER_OS, DAEMON_OS)\n    '''\n    fname = compute_filename(label, scope)\n    with open(fname, \"wb\") as f:\n        plistlib.writePlist(plist, f)\n    return fname"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef alphakt_pth(v, temp, v0, alpha0, k0, n, z, t_ref=300.,\n                three_r=3. * constants.R):\n    \"\"\"\n    calculate thermal pressure from thermal expansion and bulk modulus\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature in K\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param alpha0: thermal expansion parameter at 1 bar in K-1\n    :param k0: bulk modulus in GPa\n    :param n: number of atoms in a formula unit\n    :param z: number of formula unit in a unit cell\n    :param t_ref: reference temperature\n    :param three_r: 3R in case adjustment is needed\n    :return: thermal pressure in GPa\n    \"\"\"\n    return alpha0 * k0 * (temp - t_ref)", "response": "calculate thermal pressure from alphakt formula"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dictify_device_meta(device_object):\n    try:\n        if  isinstance(device_object['info']['description']['meta'], str) or \\\n            isinstance(device_object['info']['description']['meta'], unicode):\n            device_object['info']['description']['meta'] =\\\n                json.loads(device_object['info']['description']['meta'])\n    except ValueError as err:\n        print(\"dictify: {0}\".format(err))\n    return device_object", "response": "Convert the device object meta to a python dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stringify_device_meta(device_object):\n    try:\n        if isinstance(device_object['info']['description']['meta'], dict):\n            device_object['info']['description']['meta'] =\\\n                json.dumps(device_object['info']['description']['meta'])\n    except ValueError as err:\n        print(\"stringify: {0}\".format(err))\n    return device_object", "response": "Convert the device object meta to a python string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_output_nodes(self, output_path, error_path):\n        status = cod_deposition_states.UNKNOWN\n        messages = []\n\n        if output_path is not None:\n            content = None\n            with open(output_path) as f:\n                content = f.read()\n            status, message = CifCodDepositParser._deposit_result(content)\n            messages.extend(message.split('\\n'))\n\n        if error_path is not None:\n            with open(error_path) as f:\n                content = f.readlines()\n            lines = [x.strip('\\n') for x in content]\n            messages.extend(lines)\n\n        parameters = {'output_messages': messages, 'status': status}\n\n        output_nodes = []\n        output_nodes.append(('messages', Dict(dict=parameters)))\n\n        if status == cod_deposition_states.SUCCESS:\n            return True, output_nodes\n\n        return False, output_nodes", "response": "Extracts output nodes from the standard output and standard error files and returns a list of output nodes and the list of output nodes that are returned."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nraising exception if directory does not exist.", "response": "def _check_directory(directory):\n    \"\"\"Raise exception if directory does not exist.\"\"\"\n    if directory is not None:\n        if not exists(directory):\n            raise CommandError(\n                \"Cannot run command - directory {0} does not exist\".format(directory)\n            )\n\n        if not isdir(directory):\n            raise CommandError(\n                \"Cannot run command - specified directory {0} is not a directory.\".format(\n                    directory\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting the features from a Tweets. zip file.", "response": "def features(filename='tweets.zip'):\n    \"\"\"NotImplemented\"\"\"\n    raise NotImplemented(\"Need to implement feature extraction.\")\n    js = load_tweets(filename)\n    index = []\n    table = []\n    columns = [u'text', u'is_quote_status',\n               u'in_reply_to_status_id', u'in_reply_to_user_id',\n               u'favorited', u'favorite_count',  u'retweeted', u'retweet_count',\n               u'source', u'coordinates',\n               (u'user', u'id'), (u'user', u'followers_count'), (u'user', u'location'),\n               (u'metadata', u'iso_language_code'),\n               u'user',\n               u'geo',\n               u'in_reply_to_user_id_str',\n               u'possibly_sensitive',\n               u'lang',\n               u'created_at',\n               u'in_reply_to_status_id_str',\n               u'place',\n               ]\n\n    for tweet in js:\n        index += [int(tweet['id'])]\n        txt += [tweet['text']]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_args(args):\n    parser = argparse.ArgumentParser(\n        description=\"Concatenate and preprocess tweet json files dumped by tweetget\")\n    parser.add_argument(\n        '-v',\n        '--verbose',\n        help='Whether to show progress messages on stdout',\n        action='store_true')\n    parser.add_argument(\n        '--version',\n        help='print twip package version and exit.',\n        action='version',\n        version='twip {ver}'.format(ver=__version__))\n    parser.add_argument(\n        '-p',\n        '--path',\n        help='path to data dir (json input and csv output files)',\n        default=DATA_PATH)\n    parser.add_argument(\n        '-t',\n        '--tweetfile',\n        help='file to store normalized table (csv) of tweets and features (metadata)',\n        default='all_tweets.csv')\n    parser.add_argument(\n        '-n',\n        '--numtweets',\n        help='maximum number of tweets to process',\n        type=int,\n        default=1000000)\n    parser.add_argument(\n        '-g',\n        '--geofile',\n        help=\"file to store tweet lat/lon information (few use it)\",\n        default='geo_tweets.csv')\n    return parser.parse_args(args)", "response": "Parse command line parameters and return a list of strings"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncombine all tweetget json files into a single dataframe", "response": "def cat_tweets(filename='all_tweets.json.gz', path=DATA_PATH, ext='.json', save_tmp=False, verbosity=1, numtweets=10000000, ignore_suspicious=True):\n    \"\"\"Find json files that were dumped by tweetget and combine them into a single CSV\n\n    Normalize some (lat/lon)\"\"\"\n    log.info('Finding {} files in {}...'.format(ext, path))\n    meta_files = find_files(path=path, ext=ext)\n    meta_files = [meta for meta in meta_files\n                  if re.match(r'^[-#@a-z ]*201[5-6]-[0-9]{2}-[0-9]{2}.*', meta['name'])]\n    #  '\\s[0-9]{2}[:][0-9]{2}[:][0-9]{2}[.][0-9]+[.]json(.gz)?$', meta['name'])]\n    log.info('Found {} files that look like tweetget dumps.'.format(len(meta_files)))\n    print([mf['name'] for mf in meta_files])\n    total_size = sum([meta['size'] for meta in meta_files])\n    if verbosity > 0:\n        pbar = progressbar.ProgressBar(maxval=(total_size + 1.) / 1e6)\n        pbar.start()\n    else:\n        pbar = None\n\n    loaded_size = 0\n    df_all = pd.DataFrame()\n    for meta in meta_files:\n        with (gzip.open(meta['path']) if ext.endswith('.gz') else open(meta['path'])) as fin:\n            js = pd.json.load(fin)\n        if not len(js):\n            continue\n        df = pd.io.json.json_normalize(js)\n        # json entries were dumped in reverse time order (most recent first)\n        df.drop_duplicates(['id'], keep='first', inplace=True)\n        df.set_index('id', drop=True, inplace=True)\n        if 'geo.coordinates' in df.columns:\n            latlon = np.array([(ll[0], ll[1]) if isinstance(ll, list) else (np.nan, np.nan) for ll in df['geo.coordinates']])\n            for i, ll in enumerate(latlon):\n                try:\n                    latlon[i] = float(ll[0]), float(ll[1])\n                except ValueError:\n                    latlon[i] = np.nan, np.nan\n            ll = list(zip(*latlon))\n            df['lat'] = ll[0]\n            df['lon'] = ll[1]\n            df_all = df_all.append(df)\n        else:\n            df['lat'] = np.nan * np.ones(len(df))\n            df['lon'] = np.nan * np.ones(len(df))\n            if ignore_suspicious:\n                log.info('\\nOddly the DataFrame in {} didnt have a geo.coordinates column.'.format(meta['path']))\n                log.warn('\\nSkipping {} suspicious tweets.'.format(len(df)))\n            else:\n                df_all = df_all.append(df)\n        # this would be a good time to incrementally save these rows to disc\n        del df\n        loaded_size += meta['size']\n        if len(df_all) >= numtweets:\n            # FIXME use average rate of 400 tweets/MB to calculate better progressbar size at start\n            break\n        if save_tmp:\n            save_tweets(df_all, path=path, filename='tmp.csv')\n        if pbar:\n            pbar.update(loaded_size / 1e6)\n    print(len(df_all))\n    bigger_better_cols = [c for c in df_all.columns if c.endswith('_at') or '_count' in c]\n    print(bigger_better_cols)\n    print(all(c in df_all.columns for c in bigger_better_cols))\n    df_all = df_all.sort_values(by=bigger_better_cols, inplace=False)\n    hashable_cols = [c for c in df_all.columns if df_all[c].dtype not in (list,)]\n    df_all = df_all.drop_duplicates(subset=hashable_cols, inplace=False)\n    if pbar:\n        pbar.finish()\n    log.info('Loaded {} unique tweets.'.format(len(df_all)))\n    return df_all"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndrops columns that are mostly NaNs", "response": "def drop_nan_columns(df, thresh=325):\n    \"\"\"Drop columns that are mostly NaNs\n\n    Excel files can only have 256 columns, so you may have to drop a lot in order to get down to this\n    \"\"\"\n    if thresh < 1:\n        thresh = int(thresh * df)\n    return df.dropna(axis=1, thresh=thresh, inplace=False)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fast_deduplication_backup(self, old_backup_entry, process_bar):\n        # TODO: merge code with parts from deduplication_backup()\n        src_path = self.dir_path.resolved_path\n        log.debug(\"*** fast deduplication backup: '%s'\", src_path)\n        old_file_path = old_backup_entry.get_backup_path()\n\n        if not self.path_helper.abs_dst_path.is_dir():\n            try:\n                self.path_helper.abs_dst_path.makedirs(mode=phlb_config.default_new_path_mode)\n            except OSError as err:\n                raise BackupFileError(\"Error creating out path: %s\" % err)\n        else:\n            assert not self.path_helper.abs_dst_filepath.is_file(), (\n                \"Out file already exists: %r\" % self.path_helper.abs_src_filepath\n            )\n\n        with self.path_helper.abs_dst_hash_filepath.open(\"w\") as hash_file:\n            try:\n                old_file_path.link(self.path_helper.abs_dst_filepath)  # call os.link()\n            except OSError as err:\n                log.error(\"Can't link '%s' to '%s': %s\" % (old_file_path, self.path_helper.abs_dst_filepath, err))\n                log.info(\"Mark %r with 'no link source'.\", old_backup_entry)\n                old_backup_entry.no_link_source = True\n                old_backup_entry.save()\n\n                # do a normal copy backup\n                self.deduplication_backup(process_bar)\n                return\n\n            hash_hexdigest = old_backup_entry.content_info.hash_hexdigest\n            hash_file.write(hash_hexdigest)\n\n        file_size = self.dir_path.stat.st_size\n        if file_size > 0:\n            # tqdm will not accept 0 bytes files ;)\n            process_bar.update(file_size)\n\n        BackupEntry.objects.create(\n            backup_run=self.backup_run,\n            backup_entry_path=self.path_helper.abs_dst_filepath,\n            hash_hexdigest=hash_hexdigest,\n        )\n\n        if self._SIMULATE_SLOW_SPEED:\n            log.error(\"Slow down speed for tests!\")\n            time.sleep(self._SIMULATE_SLOW_SPEED)\n\n        self.fast_backup = True  # Was a fast backup used?\n        self.file_linked = True", "response": "This method will link a backup entry to the new one and then deduplication the new one."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deduplication_backup(self, process_bar):\n        self.fast_backup = False  # Was a fast backup used?\n\n        src_path = self.dir_path.resolved_path\n        log.debug(\"*** deduplication backup: '%s'\", src_path)\n\n        log.debug(\"abs_src_filepath: '%s'\", self.path_helper.abs_src_filepath)\n        log.debug(\"abs_dst_filepath: '%s'\", self.path_helper.abs_dst_filepath)\n        log.debug(\"abs_dst_hash_filepath: '%s'\", self.path_helper.abs_dst_hash_filepath)\n        log.debug(\"abs_dst_dir: '%s'\", self.path_helper.abs_dst_path)\n\n        if not self.path_helper.abs_dst_path.is_dir():\n            try:\n                self.path_helper.abs_dst_path.makedirs(mode=phlb_config.default_new_path_mode)\n            except OSError as err:\n                raise BackupFileError(\"Error creating out path: %s\" % err)\n        else:\n            assert not self.path_helper.abs_dst_filepath.is_file(), (\n                \"Out file already exists: %r\" % self.path_helper.abs_src_filepath\n            )\n\n        try:\n            try:\n                with self.path_helper.abs_src_filepath.open(\"rb\") as in_file:\n                    with self.path_helper.abs_dst_hash_filepath.open(\"w\") as hash_file:\n                        with self.path_helper.abs_dst_filepath.open(\"wb\") as out_file:\n                            hash = self._deduplication_backup(self.dir_path, in_file, out_file, process_bar)\n                        hash_hexdigest = hash.hexdigest()\n                        hash_file.write(hash_hexdigest)\n            except OSError as err:\n                # FIXME: Better error message\n                raise BackupFileError(\"Skip file %s error: %s\" % (self.path_helper.abs_src_filepath, err))\n        except KeyboardInterrupt:\n            # Try to remove created files\n            try:\n                self.path_helper.abs_dst_filepath.unlink()\n            except OSError:\n                pass\n            try:\n                self.path_helper.abs_dst_hash_filepath.unlink()\n            except OSError:\n                pass\n            raise KeyboardInterrupt\n\n        old_backup_entry = deduplicate(self.path_helper.abs_dst_filepath, hash_hexdigest)\n        if old_backup_entry is None:\n            log.debug(\"File is unique.\")\n            self.file_linked = False  # Was a hardlink used?\n        else:\n            log.debug(\"File was deduplicated via hardlink to: %s\" % old_backup_entry)\n            self.file_linked = True  # Was a hardlink used?\n\n        # set origin access/modified times to the new created backup file\n        atime_ns = self.dir_path.stat.st_atime_ns\n        mtime_ns = self.dir_path.stat.st_mtime_ns\n        self.path_helper.abs_dst_filepath.utime(ns=(atime_ns, mtime_ns))  # call os.utime()\n        log.debug(\"Set mtime to: %s\" % mtime_ns)\n\n        BackupEntry.objects.create(\n            backup_run=self.backup_run,\n            backup_entry_path=self.path_helper.abs_dst_filepath,\n            hash_hexdigest=hash_hexdigest,\n        )\n\n        self.fast_backup = False", "response": "Backup the current file and compare the content."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _backup_dir_item(self, dir_path, process_bar):\n        self.path_helper.set_src_filepath(dir_path)\n        if self.path_helper.abs_src_filepath is None:\n            self.total_errored_items += 1\n            log.info(\"Can't backup %r\", dir_path)\n\n        # self.summary(no, dir_path.stat.st_mtime, end=\" \")\n        if dir_path.is_symlink:\n            self.summary(\"TODO Symlink: %s\" % dir_path)\n            return\n\n        if dir_path.resolve_error is not None:\n            self.summary(\"TODO resolve error: %s\" % dir_path.resolve_error)\n            pprint_path(dir_path)\n            return\n\n        if dir_path.different_path:\n            self.summary(\"TODO different path:\")\n            pprint_path(dir_path)\n            return\n\n        if dir_path.is_dir:\n            self.summary(\"TODO dir: %s\" % dir_path)\n        elif dir_path.is_file:\n            # self.summary(\"Normal file: %s\", dir_path)\n\n            file_backup = FileBackup(dir_path, self.path_helper, self.backup_run)\n            old_backup_entry = self.fast_compare(dir_path)\n            if old_backup_entry is not None:\n                # We can just link the file from a old backup\n                file_backup.fast_deduplication_backup(old_backup_entry, process_bar)\n            else:\n                file_backup.deduplication_backup(process_bar)\n\n            assert file_backup.fast_backup is not None, dir_path.path\n            assert file_backup.file_linked is not None, dir_path.path\n\n            file_size = dir_path.stat.st_size\n            if file_backup.file_linked:\n                # os.link() was used\n                self.total_file_link_count += 1\n                self.total_stined_bytes += file_size\n            else:\n                self.total_new_file_count += 1\n                self.total_new_bytes += file_size\n\n            if file_backup.fast_backup:\n                self.total_fast_backup += 1\n        else:\n            self.summary(\"TODO:\" % dir_path)\n            pprint_path(dir_path)", "response": "This function is called by the backup_dir_item method. It will backup one directory item and return the corresponding instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints some status information in between.", "response": "def print_update(self):\n        \"\"\"\n        print some status information in between.\n        \"\"\"\n        print(\"\\r\\n\")\n        now = datetime.datetime.now()\n        print(\"Update info: (from: %s)\" % now.strftime(\"%c\"))\n\n        current_total_size = self.total_stined_bytes + self.total_new_bytes\n\n        if self.total_errored_items:\n            print(\" * WARNING: %i omitted files!\" % self.total_errored_items)\n\n        print(\" * fast backup: %i files\" % self.total_fast_backup)\n\n        print(\n            \" * new content saved: %i files (%s %.1f%%)\"\n            % (\n                self.total_new_file_count,\n                human_filesize(self.total_new_bytes),\n                to_percent(self.total_new_bytes, current_total_size),\n            )\n        )\n\n        print(\n            \" * stint space via hardlinks: %i files (%s %.1f%%)\"\n            % (\n                self.total_file_link_count,\n                human_filesize(self.total_stined_bytes),\n                to_percent(self.total_stined_bytes, current_total_size),\n            )\n        )\n\n        duration = default_timer() - self.start_time\n        performance = current_total_size / duration / 1024.0 / 1024.0\n        print(\" * present performance: %.1fMB/s\\n\" % performance)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning any cod - tools calculation for the given CifData node.", "response": "def cli(code, cif, parameters, daemon):\n    \"\"\"Run any cod-tools calculation for the given ``CifData`` node.\n\n    The ``-p/--parameters`` option takes a single string with any command line parameters that you want to be passed\n    to the calculation, and by extension the cod-tools script. Example::\n\n        launch_calculation_cod_tools -X cif-filter -N 95 -p '--use-c-parser --authors \"Jane Doe; John Doe\"'\n\n    The parameters will be parsed into a dictionary and passed as the ``parameters`` input node to the calculation.\n    \"\"\"\n    from aiida import orm\n    from aiida.plugins import factories\n    from aiida_codtools.common.cli import CliParameters, CliRunner\n    from aiida_codtools.common.resources import get_default_options\n\n    process = factories.CalculationFactory(code.get_attribute('input_plugin'))\n    parameters = CliParameters.from_string(parameters).get_dictionary()\n\n    inputs = {\n        'cif': cif,\n        'code': code,\n        'metadata': {'options': get_default_options()}\n    }\n\n    if parameters:\n        inputs['parameters'] = orm.Dict(dict=parameters)\n\n    cli_runner = CliRunner(process, inputs)\n    cli_runner.run(daemon=daemon)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the keystone - paste. ini file", "response": "def _update_keystone_paste_ini(self):\r\n        \"\"\"remove admin_token_auth from the [pipeline:public_api],\r\n        [pipeline:admin_api], and [pipeline:api_v3] sections\"\"\"\r\n        with open('tmp_keystone_paste_ini_' + env.host_string, 'w') as f:\r\n            f.write(conf_keystone_paste_ini)\r\n        files.upload_template(filename='tmp_keystone_paste_ini_' + env.host_string,\r\n                              destination='/etc/keystone/keystone-paste.ini',\r\n                              use_sudo=True,\r\n                              backup=True)\r\n        os.remove('tmp_keystone_paste_ini_' + env.host_string)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a short informative but not - so - unique identifying string for a trained model.", "response": "def compose_suffix(num_docs=0, num_topics=0, suffix=None):\n    \"\"\"Create a short, informative, but not-so-unique identifying string for a trained model\n    If a str suffix is provided then just pass it through.\n    >>> compose_suffix(num_docs=100, num_topics=20)\n    '_100X20'\n    >>> compose_suffix(suffix='_sfx')\n    '_sfx'\n    >>> compose_suffix(suffix='')\n    ''\n    >>> compose_suffix(suffix=None)\n    '_0X0'\n    \"\"\"\n    if not isinstance(suffix, basestring):\n        suffix = '_{}X{}'.format(num_docs, num_topics)\n    return suffix"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a json file containing topic key value pairs and print the top m words for the top n features", "response": "def summarize_topics(f='lsi_topics.json', num_topics=1000, num_tokens=10, column_width=10, do_print=True, justify=True, data_path=DATA_PATH):\n    \"\"\"Load json file containing topic key/value pairs and print the top m words for the top n features\"\"\"\n    if isinstance(f, basestring):\n        if os.path.sep not in f:\n            f = os.path.expanduser(os.path.join(data_path, f))\n        f = open(f, 'rUb')\n    if isinstance(f, pd.DataFrame):\n        f = list(np.array(f[f.columns[-1]]))\n    elif isinstance(f, file):\n        f = json.load(f)\n    if isinstance(f, Mapping):\n        f = [v for k, v in sorted(f.items())]\n    topics = list(f)\n    s = ''\n    digits = num_digits(min(len(topics), num_topics) - 1)\n    for i, t in enumerate(topics):\n        if i > num_topics:\n            break\n        t_sorted = sorted(t.items(), key=lambda x: -abs(x[1]))[:num_tokens]\n        line = '{:{}d}: {}'.format(i, digits, ' '.join(('-+'[int(v > 0)] + '{:{}s}'.format(k[:column_width], column_width) for (k, v) in t_sorted)))\n        if not justify:\n            line = ' '.join([col for col in line.split(' \\t') if col])\n        s += line + '\\n'\n    if do_print:\n        print(s)\n    return s.split('\\n')[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates DataFrame of GroupBy object with columns for each product", "response": "def df_from_groups(groups, columns=None):\n    \"\"\"Create DataFrame of GroupBy object with columns for each product(grouped_value, column_label)\"\"\"\n    if columns is None:\n        columns = list(groups.get_group(groups.indices.keys()[0]).columns)\n    df = pd.DataFrame()\n    for col, group_label in product(columns, groups.indices.keys()):\n        label = '{}_{}'.format(col, group_label)\n        df[label] = pd.Series(groups.get_group(group_label)[col].values)\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef score_hist(df, columns=None, groupby=None, threshold=0.7, stacked=True,\n               bins=20, percent=True, alpha=0.33, show=True, block=False, save=False):\n    \"\"\"Plot multiple histograms on one plot, typically of \"score\" values between 0 and 1\n    Typically the groupby or columns of the dataframe are the classification categories (0, .5, 1)\n    And the values are scores between 0 and 1.\n    \"\"\"\n    df = df if columns is None else df[([] if groupby is None else [groupby]) + list(columns)].copy()\n    if groupby is not None or threshold is not None:\n        df = groups_from_scores(df, groupby=groupby, threshold=threshold)\n    percent = 100. if percent else 1.\n    if isinstance(df, pd.core.groupby.DataFrameGroupBy):\n        df = df_from_groups(df, columns=columns) * percent\n    columns = df.columns if columns is None else columns\n    if bins is None:\n        bins = 20\n    if isinstance(bins, int):\n        bins = np.linspace(np.min(df.min()), np.max(df.max()), bins)\n    log.debug('bins: {}'.format(bins))\n    figs = []\n\n    df.plot(kind='hist', alpha=alpha, stacked=stacked, bins=bins)\n    # for col in df.columns:\n    #     series = df[col] * percent\n    #     log.debug('{}'.format(series))\n    #     figs.append(plt.hist(series, bins=bins, alpha=alpha,\n    #                 weights=percent * np.ones_like(series) / len(series.dropna()),\n    #                 label=stringify(col)))\n    plt.legend()\n    plt.xlabel('Score (%)')\n    plt.ylabel('Percent')\n    plt.title('{} Scores for {}'.format(np.sum(df.count()), columns))\n    plt.draw()\n    if save or not show:\n        fig = plt.gcf()\n        today = datetime.datetime.today()\n        fig.savefig(os.path.join(IMAGES_PATH, 'score_hist_{:04d}-{:02d}-{:02d}_{:02d}{:02d}.jpg'.format(*today.timetuple())))\n    if show:\n        plt.show(block=block)\n    return figs", "response": "Plot multiple histograms on one plot typically of score values between 0 and 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd(user, hosts, key_filename, password, run):\n    try:\n        remote = Cmd(user, hosts, key_filename, password)\n    except AttributeError:\n        sys.stderr.write('No hosts found. Please using --hosts param.')\n        sys.exit(1)\n    remote.cmd(run)", "response": "Command for the neccesary version of the command line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeprecating - prepare OpenStack basic environment", "response": "def make(parser):\n    \"\"\"DEPRECATED\n    prepare OpenStack basic environment\"\"\"\n    s = parser.add_subparsers(\n        title='commands',\n        metavar='COMMAND',\n        help='description',\n        )\n\n    def gen_pass_f(args):\n        gen_pass()\n    gen_pass_parser = s.add_parser('gen-pass', help='generate the password')\n    gen_pass_parser.set_defaults(func=gen_pass_f)\n\n    def cmd_f(args):\n        cmd(args.user, args.hosts.split(','), args.key_filename, args.password, args.run)\n    cmd_parser = s.add_parser('cmd', help='run command line on the target host')\n    cmd_parser.add_argument('--run', help='the command running on the remote node', action='store', default=None, dest='run')\n    cmd_parser.set_defaults(func=cmd_f)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getTextualNode(\n            self,\n            textId: str,\n            subreference: Union[str, BaseReference]=None,\n            prevnext: bool=False,\n            metadata: bool=False\n    ) -> TextualNode:\n        \"\"\" Retrieve a text node from the API\n\n        :param textId: CtsTextMetadata Identifier\n        :type textId: str\n        :param subreference: CapitainsCtsPassage Reference\n        :type subreference: str\n        :param prevnext: Retrieve graph representing previous and next passage\n        :type prevnext: boolean\n        :param metadata: Retrieve metadata about the passage and the text\n        :type metadata: boolean\n        :return: CapitainsCtsPassage\n        :rtype: CapitainsCtsPassage\n        \"\"\"\n        raise NotImplementedError()", "response": "Retrieve a text node from the API."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getSiblings(self, textId: str, subreference: Union[str, BaseReference]) -> Tuple[BaseReference, BaseReference]:\n        raise NotImplementedError()", "response": "Retrieve the siblings of a textual node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves siblings of a textual node.", "response": "def getReffs(\n            self,\n            textId: str,\n            level: int=1,\n            subreference: Union[str, BaseReference]=None,\n            include_descendants: bool=False,\n            additional_parameters: Optional[Dict[str, Any]]=None\n    ) -> BaseReferenceSet:\n        \"\"\" Retrieve the siblings of a textual node\n\n        :param textId: CtsTextMetadata Identifier\n        :type textId: str\n        :param level: Depth for retrieval\n        :type level: int\n        :param subreference: CapitainsCtsPassage Reference\n        :type subreference: str\n        :param include_descendants:\n        :param additional_parameters:\n        :return: List of references\n        :rtype: [str]\n\n        ..toDo :: This starts to be a bloated function....\n        \"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvisiting the specific page of the site", "response": "def visit_page(self, page):\n    \"\"\"\n    Visit the specific page of the site, e.g.\n\n    .. code-block:: gherkin\n\n        When I visit site page \"/users\"\n    \"\"\"\n\n    url = urljoin(django_url(self), page)\n    self.given('I visit \"%s\"' % url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert column name to filter.", "response": "def pw_converter(handler, flt):\n    \"\"\"Convert column name to filter.\"\"\"\n    import peewee as pw\n\n    if isinstance(flt, Filter):\n        return flt\n\n    model = handler.model\n    field = getattr(model, flt)\n\n    if isinstance(field, pw.BooleanField):\n        return PWBoolFilter(flt)\n\n    if field.choices:\n        choices = [(Filter.default, '---')] + list(field.choices)\n        return PWChoiceFilter(flt, choices=choices)\n\n    return PWFilter(flt)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_one(self, request):\n        resource = request.query.get('pk')\n        if not resource:\n            return None\n\n        try:\n            return self.collection.where(self.model._meta.primary_key == resource).get()\n        except Exception:\n            raise muffin.HTTPNotFound()", "response": "Load a resource from the database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfiltering a query based on the current value of the attribute.", "response": "def apply(self, query, data):\n        \"\"\"Filter a query.\"\"\"\n        field = self.model_field or query.model_class._meta.fields.get(self.name)\n        if not field or self.name not in data:\n            return query\n        value = self.value(data)\n        if value is self.default:\n            return query\n        value = field.db_value(value)\n        return self.filter_query(query, field, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef value(self, data):\n        value = data.get(self.name)\n        if value:\n            return int(value)\n        return self.default", "response": "Get value from data."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the field names and values from a node.", "response": "def get_fields(node, fields_tag=\"field_list\"):\n    \"\"\"Get the field names and their values from a node.\n\n    :sig: (Document, str) -> Dict[str, str]\n    :param node: Node to get the fields from.\n    :param fields_tag: Tag of child node that contains the fields.\n    :return: Names and values of fields.\n    \"\"\"\n    fields_nodes = [c for c in node.children if c.tagname == fields_tag]\n    if len(fields_nodes) == 0:\n        return {}\n    assert len(fields_nodes) == 1, \"multiple nodes with tag \" + fields_tag\n    fields_node = fields_nodes[0]\n    fields = [\n        {f.tagname: f.rawsource.strip() for f in n.children}\n        for n in fields_node.children\n        if n.tagname == \"field\"\n    ]\n    return {f[\"field_name\"]: f[\"field_body\"] for f in fields}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract_signature(docstring):\n    root = publish_doctree(docstring, settings_overrides={\"report_level\": 5})\n    fields = get_fields(root)\n    return fields.get(SIG_FIELD)", "response": "Extract the signature from a docstring."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef split_parameter_types(parameters):\n    if parameters == \"\":\n        return []\n\n    # only consider the top level commas, ignore the ones in []\n    commas = []\n    bracket_depth = 0\n    for i, char in enumerate(parameters):\n        if (char == \",\") and (bracket_depth == 0):\n            commas.append(i)\n        elif char == \"[\":\n            bracket_depth += 1\n        elif char == \"]\":\n            bracket_depth -= 1\n\n    types = []\n    last_i = 0\n    for i in commas:\n        types.append(parameters[last_i:i].strip())\n        last_i = i + 1\n    else:\n        types.append(parameters[last_i:].strip())\n    return types", "response": "Splits a parameter types declaration into individual types."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_signature(signature):\n    if \" -> \" not in signature:\n        # signature comment: no parameters, treat variable type as return type\n        param_types, return_type = None, signature.strip()\n    else:\n        lhs, return_type = [s.strip() for s in signature.split(\" -> \")]\n        csv = lhs[1:-1].strip()  # remove the parentheses around the parameter type list\n        param_types = split_parameter_types(csv)\n    requires = set(_RE_QUALIFIED_TYPES.findall(signature))\n    return param_types, return_type, requires", "response": "Parse a signature into its input and return parameter types and all required types."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the type aliases in the source code.", "response": "def get_aliases(lines):\n    \"\"\"Get the type aliases in the source.\n\n    :sig: (Sequence[str]) -> Dict[str, str]\n    :param lines: Lines of the source code.\n    :return: Aliases and their their definitions.\n    \"\"\"\n    aliases = {}\n    for line in lines:\n        line = line.strip()\n        if len(line) > 0 and line.startswith(SIG_ALIAS):\n            _, content = line.split(SIG_ALIAS)\n            alias, signature = [t.strip() for t in content.split(\"=\")]\n            aliases[alias] = signature\n    return aliases"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stub(source, generic=False):\n    generator = StubGenerator(source, generic=generic)\n    stub = generator.generate_stub()\n    return stub", "response": "Generate a stub code for a source code."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_mod_paths(mod_name, out_dir):\n    paths = []\n    try:\n        mod = get_loader(mod_name)\n        source = Path(mod.path)\n        if source.name.endswith(\".py\"):\n            source_rel = Path(*mod_name.split(\".\"))\n            if source.name == \"__init__.py\":\n                source_rel = source_rel.joinpath(\"__init__.py\")\n            destination = Path(out_dir, source_rel.with_suffix(\".pyi\"))\n            paths.append((source, destination))\n    except Exception as e:\n        _logger.debug(e)\n        _logger.warning(\"cannot handle module, skipping: %s\", mod_name)\n    return paths", "response": "Get source and stub paths for a module."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_pkg_paths(pkg_name, out_dir):\n    paths = []\n    try:\n        pkg = import_module(pkg_name)\n        if not hasattr(pkg, \"__path__\"):\n            return get_mod_paths(pkg_name, out_dir)\n        for mod_info in walk_packages(pkg.__path__, pkg.__name__ + \".\"):\n            mod_paths = get_mod_paths(mod_info.name, out_dir)\n            paths.extend(mod_paths)\n    except Exception as e:\n        _logger.debug(e)\n        _logger.warning(\"cannot handle package, skipping: %s\", pkg_name)\n    return paths", "response": "Recursively get all source and stub paths for a package."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmodifying the docstring before generating documentation.", "response": "def process_docstring(app, what, name, obj, options, lines):\n    \"\"\"Modify the docstring before generating documentation.\n\n    This will insert type declarations for parameters and return type\n    into the docstring, and remove the signature field so that it will\n    be excluded from the generated document.\n    \"\"\"\n    aliases = getattr(app, \"_sigaliases\", None)\n    if aliases is None:\n        if what == \"module\":\n            aliases = get_aliases(inspect.getsource(obj).splitlines())\n            app._sigaliases = aliases\n\n    sig_marker = \":\" + SIG_FIELD + \":\"\n    is_class = what in (\"class\", \"exception\")\n\n    signature = extract_signature(\"\\n\".join(lines))\n    if signature is None:\n        if not is_class:\n            return\n\n        init_method = getattr(obj, \"__init__\")\n        init_doc = init_method.__doc__\n        init_lines = init_doc.splitlines()[1:]\n        if len(init_lines) > 1:\n            init_doc = textwrap.dedent(\"\\n\".join(init_lines[1:]))\n            init_lines = init_doc.splitlines()\n        if sig_marker not in init_doc:\n            return\n\n        sig_started = False\n        for line in init_lines:\n            if line.lstrip().startswith(sig_marker):\n                sig_started = True\n            if sig_started:\n                lines.append(line)\n        signature = extract_signature(\"\\n\".join(lines))\n\n    if is_class:\n        obj = init_method\n\n    param_types, rtype, _ = parse_signature(signature)\n    param_names = [p for p in inspect.signature(obj).parameters]\n\n    if is_class and (param_names[0] == \"self\"):\n        del param_names[0]\n\n    # if something goes wrong, don't insert parameter types\n    if len(param_names) == len(param_types):\n        for name, type_ in zip(param_names, param_types):\n            find = \":param %(name)s:\" % {\"name\": name}\n            alias = aliases.get(type_)\n            if alias is not None:\n                type_ = \"*%(type)s* :sup:`%(alias)s`\" % {\"type\": type_, \"alias\": alias}\n            for i, line in enumerate(lines):\n                if line.startswith(find):\n                    lines.insert(i, \":type %(name)s: %(type)s\" % {\"name\": name, \"type\": type_})\n                    break\n\n    if not is_class:\n        for i, line in enumerate(lines):\n            if line.startswith((\":return:\", \":returns:\")):\n                lines.insert(i, \":rtype: \" + rtype)\n                break\n\n    # remove the signature field\n    sig_start = 0\n    while sig_start < len(lines):\n        if lines[sig_start].startswith(sig_marker):\n            break\n        sig_start += 1\n    sig_end = sig_start + 1\n    while sig_end < len(lines):\n        if (not lines[sig_end]) or (lines[sig_end][0] != \" \"):\n            break\n        sig_end += 1\n    for i in reversed(range(sig_start, sig_end)):\n        del lines[i]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart the command line interface.", "response": "def main(argv=None):\n    \"\"\"Start the command line interface.\"\"\"\n    parser = ArgumentParser(prog=\"pygenstub\")\n    parser.add_argument(\"--version\", action=\"version\", version=\"%(prog)s \" + __version__)\n    parser.add_argument(\"files\", nargs=\"*\", help=\"generate stubs for given files\")\n    parser.add_argument(\n        \"-m\",\n        \"--module\",\n        action=\"append\",\n        metavar=\"MODULE\",\n        dest=\"modules\",\n        default=[],\n        help=\"generate stubs for given modules\",\n    )\n    parser.add_argument(\n        \"-o\", \"--output\", metavar=\"PATH\", dest=\"out_dir\", help=\"change the output directory\"\n    )\n    parser.add_argument(\n        \"--generic\", action=\"store_true\", default=False, help=\"generate generic stubs\"\n    )\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"enable debug messages\")\n\n    argv = argv if argv is not None else sys.argv\n    arguments = parser.parse_args(argv[1:])\n\n    # set debug mode\n    if arguments.debug:\n        logging.basicConfig(level=logging.DEBUG)\n        _logger.debug(\"running in debug mode\")\n\n    out_dir = arguments.out_dir if arguments.out_dir is not None else \"\"\n    if (out_dir == \"\") and (len(arguments.modules) > 0):\n        print(\"Output directory must be given when generating stubs for modules.\")\n        sys.exit(1)\n\n    modules = []\n    for path in arguments.files:\n        paths = Path(path).glob(\"**/*.py\") if Path(path).is_dir() else [Path(path)]\n        for source in paths:\n            if str(source).startswith(os.path.pardir):\n                source = source.absolute().resolve()\n            if (out_dir != \"\") and source.is_absolute():\n                source = source.relative_to(source.root)\n            destination = Path(out_dir, source.with_suffix(\".pyi\"))\n            modules.append((source, destination))\n\n    for mod_name in arguments.modules:\n        modules.extend(get_pkg_paths(mod_name, out_dir))\n\n    for source, destination in modules:\n        _logger.info(\"generating stub for %s to path %s\", source, destination)\n        with source.open() as f:\n            code = f.read()\n        try:\n            stub = get_stub(code, generic=arguments.generic)\n        except Exception as e:\n            print(source, \"-\", e, file=sys.stderr)\n            continue\n\n        if stub != \"\":\n            if not destination.parent.exists():\n                destination.parent.mkdir(parents=True)\n            with destination.open(\"w\") as f:\n                f.write(\"# \" + EDIT_WARNING + \"\\n\\n\" + stub)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a variable node to this node.", "response": "def add_variable(self, node):\n        \"\"\"Add a variable node to this node.\n\n        :sig: (VariableNode) -> None\n        :param node: Variable node to add.\n        \"\"\"\n        if node.name not in self.variable_names:\n            self.variables.append(node)\n            self.variable_names.add(node.name)\n            node.parent = self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the stub code for this node.", "response": "def get_code(self):\n        \"\"\"Get the stub code for this node.\n\n        The stub code for a node consists of the type annotations of its variables,\n        followed by the prototypes of its functions/methods and classes.\n\n        :sig: () -> List[str]\n        :return: Lines of stub code for this node.\n        \"\"\"\n        stub = []\n        for child in self.variables:\n            stub.extend(child.get_code())\n        if (\n            (len(self.variables) > 0)\n            and (len(self.children) > 0)\n            and (not isinstance(self, ClassNode))\n        ):\n            stub.append(\"\")\n        for child in self.children:\n            stub.extend(child.get_code())\n        return stub"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the stub code for this function.", "response": "def get_code(self):\n        \"\"\"Get the stub code for this function.\n\n        :sig: () -> List[str]\n        :return: Lines of stub code for this function.\n        \"\"\"\n        stub = []\n\n        for deco in self.decorators:\n            if (deco in DECORATORS) or deco.endswith(\".setter\"):\n                stub.append(\"@\" + deco)\n\n        parameters = []\n        for name, type_, has_default in self.parameters:\n            decl = \"%(n)s%(t)s%(d)s\" % {\n                \"n\": name,\n                \"t\": \": \" + type_ if type_ else \"\",\n                \"d\": \" = ...\" if has_default else \"\",\n            }\n            parameters.append(decl)\n\n        slots = {\n            \"a\": \"async \" if self._async else \"\",\n            \"n\": self.name,\n            \"p\": \", \".join(parameters),\n            \"r\": self.rtype,\n        }\n\n        prototype = \"%(a)sdef %(n)s(%(p)s) -> %(r)s: ...\" % slots\n        if len(prototype) <= LINE_LENGTH_LIMIT:\n            stub.append(prototype)\n        elif len(INDENT + slots[\"p\"]) <= LINE_LENGTH_LIMIT:\n            stub.append(\"%(a)sdef %(n)s(\" % slots)\n            stub.append(INDENT + slots[\"p\"])\n            stub.append(\") -> %(r)s: ...\" % slots)\n        else:\n            stub.append(\"%(a)sdef %(n)s(\" % slots)\n            for param in parameters:\n                stub.append(INDENT + param + \",\")\n            stub.append(\") -> %(r)s: ...\" % slots)\n\n        return stub"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_code(self):\n        stub = []\n        bases = (\"(\" + \", \".join(self.bases) + \")\") if len(self.bases) > 0 else \"\"\n        slots = {\"n\": self.name, \"b\": bases}\n        if (len(self.children) == 0) and (len(self.variables) == 0):\n            stub.append(\"class %(n)s%(b)s: ...\" % slots)\n        else:\n            stub.append(\"class %(n)s%(b)s:\" % slots)\n            super_code = super().get_code() if PY3 else StubNode.get_code(self)\n            for line in super_code:\n                stub.append(INDENT + line)\n        return stub", "response": "Get the stub code for this class."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef collect_aliases(self):\n        self.aliases = get_aliases(self._code_lines)\n        for alias, signature in self.aliases.items():\n            _, _, requires = parse_signature(signature)\n            self.required_types |= requires\n            self.defined_types |= {alias}", "response": "Collect the type aliases in the source."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef visit_Import(self, node):\n        line = self._code_lines[node.lineno - 1]\n        module_name = line.split(\"import\")[0].strip()\n        for name in node.names:\n            imported_name = name.name\n            if name.asname:\n                imported_name = name.asname + \"::\" + imported_name\n            self.imported_namespaces[imported_name] = module_name", "response": "Visit an import node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvisiting an from - import node.", "response": "def visit_ImportFrom(self, node):\n        \"\"\"Visit an from-import node.\"\"\"\n        line = self._code_lines[node.lineno - 1]\n        module_name = line.split(\"from\")[1].split(\"import\")[0].strip()\n        for name in node.names:\n            imported_name = name.name\n            if name.asname:\n                imported_name = name.asname + \"::\" + imported_name\n            self.imported_names[imported_name] = module_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef visit_Assign(self, node):\n        line = self._code_lines[node.lineno - 1]\n        if SIG_COMMENT in line:\n            line = _RE_COMMENT_IN_STRING.sub(\"\", line)\n\n        if (SIG_COMMENT not in line) and (not self.generic):\n            return\n\n        if SIG_COMMENT in line:\n            _, signature = line.split(SIG_COMMENT)\n            _, return_type, requires = parse_signature(signature)\n            self.required_types |= requires\n\n        parent = self._parents[-1]\n        for var in node.targets:\n            if isinstance(var, ast.Name):\n                name, p = var.id, parent\n            elif (\n                isinstance(var, ast.Attribute)\n                and isinstance(var.value, ast.Name)\n                and (var.value.id == \"self\")\n            ):\n                name, p = var.attr, parent.parent\n            else:\n                name, p = None, None\n\n            if name is not None:\n                if self.generic:\n                    return_type = \"Any\"\n                    self.required_types.add(return_type)\n                stub_node = VariableNode(name, return_type)\n                p.add_variable(stub_node)", "response": "Visit an assignment node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprocessing a function node.", "response": "def get_function_node(self, node):\n        \"\"\"Process a function node.\n\n        :sig: (Union[ast.FunctionDef, ast.AsyncFunctionDef]) -> FunctionNode\n        :param node: Node to process.\n        :return: Generated function node in stub tree.\n        \"\"\"\n        decorators = []\n        for d in node.decorator_list:\n            if hasattr(d, \"id\"):\n                decorators.append(d.id)\n            elif hasattr(d, \"func\"):\n                decorators.append(d.func.id)\n            elif hasattr(d, \"value\"):\n                decorators.append(d.value.id + \".\" + d.attr)\n\n        signature = get_signature(node)\n\n        if signature is None:\n            parent = self._parents[-1]\n            if isinstance(parent, ClassNode) and (node.name == \"__init__\"):\n                signature = parent.signature\n\n        if (signature is None) and (not self.generic):\n            return None\n\n        param_names = [arg.arg if PY3 else arg.id for arg in node.args.args]\n        n_args = len(param_names)\n\n        if signature is None:\n            param_types, rtype, requires = [\"Any\"] * n_args, \"Any\", {\"Any\"}\n        else:\n            _logger.debug(\"parsing signature for %s\", node.name)\n            param_types, rtype, requires = parse_signature(signature)\n\n        # TODO: only in classes\n        if ((n_args > 0) and (param_names[0] == \"self\")) or (\n            (n_args > 0) and (param_names[0] == \"cls\") and (\"classmethod\" in decorators)\n        ):\n            if signature is None:\n                param_types[0] = \"\"\n            else:\n                param_types.insert(0, \"\")\n\n        _logger.debug(\"parameter types: %s\", param_types)\n        _logger.debug(\"return type: %s\", rtype)\n        _logger.debug(\"required types: %s\", requires)\n\n        self.required_types |= requires\n\n        if node.args.vararg is not None:\n            param_names.append(\"*\" + (node.args.vararg.arg if PY3 else node.args.vararg))\n            param_types.append(\"\")\n\n        if node.args.kwarg is not None:\n            param_names.append(\"**\" + (node.args.kwarg.arg if PY3 else node.args.kwarg))\n            param_types.append(\"\")\n\n        kwonly_args = getattr(node.args, \"kwonlyargs\", [])\n        if len(kwonly_args) > 0:\n            param_names.extend([arg.arg for arg in kwonly_args])\n            if signature is None:\n                param_types.extend([\"Any\"] * len(kwonly_args))\n\n        if len(param_types) != len(param_names):\n            raise ValueError(\"Parameter names and types don't match: \" + node.name)\n\n        param_locs = [(a.lineno, a.col_offset) for a in (node.args.args + kwonly_args)]\n        param_defaults = {\n            bisect(param_locs, (d.lineno, d.col_offset)) - 1 for d in node.args.defaults\n        }\n\n        kwonly_defaults = getattr(node.args, \"kw_defaults\", [])\n        for i, d in enumerate(kwonly_defaults):\n            if d is not None:\n                param_defaults.add(n_args + i)\n\n        params = [\n            (name, type_, i in param_defaults)\n            for i, (name, type_) in enumerate(zip(param_names, param_types))\n        ]\n\n        if len(kwonly_args) > 0:\n            params.insert(n_args, (\"*\", \"\", False))\n\n        stub_node = FunctionNode(\n            node.name, parameters=params, rtype=rtype, decorators=decorators\n        )\n        self._parents[-1].add_child(stub_node)\n\n        self._parents.append(stub_node)\n        self.generic_visit(node)\n        del self._parents[-1]\n        return stub_node"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef visit_FunctionDef(self, node):\n        node = self.get_function_node(node)\n        if node is not None:\n            node._async = False", "response": "Visit a function node."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvisits an async function node.", "response": "def visit_AsyncFunctionDef(self, node):\n        \"\"\"Visit an async function node.\"\"\"\n        node = self.get_function_node(node)\n        if node is not None:\n            node._async = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef visit_ClassDef(self, node):\n        self.defined_types.add(node.name)\n\n        bases = []\n        for n in node.bases:\n            base_parts = []\n            while True:\n                if not isinstance(n, ast.Attribute):\n                    base_parts.append(n.id)\n                    break\n                else:\n                    base_parts.append(n.attr)\n                n = n.value\n            bases.append(\".\".join(base_parts[::-1]))\n        self.required_types |= set(bases)\n\n        signature = get_signature(node)\n        stub_node = ClassNode(node.name, bases=bases, signature=signature)\n        self._parents[-1].add_child(stub_node)\n\n        self._parents.append(stub_node)\n        self.generic_visit(node)\n        del self._parents[-1]", "response": "Visit a class node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating an import line.", "response": "def generate_import_from(module_, names):\n        \"\"\"Generate an import line.\n\n        :sig: (str, Set[str]) -> str\n        :param module_: Name of module to import the names from.\n        :param names: Names to import.\n        :return: Import line in stub code.\n        \"\"\"\n        regular_names = [n for n in names if \"::\" not in n]\n        as_names = [n for n in names if \"::\" in n]\n\n        line = \"\"\n        if len(regular_names) > 0:\n            slots = {\"m\": module_, \"n\": \", \".join(sorted(regular_names))}\n            line = \"from %(m)s import %(n)s\" % slots\n            if len(line) > LINE_LENGTH_LIMIT:\n                slots[\"n\"] = INDENT + (\",\\n\" + INDENT).join(sorted(regular_names)) + \",\"\n                line = \"from %(m)s import (\\n%(n)s\\n)\" % slots\n            if len(as_names) > 0:\n                line += \"\\n\"\n\n        for as_name in as_names:\n            a, n = as_name.split(\"::\")\n            line += \"from %(m)s import %(n)s as %(a)s\" % {\"m\": module_, \"n\": n, \"a\": a}\n        return line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_stub(self):\n        needed_types = self.required_types - BUILTIN_TYPES\n\n        needed_types -= self.defined_types\n        _logger.debug(\"defined types: %s\", self.defined_types)\n\n        module_vars = {v.name for v in self.root.variables}\n        _logger.debug(\"module variables: %s\", module_vars)\n\n        qualified_types = {n for n in needed_types if \".\" in n}\n        qualified_namespaces = {\".\".join(n.split(\".\")[:-1]) for n in qualified_types}\n\n        needed_namespaces = qualified_namespaces - module_vars\n        needed_types -= qualified_types\n        _logger.debug(\"needed namespaces: %s\", needed_namespaces)\n\n        imported_names = {n.split(\"::\")[0] for n in self.imported_names}\n        imported_types = imported_names & (needed_types | needed_namespaces)\n        needed_types -= imported_types\n        needed_namespaces -= imported_names\n        _logger.debug(\"used imported types: %s\", imported_types)\n\n        try:\n            typing_mod = __import__(\"typing\")\n            typing_types = {n for n in needed_types if hasattr(typing_mod, n)}\n            needed_types -= typing_types\n            _logger.debug(\"types from typing module: %s\", typing_types)\n        except ImportError:\n            typing_types = set()\n            _logger.warn(\"typing module not installed\")\n\n        if len(needed_types) > 0:\n            raise ValueError(\"Unknown types: \" + \", \".join(needed_types))\n\n        out = StringIO()\n        started = False\n\n        if len(typing_types) > 0:\n            line = self.generate_import_from(\"typing\", typing_types)\n            out.write(line + \"\\n\")\n            started = True\n\n        if len(imported_types) > 0:\n            if started:\n                out.write(\"\\n\")\n            # preserve the import order in the source file\n            for name in self.imported_names:\n                if name.split(\"::\")[0] in imported_types:\n                    line = self.generate_import_from(self.imported_names[name], {name})\n                    out.write(line + \"\\n\")\n            started = True\n\n        if len(needed_namespaces) > 0:\n            if started:\n                out.write(\"\\n\")\n            as_names = {n.split(\"::\")[0]: n for n in self.imported_namespaces if \"::\" in n}\n            for module_ in sorted(needed_namespaces):\n                if module_ in as_names:\n                    a, n = as_names[module_].split(\"::\")\n                    out.write(\"import \" + n + \" as \" + a + \"\\n\")\n                else:\n                    out.write(\"import \" + module_ + \"\\n\")\n            started = True\n\n        if len(self.aliases) > 0:\n            if started:\n                out.write(\"\\n\")\n            for alias, signature in self.aliases.items():\n                out.write(\"%s = %s\\n\" % (alias, signature))\n            started = True\n\n        if started:\n            out.write(\"\\n\")\n        stub_lines = self.root.get_code()\n        n_lines = len(stub_lines)\n        for line_no in range(n_lines):\n            prev_line = stub_lines[line_no - 1] if line_no > 0 else None\n            line = stub_lines[line_no]\n            next_line = stub_lines[line_no + 1] if line_no < (n_lines - 1) else None\n            if (\n                line.startswith(\"class \")\n                and (prev_line is not None)\n                and (\n                    (not prev_line.startswith(\"class \"))\n                    or (next_line and next_line.startswith(\" \"))\n                )\n            ):\n                out.write(\"\\n\")\n            if (\n                line.startswith(\"def \")\n                and (prev_line is not None)\n                and (prev_line.startswith((\" \", \"class \")))\n            ):\n                out.write(\"\\n\")\n            out.write(line + \"\\n\")\n            line_no += 1\n        return out.getvalue()", "response": "Generate the stub code for this source."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef properties(self):\n        '''\n        This is a lazily loaded dictionary containing the launchd runtime\n        information of the job in question. Internally, this is retrieved\n        using ServiceManagement.SMJobCopyDictionary(). Keep in mind that\n        some dictionary keys are not always present (for example 'PID').\n        If the job specified by the label cannot be found in launchd, then\n        this method raises a ValueError exception.\n        '''\n        if hasattr(self, '_nsproperties'):\n            self._properties = convert_NSDictionary_to_dict(self._nsproperties)\n            del self._nsproperties\n            #self._nsproperties = None\n        if self._properties is None:\n            self.refresh()\n        return self._properties", "response": "Returns the properties of the job in question."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plistfilename(self):\n        '''\n        This is a lazily detected absolute filename of the corresponding\n        property list file (*.plist). None if it doesn't exist.\n        '''\n        if self._plist_fname is None:\n            self._plist_fname = discover_filename(self.label)\n        return self._plist_fname", "response": "Returns the absolute filename of the corresponding\n        property list file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_csv_permission(self, request, obj=None):\n        if getattr(settings, 'DJANGO_EXPORTS_REQUIRE_PERM', None):\n            opts = self.opts\n            codename = '%s_%s' % ('csv', opts.object_name.lower())\n            return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n        return True", "response": "Returns True if the given request has permission to add an object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new ImmutableDict instance with value associated with key.", "response": "def assoc(self, key, value):\n        '''Returns a new ImmutableDict instance with value associated with key.\n        The implicit parameter is not modified.'''\n        copydict = ImmutableDict()\n        copydict.tree = self.tree.assoc(hash(key), (key, value))\n        copydict._length = self._length + 1\n        return copydict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking the same arguments as the builtin dict class. However this version returns a new ImmutableDict instead of modifying in - place.", "response": "def update(self, other=None, **kwargs):\n        '''Takes the same arguments as the update method in the builtin dict\n        class. However, this version returns a new ImmutableDict instead of\n        modifying in-place.'''\n        copydict = ImmutableDict()\n        if other:\n            vallist = [(hash(key), (key, other[key])) for key in other]\n        else: vallist = []\n        if kwargs:\n            vallist += [(hash(key), (key, kwargs[key])) for key in kwargs]\n        copydict.tree = self.tree.multi_assoc(vallist)\n        copydict._length = iter_length(copydict.tree)\n        return copydict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new ImmutableDict with the given key removed.", "response": "def remove(self, key):\n        '''Returns a new ImmutableDict with the given key removed.'''\n        copydict = ImmutableDict()\n        copydict.tree = self.tree.remove(hash(key))\n        copydict._length = self._length - 1\n        return copydict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open(self, url, quality):\n\n        self.original_url = url\n        try:\n            self.livestreamer = Livestreamer()\n            self._load_config()\n            streams = self.livestreamer.streams(url)\n        except NoPluginError:\n            self.exit(\"Livestreamer is unable to handle the URL '{}'\".\n                      format(url))\n        except PluginError as err:\n            self.exit(\"Plugin error: {}\".format(err))\n\n        if quality not in streams:\n            print(\"Unable to find '{}' stream on URL '{}'\"\n                  .format(quality, url), file=sys.stderr)\n            self.exit(\"List of available streams: {}\".\n                      format(sorted(streams.keys())))\n\n        self.stream = streams[quality]\n        try:\n            self.fd = self.stream.open()\n        except StreamError as err:\n            self.exit(\"Failed to open stream: {}\".format(err))", "response": "Attempt to open stream from url."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload and parse config file pass options to livestreamer", "response": "def _load_config(self):\n        \"Load and parse config file, pass options to livestreamer\"\n        \n        config = SafeConfigParser()\n        config_file = os.path.join(self.config_path, 'settings.ini')\n        config.read(config_file)\n\n        for option, type in list(AVAILABLE_OPTIONS.items()):\n            if config.has_option('DEFAULT', option):\n                if type == 'int':\n                    value = config.getint('DEFAULT', option)\n                if type == 'float':\n                    value = config.getfloat('DEFAULT', option)\n                if type == 'bool':\n                    value = config.getboolean('DEFAULT', option)\n                if type == 'str':\n                    value = config.get('DEFAULT', option)\n\n                self.livestreamer.set_option(option, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the title of the current page.", "response": "def get_title(self):\n        \"\"\"Returns the filename from URL (including extension), that\n        may be:\n\n        https://www.youtube.com/watch?v=ZEtEH-GIAJE ->\n        '[Hatsune Miku] After Rain Sweet*Drops [English Sub] -\n        YouTube.mp4'\n\n        https://www.youtube.com/watch?v=ZEtEH-GIAJE ->\n        'watch_v=ZEtEH-GIAJE.mp4'\n\n        The former case occurs when URL is a web page with <title> tags.\n        The last case will occur in pages with malformed HTML or when\n        you pass a non-HTML URL as a parameter (for example, a link to\n        a direct HTML5 video).\n\n        The extension will be detected according to the stream type,\n        for example RTMPStream will always be '.flv'. The only format\n        that may returns a wrong extension is HTTPStream, since there\n        is no standard container in this case. We assume (for now) that\n        every HTTPStream is '.mp4'.\n        \"\"\"\n\n        stream_type = self.stream.__class__.__name__\n        try:\n            extension = VIDEO_EXTENSIONS[stream_type]\n        except KeyError:\n            print('No extension found...', file=sys.stderr)\n            extension = ''\n\n        r = requests.get(self.original_url)\n        regex_result = _RE_PAGE_TITLE.search(r.text)\n        \n        if regex_result is not None:\n          filename = regex_result.group(1)\n\n        # Badly formatted HTML (e.g. no '<title>')\n        else:\n          # 'http://www.example.com/path1/path2?q=V1' ->\n          # 'http', 'www.example.com', '/path1/path2', 'q=V1'\n          split_url = urlsplit(self.original_url)\n          # '/path1/path2' -> 'path2'\n          filename = split_url.path.split('/')[-1]\n          # 'path2' -> 'path2_q=V1'\n          if split_url.query:\n              filename = filename + '_' + split_url.query\n\n        # Substitute invalid chars for '_'\n        filename = _RE_INVALID_CHARS.sub('_', filename)\n\n        # Since Windows (Explorer?) has a retarted limit for 255 chars for\n        # filename, including the path, we need to limit the filename to a sane\n        # size. In this case I am using 80 chars.\n        return filename[:80] + extension"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dump(self, filepath):\n        \"Attempt to dump an opened stream to path *filepath*.\"\n\n        common.ask_overwrite(filepath)\n\n        filename = os.path.basename(filepath)\n        file_size = 0\n        with open(filepath, 'ab') as f:\n            try:\n                while True:\n                    buf = self.fd.read(READ_BUFFER)\n                    if not buf:\n                        break\n                    f.write(buf)\n                    file_size = file_size + (READ_BUFFER / KB)\n                    print(\"Downloaded {} KB of file '{}'\".\n                          format(file_size, filename), end='\\r')\n            except KeyboardInterrupt:\n                self.exit(\"\\nPartial download of file '{}'\".format(filepath))\n\n        print(\"\\nComplete download of file '{}'\".format(filepath))", "response": "Attempt to dump an opened stream to path filepath *."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef urn(self, value: Union[URN, str]):\n        if isinstance(value, str):\n            value = URN(value)\n        elif not isinstance(value, URN):\n            raise TypeError(\"New urn must be string or {} instead of {}\".format(type(URN), type(value)))\n        self._urn = value", "response": "Set the urn of the current object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting easily a metadata from the CTS namespace", "response": "def get_cts_metadata(self, key: str, lang: str = None) -> Literal:\n        \"\"\" Get easily a metadata from the CTS namespace\n\n        :param key: CTS property to retrieve\n        :param lang: Language in which it should be\n        :return: Literal value of the CTS graph property\n        \"\"\"\n        return self.metadata.get_single(RDF_NAMESPACES.CTS.term(key), lang)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the object metadata using its collections recursively", "response": "def set_metadata_from_collection(self, text_metadata: CtsTextMetadata):\n        \"\"\" Set the object metadata using its collections recursively\n\n        :param text_metadata: Object representing the current text as a collection\n        :type text_metadata: CtsEditionMetadata or CtsTranslationMetadata\n        \"\"\"\n        edition, work, textgroup = tuple(([text_metadata] + text_metadata.parents)[:3])\n\n        for node in textgroup.metadata.get(RDF_NAMESPACES.CTS.groupname):\n            lang = node.language\n            self.metadata.add(RDF_NAMESPACES.CTS.groupname, lang=lang, value=str(node))\n            self.set_creator(str(node), lang)\n\n        for node in work.metadata.get(RDF_NAMESPACES.CTS.title):\n            lang = node.language\n            self.metadata.add(RDF_NAMESPACES.CTS.title, lang=lang, value=str(node))\n            self.set_title(str(node), lang)\n\n        for node in edition.metadata.get(RDF_NAMESPACES.CTS.label):\n            lang = node.language\n            self.metadata.add(RDF_NAMESPACES.CTS.label, lang=lang, value=str(node))\n            self.set_subject(str(node), lang)\n\n        for node in edition.metadata.get(RDF_NAMESPACES.CTS.description):\n            lang = node.language\n            self.metadata.add(RDF_NAMESPACES.CTS.description, lang=lang, value=str(node))\n            self.set_description(str(node), lang)\n\n        if not self.citation.is_set() and edition.citation.is_set():\n            self.citation = edition.citation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reffs(self) -> BaseReferenceSet:\n        if not self._cts:\n            self._cts = BaseReferenceSet(\n                [reff for reffs in [self.getReffs(level=i) for i in range(1, len(self.citation) + 1)] for reff in reffs]\n            )\n        return self._cts", "response": "Get all valid reffs for every part of the CtsText"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_datapoint(value, timestamp=None, **tags):\n    if timestamp is None:\n        timestamp = time_millis()\n\n    if type(timestamp) is datetime:\n        timestamp = datetime_to_time_millis(timestamp)\n\n    item = { 'timestamp': timestamp,\n             'value': value }\n\n    if tags is not None:\n        item['tags'] = tags\n\n    return item", "response": "Creates a single datapoint dict with a value timestamp and tags."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_metric(metric_type, metric_id, data):\n    if not isinstance(data, list):\n        data = [data]\n\n    return { 'type': metric_type,'id': metric_id, 'data': data }", "response": "Create Hawkular - Metrics submittable structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends multiple different metric_ids to the server in a single batch.", "response": "def put(self, data):\n        \"\"\"\n        Send multiple different metric_ids to the server in a single batch. Metrics can be a mixture\n        of types.\n\n        :param data: A dict or a list of dicts created with create_metric(metric_type, metric_id, datapoints)\n        \"\"\"\n        if not isinstance(data, list):\n            data = [data]\n\n        r = collections.defaultdict(list)\n\n        for d in data:\n            metric_type = d.pop('type', None)\n            if metric_type is None:\n                raise HawkularError('Undefined MetricType')\n            r[metric_type].append(d)\n\n        # This isn't transactional, but .. ouh well. One can always repost everything.\n        for l in r:\n            self._post(self._get_metrics_raw_url(self._get_url(l)), r[l],parse_json=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef push(self, metric_type, metric_id, value, timestamp=None):\n        if type(timestamp) is datetime:\n            timestamp = datetime_to_time_millis(timestamp)\n\n        item = create_metric(metric_type, metric_id, create_datapoint(value, timestamp))\n        self.put(item)", "response": "Pushes a single metric_id datapoint combination to the server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query_metric(self, metric_type, metric_id, start=None, end=None, **query_options):\n        if start is not None:\n            if type(start) is datetime:\n                query_options['start'] = datetime_to_time_millis(start)\n            else:\n                query_options['start'] = start\n\n        if end is not None:\n            if type(end) is datetime:\n                query_options['end'] = datetime_to_time_millis(end)\n            else:\n                query_options['end'] = end\n\n        return self._get(\n            self._get_metrics_raw_url(\n                self._get_metrics_single_url(metric_type, metric_id)),\n            **query_options)", "response": "Query the Hawkular - Metrics API for a single metric."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef query_metric_stats(self, metric_type, metric_id=None, start=None, end=None, bucketDuration=None, **query_options):\n        if start is not None:\n            if type(start) is datetime:\n                query_options['start'] = datetime_to_time_millis(start)\n            else:\n                query_options['start'] = start\n\n        if end is not None:\n            if type(end) is datetime:\n                query_options['end'] = datetime_to_time_millis(end)\n            else:\n                query_options['end'] = end\n\n        if bucketDuration is not None:\n            if type(bucketDuration) is timedelta:\n                query_options['bucketDuration'] = timedelta_to_duration(bucketDuration)\n            else:\n                query_options['bucketDuration'] = bucketDuration\n\n        if metric_id is not None:\n            url = self._get_metrics_stats_url(self._get_metrics_single_url(metric_type, metric_id))\n        else:\n            if len(query_options) < 0:\n                raise HawkularError('Tags are required when querying without metric_id')\n            url = self._get_metrics_stats_url(self._get_url(metric_type))\n\n        return self._get(url, **query_options)", "response": "Query for metric aggregates from the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nquery the definition of a single metric id.", "response": "def query_metric_definition(self, metric_type, metric_id):\n        \"\"\"\n        Query definition of a single metric id.\n\n        :param metric_type: MetricType to be matched (required)\n        :param metric_id: Exact string matching metric id\n        \"\"\"\n        return self._get(self._get_metrics_single_url(metric_type, metric_id))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef query_metric_definitions(self, metric_type=None, id_filter=None, **tags):\n        params = {}\n\n        if id_filter is not None:\n            params['id'] = id_filter\n\n        if metric_type is not None:\n            params['type'] = MetricType.short(metric_type)\n\n        if len(tags) > 0:\n            params['tags'] = self._transform_tags(**tags)\n\n        return self._get(self._get_url(), **params)", "response": "Query available metric definitions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nquerying for possible tag values.", "response": "def query_tag_values(self, metric_type=None, **tags):\n        \"\"\"\n        Query for possible tag values.\n\n        :param metric_type: A MetricType to be queried. If left to None, matches all the MetricTypes\n        :param tags: A dict of tag key/value pairs. Uses Hawkular-Metrics tag query language for syntax\n        \"\"\"\n        tagql = self._transform_tags(**tags)\n\n        return self._get(self._get_metrics_tags_url(self._get_url(metric_type)) + '/{}'.format(tagql))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a metric definition with custom definition.", "response": "def create_metric_definition(self, metric_type, metric_id, **tags):\n        \"\"\"\n        Create metric definition with custom definition. **tags should be a set of tags, such as\n        units, env ..\n\n        :param metric_type: MetricType of the new definition\n        :param metric_id: metric_id is the string index of the created metric\n        :param tags: Key/Value tag values of the new metric\n        \"\"\"\n        item = { 'id': metric_id }\n        if len(tags) > 0:\n            # We have some arguments to pass..\n            data_retention = tags.pop('dataRetention', None)\n            if data_retention is not None:\n                item['dataRetention'] = data_retention\n\n            if len(tags) > 0:\n                item['tags'] = tags\n\n        json_data = json.dumps(item, indent=2)\n        try:\n            self._post(self._get_url(metric_type), json_data)\n        except HawkularError as e:\n            if e.code == 409:\n                return False\n            raise e\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query_metric_tags(self, metric_type, metric_id):\n        definition = self._get(self._get_metrics_tags_url(self._get_metrics_single_url(metric_type, metric_id)))\n        return definition", "response": "Query the metric definition for tags."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the tags of the metric_id with the given tags.", "response": "def update_metric_tags(self, metric_type, metric_id, **tags):\n        \"\"\"\n        Replace the metric_id's tags with given **tags\n\n        :param metric_type: MetricType to be matched (required)\n        :param metric_id: Exact string matching metric id\n        :param tags: Updated key/value tag values of the metric\n        \"\"\"\n        self._put(self._get_metrics_tags_url(self._get_metrics_single_url(metric_type, metric_id)), tags, parse_json=False)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_metric_tags(self, metric_type, metric_id, **deleted_tags):\n        tags = self._transform_tags(**deleted_tags)\n        tags_url = self._get_metrics_tags_url(self._get_metrics_single_url(metric_type, metric_id)) + '/{0}'.format(tags)\n\n        self._delete(tags_url)", "response": "Delete one or more tags from the metric definition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a tenant. Currently nothing can be set (to be fixed after the master version of Hawkular-Metrics has fixed implementation. :param retentions: A set of retention settings, see Hawkular-Metrics documentation for more info", "response": "def create_tenant(self, tenant_id, retentions=None):\n        \"\"\"\n        Create a tenant. Currently nothing can be set (to be fixed after the master\n        version of Hawkular-Metrics has fixed implementation.\n\n        :param retentions: A set of retention settings, see Hawkular-Metrics documentation for more info\n        \"\"\"\n        item = { 'id': tenant_id }\n        if retentions is not None:\n            item['retentions'] = retentions\n\n        self._post(self._get_tenants_url(), json.dumps(item, indent=2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_default_options(num_machines=1, max_wallclock_seconds=1800, withmpi=False):\n    return {\n        'resources': {\n            'num_machines': int(num_machines)\n        },\n        'max_wallclock_seconds': int(max_wallclock_seconds),\n        'withmpi': withmpi,\n    }", "response": "Returns a dictionary with the minimally required parameters\n    for a JobCalculation and set to default values unless overriden\n    is True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef take_screenshot(self):\n\n    if not self.failed:\n        return\n\n    browser = getattr(world, 'browser', None)\n    if not browser:\n        return\n\n    try:\n        scenario_name = self.scenario.name\n        scenario_index = \\\n            self.scenario.feature.scenarios.index(self.scenario) + 1\n    except AttributeError:\n        scenario_name = self.background.keyword\n        scenario_index = 0\n\n    if self.outline is None:\n        outline_index_str = ''\n    else:\n        outline_index = self.scenario.outlines.index(self.outline) + 1\n        outline_index_str = '_{}'.format(outline_index)\n\n    base_name = FORMAT.format(\n        feature_file=os.path.relpath(self.feature.filename),\n        scenario_index=scenario_index,\n        scenario_name=scenario_name,\n        outline_index=outline_index_str,\n    )\n    base_name = re.sub(r'\\W', '_', base_name, flags=re.UNICODE)\n    base_name = os.path.join(DIRECTORY, base_name)\n\n    world.browser.save_screenshot('{}.png'.format(base_name))\n\n    with open('{}.html'.format(base_name), 'w') as page_source_file:\n        page_source_file.write(world.browser.page_source)", "response": "Take a screenshot after a failed step."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef kunc_p(v, v0, k0, k0p, order=5):\n    return cal_p_kunc(v, [v0, k0, k0p], order=order,\n                      uncertainties=isuncertainties([v, v0, k0, k0p]))", "response": "calculate Kunc EOS\n    see Dorogokupets 2015 for detail\n\n    :param v: unit-cell volume in A^3\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :param order: order for the Kunc equation\n    :return: pressure in GPa"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating pressure in Kunc EOS", "response": "def cal_p_kunc(v, k, order=5, uncertainties=True):\n    \"\"\"\n    calculate Kunc EOS,\n    see Dorogokupets2015 for functional form\n\n    :param v: unit-cell volume in A^3\n    :param k: [v0, k0, k0p]\n    :param order: order for the Kunc equation\n    :param uncertainties: use of uncertainties package\n    :return: pressure in GPa\n    :note: internal function\n    \"\"\"\n    v0 = k[0]\n    k0 = k[1]\n    k0p = k[2]\n    x = np.power(v / v0, 1. / 3.)\n    f1 = (1. - x) / (np.power(x, order))\n    if uncertainties:\n        f2 = unp.exp((1.5 * k0p - order + 0.5) * (1. - x))\n    else:\n        f2 = np.exp((1.5 * k0p - order + 0.5) * (1. - x))\n    p = 3. * k0 * f1 * f2\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef kunc_v_single(p, v0, k0, k0p, order=5, min_strain=0.01):\n    if p <= 1.e-5:\n        return v0\n\n    def f_diff(v, v0, k0, k0p, p, order=order):\n        return kunc_p(v, v0, k0, k0p, order=order) - p\n    v = brenth(f_diff, v0, v0 * min_strain, args=(v0, k0, k0p, p, order))\n    return v", "response": "find volume at given pressure using brenth in scipy. optimize\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding volume at given pressure using a Kunc function", "response": "def kunc_v(p, v0, k0, k0p, order=5, min_strain=0.01):\n    \"\"\"\n    find volume at given pressure using brenth in scipy.optimize\n\n    :param p: pressure in GPa\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :param order: order of Kunc function\n    :param min_strain: defining minimum v/v0 value to search volume for\n    :return: unit-cell volume at high pressure in GPa\n    :note: a wrapper function vectorizing kunc_v_single\n    \"\"\"\n    if isuncertainties([p, v0, k0, k0p]):\n        f_u = np.vectorize(uct.wrap(kunc_v_single), excluded=[1, 2, 3, 4, 5])\n        return f_u(p, v0, k0, k0p, order=order, min_strain=min_strain)\n    else:\n        f_v = np.vectorize(kunc_v_single, excluded=[1, 2, 3, 4, 5])\n        return f_v(p, v0, k0, k0p, order=order, min_strain=min_strain)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef kunc_dPdV(v, v0, k0, k0p, order=5, precision=1.e-5):\n    def f_scalar(v, v0, k0, k0p, order=order, precision=1.e-5):\n        return derivative(kunc_p, v, args=(v0, k0, k0p, order),\n                          dx=v0 * precision)\n    f_v = np.vectorize(f_scalar, excluded=[1, 2, 3, 4, 5])\n    return f_v(v, v0, k0, k0p, order=order, precision=precision)", "response": "calculate dP / dV for bulk modulus at reference conditions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate bulk modulus numerically from volume not pressure", "response": "def kunc_k_num(v, v0, k0, k0p, order=5, precision=1.e-5):\n    \"\"\"\n    calculate bulk modulus numerically from volume, not pressure\n    according to test this differs from analytical result by 1.e-5\n\n    :param v: unit-cell volume in A^3\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :param precision: precision for numerical calc (default = 1.e-5 * v0)\n    :return: bulk modulus\n    \"\"\"\n    return -1. * v * kunc_dPdV(v, v0, k0, k0p, order=order,\n                               precision=precision)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves the access modify and create timetags for a path.", "response": "def path_status(path, filename='', status=None, verbosity=0):\n    \"\"\" Retrieve the access, modify, and create timetags for a path along with its size\n\n    Arguments:\n        path (str): full path to the file or directory to be statused\n        status (dict): optional existing status to be updated/overwritten with new status values\n\n    Returns:\n        dict: {'size': bytes (int), 'accessed': (datetime), 'modified': (datetime), 'created': (datetime)}\n    \"\"\"\n    status = status or {}\n    if not filename:\n        dir_path, filename = os.path.split()  # this will split off a dir and as `filename` if path doesn't end in a /\n    else:\n        dir_path = path\n    full_path = os.path.join(dir_path, filename)\n    if verbosity > 1:\n        print(full_path)\n    status['name'] = filename\n    status['path'] = full_path\n    status['dir'] = dir_path\n    status['type'] = []\n    try:\n        status['size'] = os.path.getsize(full_path)\n        status['accessed'] = datetime.datetime.fromtimestamp(os.path.getatime(full_path))\n        status['modified'] = datetime.datetime.fromtimestamp(os.path.getmtime(full_path))\n        status['created'] = datetime.datetime.fromtimestamp(os.path.getctime(full_path))\n        status['mode'] = os.stat(full_path).st_mode   # first 3 digits are User, Group, Other permissions: 1=execute,2=write,4=read\n        if os.path.ismount(full_path):\n            status['type'] += ['mount-point']\n        elif os.path.islink(full_path):\n            status['type'] += ['symlink']\n        if os.path.isfile(full_path):\n            status['type'] += ['file']\n        elif os.path.isdir(full_path):\n            status['type'] += ['dir']\n        if not status['type']:\n            if os.stat.S_ISSOCK(status['mode']):\n                status['type'] += ['socket']\n            elif os.stat.S_ISCHR(status['mode']):\n                status['type'] += ['special']\n            elif os.stat.S_ISBLK(status['mode']):\n                status['type'] += ['block-device']\n            elif os.stat.S_ISFIFO(status['mode']):\n                status['type'] += ['pipe']\n        if not status['type']:\n            status['type'] += ['unknown']\n        elif status['type'] and status['type'][-1] == 'symlink':\n            status['type'] += ['broken']\n    except OSError:\n        status['type'] = ['nonexistent'] + status['type']\n        if verbosity > -1:\n            warnings.warn(\"Unable to stat path '{}'\".format(full_path))\n    status['type'] = '->'.join(status['type'])\n\n    return status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_files(path='', ext='', level=None, typ=list, dirs=False, files=True, verbosity=0):\n    gen = generate_files(path, ext=ext, level=level, dirs=dirs, files=files, verbosity=verbosity)\n    if isinstance(typ(), collections.Mapping):\n        return typ((ff['path'], ff) for ff in gen)\n    elif typ is not None:\n        return typ(gen)\n    else:\n        return gen", "response": "Find all files in the specified directory tree."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_files(path='', ext='', level=None, dirs=False, files=True, verbosity=0):\n    path = path or './'\n    ext = str(ext).lower()\n\n    for dir_path, dir_names, filenames in walk_level(path, level=level):\n        if verbosity > 0:\n            print('Checking path \"{}\"'.format(dir_path))\n        if files:\n            for fn in filenames:  # itertools.chain(filenames, dir_names)\n                if ext and not fn.lower().endswith(ext):\n                    continue\n                yield path_status(dir_path, fn, verbosity=verbosity)\n        if dirs:\n            # TODO: warn user if ext and dirs both set\n            for fn in dir_names:\n                if ext and not fn.lower().endswith(ext):\n                    continue\n                yield path_status(dir_path, fn, verbosity=verbosity)", "response": "Generate files in a directory tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize the token and return it as bytes.", "response": "def serialize(self):\n        \"\"\"Serialize the token and return it as bytes.\"\"\"\n        if type(self.value) == int:\n            return \"i{:X}s\".format(self.value).encode('ascii')\n\n        if type(self.value) == str:\n            value = self.value.encode('utf-8')\n            return \"{:X}:\".format(len(value)).encode('ascii') + value\n\n        if type(self.value) == bytes:\n            value = base64.standard_b64encode(self.value)\n            return \"u{:X}:\".format(len(value)).encode('ascii') + value\n\n        if type(self.value) == list:\n            items = [LiveMessageToken(m).serialize() for m in self.value]\n            return b'l' + b''.join(items) + b's'\n\n        if type(self.value) == dict:\n            items = []\n            for key, value in self.value.items():\n                items.append(LiveMessageToken(str(key)).serialize())\n                items.append(LiveMessageToken(value).serialize())\n            return b'h' + b''.join(items) + b's'\n\n        raise RuntimeError(\"Unknown type %s\" % type(self.value))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self, file_or_path, append=False, timeout=10):\n        if isinstance(file_or_path, six.string_types):\n            if self.coverage:\n                file_or_path = get_smother_filename(\n                    file_or_path, self.coverage.config.parallel)\n\n            outfile = Lock(\n                file_or_path, mode='a+',\n                timeout=timeout,\n                fail_when_locked=False\n            )\n        else:\n            outfile = noclose(file_or_path)\n\n        with outfile as fh:\n\n            if append:\n                fh.seek(0)\n                try:\n                    other = Smother.load(fh)\n                except ValueError:  # no smother data\n                    pass\n                else:\n                    self |= other\n\n            fh.seek(0)\n            fh.truncate()  # required to overwrite data in a+ mode\n            json.dump(self.data, fh)", "response": "Writes smother results to a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query_context(self, regions, file_factory=PythonFile):\n        result = set()\n\n        for region in regions:\n            try:\n                pf = file_factory(region.filename)\n            except InvalidPythonFile:\n                continue\n\n            # region and/or coverage report may use paths\n            # relative to this directory. Ensure we find a match\n            # if they use different conventions.\n            paths = {\n                os.path.abspath(region.filename),\n                os.path.relpath(region.filename)\n            }\n            for test_context, hits in six.iteritems(self.data):\n                if test_context in result:\n                    continue\n\n                for path in paths:\n                    if region.intersects(pf, hits.get(path, [])):\n                        result.add(test_context)\n\n        return QueryResult(result)", "response": "Query which set of test contexts intersect a set of code regions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninverting coverage data from source context to coverage data.", "response": "def _invert(self):\n        \"\"\"\n        Invert coverage data from {test_context: {file: line}}\n        to {file: {test_context: line}}\n        \"\"\"\n        result = defaultdict(dict)\n        for test_context, src_context in six.iteritems(self.data):\n            for src, lines in six.iteritems(src_context):\n                result[src][test_context] = lines\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the children of the current object to the given list of citation children.", "response": "def children(self, val: list):\n        \"\"\" Sets children\n\n        :param val: List of citation children\n        \"\"\"\n        final_value = []\n        if val is not None:\n            for citation in val:\n                if citation is None:\n                    continue\n                elif not isinstance(citation, (BaseCitation, type(self))):\n                    raise TypeError(\"Citation children should be Citation\")\n                else:\n                    if isinstance(self, BaseCitation):\n                        citation.root = self.root\n                    else:\n                        citation.root = self\n                    final_value.append(citation)\n\n        self._children = final_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a child to the citation set.", "response": "def add_child(self, child):\n        \"\"\" Adds a child to the CitationSet\n\n        :param child: Child citation to add\n        :return:\n        \"\"\"\n        if isinstance(child, BaseCitation):\n            self._children.append(child)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef depth(self) -> int:\n        if len(self.children):\n            return 1 + max([child.depth for child in self.children])\n        else:\n            return 1", "response": "Depth of the citation scheme."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget given property in CTS Namespace collection.", "response": "def get_cts_property(self, prop, lang=None):\n        \"\"\" Set given property in CTS Namespace\n\n        .. example::\n            collection.get_cts_property(\"groupname\", \"eng\")\n\n        :param prop: Property to get (Without namespace)\n        :param lang: Language to get for given value\n        :return: Value or default if lang is set, else whole set of values\n        :rtype: dict or Literal\n        \"\"\"\n        x = {\n            obj.language: obj for obj in self.metadata.get(RDF_NAMESPACES.CTS.term(prop))\n        }\n        if lang is not None:\n            if lang in x:\n                return x[lang]\n            return next(x.values())\n        return x"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting given property in CTS Namespace", "response": "def set_cts_property(self, prop, value, lang=None):\n        \"\"\" Set given property in CTS Namespace\n\n        .. example::\n            collection.set_cts_property(\"groupname\", \"MyCapytain\", \"eng\")\n\n        :param prop: Property to set (Without namespace)\n        :param value: Value to set for given property\n        :param lang: Language to set for given value\n        \"\"\"\n        if not isinstance(value, Literal):\n            value = Literal(value, lang=lang)\n        prop = RDF_NAMESPACES.CTS.term(prop)\n\n        if prop == self.DC_TITLE_KEY:\n            self.set_label(value, lang)\n\n        self.metadata.add(prop, value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting given link in CTS Namespace collection. set_link ( namespaces. CTS. about", "response": "def set_link(self, prop, value):\n        \"\"\" Set given link in CTS Namespace\n\n        .. example::\n            collection.set_link(NAMESPACES.CTS.about, \"urn:cts:latinLit:phi1294.phi002\")\n\n        :param prop: Property to set (Without namespace)\n        :param value: Value to set for given property\n        \"\"\"\n        # https://rdflib.readthedocs.io/en/stable/\n        # URIRef == identifiers (urn, http, URI in general)\n        # Literal == String or Number (can have a language)\n        # BNode == Anonymous nodes (So no specific identifier)\n        #\t\teg. BNode : Edition(MartialEpigrams:URIRef) ---has_metadata--> Metadata(BNode)\n        if not isinstance(value, URIRef):\n            value = URIRef(value)\n\n        self.metadata.add(prop, value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef editions(self):\n        return [\n                item\n                for urn, item in self.parent.children.items()\n                if isinstance(item, CtsEditionMetadata)\n            ]", "response": "Get all the editions of the texts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_creator(self, lang=None):\n        return self.parent.parent.metadata.get_label(lang=lang)", "response": "Get the DC Creator literal value for the given language"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_description(self, lang=None):\n        return self.metadata.get_single(key=RDF_NAMESPACES.CTS.description, lang=lang)", "response": "Get the DC description of the object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lang(self):\n        return str(self.graph.value(self.asNode(), DC.language))", "response": "Returns the language of the current text in the language graph."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the language of this text in the node graph.", "response": "def lang(self, lang):\n        \"\"\" Language this text is available in\n\n        :param lang: Language to add\n        :type lang: str\n        \"\"\"\n        self.graph.set((self.asNode(), DC.language, Literal(lang)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, other):\n        if not isinstance(other, CtsWorkMetadata):\n            raise TypeError(\"Cannot add %s to CtsWorkMetadata\" % type(other))\n        elif self.urn != other.urn:\n            raise InvalidURN(\"Cannot add CtsWorkMetadata %s to CtsWorkMetadata %s \" % (self.urn, other.urn))\n\n        for urn, text in other.children.items():\n            self.texts[urn] = text\n            self.texts[urn].parent = self\n            self.texts[urn].resource = None\n\n        return self", "response": "Merge two XmlCtsWorkMetadata Objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_translation_in(self, key=None):\n        if key is not None:\n            return [\n                item\n                for item in self.texts.values()\n                if isinstance(item, CtsTranslationMetadata) and item.lang == key\n                ]\n        else:\n            return [\n                item\n                for item in self.texts.values()\n                if isinstance(item, CtsTranslationMetadata)\n            ]", "response": "Returns a list of availableables translations in the language specified by key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmerge two Textgroup Objects.", "response": "def update(self, other):\n        \"\"\" Merge two Textgroup Objects.\n\n        - Original (left Object) keeps his parent.\n        - Added document merges with work if it already exists\n\n        :param other: Textgroup object\n        :type other: CtsTextgroupMetadata\n        :return: Textgroup Object\n        :rtype: CtsTextgroupMetadata\n        \"\"\"\n        if not isinstance(other, CtsTextgroupMetadata):\n            raise TypeError(\"Cannot add %s to CtsTextgroupMetadata\" % type(other))\n        elif str(self.urn) != str(other.urn):\n            raise InvalidURN(\"Cannot add CtsTextgroupMetadata %s to CtsTextgroupMetadata %s \" % (self.urn, other.urn))\n\n        for urn, work in other.works.items():\n            if urn in self.works:\n                self.works[urn].update(deepcopy(work))\n            else:\n                self.works[urn] = deepcopy(work)\n            self.works[urn].parent = self\n            self.works[urn].resource = None\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, tags=[], trigger_ids=[]):\n        params = {}\n        if len(tags) > 0:\n            params['tags'] = ','.join(tags)\n\n        if len(trigger_ids) > 0:\n            params['triggerIds'] = ','.join(trigger_ids)\n\n        url = self._service_url('triggers', params=params)\n        triggers_dict = self._get(url)\n        return Trigger.list_to_object_list(triggers_dict)", "response": "Get all the triggers with optional filtering. Querying without parameters returns all the trigger definitions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, trigger):\n        data = self._serialize_object(trigger)\n        if isinstance(trigger, FullTrigger):\n            returned_dict = self._post(self._service_url(['triggers', 'trigger']), data)\n            return FullTrigger(returned_dict)\n        else:\n            returned_dict = self._post(self._service_url('triggers'), data)\n            return Trigger(returned_dict)", "response": "Create a new trigger."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating an existing full trigger.", "response": "def update(self, trigger_id, full_trigger):\n        \"\"\"\n        Update an existing full trigger.\n\n        :param full_trigger: FullTrigger with conditions, dampenings and triggers\n        :type full_trigger: FullTrigger\n        :return: Updated FullTrigger definition\n        \"\"\"\n        data = self._serialize_object(full_trigger)\n        rdict = self._put(self._service_url(['triggers', 'trigger', trigger_id]), data)\n        return FullTrigger(rdict)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a single trigger definition.", "response": "def single(self, trigger_id, full=False):\n        \"\"\"\n        Get an existing (full) trigger definition.\n\n        :param trigger_id: Trigger definition id to be retrieved.\n        :param full: Fetch the full definition, default is False.\n        :return: Trigger of FullTrigger depending on the full parameter value.\n        \"\"\"\n        if full:\n            returned_dict = self._get(self._service_url(['triggers', 'trigger', trigger_id]))\n            return FullTrigger(returned_dict)\n        else:\n            returned_dict = self._get(self._service_url(['triggers', trigger_id]))\n            return Trigger(returned_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new group trigger.", "response": "def create_group(self, trigger):\n        \"\"\"\n        Create a new group trigger.\n\n        :param trigger: Group member trigger to be created\n        :return: The created group Trigger\n        \"\"\"\n        data = self._serialize_object(trigger)\n        return Trigger(self._post(self._service_url(['triggers', 'groups']), data))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all group members trigger definitions in a group.", "response": "def group_members(self, group_id, include_orphans=False):\n        \"\"\"\n        Find all group member trigger definitions\n\n        :param group_id: group trigger id\n        :param include_orphans: If True, include orphan members\n        :return: list of asociated group members as trigger objects\n        \"\"\"\n        params = {'includeOrphans': str(include_orphans).lower()}\n        url = self._service_url(['triggers', 'groups', group_id, 'members'], params=params)\n        return Trigger.list_to_object_list(self._get(url))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_group(self, group_id, trigger):\n        data = self._serialize_object(trigger)\n        self._put(self._service_url(['triggers', 'groups', group_id]), data, parse_json=False)", "response": "Update an existing group trigger definition and its member definitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_group(self, group_id, keep_non_orphans=False, keep_orphans=False):\n        params = {'keepNonOrphans': str(keep_non_orphans).lower(), 'keepOrphans': str(keep_orphans).lower()}\n        self._delete(self._service_url(['triggers', 'groups', group_id], params=params))", "response": "Delete a group trigger from the cache"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new member trigger for a parent trigger.", "response": "def create_group_member(self, member):\n        \"\"\"\n        Create a new member trigger for a parent trigger.\n\n        :param member: Group member trigger to be created\n        :type member: GroupMemberInfo\n        :return: A member Trigger object\n        \"\"\"\n        data = self._serialize_object(member)\n        return Trigger(self._post(self._service_url(['triggers', 'groups', 'members']), data))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_group_conditions(self, group_id, conditions, trigger_mode=None):\n        data = self._serialize_object(conditions)\n\n        if trigger_mode is not None:\n            url = self._service_url(['triggers', 'groups', group_id, 'conditions', trigger_mode])\n        else:\n            url = self._service_url(['triggers', 'groups', group_id, 'conditions'])\n\n        response = self._put(url, data)\n        return Condition.list_to_object_list(response)", "response": "Set the group conditions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_conditions(self, trigger_id, conditions, trigger_mode=None):\n        data = self._serialize_object(conditions)\n        if trigger_mode is not None:\n            url = self._service_url(['triggers', trigger_id, 'conditions', trigger_mode])\n        else:\n            url = self._service_url(['triggers', trigger_id, 'conditions'])\n\n        response = self._put(url, data)\n        return Condition.list_to_object_list(response)", "response": "Set the conditions for the relevant trigger."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all conditions for a specific trigger.", "response": "def conditions(self, trigger_id):\n        \"\"\"\n        Get all conditions for a specific trigger.\n\n        :param trigger_id: Trigger definition id to be retrieved\n        :return: list of condition objects\n        \"\"\"\n        response = self._get(self._service_url(['triggers', trigger_id, 'conditions']))\n        return  Condition.list_to_object_list(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all Dampenings for a given Trigger.", "response": "def dampenings(self, trigger_id, trigger_mode=None):\n        \"\"\"\n        Get all Dampenings for a Trigger (1 Dampening per mode).\n\n        :param trigger_id: Trigger definition id to be retrieved.\n        :param trigger_mode: Optional TriggerMode which is only fetched\n        :type trigger_mode: TriggerMode\n        :return: List of Dampening objects\n        \"\"\"\n        if trigger_mode is not None:\n            url = self._service_url(['triggers', trigger_id, 'dampenings', 'mode', trigger_mode])\n        else:\n            url = self._service_url(['triggers', trigger_id, 'dampenings'])\n\n        data = self._get(url)\n        return Dampening.list_to_object_list(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new dampening.", "response": "def create_dampening(self, trigger_id, dampening):\n        \"\"\"\n        Create a new dampening.\n\n        :param trigger_id: TriggerId definition attached to the dampening\n        :param dampening: Dampening definition to be created.\n        :type dampening: Dampening\n        :return: Created dampening\n        \"\"\"\n        data = self._serialize_object(dampening)\n        url = self._service_url(['triggers', trigger_id, 'dampenings'])\n        return Dampening(self._post(url, data))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_dampening(self, trigger_id, dampening_id):\n        self._delete(self._service_url(['triggers', trigger_id, 'dampenings', dampening_id]))", "response": "Delete an existing dampening definition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate an existing dampening definition.", "response": "def update_dampening(self, trigger_id, dampening_id):\n        \"\"\"\n        Update an existing dampening definition.\n\n        Note that the trigger mode can not be changed using this method.\n        :param trigger_id: Trigger definition id targeted for update.\n        :param dampening_id: Dampening definition id to be updated.\n        :return: Updated Dampening\n        \"\"\"\n        data = self._serialize_object(dampening)\n        url = self._service_url(['triggers', trigger_id, 'dampenings', dampening_id])\n        return Dampening(self._put(url, data))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new group dampening.", "response": "def create_group_dampening(self, group_id, dampening):\n        \"\"\"\n        Create a new group dampening\n\n        :param group_id: Group Trigger id attached to dampening\n        :param dampening: Dampening definition to be created.\n        :type dampening: Dampening\n        :return: Group Dampening created\n        \"\"\"\n        data = self._serialize_object(dampening)\n        url = self._service_url(['triggers', 'groups', group_id, 'dampenings'])\n        return Dampening(self._post(url, data))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates an existing group dampening", "response": "def update_group_dampening(self, group_id, dampening_id, dampening):\n        \"\"\"\n        Update an existing group dampening\n\n        :param group_id: Group Trigger id attached to dampening\n        :param dampening_id: id of the dampening to be updated\n        :return: Group Dampening created\n        \"\"\"\n        data = self._serialize_object(dampening)\n        url = self._service_url(['triggers', 'groups', group_id, 'dampenings', dampening_id])\n        return Dampening(self._put(url, data))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete an existing group dampening", "response": "def delete_group_dampening(self, group_id, dampening_id):\n        \"\"\"\n        Delete an existing group dampening\n\n        :param group_id: Group Trigger id to be retrieved\n        :param dampening_id: id of the Dampening to be deleted\n        \"\"\"\n        self._delete(self._service_url(['triggers', 'groups', group_id, 'dampenings', dampening_id]))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_group_member_orphan(self, member_id):\n        self._put(self._service_url(['triggers', 'groups', 'members', member_id, 'orphan']), data=None, parse_json=False)", "response": "Make a non - orphan member trigger into an orphan."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_group_member_unorphan(self, member_id, unorphan_info):\n        data = self._serialize_object(unorphan_info)\n        data = self._service_url(['triggers', 'groups', 'members', member_id, 'unorphan'])\n        return Trigger(self._put(url, data))", "response": "Set an orphan member trigger into a group trigger."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef enable(self, trigger_ids=[]):\n        trigger_ids = ','.join(trigger_ids)\n        url = self._service_url(['triggers', 'enabled'], params={'triggerIds': trigger_ids, 'enabled': 'true'})\n        self._put(url, data=None, parse_json=False)", "response": "Enable all the triggers in the specified list of trigger ids."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef launch_cif_clean(cif_filter, cif_select, group_cif_raw, group_cif_clean, group_structure, group_workchain, node,\n    max_entries, skip_check, parse_engine, daemon):\n    \"\"\"Run the `CifCleanWorkChain` on the entries in a group with raw imported CifData nodes.\n\n    It will use the `cif_filter` and `cif_select` scripts of `cod-tools` to clean the input cif file. Additionally, if\n    the `group-structure` option is passed, the workchain will also attempt to use the given parse engine to parse the\n    cleaned `CifData` to obtain the structure and then use SeeKpath to find the primitive structure, which, if\n    successful, will be added to the `group-structure` group.\n    \"\"\"\n    # pylint: disable=too-many-arguments,too-many-locals,too-many-statements,too-many-branches\n    import inspect\n    from datetime import datetime\n\n    from aiida import orm\n    from aiida.engine import launch\n    from aiida.plugins import DataFactory, WorkflowFactory\n    from aiida_codtools.common.cli import echo_utc\n    from aiida_codtools.common.resources import get_default_options\n    from aiida_codtools.common.utils import get_input_node\n\n    CifData = DataFactory('cif')  # pylint: disable=invalid-name\n    CifCleanWorkChain = WorkflowFactory('codtools.cif_clean')  # pylint: disable=invalid-name\n\n    # Collect the dictionary of not None parameters passed to the launch script and print to screen\n    local_vars = locals()\n    launch_paramaters = {}\n    for arg in inspect.getargspec(launch_cif_clean.callback).args:  # pylint: disable=deprecated-method\n        if arg in local_vars and local_vars[arg]:\n            launch_paramaters[arg] = local_vars[arg]\n\n    click.echo('=' * 80)\n    click.echo('Starting on {}'.format(datetime.utcnow().isoformat()))\n    click.echo('Launch parameters: {}'.format(launch_paramaters))\n    click.echo('-' * 80)\n\n    if group_cif_raw is not None:\n\n        # Get CifData nodes that should actually be submitted according to the input filters\n        builder = orm.QueryBuilder()\n        builder.append(orm.Group, filters={'id': {'==': group_cif_raw.pk}}, tag='group')\n\n        if skip_check:\n            builder.append(CifData, with_group='group', project=['*'])\n        else:\n            # Get CifData nodes that already have an associated workchain node in the `group_workchain` group.\n            submitted = orm.QueryBuilder()\n            submitted.append(orm.WorkChainNode, tag='workchain')\n            submitted.append(orm.Group, filters={'id': {'==': group_workchain.pk}}, with_node='workchain')\n            submitted.append(orm.CifData, with_outgoing='workchain', tag='data', project=['id'])\n            submitted_nodes = set(pk for entry in submitted.all() for pk in entry)\n\n            if submitted_nodes:\n                filters = {'id': {'!in': submitted_nodes}}\n            else:\n                filters = {}\n\n            # Get all CifData nodes that are not included in the submitted node list\n            builder.append(CifData, with_group='group', filters=filters, project=['*'])\n\n        if max_entries is not None:\n            builder.limit(int(max_entries))\n\n        nodes = [entry[0] for entry in builder.all()]\n\n    elif node is not None:\n\n        nodes = [node]\n\n    else:\n        raise click.BadParameter('you have to specify either --group-cif-raw or --node')\n\n    counter = 0\n\n    node_cif_filter_parameters = get_input_node(orm.Dict, {\n        'fix-syntax-errors': True,\n        'use-c-parser': True,\n        'use-datablocks-without-coordinates': True,\n    })\n\n    node_cif_select_parameters = get_input_node(orm.Dict, {\n        'canonicalize-tag-names': True,\n        'dont-treat-dots-as-underscores': True,\n        'invert': True,\n        'tags': '_publ_author_name,_citation_journal_abbrev',\n        'use-c-parser': True,\n    })\n\n    node_options = get_input_node(orm.Dict, get_default_options())\n    node_parse_engine = get_input_node(orm.Str, parse_engine)\n    node_site_tolerance = get_input_node(orm.Float, 5E-4)\n    node_symprec = get_input_node(orm.Float, 5E-3)\n\n    for cif in nodes:\n\n        inputs = {\n            'cif': cif,\n            'cif_filter': cif_filter,\n            'cif_select': cif_select,\n            'cif_filter_parameters': node_cif_filter_parameters,\n            'cif_select_parameters': node_cif_select_parameters,\n            'options': node_options,\n            'parse_engine': node_parse_engine,\n            'site_tolerance': node_site_tolerance,\n            'symprec': node_symprec,\n        }\n\n        if group_cif_clean is not None:\n            inputs['group_cif'] = group_cif_clean\n\n        if group_structure is not None:\n            inputs['group_structure'] = group_structure\n\n        if daemon:\n            workchain = launch.submit(CifCleanWorkChain, **inputs)\n            echo_utc('CifData<{}> submitting: {}<{}>'.format(cif.pk, CifCleanWorkChain.__name__, workchain.pk))\n        else:\n            echo_utc('CifData<{}> running: {}'.format(cif.pk, CifCleanWorkChain.__name__))\n            _, workchain = launch.run_get_node(CifCleanWorkChain, **inputs)\n\n        if group_workchain is not None:\n            group_workchain.add_nodes([workchain])\n\n        counter += 1\n\n        if max_entries is not None and counter >= max_entries:\n            break\n\n    click.echo('-' * 80)\n    click.echo('Submitted {} new workchains'.format(counter))\n    click.echo('Stopping on {}'.format(datetime.utcnow().isoformat()))\n    click.echo('=' * 80)", "response": "Launch a CifCleanWorkChain on the entries in a group with raw imported CifData nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef eventize(self, granularity):\n\n        df_columns = {}\n        # Init common columns\n        self._init_common_fields(df_columns)\n\n        # First level granularity\n        df_columns[Git.COMMIT_ID] = []\n        df_columns[Git.COMMIT_EVENT] = []\n        df_columns[Git.COMMIT_DATE] = []\n        df_columns[Git.COMMIT_OWNER] = []\n        df_columns[Git.COMMIT_COMMITTER] = []\n        df_columns[Git.COMMIT_COMMITTER_DATE] = []\n        df_columns[Git.COMMIT_REPOSITORY] = []\n        df_columns[Git.COMMIT_MESSAGE] = []\n        df_columns[Git.COMMIT_NUM_FILES] = []\n        df_columns[Git.COMMIT_ADDED_LINES] = []\n        df_columns[Git.COMMIT_REMOVED_LINES] = []\n        df_columns[Git.COMMIT_HASH] = []\n        df_columns[Git.AUTHOR_DOMAIN] = []\n\n        # Second level of granularity\n        df_columns[Git.FILE_FILES] = []\n        df_columns[Git.FILE_EVENT] = []\n        df_columns[Git.FILE_PATH] = []\n        df_columns[Git.FILE_ADDED_LINES] = []\n        df_columns[Git.FILE_REMOVED_LINES] = []\n\n        events = pandas.DataFrame()\n\n        for item in self.items:\n            commit_data = item[\"data\"]\n            if granularity == 1:\n                self._add_common_fields(df_columns, item)\n                self.__add_commit_info(df_columns, item)\n\n                added_lines = 0\n                removed_lines = 0\n                files = commit_data[\"files\"]\n                df_columns[Git.COMMIT_NUM_FILES] = int(len(files))\n                for f in files:\n                    if \"added\" in f.keys() and f[\"added\"] != \"-\":\n                        added_lines = added_lines + int(f[\"added\"])\n                    if \"removed\" in f.keys() and f[\"removed\"] != \"-\":\n                        removed_lines = removed_lines + int(f[\"removed\"])\n                df_columns[Git.COMMIT_ADDED_LINES] = added_lines\n                df_columns[Git.COMMIT_REMOVED_LINES] = removed_lines\n\n            # TODO: this will fail if no files are found in a commit (eg: merge)\n            if granularity == 2:\n                # Add extra info about files actions, if there were any\n                if \"files\" in commit_data.keys():\n                    files = commit_data[\"files\"]\n                    nfiles = 0\n                    for f in files:\n                        if \"action\" in f.keys():\n                            nfiles += 1\n\n                    for f in files:\n                        self._add_common_fields(df_columns, item)\n                        self.__add_commit_info(df_columns, item)\n\n                        df_columns[Git.FILE_FILES].append(nfiles)\n\n                        if \"action\" in f.keys():\n                            df_columns[Git.FILE_EVENT].append(Git.EVENT_FILE + f[\"action\"])\n                        else:\n                            df_columns[Git.FILE_EVENT].append(\"-\")\n\n                        if \"file\" in f.keys():\n                            df_columns[Git.FILE_PATH].append(f[\"file\"])\n                        else:\n                            df_columns[Git.FILE_PATH].append(\"-\")\n\n                        if \"added\" in f.keys():\n                            if f[\"added\"] == \"-\":\n                                df_columns[Git.FILE_ADDED_LINES].append(0)\n                            else:\n                                df_columns[Git.FILE_ADDED_LINES].append(int(f[\"added\"]))\n                        else:\n                            df_columns[Git.FILE_ADDED_LINES].append(0)\n\n                        if \"removed\" in f.keys():\n                            if f[\"removed\"] == \"-\":\n                                df_columns[Git.FILE_REMOVED_LINES].append(0)\n                            else:\n                                df_columns[Git.FILE_REMOVED_LINES].append(int(f[\"removed\"]))\n                        else:\n                            df_columns[Git.FILE_REMOVED_LINES].append(0)\n\n                else:\n                    print(\"Merge found, doing nothing...\")\n\n            if granularity == 3:\n                # TDB\n                pass\n\n        # Done in this way to have an order (and not a direct cast)\n        self._add_common_events(events, df_columns)\n\n        events[Git.COMMIT_ID] = df_columns[Git.COMMIT_ID]\n        events[Git.COMMIT_EVENT] = df_columns[Git.COMMIT_EVENT]\n        events[Git.COMMIT_DATE] = df_columns[Git.COMMIT_DATE]\n        events[Git.COMMIT_OWNER] = df_columns[Git.COMMIT_OWNER]\n        events[Git.COMMIT_COMMITTER] = df_columns[Git.COMMIT_COMMITTER]\n        events[Git.COMMIT_COMMITTER_DATE] = df_columns[Git.COMMIT_COMMITTER_DATE]\n        events[Git.COMMIT_REPOSITORY] = df_columns[Git.COMMIT_REPOSITORY]\n        events[Git.COMMIT_MESSAGE] = df_columns[Git.COMMIT_MESSAGE]\n        events[Git.COMMIT_HASH] = df_columns[Git.COMMIT_HASH]\n        events[Git.AUTHOR_DOMAIN] = df_columns[Git.AUTHOR_DOMAIN]\n\n        if granularity == 1:\n            events[Git.COMMIT_NUM_FILES] = df_columns[Git.COMMIT_NUM_FILES]\n            events[Git.COMMIT_ADDED_LINES] = df_columns[Git.COMMIT_ADDED_LINES]\n            events[Git.COMMIT_REMOVED_LINES] = df_columns[Git.COMMIT_REMOVED_LINES]\n        if granularity == 2:\n            events[Git.FILE_FILES] = df_columns[Git.FILE_FILES]\n            events[Git.FILE_EVENT] = df_columns[Git.FILE_EVENT]\n            events[Git.FILE_PATH] = df_columns[Git.FILE_PATH]\n            events[Git.FILE_ADDED_LINES] = df_columns[Git.FILE_ADDED_LINES]\n            events[Git.FILE_REMOVED_LINES] = df_columns[Git.FILE_REMOVED_LINES]\n\n        return events", "response": "This function splits the JSON information found at self. events into several events."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nguess a location lat / lon from the provided string", "response": "def geocode(location, *args, **kwargs):\n    \"\"\"Guess a location lat/lon from the provided string\n\n    Returns:\n      str: +##.####,+###.####,### latitude, longitude, distance\n           A location and radius in twitter geocode format\n\n    >>> geocode('')\n    '45.52,-122.6819,20mi'\n    \"\"\"\n    location = LOCATIONS.get(location, location)\n    if len(args):\n        location = [location] + args\n    try:\n        llr = location.split(',')\n    except:\n        llr = [str(s).strip.lower() for s in location]\n    llr = [s for s in llr if s]\n    for i in range(len(LOCATIONS['Portland'])):\n        if len(llr) < i + 1:\n            llr += [LOCATIONS['Portland'][i]]\n    if str(llr[-1])[-2:] not in DISTANCE_UNITS:\n        llr[-1] = str(llr[-1]) + DISTANCE_UNITS[0]\n    return ','.join([str(value) for value in llr])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a list of Twitter objects", "response": "def get_twitter(app_key=None, app_secret=None, search='python', location='', **kwargs):\n    \"\"\"Location may be specified with a string name or latitude, longitude, radius\"\"\"\n    if not app_key:\n        from settings_secret import TWITTER_API_KEY as app_key\n    if not app_secret:\n        from settings_secret import TWITTER_API_SECRET as app_secret\n    twitter = Twython(app_key, app_secret, oauth_version=2)\n    return Twython(app_key, access_token=twitter.obtain_access_token())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndumps a limitted number of json. dump -able objects to the specified file", "response": "def limitted_dump(cursor=None, twitter=None, path='tweets.json', limit=450, rate=TWITTER_SEARCH_RATE_LIMIT, indent=-1):\n    \"\"\"Dump a limitted number of json.dump-able objects to the indicated file\n\n    rate (int): Number of queries per 15 minute twitter window\n    \"\"\"\n    if not twitter:\n        twitter = get_twitter()\n    cursor = cursor or 'python'\n    if isinstance(cursor, basestring):\n        cursor = get_cursor(twitter, search=cursor)\n    newline = '\\n' if indent is not None else ''\n    if indent < 0:\n        indent = None\n    # TODO: keep track of T0 for the optimal \"reset\" sleep duration\n    with (open(path, 'w') if not isinstance(path, file) else path) as f:\n        f.write('[\\n')\n        for i, obj in enumerate(cursor):\n            f.write(json.dumps(obj, indent=indent))\n            if i < limit - 1:\n                f.write(',' + newline)\n            else:\n                break\n            remaining = int(twitter.get_lastfunction_header('x-rate-limit-remaining'))\n            if remaining > 0:\n                sleep(1. / rate)\n            else:\n                sleep(15 * 60)\n        f.write('\\n]\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a text node from the API and return it as a DtsResolverDocument object.", "response": "def getTextualNode(\n            self,\n            textId: str,\n            subreference: Union[str, BaseReference]=None,\n            prevnext: bool=False,\n            metadata: bool=False\n    ) -> DtsResolverDocument:\n        \"\"\" Retrieve a text node from the API\n\n        :param textId: CtsTextMetadata Identifier\n        :type textId: str\n        :param subreference: CapitainsCtsPassage Reference\n        :type subreference: str\n        :param prevnext: Retrieve graph representing previous and next passage\n        :type prevnext: boolean\n        :param metadata: Retrieve metadata about the passage and the text\n        :type metadata: boolean\n        :return: CapitainsCtsPassage\n        :rtype: CapitainsCtsPassage\n        \"\"\"\n        return DtsResolverDocument.parse(\n            identifier=textId,\n            reference=subreference,\n            resolver=self,\n            response=self.endpoint.get_document(collection_id=textId, ref=subreference)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef altshuler_grun(v, v0, gamma0, gamma_inf, beta):\n    x = v / v0\n    return gamma_inf + (gamma0 - gamma_inf) * np.power(x, beta)", "response": "calculate Gruneisen parameter for Altshuler equation"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef altshuler_debyetemp(v, v0, gamma0, gamma_inf, beta, theta0):\n    x = v / v0\n    if isuncertainties([v, v0, gamma0, gamma_inf, beta, theta0]):\n        theta = theta0 * np.power(x, -1. * gamma_inf) *\\\n            unp.exp((gamma0 - gamma_inf) / beta * (1. - np.power(x, beta)))\n    else:\n        theta = theta0 * np.power(x, -1. * gamma_inf) *\\\n            np.exp((gamma0 - gamma_inf) / beta * (1. - np.power(x, beta)))\n    return theta", "response": "calculate Debye temperature for Altshuler equation"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates thermal pressure for Dorogokupets 2007", "response": "def dorogokupets2007_pth(v, temp, v0, gamma0, gamma_inf, beta, theta0, n, z,\n                         three_r=3. * constants.R, t_ref=300.):\n    \"\"\"\n    calculate thermal pressure for Dorogokupets 2007 EOS\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature in K\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param gamma_inf: Gruneisen parameter at infinite pressure\n    :param beta: volume dependence of Gruneisen parameter\n    :param theta0: Debye temperature at 1 bar in K\n    :param n: number of elements in a chemical formula\n    :param z: number of formula unit in a unit cell\n    :param three_r: 3 times gas constant.\n        Jamieson modified this value to compensate for mismatches\n    :param t_ref: reference temperature, 300 K\n    :return: thermal pressure in GPa\n    \"\"\"\n    v_mol = vol_uc2mol(v, z)\n    # x = v_mol / v0_mol\n    gamma = altshuler_grun(v, v0, gamma0, gamma_inf, beta)\n    theta = altshuler_debyetemp(v, v0, gamma0, gamma_inf, beta, theta0)\n\n    def f(t):\n        xx = theta / t\n        debye = debye_E(xx)\n        Eth = three_r * n * t * debye\n        return (gamma / v_mol * Eth) * 1.e-9\n    return f(temp) - f(t_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting to admin interface and application.", "response": "def bind(cls, app, *paths, methods=None, name=None, view=None):\n        \"\"\"Connect to admin interface and application.\"\"\"\n        # Register self in admin\n        if view is None:\n            app.ps.admin.register(cls)\n            if not paths:\n                paths = ('%s/%s' % (app.ps.admin.cfg.prefix, name or cls.name),)\n            cls.url = paths[0]\n        return super(AdminHandler, cls).bind(app, *paths, methods=methods, name=name, view=view)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters admin view action.", "response": "def action(cls, view):\n        \"\"\"Register admin view action.\"\"\"\n        name = \"%s:%s\" % (cls.name, view.__name__)\n        path = \"%s/%s\" % (cls.url, view.__name__)\n        cls.actions.append((view.__doc__, path))\n        return cls.register(path, name=name)(view)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsorts the related objects in the database.", "response": "async def sort(self, request, reverse=False):\n        \"\"\"Sort collection.\"\"\"\n        return sorted(\n            self.collection, key=lambda o: getattr(o, self.columns_sort, 0), reverse=reverse)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbase point load resource.", "response": "async def get_form(self, request):\n        \"\"\"Base point load resource.\"\"\"\n        if not self.form:\n            return None\n        formdata = await request.post()\n        return self.form(formdata, obj=self.resource)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets collection of resources.", "response": "async def get(self, request):\n        \"\"\"Get collection of resources.\"\"\"\n        form = await self.get_form(request)\n        ctx = dict(active=self, form=form, request=request)\n        if self.resource:\n            return self.app.ps.jinja2.render(self.template_item, **ctx)\n        return self.app.ps.jinja2.render(self.template_list, **ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating or edit items.", "response": "async def post(self, request):\n        \"\"\"Create/Edit items.\"\"\"\n        form = await self.get_form(request)\n        if not form.validate():\n            raise muffin.HTTPBadRequest(\n                text=json.dumps(form.errors), content_type='application/json')\n        await self.save_form(form, request)\n        raise muffin.HTTPFound(self.url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef columns_formatter(cls, colname):\n        def wrapper(func):\n            cls.columns_formatters[colname] = func\n            return func\n        return wrapper", "response": "Decorator to mark a function as columns formatter."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders the value of a column.", "response": "def render_value(self, data, column):\n        \"\"\"Render value.\"\"\"\n        renderer = self.columns_formatters.get(column, format_value)\n        return renderer(self, data, column)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a copy of the environment variables that will be run with this command.", "response": "def env(self):\n        \"\"\"\n        Dict of all environment variables that will be run with this command.\n        \"\"\"\n        env_vars = os.environ.copy()\n        env_vars.update(self._env)\n        new_path = \":\".join(\n            self._paths + [env_vars[\"PATH\"]] if \"PATH\" in env_vars else [] + self._paths\n        )\n        env_vars[\"PATH\"] = new_path\n        for env_var in self._env_drop:\n            if env_var in env_vars:\n                del env_vars[env_var]\n        return env_vars"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a copy of the current command that will not raise an exception when the return code > 0.", "response": "def ignore_errors(self):\n        \"\"\"\n        Return new command object that will not raise an exception when\n        return code > 0.\n        \"\"\"\n        new_command = copy.deepcopy(self)\n        new_command._ignore_errors = True\n        return new_command"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef with_env(self, **environment_variables):\n        new_env_vars = {\n            str(var): str(val) for var, val in environment_variables.items()\n        }\n        new_command = copy.deepcopy(self)\n        new_command._env.update(new_env_vars)\n        return new_command", "response": "Returns a new Command object that will be run with additional environment variables."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef without_env(self, environment_variable):\n        new_command = copy.deepcopy(self)\n        new_command._env_drop.append(str(environment_variable))\n        return new_command", "response": "Returns a new Command object that will drop a specified environment variable if it is set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef in_dir(self, directory):\n        new_command = copy.deepcopy(self)\n        new_command._directory = str(directory)\n        return new_command", "response": "Returns a copy of this Command object that will be run in specified directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new Command object that will be run using shell.", "response": "def with_shell(self):\n        \"\"\"\n        Return new Command object that will be run using shell.\n        \"\"\"\n        new_command = copy.deepcopy(self)\n        new_command._shell = True\n        return new_command"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef with_trailing_args(self, *arguments):\n        new_command = copy.deepcopy(self)\n        new_command._trailing_args = [str(arg) for arg in arguments]\n        return new_command", "response": "Returns a new Command object that will be run with specified trailing arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new Command object that will be run with a new addition to the PATH environment variable that will be fed to the command.", "response": "def with_path(self, path):\n        \"\"\"\n        Return new Command object that will be run with a new addition\n        to the PATH environment variable that will be fed to the command.\n        \"\"\"\n        new_command = copy.deepcopy(self)\n        new_command._paths.append(str(path))\n        return new_command"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pexpect(self):\n        import pexpect\n\n        assert not self._ignore_errors\n\n        _check_directory(self.directory)\n\n        arguments = self.arguments\n\n        return pexpect.spawn(\n            arguments[0], args=arguments[1:], env=self.env, cwd=self.directory\n        )", "response": "Run command and return pexpect process object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self):\n        _check_directory(self.directory)\n\n        with DirectoryContextManager(self.directory):\n            process = subprocess.Popen(self.arguments, shell=self._shell, env=self.env)\n\n            _, _ = process.communicate()\n\n        returncode = process.returncode\n\n        if returncode != 0 and not self._ignore_errors:\n            raise CommandError(\n                '\"{0}\" failed (err code {1})'.format(self.__repr__(), returncode)\n            )", "response": "Run command and wait until it finishes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef primitive_structure_from_cif(cif, parse_engine, symprec, site_tolerance):\n    CifCleanWorkChain = WorkflowFactory('codtools.cif_clean')  # pylint: disable=invalid-name\n\n    try:\n        structure = cif.get_structure(converter=parse_engine.value, site_tolerance=site_tolerance, store=False)\n    except exceptions.UnsupportedSpeciesError:\n        return CifCleanWorkChain.exit_codes.ERROR_CIF_HAS_UNKNOWN_SPECIES\n    except InvalidOccupationsError:\n        return CifCleanWorkChain.exit_codes.ERROR_CIF_HAS_INVALID_OCCUPANCIES\n    except Exception:  # pylint: disable=broad-except\n        return CifCleanWorkChain.exit_codes.ERROR_CIF_STRUCTURE_PARSING_FAILED\n\n    try:\n        seekpath_results = get_kpoints_path(structure, symprec=symprec)\n    except ValueError:\n        return CifCleanWorkChain.exit_codes.ERROR_SEEKPATH_INCONSISTENT_SYMMETRY\n    except SymmetryDetectionError:\n        return CifCleanWorkChain.exit_codes.ERROR_SEEKPATH_SYMMETRY_DETECTION_FAILED\n\n    # Store important information that should be easily queryable as attributes in the StructureData\n    parameters = seekpath_results['parameters'].get_dict()\n    structure = seekpath_results['primitive_structure']\n\n    for key in ['spacegroup_international', 'spacegroup_number', 'bravais_lattice', 'bravais_lattice_extended']:\n        try:\n            value = parameters[key]\n            structure.set_extra(key, value)\n        except KeyError:\n            pass\n\n    # Store the formula as a string, in both hill as well as hill-compact notation, so it can be easily queried for\n    structure.set_extra('formula_hill', structure.get_formula(mode='hill'))\n    structure.set_extra('formula_hill_compact', structure.get_formula(mode='hill_compact'))\n    structure.set_extra('chemical_system', '-{}-'.format('-'.join(sorted(structure.get_symbols_set()))))\n\n    return structure", "response": "This function will take a CifData object and attempt to create a StructureData object from it using the SeeKpath."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate Debye energy using old fortran routine", "response": "def debye_E_single(x):\n    \"\"\"\n    calculate Debye energy using old fortran routine\n\n    :params x: Debye x value\n    :return: Debye energy\n    \"\"\"\n    # make the function handles both scalar and array\n    if ((x > 0.0) & (x <= 0.1)):\n        result = 1. - 0.375 * x + x * x * \\\n            (0.05 - (5.952380953e-4) * x * x)\n    # for 0.1 < x <= 7.25\n    if ((x > 0.1) & (x <= 7.25)):\n        result = ((((.0946173 * x - 4.432582) * x +\n                    85.07724) * x - 800.6087) * x +\n                  3953.632) / ((((x + 15.121491) * x +\n                                 143.155337) * x + 682.0012) *\n                               x + 3953.632)\n    # for x > 7.25\n    # it appears there might be error for this part, but never been exposed\n    # because of rarity of such high x value.\n    if (x > 7.25):\n        exx = np.exp(-x)\n        nn = np.round(25. / x)\n        n = nn.astype(np.int64)\n        temp = 0.\n        if (n > 0):\n            temp2 = 1.\n            end = n + 1\n            for i in range(1, end):\n                temps = i * 1.\n                temp2 = temp2 * exx\n                x3 = temps * x\n                temp = temp + temp2 * \\\n                    (6. + x3 * (6. + x3 * (3. + x3))) / \\\n                    (temps * temps * temps * temps)\n        result = 3.0 * (6.493939402 - temp) / (x * x * x)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating Debye energy using old fortran routine", "response": "def debye_E(x):\n    \"\"\"\n    calculate Debye energy using old fortran routine\n\n    :params x: Debye x value\n    :return: Debye energy\n    :note: this is a wraper function (vectorization) for debye_E_single\n    \"\"\"\n    if isuncertainties([x]):\n        f_u = uct.wrap(debye_E_single)\n        f_v = np.vectorize(f_u)\n    else:\n        f_v = np.vectorize(debye_E_single)\n    return f_v(x)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef export_capacities(self):\n        return [export for cls in getmro(type(self)) if hasattr(cls, \"EXPORT_TO\") for export in cls.EXPORT_TO]", "response": "List Mimetypes that current object can export to\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexporting the object in the Mimetype required.", "response": "def export(self, output=None, **kwargs):\n        \"\"\" Export the collection item in the Mimetype required.\n\n        :param output: Mimetype to export to (Uses MyCapytain.common.utils.Mimetypes)\n        :type output: str\n        :return: Object using a different representation\n        \"\"\"\n        if output is None:\n            output = self.DEFAULT_EXPORT\n        if output is not None and output in self.export_capacities:\n            for cls in getmro(type(self)):\n                if hasattr(cls, \"EXPORT_TO\") and output in cls.EXPORT_TO:\n                    return cls.__export__(self, output, **kwargs)\n        raise NotImplementedError(\n            \"Mimetype {} has not been implemented for this resource\".format(output or \"(No Mimetype)\")\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _filter_options(self, aliases=True, comments=True, historical=True):\n        options = []\n        if not aliases:\n            options.append('noaliases')\n        if not comments:\n            options.append('nocomments')\n        if not historical:\n            options.append('nohistorical')\n        return options", "response": "Converts a set of boolean - valued options into the relevant HTTP values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _request(self, path, key, data, method, key_is_cik, extra_headers={}):\n        if method == 'GET':\n            if len(data) > 0:\n                url = path + '?' + data\n            else:\n                url = path\n            body = None\n        else:\n            url = path\n            body = data\n\n        headers = {}\n        if key_is_cik:\n            headers['X-Exosite-CIK'] = key\n        else:\n            headers['X-Exosite-Token'] = key\n        if method == 'POST':\n            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8'\n        headers['Accept'] = 'text/plain, text/csv, application/x-www-form-urlencoded'\n        headers.update(extra_headers)\n\n        body, response = self._onephttp.request(method,\n                                                url,\n                                                body,\n                                                headers)\n\n        pr = ProvisionResponse(body, response)\n        if self._raise_api_exceptions and not pr.isok:\n            raise ProvisionException(pr)\n        return pr", "response": "Generically shared HTTP request method."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef content_create(self, key, model, contentid, meta, protected=False):\n        params = {'id': contentid, 'meta': meta}\n        if protected is not False:\n            params['protected'] = 'true'\n        data = urlencode(params)\n        path = PROVISION_MANAGE_CONTENT + model + '/'\n        return self._request(path,\n                             key, data, 'POST', self._manage_by_cik)", "response": "Creates a content entity bucket with the given contentid."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef content_download(self, cik, vendor, model, contentid):\n        data = urlencode({'vendor': vendor,\n                          'model': model,\n                          'id': contentid})\n        headers = {\"Accept\": \"*\"}\n        return self._request(PROVISION_DOWNLOAD,\n                             cik, data, 'GET', True, headers)", "response": "Download the content for a given CIK model and ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching the content information for a given CIK model and ID.", "response": "def content_info(self, key, model, contentid, vendor=None):\n        \"\"\"(Speculation) Fetches content information for a given vendor, model, and ID.\n\n        This method might map to:\n        https://github.com/exosite/docs/tree/master/provision#get---get-content-info-1,\n        but seems to be missing serial number.\n\n        Args:\n            key: The CIK or Token for the device\n            model:\n            contentid: The ID used to name the entity bucket\n            vendor: The name of the vendor\n        \"\"\"\n        if not vendor:  # if no vendor name, key should be the owner one\n            path = PROVISION_MANAGE_CONTENT + model + '/' + contentid\n            return self._request(path, key, '', 'GET', self._manage_by_cik)\n        else:  # if provide vendor name, key can be the device one\n            data = urlencode({'vendor': vendor,\n                              'model': model,\n                              'id': contentid,\n                              'info': 'true'})\n            return self._request(PROVISION_DOWNLOAD,\n                                 key, data, 'GET', self._manage_by_cik)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef content_list(self, key, model):\n        path = PROVISION_MANAGE_CONTENT + model + '/'\n        return self._request(path, key, '', 'GET', self._manage_by_cik)", "response": "Returns the list of content IDs for a given model."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef content_remove(self, key, model, contentid):\n        path = PROVISION_MANAGE_CONTENT + model + '/' + contentid\n        return self._request(path, key, '', 'DELETE', self._manage_by_cik)", "response": "Deletes the information for the given contentid under the given model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstoring the given data as a result of a query for content id given the model.", "response": "def content_upload(self, key, model, contentid, data, mimetype):\n        \"\"\"Store the given data as a result of a query for content id given the model.\n\n        This method maps to\n        https://github.com/exosite/docs/tree/master/provision#post---upload-content\n\n        Args:\n            key: The CIK or Token for the device\n            model:\n            contentid: The ID used to name the entity bucket\n            data: The data blob to save\n            mimetype: The Content-Type to use when serving the blob later\n        \"\"\"\n        headers = {\"Content-Type\": mimetype}\n        path = PROVISION_MANAGE_CONTENT + model + '/' + contentid\n        return self._request(path, key, data, 'POST', self._manage_by_cik, headers)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots a static compressional curve fitting result", "response": "def static_fit_result(fit_result, v_residual=None,\n                      v_label='Unit-cell volume $(\\mathrm{\\AA}^3)$',\n                      figsize=(5, 5), height_ratios=(3, 1), ms_data=8,\n                      p_err=None, v_err=None, pdf_filen=None,\n                      title='Fit result'):\n    \"\"\"\n    plot static compressional curve fitting result\n\n    :param fit_result: lmfit result object, see example jnb file for detail\n    :param v_residual: manual input of fit residual\n    :param v_label: label for volume axis\n    :param figsize: figure size\n    :param fitline: manual input of fit line, array of (v_fitline, p_fitline)\n        with uncertainties\n    :param height_ratios: height ratio between the main and residue plots\n    :param ms_data: marker size for data points\n    :param p_err: pressure error bar\n    :param v_err: volume error bar\n    :param pdf_filen: name of pdf output file\n    :param title: title of the figure\n    :return: None\n    \"\"\"\n    # basic figure setup\n    f, ax = plt.subplots(2, 1, sharex=True, figsize=figsize,\n                         gridspec_kw={'height_ratios': height_ratios})\n    for ax_i in ax:\n        ax_i.tick_params(direction='in')\n    # read data to plot\n    v_data = fit_result.userkws['v']\n    p_data = fit_result.data\n    p_datafit = fit_result.best_fit\n    v0 = uct.ufloat(fit_result.params['v0'].value,\n                    fit_result.params['v0'].stderr)\n    k0 = uct.ufloat(fit_result.params['k0'].value,\n                    fit_result.params['k0'].stderr)\n    k0p = uct.ufloat(fit_result.params['k0p'].value,\n                     fit_result.params['k0p'].stderr)\n    # I don't know why but fit_result.residual is not p_data - p_fit\n    # p_residual = fit_result.residual\n    # setup fitline and uncertainties\n    v_fitline = np.linspace(v0.n, min(v_data), 1000)\n    p_fit = fit_result.model.func(v_fitline, v0, k0, k0p)\n    p_fitline = unp.nominal_values(p_fit)\n    # I am unsure about why I have to divide by 3 in order to fit the\n    # eval_uncertainty result from lmfit.  For now, I do this to be\n    # consistent\n    del_p = unp.std_devs(p_fit) / 3.\n    # v_fitline = v_data\n    # p_fitline = p_datafit\n    # del_p = fit_result.eval_uncertainty()\n    # ax[0].plot(p_data, v_data, 'ko', ms=ms_data, label='Data')\n    ax[0].errorbar(p_data, v_data, xerr=p_err, yerr=v_err, fmt='ko',\n                   ms=ms_data, mec='w', capsize=0, elinewidth=0.5,\n                   label='Data')\n    ax[0].plot(p_fitline, v_fitline, 'k-', label='Fit')\n    ax[0].fill_betweenx(v_fitline, p_fitline - del_p,\n                        p_fitline + del_p, color=\"k\", alpha=0.2)\n    if v_residual is None:\n        # ax[1].plot(p_data, p_data - fit_result.best_fit, 'ko', ms=ms_data)\n        ax[1].errorbar(p_data, p_data - p_datafit, yerr=p_err,\n                       fmt='ko', ms=ms_data, mec='w',\n                       capsize=0, elinewidth=0.5)\n        ax[1].set_ylabel('$P_{obs} - P_{fit}$')\n        ax[1].fill_between(p_fitline, -1. * del_p,\n                           del_p, color=\"k\", alpha=0.2)\n    else:\n        # ax[1].plot(p_data, v_data - v_fit, 'ko', ms=ms_data)\n        ax[1].errorbar(p_data, v_residual, yerr=v_err,\n                       fmt='ko', ms=ms_data, mec='w',\n                       capsize=0, elinewidth=0.5)\n        ax[1].set_ylabel('$V_{obs} - V_{fit}$')\n    ax[0].legend()\n    ax[1].axhline(0, c='k', ls='--')\n    ax[1].set_xlabel('Pressure (GPa)')\n    ax[0].set_ylabel(v_label)\n    ax[0].set_title(title)\n    plt.tight_layout()\n    if pdf_filen is not None:\n        f.savefig(pdf_filen)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the content is contained in the content of the element.", "response": "def contains_content(browser, content):\n    \"\"\"\n    Search for an element that contains the whole of the text we're looking\n    for in it or its subelements, but whose children do NOT contain that\n    text - otherwise matches <body> or <html> or other similarly useless\n    things.\n    \"\"\"\n    for elem in browser.find_elements_by_xpath(str(\n            '//*[contains(normalize-space(.), {content}) '\n            'and not(./*[contains(normalize-space(.), {content})])]'\n            .format(content=string_literal(content)))):\n\n        try:\n            if elem.is_displayed():\n                return True\n        except StaleElementReferenceException:\n            pass\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef url_should_be(self, url):\n\n    if world.browser.current_url != url:\n        raise AssertionError(\n            \"Browser URL expected to be {!r}, got {!r}.\".format(\n                url, world.browser.current_url))", "response": "Assert the absolute URL of the browser is as provided."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassert the absolute URL of the browser contains the provided.", "response": "def url_should_contain(self, url):\n    \"\"\"Assert the absolute URL of the browser contains the provided.\"\"\"\n\n    if url not in world.browser.current_url:\n        raise AssertionError(\n            \"Browser URL expected to contain {!r}, got {!r}.\".format(\n                url, world.browser.current_url))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef url_should_not_contain(self, url):\n\n    if url in world.browser.current_url:\n        raise AssertionError(\n            \"Browser URL expected not to contain {!r}, got {!r}.\".format(\n                url, world.browser.current_url))", "response": "Assert the absolute URL of the browser does not contain the provided."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nassert the page title matches the given text.", "response": "def page_title(self, title):\n    \"\"\"\n    Assert the page title matches the given text.\n    \"\"\"\n\n    if world.browser.title != title:\n        raise AssertionError(\n            \"Page title expected to be {!r}, got {!r}.\".format(\n                title, world.browser.title))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef click(self, name):\n    try:\n        elem = world.browser.find_element_by_link_text(name)\n    except NoSuchElementException:\n        raise AssertionError(\n            \"Cannot find the link with text '{}'.\".format(name))\n    elem.click()", "response": "Click the link with the provided link text."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef should_see_link(self, link_url):\n\n    elements = ElementSelector(\n        world.browser,\n        str('//a[@href=\"%s\"]' % link_url),\n        filter_displayed=True,\n    )\n    if not elements:\n        raise AssertionError(\"Expected link not found.\")", "response": "Assert a link with the provided URL is visible on the page."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nasserts a link with the provided text points to the provided URL.", "response": "def should_see_link_text(self, link_text, link_url):\n    \"\"\"Assert a link with the provided text points to the provided URL.\"\"\"\n\n    elements = ElementSelector(\n        world.browser,\n        str('//a[@href=\"%s\"][./text()=\"%s\"]' % (link_url, link_text)),\n        filter_displayed=True,\n    )\n    if not elements:\n        raise AssertionError(\"Expected link not found.\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef should_include_link_text(self, link_text, link_url):\n\n    elements = ElementSelector(\n        world.browser,\n        str('//a[@href=\"%s\"][contains(., %s)]' %\n            (link_url, string_literal(link_text))),\n        filter_displayed=True,\n    )\n    if not elements:\n        raise AssertionError(\"Expected link not found.\")", "response": "Assert a link containing the provided text points to the provided URL."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef element_contains(self, element_id, value):\n\n    elements = ElementSelector(\n        world.browser,\n        str('id(\"{id}\")[contains(., \"{value}\")]'.format(\n            id=element_id, value=value)),\n        filter_displayed=True,\n    )\n    if not elements:\n        raise AssertionError(\"Expected element not found.\")", "response": "Assert provided content is contained within an element found by id."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nasserts provided content is not contained within an element found by id.", "response": "def element_not_contains(self, element_id, value):\n    \"\"\"\n    Assert provided content is not contained within an element found by ``id``.\n    \"\"\"\n    elem = world.browser.find_elements_by_xpath(str(\n        'id(\"{id}\")[contains(., \"{value}\")]'.format(\n            id=element_id, value=value)))\n    assert not elem, \\\n        \"Expected element not to contain the given text.\""}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassert an element with the given id is visible within n seconds.", "response": "def should_see_id_in_seconds(self, element_id, timeout):\n    \"\"\"\n    Assert an element with the given ``id`` is visible within n seconds.\n    \"\"\"\n\n    def check_element():\n        \"\"\"Check for the element with the given id.\"\"\"\n\n        assert ElementSelector(\n            world.browser,\n            'id(\"%s\")' % element_id,\n            filter_displayed=True,\n        ), \"Expected element with given id.\"\n\n    wait_for(check_element)(timeout=int(timeout))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef should_see_id(self, element_id):\n\n    elements = ElementSelector(\n        world.browser,\n        'id(\"%s\")' % element_id,\n        filter_displayed=True,\n    )\n    if not elements:\n        raise AssertionError(\"Expected element with given id.\")", "response": "Assert an element with the given id is visible."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nasserts the element is focused.", "response": "def element_focused(self, id_):\n    \"\"\"\n    Assert the element is focused.\n    \"\"\"\n\n    try:\n        elem = world.browser.find_element_by_id(id_)\n    except NoSuchElementException:\n        raise AssertionError(\"Element with ID '{}' not found.\".format(id_))\n\n    focused = world.browser.switch_to.active_element\n\n    # Elements don't have __ne__ defined, cannot test for inequality\n    if not elem == focused:\n        raise AssertionError(\"Expected element to be focused.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nasserts provided text is visible within n seconds.", "response": "def should_see_in_seconds(self, text, timeout):\n    \"\"\"\n    Assert provided text is visible within n seconds.\n\n    Be aware this text could be anywhere on the screen. Also be aware that\n    it might cross several HTML nodes. No determination is made between\n    block and inline nodes. Whitespace can be affected.\n    \"\"\"\n\n    def check_element():\n        \"\"\"Check for an element with the given content.\"\"\"\n\n        assert contains_content(world.browser, text), \\\n            \"Expected element with the given text.\"\n\n    wait_for(check_element)(timeout=int(timeout))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef see_form(self, url):\n\n    elements = ElementSelector(\n        world.browser,\n        str('//form[@action=\"%s\"]' % url),\n        filter_displayed=True,\n    )\n    if not elements:\n        raise AssertionError(\"Expected form not found.\")", "response": "Assert that a form that submits to the given URL is present."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fill_in_textfield(self, field_name, value):\n\n    date_field = find_any_field(world.browser,\n                                DATE_FIELDS,\n                                field_name)\n    if date_field:\n        field = date_field\n    else:\n        field = find_any_field(world.browser,\n                               TEXT_FIELDS,\n                               field_name)\n\n    if not field:\n        raise AssertionError(\n            \"Cannot find a field named '{}'.\".format(field_name))\n\n    if date_field:\n        field.send_keys(Keys.DELETE)\n    else:\n        field.clear()\n\n    field.send_keys(value)", "response": "Fill in the given text field with given value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclick the button with the given label.", "response": "def press_button(self, value):\n    \"\"\"\n    Click the button with the given label.\n    \"\"\"\n    button = find_button(world.browser, value)\n    if not button:\n        raise AssertionError(\n            \"Cannot find a button named '{}'.\".format(value))\n    button.click()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclicking on the given label.", "response": "def click_on_label(self, label):\n    \"\"\"\n    Click on the given label.\n\n    On a correctly set up form this will highlight the appropriate field.\n    \"\"\"\n\n    elem = ElementSelector(\n        world.browser,\n        str('//label[normalize-space(text())=%s]' % string_literal(label)),\n        filter_displayed=True,\n    )\n    if not elem:\n        raise AssertionError(\n            \"Cannot find a label with text '{}'.\".format(label))\n    elem.click()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nasserts the form input with label name or id has given value.", "response": "def input_has_value(self, field_name, value):\n    \"\"\"\n    Assert the form input with label (recommended), name or id has given value.\n    \"\"\"\n    text_field = find_any_field(world.browser,\n                                DATE_FIELDS + TEXT_FIELDS,\n                                field_name)\n    if text_field is False:\n        raise AssertionError(\n            \"Can not find a field named {!r}.\".format(field_name))\n\n    actual = text_field.get_attribute('value')\n    if actual != value:\n        raise AssertionError(\n            \"Field value expected to be {!r}, got {!r}.\".format(\n                value, actual))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef submit_the_only_form(self):\n    form = ElementSelector(world.browser, str('//form'))\n    assert form, \"Cannot find a form on the page.\"\n    form.submit()", "response": "Submit the only form on the page."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef submit_form_id(self, id_):\n    form = ElementSelector(\n        world.browser,\n        str('id(\"{id}\")'.format(id=id_)),\n    )\n    assert form, \"Cannot find a form with ID '{}' on the page.\".format(id_)\n    form.submit()", "response": "Submit the form with given id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsubmit the form with the given action URL.", "response": "def submit_form_action(self, url):\n    \"\"\"\n    Submit the form with the given action URL (i.e. the form that submits to\n    ``/post/my/data``).\n    \"\"\"\n    form = ElementSelector(\n        world.browser,\n        str('//form[@action=\"%s\"]' % url),\n    )\n    assert form, \\\n        \"Cannot find a form with action '{}' on the page.\".format(url)\n    form.submit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks the checkbox with label recommended name or id.", "response": "def check_checkbox(self, value):\n    \"\"\"Check the checkbox with label (recommended), name or id.\"\"\"\n    check_box = find_field(world.browser, 'checkbox', value)\n    assert check_box, \"Cannot find checkbox '{}'.\".format(value)\n    if not check_box.is_selected():\n        check_box.click()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assert_checked_checkbox(self, value):\n    check_box = find_field(world.browser, 'checkbox', value)\n    assert check_box, \"Cannot find checkbox '{}'.\".format(value)\n    assert check_box.is_selected(), \"Check box should be selected.\"", "response": "Assert the checkbox with label value is checked."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nselect a single item from select with label name or id.", "response": "def select_single_item(self, option_name, select_name):\n    \"\"\"\n    Select the named option from select with label (recommended), name or id.\n    \"\"\"\n    option_box = find_option(world.browser, select_name, option_name)\n    assert option_box, \"Cannot find option '{}'.\".format(option_name)\n    option_box.click()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nselect multiple options from select with label recommended name phone and fax.", "response": "def select_multi_items(self, select_name):\n    \"\"\"\n    Select multiple options from select with label (recommended), name, or\n    id. Pass a multiline string of options. e.g.\n\n    .. code-block:: gherkin\n\n        When I select the following from \"Contact Methods\":\n            \\\"\\\"\\\"\n            Email\n            Phone\n            Fax\n            \\\"\\\"\\\"\n    \"\"\"\n    # Ensure only the options selected are actually selected\n    option_names = self.multiline.split('\\n')\n    select_box = find_field(world.browser, 'select', select_name)\n    assert select_box, \"Cannot find a '{}' select.\".format(select_name)\n\n    select = Select(select_box)\n    select.deselect_all()\n\n    for option in option_names:\n        try:\n            select.select_by_value(option)\n        except NoSuchElementException:\n            try:\n                select.select_by_visible_text(option)\n            except NoSuchElementException:\n                raise AssertionError(\"Cannot find option: '{}'.\".format(option))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassert the given option is selected from the select with label name or id.", "response": "def assert_single_selected(self, option_name, select_name):\n    \"\"\"\n    Assert the given option is selected from the select with label\n    (recommended), name or id.\n\n    If multiple selections are supported other options may be selected.\n    \"\"\"\n    option = find_option(world.browser, select_name, option_name)\n    assert option.is_selected(), \"Option should be selected.\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclicking the radio button with the given label or id.", "response": "def choose_radio(self, value):\n    \"\"\"\n    Click (and choose) the radio button with the given label (recommended),\n    name or id.\n    \"\"\"\n    box = find_field(world.browser, 'radio', value)\n    assert box, \"Cannot find a '{}' radio button.\".format(value)\n    box.click()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assert_radio_selected(self, value):\n    radio = find_field(world.browser, 'radio', value)\n    assert radio, \"Cannot find a '{}' radio button.\".format(value)\n    assert radio.is_selected(), \"Radio button should be selected.\"", "response": "Assert the radio button with the given label is selected."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_alert(self, text):\n\n    try:\n        alert = Alert(world.browser)\n        if alert.text != text:\n            raise AssertionError(\n                \"Alert text expected to be {!r}, got {!r}.\".format(\n                    text, alert.text))\n    except WebDriverException:\n        # PhantomJS is kinda poor\n        pass", "response": "Assert an alert is showing with the given text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_no_alert(self):\n\n    try:\n        alert = Alert(world.browser)\n        raise AssertionError(\"Should not see an alert. Alert '%s' shown.\" %\n                             alert.text)\n    except NoAlertPresentException:\n        pass", "response": "Assert there is no alert."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_by_tooltip(browser, tooltip):\n\n    return ElementSelector(\n        world.browser,\n        str('//*[@title=%(tooltip)s or @data-original-title=%(tooltip)s]' %\n            dict(tooltip=string_literal(tooltip))),\n        filter_displayed=True,\n    )", "response": "Find elements with the given tooltip."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclick on a HTML element with a given tooltip.", "response": "def press_by_tooltip(self, tooltip):\n    \"\"\"\n    Click on a HTML element with a given tooltip.\n\n    This is very useful if you're clicking on icon buttons, etc.\n    \"\"\"\n    for button in find_by_tooltip(world.browser, tooltip):\n        try:\n            button.click()\n            break\n        except:  # pylint:disable=bare-except\n            pass\n    else:\n        raise AssertionError(\"No button with tooltip '{0}' found\"\n                             .format(tooltip))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef switch_to_frame_with_id(self, frame):\n    elem = world.browser.find_element_by_id(frame)\n    world.browser.switch_to.frame(elem)", "response": "Swap Selenium s context to the given frame or iframe."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nswapping Selenium s context to the given frame.", "response": "def switch_to_frame_with_class(self, frame):\n    \"\"\"Swap Selenium's context to the given frame or iframe.\"\"\"\n    elem = world.browser.find_element_by_class_name(frame)\n    world.browser.switch_to.frame(elem)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndo a soap request", "response": "def soap_action(self, service, action, payloadbody):\n        \"\"\"Do a soap request \"\"\"\n        payload = self.soapenvelope.format(body=payloadbody).encode('utf-8')\n        headers = ['SOAPAction: ' + action,\n                   'Content-Type: application/soap+xml; charset=UTF-8',\n                   'Content-Length: ' + str(len(payload))]\n\n        try:\n            curl = pycurl.Curl()\n            curl.setopt(pycurl.SSL_CIPHER_LIST, \"AES256-SHA\")\n            curl.setopt(pycurl.SSLVERSION, pycurl.SSLVERSION_TLSv1_0)\n    #        self.curl.setopt(pycurl.CAINFO,'ihc.crt')\n            curl.setopt(pycurl.SSL_VERIFYPEER, 0)\n            curl.setopt(pycurl.SSL_VERIFYHOST, 0)\n            curl.setopt(pycurl.POST, 1)\n            curl.setopt(pycurl.HEADERFUNCTION, IHCCurlConnection._write_header)\n\n            curl.setopt(pycurl.HTTPHEADER, headers)\n            inbuffer = BytesIO(payload)\n            curl.setopt(pycurl.READDATA, inbuffer)\n            buffer = BytesIO()\n            curl.setopt(pycurl.WRITEDATA, buffer)\n            curl.setopt(pycurl.URL, self.url + service)\n            curl.setopt(pycurl.COOKIE, IHCCurlConnection.cookies)\n    #        curl.setopt(pycurl.VERBOSE,1)\n            curl.perform()\n            body = buffer.getvalue().decode('utf-8')\n            code = curl.getinfo(pycurl.HTTP_CODE)\n            curl.close()\n        except Exception as exp:\n            return False\n        if code != 200:\n            return False\n        try:\n            xdoc = xml.etree.ElementTree.fromstring(body)\n        except xml.etree.ElementTree.ParseError:\n            return False\n        return xdoc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_equations(self):\n        print(\"P_static: \", self.eqn_st)\n        print(\"P_thermal: \", self.eqn_th)\n        print(\"P_anharmonic: \", self.eqn_anh)\n        print(\"P_electronic: \", self.eqn_el)", "response": "show equations used for the EOS"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_parameters(self):\n        print(\"Static: \", self.params_st)\n        print(\"Thermal: \", self.params_th)\n        print(\"Anharmonic: \", self.params_anh)\n        print(\"Electronic: \", self.params_el)", "response": "show thermoelastic parameters for the EOS"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchanges parameters in OrderedDict to list with or without uncertainties", "response": "def _set_params(self, p):\n        \"\"\"\n        change parameters in OrderedDict to list with or without uncertainties\n\n        :param p: parameters in OrderedDict\n        :return: parameters in list\n        :note: internal function\n        \"\"\"\n        if self.force_norm:\n            params = [value.n for key, value in p.items()]\n        else:\n            params = [value for key, value in p.items()]\n        return params"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cal_pst(self, v):\n        params = self._set_params(self.params_st)\n        return func_st[self.eqn_st](v, *params)", "response": "calculate static pressure at 300 K."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating thermal pressure in A^3", "response": "def cal_pth(self, v, temp):\n        \"\"\"\n        calculate thermal pressure\n\n        :param v: unit-cell volume in A^3\n        :param temp: temperature in K\n        :return: thermal pressure in GPa\n        \"\"\"\n        if (self.eqn_th is None) or (self.params_th is None):\n            return np.zeros_like(v)\n        params = self._set_params(self.params_th)\n        return func_th[self.eqn_th](v, temp, *params,\n                                    self.n, self.z, t_ref=self.t_ref,\n                                    three_r=self.three_r)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cal_pel(self, v, temp):\n        if (self.eqn_el is None) or (self.params_el is None):\n            return np.zeros_like(v)\n        params = self._set_params(self.params_el)\n        return func_el[self.eqn_el](v, temp, *params,\n                                    self.n, self.z, t_ref=self.t_ref,\n                                    three_r=self.three_r)", "response": "calculate pressure from electronic contributions\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating pressure from anharmonic contributions", "response": "def cal_panh(self, v, temp):\n        \"\"\"\n        calculate pressure from anharmonic contributions\n\n        :param v: unit-cell volume in A^3\n        :param temp: temperature in K\n        :return: pressure in GPa\n        \"\"\"\n        if (self.eqn_anh is None) or (self.params_anh is None):\n            return np.zeros_like(v)\n        params = self._set_params(self.params_anh)\n        return func_anh[self.eqn_anh](v, temp, *params,\n                                      self.n, self.z, t_ref=self.t_ref,\n                                      three_r=self.three_r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates total pressure at given volume and temperature", "response": "def cal_p(self, v, temp):\n        \"\"\"\n        calculate total pressure at given volume and temperature\n\n        :param v: unit-cell volume in A^3\n        :param temp: temperature in K\n        :return: pressure in GPa\n        :note: 2017/05/10 temp must be numpy array.  If not, such as list,\n            create an error.\n        \"\"\"\n        if not isinstance(temp, np.ndarray):\n            temp = np.asarray(temp)\n        if not isinstance(v, np.ndarray):\n            v = np.asarray(v)\n        return self.cal_pst(v) + self.cal_pth(v, temp) + \\\n            self.cal_pel(v, temp) + self.cal_panh(v, temp)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef print_parameters(self):\n        print(\"Static: \", self.params_hugoniot)\n        print(\"Thermal: \", self.params_therm)\n        print(\"Anharmonic: None\")\n        print(\"Electronic: None\")", "response": "Print the thermoelastic parameters for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_rho(self, v):\n        v_mol = vol_uc2mol(v, self.z)  # in m^3\n        rho = self.mass / v_mol * 1.e-6  # in g/cm^3\n        return rho", "response": "convert unit - cell volume in A^3 to density in g / cm^3\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting density in g / cm^3 to unit - cell volume in A^3", "response": "def _get_v(self, rho):\n        \"\"\"\n        convert density in g/cm^3 to unit-cell volume\n\n        :param rho: density in g/cm^3\n        :return: unit-cell volume in A^3\n\n        :note: internal function\n        \"\"\"\n        v_mol = self.mass / rho  # in cm^3\n        v = vol_mol2uc(v_mol * 1.e-6, self.z)\n        print(v)\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cal_pst(self, v):\n        p_h = self._hugoniot_p(v)\n        p_th_h = self._hugoniot_pth(v)\n        p_st = p_h - p_th_h\n        return p_st", "response": "calculate static pressure at 300 K."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _hugoniot_p(self, v):\n        rho = self._get_rho(v)\n        params = self._set_params(self.params_hugoniot)\n        if self.nonlinear:\n            return hugoniot_p_nlin(rho, *params)\n        else:\n            return hugoniot_p(rho, *params)", "response": "calculate static pressure at 300 K."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates Hugoniot temperature in A^3", "response": "def _hugoniot_t(self, v):\n        \"\"\"\n        calculate Hugoniot temperature\n\n        :param v: unit-cell volume in A^3\n        :return: temperature in K\n        :note: 2017/05/10, It is intentional that I call hugoniot_t\n        instead of hugoniot_t_nlin for the nonlinear case.\n        The reason is the hugoniot_t_nlin (and its equivalent part in mdaap)\n        has numerical problem.  In fact, I found no problem to match the\n        Jamieson table values with the use of linear thermal part instead of\n        non-linear version.\n        \"\"\"\n        rho = self._get_rho(v)\n        params_h = self._set_params(self.params_hugoniot)\n        params_t = self._set_params(self.params_therm)\n        if self.nonlinear:\n            return hugoniot_t(rho, *params_h[:-1], *params_t[1:],\n                              self.n, self.mass, three_r=self.three_r,\n                              c_v=self.c_v)\n        else:\n            return hugoniot_t(rho, *params_h, *params_t[1:],\n                              self.n, self.mass, three_r=self.three_r,\n                              c_v=self.c_v)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cal_pth(self, v, temp):\n        params_t = self._set_params(self.params_therm)\n        return constq_pth(v, temp, *params_t, self.n, self.z,\n                          t_ref=self.t_ref, three_r=self.three_r)", "response": "calculate thermal pressure in A^3\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _hugoniot_pth(self, v):\n        temp = self._hugoniot_t(v)\n        return self.cal_pth(v, temp)", "response": "calculate thermal pressure along hugoniot in A^3"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate total pressure at given volume and temperature", "response": "def cal_p(self, v, temp):\n        \"\"\"\n        calculate total pressure at given volume and temperature\n\n        :param v: unit-cell volume in A^3\n        :param temp: temperature in K\n        :return: pressure in GPa\n        \"\"\"\n        return self.cal_pst(v) + self.cal_pth(v, temp)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cal_v(self, p, temp, min_strain=0.3, max_strain=1.0):\n        v0 = self.params_therm['v0'].nominal_value\n        self.force_norm = True\n        pp = unp.nominal_values(p)\n        ttemp = unp.nominal_values(temp)\n\n        def _cal_v_single(pp, ttemp):\n            if (pp <= 1.e-5) and (ttemp == 300.):\n                return v0\n\n            def f_diff(v, ttemp, pp):\n                return self.cal_p(v, ttemp) - pp\n            # print(f_diff(v0 * 0.3, temp, p))\n            v = brenth(f_diff, v0 * max_strain, v0 * min_strain,\n                       args=(ttemp, pp))\n            return v\n        f_vu = np.vectorize(_cal_v_single)\n        v = f_vu(pp, ttemp)\n        self.force_norm = False\n        return v", "response": "calculate unit - cell volume at given pressure and temperature"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a path string into a collection of Intervals.", "response": "def parse_intervals(path, as_context=False):\n    \"\"\"\n    Parse path strings into a collection of Intervals.\n\n    `path` is a string describing a region in a file. It's format is\n\n        dotted.module.name:[line | start-stop | context]\n\n    `dotted.module.name` is a python module\n    `line` is a single line number in the module (1-offset)\n    `start-stop` is a right-open interval of line numbers\n    `context` is a '.' delimited, nested name of a class or function.\n        For example FooClass.method_a.inner_method\n\n    identifies the innermost function in code like\n\n    class FooClass:\n        def method_a(self):\n            def inner_method():\n                pass\n\n    Parameters\n    ----------\n    path : str\n        Region description (see above)\n    as_context : bool (optional, default=False)\n        If `True`, return `ContextInterval`s instead of `LineInterval`s.\n        If `path` provides a line number or range, the result will include\n        all contexts that intersect this line range.\n\n    Returns\n    -------\n    list of `Interval`s\n    \"\"\"\n\n    def _regions_from_range():\n        if as_context:\n            ctxs = list(set(pf.lines[start - 1: stop - 1]))\n            return [\n                ContextInterval(filename, ctx)\n                for ctx in ctxs\n            ]\n        else:\n            return [LineInterval(filename, start, stop)]\n\n    if ':' in path:\n        path, subpath = path.split(':')\n    else:\n        subpath = ''\n\n    pf = PythonFile.from_modulename(path)\n    filename = pf.filename\n    rng = NUMBER_RE.match(subpath)\n\n    if rng:  # specified a line or line range\n        start, stop = map(int, rng.groups(0))\n        stop = stop or start + 1\n        return _regions_from_range()\n    elif not subpath:  # asked for entire module\n        if as_context:\n            return [ContextInterval(filename, pf.prefix)]\n        start, stop = 1, pf.line_count + 1\n        return _regions_from_range()\n    else:  # specified a context name\n        context = pf.prefix + ':' + subpath\n        if context not in pf.lines:\n            raise ValueError(\"%s is not a valid context for %s\"\n                             % (context, pf.prefix))\n        if as_context:\n            return [ContextInterval(filename, context)]\n        else:\n            start, stop = pf.context_range(context)\n            return [LineInterval(filename, start, stop)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the rest of the input", "response": "def p_suffix(self, length=None, elipsis=False):\n        \"Return the rest of the input\"\n        if length is not None:\n            result = self.input[self.pos:self.pos + length]\n            if elipsis and len(result) == length:\n                result += \"...\"\n            return result\n        return self.input[self.pos:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_debug(self, message):\n        \"Format and print debug messages\"\n        print(\"{}{} `{}`\".format(self._debug_indent * \" \",\n                                 message, repr(self.p_suffix(10))))", "response": "Format and print debug messages"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p_next(self):\n        \"Consume and return the next char\"\n        try:\n            self.pos += 1\n            return self.input[self.pos - 1]\n        except IndexError:\n            self.pos -= 1\n            return None", "response": "Consume and return the next char"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn currnet column in line", "response": "def p_current_col(self):\n        \"Return currnet column in line\"\n        prefix = self.input[:self.pos]\n        nlidx = prefix.rfind('\\n')\n        if nlidx == -1:\n            return self.pos\n        return self.pos - nlidx"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef p_pretty_pos(self):\n        \"Print current line and a pretty cursor below. Used in error messages\"\n        col = self.p_current_col\n        suffix = self.input[self.pos - col:]\n        end = suffix.find(\"\\n\")\n        if end != -1:\n            suffix = suffix[:end]\n        return \"%s\\n%s\" % (suffix, \"-\" * col + \"^\")", "response": "Print current line and a pretty cursor below. Used in error messages"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef p_startswith(self, st, ignorecase=False):\n        \"Return True if the input starts with `st` at current position\"\n        length = len(st)\n        matcher = result = self.input[self.pos:self.pos + length]\n        if ignorecase:\n            matcher = result.lower()\n            st = st.lower()\n        if matcher == st:\n            self.pos += length\n            return result\n        return False", "response": "Return True if the input starts with st at current position"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef p_flatten(self, obj, **kwargs):\n        if isinstance(obj, six.string_types):\n            return obj\n        result = \"\"\n        for i in obj:\n            result += self.p_flatten(i)\n        return result", "response": "Flatten a list of lists of strings into a string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the input using the specified methodname as entry point.", "response": "def p_parse(cls, input, methodname=None, parse_all=True):\n        \"\"\"\n        Parse the `input` using `methodname` as entry point.\n\n        If `parse_all` is true, the input MUST be fully consumed at the end of\n        the parsing, otherwise p_parse raises an exception.\n        \"\"\"\n        if methodname is None:\n            methodname = cls.__default__\n        p = cls(input)\n        result = getattr(p, methodname)()\n        if result is cls.NoMatch or parse_all and p.p_peek() is not None:\n            p.p_raise()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_openstack_repository(self):\r\n        if self._release() == 'trusty':\r\n            print red(env.host_string + ' | Enable the OpenStack repository for trusty')\r\n            sudo('apt-get update')\r\n            sudo('apt-get install software-properties-common -y')\r\n            sudo('add-apt-repository cloud-archive:mitaka -y')\r\n\r\n        print red(env.host_string + ' | Executing dist-upgrade')\r\n        with prefix('sudo apt-get update'):\r\n            sudo('DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::=\"--force-confdef\" -o Dpkg::Options::=\"--force-confold\" dist-upgrade')\r\n\r\n        print red(env.host_string + ' | [Playback] waiting for reboot\\n')\r\n        with settings(warn_only=True):\r\n            reboot(wait=600)\r\n\r\n        print red(env.host_string + ' | Install the OpenStack client')\r\n        with prefix('sudo apt-get update'):\r\n            sudo('apt-get install python-openstackclient -y')", "response": "Set the OpenStack repository for trusty or client"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make(parser):\n    s = parser.add_subparsers(\n        title='commands',\n        metavar='COMMAND',\n        help='description',\n        )\n\n    def install_f(args):\n        install(args)\n    install_parser = install_subparser(s)\n    install_parser.set_defaults(func=install_f)", "response": "provison Manila Share with HA"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_paginated_members(self, direction=\"children\"):\n\n        page = self._last_page_parsed[direction]\n        if not page:\n            page = 1\n        else:\n            page = int(page)\n        while page:\n            if page > 1:\n                response = self._resolver.endpoint.get_collection(\n                    collection_id=self.id,\n                    page=page,\n                    nav=direction\n                )\n            else:\n                response = self._resolver.endpoint.get_collection(\n                    collection_id=self.id,\n                    nav=direction\n                )\n            response.raise_for_status()\n\n            data = response.json()\n            data = expand(data)[0]\n\n            if direction == \"children\":\n                self.children.update({\n                    o.id: o\n                    for o in type(self).parse_member(\n                        obj=data, collection=self, direction=direction, resolver=self._resolver\n                    )\n                })\n            else:\n                self.parents.update({\n                    o\n                    for o in type(self).parse_member(\n                        obj=data, collection=self, direction=direction, resolver=self._resolver\n                    )\n                })\n            self._last_page_parsed[direction] = page\n\n            page = None\n            if \"https://www.w3.org/ns/hydra/core#view\" in data:\n                if \"https://www.w3.org/ns/hydra/core#next\" in data[\"https://www.w3.org/ns/hydra/core#view\"][0]:\n                    page = int(_re_page.findall(\n                        data[\"https://www.w3.org/ns/hydra/core#view\"]\n                            [0][\"https://www.w3.org/ns/hydra/core#next\"]\n                            [0][\"@value\"]\n                    )[0])\n\n        self._parsed[direction] = True", "response": "Launch parsing of children and parents of the object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_member(\n            cls,\n            obj: dict,\n            collection: \"HttpResolverDtsCollection\",\n            direction: str,\n            **additional_parameters):\n\n        \"\"\" Parse the member value of a Collection response\n        and returns the list of object while setting the graph\n        relationship based on `direction`\n\n        :param obj: PyLD parsed JSON+LD\n        :param collection: Collection attached to the member property\n        :param direction: Direction of the member (children, parent)\n        \"\"\"\n        members = []\n\n        # Start pagination check here\n        hydra_members = obj.get(str(_hyd.member), [])\n\n        if hydra_members:\n            for member in hydra_members:\n                subcollection = cls.parse(member, metadata_parsed=False, **additional_parameters)\n                if direction == \"children\":\n                    subcollection.parents.set({collection})\n                members.append(subcollection)\n\n            if \"https://www.w3.org/ns/hydra/core#view\" not in obj or \\\n                    (direction == \"children\" and collection.size == 0):\n                collection._parsed[direction] = True\n\n        return members", "response": "Parse the member value of a Collection response and return the list of objects while setting the graph\n        relationship based on the direction"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef request_token(self):\n        logging.debug(\"Getting request token from %s:%d\",\n                      self.server, self.port)\n        token, secret = self._token(\"/oauth/requestToken\")\n        return \"{}/oauth/authorize?oauth_token={}\".format(self.host, token), \\\n            token, secret", "response": "Returns the url request_token request_secret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef access_token(self, request_token, request_secret):\n        logging.debug(\"Getting access token from %s:%d\",\n                      self.server, self.port)\n        self.access_token, self.access_secret = \\\n            self._token(\"/oauth/accessToken\", request_token, request_secret)\n        return self.access_token, self.access_secret", "response": "Returns the access token and access secret for the given request token and secret."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open_resource(self, name):\n        # Import nested here so we can run setup.py without GAE.\n        from google.appengine.api import memcache\n        from pytz import OLSON_VERSION\n\n        name_parts = name.lstrip('/').split('/')\n        if os.path.pardir in name_parts:\n            raise ValueError('Bad path segment: %r' % os.path.pardir)\n\n        cache_key = 'pytz.zoneinfo.%s.%s' % (OLSON_VERSION, name)\n        zonedata = memcache.get(cache_key)\n        if zonedata is None:\n            zonedata = get_zoneinfo().read('zoneinfo/' + '/'.join(name_parts))\n            memcache.add(cache_key, zonedata)\n            log.info('Added timezone to memcache: %s' % cache_key)\n        else:\n            log.info('Loaded timezone from memcache: %s' % cache_key)\n\n        return StringIO(zonedata)", "response": "Opens a resource from the zoneinfo subdir for reading."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if the given resource exists False otherwise", "response": "def resource_exists(self, name):\n        \"\"\"Return true if the given resource exists\"\"\"\n        if name not in self.available:\n            try:\n                get_zoneinfo().getinfo('zoneinfo/' + name)\n                self.available[name] = True\n            except KeyError:\n                self.available[name] = False\n\n        return self.available[name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsees datetime. tzinfo. fromutc", "response": "def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        dt = dt.replace(tzinfo=None)\n        idx = max(0, bisect_right(self._utc_transition_times, dt) - 1)\n        inf = self._transition_info[idx]\n        return (dt + inf[0]).replace(tzinfo=self._tzinfos[inf])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef localize(self, dt, is_dst=False):\n        '''Convert naive time to local time.\n\n        This method should be used to construct localtimes, rather\n        than passing a tzinfo argument to a datetime constructor.\n\n        is_dst is used to determine the correct timezone in the ambigous\n        period at the end of daylight savings time.\n\n        >>> from pytz import timezone\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> amdam = timezone('Europe/Amsterdam')\n        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)\n        >>> loc_dt1 = amdam.localize(dt, is_dst=True)\n        >>> loc_dt2 = amdam.localize(dt, is_dst=False)\n        >>> loc_dt1.strftime(fmt)\n        '2004-10-31 02:00:00 CEST (+0200)'\n        >>> loc_dt2.strftime(fmt)\n        '2004-10-31 02:00:00 CET (+0100)'\n        >>> str(loc_dt2 - loc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise an AmbiguousTimeError for ambiguous\n        times at the end of daylight savings\n\n        >>> loc_dt1 = amdam.localize(dt, is_dst=None)\n        Traceback (most recent call last):\n            [...]\n        AmbiguousTimeError: 2004-10-31 02:00:00\n\n        is_dst defaults to False\n\n        >>> amdam.localize(dt) == amdam.localize(dt, False)\n        True\n\n        is_dst is also used to determine the correct timezone in the\n        wallclock times jumped over at the start of daylight savings time.\n\n        >>> pacific = timezone('US/Pacific')\n        >>> dt = datetime(2008, 3, 9, 2, 0, 0)\n        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)\n        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)\n        >>> ploc_dt1.strftime(fmt)\n        '2008-03-09 02:00:00 PDT (-0700)'\n        >>> ploc_dt2.strftime(fmt)\n        '2008-03-09 02:00:00 PST (-0800)'\n        >>> str(ploc_dt2 - ploc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise a NonExistentTimeError for these skipped\n        times.\n\n        >>> loc_dt1 = pacific.localize(dt, is_dst=None)\n        Traceback (most recent call last):\n            [...]\n        NonExistentTimeError: 2008-03-09 02:00:00\n        '''\n        if dt.tzinfo is not None:\n            raise ValueError, 'Not naive datetime (tzinfo is already set)'\n\n        # Find the two best possibilities.\n        possible_loc_dt = set()\n        for delta in [timedelta(days=-1), timedelta(days=1)]:\n            loc_dt = dt + delta\n            idx = max(0, bisect_right(\n                self._utc_transition_times, loc_dt) - 1)\n            inf = self._transition_info[idx]\n            tzinfo = self._tzinfos[inf]\n            loc_dt = tzinfo.normalize(dt.replace(tzinfo=tzinfo))\n            if loc_dt.replace(tzinfo=None) == dt:\n                possible_loc_dt.add(loc_dt)\n\n        if len(possible_loc_dt) == 1:\n            return possible_loc_dt.pop()\n\n        # If there are no possibly correct timezones, we are attempting\n        # to convert a time that never happened - the time period jumped\n        # during the start-of-DST transition period.\n        if len(possible_loc_dt) == 0:\n            # If we refuse to guess, raise an exception.\n            if is_dst is None:\n                raise NonExistentTimeError(dt)\n\n            # If we are forcing the pre-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock forward a few\n            # hours.\n            elif is_dst:\n                return self.localize(\n                    dt + timedelta(hours=6), is_dst=True) - timedelta(hours=6)\n\n            # If we are forcing the post-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock back.\n            else:\n                return self.localize(\n                    dt - timedelta(hours=6), is_dst=False) + timedelta(hours=6)\n\n\n        # If we get this far, we have multiple possible timezones - this\n        # is an ambiguous case occuring during the end-of-DST transition.\n\n        # If told to be strict, raise an exception since we have an\n        # ambiguous case\n        if is_dst is None:\n            raise AmbiguousTimeError(dt)\n\n        # Filter out the possiblilities that don't match the requested\n        # is_dst\n        filtered_possible_loc_dt = [\n            p for p in possible_loc_dt\n                if bool(p.tzinfo._dst) == is_dst\n            ]\n\n        # Hopefully we only have one possibility left. Return it.\n        if len(filtered_possible_loc_dt) == 1:\n            return filtered_possible_loc_dt[0]\n\n        if len(filtered_possible_loc_dt) == 0:\n            filtered_possible_loc_dt = list(possible_loc_dt)\n\n        # If we get this far, we have in a wierd timezone transition\n        # where the clocks have been wound back but is_dst is the same\n        # in both (eg. Europe/Warsaw 1915 when they switched to CET).\n        # At this point, we just have to guess unless we allow more\n        # hints to be passed in (such as the UTC offset or abbreviation),\n        # but that is just getting silly.\n        #\n        # Choose the earliest (by UTC) applicable timezone.\n        def mycmp(a,b):\n            return cmp(\n                    a.replace(tzinfo=None) - a.tzinfo._utcoffset,\n                    b.replace(tzinfo=None) - b.tzinfo._utcoffset,\n                    )\n        filtered_possible_loc_dt.sort(mycmp)\n        return filtered_possible_loc_dt[0]", "response": "Convert naive time to local time."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef regressfile(filename):\n    _storybook().in_filename(filename).with_params(\n        **{\"python version\": \"2.7.14\"}\n    ).ordered_by_name().play()\n    _storybook().with_params(**{\"python version\": \"3.7.0\"}).in_filename(\n        filename\n    ).ordered_by_name().play()", "response": "Regress a file in python 2 and 3."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef readmegen():\n    hitchpylibrarytoolkit.readmegen(\n        _storybook(), DIR.project, DIR.key, DIR.gen, \"commandlib\"\n    )", "response": "Read the build documentation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_up(self):\n        self.path.state = self.path.gen.joinpath(\"state\")\n        if self.path.state.exists():\n            self.path.state.rmtree(ignore_errors=True)\n        self.path.state.mkdir()\n\n        for script in self.given.get(\"scripts\", []):\n            script_path = self.path.state.joinpath(script)\n\n            if not script_path.dirname().exists():\n                script_path.dirname().makedirs()\n\n            script_path.write_text(self.given[\"scripts\"][script])\n            script_path.chmod(\"u+x\")\n\n        for filename, contents in self.given.get(\"files\", {}).items():\n            self.path.state.joinpath(filename).write_text(contents)\n\n        self.python = hitchpylibrarytoolkit.project_build(\n            \"commandlib\", self.path, self.given[\"python version\"]\n        ).bin.python\n\n        self.example_py_code = (\n            ExamplePythonCode(self.python, self.path.state)\n            .with_code(self.given.get(\"code\", \"\"))\n            .with_setup_code(self.given.get(\"setup\", \"\"))\n        )", "response": "Set up your applications and the test environment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget specific port mapping.", "response": "async def get_specific_port_mapping(self, external_port: int, protocol: str) -> Dict:\n        \"\"\"\n        :param external_port: (int) external port to listen on\n        :param protocol:      (str) 'UDP' | 'TCP'\n        :return: (int) <internal port>, (str) <lan ip>, (bool) <enabled>, (str) <description>, (int) <lease time>\n        \"\"\"\n\n        try:\n            result = await self.gateway.commands.GetSpecificPortMappingEntry(\n                NewRemoteHost='', NewExternalPort=external_port, NewProtocol=protocol\n            )\n            if result and isinstance(self.gateway.commands.GetSpecificPortMappingEntry, SOAPCommand):\n                return {k: v for k, v in zip(self.gateway.commands.GetSpecificPortMappingEntry.return_order, result)}\n        except UPnPError:\n            pass\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def delete_port_mapping(self, external_port: int, protocol: str) -> None:\n        return await self.gateway.commands.DeletePortMapping(\n            NewRemoteHost=\"\", NewExternalPort=external_port, NewProtocol=protocol\n        )", "response": "Delete the port mapping for the specified external port and protocol."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the status of the current session.", "response": "async def get_status_info(self) -> Tuple[str, str, int]:\n        \"\"\"Returns (NewConnectionStatus, NewLastConnectionError, NewUptime)\"\"\"\n        return await self.gateway.commands.GetStatusInfo()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the iICS statistics.", "response": "async def x_get_ics_statistics(self) -> Tuple[int, int, int, int, str, str]:\n        \"\"\"Returns (TotalBytesSent, TotalBytesReceived, TotalPacketsSent, TotalPacketsReceived, Layer1DownstreamMaxBitRate, Uptime)\"\"\"\n        return await self.gateway.commands.X_GetICSStatistics()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authenticate(self, username: str, password: str) -> bool:\n        self.username = username\n        self.password = password\n\n        auth_payload = \"\"\"<authenticate1 xmlns=\\\"utcs\\\"\n                          xmlns:i=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\n                          <password>{password}</password>\n                          <username>{username}</username>\n                          <application>treeview</application>\n                          </authenticate1>\"\"\"\n        payload = auth_payload.format(password=self.password,\n                                      username=self.username)\n\n        xdoc = self.connection.soap_action(\n            '/ws/AuthenticationService', 'authenticate', payload)\n        if xdoc:\n            isok = xdoc.find(\n                './SOAP-ENV:Body/ns1:authenticate2/ns1:loginWasSuccessful',\n                IHCSoapClient.ihcns)\n            return isok.text == 'true'\n        return False", "response": "Do an Authentricate request and save the cookie returned to be used\n        Return True if the request was successfull otherwise Return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the current state of the current user", "response": "def get_state(self) -> str:\n        \"\"\"Get the controller state\"\"\"\n        xdoc = self.connection.soap_action('/ws/ControllerService',\n                                           'getState', \"\")\n        if xdoc:\n            return xdoc.find('./SOAP-ENV:Body/ns1:getState1/ns1:state',\n                             IHCSoapClient.ihcns).text\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait_for_state_change(self, state: str, waitsec) -> str:\n        payload = \"\"\"<ns1:waitForControllerStateChange1\n                     xmlns:ns1=\\\"utcs\\\" xsi:type=\\\"ns1:WSControllerState\\\">\n                     <ns1:state xsi:type=\\\"xsd:string\\\">{state}</ns1:state>\n                     </ns1:waitForControllerStateChange1>\n                     <ns2:waitForControllerStateChange2\n                     xmlns:ns2=\\\"utcs\\\" xsi:type=\\\"xsd:int\\\">\n                     {wait}</ns2:waitForControllerStateChange2>\n                     \"\"\".format(state=state, wait=waitsec)\n        xdoc = self.connection.soap_action('/ws/ControllerService',\n                                           'waitForControllerStateChange',\n                                           payload)\n        if xdoc:\n            return xdoc.find(\n                './SOAP-ENV:Body/ns1:waitForControllerStateChange3/ns1:state',\n                IHCSoapClient.ihcns).text\n        return False", "response": "Wait for controller state change and return state"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_project(self) -> str:\n        xdoc = self.connection.soap_action('/ws/ControllerService',\n                                           'getIHCProject', \"\")\n        if xdoc:\n            base64data = xdoc.find(\n                './SOAP-ENV:Body/ns1:getIHCProject1/ns1:data',\n                IHCSoapClient.ihcns).text\n            if not base64:\n                return False\n            compresseddata = base64.b64decode(base64data)\n            return zlib.decompress(compresseddata,\n                                   16+zlib.MAX_WBITS).decode('ISO-8859-1')\n        return False", "response": "Get the ihc project"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset a boolean runtime value", "response": "def set_runtime_value_bool(self, resourceid: int, value: bool) -> bool:\n        \"\"\"Set a boolean runtime value\"\"\"\n        if value:\n            boolvalue = \"true\"\n        else:\n            boolvalue = \"false\"\n\n        payload = \"\"\"\n            <setResourceValue1 xmlns=\\\"utcs\\\"\n            xmlns:i=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\n            <value i:type=\\\"a:WSBooleanValue\\\" xmlns:a=\\\"utcs.values\\\">\n            <a:value>{value}</a:value></value>\n            <typeString/>\n            <resourceID>{id}</resourceID>\n            <isValueRuntime>true</isValueRuntime>\n            </setResourceValue1>\n            \"\"\".format(id=resourceid, value=boolvalue)\n        xdoc = self.connection.soap_action('/ws/ResourceInteractionService',\n                                           'setResourceValue', payload)\n        if xdoc:\n            result = xdoc.find(r'./SOAP-ENV:Body/ns1:setResourceValue2',\n                               IHCSoapClient.ihcns).text\n            return result == \"true\"\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset a integer runtime value", "response": "def set_runtime_value_int(self, resourceid: int, intvalue: int):\n        \"\"\"Set a integer runtime value\"\"\"\n        payload = \"\"\"\n            <setResourceValue1 xmlns=\\\"utcs\\\"\n            xmlns:i=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\n            <value i:type=\\\"a:WSIntegerValue\\\" xmlns:a=\\\"utcs.values\\\">\n            <a:integer>{value}</a:integer></value>\n            <typeString/>\n            <resourceID>{id}</resourceID>\n            <isValueRuntime>true</isValueRuntime>\n            </setResourceValue1>\n            \"\"\".format(id=resourceid, value=intvalue)\n        xdoc = self.connection.soap_action('/ws/ResourceInteractionService',\n                                           'setResourceValue', payload)\n        if xdoc:\n            result = xdoc.find('./SOAP-ENV:Body/ns1:setResourceValue2',\n                               IHCSoapClient.ihcns).text\n            return result == \"true\"\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_runtime_value_float(self, resourceid: int, floatvalue: float):\n        payload = \"\"\"\n            <setResourceValue1 xmlns=\\\"utcs\\\"\n            xmlns:i=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\n            <value i:type=\\\"a:WSFloatingPointValue\\\" xmlns:a=\\\"utcs.values\\\">\n            <a:floatingPointValue>{value}</a:floatingPointValue></value>\n            <typeString/>\n            <resourceID>{id}</resourceID>\n            <isValueRuntime>true</isValueRuntime>\n            </setResourceValue1>\n            </s:Body>\n            \"\"\".format(id=resourceid, value=floatvalue)\n        xdoc = self.connection.soap_action('/ws/ResourceInteractionService',\n                                           'setResourceValue', payload)\n        if xdoc:\n            result = xdoc.find('./SOAP-ENV:Body/ns1:setResourceValue2',\n                               IHCSoapClient.ihcns).text\n            return result == \"true\"\n        return False", "response": "Set a flot runtime value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting runtime value of specified resource it", "response": "def get_runtime_value(self, resourceid: int):\n        \"\"\"Get runtime value of specified resource it\n           The returned value will be boolean, integer or float\n           Return None if resource cannot be found or on error\n        \"\"\"\n        payload = \"\"\"<getRuntimeValue1 xmlns=\"utcs\">{id}</getRuntimeValue1>\n                  \"\"\".format(id=resourceid)\n        xdoc = self.connection.soap_action('/ws/ResourceInteractionService',\n                                           'getResourceValue',\n                                           payload)\n        if not xdoc:\n            return False\n        boolresult = xdoc.find(\n            './SOAP-ENV:Body/ns1:getRuntimeValue2/ns1:value/ns2:value',\n            IHCSoapClient.ihcns)\n        if boolresult is not None:\n            return boolresult.text == \"true\"\n        intresult = xdoc.find(\n            './SOAP-ENV:Body/ns1:getRuntimeValue2/ns1:value/ns2:integer',\n            IHCSoapClient.ihcns)\n        if intresult is not None:\n            return int(intresult.text)\n        floatresult = xdoc.find(\n            ('./SOAP-ENV:Body/ns1:getRuntimeValue2/'\n             'ns1:value/ns2:floatingPointValue'),\n            IHCSoapClient.ihcns)\n        if floatresult is not None:\n            return float(floatresult.text)\n        enumNameResut = xdoc.find(\n            ('./SOAP-ENV:Body/ns1:getRuntimeValue2/'\n             'ns1:value/ns2:enumName'),\n            IHCSoapClient.ihcns)\n        if enumNameResut is not None:\n            return enumNameResut.text\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable_runtime_notifications(self, resourceids):\n        idsarr = \"\"\n        for ihcid in resourceids:\n            idsarr += \"<a:arrayItem>{id}</a:arrayItem>\".format(id=ihcid)\n\n        payload = \"\"\"<enableRuntimeValueNotifications1 xmlns=\\\"utcs\\\"\n                     xmlns:a=\\\"http://www.w3.org/2001/XMLSchema\\\"\n                     xmlns:i=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\n                     {arr}\n                     </enableRuntimeValueNotifications1>\n                     \"\"\".format(arr=idsarr)\n        xdoc = self.connection.soap_action('/ws/ResourceInteractionService',\n                                           'enableRuntimeValueNotifications',\n                                           payload)\n        if not xdoc:\n            return False\n        return True", "response": "Enable notification for specified resource ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait_for_resource_value_changes(self, wait: int=10):\n        changes = {}\n        payload = \"\"\"<waitForResourceValueChanges1\n                     xmlns=\\\"utcs\\\">{timeout}</waitForResourceValueChanges1>\n                  \"\"\".format(timeout=wait)\n        xdoc = self.connection.soap_action('/ws/ResourceInteractionService',\n                                           'getResourceValue', payload)\n        if not xdoc:\n            return False\n        result = xdoc.findall(\n            './SOAP-ENV:Body/ns1:waitForResourceValueChanges2/ns1:arrayItem',\n            IHCSoapClient.ihcns)\n        for item in result:\n            ihcid = item.find('ns1:resourceID', IHCSoapClient.ihcns)\n            if ihcid is None:\n                continue\n            bvalue = item.find('./ns1:value/ns2:value', IHCSoapClient.ihcns)\n            if bvalue is not None:\n                changes[int(ihcid.text)] = bvalue.text == 'true'\n                continue\n            ivalue = item.find('./ns1:value/ns3:integer', IHCSoapClient.ihcns)\n            if ivalue is not None:\n                changes[int(ihcid.text)] = int(ivalue.text)\n            fvalue = item.find('./ns1:value/ns2:floatingPointValue',\n                               IHCSoapClient.ihcns)\n            if fvalue is not None:\n                changes[int(ihcid.text)] = float(fvalue.text)\n                continue\n            \n            enumName = item.find('./ns1:value/ns2:enumName',\n                               IHCSoapClient.ihcns)\n            if enumName is not None:\n                changes[int(ihcid.text)] = enumName.text\n        return changes", "response": "Long polling for changes and return a dictionary with resource : value\n        for changes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user_log(self, language='da'):\n        payload = \"\"\"<getUserLog1 xmlns=\"utcs\" />\n                     <getUserLog2 xmlns=\"utcs\">0</getUserLog2>\n                     <getUserLog3 xmlns=\"utcs\">{language}</getUserLog3>\n                     \"\"\".format(language=language)\n        xdoc = self.connection.soap_action('/ws/ConfigurationService',\n                                           'getUserLog', payload)\n        if xdoc:\n            base64data = xdoc.find('./SOAP-ENV:Body/ns1:getUserLog4/ns1:data',\n                                   IHCSoapClient.ihcns).text\n            if not base64data:\n                return False\n            return base64.b64decode(base64data).decode('UTF-8')\n        return False", "response": "Get the controller state of the user log"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _add_info_from_string(self, text):\n        match = MemoryRegion.info_re.match(text)\n        assert match is not None\n\n        name = match.group(1)\n        kb_count = int(match.group(2))\n        self.info[name] = kb_count * 1024", "response": "Parse additional info from a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _from_match(match):\n        addr_beg, addr_end, r, w, x, p, offset, dev, inode, pathname = match.groups()\n        return MemoryRegion(addr_beg=int(addr_beg, 16),\n                            addr_end=int(addr_end, 16),\n                            readable=(r == \"r\"),\n                            writable=(w == \"w\"),\n                            executable=(x == \"x\"),\n                            private=(p == \"p\"),\n                            offset=int(offset, 16),\n                            dev=dev,\n                            inode=int(inode),\n                            pathname=pathname)", "response": "Create a MemoryRegion object from a regex match object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntraversing tree to node", "response": "def _get_node(response, *ancestors):\n    \"\"\" Traverse tree to node \"\"\"\n    document = response\n    for ancestor in ancestors:\n        if ancestor not in document:\n            return {}\n        else:\n            document = document[ancestor]\n    return document"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_token(self):\n        headers = {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Authorization': 'Basic ' + base64.b64encode(\n                (self._key + ':' + self._secret).encode()).decode()\n            }\n        data = {'grant_type': 'client_credentials'}\n\n        response = requests.post(TOKEN_URL, data=data, headers=headers)\n        obj = json.loads(response.content.decode('UTF-8'))\n        self._token = obj['access_token']\n        self._token_expire_date = (\n            datetime.now() +\n            timedelta(minutes=self._expiery))", "response": "Update the token from the key and secret"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of stop locations that are nearbystops.", "response": "def location_nearbystops(self, origin_coord_lat, origin_coord_long):\n        \"\"\" location.nearbystops \"\"\"\n        response = self._request(\n            'location.nearbystops',\n            originCoordLat=origin_coord_lat,\n            originCoordLong=origin_coord_long)\n        return _get_node(response, 'LocationList', 'StopLocation')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef location_name(self, name):\n        response = self._request(\n            'location.name',\n            input=name)\n        return _get_node(response, 'LocationList', 'StopLocation')", "response": "Get a location by name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the arrival board for a stop.", "response": "def arrivalboard(self, stop_id, date=None, direction=None):\n        \"\"\" arrivalBoard \"\"\"\n        date = date if date else datetime.now()\n        request_parameters = {\n            'id': stop_id,\n            'date': date.strftime(DATE_FORMAT),\n            'time': date.strftime(TIME_FORMAT)\n        }\n        if direction:\n            request_parameters['directiona'] = direction\n        response = self._request(\n            'arrivalBoard',\n            **request_parameters)\n        return _get_node(response, 'ArrivalBoard', 'Arrival')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef trip(self, origin_id, dest_id, date=None):\n        date = date if date else datetime.now()\n        response = self._request(\n            'trip',\n            originId=origin_id,\n            destId=dest_id,\n            date=date.strftime(DATE_FORMAT),\n            time=date.strftime(TIME_FORMAT))\n        return _get_node(response, 'TripList', 'Trip')", "response": "Get a list of all Trip objects from a source."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrequest method for getting a specific object from the API", "response": "def _request(self, service, **parameters):\n        \"\"\" request builder \"\"\"\n        urlformat = \"{baseurl}/{service}?{parameters}&format=json\"\n        url = urlformat.format(\n            baseurl=API_BASE_URL,\n            service=service,\n            parameters=\"&\".join([\n                \"{}={}\".format(key, value) for key, value in parameters.items()\n                ]))\n        if datetime.now() > self._token_expire_date:\n            self.update_token()\n        headers = {'Authorization': 'Bearer ' + self._token}\n        res = requests.get(url, headers=headers)\n        if res.status_code == 200:\n            return json.loads(res.content.decode('UTF-8'))\n        else:\n            raise Error('Error: ' + str(res.status_code) +\n                            str(res.content))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef expand_namespace(nsmap, string):\n    for ns in nsmap:\n        if isinstance(string, str) and isinstance(ns, str) and string.startswith(ns+\":\"):\n            return string.replace(ns+\":\", nsmap[ns])\n    return string", "response": "Expands a string with a known prefix in nsmap."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates over a graph to find object connected to a target node.", "response": "def graphiter(self, graph, target, ascendants=0, descendants=1):\n        \"\"\" Iter on a graph to finds object connected\n\n        :param graph: Graph to serialize\n        :type graph: Graph\n        :param target: Node to iterate over\n        :type target: Node\n        :param ascendants: Number of level to iter over upwards (-1 = No Limit)\n        :param descendants: Number of level to iter over downwards (-1 = No limit)\n        :return:\n        \"\"\"\n\n        asc = 0 + ascendants\n        if asc != 0:\n            asc -= 1\n\n        desc = 0 + descendants\n        if desc != 0:\n            desc -= 1\n\n        t = str(target)\n\n        if descendants != 0 and self.downwards[t] is True:\n            self.downwards[t] = False\n            for pred, obj in graph.predicate_objects(target):\n                if desc == 0 and isinstance(obj, BNode):\n                    continue\n                self.add((target, pred, obj))\n\n                # Retrieve triples about the object\n                if desc != 0 and self.downwards[str(obj)] is True:\n                    self.graphiter(graph, target=obj, ascendants=0, descendants=desc)\n\n        if ascendants != 0 and self.updwards[t] is True:\n            self.updwards[t] = False\n            for s, p in graph.subject_predicates(object=target):\n                if desc == 0 and isinstance(s, BNode):\n                    continue\n                self.add((s, p, target))\n\n                # Retrieve triples about the parent as object\n                if asc != 0 and self.updwards[str(s)] is True:\n                    self.graphiter(graph, target=s, ascendants=asc, descendants=0)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef timezone(zone):\n    r''' Return a datetime.tzinfo implementation for the given timezone\n\n    >>> from datetime import datetime, timedelta\n    >>> utc = timezone('UTC')\n    >>> eastern = timezone('US/Eastern')\n    >>> eastern.zone\n    'US/Eastern'\n    >>> timezone(u'US/Eastern') is eastern\n    True\n    >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n    >>> loc_dt = utc_dt.astimezone(eastern)\n    >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n    >>> loc_dt.strftime(fmt)\n    '2002-10-27 01:00:00 EST (-0500)'\n    >>> (loc_dt - timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 00:50:00 EST (-0500)'\n    >>> eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 01:50:00 EDT (-0400)'\n    >>> (loc_dt + timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 01:10:00 EST (-0500)'\n\n    Raises UnknownTimeZoneError if passed an unknown zone.\n\n    >>> timezone('Asia/Shangri-La')\n    Traceback (most recent call last):\n    ...\n    UnknownTimeZoneError: 'Asia/Shangri-La'\n\n    >>> timezone(u'\\N{TRADE MARK SIGN}')\n    Traceback (most recent call last):\n    ...\n    UnknownTimeZoneError: u'\\u2122'\n    '''\n    if zone.upper() == 'UTC':\n        return utc\n\n    try:\n        zone = zone.encode('US-ASCII')\n    except UnicodeEncodeError:\n        # All valid timezones are ASCII\n        raise UnknownTimeZoneError(zone)\n\n    zone = _unmunge_zone(zone)\n    if zone not in _tzinfo_cache:\n        if resource_exists(zone):\n            _tzinfo_cache[zone] = build_tzinfo(zone, open_resource(zone))\n        else:\n            raise UnknownTimeZoneError(zone)\n\n    return _tzinfo_cache[zone]", "response": "r Returns a datetime. tzinfo implementation for the given timezone."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef uniqued(iterable):\n    seen = set()\n    add = seen.add\n    return [i for i in iterable if i not in seen and not add(i)]", "response": "Return unique list of items preserving order."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nyields all items from iterable except the last one.", "response": "def butlast(iterable):\n    \"\"\"Yield all items from ``iterable`` except the last one.\n\n    >>> list(butlast(['spam', 'eggs', 'ham']))\n    ['spam', 'eggs']\n\n    >>> list(butlast(['spam']))\n    []\n\n    >>> list(butlast([]))\n    []\n    \"\"\"\n    iterable = iter(iterable)\n    try:\n        first = next(iterable)\n    except StopIteration:\n        return\n    for second in iterable:\n        yield first\n        first = second"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a translate function for strings and unicode.", "response": "def generic_translate(frm=None, to=None, delete=''):\n    \"\"\"Return a translate function for strings and unicode.\n\n    >>> translate = generic_translate('Hoy', 'Bad', 'r')\n\n    >>> translate('Holy grail')\n    'Bald gail'\n\n    >>> translate(u'Holy grail') == u'Bald gail'\n    True\n    \"\"\"\n    if PY2:\n        delete_dict = dict.fromkeys(ord(unicode(d)) for d in delete)\n\n        if frm is None and to is None:\n            string_trans = None\n            unicode_table = delete_dict\n        else:\n            string_trans = string.maketrans(frm, to)\n            unicode_table = dict(((ord(unicode(f)), unicode(t))\n                for f, t in zip(frm, to)), **delete_dict)\n\n        string_args = (string_trans, delete) if delete else (string_trans,)\n\n        translate_args = [string_args, (unicode_table,)]\n\n        def translate(basestr):\n            args = translate_args[isinstance(basestr, unicode)]\n            return basestr.translate(*args)\n\n    else:\n        string_trans = str.maketrans(frm or '', to or '', delete or '')\n\n        def translate(basestr):\n            return basestr.translate(string_trans)\n\n    return translate"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _cryptography_cipher(key, iv):\n    return Cipher(\n        algorithm=algorithms.TripleDES(key),\n        mode=modes.CBC(iv),\n        backend=default_backend()\n    )", "response": "Build a cryptography TripleDES Cipher object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing command line parameters as list of strings", "response": "def parse_args(args):\n    \"\"\"\n    Parse command line parameters\n\n    :param args: command line parameters as list of strings\n    :return: command line parameters as :obj:`argparse.Namespace`\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Build html reveal.js slides from markdown in docs/ dir\")\n    parser.add_argument(\n        '-v',\n        '--verbose',\n        help='Whether to show progress messages on stdout, including HTML',\n        action='store_true')\n    parser.add_argument(\n        '--version',\n        help='print twip package version and exit.',\n        action='version',\n        version='twip {ver}'.format(ver=__version__))\n    parser.add_argument(\n        '-b',\n        '--blog_path',\n        help='Path to source markdown files. Must contain an `images` subdir',\n        default=BLOG_PATH)\n    parser.add_argument(\n        '-s',\n        '--slide_path',\n        help='Path to dir for output slides (HTML). An images subdir will be added. A slides subdir should already exist.',\n        default=DOCS_PATH)\n    parser.add_argument(\n        '-p',\n        '--presentation',\n        help='Source markdown base file name (without .md extension). The HTML slides will share the same basename.',\n        default='2015-10-27-Hacking-Oregon-Hidden-Political-Connections')\n    return parser.parse_args(args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_git_repo():\n    today\n    commands = \"\"\"\n        git add docs/*.html\n        git add docs/images/\n        git add docs*.ipynb\n        git commit -am \"autocommit new docs build {}\"\n        git push hobson\n        git push origin\n\n        git checkout master\n        git merge gh-pages -m \"automerge gh-pages into master\"\n        git push hobson\n        git push origin\n\n        git checkout gh-pages\n        git merge master -m \"automerge master into gh-pages\"\n        git push hobson\n        git push origin\n        \"\"\".format(datetime.datetime.today().isoformat())\n\n    for cmd in commands.split('\\n'):\n        cmd = cmd.strip()\n        if cmd:\n            try:\n                output = subprocess.check_output(cmd.split())\n                print(output)\n            except CalledProcessError:\n                print_exc()", "response": "Update Git repository with new contents."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_metadata(metadata_obj: Metadata, metadata_dictionary: dict) -> None:\n    for key, value_set in metadata_dictionary.get(\"https://w3id.org/dts/api#dublincore\", [{}])[0].items():\n        term = URIRef(key)\n        for value_dict in value_set:\n            metadata_obj.add(term, *dict_to_literal(value_dict))\n\n    for key, value_set in metadata_dictionary.get(\"https://w3id.org/dts/api#extensions\", [{}])[0].items():\n        term = URIRef(key)\n        for value_dict in value_set:\n            metadata_obj.add(term, *dict_to_literal(value_dict))", "response": "Parses the given dictionary into a Metadata object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef string2geocoord(coord_str, coord_class, format_str = 'D'):\n    '''\n    Create a GeoCoord object (e.g. Latitude or Longitude) from a string.\n    Inputs:\n        coord_str (str) - a string representation of a geographic coordinate (e.g. '5.083 N'). Each\n          section of the string must be separated by some kind of a separator character ('5.083N' is\n          invalid).\n        coord_class (class) - a class inheriting from GeoCoord that includes a set_hemisphere method.\n          Can be either Latitude or Longitude\n        format_str (str) - a string representation of the sections of coord_str. Possible letter values\n        correspond to the keys of the dictionary format2value, where\n              'H' is a hemisphere identifier (e.g. N, S, E or W)\n              'D' is a coordinate in decimal degrees notation\n              'd' is a coordinate in degrees notation\n              'M' is a coordinate in decimal minutes notaion\n              'm' is a coordinate in minutes notation\n              'S' is a coordinate in seconds notation\n              Any other characters (e.g. ' ' or ', ') will be treated as a separator between the above components.\n          All components should be separated by the '%' character. For example, if the coord_str is\n          '5, 52, 59.88_N', the format_str would be 'd%, %m%, %S%_%H'\n    Returns:\n        GeoCoord object initialized with the coordinate information from coord_str\n    '''\n    new_coord = coord_class()\n    # Dictionary of functions for setting variables in the coordinate class:\n    format2value = {'H': new_coord.set_hemisphere,\n                    'M': new_coord.set_minute,\n                    'm': new_coord.set_minute,\n                    'd': new_coord.set_degree,\n                    'D': new_coord.set_degree,\n                    'S': new_coord.set_second}\n    if format_str[0] == 'H':\n        ''' Having the hemisphere identifier at the beginning is problematic for ensuring that\n        the final coordinate value will be negative. Instead, change the identifier and the\n        format string so that the hemisphere is identified at the end:'''\n        new_coord_start = re.search('\\d', coord_str).start() # Find the beginning of the coordinate\n        new_format_start = re.search('[a-gi-zA-GI-Z]', format_str).start() # Find the first non-hemisphere identifier\n        format_str = '% %'.join((format_str[new_format_start:], format_str[0])) # Move hemisphere identifier to the back\n        coord_str = ' '.join((coord_str[new_coord_start:], coord_str[0])) # Move hemisphere identifier to the back\n    format_elements = format_str.split('%')\n    separators = [sep for sep in format_elements if sep not in format2value.keys()] # E.g. ' ', '_' or ', ' characters\n    separators.append('%') # Dummy separator for the final part of the coord_str\n    formatters = [form for form in format_elements if form in format2value.keys()] # E.g. 'D', 'm', or 'S' characters\n    for form, sep in zip(formatters, separators):\n        coord_elements = coord_str.split(sep)\n        format2value[form](coord_elements[0]) # Set the coordinate variable (e.g. 'self.degree' with the coordinate substring (e.g. '5')\n        coord_str = sep.join(coord_elements[1:]) # Get rid of parts of the substring that have already been done\n    new_coord._update() # Change all of the variables in the coordinate class so they are consistent with each other\n    return new_coord", "response": "Converts a string representation of a geographic coordinate into a GeoCoord object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a string representation of a latitude and longitude into a LatLon object.", "response": "def string2latlon(lat_str, lon_str, format_str):\n    '''\n    Create a LatLon object from a pair of strings.\n    Inputs:\n        lat_str (str) - string representation of a latitude (e.g. '5 52 59.88 N')\n        lon_str (str) - string representation of a longitude (e.g. '162 4 59.88 W')\n        format_str (str) - format in which the coordinate strings are given (e.g.\n          for the above examples this would be 'd% %m% %S% %H'). See function\n          string2geocoord for a detailed explanation on how to specify formats.\n    Returns:\n        A LatLon object initialized with coordinate data from lat_str and lon_str\n    '''\n    lat = string2geocoord(lat_str, Latitude, format_str)\n    lon = string2geocoord(lon_str, Longitude, format_str)\n    new_latlon = LatLon(lat = lat, lon = lon)\n    return new_latlon"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _calc_degreeminutes(decimal_degree):\n        '''\n        Calculate degree, minute second from decimal degree\n        '''\n        sign = compare(decimal_degree, 0) # Store whether the coordinate is negative or positive\n        decimal_degree = abs(decimal_degree)\n        degree = decimal_degree//1 # Truncate degree to be an integer\n        decimal_minute = (decimal_degree - degree)*60. # Calculate the decimal minutes\n        minute = decimal_minute//1 # Truncate minute to be an integer\n        second = (decimal_minute - minute)*60. # Calculate the decimal seconds\n        # Finally, re-impose the appropriate sign\n        degree = degree*sign\n        minute = minute*sign\n        second = second*sign\n        return (degree, minute, decimal_minute, second)", "response": "Calculate degree minute second from decimal degree\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update(self):\n        '''\n        Given degree, minute, and second information, clean up the variables and make them\n        consistent (for example, if minutes > 60, add extra to degrees, or if degrees is\n        a decimal, add extra to minutes).\n        '''\n        self.decimal_degree = self._calc_decimaldegree(self.degree, self.minute, self.second)\n        self.degree, self.minute, self.decimal_minute, self.second = self._calc_degreeminutes(self.decimal_degree)", "response": "Update the internal representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_string(self, format_str):\n        '''\n        Output lat, lon coordinates as string in chosen format\n        Inputs:\n            format (str) - A string of the form A%B%C where A, B and C are identifiers.\n              Unknown identifiers (e.g. ' ', ', ' or '_' will be inserted as separators\n              in a position corresponding to the position in format.\n        Examples:\n            >> palmyra = LatLon(5.8833, -162.0833)\n            >> palmyra.to_string('D') # Degree decimal output\n            ('5.8833', '-162.0833')\n            >> palmyra.to_string('H% %D')\n            ('N 5.8833', 'W 162.0833')\n            >> palmyra.to_string('d%_%M')\n            ('5_52.998', '-162_4.998')\n        '''\n        format2value = {'H': self.get_hemisphere(),\n                        'M': abs(self.decimal_minute),\n                        'm': int(abs(self.minute)),\n                        'd': int(self.degree),\n                        'D': self.decimal_degree,\n                        'S': abs(self.second)}\n        format_elements = format_str.split('%')\n        coord_list = [str(format2value.get(element, element)) for element in format_elements]\n        coord_str = ''.join(coord_list)\n        if 'H' in format_elements: # No negative values when hemispheres are indicated\n            coord_str = coord_str.replace('-', '')\n        return coord_str", "response": "Converts the current object into a string in the chosen format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_hemisphere(self, hemi_str):\n        '''\n        Given a hemisphere identifier, set the sign of the coordinate to match that hemisphere\n        '''\n        if hemi_str == 'W':\n            self.degree = abs(self.degree)*-1\n            self.minute = abs(self.minute)*-1\n            self.second = abs(self.second)*-1\n            self._update()\n        elif hemi_str == 'E':\n            self.degree = abs(self.degree)\n            self.minute = abs(self.minute)\n            self.second = abs(self.second)\n            self._update()\n        else:\n            raise ValueError('Hemisphere identifier for longitudes must be E or W')", "response": "Given a hemisphere identifier set the sign of the coordinate to match that hemisphere."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn coordinates transformed to a given projection", "response": "def project(self, projection):\n        '''\n        Return coordinates transformed to a given projection\n        Projection should be a basemap or pyproj projection object or similar\n        '''\n        x, y = projection(self.lon.decimal_degree, self.lat.decimal_degree)\n        return (x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _pyproj_inv(self, other, ellipse = 'WGS84'):\n        '''\n        Perform Pyproj's inv operation on two LatLon objects\n        Returns the initial heading and reverse heading in degrees, and the distance\n        in km.\n        '''\n        lat1, lon1 = self.lat.decimal_degree, self.lon.decimal_degree\n        lat2, lon2 = other.lat.decimal_degree, other.lon.decimal_degree\n        g = pyproj.Geod(ellps = ellipse)\n        heading_initial, heading_reverse, distance = g.inv(lon1, lat1, lon2, lat2, radians = False)\n        distance = distance/1000.0\n        if heading_initial == 0.0: # Reverse heading not well handled for coordinates that are directly south\n            heading_reverse = 180.0\n        return {'heading_initial': heading_initial, 'heading_reverse': heading_reverse, 'distance': distance}", "response": "Perform Pyproj s inv operation on two LatLon objects returning the initial heading and reverse heading in degrees and the distance in km."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the great circle distance between two lat - lon coordinates on a sphere.", "response": "def distance_sphere(self, other, radius = 6371.0):\n        '''\n        -- Deprecated in v0.70. Use distance(other, ellipse = 'sphere') instead --\n\n        Returns great circle distance between two lat/lon coordinates on a sphere\n        using the Haversine formula. The default radius corresponds to the FAI sphere\n        with units in km.\n        '''\n        warnings.warn(\"Deprecated in v0.70. Use distance(other, ellipse = 'sphere') instead\",\n                      DeprecationWarning)\n        lat1, lon1 = self.lat.decimal_degree, self.lon.decimal_degree\n        lat2, lon2 = other.lat.decimal_degree, other.lon.decimal_degree\n        pi = math.pi/180.\n        # phi is 90 - latitude\n        phi1 = (90. - lat1)*pi\n        phi2 = (90. - lat2)*pi\n        # theta is longitude\n        theta1 = lon1*pi\n        theta2 = lon2 *pi\n        cos = (math.sin(phi1)*math.sin(phi2)*math.cos(theta1 - theta2) +\n               math.cos(phi1)*math.cos(phi2))\n        arc = math.acos(cos)\n        return arc*radius"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef offset(self, heading_initial, distance, ellipse = 'WGS84'):\n        '''\n        Offset a LatLon object by a heading (in degrees) and distance (in km)\n        to return a new LatLon object\n        '''\n        lat1, lon1 = self.lat.decimal_degree, self.lon.decimal_degree\n        g = pyproj.Geod(ellps = ellipse)\n        distance = distance * 1000 # Convert km to meters\n        lon2, lat2, back_bearing = g.fwd(lon1, lat1, heading_initial, distance, radians = False)\n        return LatLon(Latitude(lat2), Longitude(lon2))", "response": "Offset a LatLon object by a heading and distance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a string representation of lat and lon as a 2 - element tuple using the format specified by formatter", "response": "def to_string(self, formatter = 'D'):\n        '''\n        Return string representation of lat and lon as a 2-element tuple\n        using the format specified by formatter\n        '''\n        return (self.lat.to_string(formatter), self.lon.to_string(formatter))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a GeoVector object that is the difference between self and other.", "response": "def _sub_latlon(self, other):\n        '''\n        Called when subtracting a LatLon object from self\n        '''\n        inv = self._pyproj_inv(other)\n        heading = inv['heading_reverse']\n        distance = inv['distance']\n        return GeoVector(initial_heading = heading, distance = distance)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _update(self):\n        '''\n        Calculate heading and distance from dx and dy\n        '''\n        try:\n            theta_radians = math.atan(float(self.dy)/self.dx)\n        except ZeroDivisionError:\n            if self.dy > 0: theta_radians = 0.5*math.pi\n            elif self.dy < 0: theta_radians = 1.5*math.pi\n            self.magnitude = self.dy\n        else:\n            self.magnitude = 1./(math.cos(theta_radians))*self.dx\n        theta = math.degrees(theta_radians)\n        self.heading = self._angle_or_heading(theta)", "response": "Update the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if self and other are almost equal to within e km of each other in dx and dy.", "response": "def almost_equals(self, other, e = 0.000001):\n        '''\n        Sometimes required for comparing GeoVectors if float error has\n        occurred. Determine if self and other (another GeoVector) are\n        equal to within e km of each other in dx and dy. The default\n        (e = 0.000001) will return True if self and other are less than\n        1 mm apart in distance.\n        '''\n        return abs(self.dx - other.dx) < e and abs(self.dy - other.dy) < e"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts auth to str so that it can be hashed", "response": "def _authstr(self, auth):\n        \"\"\"Convert auth to str so that it can be hashed\"\"\"\n        if type(auth) is dict:\n            return '{' + ','.join([\"{0}:{1}\".format(k, auth[k]) for k in sorted(auth.keys())]) + '}'\n        return auth"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add(self, auth, method, args, notimeout=False):\n        authstr = self._authstr(auth)\n        self._requests.setdefault(authstr, []).append((method, args))\n        self._notimeouts.setdefault(authstr, False)\n        if notimeout:\n            self._notimeouts[authstr] = notimeout", "response": "Append a deferred request for a particular auth / CIK."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_requests(self, auth):\n        authstr = self._authstr(auth)\n        return (authstr in self._requests\n                and len(self._requests[authstr]) > 0)", "response": "Returns True if there are any deferred requests for the given auth."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _callJsonRPC(self, auth, callrequests, returnreq=False, notimeout=False):\n        # get full auth (auth could be a CIK str)\n        auth = self._getAuth(auth)\n        jsonreq = {\"auth\": auth, \"calls\": callrequests}\n        if self.logrequests:\n            self._loggedrequests.append(jsonreq)\n        body = json.dumps(jsonreq)\n\n        def handle_request_exception(exception):\n            raise JsonRPCRequestException(\n                \"Failed to make http request: %s\" % str(exception))\n\n        body, response = self.onephttp.request('POST',\n                                               self.url,\n                                               body,\n                                               self.headers,\n                                               exception_fn=handle_request_exception,\n                                               notimeout=notimeout)\n\n        def handle_response_exception(exception):\n\n            raise JsonRPCResponseException(\n                \"Failed to get response for request: %s %s\" % (type(exception), str(exception)))\n\n        try:\n            res = json.loads(body)\n        except:\n            ex = sys.exc_info()[1]\n            raise OnePlatformException(\n                \"Exception while parsing JSON response: %s\\n%s\" % (body, ex))\n        if isinstance(res, dict) and 'error' in res:\n            raise OnePlatformException(str(res['error']))\n        if isinstance(res, list):\n            ret = []\n            for r in res:\n                # first, find the matching request so we can return it\n                # along with the response.\n                request = None\n                for call in callrequests:\n                    if call['id'] == r['id']:\n                        request = call\n                if 'status' in r:\n                    if 'ok' == r['status']:\n                        if 'result' in r:\n                            ret.append((request, True, r['result']))\n                        else:\n                            ret.append((request, True, 'ok'))\n                    else:\n                        ret.append((request, False, r['status']))\n                elif 'error' in r:\n                    raise OnePlatformException(str(r['error']))\n            if returnreq:\n                return ret\n            else:\n                # backward compatibility: return just True/False and\n                # 'ok'/result/status as before\n                return ret[0][1:]\n\n        raise OneException(\"Unknown error\")", "response": "Calls the Exosite One Platform RPC API."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _getAuth(self, auth):\n        if type(auth) is dict:\n            return auth\n        else:\n            # auth is string\n            if None != self._clientid:\n                return {\"cik\": auth, \"client_id\": self._clientid}\n            elif None != self._resourceid:\n                return {\"cik\": auth, \"resource_id\": self._resourceid}\n            return {\"cik\": auth}", "response": "Create the authorization portion of a request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall the Exosite One Platform RPC API.", "response": "def _call(self, method, auth, arg, defer, notimeout=False):\n        \"\"\"Calls the Exosite One Platform RPC API.\n\n           If `defer` is False, result is a tuple with this structure:\n\n                (success (boolean), response)\n\n           Otherwise, the result is just True.\n\n           notimeout, if True, ignores the reuseconnection setting, creating\n           a new connection with no timeout.\n        \"\"\"\n        if defer:\n            self.deferred.add(auth, method, arg, notimeout=notimeout)\n            return True\n        else:\n            calls = self._composeCalls([(method, arg)])\n            return self._callJsonRPC(auth, calls, notimeout=notimeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_deferred(self, auth):\n        if self.deferred.has_requests(auth):\n            method_arg_pairs = self.deferred.get_method_args_pairs(auth)\n            calls = self._composeCalls(method_arg_pairs)\n            # should this call be made with no timeout? (e.g. is there a\n            # wait())\n            notimeout = self.deferred.get_notimeout(auth)\n            try:\n                r = self._callJsonRPC(auth, calls, returnreq=True, notimeout=notimeout)\n            finally:\n                # remove deferred calls\n                self.deferred.reset(auth)\n            return r\n        raise JsonRPCRequestException('No deferred requests to send.')", "response": "Send all deferred requests for a particular CIK / auth."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nactivates an entity for the client specified in the resource ID.", "response": "def activate(self, auth, codetype, code, defer=False):\n        \"\"\" Given an activation code, activate an entity for the client specified in <ResourceID>.\n\n        Args:\n            auth: <cik>\n            codetype: Type of code being activated.\n            code: Code to activate.\n        \"\"\"\n\n        return self._call('activate', auth, [codetype, code], defer)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating something in Exosite.", "response": "def create(self, auth, type, desc, defer=False):\n        \"\"\" Create something in Exosite.\n\n        Args:\n            auth: <cik>\n            type: What thing to create.\n            desc: Information about thing.\n        \"\"\"\n        return self._call('create', auth, [type, desc], defer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a dataport resource.", "response": "def createDataport(self, auth, desc, defer=False):\n        \"\"\"Create a dataport resource.\n           \"format\" and \"retention\" are required\n            {\n                \"format\": \"float\" | \"integer\" | \"string\",\n                \"meta\": string = \"\",\n                \"name\": string = \"\",\n                \"preprocess\": list = [],\n                \"public\": boolean = false,\n                \"retention\": {\n                    \"count\": number | \"infinity\",\n                    \"duration\": number | \"infinity\"\n                },\n                \"subscribe\": <ResourceID> |  null = null\n            }\n        \"\"\"\n        return self._call('create', auth, ['dataport', desc], defer)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting the specified resource.", "response": "def drop(self, auth, resource, defer=False):\n        \"\"\" Deletes the specified resource.\n\n        Args:\n            auth: <cik>\n            resource: <ResourceID>\n        \"\"\"\n        return self._call('drop', auth, [resource], defer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flush(self, auth, resource, options=None, defer=False):\n        args = [resource]\n        if options is not None:\n            args.append(options)\n        return self._call('flush', auth, args, defer)", "response": "Empties the specified resource of data per specified constraints."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngrant resources with specific permissions and return a token.", "response": "def grant(self, auth, resource, permissions, ttl=None, defer=False):\n        \"\"\" Grant resources with specific permissions and return a token.\n\n        Args:\n            auth: <cik>\n            resource: Alias or ID of resource.\n            permissions: permissions of resources.\n            ttl: Time To Live.\n        \"\"\"\n        args = [resource, permissions]\n        if ttl is not None:\n            args.append({\"ttl\": ttl})\n        return self._call('grant', auth, args, defer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef info(self, auth, resource, options={}, defer=False):\n        return self._call('info', auth,  [resource, options], defer)", "response": "Request creation and usage information of specified resource according to the specified options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lookup(self, auth, type, mapping, defer=False):\n        return self._call('lookup', auth, [type, mapping], defer)", "response": "Look up a Resource ID by alias owned Resource ID or share activation code under the base resource ID."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef map(self, auth, resource, alias, defer=False):\n        return self._call('map', auth, ['alias', resource, alias], defer)", "response": "Creates an alias for a resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef move(self, auth, resource, destinationresource, options={\"aliases\": True}, defer=False):\n        return self._call('move', auth, [resource, destinationresource, options], defer)", "response": "Moves a resource from one parent client to another."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read(self, auth, resource, options, defer=False):\n        return self._call('read', auth, [resource, options], defer)", "response": "Reads the value of a dataport."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrecording a list of historical entries to the specified resource.", "response": "def record(self, auth, resource, entries, options={}, defer=False):\n        \"\"\" Records a list of historical entries to the resource specified.\n\n        Note: This API is depricated, use recordbatch instead.\n\n        Calls a function that bulids a request that writes a list of historical entries to the\n        specified resource.\n\n        Args:\n            auth: Takes the device cik\n            resource: Takes the dataport alias or rid.\n            entries: A list of entries to write to the resource.\n            options: Currently unused.\n        \"\"\"\n        return self._call('record', auth, [resource, entries, options], defer)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recordbatch(self, auth, resource, entries, defer=False):\n        return self._call('recordbatch', auth, [resource, entries], defer)", "response": "Records a list of historical entries to the resource specified."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef revoke(self, auth, codetype, code, defer=False):\n        return self._call('revoke', auth, [codetype, code], defer)", "response": "Revoke an associated entity with the given activation code."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef share(self, auth, resource, options={}, defer=False):\n        return self._call('share', auth, [resource, options], defer)", "response": "Generates a share code for the given resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, auth, resource, desc={}, defer=False):\n        return self._call('update', auth, [resource, desc], defer)", "response": "Updates the description of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the usage for a specific resource and its subhierarchy.", "response": "def usage(self, auth, resource, metric, starttime, endtime, defer=False):\n        \"\"\" Returns metric usage for client and its subhierarchy.\n\n        Args:\n            auth: <cik> for authentication\n            resource: ResourceID\n            metrics: Metric to measure (as string), it may be an entity or consumable.\n            starttime: Start time of window to measure useage (format is ___).\n            endtime: End time of window to measure useage (format is ___).\n        \"\"\"\n        return self._call('usage', auth,\n                          [resource, metric, starttime, endtime], defer)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wait(self, auth, resource, options, defer=False):\n        # let the server control the timeout\n        return self._call('wait', auth, [resource, options], defer, notimeout=True)", "response": "This is a HTTP Long Polling API which allows a user to wait on specific resources to be updated."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a single value to the resource specified.", "response": "def write(self, auth, resource, value, options={}, defer=False):\n        \"\"\" Writes a single value to the resource specified.\n\n        Args:\n            auth: cik for authentication.\n            resource: resource to write to.\n            value: value to write\n            options: options.\n        \"\"\"\n        return self._call('write', auth, [resource, value, options], defer)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef writegroup(self, auth, entries, defer=False):\n        return self._call('writegroup', auth, [entries], defer)", "response": "Writes the given values for the respective resources in the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_stdout(self, filelike):\n        from aiida.orm import CifData\n\n        content = filelike.read().strip()\n\n        if not content:\n            return self.exit_codes.ERROR_EMPTY_OUTPUT_FILE\n\n        try:\n            cifs = {}\n            for line in content.split('\\n'):\n                filename = line.strip()\n                output_name = os.path.splitext(os.path.basename(filename))[0]\n                with self.retrieved.open(filename) as handle:\n                    cifs[output_name] = CifData(file=handle)\n\n        except Exception:  # pylint: disable=broad-except\n            self.logger.exception('Failed to open a generated from the stdout file\\n%s', traceback.format_exc())\n            return self.exit_codes.ERROR_PARSING_OUTPUT_DATA\n\n        self.out('cifs', cifs)\n\n        return", "response": "Parse the content written by the script to standard out."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the content written by the script to standard out.", "response": "def parse_stdout(self, filelike):\n        \"\"\"Parse the content written by the script to standard out.\n\n        :param filelike: filelike object of stdout\n        :returns: an exit code in case of an error, None otherwise\n        \"\"\"\n        from aiida.orm import Dict\n\n        numbers = {}\n        content = filelike.read().strip()\n\n        if not content:\n            return self.exit_codes.ERROR_EMPTY_OUTPUT_FILE\n\n        try:\n            for line in content.split('\\n'):\n                formula, identifier, count, _ = re.split(r'\\s+', line.strip())\n                numbers[identifier] = {'count': int(count), 'formula': formula}\n        except Exception:  # pylint: disable=broad-except\n            self.logger.exception('Failed to parse the numbers from the stdout file\\n%s', traceback.format_exc())\n            return self.exit_codes.ERROR_PARSING_OUTPUT_DATA\n        else:\n            self.out('numbers', Dict(dict=numbers))\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate pressure from 3rd order Birch - Murnathan equation", "response": "def bm3_p(v, v0, k0, k0p, p_ref=0.0):\n    \"\"\"\n    calculate pressure from 3rd order Birch-Murnathan equation\n\n    :param v: volume at different pressures\n    :param v0: volume at reference conditions\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at different conditions\n    :param p_ref: reference pressure (default = 0)\n    :return: pressure\n    \"\"\"\n    return cal_p_bm3(v, [v0, k0, k0p], p_ref=p_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating pressure from 3rd order Birch - Murnaghan equation", "response": "def cal_p_bm3(v, k, p_ref=0.0):\n    \"\"\"\n    calculate pressure from 3rd order Birch-Murnaghan equation\n\n    :param v: volume at different pressures\n    :param k: [v0, k0, k0p]\n    :param p_ref: reference pressure, default = 0.\n    :return: static pressure\n    \"\"\"\n    vvr = v / k[0]\n    p = (p_ref - 0.5 * (3. * k[1] - 5. * p_ref) * (1. - vvr**(-2. / 3.)) +\n         9. / 8. * k[1] * (k[2] - 4. + 35. / 9. * p_ref / k[1]) *\n         (1. - vvr**(-2. / 3.))**2.) * vvr**(-5. / 3.)\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bm3_v(p, v0, k0, k0p, p_ref=0.0, min_strain=0.01):\n    if isuncertainties([p, v0, k0, k0p]):\n        f_u = np.vectorize(uct.wrap(bm3_v_single), excluded=[1, 2, 3, 4, 5])\n        return f_u(p, v0, k0, k0p, p_ref=p_ref, min_strain=min_strain)\n    else:\n        f_v = np.vectorize(bm3_v_single, excluded=[1, 2, 3, 4, 5])\n        return f_v(p, v0, k0, k0p, p_ref=p_ref, min_strain=min_strain)", "response": "find volume at given pressure using brenth in scipy. optimize\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bm3_k(p, v0, k0, k0p):\n    return cal_k_bm3(p, [v0, k0, k0p])", "response": "calculate bulk modulus at high pressure\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating dP / dV for bulk modulus at different conditions", "response": "def bm3_dPdV(v, v0, k0, k0p, precision=1.e-5):\n    \"\"\"\n    calculate dP/dV for numerical calculation of bulk modulus\n    according to test this differs from analytical result by 1.e-5\n\n    :param v: volume\n    :param v0: volume at reference conditions\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at different conditions\n    :param precision: precision for numerical calculation (default = 1.e-5*v0)\n    :return: dP/dV\n    \"\"\"\n    def f_scalar(v, v0, k0, k0p, precision=precision):\n        return derivative(bm3_p, v, args=(v0, k0, k0p), dx=v0 * precision)\n    f_v = np.vectorize(f_scalar, excluded=[1, 2, 3, 4])\n    return f_v(v, v0, k0, k0p, precision=precision)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bm3_k_num(v, v0, k0, k0p, precision=1.e-5):\n    return -1. * v * bm3_dPdV(v, v0, k0, k0p, precision=precision)", "response": "calculate bulk modulus numerically from volume not pressure\n    according to test this differs from analytical result by 1. e - 5"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cal_k_bm3(p, k):\n    v = cal_v_bm3(p, k)\n    return cal_k_bm3_from_v(v, k)", "response": "calculate bulk modulus at high pressure\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating shear modulus at given pressure", "response": "def bm3_g(p, v0, g0, g0p, k0, k0p):\n    \"\"\"\n    calculate shear modulus at given pressure.\n    not fully tested with mdaap.\n\n    :param p: pressure\n    :param v0: volume at reference condition\n    :param g0: shear modulus at reference condition\n    :param g0p: pressure derivative of shear modulus at reference condition\n    :param k0: bulk modulus at reference condition\n    :param k0p: pressure derivative of bulk modulus at reference condition\n    :return: shear modulus at high pressure\n    \"\"\"\n    return cal_g_bm3(p, [g0, g0p], [v0, k0, k0p])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cal_g_bm3(p, g, k):\n    v = cal_v_bm3(p, k)\n    v0 = k[0]\n    k0 = k[1]\n    kp = k[2]\n    g0 = g[0]\n    gp = g[1]\n    f = 0.5 * ((v / v0)**(-2. / 3.) - 1.)\n    return (1. + 2. * f)**(5. / 2.) * (g0 + (3. * k0 * gp - 5. * g0) * f +\n                                       (6. * k0 * gp - 24. * k0 - 14. * g0 +\n                                        9. / 2. * k0 * kp) * f**2.)", "response": "calculate shear modulus at given pressure"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bm3_big_F(p, v, v0):\n    f = bm3_small_f(v, v0)\n    return cal_big_F(p, f)", "response": "calculate big F for linearlized form\n    not fully tested"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef soap_action(self, service, action, payloadbody):\n        payload = self.soapenvelope.format(body=payloadbody).encode('utf-8')\n        headers = {\"Host\": self.url,\n                   \"Content-Type\": \"text/xml; charset=UTF-8\",\n                   \"Cache-Control\": \"no-cache\",\n                   \"Content-Length\": str(len(payload)),\n                   \"SOAPAction\": action}\n        try:\n            response = self.session.post(\n                url=self.url + service, headers=headers, data=payload)\n        except Exception as exp:\n            return False\n        if response.status_code != 200:\n            return False\n        try:\n            xdoc = xml.etree.ElementTree.fromstring(response.text)\n        except xml.etree.ElementTree.ParseError:\n            return False\n        return xdoc", "response": "Do a soap request"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize poolmanager with cipher and Tlsv1", "response": "def init_poolmanager(self, connections, maxsize,\n                         block=requests.adapters.DEFAULT_POOLBLOCK,\n                         **pool_kwargs):\n        \"\"\"Initialize poolmanager with cipher and Tlsv1\"\"\"\n        context = create_urllib3_context(ciphers=self.CIPHERS,\n                                         ssl_version=ssl.PROTOCOL_TLSv1)\n        pool_kwargs['ssl_context'] = context\n        return super(TLSv1Adapter, self).init_poolmanager(connections, maxsize,\n                                                          block, **pool_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures cipher and Tlsv1", "response": "def proxy_manager_for(self, proxy, **proxy_kwargs):\n        \"\"\"Ensure cipher and Tlsv1\"\"\"\n        context = create_urllib3_context(ciphers=self.CIPHERS,\n                                         ssl_version=ssl.PROTOCOL_TLSv1)\n        proxy_kwargs['ssl_context'] = context\n        return super(TLSv1Adapter, self).proxy_manager_for(proxy,\n                                                           **proxy_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the formulae from the content written by the script to standard out.", "response": "def parse_stdout(self, filelike):\n        \"\"\"Parse the formulae from the content written by the script to standard out.\n\n        :param filelike: filelike object of stdout\n        :returns: an exit code in case of an error, None otherwise\n        \"\"\"\n        from aiida.orm import Dict\n\n        formulae = {}\n        content = filelike.read().strip()\n\n        if not content:\n            return self.exit_codes.ERROR_EMPTY_OUTPUT_FILE\n\n        try:\n            for line in content.split('\\n'):\n                datablock, formula = re.split(r'\\s+', line.strip(), 1)\n                formulae[datablock] = formula\n        except Exception:  # pylint: disable=broad-except\n            self.logger.exception('Failed to parse formulae from the stdout file\\n%s', traceback.format_exc())\n            return self.exit_codes.ERROR_PARSING_OUTPUT_DATA\n        else:\n            self.out('formulae', Dict(dict=formulae))\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_features(context, frmat='table', str_maximal=False):\n    config = Config.create(context=context, format=frmat, str_maximal=str_maximal)\n    return FeatureSystem(config)", "response": "Return a new feature system from a context string in the given format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef vinet_p(v, v0, k0, k0p):\n    # unumpy.exp works for both numpy and unumpy\n    # so I set uncertainty default.\n    # if unumpy.exp is used for lmfit, it generates an error\n    return cal_p_vinet(v, [v0, k0, k0p],\n                       uncertainties=isuncertainties([v, v0, k0, k0p]))", "response": "calculate pressure from vinet equation"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding volume at given pressure using brenth in scipy. optimize this is for single p value not vectorized", "response": "def vinet_v_single(p, v0, k0, k0p, min_strain=0.01):\n    \"\"\"\n    find volume at given pressure using brenth in scipy.optimize\n    this is for single p value, not vectorized\n\n    :param p: pressure in GPa\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :param min_strain: defining minimum v/v0 value to search volume for\n    :return: unit cell volume at high pressure in A^3\n    \"\"\"\n    if p <= 1.e-5:\n        return v0\n\n    def f_diff(v, v0, k0, k0p, p):\n        return vinet_p(v, v0, k0, k0p) - p\n    v = brenth(f_diff, v0, v0 * min_strain, args=(v0, k0, k0p, p))\n    return v"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding volume at given pressure :param p: pressure in GPa :param v0: unit-cell volume in A^3 at 1 bar :param k0: bulk modulus at reference conditions :param k0p: pressure derivative of bulk modulus at reference conditions :param min_strain: defining minimum v/v0 value to search volume for :return: unit cell volume at high pressure in A^3 :note: wrapper function vetorizing vinet_v_single", "response": "def vinet_v(p, v0, k0, k0p, min_strain=0.01):\n    \"\"\"\n    find volume at given pressure\n\n    :param p: pressure in GPa\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :param min_strain: defining minimum v/v0 value to search volume for\n    :return: unit cell volume at high pressure in A^3\n    :note: wrapper function vetorizing vinet_v_single\n    \"\"\"\n    if isuncertainties([p, v0, k0, k0p]):\n        f_u = np.vectorize(uct.wrap(vinet_v_single), excluded=[1, 2, 3, 4])\n        return f_u(p, v0, k0, k0p, min_strain=min_strain)\n    else:\n        f_v = np.vectorize(vinet_v_single, excluded=[1, 2, 3, 4])\n        return f_v(p, v0, k0, k0p, min_strain=min_strain)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates bulk modulus at high pressure in a uncertainties", "response": "def vinet_k(p, v0, k0, k0p, numerical=False):\n    \"\"\"\n    calculate bulk modulus, wrapper for cal_k_vinet\n    cannot handle uncertainties\n\n    :param p: pressure in GPa\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :return: bulk modulus at high pressure in GPa\n    \"\"\"\n    f_u = uct.wrap(cal_k_vinet)\n    return f_u(p, [v0, k0, k0p])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate dP / dV for bulk modulus at reference conditions", "response": "def vinet_dPdV(v, v0, k0, k0p, precision=1.e-5):\n    \"\"\"\n    calculate dP/dV for numerical calculation of bulk modulus\n    according to test this differs from analytical result by 1.e-5\n\n    :param v: unit-cell volume in A^3\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param k0: bulk modulus at reference conditions\n    :param k0p: pressure derivative of bulk modulus at reference conditions\n    :param precision: precision for numerical calc (default = 1.e-5 * v0)\n    :return: dP/dV\n    \"\"\"\n    def f_scalar(v, v0, k0, k0p, precision=1.e-5):\n        return derivative(vinet_p, v, args=(v0, k0, k0p), dx=v0 * precision)\n    f_v = np.vectorize(f_scalar, excluded=[1, 2, 3, 4])\n    return f_v(v, v0, k0, k0p, precision=precision)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vinet_k_num(v, v0, k0, k0p, precision=1.e-5):\n    return -1. * v * vinet_dPdV(v, v0, k0, k0p, precision=precision)", "response": "calculate bulk modulus numerically from volume not pressure - based"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cal_k_vinet(p, k):\n    v = cal_v_vinet(p, k)\n    return cal_k_vinet_from_v(v, k[0], k[1], k[2])", "response": "calculate bulk modulus at high pressure in a single node"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cal_k_vinet_from_v(v, v0, k0, k0p):\n    x = v / v0\n    y = np.power(x, 1. / 3.)\n    eta = 1.5 * (k0p - 1.)\n    k = k0 * np.power(y, -2.) * (1. + (eta * y + 1.) * (1. - y)) * \\\n        unp.exp((1. - y) * eta)\n    return k", "response": "calculate bulk modulus at high pressure in A^3"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_portals_list(self):\n        portal_ids = self.get_domain_portal_ids()\n        portals = [ (p, self.get_portal_by_id(p)) for p in portal_ids ]\n        return [ (p[0], p[1]['info']['description']['name'], p) for p in portals ]", "response": "Method to return a list of Portal names with their id s. \n Returns list of tuples as [ id_1 id_2 portal_name1 portal_name2 ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef user_portals_picker(self):\n        # print(\"Getting Portals list. This could take a few seconds...\")\n        portals = self.get_portals_list()\n        done = False\n        while not done:\n            opts = [ (i, p) for i, p in enumerate(portals) ]\n            # print('')\n            for opt, portal in opts:\n                print(\"\\t{0} - {1}\".format(opt, portal[1]))\n            # print('')\n            valid_choices = [o[0] for o in opts]\n            choice = _input(\"Enter choice ({0}): \".format(valid_choices) )\n            if int(choice) in valid_choices:\n                done = True\n\n                # loop through all portals until we find an 'id':'rid' match\n                self.set_portal_name( opts[int(choice)][1][1] )\n                self.set_portal_id( opts[int(choice)][1][0] )\n                # self.set_portal_rid( opts[int(choice)][1][2][1]['info']['key'] )\n                # self.__portal_sn_rid_dict = opts[int(choice)][1][2][1]['info']['aliases']\n\n            else:\n                print(\"'{0}' is not a valid choice. Please choose from {1}\".format(\n                    choice, valid_choices))", "response": "This function is broken and needs to be fixed and discarded. It is broken and needs to be fixed and needs to be discarded."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_portal_by_name(self, portal_name):\n        portals = self.get_portals_list()\n\n        for p in portals:\n            # print(\"Checking {!r}\".format(p))\n            if portal_name == p[1]:\n                # print(\"Found Portal!\")\n                self.set_portal_name( p[1] )\n                self.set_portal_id( p[0] )\n                self.set_portal_cik( p[2][1]['info']['key'] )\n                # print(\"Active Portal Details:\\nName: {0}\\nId: {1}\\nCIK: {2}\".format(\n                #                               self.portal_name(),\n                #                               self.portal_id(),\n                #                               self.portal_cik()))\n                return p\n        return None", "response": "Get the active portal according to the name passed in portal_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef login_to_portal(cls,\n                        domain=None,\n                        portal_name=None,\n                        user=None,\n                        credential=None,\n                        use_token=False,\n                        portal_id=None,\n                        # portal_rid=None,\n                        get_devices=False,\n                        debug=False):\n        \"\"\"\n            A classmethod that returns a (token, Portals object) tuple.\n\n            This method can be interactive based on the input arguments.\n\n            Sets up the Portals object with all the member variables\n            it needs to make future api calls. It basically just calls \n            Portals.get_portal_by_name(), but instead of returning a \n            Portals object, it returns a Portals() object.\n\n            This is a convenience function that can be called at the \n            time of instantiation.\n\n            Instantiate the Portals object with user/password authentication\n            then call this function. The resultant object will be a Portals\n            object that uses token authentication for all future calls \n            instead of using user/password credentials.\n\n            Examples:\n                # for interactive mode, get a password prompt, a token \n                # and a logged-in Portals object\n                token, B = Portals.login_to_portal( domain=<domain>,\n                                                     portal_name=<portal>,\n                                                     user=<user/email>\n                )\n\n                # for non-interactive mode, passing in user password to \n                # get a token and a logged-in Portals object\n                token, B = Portals.login_to_portal( domain=<domain>,\n                                                     portal_name=<portal>,\n                                                     user=<user/email>,\n                                                     credential=<password>\n                )\n\n                # for non-interactive mode, passing in token to get a \n                # logged-in Portals object\n                token, B = Portals.login_to_portal( domain=<domain>,\n                                                     portal_name=<portal>,\n                                                     user=<user/email>,\n                                                     credential=<token>,\n                                                     use_token=True\n                )\n\n                # for non-interactive mode, passing in token and id \n                # to get a Portals object that doesn't need to make any \n                # Portals API calls. \n                token, B = Portals.login_to_portal( domain=<domain>,\n                                                     portal_name=<portal>,\n                                                     user=<user/email>,\n                                                     credential=<token>,\n                                                     use_token=True,\n                                                     portal_id=<portal_id>,\n                                                     portal_rid=<portal_rid>\n                )\n        \"\"\"\n        if domain is None:\n            domain = _input(\"Enter domain: \")\n        if portal_name is None:\n            portal_name = _input(\"Enter name of Portal: \")\n        if user is None:\n            user = _input(\"Enter username: \")\n        if None is credential:\n            # interactive mode\n            B = Portals(   domain=domain,\n                            portal_name=portal_name,\n                            user=user,\n                            debug=debug\n            )\n            token = B.get_user_token()\n            # print(\"Got token {0}\".format(token))\n        elif not None is credential and not use_token:\n            # non-interactive, using a user-password to retrieve token\n            B = Portals(   domain=domain,\n                            portal_name=portal_name,\n                            user=user,\n                            auth=credential,\n                            debug=debug\n            )\n            token = B.get_user_token()\n        elif not None is credential and use_token:\n            # non-interactive, mainly just need to instantiate an object.\n            B = Portals(   domain=domain,\n                            portal_name=portal_name,\n                            user=user,\n                            auth=credential,\n                            use_token=use_token,\n                            debug=debug\n            )\n            token = credential\n\n        if portal_id is None: # or portal_rid is None:\n            B.get_portal_by_name(B.portal_name())\n        else:\n            B.set_portal_id(portal_id)\n            # B.set_portal_rid(portal_rid)\n        if get_devices:\n            B.map_aliases_to_device_objects()\n        return token, B", "response": "This classmethod is used to login to a portal object. It returns a tuple that is used to create a new object and return it."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_device_with_name_location_timezone( self,\n                                                model,\n                                                serial,\n                                                name,\n                                                location,\n                                                timezone):\n        \"\"\"\n            This method wraps the self.add_device() and self.rename_device()\n            methods.\n            \n            Returns device object.\n        \"\"\"\n        retval = None\n        retval = self.add_location_timezone_to_device(\n                    self.rename_device(\n                        self.add_device(\n                            model,\n                            serial),\n                        name\n                    ),\n                    location,\n                    timezone\n        )\n        return retval", "response": "This method adds a new device with the specified name location and timezone."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds location and timezone to a device object.", "response": "def add_location_timezone_to_device(self, device_obj, location, timezone):\n        \"\"\"\n            Returns 'device object' with updated location\n            \n            http://docs.exosite.com/portals/#update-device\n            http://docs.exosite.com/portals/#device-object\n        \"\"\"\n        dictify_device_meta(device_obj)\n        device_obj['info']['description']['meta']['location'] = location\n        device_obj['info']['description']['meta']['Location'] = location\n        device_obj['info']['description']['meta']['timezone'] = timezone\n        device_obj['info']['description']['meta']['Timezone'] = timezone\n        return self.update_device(device_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_device(self, rid):\n        headers = {\n                'User-Agent': self.user_agent(),\n                'Content-Type': self.content_type()\n            }\n        headers.update(self.headers())\n        r = requests.delete(    self.portals_url()+'/devices/'+rid, \n                                headers=headers,\n                                auth=self.auth())\n        if HTTP_STATUS.NO_CONTENT == r.status_code:\n            print(\"Successfully deleted device with rid: {0}\".format(rid))\n            return True\n        else:\n            print(\"Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            r.raise_for_status()\n            return False", "response": "Deletes a device object with given rid"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_device_data_sources(self, device_rid):\n        headers = {\n                'User-Agent': self.user_agent(),\n        }\n        headers.update(self.headers())\n\n        r = requests.get(   self.portals_url()+'/devices/'+device_rid+'/data-sources', \n                    headers=headers, auth=self.auth())\n        if HTTP_STATUS.OK == r.status_code:\n            return r.json()\n        else:\n            print(\"Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            return None", "response": "List data sources of a portal device with rid device_rid."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for all devices in portal that match the serial number sn.", "response": "def search_for_devices_by_serial_number(self, sn):\n        \"\"\"\n            Returns a list of device objects that match the serial number\n            in param 'sn'.\n\n            This will match partial serial numbers.\n        \"\"\"\n        import re\n\n        sn_search = re.compile(sn)\n\n        matches = []\n        for dev_o in self.get_all_devices_in_portal():\n            # print(\"Checking {0}\".format(dev_o['sn']))\n            try:\n                if sn_search.match(dev_o['sn']):\n\n                    matches.append(dev_o)\n            except TypeError as err:\n                print(\"Problem checking device {!r}: {!r}\".format(\n                                    dev_o['info']['description']['name'],\n                                    str(err)))\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint the list of portal devices objects.", "response": "def print_device_list(self, device_list=None):\n        \"\"\"\n            Optional parameter is a list of device objects. If omitted, will\n            just print all portal devices objects.\n        \"\"\"\n        dev_list = device_list if device_list is not None else self.get_all_devices_in_portal()\n\n        for dev in dev_list:\n            print('{0}\\t\\t{1}\\t\\t{2}'.format(\n                    dev['info']['description']['name'],\n                    dev['sn'],\n                    dev['portals_aliases']\\\n                        if len(dev['portals_aliases']) != 1\n                        else dev['portals_aliases'][0]\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_sorted_device_list(self, device_list=None, sort_key='sn'):\n        dev_list = device_list if device_list is not None else self.get_all_devices_in_portal()\n        sorted_dev_list = []\n        if sort_key == 'sn':\n            sort_keys = [ k[sort_key] for k in dev_list if k[sort_key] is not None ]\n            sort_keys = sorted(sort_keys)\n            for key in sort_keys:\n                sorted_dev_list.extend([ d for d in dev_list if d['sn'] == key ])\n\n        elif sort_key == 'name':\n            sort_keys = [ k['info']['description'][sort_key]\\\n                    for k in dev_list if k['info']['description'][sort_key] is not None ]\n            sort_keys = sorted(sort_keys)\n            for key in sort_keys:\n                sorted_dev_list.extend( [ d for d in dev_list\\\n                                            if d['info']['description'][sort_key] == key\n                                        ]\n                )\n\n        elif sort_key == 'portals_aliases':\n            sort_keys = [ k[sort_key] for k in dev_list if k[sort_key] is not None ]\n            sort_keys = sorted(sort_keys)\n            for key in sort_keys:\n                sorted_dev_list.extend([ d for d in dev_list if d[sort_key] == key ])\n\n        else:\n            print(\"Sort key {!r} not recognized.\".format(sort_key))\n            sort_keys = None\n\n        self.print_device_list(device_list=sorted_dev_list)", "response": "Print the list of all the devices in the portal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_user_id_from_email(self, email):\n        accts = self.get_all_user_accounts()\n\n        for acct in accts:\n            if acct['email'] == email:\n                return acct['id']\n        return None", "response": "Returns the user - id of the user with the given email address."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user_permission_from_email(self, email):\n        _id = self.get_user_id_from_email(email)\n        return self.get_user_permission(_id)", "response": "Returns a user s permissions object when given the user email."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the d_p_list permission to a user object when provided a user_email and portal_id.", "response": "def add_dplist_permission_for_user_on_portal(self, user_email, portal_id):\n        \"\"\" Adds the 'd_p_list' permission to a user object when provided\n            a user_email and portal_id.\"\"\"\n        _id = self.get_user_id_from_email(user_email)\n        print(self.get_user_permission_from_email(user_email))\n        retval = self.add_user_permission(  _id, json.dumps( \n                        [{'access': 'd_p_list', 'oid':{'id': portal_id, 'type':'Portal'}}] \n                )\n        )\n        print(self.get_user_permission_from_email(user_email))\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_portal_cik(self, portal_name):\n        portal = self.get_portal_by_name(portal_name)\n        cik = portal[2][1]['info']['key']\n        return cik", "response": "Returns the portal object according to portal_name and\n        returns its cik."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_write_index(es_write, es_write_index):\n    logging.info(\"Initializing index: \" + es_write_index)\n    es_write.indices.delete(es_write_index, ignore=[400, 404])\n    es_write.indices.create(es_write_index, body=MAPPING_GIT)", "response": "Initializes ES write index"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure logging for the current node.", "response": "def configure_logging(info=False, debug=False):\n    \"\"\"Configure logging\n    The function configures log messages. By default, log messages\n    are sent to stderr. Set the parameter `debug` to activate the\n    debug mode.\n    :param debug: set the debug mode\n    \"\"\"\n    if info:\n        logging.basicConfig(level=logging.INFO,\n                            format=LOG_FORMAT)\n        logging.getLogger('requests').setLevel(logging.WARNING)\n        logging.getLogger('urrlib3').setLevel(logging.WARNING)\n        logging.getLogger('elasticsearch').setLevel(logging.WARNING)\n    elif debug:\n        logging.basicConfig(level=logging.DEBUG,\n                            format=DEBUG_LOG_FORMAT)\n    else:\n        logging.basicConfig(level=logging.WARNING,\n                            format=LOG_FORMAT)\n        logging.getLogger('requests').setLevel(logging.WARNING)\n        logging.getLogger('urrlib3').setLevel(logging.WARNING)\n        logging.getLogger('elasticsearch').setLevel(logging.WARNING)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enrich(self, column, projects):\n\n        if column not in self.data.columns:\n            return self.data\n\n        self.data = pandas.merge(self.data, projects, how='left', on=column)\n\n        return self.data", "response": "This method adds a new column named as project where the associated project is associated with the item with the event in column."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __parse_flags(self, body):\n        flags = []\n        values = []\n        lines = body.split('\\n')\n        for l in lines:\n            for name in self.FLAGS_REGEX:\n                m = re.match(self.FLAGS_REGEX[name], l)\n\n                if m:\n                    flags.append(name)\n                    values.append(m.group(\"value\").strip())\n\n        if flags == []:\n            flags = \"\"\n            values = \"\"\n\n        return flags, values", "response": "Parse flags from a message body"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enrich(self, column):\n\n        if column not in self.data.columns:\n            return self.data\n\n        self.data['domain'] = self.data[column].apply(lambda x: self.__parse_email(x))\n        return self.data", "response": "This function returns the same dataframe with a new column named domain."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves surrogates in the specified string s", "response": "def __remove_surrogates(self, s, method='replace'):\n        \"\"\" Remove surrogates in the specified string\n        \"\"\"\n\n        if type(s) == list and len(s) == 1:\n            if self.__is_surrogate_escaped(s[0]):\n                return s[0].encode('utf-8', method).decode('utf-8')\n            else:\n                return \"\"\n        if type(s) == list:\n            return \"\"\n        if type(s) != str:\n            return \"\"\n        if self.__is_surrogate_escaped(s):\n            return s.encode('utf-8', method).decode('utf-8')\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if surrogate is escaped", "response": "def __is_surrogate_escaped(self, text):\n        \"\"\" Checks if surrogate is escaped\n        \"\"\"\n\n        try:\n            text.encode('utf-8')\n        except UnicodeEncodeError as e:\n            if e.reason == 'surrogates not allowed':\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse an email address and return the first and last entry in the list.", "response": "def __parse_addr(self, addr):\n        \"\"\" Parse email addresses\n        \"\"\"\n\n        from email.utils import parseaddr\n\n        value = parseaddr(addr)\n        return value[0], value[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enrich(self, column):\n\n        if column not in self.data.columns:\n            return self.data\n\n        self.data[\"user\"], self.data[\"email\"] = zip(*self.data[column].map(self.__parse_addr))\n\n        return self.data", "response": "This method creates two new columns user and email."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enrich(self, column1, column2):\n\n        if column1 not in self.data.columns or \\\n           column2 not in self.data.columns:\n            return self.data\n\n        self.data[\"timedifference\"] = (self.data[column2] - self.data[column1]) / np.timedelta64(1, 's')\n        return self.data", "response": "This method adds the difference in seconds between column1 and column2 to the dataframe."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef enrich(self, columns):\n\n        for column in columns:\n            if column not in self.data.columns:\n                return self.data\n\n        self.data = pandas.merge(self.data, self.uuids_df, how='left', on=columns)\n        self.data = self.data.fillna(\"notavailable\")\n\n        return self.data", "response": "Merges the original dataframe with corresponding entity uuids based on the given columns."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef enrich(self, member_column, events_column):\n\n        if member_column not in self.data.columns or \\\n           events_column not in self.data.columns:\n            return self.data\n\n        # Order the data... just in case\n        self.data.sort_values(by=events_column, ascending=False, inplace=True)\n        # Reset the index to properly work with other methods\n        self.data.reset_index(inplace=True)\n        # Remove resultant new 'index' column\n        self.data.drop([\"index\"], axis=1, inplace=True)\n\n        # Calculate onion limits and accumulative sum and percentage\n        self.data[\"cum_net_sum\"] = self.data[events_column].cumsum()\n        self.data[\"percent_cum_net_sum\"] = (self.data.cum_net_sum/self.data[events_column].sum())*100\n\n        # Assign roles based on the percentage\n        self.data[\"onion_role\"] = pandas.cut(self.data[\"percent_cum_net_sum\"],\n                                               [0.0, 80.0, 95.0, 100.0],\n                                               labels=[\"core\", \"regular\", \"casual\"])\n\n        return self.data", "response": "This method calculates the onion model for the given set of columns."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\necho the string to standard out prefixed with the current date and time in UTC format.", "response": "def echo_utc(string):\n    \"\"\"Echo the string to standard out, prefixed with the current date and time in UTC format.\n\n    :param string: string to echo\n    \"\"\"\n    from datetime import datetime\n    click.echo('{} | {}'.format(datetime.utcnow().isoformat(), string))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a single string representing all command line parameters.", "response": "def from_string(cls, string):\n        \"\"\"Parse a single string representing all command line parameters.\"\"\"\n        if string is None:\n            string = ''\n\n        if not isinstance(string, six.string_types):\n            raise TypeError('string has to be a string type, got: {}'.format(type(string)))\n\n        dictionary = {}\n        tokens = [token.strip() for token in shlex.split(string)]\n\n        def list_tuples(some_iterable):\n            items, nexts = itertools.tee(some_iterable, 2)\n            nexts = itertools.chain(itertools.islice(nexts, 1, None), [None])\n            return list(zip(items, nexts))\n\n        for token_current, token_next in list_tuples(tokens):\n\n            # If current token starts with a dash, it is a value so we skip it\n            if not token_current.startswith('-'):\n                continue\n\n            # If the next token is None or starts with a dash, the current token must be a flag, so the value is True\n            if not token_next or token_next.startswith('-'):\n                dictionary[token_current.lstrip('-')] = True\n\n            # Otherwise the current token is an option with the next token being its value\n            else:\n                dictionary[token_current.lstrip('-')] = token_next\n\n        return cls.from_dictionary(dictionary)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a dictionary representing all command line parameters.", "response": "def from_dictionary(cls, dictionary):\n        \"\"\"Parse a dictionary representing all command line parameters.\"\"\"\n        if not isinstance(dictionary, dict):\n            raise TypeError('dictionary has to be a dict type, got: {}'.format(type(dictionary)))\n\n        return cls(dictionary)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the command line parameters as a list of options their values and arguments.", "response": "def get_list(self):\n        \"\"\"Return the command line parameters as a list of options, their values and arguments.\n\n        :return: list of options, their optional values and arguments\n        \"\"\"\n        result = []\n\n        for key, value in self.parameters.items():\n\n            if value is None:\n                continue\n\n            if not isinstance(value, list):\n                value = [value]\n\n            if len(key) == 1:\n                string_key = '-{}'.format(key)\n            else:\n                string_key = '--{}'.format(key)\n\n            for sub_value in value:\n\n                if isinstance(sub_value, bool) and sub_value is False:\n                    continue\n\n                result.append(string_key)\n\n                if not isinstance(sub_value, bool):\n                    if ' ' in sub_value:\n                        string_value = \"'{}'\".format(sub_value)\n                    else:\n                        string_value = sub_value\n\n                    result.append(str(string_value))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, daemon=False):\n        from aiida.engine import launch\n\n        # If daemon is True, submit the process and return\n        if daemon:\n            node = launch.submit(self.process, **self.inputs)\n            echo.echo_info('Submitted {}<{}>'.format(self.process_name, node.pk))\n            return\n\n        # Otherwise we run locally and wait for the process to finish\n        echo.echo_info('Running {}'.format(self.process_name))\n        try:\n            _, node = launch.run_get_node(self.process, **self.inputs)\n        except Exception as exception:  # pylint: disable=broad-except\n            echo.echo_critical('an exception occurred during execution: {}'.format(str(exception)))\n\n        if node.is_killed:\n            echo.echo_critical('{}<{}> was killed'.format(self.process_name, node.pk))\n        elif not node.is_finished_ok:\n            arguments = [self.process_name, node.pk, node.exit_status, node.exit_message]\n            echo.echo_warning('{}<{}> failed with exit status {}: {}'.format(*arguments))\n        else:\n            output = []\n            echo.echo_success('{}<{}> finished successfully\\n'.format(self.process_name, node.pk))\n            for triple in sorted(node.get_outgoing().all(), key=lambda triple: triple.link_label):\n                output.append([triple.link_label, '{}<{}>'.format(triple.node.__class__.__name__, triple.node.pk)])\n            echo.echo(tabulate.tabulate(output, headers=['Output label', 'Node']))", "response": "Launch the process with the given inputs by default running in the current interpreter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _xpathDict(xml, xpath, cls, parent, **kwargs):\n    children = []\n    for child in xml.xpath(xpath, namespaces=XPATH_NAMESPACES):\n        children.append(cls.parse(\n            resource=child,\n            parent=parent,\n            **kwargs\n        ))\n    return children", "response": "Returns a default Dict given certain information."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse an XML object for structured metadata.", "response": "def _parse_structured_metadata(obj, xml):\n    \"\"\" Parse an XML object for structured metadata\n\n    :param obj: Object whose metadata are parsed\n    :param xml: XML that needs to be parsed\n    \"\"\"\n    for metadata in xml.xpath(\"cpt:structured-metadata/*\", namespaces=XPATH_NAMESPACES):\n        tag = metadata.tag\n        if \"{\" in tag:\n            ns, tag = tuple(tag.split(\"}\"))\n            tag = URIRef(ns[1:]+tag)\n            s_m = str(metadata)\n            if s_m.startswith(\"urn:\") or s_m.startswith(\"http:\") or s_m.startswith(\"https:\") or s_m.startswith(\"hdl:\"):\n                obj.metadata.add(\n                    tag,\n                    URIRef(metadata)\n                )\n            elif '{http://www.w3.org/XML/1998/namespace}lang' in metadata.attrib:\n                obj.metadata.add(\n                    tag,\n                    s_m,\n                    lang=metadata.attrib['{http://www.w3.org/XML/1998/namespace}lang']\n                )\n            else:\n                if \"{http://www.w3.org/1999/02/22-rdf-syntax-ns#}datatype\" in metadata.attrib:\n                    datatype = metadata.attrib[\"{http://www.w3.org/1999/02/22-rdf-syntax-ns#}datatype\"]\n                    if not datatype.startswith(\"http\") and \":\" in datatype:\n                        datatype = expand_namespace(metadata.nsmap, datatype)\n                    obj.metadata.add(tag, Literal(s_m, datatype=URIRef(datatype)))\n                elif isinstance(metadata, IntElement):\n                    obj.metadata.add(tag, Literal(int(metadata), datatype=XSD.integer))\n                elif isinstance(metadata, FloatElement):\n                    obj.metadata.add(tag, Literal(float(metadata), datatype=XSD.float))\n                else:\n                    obj.metadata.add(tag, s_m)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ingest(cls, resource, element=None, xpath=\"ti:citation\"):\n        # Reuse of of find citation\n        results = resource.xpath(xpath, namespaces=XPATH_NAMESPACES)\n        if len(results) > 0:\n            citation = cls(\n                name=results[0].get(\"label\"),\n                xpath=results[0].get(\"xpath\"),\n                scope=results[0].get(\"scope\")\n            )\n\n            if isinstance(element, cls):\n                element.child = citation\n                cls.ingest(\n                    resource=results[0],\n                    element=element.child\n                )\n            else:\n                element = citation\n                cls.ingest(\n                    resource=results[0],\n                    element=element\n                )\n\n            return citation\n\n        return None", "response": "Ingest xml to create a citation"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_metadata(cls, obj, xml):\n\n        for child in xml.xpath(\"ti:description\", namespaces=XPATH_NAMESPACES):\n            lg = child.get(\"{http://www.w3.org/XML/1998/namespace}lang\")\n            if lg is not None:\n                obj.set_cts_property(\"description\", child.text, lg)\n\n        for child in xml.xpath(\"ti:label\", namespaces=XPATH_NAMESPACES):\n            lg = child.get(\"{http://www.w3.org/XML/1998/namespace}lang\")\n            if lg is not None:\n                obj.set_cts_property(\"label\", child.text, lg)\n\n        obj.citation = cls.CLASS_CITATION.ingest(xml, obj.citation, \"ti:online/ti:citationMapping/ti:citation\")\n\n        # Added for commentary\n        for child in xml.xpath(\"ti:about\", namespaces=XPATH_NAMESPACES):\n            obj.set_link(RDF_NAMESPACES.CTS.term(\"about\"), child.get('urn'))\n\n        _parse_structured_metadata(obj, xml)\n\n        \"\"\"\n        online = xml.xpath(\"ti:online\", namespaces=NS)\n        if len(online) > 0:\n            online = online[0]\n            obj.docname = online.get(\"docname\")\n            for validate in online.xpath(\"ti:validate\", namespaces=NS):\n                obj.validate = validate.get(\"schema\")\n            for namespaceMapping in online.xpath(\"ti:namespaceMapping\", namespaces=NS):\n                obj.metadata[\"namespaceMapping\"][namespaceMapping.get(\"abbreviation\")] = namespaceMapping.get(\"nsURI\")\n        \"\"\"", "response": "Parse a resource to feed the object containing the metadata."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a resource element and return a new object with the properties set to the properties of the object.", "response": "def parse(cls, resource, parent=None, _with_children=False):\n        \"\"\" Parse a resource\n\n        :param resource: Element rerpresenting a work\n        :param type: basestring, etree._Element\n        :param parent: Parent of the object\n        :type parent: XmlCtsTextgroupMetadata\n        :param _cls_dict: Dictionary of classes to generate subclasses\n        \"\"\"\n        xml = xmlparser(resource)\n        o = cls(urn=xml.get(\"urn\"), parent=parent)\n\n        lang = xml.get(\"{http://www.w3.org/XML/1998/namespace}lang\")\n        if lang is not None:\n            o.lang = lang\n\n        for child in xml.xpath(\"ti:title\", namespaces=XPATH_NAMESPACES):\n            lg = child.get(\"{http://www.w3.org/XML/1998/namespace}lang\")\n            if lg is not None:\n                o.set_cts_property(\"title\", child.text, lg)\n\n        # Parse children\n        children = []\n        children.extend(_xpathDict(\n            xml=xml, xpath='ti:edition',\n            cls=cls.CLASS_EDITION, parent=o\n        ))\n        children.extend(_xpathDict(\n            xml=xml, xpath='ti:translation',\n            cls=cls.CLASS_TRANSLATION, parent=o\n        ))\n        children.extend(_xpathDict(\n            xml=xml, xpath='ti:commentary',\n            cls=cls.CLASS_COMMENTARY, parent=o\n        ))\n\n        _parse_structured_metadata(o, xml)\n\n        if _with_children:\n            return o, children\n        return o"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a textgroup resource and return a new object containing all the classes that are derived from the resource.", "response": "def parse(cls, resource, parent=None):\n        \"\"\" Parse a textgroup resource\n\n        :param resource: Element representing the textgroup\n        :param parent: Parent of the textgroup\n        :param _cls_dict: Dictionary of classes to generate subclasses\n        \"\"\"\n        xml = xmlparser(resource)\n        o = cls(urn=xml.get(\"urn\"), parent=parent)\n\n        for child in xml.xpath(\"ti:groupname\", namespaces=XPATH_NAMESPACES):\n            lg = child.get(\"{http://www.w3.org/XML/1998/namespace}lang\")\n            if lg is not None:\n                o.set_cts_property(\"groupname\", child.text, lg)\n\n        # Parse Works\n        _xpathDict(xml=xml, xpath='ti:work', cls=cls.CLASS_WORK, parent=o)\n\n        _parse_structured_metadata(o, xml)\n        return o"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a resource containing the text inventory and return a new object.", "response": "def parse(cls, resource):\n        \"\"\" Parse a resource\n\n        :param resource: Element representing the text inventory\n        :param _cls_dict: Dictionary of classes to generate subclasses\n        \"\"\"\n        xml = xmlparser(resource)\n        o = cls(name=xml.xpath(\"//ti:TextInventory\", namespaces=XPATH_NAMESPACES)[0].get(\"tiid\") or \"\")\n        # Parse textgroups\n        _xpathDict(xml=xml, xpath='//ti:textgroup', cls=cls.CLASS_TEXTGROUP, parent=o)\n        return o"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites the content of buf in a hexdump style.", "response": "def write_hex(fout, buf, offset, width=16):\n    \"\"\"Write the content of 'buf' out in a hexdump style\n\n    Args:\n        fout: file object to write to\n        buf: the buffer to be pretty printed\n        offset: the starting offset of the buffer\n        width: how many bytes should be displayed per row\n    \"\"\"\n\n    skipped_zeroes = 0\n    for i, chunk in enumerate(chunk_iter(buf, width)):\n        # zero skipping\n        if chunk == (b\"\\x00\" * width):\n            skipped_zeroes += 1\n            continue\n        elif skipped_zeroes != 0:\n            fout.write(\"  -- skipped zeroes: {}\\n\".format(skipped_zeroes))\n            skipped_zeroes = 0\n\n        # starting address of the current line\n        fout.write(\"{:016x}  \".format(i * width + offset))\n\n        # bytes column\n        column = \"  \".join([\" \".join([\"{:02x}\".format(c) for c in subchunk])\n                            for subchunk in chunk_iter(chunk, 8)])\n        w = width * 2 + (width - 1) + ((width // 8) - 1)\n        if len(column) != w:\n            column += \" \" * (w - len(column))\n        fout.write(column)\n\n        # ASCII character column\n        fout.write(\"  |\")\n        for c in chunk:\n            if c in PRINTABLE_CHARS:\n                fout.write(chr(c))\n            else:\n                fout.write(\".\")\n        if len(chunk) < width:\n            fout.write(\" \" * (width - len(chunk)))\n        fout.write(\"|\")\n\n        fout.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef edit_ini(ini_filepath=None):\n    if ini_filepath == None:\n        ini_filepath = get_ini_filepath()\n\n    try:\n        click.edit(filename=ini_filepath)\n    except click.exceptions.ClickException as err:\n        print(\"Click err: %s\" % err)\n        webbrowser.open(ini_filepath)", "response": "Open the. ini file with the operating system s associated editor."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads and convert the ini file.", "response": "def _read_and_convert(self, filepath, all_values):\n        \"\"\"\n        if all_values==True: the readed ini file must contain all values\n        \"\"\"\n        d = get_dict_from_ini(filepath)\n        result = {}\n        for key, func in self.ini_converter_dict.items():\n            if not all_values and key not in d:\n                continue\n\n            try:\n                value = d[key]\n            except KeyError as err:\n                traceback.print_exc()\n                print(\"_\" * 79)\n                print(\"ERROR: %r is missing in your config!\" % err)\n                print(\"Debug '%s':\" % filepath)\n                try:\n                    print(pprint.pformat(d))\n                except KeyError:\n                    pass\n                print(\"\\n\")\n                if click.confirm(\"Open the editor?\"):\n                    self.open_editor()\n                sys.exit(-1)\n\n            if func:\n                try:\n                    value = func(value)\n                except (KeyError, ValueError) as err:\n                    edit_ini(self.ini_filepath)\n                    raise Exception(\"%s - .ini file: '%s'\" % (err, self.ini_filepath))\n\n            result[key] = value\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the config file and returns the config as a dict.", "response": "def _read_config(self):\n        \"\"\"\n        returns the config as a dict.\n        \"\"\"\n        default_config_filepath = Path2(os.path.dirname(__file__), DEAFULT_CONFIG_FILENAME)\n        log.debug(\"Read defaults from: '%s'\" % default_config_filepath)\n        if not default_config_filepath.is_file():\n            raise RuntimeError(\n                \"Internal error: Can't locate the default .ini file here: '%s'\" % default_config_filepath\n            )\n        config = self._read_and_convert(default_config_filepath, all_values=True)\n        log.debug(\"Defaults: %s\", pprint.pformat(config))\n\n        self.ini_filepath = get_ini_filepath()\n        if not self.ini_filepath:\n            # No .ini file made by user found\n            # -> Create one into user home\n            self.ini_filepath = get_user_ini_filepath()\n\n            # We don't use shutil.copyfile here, so the line endings will\n            # be converted e.g. under windows from \\n to \\n\\r\n            with default_config_filepath.open(\"r\") as infile:\n                with self.ini_filepath.open(\"w\") as outfile:\n                    outfile.write(infile.read())\n\n            print(\"\\n*************************************************************\")\n            print(\"Default config file was created into your home:\")\n            print(\"\\t%s\" % self.ini_filepath)\n            print(\"Change it for your needs ;)\")\n            print(\"*************************************************************\\n\")\n        else:\n            print(\"\\nread user configuration from:\")\n            print(\"\\t%s\\n\" % self.ini_filepath)\n            config.update(self._read_and_convert(self.ini_filepath, all_values=False))\n            log.debug(\"RawConfig changed to: %s\", pprint.pformat(config))\n\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef patch(filepath, debug):\n    print(\"patch 'pause' in %r\" % filepath)\n    with open(filepath, \"r\") as infile:\n        origin_content = infile.read()\n\n    new_content = origin_content.replace(\"pause\\n\", \"\"\"echo \"'pause'\"\\n\"\"\")\n    assert new_content!=origin_content, \"not changed: %s\" % origin_content\n\n    with open(filepath, \"w\") as outfile:\n        outfile.write(new_content)\n\n    print(\"%r patched\" % filepath)\n    if debug:\n        print(\"-\"*79)\n        print(repr(new_content))\n        print(\"-\"*79)\n        print(new_content)\n        print(\"-\"*79)", "response": "patch the file at filepath with the new content"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbinding a graph with generic MyCapytain prefixes", "response": "def bind_graph(graph=None):\n    \"\"\" Bind a graph with generic MyCapytain prefixes\n\n    :param graph: Graph (Optional)\n    :return: Bound graph\n    \"\"\"\n    if graph is None:\n        graph = Graph()\n    for prefix, ns in GRAPH_BINDINGS.items():\n        graph.bind(prefix, ns, True)\n    return graph"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nasks the user for yes or no ; ask again until user answers a valid option.", "response": "def yes_no_query(question):\n    \"\"\"Ask the user *question* for 'yes' or 'no'; ask again until user\n    inputs a valid option.\n\n    Returns:\n    'True' if user answered 'y', 'yes', 't', 'true', 'on' or '1'.\n    'False' if user answered 'n', 'no', 'f', 'false', 'off' or '0'.\n    \"\"\"\n\n    print(\"{} (y/n)\".format(question), end=\" \"),\n    while True:\n        try:\n            return strtobool(input().lower())\n        except ValueError:\n            print(\"Please respond with 'y' or 'n'.\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if file *dest* exists. If True asks if the user wants to overwrite it. If False exit the program.", "response": "def ask_overwrite(dest):\n    \"\"\"Check if file *dest* exists. If 'True', asks if the user wants\n    to overwrite it (just remove the file for later overwrite).\n    \"\"\"\n\n    msg = \"File '{}' already exists. Overwrite file?\".format(dest)\n    if os.path.exists(dest):\n        if yes_no_query(msg):\n            os.remove(dest)\n        else:\n            sys.exit(\"Cancelling operation...\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating electronic contributions in pressure for Zharkov equation", "response": "def zharkov_pel(v, temp, v0, e0, g, n, z, t_ref=300.,\n                three_r=3. * constants.R):\n    \"\"\"\n    calculate electronic contributions in pressure for the Zharkov equation\n    the equation can be found in Sokolova and Dorogokupets 2013\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature in K\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param e0: parameter in K-1 for the Zharkov equation\n    :param g: parameter for the Zharkov equation\n    :param n: number of atoms in a formula unit\n    :param z: number of formula unit in a unit cell\n    :param t_ref: reference temperature, 300 K\n    :param three_r: 3 times gas constant\n    :return: electronic contribution in GPa\n    \"\"\"\n    v_mol = vol_uc2mol(v, z)\n    x = v / v0\n#    a = a0 * np.power(x, m)\n\n    def f(t):\n        return three_r * n / 2. * e0 * np.power(x, g) * np.power(t, 2.) * \\\n            g / v_mol * 1.e-9\n    return f(temp) - f(t_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tsuchiya_pel(v, temp, v0, a, b, c, d, n, z, three_r=3. * constants.R,\n                 t_ref=300.):\n    \"\"\"\n    calculate electronic contributions in pressure for the Tsuchiya equation\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature in K\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param a: parameter for the Tsuchiya equation\n    :param b: parameter for the Tsuchiya equation\n    :param c: parameter for the Tsuchiya equation\n    :param d: parameter for the Tsuchiya equation\n    :param n: number of atoms in a formula unit\n    :param z: number of formula unit in a unit cell\n    :param t_ref: reference temperature, 300 K\n    :param three_r: 3 times gas constant\n    :return: electronic contribution in GPa\n    :note: n, z, three_r are not used but in there for consistency\n        with other electronic contribution equations\n    \"\"\"\n    def f(temp):\n        return a + b * temp + c * np.power(temp, 2.) + d * np.power(temp, 3.)\n    return f(temp) - f(t_ref)", "response": "calculate electronic contributions in pressure for the Tsuchiya equation"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_resources(self):\n        resources = self.options.resources\n\n        for key in ['num_machines', 'num_mpiprocs_per_machine', 'tot_num_mpiprocs']:\n            if key in resources and resources[key] != 1:\n                raise exceptions.FeatureNotAvailable(\n                    \"Cannot set resource '{}' to value '{}' for {}: parallelization is not supported, \"\n                    \"only a value of '1' is accepted.\".format(key, resources[key], self.__class__.__name__))", "response": "Validate the resources defined in the options."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prepare_for_submission(self, folder):\n        from aiida_codtools.common.cli import CliParameters\n\n        try:\n            parameters = self.inputs.parameters.get_dict()\n        except AttributeError:\n            parameters = {}\n\n        self._validate_resources()\n\n        cli_parameters = copy.deepcopy(self._default_cli_parameters)\n        cli_parameters.update(parameters)\n\n        codeinfo = datastructures.CodeInfo()\n        codeinfo.code_uuid = self.inputs.code.uuid\n        codeinfo.cmdline_params = CliParameters.from_dictionary(cli_parameters).get_list()\n        codeinfo.stdin_name = self.options.input_filename\n        codeinfo.stdout_name = self.options.output_filename\n        codeinfo.stderr_name = self.options.error_filename\n\n        calcinfo = datastructures.CalcInfo()\n        calcinfo.uuid = str(self.uuid)\n        calcinfo.codes_info = [codeinfo]\n        calcinfo.retrieve_list = [self.options.output_filename, self.options.error_filename]\n        calcinfo.local_copy_list = [(self.inputs.cif.uuid, self.inputs.cif.filename, self.options.input_filename)]\n        calcinfo.remote_copy_list = []\n\n        return calcinfo", "response": "This method is called before the job submission with a set of calculation input nodes. This method is called before the job submission with a set of calculation input nodes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate pressure along a Hugoniot", "response": "def hugoniot_p(rho, rho0, c0, s):\n    \"\"\"\n    calculate pressure along a Hugoniot\n\n    :param rho: density in g/cm^3\n    :param rho0: density at 1 bar in g/cm^3\n    :param c0: velocity at 1 bar in km/s\n    :param s: slope of the velocity change\n    :return: pressure in GPa\n    \"\"\"\n    eta = 1. - (rho0 / rho)\n    Ph = rho0 * c0 * c0 * eta / np.power((1. - s * eta), 2.)\n    return Ph"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hugoniot_t(rho, rho0, c0, s, gamma0, q, theta0, n, mass,\n               three_r=3. * constants.R, t_ref=300., c_v=0.):\n    \"\"\"\n    calculate temperature along a hugoniot\n\n    :param rho: density in g/cm^3\n    :param rho0: density at 1 bar in g/cm^3\n    :param c0: velocity at 1 bar in km/s\n    :param s: slope of the velocity change\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param q: logarithmic derivative of Gruneisen parameter\n    :param theta0: Debye temperature in K\n    :param n: number of elements in a chemical formula\n    :param mass: molar mass in gram\n    :param three_r: 3 times gas constant.\n        Jamieson modified this value to compensate for mismatches\n    :param t_ref: reference temperature, 300 K\n    :param c_v: heat capacity, see Jamieson 1983 for detail\n    :return: temperature along hugoniot\n    \"\"\"\n    if isuncertainties([rho, rho0, c0, s, gamma0, q, theta0]):\n        f_v = np.vectorize(uct.wrap(hugoniot_t_single),\n                           excluded=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    else:\n        f_v = np.vectorize(hugoniot_t_single, excluded=[1, 2, 3, 4, 5, 6,\n                                                        7, 8, 9, 10, 11])\n    return f_v(rho, rho0, c0, s, gamma0, q, theta0, n, mass,\n               three_r=three_r, t_ref=t_ref, c_v=c_v)", "response": "calculate temperature along a hugoniot"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hugoniot_rho(p, rho0, c0, s, min_strain=0.01):\n    if isuncertainties([p, rho0, c0, s]):\n        f_u = np.vectorize(uct.wrap(hugoniot_rho_single),\n                           excluded=[1, 2, 3, 4])\n        return f_u(p, rho0, c0, s, min_strain=min_strain)\n    else:\n        f_v = np.vectorize(hugoniot_rho_single, excluded=[1, 2, 3, 4])\n        return f_v(p, rho0, c0, s, min_strain=min_strain)", "response": "calculate density in g / cm^3 from a hugoniot curve"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating density in g / cm^3 from a hugoniot curve", "response": "def hugoniot_rho_single(p, rho0, c0, s, min_strain=0.01):\n    \"\"\"\n    calculate density in g/cm^3 from a hugoniot curve\n\n    :param p: pressure in GPa\n    :param rho0: density at 1 bar in g/cm^3\n    :param c0: velocity at 1 bar in km/s\n    :param s: slope of the velocity change\n    :param min_strain: defining minimum v/v0 value to search volume for\n    :return: density in g/cm^3\n    \"\"\"\n    if p <= 1.e-5:\n        return rho0\n\n    def f_diff(rho):\n        return hugoniot_p(rho, rho0, c0, s) - p\n    rho = brenth(f_diff, rho0, rho0 / min_strain)\n    return rho"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_str(self):\n        val = c_backend.pystring_get_str(self._ptr)\n        delattr(self, '_ptr')\n        setattr(self, 'to_str', _dangling_pointer)\n        return val.decode(\"utf-8\")", "response": "Consumes the wrapper and returns a Python string. Afterwards is not necessary to destruct it as it has already been consumed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef servers(self, server='api.telldus.com', port=http.HTTPS_PORT):\n        logging.debug(\"Fetching server list from %s:%d\", server, port)\n\n        conn = http.HTTPSConnection(server, port, context=self.ssl_context())\n        conn.request('GET', \"/server/assign?protocolVersion=2\")\n\n        response = conn.getresponse()\n        if response.status != http.OK:\n            raise RuntimeError(\"Could not connect to {}:{}: {} {}\".format(\n                server, port, response.status, response.reason))\n\n        servers = []\n\n        def extract_servers(name, attributes):\n            if name == \"server\":\n                servers.append((attributes['address'],\n                                int(attributes['port'])))\n\n        parser = expat.ParserCreate()\n        parser.StartElementHandler = extract_servers\n        parser.ParseFile(response)\n\n        logging.debug(\"Found %d available servers\", len(servers))\n        return servers", "response": "Fetch list of servers that can be connected to."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef solve(self):\n\n        R, C = int(math.sqrt(len(self.sudoku))), int(math.sqrt(len(self.sudoku[0])))\n        N = R * C\n\n        X = ([(\"rc\", rc) for rc in product(range(N), range(N))] +\n             [(\"rn\", rn) for rn in product(range(N), range(1, N + 1))] +\n             [(\"cn\", cn) for cn in product(range(N), range(1, N + 1))] +\n             [(\"bn\", bn) for bn in product(range(N), range(1, N + 1))])\n        Y = dict()\n\n        for r, c, n in product(range(N), range(N), range(1, N + 1)):\n            b = (r // R) * R + (c // C)  # Box number\n            Y[(r, c, n)] = [\n                (\"rc\", (r, c)),\n                (\"rn\", (r, n)),\n                (\"cn\", (c, n)),\n                (\"bn\", (b, n))]\n\n        X, Y = self._exact_cover(X, Y)\n\n        for i, row in enumerate(self.sudoku):\n            for j, n in enumerate(row):\n                if n:\n                    self._select(X, Y, (i, j, n))\n\n        for solution in self._solve(X, Y, []):\n            grid = copy.deepcopy(self.sudoku)\n            for (r, c, n) in solution:\n                grid[r][c] = n\n            yield grid", "response": "Runs the Dancing Links and Algorithm X solver on the Sudoku."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun a shell command and return stdout", "response": "def execute(cmd):\n    \"\"\"Run a shell command and return stdout\"\"\"\n    proc = Popen(cmd, stdout=PIPE)\n    stdout, _ = proc.communicate()\n    if proc.returncode != 0:\n        raise CalledProcessError(proc.returncode, \" \".join(cmd))\n\n    return stdout.decode('utf8')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isuncertainties(arg_list):\n    for arg in arg_list:\n        if isinstance(arg, (list, tuple)) and isinstance(arg[0], uct.UFloat):\n            return True\n        elif isinstance(arg, np.ndarray) and isinstance(\n                np.atleast_1d(arg)[0], uct.UFloat):\n            return True\n        elif isinstance(arg, (float, uct.UFloat)) and \\\n                isinstance(arg, uct.UFloat):\n            return True\n    return False", "response": "check if the input list contains any elements with uncertainties class\n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of tuples for names that are tz data files.", "response": "def filter_tzfiles(name_list):\n    \"\"\"Returns a list of tuples for names that are tz data files.\"\"\"\n    for src_name in name_list:\n        # pytz-2012j/pytz/zoneinfo/Indian/Christmas\n        parts = src_name.split('/')\n        if len(parts) > 3 and parts[2] == 'zoneinfo':\n            dst_name = '/'.join(parts[2:])\n            yield src_name, dst_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_zip(fileobj):\n    archive = zipfile.ZipFile(fileobj, mode='r')\n    filenames = archive.namelist()\n\n    for src_name, dst_name in filter_tzfiles(filenames):\n        modified = archive.getinfo(src_name).date_time\n        bytes = archive.read(src_name)\n\n        yield dst_name, modified, bytes", "response": "Yields 3 - tuples of name modified bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_tar(fileobj):\n    import time\n\n    archive = tarfile.open(fileobj=fileobj)\n    filenames = [info.name for info in archive.getmembers() if info.isfile()]\n\n    for src_name, dst_name in filter_tzfiles(filenames):\n        mtime = archive.getmember(src_name).mtime\n        modified = tuple(time.gmtime(mtime)[:6])\n        bytes = archive.extractfile(src_name).read()\n\n        yield dst_name, modified, bytes", "response": "Yields 3 - tuples of name modified bytes"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_args(args):\n    parser = argparse.ArgumentParser(\n        description=\"Just a Hello World demonstration\")\n    parser.add_argument(\n        '-v',\n        '--version',\n        action='version',\n        version='twip {ver}'.format(ver=__version__))\n    return parser.parse_args(args)", "response": "Parse command line parameters as list of strings"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a new handler.", "response": "def register(self, *handlers, **params):\n        \"\"\" Ensure that handler is not registered. \"\"\"\n        for handler in handlers:\n\n            if issubclass(handler, PWModel):\n                handler = type(\n                    handler._meta.db_table.title() + 'Admin',\n                    (PWAdminHandler,), dict(model=handler, **params))\n                self.app.register(handler)\n                continue\n\n            name = handler.name.lower()\n            self.handlers[name] = handler"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndefine a authorization process.", "response": "def authorization(self, func):\n        \"\"\" Define a authorization process. \"\"\"\n        if self.app is None:\n            raise PluginException('The plugin must be installed to application.')\n\n        self.authorize = muffin.to_coroutine(func)\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nyield all directories with the given deep limit", "response": "def scandir_limited(top, limit, deep=0):\n    \"\"\"\n    yields only directories with the given deep limit\n\n    :param top: source path\n    :param limit: how deep should be scanned?\n    :param deep: internal deep number\n    :return: yields os.DirEntry() instances\n    \"\"\"\n    deep += 1\n    try:\n        scandir_it = Path2(top).scandir()\n    except PermissionError as err:\n        log.error(\"scandir error: %s\" % err)\n        return\n\n    for entry in scandir_it:\n        if entry.is_dir(follow_symlinks=False):\n            if deep < limit:\n                yield from scandir_limited(entry.path, limit, deep)\n            else:\n                yield entry"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iter_filtered_dir_entry(dir_entries, match_patterns, on_skip):\n\n    def match(dir_entry_path, match_patterns, on_skip):\n        for match_pattern in match_patterns:\n            if dir_entry_path.path_instance.match(match_pattern):\n                on_skip(dir_entry_path, match_pattern)\n                return True\n        return False\n\n    for entry in dir_entries:\n        try:\n            dir_entry_path = DirEntryPath(entry)\n        except FileNotFoundError as err:\n            # e.g.: A file was deleted after the first filesystem scan\n            # Will be obsolete if we use shadow-copy / snapshot function from filesystem\n            # see: https://github.com/jedie/PyHardLinkBackup/issues/6\n            log.error(\"Can't make DirEntryPath() instance: %s\" % err)\n            continue\n        if match(dir_entry_path, match_patterns, on_skip):\n            yield None\n        else:\n            yield dir_entry_path", "response": "Iterate a list of DirEntryPath instances with the given pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an iterator over the directory entries that are not empty", "response": "def iter(self, dir_entries):\n        \"\"\"\n        :param dir_entries: list of os.DirEntry() instances\n        \"\"\"\n        filter = self.filter\n        for entry in dir_entries:\n            path = filter(Path2(entry.path))\n            if path != False:\n                yield path"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_pagination(headers):\n    links = {\n        link.rel: parse_qs(link.href).get(\"page\", None)\n        for link in link_header.parse(headers.get(\"Link\", \"\")).links\n    }\n    return _Navigation(\n        links.get(\"previous\", [None])[0],\n        links.get(\"next\", [None])[0],\n        links.get(\"last\", [None])[0],\n        links.get(\"current\", [None])[0],\n        links.get(\"first\", [None])[0]\n    )", "response": "Parses the HTTP Headers to create a pagination object for the current page and last pages."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_uri(uri, endpoint_uri):\n    temp_parse = urlparse(uri)\n    return _Route(\n        urljoin(endpoint_uri, temp_parse.path),\n        parse_qs(temp_parse.query)\n    )", "response": "Parse a URI into a named tuple containing the path query and the url of the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding a Pycryptodome AES Cipher object.", "response": "def _cryptodome_cipher(key, iv):\n    \"\"\"Build a Pycryptodome AES Cipher object.\n\n    :param bytes key: Encryption key\n    :param bytes iv: Initialization vector\n    :returns: AES Cipher instance\n    \"\"\"\n    return AES.new(key, AES.MODE_CFB, iv, segment_size=128)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _cryptography_cipher(key, iv):\n    return Cipher(\n        algorithm=algorithms.AES(key),\n        mode=modes.CFB(iv),\n        backend=default_backend()\n    )", "response": "Build a cryptography AES Cipher object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_xml_node(graph, name, close=False, attributes=None, text=\"\", complete=False, innerXML=\"\"):\n    name = graph.namespace_manager.qname(name)\n    if complete:\n        if attributes is not None:\n            return \"<{0} {1}>{2}{3}</{0}>\".format(\n                name,\n                \" \".join(\n                    [\n                        \"{}=\\\"{}\\\"\".format(attr_name, attr_value)\n                        for attr_name, attr_value in attributes.items()\n                    ]\n                ),\n                escape(text),\n                innerXML\n            )\n        return \"<{0}>{1}{2}</{0}>\".format(name, escape(text), innerXML)\n    elif close is True:\n        return \"</{}>\".format(name)\n    elif attributes is not None:\n        return \"<{} {}>\".format(\n            name,\n            \" \".join(\n                [\n                    \"{}=\\\"{}\\\"\".format(attr_name, attr_value)\n                    for attr_name, attr_value in attributes.items()\n                ]\n            )\n        )\n    return \"<{}>\".format(name)", "response": "Creates an XML node for the given node name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing an XML element and return the root element.", "response": "def xmlparser(xml, objectify=True):\n    \"\"\" Parse xml\n\n    :param xml: XML element\n    :type xml: Union[text_type, lxml.etree._Element]\n    :rtype: lxml.etree._Element\n    :returns: An element object\n    :raises: TypeError if element is not in accepted type\n\n    \"\"\"\n    doclose = None\n    if isinstance(xml, (etree._Element, ObjectifiedElement, etree._ElementTree)):\n        return xml\n    elif isinstance(xml, text_type):\n        xml = StringIO(xml)\n        doclose = True\n    elif not isinstance(xml, IOBase):\n        raise TypeError(\"Unsupported type of resource {}\".format(type(xml)))\n\n    if objectify is False:\n        parsed = etree.parse(xml).getroot()\n    else:\n        parsed = parse(xml).getroot()\n    if doclose:\n        xml.close()\n    return parsed"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform an XPath on an element and indicate if we need to loop over it.", "response": "def performXpath(parent, xpath):\n    \"\"\" Perform an XPath on an element and indicate if we need to loop over it to find something\n\n    :param parent: XML Node on which to perform XPath\n    :param xpath: XPath to run\n    :return: (Result, Need to loop Indicator)\n    \"\"\"\n    loop = False\n    if xpath.startswith(\".//\"):\n        result = parent.xpath(\n            xpath.replace(\".//\", \"./\", 1),\n            namespaces=XPATH_NAMESPACES\n        )\n        if len(result) == 0:\n            result = parent.xpath(\n                \"*[{}]\".format(xpath),\n                namespaces=XPATH_NAMESPACES\n            )\n            loop = True\n    else:\n        result = parent.xpath(\n            xpath,\n            namespaces=XPATH_NAMESPACES\n        )\n    return result[0], loop"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncopy an XML node to a new Element", "response": "def copyNode(node, children=False, parent=False):\n    \"\"\" Copy an XML Node\n\n    :param node: Etree Node\n    :param children: Copy children nodes is set to True\n    :param parent: Append copied node to parent if given\n    :return: New Element\n    \"\"\"\n    if parent is not False:\n        element = SubElement(\n            parent,\n            node.tag,\n            attrib=node.attrib,\n            nsmap={None: \"http://www.tei-c.org/ns/1.0\"}\n        )\n    else:\n        element = Element(\n            node.tag,\n            attrib=node.attrib,\n            nsmap={None: \"http://www.tei-c.org/ns/1.0\"}\n        )\n    if children:\n        if node.text:\n            element._setText(node.text)\n        for child in xmliter(node):\n            element.append(copy(child))\n    return element"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef normalizeXpath(xpath):\n    new_xpath = []\n    for x in range(0, len(xpath)):\n        if x > 0 and len(xpath[x-1]) == 0:\n            new_xpath.append(\"/\"+xpath[x])\n        elif len(xpath[x]) > 0:\n            new_xpath.append(xpath[x])\n    return new_xpath", "response": "Normalize XPATH split around slashes and return a new list of xpath elements"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nloop over passages to construct and increment a new tree given a parent and an xpath.", "response": "def passageLoop(parent, new_tree, xpath1, xpath2=None, preceding_siblings=False, following_siblings=False):\n    \"\"\" Loop over passages to construct and increment new tree given a parent and XPaths\n\n    :param parent: Parent on which to perform xpath\n    :param new_tree: Parent on which to add nodes\n    :param xpath1: List of xpath elements\n    :type xpath1: [str]\n    :param xpath2: List of xpath elements\n    :type xpath2: [str]\n    :param preceding_siblings: Append preceding siblings of XPath 1/2 match to the tree\n    :param following_siblings: Append following siblings of XPath 1/2 match to the tree\n    :return: Newly incremented tree\n    \"\"\"\n    current_1, queue_1 = __formatXpath__(xpath1)\n    if xpath2 is None:  # In case we need what is following or preceding our node\n        result_1, loop = performXpath(parent, current_1)\n        if loop is True:\n            queue_1 = xpath1\n\n        central = None\n        has_no_queue = len(queue_1) == 0\n        # For each sibling, when we need them in the context of a range\n        if preceding_siblings or following_siblings:\n            for sibling in xmliter(parent):\n                if sibling == result_1:\n                    central = True\n                    # We copy the node we looked for (Result_1)\n                    child = copyNode(result_1, children=has_no_queue, parent=new_tree)\n                    # if we don't have children\n                    # we loop over the passage child\n                    if not has_no_queue:\n                        passageLoop(\n                            result_1,\n                            child,\n                            queue_1,\n                            None,\n                            preceding_siblings=preceding_siblings,\n                            following_siblings=following_siblings\n                        )\n                    # If we were waiting for preceding_siblings, we break it off\n                    # As we don't need to go further\n                    if preceding_siblings:\n                        break\n                elif not central and preceding_siblings:\n                    copyNode(sibling, parent=new_tree, children=True)\n                elif central and following_siblings:\n                    copyNode(sibling, parent=new_tree, children=True)\n    else:\n        result_1, loop = performXpath(parent, current_1)\n        if loop is True:\n            queue_1 = xpath1\n            if xpath2 == xpath1:\n                current_2, queue_2 = current_1, queue_1\n            else:\n                current_2, queue_2 = __formatXpath__(xpath2)\n        else:\n            current_2, queue_2 = __formatXpath__(xpath2)\n\n        if xpath1 != xpath2:\n            result_2, loop = performXpath(parent, current_2)\n            if loop is True:\n                queue_2 = xpath2\n        else:\n            result_2 = result_1\n\n        if result_1 == result_2:\n            has_no_queue = len(queue_1) == 0\n            child = copyNode(result_1, children=has_no_queue, parent=new_tree)\n            if not has_no_queue:\n                passageLoop(\n                    result_1,\n                    child,\n                    queue_1,\n                    queue_2\n                )\n        else:\n            start = False\n            # For each sibling\n            for sibling in xmliter(parent):\n                # If we have found start\n                # We copy the node because we are between start and end\n                if start:\n                    # If we are at the end\n                    # We break the copy\n                    if sibling == result_2:\n                        break\n                    else:\n                        copyNode(sibling, parent=new_tree, children=True)\n                # If this is start\n                # Then we copy it and initiate star\n                elif sibling == result_1:\n                    start = True\n                    has_no_queue_1 = len(queue_1) == 0\n                    node = copyNode(sibling, children=has_no_queue_1, parent=new_tree)\n                    if not has_no_queue_1:\n                        passageLoop(sibling, node, queue_1, None, following_siblings=True)\n\n            continue_loop = len(queue_2) == 0\n            node = copyNode(result_2, children=continue_loop, parent=new_tree)\n            if not continue_loop:\n                passageLoop(result_2, node, queue_2, None, preceding_siblings=True)\n\n    return new_tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the label for given lang or any default", "response": "def get_label(self, lang=None):\n        \"\"\" Return label for given lang or any default\n\n        :param lang: Language to request\n        :return: Label value\n        :rtype: Literal\n        \"\"\"\n        x = None\n        if lang is None:\n            for obj in self.graph.objects(self.asNode(), RDFS.label):\n                return obj\n        for obj in self.graph.objects(self.asNode(), RDFS.label):\n            x = obj\n            if x.language == lang:\n                return x\n        return x"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parent(self, parent):\n        self._parent = parent\n        self.graph.add(\n            (self.asNode(), RDF_NAMESPACES.CAPITAINS.parent, parent.asNode())\n        )\n        parent._add_member(self)", "response": "Sets the parent of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_member(self, member):\n        if member.id in self.children:\n            return None\n        else:\n            self.children[member.id] = member", "response": "Adds a member to the children of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of all descendant items of the item.", "response": "def descendants(self):\n        \"\"\" Any descendant (no max level) of the collection's item\n\n        :rtype: [Collection]\n        \"\"\"\n        return self.members + \\\n            [submember for member in self.members for submember in member.descendants]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef export_base_dts(cls, graph, obj, nsm):\n\n        o = {\n            \"@id\": str(obj.asNode()),\n            \"@type\": nsm.qname(obj.type),\n            nsm.qname(RDF_NAMESPACES.HYDRA.title): str(obj.get_label()),\n            nsm.qname(RDF_NAMESPACES.HYDRA.totalItems): obj.size\n        }\n\n        for desc in graph.objects(obj.asNode(), RDF_NAMESPACES.HYDRA.description):\n            o[nsm.qname(RDF_NAMESPACES.HYDRA.description)] = str(desc)\n\n        return o", "response": "Export the base DTS information in a simple reusable way"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the DC Creator literal value", "response": "def get_creator(self, lang=None):\n        \"\"\" Get the DC Creator literal value\n\n        :param lang: Language to retrieve\n        :return: Creator string representation\n        :rtype: Literal\n        \"\"\"\n        return self.metadata.get_single(key=DC.creator, lang=lang)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_title(self, lang=None):\n        return self.metadata.get_single(key=DC.title, lang=lang)", "response": "Get the title of the object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_subject(self, lang=None):\n        return self.metadata.get_single(key=DC.subject, lang=lang)", "response": "Get the subject of the object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_context(self):\n        if not self.is_valid():\n            raise ValueError(\"Cannot generate Context when form is invalid.\")\n        return dict(request=self.request, **self.cleaned_data)", "response": "Return a dict containing the current context of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef zharkov_panh(v, temp, v0, a0, m, n, z, t_ref=300.,\n                 three_r=3. * constants.R):\n    \"\"\"\n    calculate pressure from anharmonicity for Zharkov equation\n    the equation is from Dorogokupets 2015\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature in K\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param a0: parameter in K-1 for the Zharkov equation\n    :param m: parameter for the Zharkov equation\n    :param n: number of elements in a chemical formula\n    :param z: number of formula unit in a unit cell\n    :param three_r: 3 times gas constant\n    :return: anharmonic contribution for pressure in GPa\n    \"\"\"\n    v_mol = vol_uc2mol(v, z)\n    x = v / v0\n    a = a0 * np.power(x, m)\n\n    def f(t):\n        return three_r * n / 2. * a * m / v_mol * np.power(t, 2.) * 1.e-9\n\n    return f(temp) - f(t_ref)", "response": "calculate pressure from anharmonicity for Zharkov equation"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef split_words(line):\n  # Normalize any camel cased words first\n  line = _NORM_REGEX.sub(r'\\1 \\2', line)\n  return [normalize(w) for w in _WORD_REGEX.split(line)]", "response": "Return the list of words contained in a line."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, files):\n    if files.__class__.__name__ == 'str':\n      self._files.append(files)\n    else:\n      self._files.extend(files)", "response": "Adds files to check.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the files for misspellings.", "response": "def check(self):\n    \"\"\"Checks the files for misspellings.\n\n    Returns:\n      (errors, results)\n      errors: List of system errors, usually file access errors.\n      results: List of spelling errors - each tuple is filename,\n               line number and misspelled word.\n    \"\"\"\n    errors = []\n    results = []\n    for fn in self._files:\n      if not os.path.isdir(fn):\n        try:\n          with open(fn, 'r') as f:\n            line_ct = 1\n            for line in f:\n              for word in split_words(line):\n                if (word in self._misspelling_dict or\n                    word.lower() in self._misspelling_dict):\n                  results.append([fn, line_ct, word])\n              line_ct += 1\n        except UnicodeDecodeError:\n          pass\n        except IOError:\n          errors.append('%s' % sys.exc_info()[1])\n    return errors, results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef suggestions(self, word):\n    suggestions = set(self._misspelling_dict.get(word, [])).union(\n        set(self._misspelling_dict.get(word.lower(), [])))\n    return sorted([same_case(source=word, destination=w)\n                   for w in suggestions])", "response": "Returns a list of suggestions for a misspelled word."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of misspelled words and corrections.", "response": "def dump_misspelling_list(self):\n    \"\"\"Returns a list of misspelled words and corrections.\"\"\"\n    results = []\n    for bad_word in sorted(self._misspelling_dict.keys()):\n      for correction in self._misspelling_dict[bad_word]:\n        results.append([bad_word, correction])\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the status of Alerting Service", "response": "def status(self):\n        \"\"\"\n        Get the status of Alerting Service\n\n        :return: Status object\n        \"\"\"\n        orig_dict = self._get(self._service_url('status'))\n        orig_dict['implementation_version'] = orig_dict.pop('Implementation-Version')\n        orig_dict['built_from_git_sha1'] = orig_dict.pop('Built-From-Git-SHA1')\n        return Status(orig_dict)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cli(ctx, report, semantic, rcfile):\n    ctx.obj = {\n        'report': report,\n        'semantic': semantic,\n        'rcfile': rcfile,\n    }", "response": "Query or manipulate smother reports\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lookup(ctx, path):\n    regions = parse_intervals(path, as_context=ctx.obj['semantic'])\n    _report_from_regions(regions, ctx.obj)", "response": "Lookup test set for a source interval."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining which tests intersect a git diff.", "response": "def diff(ctx, branch):\n    \"\"\"\n    Determine which tests intersect a git diff.\n    \"\"\"\n    diff = GitDiffReporter(branch)\n    regions = diff.changed_intervals()\n    _report_from_regions(regions, ctx.obj, file_factory=diff.old_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncombines several smother reports.", "response": "def combine(ctx, src, dst):\n    \"\"\"\n    Combine several smother reports.\n    \"\"\"\n    c = coverage.Coverage(config_file=ctx.obj['rcfile'])\n    result = Smother(c)\n\n    for infile in src:\n        result |= Smother.load(infile)\n\n    result.write(dst)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_to_relative_paths(src, dst):\n    result = Smother.convert_to_relative_paths(Smother.load(src))\n    result.write(dst)", "response": "Converts all file paths in a smother report to relative paths relative\n    to the current directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef csv(ctx, dst):\n    sm = Smother.load(ctx.obj['report'])\n    semantic = ctx.obj['semantic']\n    writer = _csv.writer(dst, lineterminator='\\n')\n    dst.write(\"source_context, test_context\\n\")\n    writer.writerows(sm.iter_records(semantic=semantic))", "response": "Flatten a coverage file into a CSV file containing source_context testname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef erase(ctx):\n    if os.path.exists(ctx.obj['report']):\n        os.remove(ctx.obj['report'])", "response": "Erase the existing smother report."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_coverage(ctx):\n    sm = Smother.load(ctx.obj['report'])\n    sm.coverage = coverage.coverage()\n    sm.write_coverage()", "response": "Produce a. coverage file from a smother file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fill_missing_fields(self, data, columns):\n\n        for column in columns:\n            if column not in data.columns:\n                data[column] = scipy.zeros(len(data))\n\n        return data", "response": "This method fills with 0 s missing fields in the DataFrame with 0 s missing fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_field_names(self, data, matching):\n\n        for key in matching.keys():\n            if key in data.columns:\n                data.rename(columns={key:matching[key]})\n\n        return data", "response": "This method updates the names of the fields according to the given dictionary of matching values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_dates(self, data, columns):\n\n        for column in columns:\n            if column in data.columns:\n                data[column] = pandas.to_datetime(data[column])\n\n        return data", "response": "This method translates columns values into datetime objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a message to a channel.", "response": "def __send_notification(self, message, title, title_link='', color='good',\n                            fields='', log_level=LogLv.INFO):\n        \"\"\"Send a message to a channel.\n        Args:\n            title: Message title.\n            title_link: Link of the message title.\n            message: Message body.\n            color: Message line color on Slack. This parameter should be one of the following values: 'good', 'warning',\n             'danger' or any hex color code.\n\n        Returns:\n            response: Response of Slack API.\n\n        Raises:\n            Exception:\n        \"\"\"\n        if log_level < self.log_level:\n            return None\n\n        payload = self.__build_payload(message, title, title_link, color, fields)\n\n        try:\n            response = self.__post(payload)\n\n        except Exception:\n            raise Exception(traceback.format_exc())\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tange_grun(v, v0, gamma0, a, b):\n    x = v / v0\n    return gamma0 * (1. + a * (np.power(x, b) - 1.))", "response": "calculate Gruneisen parameter for the Tange equation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tange_debyetemp(v, v0, gamma0, a, b, theta0):\n    x = v / v0\n    gamma = tange_grun(v, v0, gamma0, a, b)\n    if isuncertainties([v, v0, gamma0, a, b, theta0]):\n        theta = theta0 * np.power(x, (-1. * (1. - a) * gamma0)) * \\\n            unp.exp((gamma0 - gamma) / b)\n    else:\n        theta = theta0 * np.power(x, (-1. * (1. - a) * gamma0)) * \\\n            np.exp((gamma0 - gamma) / b)\n    return theta", "response": "calculate Debye temperature for the Tange equation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating thermal pressure for a Tange formula", "response": "def tange_pth(v, temp, v0, gamma0, a, b, theta0, n, z,\n              t_ref=300., three_r=3. * constants.R):\n    \"\"\"\n    calculate thermal pressure for the Tange equation\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature in K\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param a: volume-independent adjustable parameters\n    :param b: volume-independent adjustable parameters\n    :param theta0: Debye temperature at 1 bar in K\n    :param n: number of atoms in a formula unit\n    :param z: number of formula unit in a unit cell\n    :param t_ref: reference temperature\n    :param three_r: 3R in case adjustment is needed\n    :return: thermal pressure in GPa\n    \"\"\"\n    v_mol = vol_uc2mol(v, z)\n    gamma = tange_grun(v, v0, gamma0, a, b)\n    theta = tange_debyetemp(v, v0, gamma0, a, b, theta0)\n    xx = theta / temp\n    debye = debye_E(xx)\n    if t_ref == 0.:\n        debye0 = 0.\n    else:\n        xx0 = theta / t_ref\n        debye0 = debye_E(xx0)\n    Eth0 = three_r * n * t_ref * debye0\n    Eth = three_r * n * temp * debye\n    delEth = Eth - Eth0\n    p_th = (gamma / v_mol * delEth) * 1.e-9\n    return p_th"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _make_passage_kwargs(urn, reference):\n    kwargs = {}\n    if urn is not None:\n        if reference is not None:\n            kwargs[\"urn\"] = URN(\"{}:{}\".format(urn.upTo(URN.VERSION), reference))\n        else:\n            kwargs[\"urn\"] = urn\n    return kwargs", "response": "Helper function to create keyword arguments for passage based on identifier and reference"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind a passage in the current text object.", "response": "def getTextualNode(self, subreference=None, simple=False):\n        \"\"\" Finds a passage in the current text\n\n        :param subreference: Identifier of the subreference / passages\n        :type subreference: Union[list, CtsReference]\n        :param simple: If set to true, retrieves nodes up to the given one, cleaning non required siblings.\n        :type simple: boolean\n        :rtype: CapitainsCtsPassage, ContextPassage\n        :returns: Asked passage\n        \"\"\"\n        if subreference is None:\n            return self._getSimplePassage()\n\n        if not isinstance(subreference, CtsReference):\n            if isinstance(subreference, str):\n                subreference = CtsReference(subreference)\n            elif isinstance(subreference, list):\n                subreference = CtsReference(\".\".join(subreference))\n\n        if len(subreference.start) > self.citation.root.depth:\n            raise CitationDepthError(\"URN is deeper than citation scheme\")\n\n        if simple is True:\n            return self._getSimplePassage(subreference)\n\n        if not subreference.is_range():\n            start = end = subreference.start.list\n        else:\n            start, end = subreference.start.list, subreference.end.list\n\n        citation_start = self.citation.root[len(start)-1]\n        citation_end = self.citation.root[len(end)-1]\n\n        start, end = citation_start.fill(passage=start), citation_end.fill(passage=end)\n        start, end = normalizeXpath(start.split(\"/\")[2:]), normalizeXpath(end.split(\"/\")[2:])\n\n        xml = self.textObject.xml\n\n        if isinstance(xml, etree._Element):\n            root = copyNode(xml)\n        else:\n            root = copyNode(xml.getroot())\n\n        root = passageLoop(xml, root, start, end)\n\n        if self.urn:\n            urn = URN(\"{}:{}\".format(self.urn, subreference))\n        else:\n            urn = None\n\n        return CapitainsCtsPassage(\n            urn=urn,\n            resource=root,\n            text=self,\n            citation=citation_start,\n            reference=subreference\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving a single node representing the passage.", "response": "def _getSimplePassage(self, reference=None):\n        \"\"\" Retrieve a single node representing the passage.\n\n        .. warning:: Range support is awkward.\n\n        :param reference: Identifier of the subreference / passages\n        :type reference: list, reference\n        :returns: Asked passage\n        :rtype: CapitainsCtsPassage\n        \"\"\"\n        if reference is None:\n            return _SimplePassage(\n                resource=self.resource,\n                reference=None,\n                urn=self.urn,\n                citation=self.citation.root,\n                text=self\n            )\n\n        subcitation = self.citation.root[reference.depth-1]\n        resource = self.resource.xpath(\n            subcitation.fill(reference),\n            namespaces=XPATH_NAMESPACES\n        )\n\n        if len(resource) != 1:\n            raise InvalidURN\n\n        return _SimplePassage(\n            resource[0],\n            reference=reference,\n            urn=self.urn,\n            citation=subcitation,\n            text=self.textObject\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of valid reffs at a given level.", "response": "def getReffs(self, level: int=1, subreference: CtsReference=None) -> CtsReferenceSet:\n        \"\"\" CtsReference available at a given level\n\n        :param level: Depth required. If not set, should retrieve first encountered level (1 based)\n        :param subreference: Subreference (optional)\n        :returns: List of levels\n        \"\"\"\n\n        if not subreference and hasattr(self, \"reference\"):\n            subreference = self.reference\n        elif subreference and not isinstance(subreference, CtsReference):\n            subreference = CtsReference(subreference)\n\n        return self.getValidReff(level=level, reference=subreference)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving the valid passages for the given level and reference.", "response": "def getValidReff(self, level: int=1, reference: CtsReference=None, _debug: bool=False) -> CtsReferenceSet:\n        \"\"\" Retrieve valid passages directly\n\n        :param level: Depth required. If not set, should retrieve first encountered level (1 based)\n        :type level: int\n        :param reference: CapitainsCtsPassage Reference\n        :type reference: CtsReference\n        :param _debug: Check on passages duplicates\n        :type _debug: bool\n        :returns: List of levels\n\n        .. note:: GetValidReff works for now as a loop using CapitainsCtsPassage, subinstances of CtsTextMetadata, to retrieve the valid \\\n        informations. Maybe something is more powerfull ?\n        \"\"\"\n\n        depth = 0\n        xml = self.textObject.xml\n\n        if reference:\n            if isinstance(reference, CtsReference):\n                if not reference.is_range():\n                    passages = [reference.start.list]\n                    depth = len(passages[0])\n                    if level == 0:\n                        level = None\n                        if _debug:\n                            warnings.warn(\"Using level=0 with a Non-range Reference is invalid. Autocorrected to 1\")\n                else:\n                    xml = self.getTextualNode(subreference=reference)\n\n                    common = []\n\n                    for index, part in enumerate(reference.start.list):\n                        if index <= reference.end.depth:\n                            if part == reference.end.list[index]:\n                                common.append(part)\n                            else:\n                                break\n                        else:\n                            break\n\n                    passages = [common]\n                    depth = len(common)\n\n                    if level is None:\n                        level = reference.start.depth + depth\n                    elif level == 1:\n                        level = reference.start.depth + 1\n                    elif level == 0:\n                        level = reference.start.depth\n            else:\n                raise TypeError()\n        else:\n            passages = [[]]\n\n        if level is None:\n            level = 1\n\n        if level <= len(passages[0]) and reference is not None:\n            level = len(passages[0]) + 1\n        if level > len(self.citation.root):\n            raise CitationDepthError(\"The required level is too deep\")\n\n        nodes = [None] * (level - depth)\n\n        citations = [citation for citation in self.citation.root]\n\n        while len(nodes) >= 1:\n            passages = [\n                refs + [node.get(current_citation.attribute.replace(\"xml:\", \"{http://www.w3.org/XML/1998/namespace}\"))]\n                for xpath_result, refs, current_citation in [\n                        (\n                            xml.xpath(\n                                citations[len(filling)-1].fill(filling),\n                                namespaces=XPATH_NAMESPACES\n                            ),\n                            refs,\n                            citations[len(filling)-1]\n                        )\n                        for filling, refs in\n                        [(refs + [None], refs) for refs in passages]\n                    ]\n                for node in xpath_result\n            ]\n            nodes.pop(0)\n\n            if len(passages) == 0:\n                msg = \"Unknown reference {}\".format(reference)\n                raise KeyError(msg)\n\n        passages = [\".\".join(passage) for passage in passages]\n\n        if _debug:\n            duplicates = set([n for n in passages if passages.count(n) > 1])\n            if len(duplicates) > 0:\n                message = \", \".join(duplicates)\n                warnings.warn(message, DuplicateReference)\n            del duplicates\n            empties = [n for n in passages if n.rstrip('.') != n or n == '']\n            if len(empties) > 0:\n                message = '{} empty reference(s) at citation level {}'.format(len(empties), level)\n                print(empties)\n                warnings.warn(message, EmptyReference)\n\n        references = CtsReferenceSet(\n            [CtsReference(reff) for reff in passages],\n            citation=self.citation.root[level-1],\n            level=level\n        )\n        return references"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef xpath(self, *args, **kwargs):\n        if \"smart_strings\" not in kwargs:\n            kwargs[\"smart_strings\"] = False\n        return self.resource.xpath(*args, **kwargs)", "response": "Perform XPath on the passage XML\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransform the CapitainsCtsPassage in XML string", "response": "def tostring(self, *args, **kwargs):\n        \"\"\" Transform the CapitainsCtsPassage in XML string\n\n        :param args: Ordered arguments for etree.tostring() (except the first one)\n        :param kwargs: Named arguments\n        :return:\n        \"\"\"\n        return etree.tostring(self.resource, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary of chidren where key is the child of the passage.", "response": "def childIds(self):\n        \"\"\" Children of the passage\n\n        :rtype: None, CtsReference\n        :returns: Dictionary of chidren, where key are subreferences\n        \"\"\"\n        if self.depth >= len(self.citation.root):\n            return []\n        elif self._children is not None:\n            return self._children\n        else:\n            self._children = self.getReffs()\n            return self._children"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of valid CtsReferenceSet for the given level and subreference.", "response": "def getReffs(self, level=1, subreference=None) -> CtsReferenceSet:\n        \"\"\" Reference available at a given level\n\n        :param level: Depth required. If not set, should retrieve first encountered level (1 based). 0 retrieves inside\n            a range\n        :param subreference: Subreference (optional)\n        :returns: List of levels\n        \"\"\"\n        level += self.depth\n        if not subreference:\n            subreference = self.reference\n        return self.textObject.getValidReff(level, reference=subreference)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef siblingsId(self) -> Tuple[CtsReference, CtsReference]:\n\n        if not self._text:\n            raise MissingAttribute(\"CapitainsCtsPassage was iniated without CtsTextMetadata object\")\n        if self._prev_next is not None:\n            return self._prev_next\n\n        document_references = self._text.getReffs(level=self.depth)\n\n        range_length = 1\n        if self.reference.is_range():\n            range_length = len(self.getReffs())\n\n        start = document_references.index(self.reference.start)\n\n        if start == 0:\n            # If the passage is already at the beginning\n            _prev = None\n        elif start - range_length < 0:\n            _prev = document_references[0]\n        else:\n            _prev = document_references[start - 1]\n\n        if start + 1 == len(document_references):\n            # If the passage is already at the end\n            _next = None\n        elif start + range_length > len(document_references):\n            _next = document_references[-1]\n        else:\n            _next = document_references[start + 1]\n\n        self._prev_next = (_prev, _next)\n        return self._prev_next", "response": "Returns the Siblings Identifiers of the passage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding CRefPattern in the text and set object. citation", "response": "def _findCRefPattern(self, xml):\n        \"\"\" Find CRefPattern in the text and set object.citation\n        :param xml: Xml Resource\n        :type xml: lxml.etree._Element\n        :return: None\n        \"\"\"\n        if not self.citation.is_set():\n            citation = xml.xpath(\"//tei:refsDecl[@n='CTS']\", namespaces=XPATH_NAMESPACES)\n            if len(citation):\n                self.citation = Citation.ingest(resource=citation[0], xpath=\".//tei:cRefPattern\")\n            else:\n                raise MissingRefsDecl(\"No reference declaration (refsDecl) found.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef siblingsId(self) -> Tuple[CtsReference, CtsReference]:\n        self._raise_depth()\n\n        if not self._text:\n            raise MissingAttribute(\"CapitainsCtsPassage was initiated without CtsTextMetadata object\")\n        if self._prev_next:\n            return self._prev_next\n\n        document_references = self._text.getReffs(level=self.depth)\n\n        if self.reference.is_range():\n            start, end = self.reference.start, self.reference.end\n            range_length = len(self.getReffs(level=0))\n        else:\n            start = end = self.reference.start\n            range_length = 1\n\n        start = document_references.index(start)\n        end = document_references.index(end)\n\n        if start == 0:\n            # If the passage is already at the beginning\n            _prev = None\n        elif start - range_length < 0:\n            if start == end:\n                _prev = document_references[0]\n            else:\n                _prev = \"{}-{}\".format(document_references[0], document_references[start-1])\n        else:\n            if start == end:\n                _prev = document_references[start-1]\n            else:\n                _prev = \"{}-{}\".format(document_references[start-range_length], document_references[start-1])\n\n        if start + 1 == len(document_references) or end + 1 == len(document_references):\n            # If the passage is already at the end\n            _next = None\n        elif end + range_length > len(document_references):\n            if start == end:\n                _next = document_references[-1]\n            else:\n                _next = \"{}-{}\".format(document_references[end+1], document_references[-1])\n        else:\n            if start == end:\n                _next = document_references[end+1]\n            else:\n                _next = \"{}-{}\".format(document_references[end+1], document_references[end + range_length])\n\n        self._prev_next = (CtsReference(_prev), CtsReference(_next))\n        return self._prev_next", "response": "Returns the Siblings Identifiers of the passage."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef next(self):\n        if self.nextId is not None:\n            return super(CapitainsCtsPassage, self).getTextualNode(subreference=self.nextId)", "response": "Returns the next CapitainsCtsPassage in the textual tree."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prev(self):\n        if self.prevId is not None:\n            return super(CapitainsCtsPassage, self).getTextualNode(subreference=self.prevId)", "response": "Get the previous CapitainsCtsPassage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a formatted string representing the coordinate in this module s hexadecimal coordinate system.", "response": "def location(hexgrid_type, coord):\n    \"\"\"\n    Returns a formatted string representing the coordinate. The format depends on the\n    coordinate type.\n\n    Tiles look like: 1, 12\n    Nodes look like: (1 NW), (12 S)\n    Edges look like: (1 NW), (12 SE)\n\n    :param hexgrid_type: hexgrid.TILE, hexgrid.NODE, hexgrid.EDGE\n    :param coord: integer coordinate in this module's hexadecimal coordinate system\n    :return: formatted string for display\n    \"\"\"\n    if hexgrid_type == TILE:\n        return str(coord)\n    elif hexgrid_type == NODE:\n        tile_id = nearest_tile_to_node(coord)\n        dirn = tile_node_offset_to_direction(coord - tile_id_to_coord(tile_id))\n        return '({} {})'.format(tile_id, dirn)\n    elif hexgrid_type == EDGE:\n        tile_id = nearest_tile_to_edge(coord)\n        dirn = tile_edge_offset_to_direction(coord - tile_id_to_coord(tile_id))\n        return '({} {})'.format(tile_id, dirn)\n    else:\n        logging.warning('unsupported hexgrid_type={}'.format(hexgrid_type))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of tuples that represent the coastal edges of the grid.", "response": "def coastal_coords():\n    \"\"\"\n    A coastal coord is a 2-tuple: (tile id, direction).\n\n    An edge is coastal if it is on the grid's border.\n\n    :return: list( (tile_id, direction) )\n    \"\"\"\n    coast = list()\n    for tile_id in coastal_tile_ids():\n        tile_coord = tile_id_to_coord(tile_id)\n        for edge_coord in coastal_edges(tile_id):\n            dirn = tile_edge_offset_to_direction(edge_coord - tile_coord)\n            if tile_id_in_direction(tile_id, dirn) is None:\n                coast.append((tile_id, dirn))\n    # logging.debug('coast={}'.format(coast))\n    return coast"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of coastal edge coordinate.", "response": "def coastal_edges(tile_id):\n    \"\"\"\n    Returns a list of coastal edge coordinate.\n\n    An edge is coastal if it is on the grid's border.\n    :return: list(int)\n    \"\"\"\n    edges = list()\n    tile_coord = tile_id_to_coord(tile_id)\n    for edge_coord in edges_touching_tile(tile_id):\n        dirn = tile_edge_offset_to_direction(edge_coord - tile_coord)\n        if tile_id_in_direction(tile_id, dirn) is None:\n            edges.append(edge_coord)\n    return edges"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tile_id_in_direction(from_tile_id, direction):\n    coord_from = tile_id_to_coord(from_tile_id)\n    for offset, dirn in _tile_tile_offsets.items():\n        if dirn == direction:\n            coord_to = coord_from + offset\n            if coord_to in legal_tile_coords():\n                return tile_id_from_coord(coord_to)\n    return None", "response": "Returns the ID of the first valid tile in the given direction."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef edge_coord_in_direction(tile_id, direction):\n    tile_coord = tile_id_to_coord(tile_id)\n    for edge_coord in edges_touching_tile(tile_id):\n        if tile_edge_offset_to_direction(edge_coord - tile_coord) == direction:\n            return edge_coord\n    raise ValueError('No edge found in direction={} at tile_id={}'.format(\n        direction,\n        tile_id\n    ))", "response": "Returns the edge coordinate in the given direction at the given tile identifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef node_coord_in_direction(tile_id, direction):\n    tile_coord = tile_id_to_coord(tile_id)\n    for node_coord in nodes_touching_tile(tile_id):\n        if tile_node_offset_to_direction(node_coord - tile_coord) == direction:\n            return node_coord\n    raise ValueError('No node found in direction={} at tile_id={}'.format(\n        direction,\n        tile_id\n    ))", "response": "Returns the node coordinate in the given direction at the given tile identifier."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a tile coordinate to its corresponding tile identifier.", "response": "def tile_id_from_coord(coord):\n    \"\"\"\n    Convert a tile coordinate to its corresponding tile identifier.\n\n    :param coord: coordinate of the tile, int\n    :return: tile identifier, Tile.tile_id\n    \"\"\"\n    for i, c in _tile_id_to_coord.items():\n        if c == coord:\n            return i\n    raise Exception('Tile id lookup failed, coord={} not found in map'.format(hex(coord)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the first tile found adjacent to the given edge. Returns a tile identifier.", "response": "def nearest_tile_to_edge_using_tiles(tile_ids, edge_coord):\n    \"\"\"\n    Get the first tile found adjacent to the given edge. Returns a tile identifier.\n\n    :param tile_ids: tiles to look at for adjacency, list(Tile.tile_id)\n    :param edge_coord: edge coordinate to find an adjacent tile to, int\n    :return: tile identifier of an adjacent tile, Tile.tile_id\n    \"\"\"\n    for tile_id in tile_ids:\n        if edge_coord - tile_id_to_coord(tile_id) in _tile_edge_offsets.keys():\n            return tile_id\n    logging.critical('Did not find a tile touching edge={}'.format(edge_coord))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nearest_tile_to_node_using_tiles(tile_ids, node_coord):\n    for tile_id in tile_ids:\n        if node_coord - tile_id_to_coord(tile_id) in _tile_node_offsets.keys():\n            return tile_id\n    logging.critical('Did not find a tile touching node={}'.format(node_coord))", "response": "Get the first tile found adjacent to the given node. Returns a tile identifier."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef edges_touching_tile(tile_id):\n    coord = tile_id_to_coord(tile_id)\n    edges = []\n    for offset in _tile_edge_offsets.keys():\n        edges.append(coord + offset)\n    # logging.debug('tile_id={}, edges touching={}'.format(tile_id, edges))\n    return edges", "response": "Get a list of edge coordinates touching a given tile."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a list of node coordinates touching a given tile.", "response": "def nodes_touching_tile(tile_id):\n    \"\"\"\n    Get a list of node coordinates touching the given tile.\n\n    :param tile_id: tile identifier, Tile.tile_id\n    :return: list of node coordinates touching the given tile, list(int)\n    \"\"\"\n    coord = tile_id_to_coord(tile_id)\n    nodes = []\n    for offset in _tile_node_offsets.keys():\n        nodes.append(coord + offset)\n    # logging.debug('tile_id={}, nodes touching={}'.format(tile_id, nodes))\n    return nodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the two node coordinates which are on the given edge coordinate.", "response": "def nodes_touching_edge(edge_coord):\n    \"\"\"\n    Returns the two node coordinates which are on the given edge coordinate.\n\n    :return: list of 2 node coordinates which are on the given edge coordinate, list(int)\n    \"\"\"\n    a, b = hex_digit(edge_coord, 1), hex_digit(edge_coord, 2)\n    if a % 2 == 0 and b % 2 == 0:\n        return [coord_from_hex_digits(a, b + 1),\n                coord_from_hex_digits(a + 1, b)]\n    else:\n        return [coord_from_hex_digits(a, b),\n                coord_from_hex_digits(a + 1, b + 1)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn all legal edge coordinates on the grid.", "response": "def legal_edge_coords():\n    \"\"\"\n    Return all legal edge coordinates on the grid.\n    \"\"\"\n    edges = set()\n    for tile_id in legal_tile_ids():\n        for edge in edges_touching_tile(tile_id):\n            edges.add(edge)\n    logging.debug('Legal edge coords({})={}'.format(len(edges), edges))\n    return edges"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all legal node coordinates on the grid", "response": "def legal_node_coords():\n    \"\"\"\n    Return all legal node coordinates on the grid\n    \"\"\"\n    nodes = set()\n    for tile_id in legal_tile_ids():\n        for node in nodes_touching_tile(tile_id):\n            nodes.add(node)\n    logging.debug('Legal node coords({})={}'.format(len(nodes), nodes))\n    return nodes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn either the first or second digit of the hexadecimal representation of the given coordinate.", "response": "def hex_digit(coord, digit=1):\n    \"\"\"\n    Returns either the first or second digit of the hexadecimal representation of the given coordinate.\n    :param coord: hexadecimal coordinate, int\n    :param digit: 1 or 2, meaning either the first or second digit of the hexadecimal\n    :return: int, either the first or second digit\n    \"\"\"\n    if digit not in [1,2]:\n        raise ValueError('hex_digit can only get the first or second digit of a hex number, was passed digit={}'.format(\n            digit\n        ))\n    return int(hex(coord)[1+digit], 16)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rotate_direction(hexgrid_type, direction, ccw=True):\n    if hexgrid_type in [TILE, EDGE]:\n        directions = ['NW', 'W', 'SW', 'SE', 'E', 'NE', 'NW'] if ccw \\\n                else ['NW', 'NE', 'E', 'SE', 'SW', 'W', 'NW']\n        return directions[directions.index(direction) + 1]\n    elif hexgrid_type in [NODE]:\n        directions = ['N', 'NW', 'SW', 'S', 'SE', 'NE', 'N'] if ccw \\\n            else ['N', 'NE', 'SE', 'S', 'SW', 'NW', 'N']\n        return directions[directions.index(direction) + 1]\n    else:\n        raise ValueError('Invalid hexgrid type={} passed to rotate direction'.format(hexgrid_type))", "response": "Rotates a given hexgrid element in one tick in the given direction."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a new port mapping to the cluster.", "response": "async def AddPortMapping(NewRemoteHost: str, NewExternalPort: int, NewProtocol: str, NewInternalPort: int,\n                       NewInternalClient: str, NewEnabled: int, NewPortMappingDescription: str,\n                       NewLeaseDuration: str) -> None:\n        \"\"\"Returns None\"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Generic Port Mapping Entry.", "response": "async def GetGenericPortMappingEntry(NewPortMappingIndex: int) -> Tuple[str, int, str, int, str,\n                                                                            bool, str, int]:\n        \"\"\"\n        Returns (NewRemoteHost, NewExternalPort, NewProtocol, NewInternalPort, NewInternalClient, NewEnabled,\n                 NewPortMappingDescription, NewLeaseDuration)\n        \"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget specific port mapping entry.", "response": "async def GetSpecificPortMappingEntry(NewRemoteHost: str, NewExternalPort: int,\n                                          NewProtocol: str) -> Tuple[int, str, bool, str, int]:\n        \"\"\"Returns (NewInternalPort, NewInternalClient, NewEnabled, NewPortMappingDescription, NewLeaseDuration)\"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef assoc(self, index, value):\n        '''Return a new tree with value associated at index.'''\n        newnode = LookupTreeNode(index, value)\n        newtree = LookupTree()\n        newtree.root = _assoc_down(self.root, newnode, 0)\n        return newtree", "response": "Return a new tree with value associated at index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef multi_assoc(self, values):\n        '''Return a new tree with multiple values associated. The parameter\n        values can either be a dictionary mapping indices to values, or a list\n        of (index,value) tuples'''\n        if isinstance(values, dict):\n            nndict = dict([(i, LookupTreeNode(i, values[i])) for i in values])\n        else:\n            nndict = dict([(i, LookupTreeNode(i, val)) for (i,val) in values])\n        newtree = LookupTree()\n        newtree.root = _multi_assoc_down(self.root, nndict, 0)\n        return newtree", "response": "Return a new tree with multiple values associated. The parameter\n        values can either be a dictionary mapping indices to values or a list of tuples of values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning new tree with index removed.", "response": "def remove(self, index):\n        '''Return new tree with index removed.'''\n        newtree = LookupTree()\n        newtree.root = _remove_down(self.root, index, 0)\n        return newtree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninsert a node in - place. It is highly suggested that you do not have a value in - place. Use assoc instead.", "response": "def insert(self, index, value):\n        '''Insert a node in-place. It is highly suggested that you do not\n        use this method. Use assoc instead'''\n        newnode = LookupTreeNode(index, value)\n        level = 0\n        node = self.root\n        while True:\n            ind = _getbits(newnode.index, level)\n            level += 1\n            child = node.children[ind]\n            if child is None or child.index == newnode.index:\n                if child:\n                    assert child.value == newnode.value\n                node.children[ind] = newnode\n                break\n            elif child.index == _root_index:\n                # This is a branch\n                node = child\n            else:\n                branch = LookupTreeNode()\n                nind = _getbits(newnode.index, level)\n                cind = _getbits(child.index, level)\n                node.children[ind] = branch\n\n                # Life gets tricky when...\n                if nind == cind:\n                    branch.children[cind] = child\n                    # recurse\n                    node = branch\n                else:\n                    branch.children[nind] = newnode\n                    branch.children[cind] = child\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreset the registry to the standard codecs.", "response": "def reset(cls):\n        \"\"\"Reset the registry to the standard codecs.\"\"\"\n        cls._codecs = {}\n        c = cls._codec\n        for (name, encode, decode) in cls._common_codec_data:\n            cls._codecs[name] = c(encode, decode)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a codec to the registry.", "response": "def register(cls, name, encode, decode):\n        \"\"\"Add a codec to the registry.\n\n        Registers a codec with the given `name` (a string) to be used with the\n        given `encode` and `decode` functions, which take a `bytes` object and\n        return another one.  An existing codec is replaced.\n\n        >>> import binascii\n        >>> CodecReg.register('uu', binascii.b2a_uu, binascii.a2b_uu)\n        >>> CodecReg.get_decoder('uu') is binascii.a2b_uu\n        True\n        >>> CodecReg.reset()\n        >>> 'uu' in CodecReg\n        False\n        \"\"\"\n        cls._codecs[name] = cls._codec(encode, decode)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef default_formatter(handler, item, value):\n    if hasattr(value, '__unicode__'):\n        value = value.__unicode__()\n\n    return escape(str(value))", "response": "Default formatter. Convert value to string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a regular expression string for optionally signed binary or privative feature.", "response": "def make_regex(string):\n    \"\"\"Regex string for optionally signed binary or privative feature.\n\n    >>> [make_regex(s) for s in '+spam -spam spam'.split()]\n    ['([+]?spam)', '(-spam)', '(spam)']\n\n    >>> make_regex('+eggs-spam')\n    Traceback (most recent call last):\n        ...\n    ValueError: inappropriate feature name: '+eggs-spam'\n\n    >>> make_regex('')\n    Traceback (most recent call last):\n        ...\n    ValueError: inappropriate feature name: ''\n    \"\"\"\n    if string and string[0] in '+-':\n        sign, name = string[0], string[1:]\n        if not name or '+' in name or '-' in name:\n            raise ValueError('inappropriate feature name: %r' % string)\n\n        tmpl = r'([+]?%s)' if sign == '+' else r'(-%s)'\n        return tmpl % name\n\n    if not string or '+' in string or '-' in string:\n        raise ValueError('inappropriate feature name: %r' % string)\n\n    return r'(%s)' % string"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef substring_names(features):\n    names = tools.uniqued(map(remove_sign, features))\n    for l, r in permutations(names, 2):\n        if l in r:\n            yield (l, r)", "response": "Yield all feature name pairs in substring relation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the nearest featureset that subsumes all given ones.", "response": "def join(self, featuresets):\n        \"\"\"Return the nearest featureset that subsumes all given ones.\"\"\"\n        concepts = (f.concept for f in featuresets)\n        join = self.lattice.join(concepts)\n        return self._featuresets[join.index]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the nearest featureset that implies all given ones.", "response": "def meet(self, featuresets):\n        \"\"\"Return the nearest featureset that implies all given ones.\"\"\"\n        concepts = (f.concept for f in featuresets)\n        meet = self.lattice.meet(concepts)\n        return self._featuresets[meet.index]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields all featuresets that subsume any of the given ones.", "response": "def upset_union(self, featuresets):\n        \"\"\"Yield all featuresets that subsume any of the given ones.\"\"\"\n        concepts = (f.concept for f in featuresets)\n        indexes = (c.index for c in self.lattice.upset_union(concepts))\n        return map(self._featuresets.__getitem__, indexes)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the system lattice visualization as graphviz source.", "response": "def graphviz(self, highlight=None, maximal_label=None, topdown=None,\n            filename=None, directory=None, render=False, view=False):\n        \"\"\"Return the system lattice visualization as graphviz source.\"\"\"\n        return visualize.featuresystem(self, highlight, maximal_label,\n            topdown, filename, directory, render, view)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo a soap request.", "response": "def soap_action(self, service, action, payloadbody):\n        \"\"\"Do a soap request.\"\"\"\n        payload = self.soapenvelope.format(body=payloadbody).encode('utf-8')\n        headers = {\"Host\": self.url,\n                   \"Content-Type\": \"text/xml; charset=UTF-8\",\n                   \"Cache-Control\": \"no-cache\",\n                   \"Content-Length\": str(len(payload)),\n                   \"SOAPAction\": action}\n        try:\n            self.last_exception = None\n            response = requests.post(url=self.url + service, headers=headers,\n                                     data=payload, cookies=self.cookies)\n        except requests.exceptions.RequestException as exp:\n            self.last_exception = exp\n            return False\n        if response.status_code != 200:\n            self.last_response = response\n            return False\n        self.cookies = response.cookies\n        try:\n            xdoc = xml.etree.ElementTree.fromstring(response.text)\n        except xml.etree.ElementTree.ParseError as exp:\n            self.last_exception = exp\n            self.last_response = response\n            return False\n        return xdoc"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getValidReff(self, level=1, reference=None):\n        if reference:\n            urn = \"{0}:{1}\".format(self.urn, reference)\n        else:\n            urn = str(self.urn)\n\n        if level == -1:\n            level = len(self.citation)\n\n        xml = self.retriever.getValidReff(\n            level=level,\n            urn=urn\n        )\n        xml = xmlparser(xml)\n        self._parse_request(xml.xpath(\"//ti:request\", namespaces=XPATH_NAMESPACES)[0])\n\n        return [ref.split(\":\")[-1] for ref in xml.xpath(\"//ti:reply//ti:urn/text()\", namespaces=XPATH_NAMESPACES)]", "response": "Given a resource and a reference returns a list of valid reffs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getTextualNode(self, subreference=None):\n        if isinstance(subreference, URN):\n            urn = str(subreference)\n        elif isinstance(subreference, CtsReference):\n            urn = \"{0}:{1}\".format(self.urn, str(subreference))\n        elif isinstance(subreference, str):\n            if \":\" in subreference:\n                urn = subreference\n            else:\n                urn = \"{0}:{1}\".format(self.urn.upTo(URN.NO_PASSAGE), subreference)\n        elif isinstance(subreference, list):\n            urn = \"{0}:{1}\".format(self.urn, \".\".join(subreference))\n        else:\n            urn = str(self.urn)\n\n        response = xmlparser(self.retriever.getPassage(urn=urn))\n\n        self._parse_request(response.xpath(\"//ti:request\", namespaces=XPATH_NAMESPACES)[0])\n        return CtsPassage(urn=urn, resource=response, retriever=self.retriever)", "response": "Retrieve a passage and store it in the object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of valid reference levels at a given level.", "response": "def getReffs(self, level=1, subreference=None):\n        \"\"\" Reference available at a given level\n\n        :param level: Depth required. If not set, should retrieve first encountered level (1 based)\n        :type level: Int\n        :param subreference: Subreference (optional)\n        :type subreference: CtsReference\n        :rtype: [text_type]\n        :returns: List of levels\n        \"\"\"\n        if self.depth is not None:\n            level += self.depth\n\n        return self.getValidReff(level, subreference)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve a passage and informations around it and store it in the object", "response": "def getPassagePlus(self, reference=None):\n        \"\"\" Retrieve a passage and informations around it and store it in the object\n\n        :param reference: Reference of the passage\n        :type reference: CtsReference or List of text_type\n        :rtype: CtsPassage\n        :returns: Object representing the passage\n        :raises: *TypeError* when reference is not a list or a Reference\n        \"\"\"\n        if reference:\n            urn = \"{0}:{1}\".format(self.urn, reference)\n        else:\n            urn = str(self.urn)\n\n        response = xmlparser(self.retriever.getPassagePlus(urn=urn))\n\n        passage = CtsPassage(urn=urn, resource=response, retriever=self.retriever)\n        passage._parse_request(response.xpath(\"//ti:reply/ti:label\", namespaces=XPATH_NAMESPACES)[0])\n        self.citation = passage.citation\n        return passage"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_request(self, xml):\n        for node in xml.xpath(\".//ti:groupname\", namespaces=XPATH_NAMESPACES):\n            lang = node.get(\"xml:lang\") or CtsText.DEFAULT_LANG\n            self.metadata.add(RDF_NAMESPACES.CTS.groupname, lang=lang, value=node.text)\n            self.set_creator(node.text, lang)\n\n        for node in xml.xpath(\".//ti:title\", namespaces=XPATH_NAMESPACES):\n            lang = node.get(\"xml:lang\") or CtsText.DEFAULT_LANG\n            self.metadata.add(RDF_NAMESPACES.CTS.title, lang=lang, value=node.text)\n            self.set_title(node.text, lang)\n\n        for node in xml.xpath(\".//ti:label\", namespaces=XPATH_NAMESPACES):\n            lang = node.get(\"xml:lang\") or CtsText.DEFAULT_LANG\n            self.metadata.add(RDF_NAMESPACES.CTS.label, lang=lang, value=node.text)\n            self.set_subject(node.text, lang)\n\n        for node in xml.xpath(\".//ti:description\", namespaces=XPATH_NAMESPACES):\n            lang = node.get(\"xml:lang\") or CtsText.DEFAULT_LANG\n            self.metadata.add(RDF_NAMESPACES.CTS.description, lang=lang, value=node.text)\n            self.set_description(node.text, lang)\n\n        # Need to code that p\n        if not self.citation.is_set() and xml.xpath(\"//ti:citation\", namespaces=XPATH_NAMESPACES):\n            self.citation = CtsCollection.XmlCtsCitation.ingest(\n                xml,\n                xpath=\".//ti:citation[not(ancestor::ti:citation)]\"\n            )", "response": "Parses a request with metadata information and sets the object properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves metadata about the text", "response": "def getLabel(self):\n        \"\"\" Retrieve metadata about the text\n\n        :rtype: Metadata\n        :returns: Dictionary with label informations\n        \"\"\"\n        response = xmlparser(\n            self.retriever.getLabel(urn=str(self.urn))\n        )\n\n        self._parse_request(\n            response.xpath(\"//ti:reply/ti:label\", namespaces=XPATH_NAMESPACES)[0]\n        )\n\n        return self.metadata"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the previous URN of a reference of the text SetException", "response": "def getPrevNextUrn(self, reference):\n        \"\"\" Get the previous URN of a reference of the text\n\n        :param reference: CtsReference from which to find siblings\n        :type reference: Union[CtsReference, str]\n        :return: (Previous CapitainsCtsPassage CtsReference,Next CapitainsCtsPassage CtsReference)\n        \"\"\"\n        _prev, _next = _SharedMethod.prevnext(\n            self.retriever.getPrevNextUrn(\n                urn=\"{}:{}\".format(\n                    str(\n                        URN(\n                            str(self.urn)).upTo(URN.NO_PASSAGE)\n                    ),\n                    str(reference)\n                )\n            )\n        )\n        return _prev, _next"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getFirstUrn(self, reference=None):\n        if reference is not None:\n            if \":\" in reference:\n                urn = reference\n            else:\n                urn = \"{}:{}\".format(\n                    str(URN(str(self.urn)).upTo(URN.NO_PASSAGE)),\n                    str(reference)\n                )\n        else:\n            urn = str(self.urn)\n        _first = _SharedMethod.firstUrn(\n            self.retriever.getFirstUrn(\n                urn\n            )\n        )\n        return _first", "response": "Get the first children URN for a given resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the first urn of the children of the passage.", "response": "def firstId(self):\n        \"\"\" Children passage\n\n        :rtype: str\n        :returns: First children of the graph. Shortcut to self.graph.children[0]\n        \"\"\"\n        if self._first is False:\n            # Request the next urn\n            self._first = self.getFirstUrn()\n        return self._first"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the last urn of the children of the graph.", "response": "def lastId(self):\n        \"\"\" Children passage\n\n        :rtype: str\n        :returns: First children of the graph. Shortcut to self.graph.children[0]\n        \"\"\"\n        if self._last is False:\n            # Request the next urn\n            self._last = self.childIds[-1]\n        return self._last"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a resource to get the first URN", "response": "def firstUrn(resource):\n        \"\"\" Parse a resource to get the first URN\n\n        :param resource: XML Resource\n        :type resource: etree._Element\n        :return: Tuple representing previous and next urn\n        :rtype: str\n        \"\"\"\n        resource = xmlparser(resource)\n        urn = resource.xpath(\"//ti:reply/ti:urn/text()\", namespaces=XPATH_NAMESPACES, magic_string=True)\n\n        if len(urn) > 0:\n            urn = str(urn[0])\n            return urn.split(\":\")[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prevnext(resource):\n        _prev, _next = False, False\n        resource = xmlparser(resource)\n        prevnext = resource.xpath(\"//ti:prevnext\", namespaces=XPATH_NAMESPACES)\n\n        if len(prevnext) > 0:\n            _next, _prev = None, None\n            prevnext = prevnext[0]\n            _next_xpath = prevnext.xpath(\"ti:next/ti:urn/text()\", namespaces=XPATH_NAMESPACES, smart_strings=False)\n            _prev_xpath = prevnext.xpath(\"ti:prev/ti:urn/text()\", namespaces=XPATH_NAMESPACES, smart_strings=False)\n\n            if len(_next_xpath):\n                _next = _next_xpath[0].split(\":\")[-1]\n\n            if len(_prev_xpath):\n                _prev = _prev_xpath[0].split(\":\")[-1]\n\n        return _prev, _next", "response": "Parse a resource to get the prev and next urn\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reffs(self):\n        if not self.citation.is_set():\n            self.getLabel()\n        return [\n            reff for reffs in [self.getValidReff(level=i) for i in range(1, len(self.citation) + 1)] for reff in reffs\n        ]", "response": "Get all valid reffs for every part of the CtsText\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export(self, output=Mimetypes.PLAINTEXT, exclude=None, **kwargs):\n        return self.getTextualNode().export(output, exclude)", "response": "Exports the collection item in the Mimetype required."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the previous passage identifier at same level as the current passage.", "response": "def prevId(self):\n        \"\"\" Previous passage Identifier\n\n        :rtype: CtsPassage\n        :returns: Previous passage at same level\n        \"\"\"\n        if self._prev_id is False:\n            # Request the next urn\n            self._prev_id, self._next_id = self.getPrevNextUrn(reference=self.urn.reference)\n        return self._prev_id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nextId(self):\n        if self._next_id is False:\n            # Request the next urn\n            self._prev_id, self._next_id = self.getPrevNextUrn(reference=self.urn.reference)\n        return self._next_id", "response": "Get the next passage identifier for this object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse(self):\n        self.response = self.resource\n        self.resource = self.resource.xpath(\"//ti:passage/tei:TEI\", namespaces=XPATH_NAMESPACES)[0]\n\n        self._prev_id, self._next_id = _SharedMethod.prevnext(self.response)\n\n        if not self.citation.is_set() and len(self.resource.xpath(\"//ti:citation\", namespaces=XPATH_NAMESPACES)):\n            self.citation = CtsCollection.XmlCtsCitation.ingest(\n                self.response,\n                xpath=\".//ti:citation[not(ancestor::ti:citation)]\"\n            )", "response": "Given self. resource split information from the CTS API\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_user_token(self):\n        headers = { 'User-Agent': self.user_agent(),\n                'Host': self.domain(),\n                'Accept': '*/*',\n        }\n        headers.update(self.headers())\n        r = requests.get(   self.portals_url()+'/users/_this/token',\n                            headers=headers,\n                            auth=self.auth())\n        if HTTP_STATUS.OK == r.status_code:\n            return r.text\n        else:\n            print(\"get_user_token: Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            r.raise_for_status()", "response": "Gets a user s authorization token for session reuse."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new device to the system.", "response": "def add_device(self, model, serial):\n        \"\"\"\n            Returns 'device object' of newly created device.\n\n            http://docs.exosite.com/portals/#create-device\n            http://docs.exosite.com/portals/#device-object\n        \"\"\"\n        device = {\n                'model': model,\n                'vendor': self.vendor(),\n                'sn': serial,\n                'type': 'vendor'\n        }\n        headers = {\n                'User-Agent': self.user_agent(),\n        }\n        headers.update(self.headers())\n\n        r = requests.post(  self.portals_url()+'/portals/'+self.portal_id()+'/devices', \n                                data=json.dumps(device),\n                                headers=headers,\n                                auth=self.auth())\n\n        if HTTP_STATUS.ADDED == r.status_code:\n            # fix the 'meta' to be dictionary instead of string\n            device_obj = r.json()\n            return dictify_device_meta(device_obj)\n        else:\n            print(\"add_device: Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            r.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_device(self, device_obj):\n        rid = device_obj['rid']\n        device_obj['info']['description']['meta'] = \\\n                json.dumps(device_obj['info']['description']['meta'])\n        headers = {\n                'User-Agent': self.user_agent(),\n        }\n        headers.update(self.headers())\n\n        r = requests.put(   self.portals_url()+'/devices/'+rid, \n                            data=json.dumps(device_obj),\n                            headers=headers,\n                            auth=self.auth())\n        if HTTP_STATUS.OK == r.status_code:\n            # fix the 'meta' to be dictionary instead of string\n            updated_dev_obj = r.json()\n            updated_dev_obj['info']['description']['meta'] =\\\n                            json.loads(device_obj['info']['description']['meta'])\n            return updated_dev_obj\n        else:\n            print(\"update_device: Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            r.raise_for_status()", "response": "Implements the Update device Portals API.\n            \n            is used to update the related object of a specific device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimplement the Update device Portals API.", "response": "def update_portal(self, portal_obj):\n        \"\"\" Implements the Update device Portals API.\n\n            This function is extremely dangerous. The portal object\n            you pass in will completely overwrite the portal.\n            \n            http://docs.exosite.com/portals/#update-portal\n        \"\"\"\n        headers = {\n                'User-Agent': self.user_agent(),\n        }\n        headers.update(self.headers())\n\n        r = requests.put(   self.portals_url()+'/portals/'+self.portal_id(), \n                            data=json.dumps(portal_obj),\n                            headers=headers,\n                            auth=self.auth())\n        if HTTP_STATUS.OK == r.status_code:\n            return r.json()\n        else:\n            print(\"update_portal: Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            r.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_device(self, rid):\n        headers = {\n                'User-Agent': self.user_agent(),\n                'Content-Type': self.content_type()\n        }\n        headers.update(self.headers())\n\n        url = self.portals_url()+'/devices/'+rid\n        # print(\"URL: {0}\".format(url))\n\n        r = requests.get(   url,\n                            headers=headers,\n                            auth=self.auth())\n    \n        if HTTP_STATUS.OK == r.status_code:\n            # fix the 'meta' to be dictionary instead of string\n            device_obj = r.json()\n            # device_obj['info']['description']['meta'] = \\\n                    # json.loads(device_obj['info']['description']['meta'])\n            return device_obj\n        else:\n            print(\"get_device: Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            r.raise_for_status()", "response": "Retrieve the device object for a given RID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_multiple_devices(self, rids):\n        headers = {\n                'User-Agent': self.user_agent(),\n                'Content-Type': self.content_type()\n        }\n        headers.update(self.headers())\n\n        url = self.portals_url()+'/users/_this/devices/' + str(rids).replace(\"'\", \"\").replace(' ','')\n        # print(\"URL: {0}\".format(url))\n        r = requests.get(   url,\n                            headers=headers,\n                            auth=self.auth())\n    \n        if HTTP_STATUS.OK == r.status_code:\n            # TODO: loop through all rids and fix 'meta' to be dict like add_device and get_device do\n            return r.json()\n        else:\n            print(\"get_multiple_devices: Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            r.raise_for_status()", "response": "Implements the Get Multiple Devices API."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_token(self, user_id, permission_obj):\n\n        headers = {\n                'User-Agent': self.user_agent(),\n                'Content-Type': self.content_type()\n        }\n        headers.update(self.headers())\n\n        url = self.portals_url()+'/users/{0}/permissions'.format(user_id)\n        # print(\"URL: {0}\".format(url))\n        r = requests.post(  url,\n                            data=permission_obj,\n                            headers=headers,\n                            auth=self.auth())\n    \n        if HTTP_STATUS.OK == r.status_code:\n            return r.json()\n        else:\n            print(\"create_token: Something went wrong: <{0}>: {1}\".format(\n                        r.status_code, r.reason))\n            r.raise_for_status()", "response": "Creates a new token for a user."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate thermal pressure for Dorogokupets 2015", "response": "def dorogokupets2015_pth(v, temp, v0, gamma0, gamma_inf, beta, theta01,\n                         m1, theta02, m2, n, z, t_ref=300.,\n                         three_r=3. * constants.R):\n    \"\"\"\n    calculate thermal pressure for Dorogokupets 2015 EOS\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature in K\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param gamma_inf: Gruneisen parameter at infinite pressure\n    :param beta: volume dependence of Gruneisen parameter\n    :param theta01: Debye temperature at 1 bar in K\n    :param m1: weighting factor, see Dorogokupets 2015 for detail\n    :param theta02: Debye temperature at 1 bar in K\n    :param m2: weighting factor, see Dorogokupets 2015 for detail\n    :param n: number of elements in a chemical formula\n    :param z: number of formula unit in a unit cell\n    :param three_r: 3 times gas constant.\n        Jamieson modified this value to compensate for mismatches\n    :param t_ref: reference temperature, 300 K\n    :return: thermal pressure in GPa\n    \"\"\"\n    # x = v / v0\n    # a = a0 * np.power(x, m)\n    v_mol = vol_uc2mol(v, z)\n    gamma = altshuler_grun(v, v0, gamma0, gamma_inf, beta)\n    theta1 = altshuler_debyetemp(v, v0, gamma0, gamma_inf, beta, theta01)\n    theta2 = altshuler_debyetemp(v, v0, gamma0, gamma_inf, beta, theta02)\n    if isuncertainties([v, temp, v0, gamma0, gamma_inf, beta,\n                        theta01, m1, theta02, m2]):\n        term_h1 = m1 / (m1 + m2) * three_r * n * gamma / v_mol * \\\n            (theta1 / (unp.exp(theta1 / temp) - 1.))\n        term_h2 = m2 / (m1 + m2) * three_r * n * gamma / v_mol * \\\n            (theta2 / (unp.exp(theta2 / temp) - 1.))\n        term_h1_ref = m1 / (m1 + m2) * three_r * n * gamma / v_mol * \\\n            (theta1 / (unp.exp(theta1 / t_ref) - 1.))\n        term_h2_ref = m2 / (m1 + m2) * three_r * n * gamma / v_mol * \\\n            (theta2 / (unp.exp(theta2 / t_ref) - 1.))\n    else:\n        term_h1 = m1 / (m1 + m2) * three_r * n * gamma / v_mol * \\\n            (theta1 / (np.exp(theta1 / temp) - 1.))\n        term_h2 = m2 / (m1 + m2) * three_r * n * gamma / v_mol * \\\n            (theta2 / (np.exp(theta2 / temp) - 1.))\n        term_h1_ref = m1 / (m1 + m2) * three_r * n * gamma / v_mol * \\\n            (theta1 / (np.exp(theta1 / t_ref) - 1.))\n        term_h2_ref = m2 / (m1 + m2) * three_r * n * gamma / v_mol * \\\n            (theta2 / (np.exp(theta2 / t_ref) - 1.))\n    p_th = term_h1 * 1.e-9 + term_h2 * 1.e-9\n    p_th_ref = term_h1_ref * 1.e-9 + term_h2_ref * 1.e-9\n    return (p_th - p_th_ref)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall an endpoint given the parameters", "response": "def call(self, route, parameters, mimetype=\"application/ld+json\", defaults=None):\n        \"\"\" Call an endpoint given the parameters\n\n        :param route: Named of the route which is called\n        :type route: str\n        :param parameters: Dictionary of parameters\n        :type parameters: dict\n        :param mimetype: Mimetype to require\n        :type mimetype: str\n        :rtype: text\n        \"\"\"\n        if not defaults:\n            defaults = {}\n        parameters = {\n            key: str(parameters[key])\n            for key in parameters\n            if parameters[key] is not None and\n               parameters[key] != defaults.get(key, None)\n        }\n        parameters.update(self.routes[route].query_dict)\n\n        request = requests.get(\n            self.routes[route].path,\n            params=parameters,\n            headers={\n                \"Accept\": mimetype,\n                \"Accept-Charset\": \"utf-8\",\n                \"User-Agent\": \"MyCapytain/{MyCapVersion} {DefaultRequestUA}\".format(\n                    MyCapVersion=__version__,\n                    DefaultRequestUA=requests.utils.default_user_agent()\n                )\n            }\n        )\n        request.raise_for_status()\n        if request.encoding is None:\n            request.encoding = \"utf-8\"\n        return request"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves the main routes of the DTS Collection", "response": "def routes(self):\n        \"\"\" Retrieves the main routes of the DTS Collection\n\n        Response format expected :\n            {\n              \"@context\": \"/dts/api/contexts/EntryPoint.jsonld\",\n              \"@id\": \"/dts/api/\",\n              \"@type\": \"EntryPoint\",\n              \"collections\": \"/dts/api/collections/\",\n              \"documents\": \"/dts/api/documents/\",\n              \"navigation\" : \"/dts/api/navigation\"\n            }\n\n        :returns: Dictionary of main routes with their path\n        :rtype: dict\n        \"\"\"\n        if self._routes:\n            return self._routes\n\n        request = requests.get(self.endpoint)\n        request.raise_for_status()\n        data = request.json()\n        self._routes = {\n            \"collections\": parse_uri(data[\"collections\"], self.endpoint),\n            \"documents\": parse_uri(data[\"documents\"], self.endpoint),\n            \"navigation\": parse_uri(data[\"navigation\"], self.endpoint)\n        }\n        return self._routes"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_collection(self, collection_id=None, nav=\"children\", page=None):\n        return self.call(\n            \"collections\",\n            {\n                \"id\": collection_id,\n                \"nav\": nav,\n                \"page\": page\n            },\n            defaults={\n                \"id\": None,\n                \"nav\": \"children\",\n                \"page\": 1\n            }\n        )", "response": "Makes a call to the API\n            API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a navigation request on the DTS API.", "response": "def get_navigation(\n            self, collection_id, level=None, ref=None,\n            group_by=None, max_=None, exclude=None, page=None):\n        \"\"\" Make a navigation request on the DTS API\n\n        :param collection_id: Id of the collection\n        :param level: Lever at which the references should be listed\n        :param ref: If ref is a tuple, it is treated as a range. String or int are treated as single ref\n        :param group_by: Size of the ranges the server should produce\n        :param max_: Maximum number of results\n        :param exclude: Exclude specific metadata.\n        :param page: Page\n        :return: Response\n        :rtype: requests.Response\n        \"\"\"\n        parameters = {\n            \"id\": collection_id,\n            \"level\": level,\n            \"groupBy\": group_by,\n            \"max\": max_,\n            \"exclude\": exclude,\n            \"page\": page\n        }\n        _parse_ref_parameters(parameters, ref)\n\n        return self.call(\n            \"navigation\",\n            parameters\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a navigation request on the DTS API.", "response": "def get_document(\n            self,\n            collection_id, ref=None, mimetype=\"application/tei+xml, application/xml\"):\n        \"\"\" Make a navigation request on the DTS API\n\n        :param collection_id: Id of the collection\n        :param ref: If ref is a tuple, it is treated as a range. String or int are treated as single ref\n        :param mimetype: Media type to request\n        :return: Response\n        :rtype: requests.Response\n        \"\"\"\n        parameters = {\n            \"id\": collection_id\n        }\n        _parse_ref_parameters(parameters, ref)\n\n        return self.call(\n            \"documents\",\n            parameters,\n            mimetype=mimetype\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates the glance database", "response": "def _create_glance_db(self, root_db_pass, glance_db_pass):\r\n        \"\"\"Create the glance database\"\"\"\r\n        print red(env.host_string + ' | Create glance database')\r\n        sudo(\r\n            \"mysql -uroot -p{0} -e \\\"CREATE DATABASE glance;\\\"\".format(root_db_pass), shell=False)\r\n        sudo(\"mysql -uroot -p{0} -e \\\"GRANT ALL PRIVILEGES ON glance.* TO 'glance'@'localhost' IDENTIFIED BY '{1}';\\\"\".format(\r\n            root_db_pass, glance_db_pass), shell=False)\r\n        sudo(\"mysql -uroot -p{0} -e \\\"GRANT ALL PRIVILEGES ON glance.* TO 'glance'@'%' IDENTIFIED BY '{1}';\\\"\".format(\r\n            root_db_pass, glance_db_pass), shell=False)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef chain(self, token: 'CancelToken') -> 'CancelToken':\n        if self.loop != token._loop:\n            raise EventLoopMismatch(\"Chained CancelToken objects must be on the same event loop\")\n        chain_name = \":\".join([self.name, token.name])\n        chain = CancelToken(chain_name, loop=self.loop)\n        chain._chain.extend([self, token])\n        return chain", "response": "Returns a new CancelToken that is the same as this one and the given token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef triggered_token(self) -> 'CancelToken':\n        if self._triggered.is_set():\n            return self\n        for token in self._chain:\n            if token.triggered:\n                # Use token.triggered_token here to make the lookup recursive as self._chain may\n                # contain other chains.\n                return token.triggered_token\n        return None", "response": "Return the token which was triggered."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef triggered(self) -> bool:\n        if self._triggered.is_set():\n            return True\n        return any(token.triggered for token in self._chain)", "response": "Return True if this token has been triggered."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def wait(self) -> None:\n        if self.triggered_token is not None:\n            return\n\n        futures = [asyncio.ensure_future(self._triggered.wait(), loop=self.loop)]\n        for token in self._chain:\n            futures.append(asyncio.ensure_future(token.wait(), loop=self.loop))\n\n        def cancel_not_done(fut: 'asyncio.Future[None]') -> None:\n            for future in futures:\n                if not future.done():\n                    future.cancel()\n\n        async def _wait_for_first(futures: Sequence[Awaitable[Any]]) -> None:\n            for future in asyncio.as_completed(futures):\n                # We don't need to catch CancelledError here (and cancel not done futures)\n                # because our callback (above) takes care of that.\n                await cast(Awaitable[Any], future)\n                return\n\n        fut = asyncio.ensure_future(_wait_for_first(futures), loop=self.loop)\n        fut.add_done_callback(cancel_not_done)\n        await fut", "response": "Coroutine which returns when this token has been triggered"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def cancellable_wait(self, *awaitables: Awaitable[_R], timeout: float = None) -> _R:\n        futures = [asyncio.ensure_future(a, loop=self.loop) for a in awaitables + (self.wait(),)]\n        try:\n            done, pending = await asyncio.wait(\n                futures,\n                timeout=timeout,\n                return_when=asyncio.FIRST_COMPLETED,\n                loop=self.loop,\n            )\n        except asyncio.futures.CancelledError:\n            # Since we use return_when=asyncio.FIRST_COMPLETED above, we can be sure none of our\n            # futures will be done here, so we don't need to check if any is done before cancelling.\n            for future in futures:\n                future.cancel()\n            raise\n        for task in pending:\n            task.cancel()\n        if not done:\n            raise TimeoutError()\n        if self.triggered_token is not None:\n            # We've been asked to cancel so we don't care about our future, but we must\n            # consume its exception or else asyncio will emit warnings.\n            for task in done:\n                task.exception()\n            raise OperationCancelled(\n                \"Cancellation requested by {} token\".format(self.triggered_token)\n            )\n        return done.pop().result()", "response": "Wait for the first awaitable to complete."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the parent of the current entry.", "response": "def parent(self) -> Optional['CtsReference']:\n        \"\"\" Parent of the actual URN, for example, 1.1 for 1.1.1\n\n        :rtype: CtsReference\n        \"\"\"\n        if self.start.depth == 1 and (self.end is None or self.end.depth <= 1):\n            return None\n        else:\n            if self.start.depth > 1 and (self.end is None or self.end.depth == 0):\n                return CtsReference(\"{0}{1}\".format(\n                    \".\".join(self.start.list[:-1]),\n                    self.start.subreference or \"\"\n                ))\n            elif self.start.depth > 1 and self.end is not None and self.end.depth > 1:\n                _start = self.start.list[0:-1]\n                _end = self.end.list[0:-1]\n                if _start == _end and \\\n                        self.start.subreference is None and \\\n                        self.end.subreference is None:\n                    return CtsReference(\n                        \".\".join(_start)\n                    )\n                else:\n                    return CtsReference(\"{0}{1}-{2}{3}\".format(\n                        \".\".join(_start),\n                        self.start.subreference or \"\",\n                        \".\".join(_end),\n                        self.end.subreference or \"\"\n                    ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef highest(self) -> CtsSinglePassageId:\n        if not self.end:\n            return self.start\n        elif len(self.start) < len(self.end) and len(self.start):\n            return self.start\n        elif len(self.start) > len(self.end) and len(self.end):\n            return self.end\n        elif len(self.start):\n            return self.start", "response": "Return the highest reference level for the current ctsSinglePassageId."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the urn up to given level using URN constants", "response": "def upTo(self, key):\n        \"\"\" Returns the urn up to given level using URN Constants\n\n        :param key: Identifier of the wished resource using URN constants\n        :type key: int\n        :returns: String representation of the partial URN requested\n        :rtype: str\n\n        :Example:\n            >>>    a = URN(urn=\"urn:cts:latinLit:phi1294.phi002.perseus-lat2:1.1\")\n            >>>    a.upTo(URN.TEXTGROUP) == \"urn:cts:latinLit:phi1294\"\n        \"\"\"\n        middle = [\n            component\n            for component in [self.__parsed[\"textgroup\"], self.__parsed[\"work\"], self.__parsed[\"version\"]]\n            if component is not None\n        ]\n\n        if key == URN.COMPLETE:\n            return self.__str__()\n        elif key == URN.NAMESPACE:\n            return \":\".join([\n                \"urn\",\n                self.__parsed[\"urn_namespace\"],\n                self.__parsed[\"cts_namespace\"]])\n        elif key == URN.TEXTGROUP and self.__parsed[\"textgroup\"]:\n            return \":\".join([\n                \"urn\",\n                self.__parsed[\"urn_namespace\"],\n                self.__parsed[\"cts_namespace\"],\n                self.__parsed[\"textgroup\"]\n            ])\n        elif key == URN.WORK and self.__parsed[\"work\"]:\n            return \":\".join([\n                \"urn\",\n                self.__parsed[\"urn_namespace\"],\n                self.__parsed[\"cts_namespace\"],\n                \".\".join([self.__parsed[\"textgroup\"], self.__parsed[\"work\"]])\n            ])\n        elif key == URN.VERSION and self.__parsed[\"version\"]:\n            return \":\".join([\n                \"urn\",\n                self.__parsed[\"urn_namespace\"],\n                self.__parsed[\"cts_namespace\"],\n                \".\".join(middle)\n            ])\n        elif key == URN.NO_PASSAGE and self.__parsed[\"work\"]:\n            return \":\".join([\n                \"urn\",\n                self.__parsed[\"urn_namespace\"],\n                self.__parsed[\"cts_namespace\"],\n                \".\".join(middle)\n            ])\n        elif key == URN.PASSAGE and self.__parsed[\"reference\"]:\n            return \":\".join([\n                \"urn\",\n                self.__parsed[\"urn_namespace\"],\n                self.__parsed[\"cts_namespace\"],\n                \".\".join(middle),\n                str(self.reference)\n            ])\n        elif key == URN.PASSAGE_START and self.__parsed[\"reference\"]:\n            return \":\".join([\n                \"urn\",\n                self.__parsed[\"urn_namespace\"],\n                self.__parsed[\"cts_namespace\"],\n                \".\".join(middle),\n                str(self.reference.start)\n            ])\n        elif key == URN.PASSAGE_END and self.__parsed[\"reference\"] and self.reference.end is not None:\n            return \":\".join([\n                \"urn\",\n                self.__parsed[\"urn_namespace\"],\n                self.__parsed[\"cts_namespace\"],\n                \".\".join(middle),\n                str(self.reference.end)\n            ])\n        else:\n            raise KeyError(\"Provided key is not recognized.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef attribute(self):\n        refs = re.findall(\n            \"\\@([a-zA-Z:]+)=\\\\\\?[\\'\\\"]\\$\"+str(self.refsDecl.count(\"$\"))+\"\\\\\\?[\\'\\\"]\",\n            self.refsDecl\n        )\n        return refs[-1]", "response": "Attribute that serves as a reference getter\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parseXpathScope(self):\n        rd = self.refsDecl\n        matches = REFSDECL_SPLITTER.findall(rd)\n        return REFSDECL_REPLACER.sub(\"?\", \"\".join(matches[0:-1])), REFSDECL_REPLACER.sub(\"?\", matches[-1])", "response": "Update xpath and scope property when refsDecl is updated\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates xpath and scope property when refsDecl is updated", "response": "def _fromScopeXpathToRefsDecl(self, scope, xpath):\n        \"\"\" Update xpath and scope property when refsDecl is updated\n\n        \"\"\"\n        if scope is not None and xpath is not None:\n            _xpath = scope + xpath\n            i = _xpath.find(\"?\")\n            ii = 1\n            while i >= 0:\n                _xpath = _xpath[:i] + \"$\" + str(ii) + _xpath[i+1:]\n                i = _xpath.find(\"?\")\n                ii += 1\n            self.refsDecl = _xpath"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a passageId matches a citation level returns True if the citation level matches the citation level otherwise False.", "response": "def match(self, passageId):\n        \"\"\" Given a passageId matches a citation level\n\n        :param passageId: A passage to match\n        :return:\n        \"\"\"\n        if not isinstance(passageId, CtsReference):\n            passageId = CtsReference(passageId)\n\n        if self.is_root():\n            return self[passageId.depth-1]\n        return self.root.match(passageId)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfills the xpath with given informations", "response": "def fill(self, passage=None, xpath=None):\n        \"\"\" Fill the xpath with given informations\n\n        :param passage: CapitainsCtsPassage reference\n        :type passage: CtsReference or list or None. Can be list of None and not None\n        :param xpath: If set to True, will return the replaced self.xpath value and not the whole self.refsDecl\n        :type xpath: Boolean\n        :rtype: basestring\n        :returns: Xpath to find the passage\n\n        .. code-block:: python\n\n            citation = XmlCtsCitation(name=\"line\", scope=\"/TEI/text/body/div/div[@n=\\\"?\\\"]\",xpath=\"//l[@n=\\\"?\\\"]\")\n            print(citation.fill([\"1\", None]))\n            # /TEI/text/body/div/div[@n='1']//l[@n]\n            print(citation.fill(None))\n            # /TEI/text/body/div/div[@n]//l[@n]\n            print(citation.fill(CtsReference(\"1.1\"))\n            # /TEI/text/body/div/div[@n='1']//l[@n='1']\n            print(citation.fill(\"1\", xpath=True)\n            # //l[@n='1']\n\n\n        \"\"\"\n        if xpath is True:  # Then passage is a string or None\n            xpath = self.xpath\n\n            replacement = r\"\\1\"\n            if isinstance(passage, str):\n                replacement = r\"\\1\\2'\" + passage + \"'\"\n\n            return REFERENCE_REPLACER.sub(replacement, xpath)\n        else:\n            if isinstance(passage, CtsReference):\n                passage = passage.start.list\n            elif passage is None:\n                return REFERENCE_REPLACER.sub(\n                    r\"\\1\",\n                    self.refsDecl\n                )\n            passage = iter(passage)\n            return REFERENCE_REPLACER.sub(\n                lambda m: _ref_replacer(m, passage),\n                self.refsDecl\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ningest a resource and store data in its instance", "response": "def ingest(resource, xpath=\".//tei:cRefPattern\"):\n        \"\"\" Ingest a resource and store data in its instance\n\n        :param resource: XML node cRefPattern or list of them in ASC hierarchy order (deepest to highest, eg. lines to poem to book)\n        :type resource: [lxml.etree._Element]\n        :param xpath: XPath to use to retrieve citation\n        :type xpath: str\n\n        :returns: A citation object\n        :rtype: Citation\n        \"\"\"\n        if len(resource) == 0 and isinstance(resource, list):\n            return None\n        elif isinstance(resource, list):\n            resource = resource[0]\n        elif not isinstance(resource, _Element):\n            return None\n\n        resource = resource.xpath(xpath, namespaces=XPATH_NAMESPACES)\n        citations = []\n\n        for x in range(0, len(resource)):\n            citations.append(\n                Citation(\n                    name=resource[x].get(\"n\"),\n                    refsDecl=resource[x].get(\"replacementPattern\")[7:-1],\n                    child=_child_or_none(citations)\n                )\n            )\n        if len(citations) > 1:\n            for citation in citations[:-1]:\n                citation.root = citations[-1]\n        return citations[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the contents of the output files retrieved in the FolderData.", "response": "def parse(self, **kwargs):\n        \"\"\"Parse the contents of the output files retrieved in the `FolderData`.\"\"\"\n        try:\n            output_folder = self.retrieved\n        except exceptions.NotExistent:\n            return self.exit_codes.ERROR_NO_RETRIEVED_FOLDER\n\n        filename_stdout = self.node.get_attribute('output_filename')\n        filename_stderr = self.node.get_attribute('error_filename')\n\n        try:\n            with output_folder.open(filename_stderr, 'r') as handle:\n                exit_code = self.parse_stderr(handle)\n        except (OSError, IOError):\n            self.logger.exception('Failed to read the stderr file\\n%s', traceback.format_exc())\n            return self.exit_codes.ERROR_READING_ERROR_FILE\n\n        if exit_code:\n            return exit_code\n\n        try:\n            with output_folder.open(filename_stdout, 'r') as handle:\n                handle.seek(0)\n                exit_code = self.parse_stdout(handle)\n        except (OSError, IOError):\n            self.logger.exception('Failed to read the stdout file\\n%s', traceback.format_exc())\n            return self.exit_codes.ERROR_READING_OUTPUT_FILE\n\n        if exit_code:\n            return exit_code"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the content written by the script to standard out into a CifData object.", "response": "def parse_stdout(self, filelike):\n        \"\"\"Parse the content written by the script to standard out into a `CifData` object.\n\n        :param filelike: filelike object of stdout\n        :returns: an exit code in case of an error, None otherwise\n        \"\"\"\n        from CifFile import StarError\n\n        if not filelike.read().strip():\n            return self.exit_codes.ERROR_EMPTY_OUTPUT_FILE\n\n        try:\n            filelike.seek(0)\n            cif = CifData(file=filelike)\n        except StarError:\n            self.logger.exception('Failed to parse a `CifData` from the stdout file\\n%s', traceback.format_exc())\n            return self.exit_codes.ERROR_PARSING_CIF_DATA\n        else:\n            self.out('cif', cif)\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the content written by the script to standard err.", "response": "def parse_stderr(self, filelike):\n        \"\"\"Parse the content written by the script to standard err.\n\n        :param filelike: filelike object of stderr\n        :returns: an exit code in case of an error, None otherwise\n        \"\"\"\n        marker_error = 'ERROR,'\n        marker_warning = 'WARNING,'\n\n        messages = {'errors': [], 'warnings': []}\n\n        for line in filelike.readlines():\n            if marker_error in line:\n                messages['errors'].append(line.split(marker_error)[-1].strip())\n            if marker_warning in line:\n                messages['warnings'].append(line.split(marker_warning)[-1].strip())\n\n        if self.node.get_option('attach_messages'):\n            self.out('messages', Dict(dict=messages))\n\n        for error in messages['errors']:\n            if 'unknown option' in error:\n                return self.exit_codes.ERROR_INVALID_COMMAND_LINE_OPTION\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresetting the registry to the standard multihash functions.", "response": "def reset(cls):\n        \"\"\"Reset the registry to the standard multihash functions.\"\"\"\n        # Maps function names (hyphens or underscores) to registered functions.\n        cls._func_from_name = {}\n\n        # Maps hashlib names to registered functions.\n        cls._func_from_hash = {}\n\n        # Hashlib compatibility data by function.\n        cls._func_hash = {}\n\n        register = cls._do_register\n        for (func, hash_name, hash_new) in cls._std_func_data:\n            register(func, func.name, hash_name, hash_new)\n        assert set(cls._func_hash) == set(Func)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(cls, func_hint):\n        # Different possibilities of `func_hint`, most to least probable.\n        try:  # `Func` member (or its value)\n            return Func(func_hint)\n        except ValueError:\n            pass\n        if func_hint in cls._func_from_name:  # `Func` member name, extended\n            return cls._func_from_name[func_hint]\n        if func_hint in cls._func_hash:  # registered app-specific code\n            return func_hint\n        raise KeyError(\"unknown hash function\", func_hint)", "response": "Return a registered hash function matching the given hint."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _do_register(cls, code, name, hash_name=None, hash_new=None):\n        cls._func_from_name[name.replace('-', '_')] = code\n        cls._func_from_name[name.replace('_', '-')] = code\n        if hash_name:\n            cls._func_from_hash[hash_name] = code\n        cls._func_hash[code] = cls._hash(hash_name, hash_new)", "response": "Add hash function data to the registry without checks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(cls, code, name, hash_name=None, hash_new=None):\n        if not _is_app_specific_func(code):\n            raise ValueError(\n                \"only application-specific functions can be registered\")\n        # Check already registered name in different mappings.\n        name_mapping_data = [  # (mapping, name in mapping, error if existing)\n            (cls._func_from_name, name,\n             \"function name is already registered for a different function\"),\n            (cls._func_from_hash, hash_name,\n             \"hashlib name is already registered for a different function\")]\n        for (mapping, nameinmap, errmsg) in name_mapping_data:\n            existing_func = mapping.get(nameinmap, code)\n            if existing_func != code:\n                raise ValueError(errmsg, existing_func)\n        # Unregister if existing to ensure no orphan entries.\n        if code in cls._func_hash:\n            cls.unregister(code)\n        # Proceed to registration.\n        cls._do_register(code, name, hash_name, hash_new)", "response": "Add an application - specific function to the registry."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unregister(cls, code):\n        if code in Func:\n            raise ValueError(\n                \"only application-specific functions can be unregistered\")\n        # Remove mapping to function by name.\n        func_names = {n for (n, f) in cls._func_from_name.items() if f == code}\n        for func_name in func_names:\n            del cls._func_from_name[func_name]\n        # Remove hashlib data and mapping to hash.\n        hash = cls._func_hash.pop(code)\n        if hash.name:\n            del cls._func_from_hash[hash.name]", "response": "Remove an application - specific function from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hash_from_func(cls, func):\n        new = cls._func_hash[func].new\n        return new() if new else None", "response": "Return a hashlib - compatible object for the multihash func."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nplot P - V - T data for the current thermal process", "response": "def thermal_data(data, figsize=(12, 4), ms_data=50,\n                 v_label='Unit-cell volume $(\\mathrm{\\AA}^3)$',\n                 pdf_filen=None, title='P-V-T data'):\n    \"\"\"\n    plot P-V-T data before fitting\n\n    :param data: {'p': unumpy array, 'v': unumpy array, 'temp': unumpy array}\n    :param eoscurves: {'v': unumpy array, '300': unumpy array\n            at the temperature ....}\n    :param v_label: label for volume axis\n    :param figsize: figure size\n    :param ms_data: marker size for data points\n    :param pdf_filen: name of pdf output file\n    :param title: title of the figure\n    :return: None\n    \"\"\"\n    # basic figure setup\n    f, ax = plt.subplots(1, 2, figsize=figsize, sharex=True)\n\n    # read data to plot\n    if isuncertainties([data['p'], data['v'], data['temp']]):\n        p = unp.nominal_values(data['p'])\n        v = unp.nominal_values(data['v'])\n        temp = unp.nominal_values(data['temp'])\n        sp = unp.std_devs(data['p'])\n        sv = unp.std_devs(data['v'])\n        stemp = unp.std_devs(data['temp'])\n        ax[0].errorbar(p, v, xerr=sp, yerr=sv, marker=' ',\n                       c='k', ms=0, mew=0, linestyle='None',\n                       capsize=0, lw=0.5, zorder=1)\n        ax[1].errorbar(p, temp, xerr=sp, yerr=stemp, marker=' ',\n                       c='k', ms=0, mew=0, linestyle='None',\n                       capsize=0, lw=0.5, zorder=1)\n    else:\n        p = data['p']\n        v = data['v']\n        temp = data['temp']\n    points = ax[0].scatter(p, v, marker='o', s=ms_data, c=temp,\n                           cmap=c_map, vmin=300., vmax=temp.max(), zorder=2)\n    points = ax[1].scatter(p, temp, marker='o', s=ms_data, c=temp,\n                           cmap=c_map, vmin=300., vmax=temp.max(), zorder=2)\n\n    ax[0].set_xlabel('Pressure (GPa)')\n    ax[1].set_xlabel('Pressure (GPa)')\n    ax[0].set_ylabel(v_label)\n    ax[1].set_ylabel('Temperature (K)')\n    f.suptitle(title)\n    # the parameters are the specified position you set\n    position = f.add_axes([0.92, 0.11, .01, 0.75])\n    f.colorbar(points, orientation=\"vertical\", cax=position)\n    # position.text(150., 0.5, 'Temperature (K)', fontsize=10,\n    # rotation=270, va='center')\n    if pdf_filen is not None:\n        f.savefig(pdf_filen)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef thermal_fit_result(fit_result, v_residual=None,\n                       v_label='Unit-cell volume $(\\mathrm{\\AA}^3)$',\n                       temp_fitline=np.asarray(\n                           [300., 1000., 1500., 2000., 2500., 3000.]),\n                       figsize=(5, 5), height_ratios=(3, 1), ms_data=50,\n                       p_err=None, v_err=None, cbar_loc=(0.99, 0.1, .01, 0.82),\n                       pdf_filen=None, title='Fit result'):\n    \"\"\"\n    plot P-V-T EOS curve fitting result\n\n    :param fit_result: lmfit result object, see example jnb file for detail\n    :param v_label: label for volume axis\n    :param temp_fitline: temperatures to calculate isothermal compression\n        curves, default = [300., 1000., 1500., 2000., 2500., 3000.]\n    :param figsize: figure size, default = (7,7)\n    :param height_ratios: height ratio between the main and residue plots,\n        default = (3,1)\n    :param ms_data: marker size for data points\n    :param p_err: pressure error bar\n    :param v_err: volume error bar\n    :param cbar_loc: location of color bar\n    :param pdf_filen: name of pdf output file\n    :param title: title of the figure\n    :return: None\n    \"\"\"\n    # basic figure setup\n    f, ax = plt.subplots(2, 1, sharex=True, figsize=figsize,\n                         gridspec_kw={'height_ratios': height_ratios})\n    for ax_i in ax:\n        ax_i.tick_params(direction='in')\n    # read data to plot\n    v_data = fit_result.userkws['v']\n    temp_data = fit_result.userkws['temp']\n    p_data = fit_result.data\n    p_datafit = fit_result.best_fit\n    v0 = uct.ufloat(fit_result.params['st_v0'].value,\n                    fit_result.params['st_v0'].stderr)\n    sm = plt.cm.ScalarMappable(cmap=c_map,\n                               norm=plt.Normalize(\n                                   vmin=300., vmax=temp_data.max()))\n    a = sm.to_rgba(temp_fitline)\n    v_fitline = np.linspace(v0.n, min(v_data), 1000)\n    fitmodel_copy = copy.deepcopy(fit_result)\n    for a_i, temp_i in zip(a, temp_fitline):\n        p_fitline = fitmodel_copy.eval(v=v_fitline,\n                                       temp=np.ones_like(v_fitline) * temp_i)\n        ax[0].plot(p_fitline, v_fitline, c=a_i)\n    # error range here does not make a lot sense, so not supported\n    # if (p_err is not None) and (v_err is not None):\n    ax[0].errorbar(p_data, v_data, xerr=p_err, yerr=v_err, fmt=' ', c='k',\n                   capsize=0, elinewidth=0.5, label='Data', zorder=0)\n    points = ax[0].scatter(p_data, v_data, marker='o', s=ms_data, c=temp_data,\n                           cmap=c_map, vmin=300., vmax=temp_data.max(),\n                           zorder=1)\n    if v_residual is None:\n        ax[1].scatter(p_data, p_data - p_datafit, marker='o', s=ms_data,\n                      c=temp_data, cmap=c_map, vmin=300.,\n                      vmax=temp_data.max(), zorder=1)\n        ax[1].errorbar(p_data, p_data - p_datafit, yerr=p_err, fmt=' ', c='k',\n                       capsize=0, elinewidth=0.5, label='Data', zorder=0)\n        ax[1].set_ylabel('$P_{obs} - P_{fit}$')\n    else:\n        ax[1].scatter(p_data, v_residual, marker='o', s=ms_data, c=temp_data,\n                      cmap=c_map, vmin=300., vmax=temp_data.max(), zorder=1)\n        ax[1].errorbar(p_data, v_residual, yerr=p_err, fmt=' ', c='k',\n                       capsize=0, elinewidth=0.5, label='Data', zorder=0)\n        ax[1].set_ylabel('$V_{obs} - V_{fit}$')\n    # ax[0].legend()\n    position = f.add_axes(cbar_loc)\n    f.colorbar(points, orientation=\"vertical\", cax=position,\n               ticks=temp_fitline)\n    ax[1].axhline(0, c='k', ls='--')\n    ax[1].set_xlabel('Pressure (GPa)')\n    ax[0].set_ylabel(v_label)\n    ax[0].set_title(title)\n    plt.tight_layout()\n    if pdf_filen is not None:\n        f.savefig(pdf_filen)", "response": "plot P - V - T EOS curve fitting result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the binary digest of data with the given func.", "response": "def _do_digest(data, func):\n    \"\"\"Return the binary digest of `data` with the given `func`.\"\"\"\n    func = FuncReg.get(func)\n    hash = FuncReg.hash_from_func(func)\n    if not hash:\n        raise ValueError(\"no available hash function for hash\", func)\n    hash.update(data)\n    return bytes(hash.digest())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef digest(data, func):\n    digest = _do_digest(data, func)\n    return Multihash(func, digest)", "response": "Hash the given data into a new Multihash."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decode(mhash, encoding=None):\n    mhash = bytes(mhash)\n    if encoding:\n        mhash = CodecReg.get_decoder(encoding)(mhash)\n    try:\n        func = mhash[0]\n        length = mhash[1]\n        digest = mhash[2:]\n    except IndexError as ie:\n        raise ValueError(\"multihash is too short\") from ie\n    if length != len(digest):\n        raise ValueError(\n            \"multihash length field does not match digest field length\")\n    return Multihash(func, digest)", "response": "r Decode a multihash - encoded digest into a Multihash object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_hash(self, hash):\n        try:\n            func = FuncReg.func_from_hash(hash)\n        except KeyError as ke:\n            raise ValueError(\n                \"no matching multihash function\", hash.name) from ke\n        digest = hash.digest()\n        return Multihash(func, digest)", "response": "Create a Multihash object from a hashlib - compatible hash object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef verify(self, data):\n        digest = _do_digest(data, self.func)\n        return digest[:len(self.digest)] == self.digest", "response": "r Does the given data hash to the digest in this Multihash?"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef truncate(self, length):\n        if length > len(self.digest):\n            raise ValueError(\"cannot enlarge the original digest by %d bytes\"\n                             % (length - len(self.digest)))\n        return self.__class__(self.func, self.digest[:length])", "response": "Return a new Multihash with a shorter digest length."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the VALUE for KEY predicate in the Metadata Graph", "response": "def set(self, key: URIRef, value: Union[Literal, BNode, URIRef, str, int], lang: Optional[str]=None):\n        \"\"\" Set the VALUE for KEY predicate in the Metadata Graph\n\n        :param key: Predicate to be set (eg. DCT.creator)\n        :param value: Value to be stored (eg. \"Cicero\")\n        :param lang: [Optional] Language of the value (eg. \"la\")\n        \"\"\"\n        if not isinstance(value, Literal) and lang is not None:\n            value = Literal(value, lang=lang)\n        elif not isinstance(value, (BNode, URIRef)):\n            value, _type = term._castPythonToLiteral(value)\n            if _type is None:\n                value = Literal(value)\n            else:\n                value = Literal(value, datatype=_type)\n        self.graph.set((self.asNode(), key, value))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, key, value, lang=None):\n        if not isinstance(value, Literal) and lang is not None:\n            value = Literal(value, lang=lang)\n        elif not isinstance(value, (BNode, URIRef)):\n            value, _type = term._castPythonToLiteral(value)\n            if _type is None:\n                value = Literal(value)\n            else:\n                value = Literal(value, datatype=_type)\n        self.graph.add((self.asNode(), key, value))", "response": "Adds a triple to the graph related to this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of triple related to this node. Can filter on lang", "response": "def get(self, key, lang=None):\n        \"\"\" Returns triple related to this node. Can filter on lang\n\n        :param key: Predicate of the triple\n        :param lang: Language of the triple if applicable\n        :rtype: Literal or BNode or URIRef\n        \"\"\"\n        if lang is not None:\n            for o in self.graph.objects(self.asNode(), key):\n                if o.language == lang:\n                    yield o\n        else:\n            for o in self.graph.objects(self.asNode(), key):\n                yield o"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_single(self, key, lang=None):\n        if not isinstance(key, URIRef):\n            key = URIRef(key)\n\n        if lang is not None:\n            default = None\n            for o in self.graph.objects(self.asNode(), key):\n                default = o\n                if o.language == lang:\n                    return o\n            return default\n        else:\n            for o in self.graph.objects(self.asNode(), key):\n                return o", "response": "Returns a single triple related to this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove(self, predicate=None, obj=None):\n        self.graph.remove((self.asNode(), predicate, obj))", "response": "Remove triple matching the predicate or the object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unlink(self, subj=None, predicate=None):\n        self.graph.remove((subj, predicate, self.asNode()))", "response": "Remove triple where Metadata is the object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getOr(subject, predicate, *args, **kwargs):\n        if (subject, predicate, None) in get_graph():\n            return Metadata(node=get_graph().objects(subject, predicate).__next__())\n        return Metadata(*args, **kwargs)", "response": "Retrieve a metadata node or generate a new one if it does not exist"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef launch_cif_import(group, database, max_entries, number_species, skip_partial_occupancies, importer_server,\n    importer_db_host, importer_db_name, importer_db_password, importer_api_url, importer_api_key, count_entries,\n    batch_count, dry_run, verbose):\n    \"\"\"Import cif files from various structural databases, store them as CifData nodes and add them to a Group.\n\n    Note that to determine which cif files are already contained within the Group in order to avoid duplication,\n    the attribute 'source.id' of the CifData is compared to the source id of the imported cif entry. Since there\n    is no guarantee that these id's do not overlap between different structural databases and we do not check\n    explicitly for the database, it is advised to use separate groups for different structural databases.\n    \"\"\"\n    # pylint: disable=too-many-arguments,too-many-locals,too-many-statements,too-many-branches,import-error\n    import inspect\n    from CifFile.StarFile import StarError\n    from datetime import datetime\n    from six.moves.urllib.error import HTTPError\n\n    from aiida import orm\n    from aiida.plugins import factories\n    from aiida_codtools.common.cli import echo_utc\n\n    if not count_entries and group is None:\n        raise click.BadParameter('you have to specify a group unless the option --count-entries is specified')\n\n    importer_parameters = {}\n    launch_paramaters = {}\n    query_parameters = {}\n\n    if importer_server is not None:\n        importer_parameters['server'] = importer_server\n\n    if importer_db_host is not None:\n        importer_parameters['host'] = importer_db_host\n\n    if importer_db_name is not None:\n        importer_parameters['db'] = importer_db_name\n\n    if importer_db_password is not None:\n        importer_parameters['passwd'] = importer_db_password\n\n    if importer_api_url is not None:\n        importer_parameters['url'] = importer_api_url\n\n    if importer_api_key is not None:\n        importer_parameters['api_key'] = importer_api_key\n\n    importer_class = factories.DbImporterFactory(database)\n    importer = importer_class(**importer_parameters)\n\n    if database == 'mpds':\n\n        if number_species is None:\n            raise click.BadParameter('the number of species has to be defined for the {} database'.format(database))\n\n        query_parameters = {\n            'query': {},\n            'collection': 'structures'\n        }\n\n        if number_species == 1:\n            query_parameters['query']['classes'] = 'unary'\n        elif number_species == 2:\n            query_parameters['query']['classes'] = 'binary'\n        elif number_species == 3:\n            query_parameters['query']['classes'] = 'ternary'\n        elif number_species == 4:\n            query_parameters['query']['classes'] = 'quaternary'\n        elif number_species == 5:\n            query_parameters['query']['classes'] = 'quinary'\n        else:\n            raise click.BadParameter('only unaries through quinaries are supported by the {} database'\n                .format(database), param_hint='number_species')\n\n    else:\n\n        if number_species is not None:\n            query_parameters['number_of_elements'] = number_species\n\n    # Collect the dictionary of not None parameters passed to the launch script and print to screen\n    local_vars = locals()\n    for arg in inspect.getargspec(launch_cif_import.callback).args:  # pylint: disable=deprecated-method\n        if arg in local_vars and local_vars[arg]:\n            launch_paramaters[arg] = local_vars[arg]\n\n    if not count_entries:\n        click.echo('=' * 80)\n        click.echo('Starting on {}'.format(datetime.utcnow().isoformat()))\n        click.echo('Launch parameters: {}'.format(launch_paramaters))\n        click.echo('Importer parameters: {}'.format(importer_parameters))\n        click.echo('Query parameters: {}'.format(query_parameters))\n        click.echo('-' * 80)\n\n    try:\n        query_results = importer.query(**query_parameters)\n    except Exception as exception:  # pylint: disable=broad-except\n        echo.echo_critical('database query failed: {}'.format(exception))\n\n    if not count_entries:\n        builder = orm.QueryBuilder()\n        builder.append(orm.Group, filters={'label': group.label}, tag='group')\n        builder.append(orm.CifData, with_group='group', project='attributes.source.id')\n        existing_source_ids = [entry[0] for entry in builder.all()]\n\n    counter = 0\n    batch = []\n\n    for entry in query_results:\n\n        # Some query result generators fetch in batches, so we cannot simply return the length of the result set\n        if count_entries:\n            counter += 1\n            continue\n\n        source_id = entry.source['id']\n\n        if source_id in existing_source_ids:\n            if verbose:\n                echo_utc('Cif<{}> skipping: already present in group {}'.format(source_id, group.label))\n            continue\n\n        try:\n            cif = entry.get_cif_node()\n        except (AttributeError, UnicodeDecodeError, StarError, HTTPError) as exception:\n            if verbose:\n                name = exception.__class__.__name__\n                echo_utc('Cif<{}> skipping: encountered an error retrieving cif data: {}'.format(source_id, name))\n        else:\n            if skip_partial_occupancies and cif.has_partial_occupancies():\n                if verbose:\n                    echo_utc('Cif<{}> skipping: contains partial occupancies'.format(source_id))\n            else:\n                if not dry_run:\n                    batch.append(cif)\n                    template = 'Cif<{}> adding: new CifData<{}> to group {}'\n                else:\n                    template = 'Cif<{}> would have added: CifData<{}> to group {}'\n\n                echo_utc(template.format(source_id, cif.uuid, group.label))\n                counter += 1\n\n        if not dry_run and counter % batch_count == 0:\n            echo_utc('Storing batch of {} CifData nodes'.format(len(batch)))\n            nodes = [node.store() for node in batch]\n            group.add_nodes(nodes)\n            batch = []\n\n        if max_entries is not None and counter >= max_entries:\n            break\n\n    if count_entries:\n        click.echo('{}'.format(counter))\n        return\n\n    if not dry_run and batch:\n        echo_utc('Storing batch of {} CifData nodes'.format(len(batch)))\n        nodes = [node.store() for node in batch]\n        group.add_nodes(nodes)\n\n    click.echo('-' * 80)\n    click.echo('Stored {} new entries'.format(counter))\n    click.echo('Stopping on {}'.format(datetime.utcnow().isoformat()))\n    click.echo('=' * 80)", "response": "Launches a CifData import on the CifData database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a directory entry to the backup_run.", "response": "def add_dir_entry(backup_run, dir_entry_path, process_bar, result):\n    \"\"\"\n    :param backup_run:\n    :param dir_entry_path: filesystem_walk.DirEntryPath() instance\n    :param process_bar:\n    \"\"\"\n    # print(dir_entry_path.pformat())\n    # print(dir_entry_path.stat.st_nlink)\n\n    backup_entry = Path2(dir_entry_path.path)\n    filesize = dir_entry_path.stat.st_size\n    hash_filepath = Path2(\"%s%s%s\" % (backup_entry.path, os.extsep, phlb_config.hash_name))\n    if hash_filepath.is_file():\n        with hash_filepath.open(\"r\") as hash_file:\n            hash_hexdigest = hash_file.read().strip()\n        if filesize > 0:\n            process_bar.update(filesize)\n    else:\n        with hash_filepath.open(\"w\") as hash_file:\n            callback = HashCallback(process_bar)\n            with backup_entry.open(\"rb\") as f:\n                hash = calculate_hash(f, callback)\n\n            hash_hexdigest = hash.hexdigest()\n            hash_file.write(hash_hexdigest)\n\n    old_backup_entry = deduplicate(backup_entry, hash_hexdigest)\n    if old_backup_entry is None:\n        result.add_new_file(filesize)\n    else:\n        result.add_stined_file(filesize)\n\n    BackupEntry.objects.create(\n        backup_run, dir_entry_path.path_instance, hash_hexdigest=hash_hexdigest  # Path2() instance\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef forwards_func(apps, schema_editor):\n    print(\"\\n\")\n    create_count = 0\n    BackupRun = apps.get_model(\"backup_app\", \"BackupRun\")  # historical version of BackupRun\n    backup_runs = BackupRun.objects.all()\n    for backup_run in backup_runs:\n        # Use the origin BackupRun model to get access to write_config()\n        temp = OriginBackupRun(name=backup_run.name, backup_datetime=backup_run.backup_datetime)\n        try:\n            temp.write_config()\n        except OSError as err:\n            print(\"ERROR creating config file: %s\" % err)\n        else:\n            create_count += 1\n            # print(\"%r created.\" % config_path.path)\n    print(\"%i config files created.\\n\" % create_count)", "response": "Create config files for backup_app 0004_BackupRun_ini_file_20160203_1415\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reverse_func(apps, schema_editor):\n    print(\"\\n\")\n    remove_count = 0\n    BackupRun = apps.get_model(\"backup_app\", \"BackupRun\")\n    backup_runs = BackupRun.objects.all()\n    for backup_run in backup_runs:\n        # Use the origin BackupRun model to get access to get_config_path()\n        temp = OriginBackupRun(name=backup_run.name, backup_datetime=backup_run.backup_datetime)\n        config_path = temp.get_config_path()\n        try:\n            config_path.unlink()\n        except OSError as err:\n            print(\"ERROR removing config file: %s\" % err)\n        else:\n            remove_count += 1\n            # print(\"%r removed.\" % config_path.path)\n\n    print(\"%i config files removed.\\n\" % remove_count)", "response": "Remove all config files from the backup_app folder"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef speziale_grun(v, v0, gamma0, q0, q1):\n    if isuncertainties([v, v0, gamma0, q0, q1]):\n        gamma = gamma0 * unp.exp(q0 / q1 * ((v / v0) ** q1 - 1.))\n    else:\n        gamma = gamma0 * np.exp(q0 / q1 * ((v / v0) ** q1 - 1.))\n    return gamma", "response": "calculate Gruneisen parameter for the Speziale equation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating Debye temperature for the Speziale equation", "response": "def speziale_debyetemp(v, v0, gamma0, q0, q1, theta0):\n    \"\"\"\n    calculate Debye temperature for the Speziale equation\n\n    :param v: unit-cell volume in A^3\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param q0: logarithmic derivative of Gruneisen parameter\n    :param q1: logarithmic derivative of Gruneisen parameter\n    :param theta0: Debye temperature at 1 bar in K\n    :return: Debye temperature in K\n    \"\"\"\n    if isuncertainties([v, v0, gamma0, q0, q1, theta0]):\n        f_vu = np.vectorize(uct.wrap(integrate_gamma),\n                            excluded=[1, 2, 3, 4, 5, 6])\n        integ = f_vu(v, v0, gamma0, q0, q1, theta0)\n        theta = unp.exp(unp.log(theta0) - integ)\n    else:\n        f_v = np.vectorize(integrate_gamma, excluded=[1, 2, 3, 4, 5, 6])\n        integ = f_v(v, v0, gamma0, q0, q1, theta0)\n        theta = np.exp(np.log(theta0) - integ)\n    return theta"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef integrate_gamma(v, v0, gamma0, q0, q1, theta0):\n    def f_integrand(v):\n        gamma = gamma0 * np.exp(q0 / q1 * ((v / v0) ** q1 - 1.))\n        return gamma / v\n\n    theta_term = quad(f_integrand, v0, v)[0]\n    return theta_term", "response": "Integrate gamma term at a given temperature"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef speziale_pth(v, temp, v0, gamma0, q0, q1, theta0, n, z, t_ref=300.,\n                 three_r=3. * constants.R):\n    \"\"\"\n    calculate thermal pressure for the Speziale equation\n\n    :param v: unit-cell volume in A^3\n    :param temp: temperature in K\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param q0: logarithmic derivative of Gruneisen parameter\n    :param q1: logarithmic derivative of Gruneisen parameter\n    :param theta0: Debye temperature at 1 bar in K\n    :param n: number of atoms in a formula unit\n    :param z: number of formula unit in a unit cell\n    :param t_ref: reference temperature\n    :param three_r: 3R in case adjustment is needed\n    :return: thermal pressure in GPa\n    \"\"\"\n    v_mol = vol_uc2mol(v, z)\n    gamma = speziale_grun(v, v0, gamma0, q0, q1)\n    theta = speziale_debyetemp(v, v0, gamma0, q0, q1, theta0)\n    xx = theta / temp\n    debye = debye_E(xx)\n    if t_ref == 0.:\n        debye0 = 0.\n    else:\n        xx0 = theta / t_ref\n        debye0 = debye_E(xx0)\n    Eth0 = three_r * n * t_ref * debye0\n    Eth = three_r * n * temp * debye\n    delEth = Eth - Eth0\n    p_th = (gamma / v_mol * delEth) * 1.e-9\n    return p_th", "response": "calculate thermal pressure for the Speziale equation"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstrings representation of the text of the current locale.", "response": "def text(self) -> str:\n        \"\"\" String representation of the text\n\n        :return: String representation of the text\n        \"\"\"\n        return self.export(output=Mimetypes.PLAINTEXT, exclude=self.default_exclude)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the DC Creator literal value", "response": "def set_creator(self, value: Union[Literal, Identifier, str], lang: str= None):\n        \"\"\" Set the DC Creator literal value\n\n        :param value: Value of the creator node\n        :param lang: Language in which the value is\n        \"\"\"\n        self.metadata.add(key=DC.creator, value=value, lang=lang)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the title of the object in the specified language.", "response": "def get_title(self, lang: str=None) -> Literal:\n        \"\"\" Get the title of the object\n\n        :param lang: Lang to retrieve\n        :return: Title string representation\n        :rtype: Literal\n        \"\"\"\n        return self.metadata.get_single(key=DC.title, lang=lang) or \\\n            self.metadata.get_single(key=DCT.title, lang=lang)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the DC Title literal value", "response": "def set_title(self, value: Union[Literal, Identifier, str], lang: str= None):\n        \"\"\" Set the DC Title literal value\n\n        :param value: Value of the title node\n        :param lang: Language in which the value is\n        \"\"\"\n        return self.metadata.add(key=DC.title, value=value, lang=lang)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the description of the object", "response": "def get_description(self, lang: str=None) -> Literal:\n        \"\"\" Get the description of the object\n\n        :param lang: Lang to retrieve\n        :return: Description string representation\n        :rtype: Literal\n        \"\"\"\n        return self.metadata.get_single(key=DC.description, lang=lang)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the DC. description literal value", "response": "def set_description(self, value: Union[Literal, Identifier, str], lang: str= None):\n        \"\"\" Set the DC Description literal value\n\n        :param value: Value of the title node\n        :param lang: Language in which the value is\n        \"\"\"\n        return self.metadata.add(key=DC.description, value=value, lang=lang)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the DC Subject literal value", "response": "def set_subject(self, value: Union[Literal, Identifier, str], lang: str= None):\n        \"\"\" Set the DC Subject literal value\n\n        :param value: Value of the subject node\n        :param lang: Language in which the value is\n        \"\"\"\n        return self.metadata.add(key=DC.subject, value=value, lang=lang)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexporting the collection item in the Mimetype required.", "response": "def export(self, output: str=None, exclude: List[str]=None, **kwargs):\n        \"\"\" Export the collection item in the Mimetype required.\n\n        ..note:: If current implementation does not have special mimetypes, reuses default_export method\n\n        :param output: Mimetype to export to (Uses MyCapytain.common.constants.Mimetypes)\n        :type output: str\n        :param exclude: Information to exclude. Specific to implementations\n        :type exclude: [str]\n        :return: Object using a different representation\n        \"\"\"\n        return Exportable.export(self, output, exclude=exclude, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the Identifiers of children of this object.", "response": "def childIds(self) -> BaseReferenceSet:\n        \"\"\" Identifiers of children\n\n        :return: Identifiers of children\n        \"\"\"\n        if self._childIds is None:\n            self._childIds = self.getReffs()\n        return self._childIds"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef firstId(self) -> BaseReference:\n        if self.childIds is not None:\n            if len(self.childIds) > 0:\n                return self.childIds[0]\n            return None\n        else:\n            raise NotImplementedError", "response": "Returns the first child s id of current TextualNode."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lastId(self) -> BaseReference:\n        if self.childIds is not None:\n            if len(self.childIds) > 0:\n                return self.childIds[-1]\n            return None\n        else:\n            raise NotImplementedError", "response": "Returns the last child s id of current TextualNode."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a text node from the API.", "response": "def getTextualNode(self, textId, subreference=None, prevnext=False, metadata=False):\n        \"\"\" Retrieve a text node from the API\n\n        :param textId: CtsTextMetadata Identifier\n        :type textId: str\n        :param subreference: CapitainsCtsPassage Reference\n        :type subreference: str\n        :param prevnext: Retrieve graph representing previous and next passage\n        :type prevnext: boolean\n        :param metadata: Retrieve metadata about the passage and the text\n        :type metadata: boolean\n        :return: CapitainsCtsPassage\n        :rtype: CapitainsCtsPassage\n        \"\"\"\n        text = CtsText(\n            urn=textId,\n            retriever=self.endpoint\n        )\n        if metadata or prevnext:\n            return text.getPassagePlus(reference=subreference)\n        else:\n            return text.getTextualNode(subreference=subreference)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getSiblings(self, textId, subreference):\n        text = CtsText(\n            urn=textId,\n            retriever=self.endpoint\n        )\n        return text.getPrevNextUrn(subreference)", "response": "Retrieve the siblings of a textual node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve the siblings of a textual node.", "response": "def getReffs(self, textId, level=1, subreference=None):\n        \"\"\" Retrieve the siblings of a textual node\n\n        :param textId: CtsTextMetadata Identifier\n        :type textId: str\n        :param level: Depth for retrieval\n        :type level: int\n        :param subreference: CapitainsCtsPassage Reference\n        :type subreference: str\n        :return: List of references\n        :rtype: [str]\n        \"\"\"\n        text = CtsText(\n            urn=textId,\n            retriever=self.endpoint\n        )\n        return text.getReffs(level, subreference)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getMetadata(self, objectId=None, **filters):\n        if objectId is not None:\n            filters[\"urn\"] = objectId\n\n        ti = XmlCtsTextInventoryMetadata.parse(self.endpoint.getCapabilities(**filters))\n        if objectId:\n            return [x for x in [ti] + ti.descendants if x.id == objectId][0]\n        return ti", "response": "Request metadata about a text or a collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompile a sequence of documents into a set of words used anywhere in a sequence of documents and assign an integer id", "response": "def compile_vocab(docs, limit=1e6, verbose=0, tokenizer=Tokenizer(stem=None, lower=None, strip=None)):\n    \"\"\"Get the set of words used anywhere in a sequence of documents and assign an integer id\n\n    This vectorizer is much faster than the scikit-learn version (and only requires low/constant RAM ?).\n\n    >>> gen = ('label: ' + chr(ord('A') + i % 3)*3 for i in range(11))\n    >>> d = compile_vocab(gen, verbose=0)\n    >>> d\n    <gensim.corpora.dictionary.Dictionary ...>\n    >>> print(d)\n    Dictionary(4 unique tokens: [u'AAA', u'BBB', u'CCC', u'label'])\n    >>> sorted(d.token2id.values())\n    [0, 1, 2, 3]\n    >>> sorted(d.token2id.keys())\n    [u'AAA', u'BBB', u'CCC', u'label']\n    \"\"\"\n    tokenizer = make_tokenizer(tokenizer)\n    d = Dictionary()\n\n    try:\n        limit = min(limit, docs.count())\n        docs = docs.iterator()\n    except (AttributeError, TypeError):\n        pass\n    for i, doc in enumerate(docs):\n        # if isinstance(doc, (tuple, list)) and len(doc) == 2 and isinstance(doc[1], int):\n        #     doc, score = docs\n        try:\n            # in case docs is a values() queryset (dicts of records in a DB table)\n            doc = doc.values()\n        except AttributeError:  # doc already is a values_list\n            if not isinstance(doc, str):\n                doc = ' '.join([str(v) for v in doc])\n            else:\n                doc = str(doc)\n        if i >= limit:\n            break\n        d.add_documents([list(tokenizer(doc))])\n        if verbose and not i % 100:\n            log.info('{}: {}'.format(i, repr(d)[:120]))\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a sequence of BOWs in gensim format", "response": "def gen_bows(docs=None, vocab=None, limit=1e6, verbose=1, tokenizer=Tokenizer):\n    \"\"\"Generate (yield) a sequence of vectorized documents in gensim format\n\n    Gensim calls a set of word vectors (BOWs) a `Corpus`\n\n    Yield:\n      Mapping: mapping between word id and word count (a word vector or BOW)\n               associated with a single document (text string)\n    \"\"\"\n    if vocab is None:\n        vocab = compile_vocab(docs=docs, limit=limit, verbose=verbose, tokenizer=Tokenizer)\n    for doc in docs:\n        yield vocab.doc2bow(tokenizer(doc))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gen_file_lines(path, mode='rUb', strip_eol=True, ascii=True, eol='\\n'):\n    if isinstance(path, str):\n        path = open(path, mode)\n    with path:\n        # TODO: read one char at a time looking for the eol char and yielding the interveening chars\n        for line in path:\n            if ascii:\n                line = str(line)\n            if strip_eol:\n                line = line.rstrip('\\n')\n            yield line", "response": "Generator function that yields a sequence of documents from the lines in a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef interleave_skip(iterables, limit=None):\n\n    iterators = map(iter, iterables)\n    while iterators:\n        for i, it in enumerate(iterators):\n            try:\n                yield next(it)\n            except StopIteration:\n                del iterators[i]", "response": "Like chain. from_iterable but doesn t stop at the end of shortest iterable\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef span_tokenize_sents(self, strings):\n        raise NotImplementedError(\"span_tokenizer and span_tokenzie_sents not yet implemented. ;)\")\n        for s in strings:\n            yield list(self.span_tokenize(s))", "response": "Apply self. span_tokenize to each element of strings. I. e. yield a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inventory(self, inventory_name):\n        def decorator(f):\n            self.add(func=f, inventory_name=inventory_name)\n            return f\n        return decorator", "response": "Decorator to register filters for given inventory. For a function abc it has the same effect as f."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndispatch a collection using internal filters", "response": "def dispatch(self, collection, **kwargs):\n        \"\"\" Dispatch a collection using internal filters\n\n        :param collection: Collection object\n        :param kwargs: Additional keyword arguments that could be used by internal filters\n        :return: None\n        :raises:\n        \"\"\"\n        for inventory, method in self.methods[::-1]:\n            if method(collection, **kwargs) is True:\n                collection.parent = self.collection.children[inventory]\n                return\n        raise UndispatchedTextError(\"CapitainsCtsText not dispatched %s\" % collection.id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_tokens(doc, regex=CRE_TOKEN, strip=True, nonwords=False):\n    if isinstance(regex, basestring):\n        regex = re.compile(regex)\n    for w in regex.finditer(doc):\n        if w:\n            w = w.group()\n            if strip:\n                w = w.strip(r'-_*`()}{' + r\"'\")\n            if w and (nonwords or not re.match(r'^' + RE_NONWORD + '$', w)):\n                yield w", "response": "r Return a sequence of words or tokens from a given doc."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a financial number from a string", "response": "def financial_float(s, scale_factor=1, typ=float,\n                    ignore=FINANCIAL_WHITESPACE,\n                    percent_str=PERCENT_SYMBOLS,\n                    replace=FINANCIAL_MAPPING,\n                    normalize_case=str.lower):\n    \"\"\"Strip dollar signs and commas from financial numerical string\n\n    Also, convert percentages to fractions/factors (generally between 0 and 1.0)\n\n    >>> [financial_float(x) for x in (\"12k Flat\", \"12,000 flat\", \"20%\", \"$10,000 Flat\", \"15K flat\", \"null\", \"None\", \"\", None)]\n    [12000.0, 12000.0, 0.2, 10000.0, 15000.0, 'null', 'none', '', None]\n    \"\"\"\n    percent_scale_factor = 1\n    if isinstance(s, basestring):\n        s = normalize_case(s).strip()\n        for i in ignore:\n            s = s.replace(normalize_case(i), '')\n        s = s.strip()\n        for old, new in replace:\n            s = s.replace(old, new)\n        for p in percent_str:\n            if s.endswith(p):\n                # %% will become 0.0001\n                percent_scale_factor *= 0.01\n                s = s[:-len(p)]\n    try:\n        return (scale_factor if scale_factor < 1 else percent_scale_factor) * typ(float(s))\n    except (ValueError, TypeError):\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake the representation of an object more human friendly.", "response": "def friendly(obj):\n    \"\"\"Make the representation of an object (mainly numbers) more human friendly\n\n    >>> friendly(1e6)\n    '1M'\n    >>> friendly(-1e3)\n    '-1k'\n    >>> friendly(1.23456789e9)\n    '1.23G'\n    >>> friendly(0)\n    '0'\n    >>> friendly('whatever')\n    'whatever'\n    \"\"\"\n    powers = 'TGMk munp'\n    if isinstance(obj, (float, int, long)):\n        sign = 1 - 2 * int(obj < 0)\n        obj = abs(obj)\n        i = 0\n        mid = 4\n        while np.inf > safe_log(obj, 1000) >= .9999999 and i <= mid and obj > 0 and np.isfinite(obj):\n            obj = obj * .001\n            i += 1\n        while np.inf > safe_log(obj, 1000) < -.25 and i > mid - len(powers) and obj > 0 and np.isfinite(obj):\n            obj = obj * 1000.\n            i -= 1\n        return '{:.3g}{}'.format(sign * obj, powers[mid - i] if i else '')\n    return stringify(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn boolean to indicate whether a date is invalid.", "response": "def is_invalid_date(d):\n    \"\"\"Return boolean to indicate whether date is invalid, None if valid, False if not a date\n\n    >>> import datetime\n    >>> is_invalid_date(datetime.datetime(1970, 1, 1, 0, 0, 1))\n    >>> is_invalid_date(datetime.datetime(1970, 1, 1))\n    >>> is_invalid_date(datetime.datetime(1969, 12, 31, 23, 59, 59, 999999))\n    True\n    >>> is_invalid_date(datetime.date(2100, 1, 1))\n    True\n    >>> is_invalid_date(datetime.datetime(2099, 12, 31, 23, 59, 59))\n    >>> [is_invalid_date(x) for x in (None, 0, 1.0, '2000-01-01')]\n    [False, False, False, False]\n    \"\"\"\n    if not isinstance(d, DATE_TYPES):\n        return False\n    if d.year < 1970 or d.year >= 2100:\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nonnull_fields(obj, pretty=True):\n    return PrettyDict((k, v) for k, v in [(f.attname, getattr(obj, f.attname, None))\n                      for f in obj._meta.fields] if (\n                            v and\n                            v not in NULL_VALUES and\n                            stringify(v).strip().lower()[:MAX_NULL_REPR_LEN] not in NULL_REPR_VALUES and\n                            not is_invalid_date(v)))", "response": "Generate a. values dict from a table record removing non - informative values"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlikes nltk. download but get a room for the process to download the requested NLTK dataset.", "response": "def nltk_download(name, ignore_errors=True):\n    r\"\"\"Like nltk.download, but be quiet about it, and get a room (separate python process)\n\n    Does some simple whitespace normalization on `name`, but doesn't yet do fuzzy matching\n    Caches the normalized names of packages already attempted, so they aren't re-tried\n\n    >>> nltk_download('nonexistent dataset name', ignore_errors=True)\n    False\n    >>> nltk_download('WordNet', ignore_errors=True)\n    True\n    >>> nltk_download('wordnet', ignore_errors=True)\n    True\n    \"\"\"\n    name = re.sub(r\"[-\\s=+']+\", '_', name.lower())\n    if name in nltk_download.done:\n        return nltk_download.done[name]\n    proc = subprocess.Popen([\"python\", \"-c\", \"import nltk; nltk.download('{}')\".format(name)], stdout=subprocess.PIPE)\n    msgs = [s for s in proc.communicate() if s is not None]\n    if any(re.match(r'^\\[nltk_data\\]\\s+Error', msg, flags=re.IGNORECASE) for msg in msgs):\n        nltk_download.done[name] = False\n        if ignore_errors:\n            return nltk_download.done[name]\n        raise ValueError('Unable to download the requested NLTK dataset: {}'.format('\\n'.join(msgs)))\n    nltk_download.done[name] = True\n    return nltk_download.done[name]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_stemmer(stem=None, min_len=3):\n    if not stem or stem == 'passthrough':\n        stem = Stemmer()\n        # FIXME: this is unnecessary?! and will make the object less picklable?\n        stem.stem = passthrough\n        return stem\n    if isinstance(stem, basestring):\n        stem = globals().get(stem, None) or locals().get(stem, stem)\n    # in case stem is a compiled stemmer regex, make it a string so it can be compiled by the nltk.RegexStemmer\n    if hasattr(stem, 'pattern'):\n        stem = Stemmer(nltk.stem.RegexpStemmer(stem, min=min_len))\n    if isinstance(stem, basestring):\n        # strip nonascii and whitespace, and only consider first letter, case-insentively\n        name = stringify(stem).lower().strip() or 'porter'\n        if name in STEMMER_TYPES:\n            dataset = STEMMER_DATASETS.get(name, None)\n            if dataset is not None:\n                nltk_download(dataset)\n            stem = STEMMER_TYPES.get(name, stem)\n        else:\n            stem = Stemmer(nltk.stem.RegexpStemmer(stem, min=min_len))\n    if isinstance(stem, type):\n        stem = stem()\n    if (hasattr(stem, 'stem') and callable(stem.stem)) or (hasattr(stem, 'lemmatize') and callable(stem.lemmatize) or stem is True):\n        return Stemmer(stem)\n    elif callable(stem):\n        return stem\n    raise(ValueError(\"Unable to make {} into a stemmer. \".format(stem) +\n                     \"Try 'porter', 'lancaster', None, a regular expression, a callable function, \" +\n                     \"or an object with a stem method.\"))", "response": "Returns a nltk. stem. StemmerI instance from a regex or a function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_named_stemmer(stem=None, min_len=3):\n    name, stem = stringify(stem), make_stemmer(stem=stem, min_len=min_len)\n    if hasattr(stem, '__name__'):\n        return stem.__name__, stem\n    if name.strip().lower() in STEMMER_TYPES:\n        return name.strip().lower(), stem\n    if hasattr(stem, 'pattern'):\n        return stem.pattern, stem\n    return stringify(stem), stem", "response": "Construct a callable object and a string sufficient to reconstruct it later"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef vocab_freq(docs, limit=1e6, verbose=1, tokenizer=generate_tokens):\n    total = Counter()\n    try:\n        limit = min(limit, docs.count())\n        docs = docs.iterator()\n    except:\n        pass\n    for i, doc in enumerate(docs):\n        try:\n            doc = doc.values()\n        except AttributeError:\n            if not isinstance(doc, basestring):\n                doc = ' '.join([stringify(v) for v in doc])\n            else:\n                doc = stringify(doc)\n        if i >= limit:\n            break\n        c = Counter(tokenizer(doc, strip=True, nonwords=False))\n        if verbose and (verbose < 1e-3 or not i % int(limit * verbose)):\n            print('{}: {} ... {}'.format(i, c.keys()[:3], c.keys()[-3:] if len(c.keys()) > 6 else ''))\n        total += c\n    return total", "response": "Get the set of words used anywhere in a sequence of documents and count occurrences of any occurrance of any occurrence in the document."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stem(self, s):\n        if self._stemmer is None:\n            return passthrough(s)\n        try:\n            # try the local attribute `stemmer`, a StemmerI instance first\n            # if you use the self.stem method from an unpickled object it may not work\n            return getattr(getattr(self, '_stemmer', None), 'stem', None)(s)\n        except (AttributeError, TypeError):\n            return getattr(getattr(self, '_stemmer', self), 'lemmatize', passthrough)(s)", "response": "Returns the stem of the given string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assoc(self, index, value):\n        '''Return a new vector with value associated at index. The implicit\n        parameter is not modified.'''\n        newvec = ImmutableVector()\n        newvec.tree = self.tree.assoc(index, value)\n        if index >= self._length:\n            newvec._length = index+1\n        else:\n            newvec._length = self._length\n        return newvec", "response": "Return a new vector with value associated at index. The implicit\n        parameter is not modified."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the result of concatenating self to the implicit parameter", "response": "def concat(self, tailvec):\n        '''Returns the result of concatenating tailvec to the implicit\n        parameter'''\n        newvec = ImmutableVector()\n        vallist = [(i + self._length, tailvec[i]) \\\n                for i in range(0, tailvec._length)]\n        newvec.tree = self.tree.multi_assoc(vallist)\n        newvec._length = self._length + tailvec._length\n        return newvec"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pop(self):\n        '''Return a new ImmutableVector with the last item removed.'''\n        if self._length == 0:\n            raise IndexError()\n        newvec = ImmutableVector()\n        newvec.tree = self.tree.remove(self._length-1)\n        newvec._length = self._length-1\n        return newvec", "response": "Return a new ImmutableVector with the last item removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves and parse a text given an identifier", "response": "def read(self, identifier, path):\n        \"\"\" Retrieve and parse a text given an identifier\n\n        :param identifier: Identifier of the text\n        :type identifier: str\n        :param path: Path of the text\n        :type path: str\n        :return: Parsed Text\n        :rtype: CapitainsCtsText\n        \"\"\"\n        with open(path) as f:\n            o = self.classes[\"text\"](urn=identifier, resource=self.xmlparse(f))\n        return o"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_textgroup_wrapper(self, cts_file):\n        try:\n            return self._parse_textgroup(cts_file)\n        except Exception as E:\n            self.logger.error(\"Error parsing %s \", cts_file)\n            if self.RAISE_ON_GENERIC_PARSING_ERROR:\n                raise E", "response": "Wraps with a Try / Except the textgroup parsing from a cts file containing the CtsTextgroupMetadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a textgroup from a CTS file and returns a CtsTextgroupMetadata and Current file", "response": "def _parse_textgroup(self, cts_file):\n        \"\"\" Parses a textgroup from a cts file\n\n        :param cts_file: Path to the CTS File\n        :type cts_file: str\n        :return: CtsTextgroupMetadata and Current file\n        \"\"\"\n        with io.open(cts_file) as __xml__:\n            return self.classes[\"textgroup\"].parse(\n                resource=__xml__\n            ), cts_file"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps with a Try - Except the Work parsing from a CTS file and returns a Parsed Work and the Texts as well as the current file directory.", "response": "def _parse_work_wrapper(self, cts_file, textgroup):\n        \"\"\" Wraps with a Try/Except the Work parsing from a cts file\n\n        :param cts_file: Path to the CTS File\n        :type cts_file: str\n        :param textgroup: Textgroup to which the Work is a part of\n        :type textgroup: CtsTextgroupMetadata\n        :return: Parsed Work and the Texts, as well as the current file directory\n        \"\"\"\n        try:\n            return self._parse_work(cts_file, textgroup)\n        except Exception as E:\n            self.logger.error(\"Error parsing %s \", cts_file)\n            if self.RAISE_ON_GENERIC_PARSING_ERROR:\n                raise E"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a Work from a CTS file and returns a list of work and texts as well as the current file directory", "response": "def _parse_work(self, cts_file, textgroup):\n        \"\"\" Parses a work from a cts file\n\n        :param cts_file: Path to the CTS File\n        :type cts_file: str\n        :param textgroup: Textgroup to which the Work is a part of\n        :type textgroup: CtsTextgroupMetadata\n        :return: Parsed Work and the Texts, as well as the current file directory\n        \"\"\"\n        with io.open(cts_file) as __xml__:\n            work, texts = self.classes[\"work\"].parse(\n                resource=__xml__,\n                parent=textgroup,\n                _with_children=True\n            )\n\n        return work, texts, os.path.dirname(cts_file)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncomplete the TextMetadata object with its citation scheme by parsing the original text.", "response": "def _parse_text(self, text, directory):\n        \"\"\" Complete the TextMetadata object with its citation scheme by parsing the original text\n\n        :param text: Text Metadata collection\n        :type text: XmlCtsTextMetadata\n        :param directory: Directory in which the metadata was found and where the text file should be\n        :type directory: str\n        :returns: True if all went well\n        :rtype: bool\n        \"\"\"\n        text_id, text_metadata = text.id, text\n        text_metadata.path = \"{directory}/{textgroup}.{work}.{version}.xml\".format(\n            directory=directory,\n            textgroup=text_metadata.urn.textgroup,\n            work=text_metadata.urn.work,\n            version=text_metadata.urn.version\n        )\n        if os.path.isfile(text_metadata.path):\n            try:\n                text = self.read(text_id, path=text_metadata.path)\n                cites = list()\n                for cite in [c for c in text.citation][::-1]:\n                    if len(cites) >= 1:\n                        cites.append(self.classes[\"citation\"](\n                            xpath=cite.xpath.replace(\"'\", '\"'),\n                            scope=cite.scope.replace(\"'\", '\"'),\n                            name=cite.name,\n                            child=cites[-1]\n                        ))\n                    else:\n                        cites.append(self.classes[\"citation\"](\n                            xpath=cite.xpath.replace(\"'\", '\"'),\n                            scope=cite.scope.replace(\"'\", '\"'),\n                            name=cite.name\n                        ))\n                del text\n                text_metadata.citation = cites[-1]\n                self.logger.info(\"%s has been parsed \", text_metadata.path)\n                if not text_metadata.citation.is_set():\n                    self.logger.error(\"%s has no passages\", text_metadata.path)\n                    return False\n                return True\n            except Exception:\n                self.logger.error(\n                    \"%s does not accept parsing at some level (most probably citation) \",\n                    text_metadata.path\n                )\n                return False\n        else:\n            self.logger.error(\"%s is not present\", text_metadata.path)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _dispatch(self, textgroup, directory):\n        if textgroup.id in self.dispatcher.collection:\n            self.dispatcher.collection[textgroup.id].update(textgroup)\n        else:\n            self.dispatcher.dispatch(textgroup, path=directory)\n\n        for work_urn, work in textgroup.works.items():\n            if work_urn in self.dispatcher.collection[textgroup.id].works:\n                self.dispatcher.collection[work_urn].update(work)", "response": "Dispatches a given textgroup over a directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _dispatch_container(self, textgroup, directory):\n        try:\n            self._dispatch(textgroup, directory)\n        except UndispatchedTextError as E:\n            self.logger.error(\"Error dispatching %s \", directory)\n            if self.RAISE_ON_UNDISPATCHED is True:\n                raise E", "response": "Dispatches the given textgroup into the specified directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a list of directories and reads it into a collection", "response": "def parse(self, resource):\n        \"\"\" Parse a list of directories and reads it into a collection\n\n        :param resource: List of folders\n        :return: An inventory resource and a list of CtsTextMetadata metadata-objects\n        \"\"\"\n        textgroups = []\n        texts = []\n        invalids = []\n\n        for folder in resource:\n            cts_files = glob(\"{base_folder}/data/*/__cts__.xml\".format(base_folder=folder))\n            for cts_file in cts_files:\n                textgroup, cts_file = self._parse_textgroup(cts_file)\n                textgroups.append((textgroup, cts_file))\n\n        for textgroup, cts_textgroup_file in textgroups:\n            cts_work_files = glob(\"{parent}/*/__cts__.xml\".format(parent=os.path.dirname(cts_textgroup_file)))\n\n            for cts_work_file in cts_work_files:\n                _, parsed_texts, directory = self._parse_work(cts_work_file, textgroup)\n                texts.extend([(text, directory) for text in parsed_texts])\n\n        for text, directory in texts:\n            # If text_id is not none, the text parsing errored\n            if not self._parse_text(text, directory):\n                invalids.append(text)\n\n        # Dispatching routine\n        for textgroup, textgroup_path in textgroups:\n            self._dispatch_container(textgroup, textgroup_path)\n\n        # Clean invalids if there was a need\n        self._clean_invalids(invalids)\n\n        self.inventory = self.dispatcher.collection\n        return self.inventory"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhelps for pagination of the items in a list of items.", "response": "def pagination(page, limit, length):\n        \"\"\" Help for pagination\n        :param page: Provided Page\n        :param limit: Number of item to show\n        :param length: Length of the list to paginate\n        :return: (Start Index, End Index, Page Number, Item Count)\n        \"\"\"\n        realpage = page\n        page = page or CtsCapitainsLocalResolver.DEFAULT_PAGE\n        limit = limit or CtsCapitainsLocalResolver.PER_PAGE[1]\n\n        if limit < CtsCapitainsLocalResolver.PER_PAGE[0] or limit > CtsCapitainsLocalResolver.PER_PAGE[2]:\n            limit = CtsCapitainsLocalResolver.PER_PAGE[1]\n\n        page = (page - 1) * limit\n\n        if page > length:\n            realpage = int(ceil(length / limit))\n            page = limit * (realpage - 1)\n            count = length - 1\n        elif limit - 1 + page < length:\n            count = limit - 1 + page\n        else:\n            count = length - 1\n\n        return page, count + 1, realpage, count - page + 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrequesting metadata about a text or a collection of objects.", "response": "def getMetadata(self, objectId=None, **filters):\n        \"\"\" Request metadata about a text or a collection\n\n        :param objectId: Object Identifier to filter on\n        :type objectId: str\n        :param filters: Kwargs parameters.\n        :type filters: dict\n        :return: Collection\n        \"\"\"\n        if objectId is None:\n            return self.inventory\n        elif objectId in self.inventory.children.keys():\n            return self.inventory[objectId]\n        texts, _, _ = self.__getTextMetadata__(urn=objectId)\n\n        # We store inventory names and if there is only one we recreate the inventory\n        inv_names = [text.parent.parent.parent.id for text in texts]\n        if len(set(inv_names)) == 1:\n            inventory = self.classes[\"inventory\"](name=inv_names[0])\n        else:\n            inventory = self.classes[\"inventory\"]()\n\n        # For each text we found using the filter\n        for text in texts:\n            tg_urn = str(text.parent.parent.urn)\n            wk_urn = str(text.parent.urn)\n            txt_urn = str(text.urn)\n            # If we need to generate a textgroup object\n            if tg_urn not in inventory.textgroups:\n                self.classes[\"textgroup\"](urn=tg_urn, parent=inventory)\n            # If we need to generate a work object\n            if wk_urn not in inventory.textgroups[tg_urn].works:\n                self.classes[\"work\"](urn=wk_urn, parent=inventory.textgroups[tg_urn])\n\n            if isinstance(text, CtsEditionMetadata):\n                x = self.classes[\"edition\"](urn=txt_urn, parent=inventory.textgroups[tg_urn].works[wk_urn])\n                x.citation = text.citation\n            elif isinstance(text, CtsTranslationMetadata):\n                x = self.classes[\"translation\"](urn=txt_urn, parent=inventory.textgroups[tg_urn].works[wk_urn], lang=text.lang)\n                x.citation = text.citation\n            elif isinstance(text, CtsCommentaryMetadata):\n                x = self.classes[\"commentary\"](urn=txt_urn, parent=inventory.textgroups[tg_urn].works[wk_urn], lang=text.lang)\n                x.citation = text.citation\n\n        return inventory[objectId]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a text node from the API and return it", "response": "def getTextualNode(self, textId, subreference=None, prevnext=False, metadata=False):\n        \"\"\" Retrieve a text node from the API\n\n        :param textId: CtsTextMetadata Identifier\n        :type textId: str\n        :param subreference: CapitainsCtsPassage CtsReference\n        :type subreference: str\n        :param prevnext: Retrieve graph representing previous and next passage\n        :type prevnext: boolean\n        :param metadata: Retrieve metadata about the passage and the text\n        :type metadata: boolean\n        :return: CapitainsCtsPassage\n        :rtype: CapitainsCtsPassage\n        \"\"\"\n        text, text_metadata = self.__getText__(textId)\n        if subreference is not None and not isinstance(subreference, CtsReference):\n            subreference = CtsReference(subreference)\n        passage = text.getTextualNode(subreference)\n        if metadata:\n            passage.set_metadata_from_collection(text_metadata)\n        return passage"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve the siblings of a textual node.", "response": "def getSiblings(self, textId, subreference: CtsReference):\n        \"\"\" Retrieve the siblings of a textual node\n\n        :param textId: CtsTextMetadata Identifier\n        :type textId: str\n        :param subreference: CapitainsCtsPassage CtsReference\n        :type subreference: str\n        :return: Tuple of references\n        :rtype: (str, str)\n        \"\"\"\n        text, inventory = self.__getText__(textId)\n        if not isinstance(subreference, CtsReference):\n            subreference = CtsReference(subreference)\n        passage = text.getTextualNode(subreference)\n        return passage.siblingsId"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getReffs(self, textId, level=1, subreference=None):\n        passage, inventory = self.__getText__(textId)\n        if subreference:\n            passage = passage.getTextualNode(subreference)\n        return passage.getReffs(level=level, subreference=subreference)", "response": "Retrieve the siblings of a textual node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert velocities to moduli", "response": "def velocities_to_moduli(rho, v_phi, v_s):\n    \"\"\"\n    convert velocities to moduli\n    mainly to support Burnman operations\n\n    :param rho: density in kg/m^3\n    :param v_phi: bulk sound speed in m/s\n    :param v_s: shear velocity in m/s\n    :return: K_s and G\n    \"\"\"\n    return v_phi * v_phi * rho, v_s * v_s * rho"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef moduli_to_velocities(rho, K_s, G):\n    return np.sqrt(K_s / rho), np.sqrt(G / rho)", "response": "convert moduli to velocities\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates static pressure at 300 K from Hugoniot data using the constq", "response": "def jamieson_pst(v, v0, c0, s, gamma0, q, theta0, n, z, mass, c_v,\n                 three_r=3. * constants.R, t_ref=300.):\n    \"\"\"\n    calculate static pressure at 300 K from Hugoniot data using the constq\n    formulation\n\n    :param v: unit-cell volume in A^3\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param c0: velocity at 1 bar in km/s\n    :param s: slope of the velocity change\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param q: logarithmic derivative of Gruneisen parameter\n    :param theta0: Debye temperature in K\n    :param n: number of elements in a chemical formula\n    :param z: number of formula unit in a unit cell\n    :param mass: molar mass in gram\n    :param c_v: heat capacity\n    :param three_r: 3 times gas constant.\n        Jamieson modified this value to compensate for mismatches\n    :param t_ref: reference temperature, 300 K\n    :return: static pressure in GPa\n    :note: 2017/05/18 I am unsure if this is actually being used in pytheos\n    \"\"\"\n    rho = mass / vol_uc2mol(v, z) * 1.e-6\n    rho0 = mass / vol_uc2mol(v0, z) * 1.e-6\n    p_h = hugoniot_p(rho, rho0, c0, s)\n    p_th_h = jamieson_pth(v, v0, c0, s, gamma0, q, theta0, n, z, mass, c_v,\n                          three_r=three_r, t_ref=t_ref)\n    p_st = p_h - p_th_h\n    return p_st"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef jamieson_pth(v, v0, c0, s, gamma0, q, theta0, n, z, mass, c_v,\n                 three_r=3. * constants.R, t_ref=300.):\n    \"\"\"\n    calculate thermal pressure from Hugoniot data using the constq\n    formulation\n\n    :param v: unit-cell volume in A^3\n    :param v0: unit-cell volume in A^3 at 1 bar\n    :param c0: velocity at 1 bar in km/s\n    :param s: slope of the velocity change\n    :param gamma0: Gruneisen parameter at 1 bar\n    :param q: logarithmic derivative of Gruneisen parameter\n    :param theta0: Debye temperature in K\n    :param n: number of elements in a chemical formula\n    :param z: number of formula unit in a unit cell\n    :param mass: molar mass in gram\n    :param c_v: heat capacity\n    :param three_r: 3 times gas constant.\n        Jamieson modified this value to compensate for mismatches\n    :param t_ref: reference temperature, 300 K\n    :return: static pressure in GPa\n    :note: 2017/05/18 I am unsure if this is actually being used in pytheos\n    \"\"\"\n    rho = mass / vol_uc2mol(v, z) * 1.e-6\n    rho0 = mass / vol_uc2mol(v0, z) * 1.e-6\n    temp = hugoniot_t(rho, rho0, c0, s, gamma0, q, theta0, n, mass,\n                      three_r=three_r, t_ref=t_ref, c_v=c_v)\n    pth = constq_pth(v, temp, v0, gamma0, q, theta0, n, z, t_ref=t_ref,\n                     three_r=three_r)\n    return pth", "response": "calculate thermal pressure from Hugoniot data using constq_pth"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates pressure along a Hugoniot throug nonlinear equation in Jameison 1982", "response": "def hugoniot_p_nlin(rho, rho0, a, b, c):\n    \"\"\"\n    calculate pressure along a Hugoniot throug nonlinear equations\n    presented in Jameison 1982\n\n    :param rho: density in g/cm^3\n    :param rho0: density at 1 bar in g/cm^3\n    :param a: prefactor for nonlinear fit of Hugoniot data\n    :param b: prefactor for nonlinear fit of Hugoniot data\n    :param c: prefactor for nonlinear fit of Hugoniot data\n    :return: pressure along Hugoniot in GPa\n    \"\"\"\n    eta = 1. - (rho0 / rho)\n    Up = np.zeros_like(eta)\n    if isuncertainties([rho, rho0, a, b, c]):\n        Up[eta != 0.] = ((b * eta - 1.) + unp.sqrt(\n            np.power((1. - b * eta), 2.) - 4. * np.power(eta, 2.) * a * c)) /\\\n            (-2. * eta * c)\n    else:\n        Up[eta != 0.] = ((b * eta - 1.) + np.sqrt(\n            np.power((1. - b * eta), 2.) - 4. * np.power(eta, 2.) * a * c)) /\\\n            (-2. * eta * c)\n    Us = a + Up * b + Up * Up * c\n    Ph = rho0 * Up * Us\n    return Ph"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ingest(cls, resource, root=None, **kwargs):\n        cite = cls(\n            name=resource.get(_cite_type_term, [{\"@value\": None}])[0][\"@value\"],  # Not really clean ?\n            root=root\n        )\n        for subCite in resource.get(_cite_structure_term, []):\n            cite.add_child(cls.ingest(subCite, root=root))\n        return cite", "response": "Ingest a dictionary of DTS Citation objects into a new Citation Graph"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ningests a list of DTS Citation objects from the DTS Collection Endpoint and creates the Citation Graphical Set", "response": "def ingest(cls, resource):\n        \"\"\" Ingest a list of DTS Citation object (as parsed JSON-LD) and\n        creates the Citation Graph\n\n        :param resource: List of Citation objects from the\n            DTS Collection Endpoint (as expanded JSON-LD)\n        :type resource: list\n        :return: Citation Graph\n        \"\"\"\n        _set = cls()\n        for data in resource:\n            _set.add_child(\n                cls.CitationClass.ingest(data, root=_set)\n            )\n        return _set"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_address_label(self):\n        if self.organisation_name:\n            self.address_label.append(self.organisation_name)\n        if self.department_name:\n            self.address_label.append(self.department_name)\n        if self.po_box_number:\n            self.address_label.append('PO Box ' + self.po_box_number)\n\n        elements = [\n                self.sub_building_name,\n                self.building_name,\n                self.building_number,\n                self.dependent_thoroughfare,\n                self.thoroughfare,\n                self.double_dependent_locality,\n                self.dependent_locality,\n        ]\n\n        for element in elements:\n            if element:\n                self._append_to_label(element)\n\n        # pad label to length of 7 if not already\n        if len(self.address_label) < 7:\n            for i in range(7 - len(self.address_label)):\n                self.address_label.append('')\n\n        # finally, add post town\n        self.address_label[5] = self.post_town\n\n        return \", \".join([f for f in self.address_label if f])", "response": "Generate a list of address label for the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the element is an exception rule.", "response": "def _is_exception_rule(self, element):\n        \"\"\" Check for \"exception rule\".\n\n        Address elements will be appended onto a new line on the lable except\n        for when the penultimate lable line fulfils certain criteria, in which\n        case the element will be concatenated onto the penultimate line. This\n        method checks for those criteria.\n\n        i) First and last characters of the Building Name are numeric\n          (eg '1to1' or '100:1')\n        ii) First and penultimate characters are numeric, last character is\n          alphabetic (eg '12A')\n        iii) Building Name has only one character (eg 'A')\n        \"\"\"\n        if element[0].isdigit() and element[-1].isdigit():\n            return True\n        if len(element) > 1 and element[0].isdigit() and element[-2].isdigit() and element[-1].isalpha():\n            return True\n        if len(element) == 1 and element.isalpha():\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _append_to_label(self, element):\n        if len(self.address_label) > 0\\\n                and self._is_exception_rule(self.address_label[-1]):\n            self.address_label[-1] += (' ' + element)\n        else:\n            self.address_label.append(element)", "response": "Append an element to the label."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating the value of a key - value pair against the validation settings and return a new error object.", "response": "def validate(self, value, model=None, context=None):\n        \"\"\"\n        Validate\n        Perform value validation against validation settings and return\n        error object.\n\n        :param value:           list, value to check\n        :param model:           parent model being validated\n        :param context:         object or None, validation context\n        :return:                shiftschema.result.Error\n        \"\"\"\n        invalid = [item for item in value if item not in self.choices]\n        if len(invalid):\n            return Error(\n                self.invalid_multichoice,\n                dict(items=', '.join(invalid))\n            )\n\n        # success otherwise\n        return Error()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_template_source(template_name, template_dirs=None):\n    template_zipfiles = getattr(settings, \"TEMPLATE_ZIP_FILES\", [])\n\n    # Try each ZIP file in TEMPLATE_ZIP_FILES.\n    for fname in template_zipfiles:\n        try:\n            z = zipfile.ZipFile(fname)\n            source = z.read(template_name)\n        except (IOError, KeyError):\n            continue\n        z.close()\n        # We found a template, so return the source.\n        template_path = \"%s:%s\" % (fname, template_name)\n        return (source, template_path)\n\n    # If we reach here, the template couldn't be loaded\n    raise TemplateDoesNotExist(template_name)", "response": "Template loader that loads templates from a ZIP file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsanitizing the capabilities passed to Selenic so that they can be consumed by Browserstack.", "response": "def sanitize_capabilities(caps):\n    \"\"\"\n    Sanitize the capabilities we pass to Selenic so that they can\n    be consumed by Browserstack.\n\n    :param caps: The capabilities passed to Selenic. This dictionary\n    is modified.\n\n    :returns: The sanitized capabilities.\n    \"\"\"\n    platform = caps[\"platform\"]\n\n    upper_platform = platform.upper()\n\n    if upper_platform.startswith(\"WINDOWS 8\"):\n        caps[\"platform\"] = \"WIN8\"\n    elif upper_platform.startswith(\"OS X \"):\n        caps[\"platform\"] = \"MAC\"\n    elif upper_platform == \"WINDOWS 10\":\n        del caps[\"platform\"]\n        caps[\"os\"] = \"Windows\"\n        caps[\"os_version\"] = \"10\"\n\n    if caps[\"browserName\"].upper() == \"MICROSOFTEDGE\":\n        # Sauce Labs takes complete version numbers like\n        # 15.1234. However, Browser Stack takes only .0 numbers like\n        # 15.0.\n        caps[\"version\"] = caps[\"version\"].split(\".\", 1)[0] + \".0\"\n\n    caps[\"browser_version\"] = caps[\"version\"]\n    del caps[\"version\"]\n\n    return caps"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef my_func(version):  # noqa: D202\n\n    class MyClass(object):\n        \"\"\"Enclosed class.\"\"\"\n\n        if version == 2:\n            import docs.support.python2_module as pm\n        else:\n            import docs.support.python3_module as pm\n\n        def __init__(self, value):\n            self._value = value\n\n        def _get_value(self):\n            return self._value\n\n        value = property(_get_value, pm._set_value, None, \"Value property\")", "response": "This is a function that is used by the object constructor."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the internal state based a change to the content and returns the sets of words added and removed.", "response": "def update(self, text, revision=None):\n        \"\"\"\n        Modifies the internal state based a change to the content and returns\n        the sets of words added and removed.\n\n        :Parameters:\n            text : str\n                The text content of a revision\n            revision : `mixed`\n                Revision metadata\n\n        :Returns:\n            A triple of lists:\n\n            current_tokens : `list` ( :class:`~mwpersistence.Token` )\n                A sequence of Tokens representing the revision that was just\n                processed.\n            tokens_added : `list` ( :class:`~mwpersistence.Token` )\n                Tokens that were added while updating state.\n            tokens_removed : `list` ( :class:`~mwpersistence.Token` )\n                Tokens that were removed while updating state.\n        \"\"\"\n        return self._update(text=text, revision=revision)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_opdocs(self, checksum, opdocs, revision=None):\n        return self._update(checksum=checksum, opdocs=opdocs,\n                            revision=revision)", "response": "Updates the internal state based a change to the content and returns the internal state based a change to the content and returns\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches all subscriptions from Membersuite of a particular publication_id.", "response": "def get_subscriptions(self, publication_id=None, owner_id=None,\n                          since_when=None, limit_to=200, max_calls=None,\n                          start_record=0, verbose=False):\n        \"\"\"\n        Fetches all subscriptions from Membersuite of a particular\n        `publication_id` if set.\n        \"\"\"\n        query = \"SELECT Objects() FROM Subscription\"\n\n        # collect all where parameters into a list of\n        # (key, operator, value) tuples\n        where_params = []\n\n        if owner_id:\n            where_params.append(('owner', '=', \"'%s'\" % owner_id))\n        if publication_id:\n            where_params.append(('publication', '=', \"'%s'\" % publication_id))\n        if since_when:\n            d = datetime.date.today() - datetime.timedelta(days=since_when)\n            where_params.append(\n                ('LastModifiedDate', \">\", \"'%s 00:00:00'\" % d))\n\n        if where_params:\n            query += \" WHERE \"\n            query += \" AND \".join(\n                [\"%s %s %s\" % (p[0], p[1], p[2]) for p in where_params])\n\n        subscription_list = self.get_long_query(\n            query, limit_to=limit_to, max_calls=max_calls,\n            start_record=start_record, verbose=verbose)\n\n        return subscription_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect(self):\n\t\texceptions = list(__basic_ftp_exceptions__)\n\t\texceptions.append(OSError)  # OSError for \"no route to host\" issue\n\t\texceptions.append(ConnectionRefusedError)  # for unavailable service on a host\n\n\t\ttry:\n\t\t\tself.ftp_client().connect(**self.__ftp_connect_args)\n\t\t\tself.ftp_client().login(**self.__ftp_auth_args)\n\t\texcept tuple(exceptions) as e:\n\t\t\traise WClientConnectionError('Unable to connect to the server') from e\n\t\ttry:\n\t\t\tpath = self.uri().path()\n\t\t\tif path is None:\n\t\t\t\tpath = self.directory_sep()\n\t\t\tself.change_directory(path)\n\t\texcept WClientCapabilityError as e:\n\t\t\traise WClientConnectionError(\n\t\t\t\t'Unable to change current working directory to the specified one'\n\t\t\t) from e", "response": ":meth :. WNetworkClientProto. connect method implementation\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scheme_specification(cls):\n\t\treturn WSchemeSpecification(\n\t\t\t'ftp',\n\t\t\tWURIComponentVerifier(WURI.Component.username, WURIComponentVerifier.Requirement.optional),\n\t\t\tWURIComponentVerifier(WURI.Component.password, WURIComponentVerifier.Requirement.optional),\n\t\t\tWURIComponentVerifier(WURI.Component.hostname, WURIComponentVerifier.Requirement.required),\n\t\t\tWURIComponentVerifier(WURI.Component.path, WURIComponentVerifier.Requirement.optional)\n\t\t)", "response": "returns a new instance of WSchemeSpecification"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a meta class to index sub classes by their keys.", "response": "def registry(attr, base=type):\n    \"\"\"Generates a meta class to index sub classes by their keys.\"\"\"\n    class Registry(base):\n        def __init__(cls, name, bases, attrs):\n            super(Registry, cls).__init__(name, bases, attrs)\n            if not hasattr(cls, '__registry__'):\n                cls.__registry__ = {}\n            key = getattr(cls, attr)\n            if key is not NotImplemented:\n                assert key not in cls.__registry__\n                cls.__registry__[key] = cls\n        def __dispatch__(cls, key):\n            try:\n                return cls.__registry__[key]\n            except KeyError:\n                raise ValueError('Unknown %s: %s' % (attr, key))\n    return Registry"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gen_repr(cls, template, *args, **kwargs):\n    buf = io.StringIO()\n    buf.write(u'<')\n    buf.write(cls.__module__.decode() if kwargs.pop('full', False) else u'etc')\n    buf.write(u'.')\n    buf.write(cls.__name__.decode())\n    if not kwargs.pop('dense', False):\n        buf.write(u' ')\n    buf.write(template.format(*args, **kwargs))\n    options = kwargs.pop('options', [])\n    for attr, value in options:\n        if value is not None:\n            buf.write(u' %s=%s' % (attr, value))\n    buf.write(u'>')\n    return buf.getvalue()", "response": "Generates a string for the class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_default_logger(\r\n    logger_name='logger',\r\n    log_level=None,\r\n    log_dir=None,\r\n    console_enabled=True,\r\n    max_log_size=5*1024*1024,\r\n    max_backup_logs=5):\r\n    '''\r\n    Generates a logger that outputs messages in the same format as default Flask applications.\r\n    '''\r\n    old_logger_class = logging.getLoggerClass()\r\n    logging.setLoggerClass(DefaultLogger)\r\n    logger = logging.getLogger(logger_name)\r\n    logging.setLoggerClass(old_logger_class)\r\n\r\n    if log_level:\r\n        logger.setLevel(log_level)\r\n    logger.apply_default_handlers(log_dir, console_enabled, max_log_size, max_backup_logs)\r\n    return logger", "response": "Creates a logger that outputs messages in the same format as default Flask applications."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuses for efficient debugging logging where the actual message isn t evaluated unless it s actually accepted by the logger.", "response": "def debug_generate(self, debug_generator, *gen_args, **gen_kwargs):\r\n        '''\r\n        Used for efficient debug logging, where the actual message isn't evaluated unless it\r\n        will actually be accepted by the logger.\r\n        '''\r\n        if self.isEnabledFor(logging.DEBUG):\r\n            message = debug_generator(*gen_args, **gen_kwargs)\r\n            # Allow for content filtering to skip logging\r\n            if message is not None:\r\n                return self.debug(message)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfiltering the value of a reservation key.", "response": "def filter(self, value, model=None, context=None):\n        \"\"\"\n        Filter\n        Performs value filtering and returns filtered result.\n\n        :param value:           input value\n        :param model:           parent model being validated\n        :param context:         object, filtering context\n        :return:                filtered value\n        \"\"\"\n\n        value = str(value)\n        pattern = r'\\d+'\n        found = ''.join(re.findall(pattern, value))\n\n        if found and self.to_int:\n            found = int(found)\n\n        return found"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_settings_env(executable_folder=None):\n        executable_folder = executable_folder or get_executable_folder()\n        # print \"!!!!!!!!!!!!!! executable:\", executable_folder\n        if os.path.exists(os.path.join(executable_folder, \"local/total_settings.py\")):\n            print(\"Using total settings\")\n            os.chdir(executable_folder)\n            os.environ[\"DJANGO_SETTINGS_MODULE\"] = \"local.total_settings\"\n            os.environ[\"STATIC_ROOT\"] = os.path.join(executable_folder, \"static\")\n            os.environ[\"MEDIA_ROOT\"] = os.path.join(executable_folder, \"media\")\n        else:\n            os.environ.setdefault('ROOT_DIR', get_folder(get_inspection_frame(2)))\n            os.environ[\"DJANGO_SETTINGS_MODULE\"] = \"djangoautoconf.base_settings\"", "response": "Set the environment variables that will be used to set the Django settings module."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resolve_zone_file_to_profile(zone_file, address_or_public_key):\n    if is_profile_in_legacy_format(zone_file):\n        return zone_file\n\n    try:\n        token_file_url = get_token_file_url_from_zone_file(zone_file)\n    except Exception as e:\n        raise Exception(\"Token file URL could not be extracted from zone file\")\n\n    try:\n        r = requests.get(token_file_url)\n    except Exception as e:\n        raise Exception(\"Token could not be acquired from token file URL\")\n\n    try:\n        profile_token_records = json.loads(r.text)\n    except ValueError:\n        raise Exception(\"Token records could not be extracted from token file\")\n\n    try:\n        profile = get_profile_from_tokens(profile_token_records,\n                                          address_or_public_key)\n    except Exception as e:\n        raise Exception(\"Profile could not be extracted from token records\")\n\n    return profile", "response": "Resolves a zone file to a profile and checks to make sure the tokens\n        are signed with the address or public key that corresponds to the address or public key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __dog_started(self):\n\t\tif self.__task is not None:\n\t\t\traise RuntimeError('Unable to start task. In order to start a new task - at first stop it')\n\n\t\tself.__task = self.record().task()\n\t\tif isinstance(self.__task, WScheduleTask) is False:\n\t\t\ttask_class = self.__task.__class__.__qualname__\n\t\t\traise RuntimeError('Unable to start unknown type of task: %s' % task_class)", "response": "Prepare watchdog for scheduled task starting\n\t\t is not None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart a scheduled task", "response": "def __thread_started(self):\n\t\t\"\"\" Start a scheduled task\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tif self.__task is None:\n\t\t\traise RuntimeError('Unable to start thread without \"start\" method call')\n\t\tself.__task.start()\n\t\tself.__task.start_event().wait(self.__scheduled_task_startup_timeout__)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _polling_iteration(self):\n\t\tif self.__task is None:\n\t\t\tself.ready_event().set()\n\t\telif self.__task.check_events() is True:\n\t\t\tself.ready_event().set()\n\t\t\tself.registry().task_finished(self)", "response": "Poll for scheduled task stop events\n\t\t self. ready_event. Set and call task_finished method."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef thread_stopped(self):\n\t\tif self.__task is not None:\n\t\t\tif self.__task.stop_event().is_set() is False:\n\t\t\t\tself.__task.stop()\n\t\t\tself.__task = None", "response": "Stop scheduled task beacuse of watchdog stop\n\t\t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart the given schedule record", "response": "def exec(self, record):\n\t\t\"\"\" Start the given schedule record (no time checks are made by this method, task will be started as is)\n\n\t\t:param record: schedule record to start\n\n\t\t:return: None\n\t\t\"\"\"\n\t\twatchdog_cls = self.watchdog_class()\n\t\twatchdog = watchdog_cls.create(record, self)\n\t\twatchdog.start()\n\t\twatchdog.start_event().wait(self.__watchdog_startup_timeout__)\n\t\tself.__running_registry.append(watchdog)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling scheduled task that has finished", "response": "def task_finished(self, watchdog):\n\t\t\"\"\" Handle/process scheduled task stop\n\n\t\t:param watchdog: watchdog of task that was stopped\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tif watchdog in self.__running_registry:  # when cleanup hits stop\n\t\t\tself.__running_registry.remove(watchdog)\n\t\t\tself.__done_registry.append(watchdog)\n\t\t\tself.cleanup_event().set()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cleanup(self):\n\t\tfor task in self.__done_registry:\n\t\t\ttask.stop()\n\t\tself.__done_registry.clear()\n\t\tself.cleanup_event().clear()", "response": "Stop and remove watchdogs that are no longer needed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stop_running_tasks(self):\n\t\tfor task in self.__running_registry:\n\t\t\ttask.stop()\n\t\tself.__running_registry.clear()", "response": "Terminate all the running tasks\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npostponing the given task.", "response": "def postpone(self, record):\n\t\t\"\"\" Postpone (if required) the given task. The real action is depended on task postpone policy\n\n\t\t:param record: record to postpone\n\t\t:return: None\n\t\t\"\"\"\n\n\t\tmaximum_records = self.maximum_records()\n\t\tif maximum_records is not None and len(self.__records) >= maximum_records:\n\t\t\trecord.task_dropped()\n\t\t\treturn\n\n\t\ttask_policy = record.policy()\n\t\ttask_group_id = record.task_group_id()\n\n\t\tif task_policy == WScheduleRecord.PostponePolicy.wait:\n\t\t\tself.__postpone_record(record)\n\n\t\telif task_policy == WScheduleRecord.PostponePolicy.drop:\n\t\t\trecord.task_dropped()\n\n\t\telif task_policy == WScheduleRecord.PostponePolicy.postpone_first:\n\t\t\tif task_group_id is None:\n\t\t\t\tself.__postpone_record(record)\n\t\t\telse:\n\t\t\t\trecord_found = None\n\t\t\t\tfor previous_scheduled_record, task_index in self.__search_record(task_group_id):\n\t\t\t\t\tif previous_scheduled_record.policy() != task_policy:\n\t\t\t\t\t\traise RuntimeError('Invalid tasks policies')\n\t\t\t\t\trecord_found = previous_scheduled_record\n\t\t\t\t\tbreak\n\n\t\t\t\tif record_found is not None:\n\t\t\t\t\trecord.task_dropped()\n\t\t\t\telse:\n\t\t\t\t\tself.__postpone_record(record)\n\n\t\telif task_policy == WScheduleRecord.PostponePolicy.postpone_last:\n\t\t\tif task_group_id is None:\n\t\t\t\tself.__postpone_record(record)\n\t\t\telse:\n\t\t\t\trecord_found = None\n\t\t\t\tfor previous_scheduled_record, task_index in self.__search_record(task_group_id):\n\t\t\t\t\tif previous_scheduled_record.policy() != task_policy:\n\t\t\t\t\t\traise RuntimeError('Invalid tasks policies')\n\t\t\t\t\trecord_found = task_index\n\t\t\t\t\tbreak\n\n\t\t\t\tif record_found is not None:\n\t\t\t\t\tself.__records.pop(record_found).task_dropped()\n\n\t\t\t\tself.__postpone_record(record)\n\t\telse:\n\t\t\traise RuntimeError('Invalid policy spotted')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __search_record(self, task_group_id):\n\t\tfor i in range(len(self.__records)):\n\t\t\trecord = self.__records[i]\n\t\t\tif record.task_group_id() == task_group_id:\n\t\t\t\tyield record, i", "response": "Search ( iterate over ) for tasks with the given task group id"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds new tasks from a task_source to the queue.", "response": "def add_source(self, task_source):\n\t\t\"\"\" Add new tasks source\n\n\t\t:param task_source:\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tnext_start = task_source.next_start()\n\t\tself.__sources[task_source] = next_start\n\t\tself.__update(task_source)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __update_all(self):\n\t\tself.__next_start = None\n\t\tself.__next_sources = []\n\n\t\tfor source in self.__sources:\n\t\t\tself.__update(source)", "response": "Recheck next start of records from all the sources"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the internal state of the only availabe object with the given task_source.", "response": "def __update(self, task_source):\n\t\t\"\"\" Recheck next start of tasks from the given one only\n\n\t\t:param task_source: source to check\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tnext_start = task_source.next_start()\n\t\tif next_start is not None:\n\n\t\t\tif next_start.tzinfo is None or next_start.tzinfo != timezone.utc:\n\t\t\t\traise ValueError('Invalid timezone information')\n\n\t\t\tif self.__next_start is None or next_start < self.__next_start:\n\t\t\t\tself.__next_start = next_start\n\t\t\t\tself.__next_sources = [task_source]\n\t\t\telif next_start == self.__next_start:\n\t\t\t\tself.__next_sources.append(task_source)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check(self):\n\t\tif self.__next_start is not None:\n\t\t\tutc_now = utc_datetime()\n\t\t\tif utc_now >= self.__next_start:\n\t\t\t\tresult = []\n\n\t\t\t\tfor task_source in self.__next_sources:\n\t\t\t\t\trecords = task_source.has_records()\n\t\t\t\t\tif records is not None:\n\t\t\t\t\t\tresult.extend(records)\n\n\t\t\t\tself.__update_all()\n\n\t\t\t\tif len(result) > 0:\n\t\t\t\t\treturn tuple(result)", "response": "Check if there are records that are ready to start and return them if there are no tasks to start and return them if there are no tasks to start and None if there are no tasks to start"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef thread_started(self):\n\t\tself.__running_record_registry.start()\n\t\tself.__running_record_registry.start_event().wait()\n\t\tWPollingThreadTask.thread_started(self)", "response": "Start required registries and start this scheduler\n\tWPollingThreadTask"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _polling_iteration(self):\n\t\tscheduled_tasks = self.__sources_registry.check()\n\t\thas_postponed_tasks = self.__postponed_record_registry.has_records()\n\t\tmaximum_tasks = self.maximum_running_records()\n\n\t\tif scheduled_tasks is not None or has_postponed_tasks is not None:\n\t\t\trunning_tasks = len(self.__running_record_registry)\n\n\t\t\tif running_tasks >= maximum_tasks:\n\t\t\t\tif scheduled_tasks is not None:\n\t\t\t\t\tfor task in scheduled_tasks:\n\t\t\t\t\t\tself.__postponed_record_registry.postpone(task)\n\t\t\telse:\n\t\t\t\tif has_postponed_tasks is True:\n\t\t\t\t\tfor postponed_task in self.__postponed_record_registry:\n\t\t\t\t\t\tself.__running_record_registry.exec(postponed_task)\n\t\t\t\t\t\trunning_tasks += 1\n\t\t\t\t\t\tif running_tasks >= maximum_tasks:\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\tif scheduled_tasks is not None:\n\t\t\t\t\tfor task in scheduled_tasks:\n\t\t\t\t\t\tif running_tasks >= maximum_tasks:\n\t\t\t\t\t\t\tself.__postponed_record_registry.postpone(task)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tself.__running_record_registry.exec(task)\n\t\t\t\t\t\t\trunning_tasks += 1", "response": "Poll for different scheduler events like"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a file of directory is contained in another.", "response": "def dir_contains(dirname, path, exists=True):\n    \"\"\"Check if a file of directory is contained in another.\n\n    Parameters\n    ----------\n    dirname: str\n        The base directory that should contain `path`\n    path: str\n        The name of a directory or file that should be in `dirname`\n    exists: bool\n        If True, the `path` and `dirname` must exist\n\n    Notes\n    -----\n    `path` and `dirname` must be either both absolute or both relative\n    paths\"\"\"\n    if exists:\n        dirname = osp.abspath(dirname)\n        path = osp.abspath(path)\n        if six.PY2 or six.PY34:\n            return osp.exists(path) and osp.samefile(\n                osp.commonprefix([dirname, path]), dirname)\n        else:\n            return osp.samefile(osp.commonpath([dirname, path]), dirname)\n    return dirname in osp.commonprefix([dirname, path])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the next name that numerically follows old", "response": "def get_next_name(old, fmt='%i'):\n    \"\"\"Return the next name that numerically follows `old`\"\"\"\n    nums = re.findall('\\d+', old)\n    if not nums:\n        raise ValueError(\"Could not get the next name because the old name \"\n                         \"has no numbers in it\")\n    num0 = nums[-1]\n    num1 = str(int(num0) + 1)\n    return old[::-1].replace(num0[::-1], num1[::-1], 1)[::-1]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsplitting up the key by. and get the value from the base dictionary d.", "response": "def go_through_dict(key, d, setdefault=None):\n    \"\"\"\n    Split up the `key` by . and get the value from the base dictionary `d`\n\n    Parameters\n    ----------\n    key: str\n        The key in the `config` configuration. %(get_value_note)s\n    d: dict\n        The configuration dictionary containing the key\n    setdefault: callable\n        If not None and an item is not existent in `d`, it is created by\n        calling the given function\n\n    Returns\n    -------\n    str\n        The last level of the key\n    dict\n        The dictionary in `d` that contains the last level of the key\n    \"\"\"\n    patt = re.compile(r'(?<!\\\\)\\.')\n    sub_d = d\n    splitted = patt.split(key)\n    n = len(splitted)\n    for i, k in enumerate(splitted):\n        if i < n - 1:\n            if setdefault is not None:\n                sub_d = sub_d.setdefault(k, setdefault())\n            else:\n                sub_d = sub_d[k]\n        else:\n            return k, sub_d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sha1_hmac(secret, document):\n    signature = hmac.new(secret, document, hashlib.sha1).digest().encode(\"base64\")[:-1]\n    return signature", "response": "Calculate the Base 64 encoding of the HMAC for the given document."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter_query_string(query):\n    return '&'.join([q for q in query.split('&')\n        if not (q.startswith('_k=') or q.startswith('_e=') or q.startswith('_s'))])", "response": "Filter the query string to remove the _e _k and _s values\n        removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fost_hmac_url_signature(\n    key, secret, host, path, query_string, expires):\n    \"\"\"\n        Return a signature that corresponds to the signed URL.\n    \"\"\"\n    if query_string:\n        document = '%s%s?%s\\n%s' % (host, path, query_string, expires)\n    else:\n        document = '%s%s\\n%s' % (host, path, expires)\n    signature = sha1_hmac(secret, document)\n    return signature", "response": "Return a signature that corresponds to the signed URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fost_hmac_request_signature(\n    secret, method, path, timestamp, headers = {}, body = ''):\n    \"\"\"\n        Calculate the signature for the given secret and arguments.\n    \"\"\"\n    signed_headers, header_values = 'X-FOST-Headers', []\n    for header, value in headers.items():\n        signed_headers += ' ' + header\n        header_values.append(value)\n    return fost_hmac_request_signature_with_headers(\n        secret, method, path, timestamp,\n        [signed_headers] + header_values, body)", "response": "Calculate the signature for the given secret and arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fost_hmac_request_signature_with_headers(\n    secret, method, path, timestamp, headers, body):\n    \"\"\"\n        Calculate the signature for the given secret and other arguments.\n\n        The headers must be the correct header value list in the proper order.\n    \"\"\"\n    document = \"%s %s\\n%s\\n%s\\n%s\" % (\n        method, path,\n        timestamp,\n        '\\n'.join(headers),\n        body)\n    signature = sha1_hmac(secret, document)\n    logging.info(\"Calculated signature %s for document\\n%s\", signature, document)\n    return document, signature", "response": "Calculate the signature for the given secret and other arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget an Order by ID.", "response": "def get_order(membersuite_id, client=None):\n    \"\"\"Get an Order by ID.\n    \"\"\"\n    if not membersuite_id:\n        return None\n\n    client = client or get_new_client(request_session=True)\n    if not client.session_id:\n        client.request_session()\n\n    object_query = \"SELECT Object() FROM ORDER WHERE ID = '{}'\".format(\n        membersuite_id)\n\n    result = client.execute_object_query(object_query)\n\n    msql_result = result[\"body\"][\"ExecuteMSQLResult\"]\n\n    if msql_result[\"Success\"]:\n        membersuite_object_data = (msql_result[\"ResultValue\"]\n                                   [\"SingleObject\"])\n    else:\n        raise ExecuteMSQLError(result=result)\n\n    return Order(membersuite_object_data=membersuite_object_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a private key and a corresponding public key", "response": "def generate_private_key(self, key_size=2048, public_exponent=65537):\n\t\t\"\"\" Generate a private (and a corresponding public) key\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tself.__set_private_key(\n\t\t\trsa.generate_private_key(\n\t\t\t\tpublic_exponent=public_exponent, key_size=key_size, backend=default_backend()\n\t\t\t)\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexporting a private key in PEM-format :param password: If it is not None, then result will be encrypt with given password :return: bytes", "response": "def export_private_key(self, password=None):\n\t\t\"\"\" Export a private key in PEM-format\n\n\t\t:param password: If it is not None, then result will be encrypt with given password\n\t\t:return: bytes\n\t\t\"\"\"\n\n\t\tif self.__private_key is None:\n\t\t\traise ValueError('Unable to call this method. Private key must be set')\n\n\t\tif password is not None:\n\t\t\tif isinstance(password, str) is True:\n\t\t\t\tpassword = password.encode()\n\t\t\treturn self.__private_key.private_bytes(\n\t\t\t\tencoding=serialization.Encoding.PEM,\n\t\t\t\tformat=serialization.PrivateFormat.PKCS8,\n\t\t\t\tencryption_algorithm=serialization.BestAvailableEncryption(password)\n\t\t\t)\n\t\treturn self.__private_key.private_bytes(\n\t\t\tencoding=serialization.Encoding.PEM,\n\t\t\tformat=serialization.PrivateFormat.TraditionalOpenSSL,\n\t\t\tencryption_algorithm=serialization.NoEncryption()\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef export_public_key(self):\n\t\tif self.__public_key is None:\n\t\t\traise ValueError('Unable to call this method. Public key must be set')\n\n\t\treturn self.__public_key.public_bytes(\n\t\t\tencoding=serialization.Encoding.PEM,\n\t\t\tformat=serialization.PublicFormat.SubjectPublicKeyInfo\n\t\t)", "response": "Export a public key in PEM - format and return the public key in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimporting a private key from data in PEM-format :param pem_text: text with private key :param password: If it is not None, then result will be decrypt with the given password :return: None", "response": "def import_private_key(self, pem_text, password=None):\n\t\t\"\"\" Import a private key from data in PEM-format\n\n\t\t:param pem_text: text with private key\n\t\t:param password: If it is not None, then result will be decrypt with the given password\n\t\t:return: None\n\t\t\"\"\"\n\t\tif isinstance(pem_text, str) is True:\n\t\t\tpem_text = pem_text.encode()\n\t\tif password is not None and isinstance(password, str) is True:\n\t\t\tpassword = password.encode()\n\n\t\tself.__set_private_key(\n\t\t\tserialization.load_pem_private_key(pem_text, password=password, backend=default_backend())\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_public_key(self, pem_text):\n\t\tif isinstance(pem_text, str) is True:\n\t\t\tpem_text = pem_text.encode()\n\t\tself.__set_public_key(\n\t\t\tserialization.load_pem_public_key(pem_text, backend=default_backend())\n\t\t)", "response": "Import a public key from data in PEM - format\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the value against the validation settings and return a SimpleResult object.", "response": "def validate(self, value, model=None, context=None):\n        \"\"\"\n        Validate\n        Perform value validation against validation settings and return\n        simple result object\n\n        :param value:           str, value to check\n        :param model:           parent model being validated\n        :param context:         object or None, validation context\n        :return:                shiftschema.results.SimpleResult\n        \"\"\"\n\n        length = len(str(value))\n        params = dict(min=self.min, max=self.max)\n\n        # too short?\n        if self.min and self.max is None:\n            if length < self.min:\n                return Error(self.too_short, params)\n\n        # too long?\n        if self.max and self.min is None:\n            if length > self.max:\n                return Error(self.too_long, params)\n\n        # within range?\n        if self.min and self.max:\n            if length < self.min or length > self.max:\n                return Error(self.not_in_range, params)\n\n        # success otherwise\n        return Error()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef qteSaveMacroData(self, data, widgetObj: QtGui.QWidget=None):\n\n        # Check type of input arguments.\n        if not hasattr(widgetObj, '_qteAdmin') and (widgetObj is not None):\n            msg = '<widgetObj> was probably not added with <qteAddWidget>'\n            msg += ' method because it lacks the <_qteAdmin> attribute.'\n            raise QtmacsOtherError(msg)\n\n        # If no widget was specified then use the calling widget.\n        if not widgetObj:\n            widgetObj = self.qteWidget\n\n        # Store the supplied data in the applet specific macro storage.\n        widgetObj._qteAdmin.macroData[self.qteMacroName()] = data", "response": "Save the supplied data to the applet specific macro storage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the macro data associated with the given widgetObj.", "response": "def qteMacroData(self, widgetObj: QtGui.QWidget=None):\n        \"\"\"\n        Retrieve ``widgetObj`` specific data previously saved with\n        ``qteSaveMacroData``.\n\n        If no data has been stored previously then **None** is\n        returned.\n\n        If ``widgetObj`` is **None** then the calling widget\n        ``self.qteWidget`` will be used.\n\n        |Args|\n\n        * ``widgetObj`` (**QWidget**): the widget/applet with which\n          the data should be associated.\n\n        |Returns|\n\n        * **object**: the previously stored data.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        * **QtmacsOtherError** if ``widgetObj`` was not added with\n          ``qteAddWidget`` method.\n\n        \"\"\"\n\n        # Check type of input arguments.\n        if not hasattr(widgetObj, '_qteAdmin') and (widgetObj is not None):\n            msg = '<widgetObj> was probably not added with <qteAddWidget>'\n            msg += ' method because it lacks the <_qteAdmin> attribute.'\n            raise QtmacsOtherError(msg)\n\n        # If no widget was specified then use the calling widget.\n        if not widgetObj:\n            widgetObj = self.qteWidget\n\n        # Retrieve the data structure.\n        try:\n            _ = widgetObj._qteAdmin.macroData[self.qteMacroName()]\n        except KeyError:\n            # If the entry does not exist then this is a bug; create\n            # an empty entry for next time.\n            widgetObj._qteAdmin.macroData[self.qteMacroName()] = None\n\n        # Return the data.\n        return widgetObj._qteAdmin.macroData[self.qteMacroName()]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteSetAppletSignature(self, appletSignatures: (str, tuple, list)):\n        # Convert the argument to a tuple if it is not already a tuple\n        # or list.\n        if not isinstance(appletSignatures, (tuple, list)):\n            appletSignatures = appletSignatures,\n\n        # Ensure that all arguments in the tuple/list are strings.\n        for idx, val in enumerate(appletSignatures):\n            if not isinstance(val, str):\n                args = ('appletSignatures', 'str', inspect.stack()[0][3])\n                raise QtmacsArgumentError(*args)\n\n        # Store the compatible applet signatures as a tuple (of strings).\n        self._qteAppletSignatures = tuple(appletSignatures)", "response": "Set applet signatures for this macro at run time."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteSetWidgetSignature(self, widgetSignatures: (str, tuple, list)):\n\n        # Convert the argument to a tuple if it is not already a tuple\n        # or list.\n        if not isinstance(widgetSignatures, (tuple, list)):\n            widgetSignatures = widgetSignatures,\n\n        # Ensure that all arguments in the tuple/list are strings.\n        for idx, val in enumerate(widgetSignatures):\n            if not isinstance(val, str):\n                args = ('widgetSignatures', 'str', inspect.stack()[0][3])\n                raise QtmacsArgumentError(*args)\n\n        # Store the compatible widget signatures as a tuple (of strings).\n        self._qteWidgetSignatures = tuple(widgetSignatures)", "response": "Set the widget signatures for this macro."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprepares to execute the macro for the current entry point.", "response": "def qtePrepareToRun(self):\n        \"\"\"\n        This method is called by Qtmacs to prepare the macro for\n        execution.\n\n        It is probably a bad idea to overload this method as it only\n        administrates the macro execution and calls the ``qteRun``\n        method (which *should* be overloaded by the macro programmer\n        in order for the macro to do something).\n\n        |Args|\n\n        * **None**\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n\n        # Report the execution attempt.\n        msgObj = QtmacsMessage((self.qteMacroName(), self.qteWidget), None)\n        msgObj.setSignalName('qtesigMacroStart')\n        self.qteMain.qtesigMacroStart.emit(msgObj)\n\n        # Try to run the macro and radio the success via the\n        # ``qtesigMacroFinished`` signal.\n        try:\n            self.qteRun()\n            self.qteMain.qtesigMacroFinished.emit(msgObj)\n        except Exception as err:\n            if self.qteApplet is None:\n                appID = appSig = None\n            else:\n                appID = self.qteApplet.qteAppletID()\n                appSig = self.qteApplet.qteAppletSignature()\n            msg = ('Macro <b>{}</b> (called from the <b>{}</b> applet'\n                   ' with ID <b>{}</b>) did not execute properly.')\n            msg = msg.format(self.qteMacroName(), appSig, appID)\n\n            if isinstance(err, QtmacsArgumentError):\n                msg += '<br/>' + str(err)\n\n            # Irrespective of the error, log it, enable macro\n            # processing (in case it got disabled), and trigger the\n            # error signal.\n            self.qteMain.qteEnableMacroProcessing()\n            self.qteMain.qtesigMacroError.emit(msgObj)\n            self.qteLogger.exception(msg, exc_info=True, stack_info=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all_valid(formsets):\n    valid = True\n    for formset in formsets:\n        if not formset.is_valid():\n            valid = False\n    return valid", "response": "Returns true if every formset in formsets is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef forms_valid(self, inlines):\n        for formset in inlines:\n            formset.save()\n        return HttpResponseRedirect(self.get_success_url())", "response": "The form and formsets are valid save the associated models."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles POST requests. Returns a list of forms that can be used to create a new instance of the formset.", "response": "def post(self, request, *args, **kwargs):\n        \"\"\"\n        Handles POST requests, instantiating a form and formset instances with the passed\n        POST variables and then checked for validity.\n        \"\"\"\n        self.object = self.get_object()\n        self.get_context_data()\n        inlines = self.construct_inlines()\n\n        if all_valid(inlines):\n            return self.forms_valid(inlines)\n        return self.forms_invalid(inlines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_success_url(self):\n        if self.success_url:\n            # Forcing possible reverse_lazy evaluation\n            url = force_text(self.success_url)\n        else:\n            raise ImproperlyConfigured(\n                \"No URL to redirect to. Provide a success_url.\")\n        return url", "response": "Returns the supplied success URL."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef displayStatusMessage(self, msgObj):\n\n        # Ensure the message ends with a newline character.\n        msg = msgObj.data\n        if not msg.endswith('\\n'):\n            msg = msg + '\\n'\n\n        # Display the message in the status field.\n        self.qteLabel.setText(msg)", "response": "Display the last status message and partially completed key sequences."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteUpdateLogSlot(self):\n\n        # Fetch all log records that have arrived since the last\n        # fetch() call and update the record counter.\n        log = self.logHandler.fetch(start=self.qteLogCnt)\n        self.qteLogCnt += len(log)\n\n        # Return immediately if no log message is available (this case\n        # should be impossible).\n        if not len(log):\n            return\n\n        # Remove all duplicate entries and count their repetitions.\n        log_pruned = []\n        last_entry = log[0]\n        num_rep = -1\n        for cur_entry in log:\n            # If the previous log message is identical to the current\n            # one increase its repetition counter. If the two log\n            # messages differ, add the last message to the output log\n            # and reset the repetition counter.\n            if last_entry.msg == cur_entry.msg:\n                num_rep += 1\n            else:\n                log_pruned.append([last_entry, num_rep])\n                num_rep = 0\n                last_entry = cur_entry\n\n        # The very last entry must be added by hand.\n        log_pruned.append([cur_entry, num_rep])\n\n        # Format the log entries (eg. color coding etc.)\n        log_formatted = \"\"\n        for cur_entry in log_pruned:\n            log_formatted += self.qteFormatMessage(cur_entry[0], cur_entry[1])\n            log_formatted + '\\n'\n\n        # Insert the formatted text all at once as calls to insertHtml\n        # are expensive.\n        self.qteText.insertHtml(log_formatted)\n        self.qteMoveToEndOfBuffer()\n\n        # If the log contained an error (or something else of interest\n        # to the user) then switch to the messages buffer (ie. switch\n        # to this very applet).\n        if self.qteAutoActivate:\n            self.qteAutoActivate = False\n            self.qteMain.qteMakeAppletActive(self)", "response": "Update the slot in the log buffer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmoving cursor to the end of the buffer.", "response": "def qteMoveToEndOfBuffer(self):\n        \"\"\"\n        Move cursor to the end of the buffer to facilitate auto\n        scrolling.\n\n        Technically, this is exactly the 'endOfBuffer' macro but to\n        avoid swamping Qtmacs with 'qteRunMacroStarted' messages to no\n        avail it was implemented here natively.\n        \"\"\"\n        tc = self.qteText.textCursor()\n        tc.movePosition(QtGui.QTextCursor.End)\n        self.qteText.setTextCursor(tc)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sign_token_records(profile_components, parent_private_key,\n                       signing_algorithm=\"ES256K\"):\n    \"\"\" Function for iterating through a list of profile components and\n        signing separate individual profile tokens.\n    \"\"\"\n\n    if signing_algorithm != \"ES256K\":\n        raise ValueError(\"Signing algorithm not supported\")\n\n    token_records = []\n\n    for profile_component in profile_components:\n        private_key = ECPrivateKey(parent_private_key)\n        public_key = private_key.public_key()\n        subject = {\n            \"publicKey\": public_key.to_hex()\n        }\n        token = sign_token(profile_component, private_key.to_hex(), subject,\n                           signing_algorithm=signing_algorithm)\n        token_record = wrap_token(token)\n        token_record[\"parentPublicKey\"] = public_key.to_hex()\n        token_records.append(token_record)\n\n    return token_records", "response": "Function for iterating through a list of profile components and signing separate individual profile tokens."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nnormalizing locale string to be used later for dictionaries loading.", "response": "def normalize_locale(locale):\n        \"\"\"\n        Normalize locale\n        Extracts language code from passed in locale string to be used later\n        for dictionaries loading.\n\n        :param locale:          string, locale (en, en_US)\n        :return:                string, language code\n        \"\"\"\n        import re\n        match = re.match(r'^[a-z]+', locale.lower())\n        if match:\n            return match.group()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_translations(self, locale):\n        locale = self.normalize_locale(locale)\n        if locale in self.translations:\n            return self.translations[locale]\n\n        translations = {}\n        for path in self.dirs:\n            file = os.path.join(path, '{}.py'.format(locale))\n            if not os.path.isfile(file):\n                continue\n\n            loader = SourceFileLoader(locale, file)\n            locale_dict = loader.load_module()\n            if not hasattr(locale_dict, 'translations'):\n                continue\n\n            language = getattr(locale_dict, 'translations')\n            if translations:\n                translations = language\n            else:\n                merged = dict(translations.items() | language.items())\n                translations = merged\n\n        if translations:\n            self.translations[locale] = translations\n            return translations\n\n        err = 'No translations found for locale [{}]'\n        raise NoTranslations(err.format(locale))", "response": "Get translation dictionary for locale"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef translate(self, message, locale):\n        translations = self.get_translations(locale)\n        if message in translations:\n            return translations[message]\n\n        # return untranslated\n        return message", "response": "Translate a message to the given locale. Will return original message if no translation exists for the message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_ajaxable_view_from_model_inherit_parent_class(model_class, parent_class_list, operation=\"Create\"):\n    generic_module = importlib.import_module(\"django.views.generic\")\n    view_class_name = \"%sView\" % operation\n    view_class = getattr(generic_module, view_class_name)\n    # parent_class_tuple = (ajax_mixin, AjaxableFormContextUpdateMixin, view_class)\n    parent_class_list.append(view_class)\n    create_view_class = type(\"%s%s%s\" % (model_class.__name__, operation, \"View\"),\n                             tuple(parent_class_list), {\n                                 # \"Meta\": type(\"Meta\", (), {\"model\": self.model_class, \"fields\": []}),\n                                 \"model\": model_class,\n                                 \"template_name\": \"form_view_base_template.html\",\n                                 \"submit_button_text\": operation,\n                                 \"success_url\": \"../\"\n                             })\n    return create_view_class", "response": "create a dynamically generated class based view from a Django model class inheriting the parent class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreleasing a new version from a local repository.", "response": "def release_local(url, version='patch', base='master', integration=None, default_version='0.0.1', use_prefix=None):\n    # type: (str, str, str, str, str, str) -> str\n    \"\"\"\n    Tag given repository with a new semver tag (bump version),\n    optionally merging a integration branch.\n\n    This will:\n        - clone the repository to temporary directory\n        - checkout branch indicated via base argument\n        - retrieve all the tags, sort them in natural order\n        - retrieve the last tag and bump it to given version\n        - merge integration branch, if defined\n        - tag and push base branch back to origin\n\n    If no tag is present and version argument is any of the bump arguments,\n    default_version will be used\n\n    :rtype: str\n    :param url: URL of the repository\n    :param version: specific version or one of: build, prerelease, patch, minor, major\n    :param base: base branch to use, by default master\n    :param integration: integration branch to use, by default none\n    :param default_version: default version used for when there are no tags and no specific version, default 0.0.1\n    :param use_prefix: use prefix for tags - sometimes, 'v',\n    :return: newly released version string or None if can not tag\n    \"\"\"\n    workspace = mkdtemp()\n    repo = Repo.clone_from(url, workspace, progress=SimpleProgressPrinter())\n\n    if repo.bare:\n        print_err('Cloned a bare repository, can not release [???]')\n\n    origin = repo.remote('origin')\n\n    if repo.active_branch.name != base:\n        origin.fetch('refs/heads/{0}:refs/heads/{0}'.format(base), progress=SimpleProgressPrinter())\n        repo.heads[base].checkout()\n\n    if integration is not None and integration in repo.heads:\n        print_info('Found integration branch \"{0}\", fetching'.format(integration))\n        origin.fetch('refs/heads/{0}:refs/heads/{0}'.format(integration), progress=SimpleProgressPrinter())\n        print_info('Will now attempt fast-forward {0} to include {1}'.format(base, integration))\n        print_git_output(repo.git.merge('--commit', '--no-edit', '--stat', '--ff-only', '-v', integration))\n\n    head_tags = (tag for tag in repo.tags if tag.commit == repo.head.commit)\n    sorted_head_tags = natsorted(head_tags, key=lambda t: t.path)\n\n    if 0 != len(sorted_head_tags):\n        print_info(\n            'Not going to auto-tag already tagged HEAD, tagged with {0}'\n                .format(\n                str.join(', ', (t.path[10:] for t in sorted_head_tags))\n            )\n        )\n        return None\n\n    last_tag = None\n\n    if repo.tags:\n        sorted_tags = natsorted(repo.tags, key=lambda t: t.path)\n        current_tag = sorted_tags[-1].path[10:]\n        print_info('Current tag is {0}'.format(current_tag))\n        if use_prefix is not None and current_tag.startswith(use_prefix):\n            last_tag = current_tag[len(use_prefix):]\n        else:\n            last_tag = current_tag\n\n    print_info('Last known version: {0}'.format(last_tag))\n\n    if last_tag is None:\n        print('Unknown last version, using default version {0}'.format(default_version))\n        last_tag = default_version\n\n    if 'build' == version:\n        next_version = bump_build(last_tag)\n\n    elif 'prerelease' == version:\n        next_version = bump_prerelease(last_tag)\n\n    elif 'patch' == version:\n        next_version = bump_patch(last_tag)\n\n    elif 'minor' == version:\n        next_version = bump_minor(last_tag)\n\n    elif 'major' == version:\n        next_version = bump_major(last_tag)\n    else:\n        next_version = version\n\n    print_info('Next version: {0}'.format(next_version))\n\n    next_tag = next_version.strip()\n\n    if use_prefix is not None:\n        next_tag = use_prefix + next_version\n\n    print_info('Next tag: {0}'.format(next_tag))\n\n    print_info('Tagging and pushing version')\n\n    release_tag = repo.create_tag(\n        path=next_tag,\n        ref=repo.heads[base],\n        message='Release tag of {0}'.format(next_version)\n    )\n\n    origin.push([release_tag, repo.heads[base]], progress=SimpleProgressPrinter())\n\n    print_info('Done, clearing workspace')\n    rmtree(workspace)\n\n    return next_version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flatten(l):\n    '''Flatten a multi-deminision list and return a iterable\n\n    Note that dict and str will not be expanded, instead, they will be kept as a single element.\n\n    Args:\n        l (list): The list needs to be flattened\n\n    Returns:\n        A iterable of flattened list. To have a list instead use ``list(flatten(l))``\n    '''\n    for el in l:\n        # I don;t want dict to be flattened\n        if isinstance(el, Iterable) and not isinstance(\n                el, (str, bytes)) and not isinstance(el, dict):\n            yield from flatten(el)\n        else:\n            yield el", "response": "Flatten a multi - deminision list and return a iterable\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a list of lists returns a big list of lists containing all the possibilities of elements of sublist combining together.", "response": "def crossCombine(l):\n    ''' Taken a list of lists, returns a big list of lists contain all the possibilities of elements of sublist combining together.\n\n    It is basically a Combinatorics of list. For example:\n\n        >>> crossCombine([[a,a1,a2,...], [b,b1,b2,...]])\n        >>> [[a,b], [a,b1], [a,b2], [a1,b], [a1,b1], [a1, b2], [a2,b], [a2,b1], [a2,b2], ...]\n\n    For using in StartCalendarInterval, the syntax of ``l`` is like below:\n        ``l: [[dic of month], [dict of day]]``\n\n    such as:\n        ``l: [[{'month': 1}, {'month': 2}], [{'day': 2}, {'day': 3}, {'day': 4}]]``\n\n    Args:\n        l (list[list]): the list of lists you want to crossCombine with.\n\n    Returns:\n        list: crossCombined list\n\n    '''\n    resultList = []\n    firstList = l[0]\n    rest = l[1:]\n    if len(rest) == 0:\n        return firstList\n    for e in firstList:\n        for e1 in crossCombine(rest):\n            resultList.append(combinteDict(e, e1))\n    return resultList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef combine(a1, a2):\n    ''' Combine to argument into a single flat list\n\n    It is used when you are not sure whether arguments are lists but want to combine them into one flat list\n\n    Args:\n        a1: list or other thing\n        a2: list or other thing\n\n    Returns:\n        list: a flat list contain a1 and a2\n    '''\n    if not isinstance(a1, list):\n        a1 = [a1]\n    if not isinstance(a2, list):\n        a2 = [a2]\n    return a1 + a2", "response": "Combine to argument into a single flat list containing a1 and a2."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn whether an object is single or pair or neither.", "response": "def singleOrPair(obj):\n    '''Chech an object is single or pair or neither.\n\n    Of course,, all pairs are single, so what the function is really detecting is whether an object is only single or at the same time a pair.\n\n    Args:\n        obj (object): Literally anything.\n\n    Returns:\n        str: 'Single', or 'Pair', or 'Neither'\n    '''\n    if len(list(obj.__class__.__mro__)) <= 2:\n        return 'Neither'\n    else:\n        # Pair check comes first for Pair is a subclass of Single\n        if ancestorJr(obj) is Pair:\n            return 'Pair'\n        elif ancestor(obj) is Single:\n            return 'Single'\n        else:\n            return 'Neither'"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove every item that matches the input from a list of objects.", "response": "def removeEverything(toBeRemoved, l):\n    '''Remove every instance that matches the input from a list\n\n    Match with ==, operation, which can be defined in __eq__.\n\n    Args:\n        tobeRemoved (object): the same object you want to remove from the list.\n        l (list): the llist you want to remove stuff from.\n    '''\n    successful = True\n    while successful:\n        try:\n            # list.remove will remove item if equal,\n            # which is evaluated by __eq__\n            l.remove(toBeRemoved)\n        except:\n            successful = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef printMe(self, selfTag, selfValue):\n        '''Parse the single and its value and return the parsed str.\n\n        Args:\n           selfTag (str): The tag. Normally just ``self.tag``\n           selfValue (list): a list of value elements(single, subclasses, str, int). Normally just ``self.value``\n\n        Returns:\n            str: A parsed text\n        '''\n        if len(selfValue) == 0:\n            return ''\n        # if value have only one element and it is not another single\n        # print differently\n        elif len(selfValue) == 1 and not ancestor(selfValue[0]) is Single:\n            text = '<{tag}>{value}</{tag}>\\n'.format(\n                tag=selfTag, value=selfValue[0])\n            return text\n        else:\n            valueText = ''\n            for element in selfValue:\n                # if the element is another single\n                # or merely an object\n                # both possibility should not happen in the same time\n                # if so, user is not doing the right thing\n                if singleOrPair(element) == 'Single':\n                    # ask that single to print itself\n                    valueText += element.printMe(element.tag, element.value)\n                elif singleOrPair(element) == 'Pair':\n                    valueText += element.printMe(element.key, element.value)\n                else:\n                    # simply print that element\n                    valueText += str(element) + '\\n'\n            valueText = indent(valueText, 4)\n            text = '<{tag}>\\n'.format(\n                tag=selfTag) + valueText + '</{tag}>\\n'.format(tag=selfTag)\n            return text", "response": "Parse the single and its value and return the parsed str."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlook for all the non single values recursively and returns a list of them", "response": "def findAll(self, selfValue):\n        '''Looks for all the non single values(str, int) *recursively* and returns a list of them\n\n        Args:\n            selfValue: A list of single, str, int. Normally just ``self.value``\n\n        Returns:\n            list: A list contains only non singles(str, int).\n        '''\n        resultList = []\n        for element in selfValue:\n            if isinstance(element, Single):\n                resultList += element.findAll(element.value)\n            else:\n                resultList.append(element)\n        return resultList"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef findAllSingle(self, selfValue):\n        '''Looks for all the single values and subclasses *recursively* and returns a list of them\n\n        Args:\n            selfValue: A list of single, str, int. Normally just ``self.value``\n\n        Returns:\n            list: A list contains only singles and subclasses.\n        '''\n        resultList = []\n        for element in selfValue:\n            if isinstance(element, Single):\n                resultList.append(element)\n                resultList += element.findAllSingle()\n        return resultList", "response": "Looks for all the single values and subclasses recursively and returns a list of them\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, *value):\n        '''convert value and add to self.value\n\n        Subclass must overwrite this method.\n        Subclass are responsible of creating whatever single instance it need from its ``add(*value)`` and call ``_add()`` to add them to ``self.value``\n\n        Args:\n            *value: the value to be added\n        '''\n        flattenedValueList = list(flatten(value))\n        return self._add(flattenedValueList, self.value)", "response": "convert value and add to self. value\n\n        Subclass must overwrite this method."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _remove(self, removeList, selfValue):\n        '''Remove elements from a list by matching the elements in the other list.\n\n        This method only looks inside current instance's value, not recursive.\n        There is no need for a recursive one anyway.\n        Match by == operation.\n\n        Args:\n            removeList (list): The list of matching elements.\n            selfValue (list): The list you remove value from. Usually ``self.value``\n        '''\n        for removeValue in removeList:\n            print(removeValue, removeList)\n            # if removeValue equal to selfValue, remove\n            removeEverything(removeValue, selfValue)", "response": "Remove elements from a list by matching the elements in the other list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove elements from self. value by matching.", "response": "def remove(self, *l):\n        ''' remove elements from self.value by matching.\n\n        Create the exactly same single you want to delete and pass it(them) in.\n        Normally this method needs to be overwrited by subclass. It only looks inside current instance's value, not recursive. There is no need for a recursive one anyway.\n\n        Args:\n            *l: a single element, a bunch of element seperated by comma, or a list of elements, or any combination. Element is what you match with.\n        '''\n        removeList = list(flatten(l))\n        self._remove(removeList, self.value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write(self):\n        '''Write the job to the corresponding plist.'''\n        with open(self.me, 'w') as f:\n            f.write(self.printMe(self.tag, self.value))", "response": "Write the job to the corresponding plist."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef printMe(self, selfKey, selfValue):\n        '''Parse the single and its value and return the parsed str.\n\n        Args:\n           selfTag (str): The tag. Normally just ``self.tag``\n           selfValue (list): a list of value elements(single, subclasses, str, int). Normally just ``self.value``\n\n        Returns:\n            str: A parsed text\n        '''\n        text = '<key>{keyName}</key>\\n'.format(keyName=selfKey)\n\n        if len(selfValue) == 0:\n            return ''\n        else:\n            valueText = ''\n            for element in selfValue:\n                if singleOrPair(element) == 'Single':\n                    valueText += element.printMe(element.tag, element.value)\n                elif singleOrPair(element) == 'Pair':\n                    valueText += element.printMe(element.key, element.value)\n                # maybe a else statement for non single non pair?\n\n        text += valueText\n        return text", "response": "Parse the single and its value and return the parsed str."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, *l):\n        '''add inner to outer\n\n        Args:\n            *l: element that is passed into Inner init\n        '''\n        for a in flatten(l):\n            self._add([self.Inner(a)], self.l)", "response": "add inner to outer\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove(self, *l):\n        '''remove inner from outer\n\n        Args:\n            *l element that is passes into Inner init\n        '''\n        for a in flatten(l):\n            self._remove([self.Inner(a)], self.l)", "response": "remove inner from outer\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a dict as pair Args : dic ( dict )", "response": "def add(self, dic):\n        '''adds a dict as pair\n\n        Args:\n            dic (dict): key and value\n        '''\n        for kw in dic:\n            checkKey(kw, self.keyWord)\n            self._add([Pair(kw, StringSingle(dic[kw]))], self.d)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the pair by passing a identical dict", "response": "def remove(self, dic):\n        '''remove the pair by passing a identical dict\n\n        Args:\n            dic (dict): key and value\n        '''\n        for kw in dic:\n            removePair = Pair(kw, dic[kw])\n            self._remove([removePair])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges value Args: path (str): the new environment path", "response": "def changeTo(self, path):\n        '''change value\n\n        Args:\n            path (str): the new environment path\n        '''\n        dictionary = DictSingle(Pair('PATH', StringSingle(path)))\n        self.value = [dictionary]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating self. value with basenumber and time interval", "response": "def _update(self, baseNumber, magnification):\n        '''update self.value with basenumber and time interval\n\n        Args:\n            baseNumber (str): self.baseNumber\n            magnification (str): self.magnification\n        '''\n        interval = int(baseNumber * magnification)\n        self.value = [IntegerSingle(interval)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef second(self):\n        '''set unit to second'''\n        self.magnification = 1\n        self._update(self.baseNumber, self.magnification)\n        return self", "response": "set unit to second"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef minute(self):\n        '''set unit to minute'''\n        self.magnification = 60\n        self._update(self.baseNumber, self.magnification)\n        return self", "response": "set unit to minute"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets unit to hour", "response": "def hour(self):\n        '''set unit to hour'''\n        self.magnification = 3600\n        self._update(self.baseNumber, self.magnification)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef day(self):\n        '''set unit to day'''\n        self.magnification = 86400\n        self._update(self.baseNumber, self.magnification)\n        return self", "response": "set unit to day"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef week(self):\n        '''set unit to week'''\n        self.magnification = 345600\n        self._update(self.baseNumber, self.magnification)\n        return self", "response": "set unit to week"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, *dic):\n        '''add a config to StartCalendarInterval.\n\n        Args:\n            *dic (dict): dictionary with format {'Day': 12, 'Hour': 34} Avaliable keys are Month, Day, Weekday, Hour, Minute. *Note the uppercase.* You can use gen(), genMix() to generate complex config dictionary.\n        '''\n        dicList = list(flatten(dic))\n        # for every dict in the list passed in\n        for d in dicList:\n            # make a dict single (list of pairs)\n            di = []\n            for k in d:\n                # checkKey(k, self.keyWord)\n                di.append(Pair(k, IntegerSingle(d[k])))\n            dictSingle = DictSingle(di)\n            # append dict single to array single's value\n            self._add([dictSingle], self.l)", "response": "add a config to StartCalendarInterval.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove(self, *dic):\n        '''remove a calendar config.\n\n        Args:\n            *dic (dict): dictionary with format {'Day': 12, 'Hour': 34} Avaliable keys are Month, Day, Weekday, Hour, Minute. *Note the uppercase.* You can use gen(), genMix() to generate complex config dictionary.\n        '''\n        dicList = list(flatten(dic))\n        for d in dicList:\n            di = []\n            for k in d:\n                # checkkey(k, self.keyword)\n                di.append(Pair(k, IntegerSingle(d[k])))\n            dictSingle = DictSingle(di)\n            # append dict single to array single\n            self._remove([dictSingle], self.l)", "response": "remove a calendar config.\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gen(self, month=0, week=0, day=0, weekday=0, hour=0, minute=0):\n        '''generate config dictionary to pass to add() or remove()\n\n        Args:\n            month (int): month in a year, from 1 to 12\n            week (int): week in a month, from 1 to 4\n            day (int): day in a month, from 1 to 31\n            weekday (int): weekday in a week, from 0 to 7. 0 and 7 both represent Sunday\n            hour (int): hour in a day, from 0 to 24\n            minute (int): minute in an hour, from 0 to 59\n\n        Returns:\n            dict: a dictionary with form {'Day': 1, etc}\n        '''\n        dic = {\n            'Month': month,\n            'Day': day,\n            'Week': week,\n            'Weekday': weekday,\n            'Day': day,\n            'Hour': hour,\n            'Minute': minute\n        }\n        dic = {k: v for k, v in dic.items() if v != 0}\n        return dic", "response": "generate config dictionary to pass to add or remove"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef genInterval(self,\n                    month=(),\n                    day=(),\n                    week=(),\n                    weekday=(),\n                    hour=(),\n                    minute=()):\n        '''Generate list of config dictionarie(s) that represent a interval of time. Used to be passed into add() or remove().\n        For example::\n\n            genInterval(month=(1,4), week(1,4))\n            # generate list contains from first to third week in from January to March\n\n        Args:\n            month (tuple): (start, end) month in a year, from 1 to 12\n            week (tuple): (start, end) week in a month, from 1 to 4\n            day (tuple): (start, end) day in a month, from 1 to 31\n            weekday (tuple): (start, end) weekday in a week, from 0 to 7. 0 and 7 both represent Sunday\n            hour (tuple): (start, end) hour in a day, from 0 to 24\n            minute (tuple): (start, end) minute in an hour, from 0 to 59\n\n        Returns:\n            list: a list of dictionarie(s) with form [{'Day':12, 'Month':3}, {}, etc]\n        '''\n        dic = {\n            'Month': month,\n            'Day': day,\n            'Week': week,\n            'Weekday': weekday,\n            'Day': day,\n            'Hour': hour,\n            'Minute': minute\n        }\n        dic = {k: v for k, v in dic.items() if v != ()}\n        # e.g. dic: {'month': (1,5), 'day': (2,4)}\n        grandList = []\n        for k in dic:\n            # e.g. k: 'month', dic[k]: (1,5)\n            l = []\n            # rangeTuple = (dic[k][0], dic[k][1] + 1)  # e.g. (1,6)\n            rangeTuple = dic[k]\n            for num in range(rangeTuple[0],\n                             rangeTuple[1]):  # e.g. 1, 2, 3, 4, 5\n                l.append({k: num})  # e.g. [{'month': 1}, {'month': 2}]\n            grandList.append(l)  # e.g. [[list of month], [list of day]]\n        print(grandList)\n        # grandList: [[list of month], [list of day]]\n        # l: [[a,a1,a2,...], [b,b1,b2,...]]\n        # combineDict return: [{a,b}, {a,b1}, {a,b2}, {a1,b}, {a1,b1}, {a1, b2}, {a2,b}, {a2,b1}, {a2,b2}]\n        return crossCombine(grandList)", "response": "Generate a list of config dictionarie s that represent a interval of time. Used to be passed into add or remove."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild the url of the resource s index.", "response": "def get_index_url(self, resource=None, **kwargs):\n        \"\"\"\n        Builds the url of the resource's index.\n\n        :param resource: name of the resource or None\n        :param kwargs: additional keyword arguments to build the url\n        :return: url of the resource's index\n        \"\"\"\n        default_kwargs = self.default_kwargs_for_urls() \\\n            if resource == self.get_resource_name() else {}\n\n        default_kwargs.update(kwargs)\n\n        return self.get_full_url(\n            self.app.reverse(\n                '{}_index'.format(resource or self.get_resource_name()),\n                **default_kwargs\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_parent(self):\n        if self.is_entity():\n            return self.get_index_url(**self.default_kwargs_for_urls())\n        elif self._parent is not None:\n            resource = self._parent.rsplit('_', 1)[0]\n            parts = self.default_kwargs_for_urls()\n\n            if '{}_id'.format(resource) in parts:\n                id = parts.pop('{}_id'.format(resource))\n                parts['id'] = id\n            return self.get_full_url(\n                self.app.reverse(\n                    self._parent, **parts\n                )\n            )", "response": "Returns the url to the parent endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef export_context(cls, context):\n\t\tif context is None:\n\t\t\treturn\n\t\tresult = [(x.context_name(), x.context_value()) for x in context]\n\t\tresult.reverse()\n\t\treturn tuple(result)", "response": "Export the specified context to be capable context transferring\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_context(cls, context):\n\t\tif context is None or len(context) == 0:\n\t\t\treturn\n\n\t\tresult = WContext(context[0][0], context[0][1])\n\t\tfor iter_context in context[1:]:\n\t\t\tresult = WContext(iter_context[0], context_value=iter_context[1], linked_context=result)\n\t\treturn result", "response": "Imports context to corresponding WContextProto object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning linked context as adapter specification", "response": "def specification(cls, *context_specs):\n\t\t\"\"\" Return linked context as adapter specification (is used by :class:`.WCommandContextAdapter`)\n\n\t\t:param context_specs: context names\n\t\t:return: WContext\n\t\t\"\"\"\n\t\timport_data = []\n\t\tfor name in context_specs:\n\t\t\timport_data.append((name, None))\n\t\treturn cls.import_context(import_data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if context request is compatible with adapters specification.", "response": "def match(self, command_context=None, **command_env):\n\t\t\"\"\" Check if context request is compatible with adapters specification. True - if compatible,\n\t\tFalse - otherwise\n\n\t\t:param command_context: context to check\n\t\t:param command_env: command environment\n\t\t:return: bool\n\t\t\"\"\"\n\t\tspec = self.specification()\n\t\tif command_context is None and spec is None:\n\t\t\treturn True\n\t\telif command_context is not None and spec is not None:\n\t\t\treturn command_context == spec\n\t\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch command :param command_tokens: command tokens to check :param command_context: command context :param command_env: command environment :return: bool", "response": "def match(self, *command_tokens, command_context=None, **command_env):\n\t\t\"\"\" Match command\n\n\t\t:param command_tokens: command tokens to check\n\t\t:param command_context: command context\n\t\t:param command_env: command environment\n\t\t:return: bool\n\t\t\"\"\"\n\t\tif self.adapter().match(command_context, **command_env) is False:\n\t\t\treturn False\n\n\t\tcommand_tokens = self.adapter().adapt(*command_tokens, command_context=command_context, **command_env)\n\t\treturn self.original_command().match(*command_tokens, command_context=command_context, **command_env)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes command in command context", "response": "def exec(self, *command_tokens, command_context=None, **command_env):\n\t\t\"\"\" Execute command\n\n\t\t:param command_tokens: command tokens to execute\n\t\t:param command_context: command context\n\t\t:param command_env: command environment\n\t\t:return: WCommandResultProto\n\t\t\"\"\"\n\t\tif self.adapter().match(command_context, **command_env) is False:\n\t\t\tcmd = WCommandProto.join_tokens(*command_tokens)\n\t\t\tspec = self.adapter().specification()\n\t\t\tif spec is not None:\n\t\t\t\tspec = [x.context_name() for x in spec]\n\t\t\t\tspec.reverse()\n\t\t\t\tspec = ','.join(spec)\n\t\t\traise RuntimeError('Command mismatch: %s (context: %s)' % (cmd, spec))\n\n\t\tcommand_tokens = self.adapter().adapt(*command_tokens, command_context=command_context, **command_env)\n\t\treturn self.original_command().exec(*command_tokens, command_context=command_context, **command_env)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(self, value, model=None, context=None):\n\n        if not isinstance(value, Iterable):\n            return Error(self.not_iterable)\n\n        try:\n            next(iter(value))\n        except StopIteration:\n            return Error(self.cant_be_empty)\n\n        return Error()", "response": "Validate the value of the key\n        field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef any_shared(enum_one, enum_two):\r\n    '''\r\n    Truthy if any element in enum_one is present in enum_two\r\n    '''\r\n    if not is_collection(enum_one) or not is_collection(enum_two):\r\n        return False\r\n    enum_one = enum_one if isinstance(enum_one, (set, dict)) else set(enum_one)\r\n    enum_two = enum_two if isinstance(enum_two, (set, dict)) else set(enum_two)\r\n    return any(e in enum_two for e in enum_one)", "response": "Truthy if any element in enum_one is present in enum_two"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nnormalizes the given URI", "response": "def normalize_uri(cls, uri):\n\t\t\"\"\" Normalize the given URI (removes extra slashes)\n\n\t\t:param uri: uri to normalize\n\t\t:return: str\n\t\t\"\"\"\n\t\turi = WWebRoute.multiple_slashes_re.sub(\"/\", uri)\n\n\t\t# remove last slash\n\t\tif len(uri) > 1:\n\t\t\tif uri[-1] == '/':\n\t\t\t\turi = uri[:-1]\n\n\t\treturn uri"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match(self, request, service):\n\t\turi = self.normalize_uri(request.path())\n\n\t\tif request.session().protocol() not in self.protocols:\n\t\t\treturn\n\n\t\tif request.method() not in self.methods:\n\t\t\treturn\n\n\t\tif self.virtual_hosts and request.virtual_host() not in self.virtual_hosts:\n\t\t\treturn\n\n\t\tif self.ports and int(request.session().server_address().port()) not in self.ports:\n\t\t\treturn\n\n\t\tmatch_obj = self.re_pattern.match(uri)\n\n\t\tif not match_obj:\n\t\t\treturn\n\n\t\tpresenter_action = self.action\n\t\tpresenter_args = self.presenter_args.copy()\n\n\t\tfor i in range(len(self.route_args)):\n\t\t\tif self.route_args[i] == 'action':\n\t\t\t\tpresenter_action = match_obj.group(i + 1)\n\t\t\telse:\n\t\t\t\tpresenter_args[self.route_args[i]] = match_obj.group(i + 1)\n\n\t\treturn WWebTargetRoute(self.presenter, presenter_action, self, service.route_map(), **presenter_args)", "response": "Check this route for matching the given request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef url_for(self, **kwargs):\n\t\thost = self.virtual_hosts[0] if self.virtual_hosts is not None and len(self.virtual_hosts) == 1 else None\n\t\tport = self.ports[0] if self.ports is not None and len(self.ports) == 1 else None\n\t\tprotocol = self.protocols[0] if self.protocols is not None and len(self.protocols) == 1 else None\n\t\troute_args = self.route_args.copy()\n\n\t\turl_args = []\n\t\tfor key in kwargs.keys():\n\t\t\tif key == 'host':\n\t\t\t\thost = kwargs['host']\n\t\t\t\tcontinue\n\t\t\tif key == 'port':\n\t\t\t\tport = kwargs['port']\n\t\t\t\tcontinue\n\t\t\tif key == 'protocol':\n\t\t\t\tprotocol = kwargs['protocol']\n\t\t\t\tcontinue\n\n\t\t\turl_args.append(key)\n\n\t\turl_prefix = ''\n\t\tif protocol is not None and host is not None:\n\t\t\turl_prefix += ('%s://%s' % (protocol, host))\n\t\t\tif port is not None:\n\t\t\t\turl_prefix += (':%i' % port)\n\n\t\tpattern = self.pattern[1:-1]\n\t\tcheck = lambda x: WWebRoute.pattern_parentheses_removing_re.search(x) is not None or \\\n\t\t\tWWebRoute.pattern_parentheses_removing_nested_re.search(x) is not None\n\t\twhile check(pattern) is True:\n\t\t\tpattern = WWebRoute.pattern_parentheses_removing_re.sub('()', pattern)\n\t\t\tpattern = WWebRoute.pattern_parentheses_removing_nested_re.sub('(())', pattern)\n\n\t\targ_i = 0\n\t\twhile WWebRoute.pattern_recombination_re.search(pattern) is not None:\n\t\t\targ_name = route_args[arg_i]\n\t\t\targ_value = None\n\t\t\tif arg_name in url_args:\n\t\t\t\targ_value = kwargs[arg_name]\n\t\t\telif arg_name == 'action':\n\t\t\t\targ_value = self.action\n\t\t\telif arg_name in self.presenter_args:\n\t\t\t\targ_value = self.presenter_args[arg_name]\n\n\t\t\tif arg_value is None:\n\t\t\t\traise RuntimeError('Invalid argument')\n\n\t\t\tpattern = WWebRoute.pattern_recombination_re.sub(arg_value, pattern, 1)\n\t\t\targ_i += 1\n\n\t\treturn url_prefix + self.normalize_uri(pattern)", "response": "Generate url for client with specified route arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef route(self, request, service):\n\t\tfor route in self.__routes:\n\t\t\tresult = route.match(request, service)\n\t\t\tif result is not None:\n\t\t\t\tif self.target_route_valid(result) is True:\n\t\t\t\t\treturn result", "response": "method implementation\n\t. route"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect(self, pattern, presenter, **kwargs):\n\t\tself.__routes.append(WWebRoute(pattern, presenter, **kwargs))", "response": "Connect the given pattern with the given presenter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimporting route written as a string", "response": "def import_route(self, route_as_txt):\n\t\t\"\"\" Import route written as a string\n\n\t\t:param route_as_txt: single string (single route) to import\n\t\t:return: None\n\t\t\"\"\"\n\t\troute_match = WWebRouteMap.import_route_re.match(route_as_txt)\n\t\tif route_match is None:\n\t\t\traise ValueError('Invalid route code')\n\n\t\tpattern = route_match.group(1)\n\t\tpresenter_name = route_match.group(2)\n\t\troute_args = route_match.group(4)  # may be None\n\n\t\tif route_args is not None:\n\t\t\tresult_args = {}\n\t\t\tfor arg_declaration in route_args.split(\",\"):\n\t\t\t\targ_match = WWebRouteMap.import_route_arg_re.match(arg_declaration)\n\t\t\t\tif arg_match is None:\n\t\t\t\t\traise RuntimeError('Invalid argument declaration in route')\n\t\t\t\tresult_args[arg_match.group(1)] = arg_match.group(3)\n\n\t\t\tself.connect(pattern, presenter_name, **result_args)\n\t\telse:\n\t\t\tself.connect(pattern, presenter_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the presenter with the given name", "response": "def presenter(self, presenter_name):\n\t\t\"\"\" :meth:`.WWebPresenterCollectionProto.presenter` method implementation\n\t\t\"\"\"\n\t\tif presenter_name in self.__presenters.keys():\n\t\t\treturn self.__presenters[presenter_name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses a single request from the given session and return the response.", "response": "def process_request(self, session):\n\t\t\"\"\" Process single request from the given session\n\n\t\t:param session: session for reading requests and writing responses\n\t\t:return: None\n\t\t\"\"\"\n\n\t\tdebugger = self.debugger()\n\t\tdebugger_session_id = debugger.session_id() if debugger is not None else None\n\n\t\ttry:\n\t\t\trequest = session.read_request()\n\t\t\tif debugger_session_id is not None:\n\t\t\t\tdebugger.request(\n\t\t\t\t\tdebugger_session_id, request, session.protocol_version(), session.protocol()\n\t\t\t\t)\n\n\t\t\ttry:\n\t\t\t\ttarget_route = self.route_map().route(request, self)\n\t\t\t\tif debugger_session_id is not None:\n\t\t\t\t\tdebugger.target_route(debugger_session_id, target_route)\n\n\t\t\t\tif target_route is not None:\n\t\t\t\t\tresponse = self.execute(request, target_route)\n\t\t\t\telse:\n\t\t\t\t\tpresenter_cls = self.route_map().error_presenter()\n\t\t\t\t\tpresenter = presenter_cls(request)\n\t\t\t\t\tresponse = presenter.error_code(code=404)\n\n\t\t\t\tif debugger_session_id is not None:\n\t\t\t\t\tdebugger.response(debugger_session_id, response)\n\n\t\t\texcept Exception as e:\n\t\t\t\tif debugger_session_id is not None:\n\t\t\t\t\tdebugger.exception(debugger_session_id, e)\n\n\t\t\t\tpresenter_cls = self.route_map().error_presenter()\n\t\t\t\tpresenter = presenter_cls(request)\n\t\t\t\tresponse = presenter.exception_error(e)\n\n\t\t\tsession.write_response(request, response, *response.__pushed_responses__())\n\t\texcept Exception as e:\n\t\t\tif debugger_session_id is not None:\n\t\t\t\tdebugger.exception(debugger_session_id, e)\n\n\t\t\tsession.session_close()\n\n\t\tif debugger_session_id is not None:\n\t\t\tdebugger.finalize(debugger_session_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new presenter from the given requests and target routes.", "response": "def create_presenter(self, request, target_route):\n\t\t\"\"\" Create presenter from the given requests and target routes\n\n\t\t:param request: client request\n\t\t:param target_route: route to use\n\t\t:return: WWebPresenter\n\t\t\"\"\"\n\t\tpresenter_name = target_route.presenter_name()\n\t\tif self.presenter_collection().has(presenter_name) is False:\n\t\t\traise RuntimeError('No such presenter: %s' % presenter_name)\n\t\tpresenter_class = self.presenter_collection().presenter(presenter_name)\n\t\treturn self.presenter_factory().instantiate(presenter_class, request, target_route, self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect(self, pattern, presenter, **kwargs):\n\t\tif isinstance(presenter, type) and issubclass(presenter, WWebPresenter) is True:\n\t\t\tself.presenter_collection().add(presenter)\n\t\t\tpresenter = presenter.__presenter_name__()\n\t\tself.__route_map.connect(pattern, presenter, **kwargs)", "response": "Shortcut for route_map. connect method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a presenter to the collection.", "response": "def add_presenter(self, presenter):\n\t\t\"\"\" Add presenter to a collection. If the given presenter is a :class:`.WWebEnhancedPresenter` instance\n\t\tthen public routes are checked (via :meth:`..WWebEnhancedPresenter.__public_routes__` method) and are\n\t\tadded in this route map\n\n\t\t:param presenter: presenter to add\n\t\t:return: None\n\t\t\"\"\"\n\t\tself.__presenter_collection.add(presenter)\n\t\tif issubclass(presenter, WWebEnhancedPresenter) is True:\n\t\t\tfor route in presenter.__public_routes__():\n\t\t\t\tself.route_map().append(route)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes the given presenter as a target for the given client request.", "response": "def proxy(self, request, original_target_route, presenter_name, **kwargs):\n\t\t\"\"\" Execute the given presenter as a target for the given client request\n\n\t\t:param request: original client request\n\t\t:param original_target_route: previous target route\n\t\t:param presenter_name: target presenter name\n\t\t:param kwargs: presenter arguments\n\t\t:return: WWebResponseProto\n\t\t\"\"\"\n\n\t\taction_kwargs = kwargs.copy()\n\t\taction_name = 'index'\n\t\tif 'action' in action_kwargs:\n\t\t\taction_name = action_kwargs['action']\n\t\t\taction_kwargs.pop('action')\n\n\t\toriginal_route = original_target_route.route()\n\t\toriginal_route_map = original_target_route.route_map()\n\t\ttarget_route = WWebTargetRoute(\n\t\t\tpresenter_name, action_name, original_route, original_route_map, **action_kwargs\n\t\t)\n\t\treturn self.execute(request, target_route)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef instantiate(self, presenter_class, request, target_route, service, *args, **kwargs):\n\t\tif self.instantiable(presenter_class) is False:\n\t\t\traise RuntimeError('Presenter class is not instantiable')\n\t\treturn self.__constructors[presenter_class.__init__](presenter_class, request, target_route, service)", "response": ":meth:`.WWebPresenterFactoryProto.instantiate` method implementation.\n\n\t\tConstruct new presenter or raise en exception if it isn't possible.\n\n\t\t:param presenter_class: class to construct\n\t\t:param request: original client request\n\t\t:param target_route: target route to execute\n\t\t:param service: source (parent) service\n\t\t:param args: additional parameters (do not used)\n\t\t:param kwargs: additional parameters (do not used)\n\t\t:return: WWebPresenter"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the start of the section the given point belongs to.", "response": "def find_point_in_section_list(point, section_list):\n    \"\"\"Returns the start of the section the given point belongs to.\n\n    The given list is assumed to contain start points of consecutive\n    sections, except for the final point, assumed to be the end point of the\n    last section. For example, the list [5, 8, 30, 31] is interpreted as the\n    following list of sections: [5-8), [8-30), [30-31], so the points -32, 4.5,\n    32 and 100 all match no section, while 5 and 7.5 match [5-8) and so for\n    them the function returns 5, and 30, 30.7 and 31 all match [30-31].\n\n    Parameters\n    ---------\n    point : float\n        The point for which to match a section.\n    section_list : sortedcontainers.SortedList\n        A list of start points of consecutive sections.\n\n    Returns\n    -------\n    float\n        The start of the section the given point belongs to. None if no match\n        was found.\n\n    Example\n    -------\n    >>> from sortedcontainers import SortedList\n    >>> seclist = SortedList([5, 8, 30, 31])\n    >>> find_point_in_section_list(4, seclist)\n\n    >>> find_point_in_section_list(5, seclist)\n    5\n    >>> find_point_in_section_list(27, seclist)\n    8\n    >>> find_point_in_section_list(31, seclist)\n    30\n    \"\"\"\n    if point < section_list[0] or point > section_list[-1]:\n        return None\n    if point in section_list:\n        if point == section_list[-1]:\n            return section_list[-2]\n        ind = section_list.bisect(point)-1\n        if ind == 0:\n            return section_list[0]\n        return section_list[ind]\n    try:\n        ind = section_list.bisect(point)\n        return section_list[ind-1]\n    except IndexError:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_range_ix_in_section_list(start, end, section_list):\n    if start > section_list[-1] or end < section_list[0]:\n        return [0, 0]\n    if start < section_list[0]:\n        start_section = section_list[0]\n    else:\n        start_section = find_point_in_section_list(start, section_list)\n    if end > section_list[-1]:\n        end_section = section_list[-2]\n    else:\n        end_section = find_point_in_section_list(end, section_list)\n    return [\n        section_list.index(start_section), section_list.index(end_section)+1]", "response": "Returns the index range all sections belonging to the given range."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_range_in_section_list(start, end, section_list):\n    ind = find_range_ix_in_section_list(start, end, section_list)\n    return section_list[ind[0]: ind[1]]", "response": "This function returns all sections belonging to the given range."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_range_ix_in_point_list(start, end, point_list):\n    return [point_list.bisect_left(start), point_list.bisect_right(end)]", "response": "Returns the index range all points inside the given range."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge(self, config):\n\t\tif isinstance(config, ConfigParser) is True:\n\t\t\tself.update(config)\n\t\telif isinstance(config, str):\n\t\t\tself.read(config)", "response": "Load configuration from given configuration."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads configuration section from other configuration.", "response": "def merge_section(self, config, section_to, section_from=None):\n\t\t\"\"\" Load configuration section from other configuration. If specified section doesn't exist in current\n\t\tconfiguration, then it will be added automatically.\n\n\t\t:param config: source configuration\n\t\t:param section_to: destination section name\n\t\t:param section_from: source section name (if it is None, then section_to is used as source section name)\n\t\t:return: None\n\t\t\"\"\"\n\t\tsection_from = section_from if section_from is not None else section_to\n\t\tif section_from not in config.sections():\n\t\t\traise ValueError('There is no such section \"%s\" in config' % section_from)\n\n\t\tif section_to not in self.sections():\n\t\t\tself.add_section(section_to)\n\n\t\tfor option in config[section_from].keys():\n\t\t\tself.set(section_to, option, config[section_from][option])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking and return option from section from configuration.", "response": "def __option(self):\n\t\t\"\"\" Check and return option from section from configuration. Option name is equal to option prefix\n\n\t\t:return: tuple of section name and option prefix\n\t\t\"\"\"\n\t\tsection = self.section()\n\t\toption = self.option_prefix()\n\t\tif self.config().has_option(section, option) is False:\n\t\t\traise NoOptionError(option, section)\n\t\treturn section, option"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nselecting options from this selection that are started with the specified prefix", "response": "def select_options(self, options_prefix):\n\t\t\"\"\" Select options from this selection, that are started with the specified prefix\n\n\t\t:param options_prefix: name prefix of options that should be selected\n\t\t:return: WConfigSelection\n\t\t\"\"\"\n\t\treturn WConfigSelection(\n\t\t\tself.config(), self.section(), self.option_prefix() + options_prefix\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_option(self, option_name=None):\n\t\tif option_name is None:\n\t\t\toption_name = ''\n\t\treturn self.config().has_option(self.section(), self.option_prefix() + option_name)", "response": "Check whether the configuration selection has the specified option."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decorate_disabled(self):\n\t\tif len(self._tags) == 0:\n\t\t\treturn False\n\n\t\tif self._env_var not in os.environ:\n\t\t\treturn True\n\n\t\tenv_tags = os.environ[self._env_var].split(self.__class__.__tags_delimiter__)\n\t\tif '*' in env_tags:\n\t\t\treturn False\n\n\t\tfor tag in self._tags:\n\t\t\tif tag in env_tags:\n\t\t\t\treturn False\n\t\treturn True", "response": "Return True if this decoration must be omitted otherwise - False.\n\tThis class searches for tags values in environment variable\n\t(:attr :. Verifier. __environment_var__"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate checks for positional argument testing", "response": "def _args_checks_gen(self, decorated_function, function_spec, arg_specs):\n\t\t\"\"\" Generate checks for positional argument testing\n\n\t\t:param decorated_function: function decorator\n\t\t:param function_spec: function inspect information\n\t\t:param arg_specs: argument specification (same as arg_specs in :meth:`.Verifier.decorate`)\n\n\t\t:return: internal structure, that is used by :meth:`.Verifier._args_checks_test`\n\t\t\"\"\"\n\t\tinspected_args = function_spec.args\n\t\targs_check = {}\n\n\t\tfor i in range(len(inspected_args)):\n\t\t\targ_name = inspected_args[i]\n\n\t\t\tif arg_name in arg_specs.keys():\n\t\t\t\targs_check[arg_name] = self.check(arg_specs[arg_name], arg_name, decorated_function)\n\t\treturn args_check"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _varargs_checks_gen(self, decorated_function, function_spec, arg_specs):\n\t\tinspected_varargs = function_spec.varargs\n\n\t\tif inspected_varargs is not None and inspected_varargs in arg_specs.keys():\n\t\t\treturn self.check(\n\t\t\t\targ_specs[inspected_varargs], inspected_varargs, decorated_function\n\t\t\t)", "response": "Generates checks for positional variable argument ( varargs ) testing\n\t\t"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _kwargs_checks_gen(self, decorated_function, function_spec, arg_specs):\n\t\targs_names = []\n\t\targs_names.extend(function_spec.args)\n\t\tif function_spec.varargs is not None:\n\t\t\targs_names.append(function_spec.args)\n\n\t\targs_check = {}\n\n\t\tfor arg_name in arg_specs.keys():\n\t\t\tif arg_name not in args_names:\n\t\t\t\targs_check[arg_name] = self.check(\n\t\t\t\t\targ_specs[arg_name], arg_name, decorated_function\n\t\t\t\t)\n\t\treturn args_check", "response": "Generates checks for keyword argument testing\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns decorator that can decorate target function.", "response": "def decorator(self, **arg_specs):\n\t\t\"\"\" Return decorator that can decorate target function\n\n\t\t:param arg_specs: dictionary where keys are parameters name and values are theirs specification.\\\n\t\tSpecific specification is passed as is to :meth:`Verifier.check` method with corresponding \\\n\t\tparameter name.\n\n\t\t:return: function\n\t\t\"\"\"\n\n\t\tif self.decorate_disabled() is True:\n\t\t\tdef empty_decorator(decorated_function):\n\t\t\t\treturn decorated_function\n\t\t\treturn empty_decorator\n\n\t\tdef first_level_decorator(decorated_function):\n\n\t\t\tfunction_spec = getfullargspec(decorated_function)\n\t\t\targs_checks = self._args_checks_gen(decorated_function, function_spec, arg_specs)\n\t\t\tvarargs_check = self._varargs_checks_gen(decorated_function, function_spec, arg_specs)\n\t\t\tkwargs_checks = self._kwargs_checks_gen(decorated_function, function_spec, arg_specs)\n\n\t\t\tdef second_level_decorator(original_function, *args, **kwargs):\n\t\t\t\tself._args_checks_test(original_function, function_spec, args_checks, args, arg_specs)\n\t\t\t\tself._varargs_checks_test(original_function, function_spec, varargs_check, args, arg_specs)\n\t\t\t\tself._kwargs_checks_test(original_function, kwargs_checks, kwargs, arg_specs)\n\n\t\t\t\treturn original_function(*args, **kwargs)\n\t\t\treturn decorator(second_level_decorator)(decorated_function)\n\t\treturn first_level_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef help_info(self, exc, decorated_function, arg_name, arg_spec):\n\t\tif self._silent_checks is not True:\n\t\t\tprint('Exception raised:', file=sys.stderr)\n\t\t\tprint(str(exc), file=sys.stderr)\n\t\t\tfn_name = Verifier.function_name(decorated_function)\n\t\t\tprint('Decorated function: %s' % fn_name, file=sys.stderr)\n\t\t\tif decorated_function.__doc__ is not None:\n\t\t\t\tprint('Decorated function docstrings:', file=sys.stderr)\n\t\t\t\tprint(decorated_function.__doc__, file=sys.stderr)\n\t\t\tprint('Argument \"%s\" specification:' % arg_name, file=sys.stderr)\n\t\t\tif isfunction(arg_spec):\n\t\t\t\tprint(getsource(arg_spec), file=sys.stderr)\n\t\t\telse:\n\t\t\t\tprint(str(arg_spec), file=sys.stderr)\n\t\t\tprint('', file=sys.stderr)", "response": "Print debug information to stderr."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns function name in pretty style eliminates the owner class and the name of the function", "response": "def function_name(fn):\n\t\t\"\"\" Return function name in pretty style\n\n\t\t:param fn: source function\n\t\t:return: str\n\t\t\"\"\"\n\t\tfn_name = fn.__name__\n\t\tif hasattr(fn, '__qualname__'):\n\t\t\treturn fn.__qualname__\n\t\telif hasattr(fn, '__self__'):\n\t\t\towner = fn.__self__\n\t\t\tif isclass(owner) is False:\n\t\t\t\towner = owner.__class__\n\t\t\treturn '%s.%s' % (owner.__name__, fn_name)\n\t\treturn fn_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns callable that checks function parameter for type validity. Checks parameter if it is instance of specified class or classes.", "response": "def check(self, type_spec, arg_name, decorated_function):\n\t\t\"\"\" Return callable that checks function parameter for type validity. Checks parameter if it is\n\t\tinstance of specified class or classes\n\n\t\t:param type_spec: type or list/tuple/set of types\n\t\t:param arg_name: function parameter name\n\t\t:param decorated_function: target function\n\t\t:return: function\n\t\t\"\"\"\n\n\t\tdef raise_exception(x_spec):\n\t\t\texc_text = 'Argument \"%s\" for function \"%s\" has invalid type' % (\n\t\t\t\targ_name, Verifier.function_name(decorated_function)\n\t\t\t)\n\t\t\texc_text += ' (%s should be %s)' % (x_spec, type_spec)\n\t\t\traise TypeError(exc_text)\n\n\t\tif isinstance(type_spec, (tuple, list, set)):\n\t\t\tfor single_type in type_spec:\n\t\t\t\tif (single_type is not None) and isclass(single_type) is False:\n\t\t\t\t\traise RuntimeError(\n\t\t\t\t\t\t'Invalid specification. Must be type or tuple/list/set of types'\n\t\t\t\t\t)\n\t\t\tif None in type_spec:\n\t\t\t\ttype_spec = tuple(filter(lambda x: x is not None, type_spec))\n\t\t\t\treturn lambda x: None if x is None or isinstance(x, tuple(type_spec)) is True else \\\n\t\t\t\t\traise_exception(str((type(x))))\n\t\t\telse:\n\t\t\t\treturn lambda x: None if isinstance(x, tuple(type_spec)) is True else \\\n\t\t\t\t\traise_exception(str((type(x))))\n\t\telif isclass(type_spec):\n\t\t\treturn lambda x: None if isinstance(x, type_spec) is True else \\\n\t\t\t\traise_exception(str((type(x))))\n\t\telse:\n\t\t\traise RuntimeError('Invalid specification. Must be type or tuple/list/set of types')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns callable that checks function parameter for value validity.", "response": "def check(self, value_spec, arg_name, decorated_function):\n\t\t\"\"\" Return callable that checks function parameter for value validity. Checks parameter if its value\n\t\tpasses specified restrictions.\n\n\t\t:param value_spec: function or list/tuple/set of functions. Each function must accept one parameter and \\\n\t\tmust return True or False if it passed restrictions or not.\n\t\t:param arg_name: function parameter name\n\t\t:param decorated_function: target function\n\t\t:return: function\n\t\t\"\"\"\n\n\t\tdef raise_exception(text_spec):\n\t\t\texc_text = 'Argument \"%s\" for function \"%s\" has invalid value' % (\n\t\t\t\targ_name, Verifier.function_name(decorated_function)\n\t\t\t)\n\t\t\texc_text += ' (%s)' % text_spec\n\t\t\traise ValueError(exc_text)\n\n\t\tif isinstance(value_spec, (tuple, list, set)):\n\n\t\t\tfor single_value in value_spec:\n\t\t\t\tif isfunction(single_value) is False:\n\t\t\t\t\traise RuntimeError(\n\t\t\t\t\t\t'Invalid specification. Must be function or tuple/list/set of functions'\n\t\t\t\t\t)\n\n\t\t\tdef check(x):\n\t\t\t\tfor f in value_spec:\n\t\t\t\t\tif f(x) is not True:\n\t\t\t\t\t\traise_exception(str(x))\n\n\t\t\treturn check\n\n\t\telif isfunction(value_spec):\n\t\t\treturn lambda x: None if value_spec(x) is True else raise_exception(str(x))\n\t\telse:\n\t\t\traise RuntimeError('Invalid specification. Must be function or tuple/list/set of functions')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cache_control(validator=None, storage=None):\n\n\tdef default_validator(*args, **kwargs):\n\t\treturn True\n\n\tif validator is None:\n\t\tvalidator = default_validator\n\n\tif storage is None:\n\t\tstorage = WGlobalSingletonCacheStorage()\n\n\tdef first_level_decorator(decorated_function):\n\t\tdef second_level_decorator(original_function, *args, **kwargs):\n\n\t\t\tvalidator_check = validator(original_function, *args, **kwargs)\n\t\t\tcache_entry = storage.get_cache(original_function, *args, **kwargs)\n\n\t\t\tif validator_check is not True or cache_entry.has_value is False:\n\t\t\t\tresult = original_function(*args, **kwargs)\n\t\t\t\tstorage.put(result, original_function, *args, **kwargs)\n\t\t\t\treturn result\n\t\t\telse:\n\t\t\t\treturn cache_entry.cached_value\n\n\t\treturn decorator(second_level_decorator)(decorated_function)\n\treturn first_level_decorator", "response": "Decorator that will be used to cache the result of a function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef has(self, decorated_function, *args, **kwargs):\n\t\treturn self.get_cache(decorated_function, *args, **kwargs).has_value", "response": "Check if there is a result for given function in the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets result from storage for specified function. Will raise an exception if there is no result.", "response": "def get_result(self, decorated_function, *args, **kwargs):\n\t\t\"\"\" Get result from storage for specified function. Will raise an exception\n\t\t(:class:`.WCacheStorage.CacheMissedException`) if there is no cached result.\n\n\t\t:param decorated_function: called function (original)\n\t\t:param args: args with which function is called\n\t\t:param kwargs: kwargs with which function is called\n\n\t\t:return: (any type, even None)\n\t\t\"\"\"\n\t\tcache_entry = self.get_cache(decorated_function, *args, **kwargs)\n\t\tif cache_entry.has_value is False:\n\t\t\traise WCacheStorage.CacheMissedException('No cache record found')\n\t\treturn cache_entry.cached_value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_result(self, decorated_function, *args, **kwargs):\n\t\ttry:\n\t\t\treturn self._storage[decorated_function]\n\t\texcept KeyError as e:\n\t\t\traise WCacheStorage.CacheMissedException('No cache record found') from e", "response": "This method is used to get the result of a decorated function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking whether function is a bounded method or not.", "response": "def __check(self, decorated_function, *args, **kwargs):\n\t\t\"\"\" Check whether function is a bounded method or not. If check fails then exception is raised\n\n\t\t:param decorated_function: called function (original)\n\t\t:param args: args with which function is called\n\t\t:param kwargs: kwargs with which function is called\n\t\t:return: None\n\t\t\"\"\"\n\t\t# TODO replace this function with decorator which can be turned off like verify_* does\n\t\tif len(args) >= 1:\n\t\t\tobj = args[0]\n\t\t\tfunction_name = decorated_function.__name__\n\t\t\tif hasattr(obj, function_name) is True:\n\t\t\t\tfn = getattr(obj, function_name)\n\t\t\t\tif callable(fn) and fn.__self__ == obj:\n\t\t\t\t\treturn\n\n\t\traise RuntimeError('Only bounded methods are allowed')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put(self, result, decorated_function, *args, **kwargs):\n\t\tself.__check(decorated_function, *args, **kwargs)\n\n\t\tref = weakref.ref(args[0])\n\t\tif decorated_function not in self._storage:\n\t\t\tcache_entry = self._cache_record_cls.create(result, decorated_function, *args, **kwargs)\n\t\t\tself._storage[decorated_function] = [{'instance': ref, 'result': cache_entry}]\n\t\telse:\n\t\t\tinstance_found = False\n\t\t\tfor i in self._storage[decorated_function]:\n\t\t\t\tif i['instance']() == args[0]:\n\t\t\t\t\tcache_entry = i['result']\n\t\t\t\t\tcache_entry.update(result, *args, **kwargs)\n\t\t\t\t\tinstance_found = True\n\t\t\t\t\tbreak\n\t\t\tif instance_found is False:\n\t\t\t\tcache_entry = self._cache_record_cls.create(result, decorated_function, *args, **kwargs)\n\t\t\t\tself._storage[decorated_function].append({'instance': ref, 'result': cache_entry})\n\n\t\tdef finalize_ref():\n\t\t\tif decorated_function in self._storage:\n\t\t\t\tfn_list = self._storage[decorated_function]\n\t\t\t\tif len(fn_list) == 1 and fn_list[0]['instance'] == ref:\n\t\t\t\t\tdel self._storage[decorated_function]\n\n\t\t\t\tfor i in range(len(fn_list)):\n\t\t\t\t\tif fn_list[i]['instance'] == ref:\n\t\t\t\t\t\tfn_list.pop(i)\n\t\t\t\t\t\treturn\n\n\t\tweakref.finalize(args[0], finalize_ref)", "response": "method implementation\n\tself. put"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ensure_dir(directory: str) -> None:\n    if not os.path.isdir(directory):\n        LOG.debug(f\"Directory {directory} does not exist, creating it.\")\n        os.makedirs(directory)", "response": "Create a directory if it doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expand(directory: str) -> str:\n    temp1 = os.path.expanduser(directory)\n    return os.path.expandvars(temp1)", "response": "Apply expanduser and expandvars to directory to expand '~' and env vars."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_downloader(headers: Dict[str, str], args: Any, max_per_hour: int=30\n                        ) -> Callable[..., None]:\n    \"\"\"Create function to download with rate limiting and text progress.\"\"\"\n\n    def _downloader(url: str, dest: str) -> None:\n\n        @rate_limited(max_per_hour, args)\n        def _rate_limited_download() -> None:\n\n            # Create parent directory of file, and its parents, if they don't exist.\n            parent = os.path.dirname(dest)\n            if not os.path.exists(parent):\n                os.makedirs(parent)\n\n            response = requests.get(url, headers=headers, stream=True)\n            LOG.info(f\"Downloading from '{url}'.\")\n            LOG.info(f\"Trying to save to '{dest}'.\")\n\n            length = response.headers.get(\"content-length\")\n            if length is None:\n                total_length = 0\n            else:\n                total_length = int(length)\n\n            expected_size = (total_length / CHUNK_SIZE) + 1\n            chunks = response.iter_content(chunk_size=CHUNK_SIZE)\n\n            open(dest, \"a\", encoding=FORCED_ENCODING).close()\n            # per http://stackoverflow.com/a/20943461\n            with open(dest, \"wb\") as stream:\n                for chunk in tui.progress.bar(chunks, expected_size=expected_size):\n                    if not chunk:\n                        return\n                    stream.write(chunk)\n                    stream.flush()\n\n        _rate_limited_download()\n\n    return _downloader", "response": "Create function to download with rate limiting and text progress."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a string like 1 23 4 - 8 32 1 return a unique list of those integers in the string and the integers in the ranges in the string.", "response": "def parse_int_string(int_string: str) -> List[int]:\n    \"\"\"\n    Given a string like \"1 23 4-8 32 1\", return a unique list of those integers in the string and\n    the integers in the ranges in the string.\n    Non-numbers ignored. Not necessarily sorted\n    \"\"\"\n    cleaned = \" \".join(int_string.strip().split())\n    cleaned = cleaned.replace(\" - \", \"-\")\n    cleaned = cleaned.replace(\",\", \" \")\n\n    tokens = cleaned.split(\" \")\n    indices: Set[int] = set()\n    for token in tokens:\n        if \"-\" in token:\n            endpoints = token.split(\"-\")\n            if len(endpoints) != 2:\n                LOG.info(f\"Dropping '{token}' as invalid - weird range.\")\n                continue\n\n            start = int(endpoints[0])\n            end = int(endpoints[1]) + 1\n\n            indices = indices.union(indices, set(range(start, end)))\n\n        else:\n            try:\n                indices.add(int(token))\n            except ValueError:\n                LOG.info(f\"Dropping '{token}' as invalid - not an int.\")\n\n    return list(indices)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsanitizing a filename for use in a VFS file.", "response": "def sanitize(filename: str, platform: str=None) -> str:\n    \"\"\"\n    Remove disallowed characters from potential filename. Currently only guaranteed on Linux and\n    OS X.\n    \"\"\"\n    win_map = {\n        # taken from samba Catia module.\n        # https://www.samba.org/samba/docs/current/man-html/vfs_catia.8.html\n        \"\\\"\": \"\u00a8\",\n        \"*\": \"\u00a4\",\n        \"/\": \"\u00ff\",\n        \":\": \"\u00f7\",\n        \"<\": \"\u00ab\",\n        \">\": \"\u00bb\",\n        \"?\": \"\u00bf\",\n        \"\\\\\": \"\u00ff\",\n        \"|\": \"\u00a6\",\n    }\n\n    posix_map = {\n        \"/\": \"-\",\n    }\n\n    if platform is None:\n        platform = sys.platform\n\n    if platform.startswith(\"win32\"):\n        replace_map = win_map\n    else:\n        replace_map = posix_map\n\n    for key, entry in replace_map.items():\n        filename = filename.replace(key, entry)\n\n    return filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets up proper logging.", "response": "def set_up_logging(log_filename: str = \"log\", verbosity: int = 0) ->logging.Logger:\n    \"\"\"Set up proper logging.\"\"\"\n    LOG.setLevel(logging.DEBUG)\n\n    # Log everything verbosely to a file.\n    file_handler = RotatingFileHandler(filename=log_filename, maxBytes=1024000000, backupCount=10)\n    verbose_form = logging.Formatter(fmt=\"%(asctime)s - %(levelname)s - %(module)s - %(message)s\")\n    file_handler.setFormatter(verbose_form)\n    file_handler.setLevel(logging.DEBUG)\n    LOG.addHandler(file_handler)\n\n    # Provide a stdout handler logging at INFO.\n    stream_handler = logging.StreamHandler(sys.stdout)\n    simple_form = logging.Formatter(fmt=\"%(message)s\")\n    stream_handler.setFormatter(simple_form)\n\n    if verbosity > 0:\n        stream_handler.setLevel(logging.DEBUG)\n    else:\n        stream_handler.setLevel(logging.INFO)\n\n    LOG.addHandler(stream_handler)\n\n    return LOG"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef random_line(file_path: str, encoding: str = FORCED_ENCODING) -> str:\n    # Fancy alg from http://stackoverflow.com/a/35579149 to avoid loading full file.\n    line_num = 0\n    selected_line = \"\"\n    with open(file_path, encoding=encoding) as stream:\n        while True:\n            line = stream.readline()\n            if not line:\n                break\n            line_num += 1\n            if random.uniform(0, line_num) < 1:\n                selected_line = line\n\n    return selected_line.strip()", "response": "Get random line from a file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_percentage_from_prob(prob):\n    assert isinstance(prob, (float, int))\n    prob = float(prob)\n    assert prob >= 0\n    assert prob <= 1\n\n    percentages = list(probability_list.keys())\n    percentages.sort()\n    for percentage in percentages:\n        if prob < probability_list[percentage]:\n            return percentage - 1\n    return 100", "response": "Converts probability of being treated to total percentage of clinical cases treated\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listify(generator_func):\n    '''\n    Converts generator functions into list returning functions.\n\n    @listify\n    def test():\n        yield 1\n    test()\n    # => [1]\n    '''\n    def list_func(*args, **kwargs):\n        return degenerate(generator_func(*args, **kwargs))\n    return list_func", "response": "Returns a function that returns a list of generator functions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef locations_within(a, b, tolerance):\n    ret = ''\n    # Clone b so that we can destroy it.\n    b = dict(b)\n\n    for (key, value) in a.items():\n        if key not in b:\n            raise ValueError(\"b does not have the key: \" + key)\n        if abs(int(value) - int(b[key])) > tolerance:\n            ret += 'key {0} differs: {1} {2}'.format(key, int(value),\n                                                     int(b[key]))\n        del b[key]\n\n    if b:\n        raise ValueError(\"keys in b not seen in a: \" + \", \".join(b.keys()))\n\n    return ret", "response": "Returns a string that contains the differences between two dicts a and b."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches for descendants of a parent element that matches a regular expression.", "response": "def find_descendants_by_text_re(self, parent, re, immediate=False):\n        \"\"\"\n        :param parent: The parent element into which to search.\n        :type parent:\n                      :class:`selenium.webdriver.remote.webelement.WebElement`\n                      or :class:`str`. When a string is specified, it\n                      is interpreted as a CSS selector.\n        :param re: A regular expression in JavaScript syntax.\n        :type re: :class:`str`\n        :param immediate: Whether or not the function should return\n                          immediately. If ``False``, the function will\n                          wait until there **are** descendants to\n                          return. If ``True`` it will return immediately.\n        :type immediate: :class:`bool`\n        :returns: The descendants whose text (as returned by\n                  ``jQuery().text()``) match the regular expression.\n\n        \"\"\"\n\n        def cond(*_):\n            return self.driver.execute_script(\"\"\"\n            var parent = arguments[0];\n            if (typeof parent === \"string\")\n                parent = document.querySelector(parent);\n            var re = new RegExp(arguments[1]);\n            var ret = [];\n            var nodes = parent.querySelectorAll(\"*\");\n            for(var i = 0, node; (node = nodes[i]) !== undefined; ++i)\n                if (re.test(node.textContent.trim()))\n                    ret.push(node);\n            return ret;\n            \"\"\", parent, re)\n\n        return self.wait(cond) if not immediate else cond()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef command_x(self, x, to=None):\n        if to is None:\n            ActionChains(self.driver) \\\n                .send_keys([Keys.COMMAND, x, Keys.COMMAND]) \\\n                .perform()\n        else:\n            self.send_keys(to, [Keys.COMMAND, x, Keys.COMMAND])", "response": "Sends a character to the currently active element with Command\n        pressed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_keys(self, element, x):\n        ActionChains(self.driver) \\\n            .send_keys_to_element(element, x) \\\n            .perform()", "response": "Sends the specified modifiers key to the specified element."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef element_screen_center(self, element):\n        pos = self.element_screen_position(element)\n        size = element.size\n        pos[\"top\"] += int(size[\"height\"] / 2)\n        pos[\"left\"] += int(size[\"width\"] / 2)\n        return pos", "response": "Returns the center point of the element in the screen."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef visible_to_user(self, element, *ignorable):\n        if not element.is_displayed():\n            return False\n        return self.driver.execute_script(\"\"\"\n        var el = arguments[0];\n        var ignorable = arguments[1];\n\n        var old_displays = ignorable.map(function (x) {\n            var old = x.style.display;\n            x.style.display = \"none\";\n            return old;\n        });\n        try {\n            var rect = el.getBoundingClientRect();\n            // Sigh... we need to round the numbers to avoid running into\n            // factional pixels causing the following test to fail.\n            rect = {\n              left: Math.ceil(rect.left),\n              right: Math.floor(rect.right),\n              top: Math.ceil(rect.top),\n              bottom: Math.floor(rect.bottom)\n            }\n            var ret = false;\n\n            var efp = document.elementFromPoint.bind(document);\n            var at_corner;\n            ret = ((at_corner = efp(rect.left, rect.top)) === el) ||\n                   el.contains(at_corner) ||\n                  ((at_corner = efp(rect.left, rect.bottom)) === el) ||\n                   el.contains(at_corner) ||\n                  ((at_corner = efp(rect.right, rect.top)) === el) ||\n                   el.contains(at_corner) ||\n                  ((at_corner = efp(rect.right, rect.bottom)) === el) ||\n                   el.contains(at_corner);\n        }\n        finally {\n            var ix = 0;\n            ignorable.forEach(function (x) {\n                x.style.display = old_displays[ix];\n                ix++;\n            });\n        }\n        return ret;\n        \"\"\", element, ignorable)", "response": "Determines whether an element is visible to the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwaiting for a condition to be true.", "response": "def wait(self, condition):\n        \"\"\"\n        Waits for a condition to be true.\n\n        :param condition: Should be a callable that operates in the\n                          same way ``WebDriverWait.until`` expects.\n        :returns: Whatever ``WebDriverWait.until`` returns.\n        \"\"\"\n        return WebDriverWait(self.driver, self.timeout).until(condition)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait_until_not(self, condition):\n        return WebDriverWait(self.driver, self.timeout).until_not(condition)", "response": "Waits for a condition to be false."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nasserts that two items for identity are equal.", "response": "def assert_same(self, first, second):\n        \"\"\"\n        Compares two items for identity. The items can be either single\n        values or lists of values. When comparing lists, identity\n        obtains when the two lists have the same number of elements\n        and that the element at position in one list is identical to\n        the element at the same position in the other list.\n\n        This method is meant to be used for comparing lists of DOM\n        nodes. It would also work with lists of booleans, integers,\n        and similar primitive types, but is pointless in such\n        cases. Also note that this method cannot meaningfully compare\n        lists of lists or lists of dictionaries since the objects that\n        would be part of the list would be created anew by Selenium's\n        marshalling procedure. Hence, in these cases, the assertion\n        would always fail.\n\n        :param first: The first item to compare.\n        :type first:\n                     :class:`selenium.webdriver.remote.webelement.WebElement`\n                     or array of\n                     :class:`selenium.webdriver.remote.webelement.WebElement`.\n        :param second: The second item to compare.\n        :type second:\n           :class:`selenium.webdriver.remote.webelement.WebElement` or\n           :array of\n           :class:`selenium.webdriver.remote.webelement.WebElement`.\n        :raises: :class:`AssertionError` when unequal.\n        \"\"\"\n        if not isinstance(first, list):\n            first = [first]\n        if not isinstance(second, list):\n            second = [second]\n        if not self.driver.execute_script(\"\"\"\n        var first = arguments[0];\n        var second = arguments[1];\n        if (first.length != second.length)\n            return false;\n        for(var i = 0; i < first.length; ++i)\n            if (first[i] !== second[i])\n                return false;\n        return true;\n        \"\"\", first, second):\n            raise AssertionError(\"unequal\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a generator that returns a new revision document with the given persistence field.", "response": "def persistence2stats(rev_docs, min_persisted=5, min_visible=1209600,\n                      include=None, exclude=None, verbose=False):\n    \"\"\"\n    Processes a sorted and page-partitioned sequence of revision documents into\n    and adds statistics to the 'persistence' field each token \"added\" in the\n    revision persisted through future revisions.\n\n    :Parameters:\n        rev_docs : `iterable` ( `dict` )\n            JSON documents of revision data containing a 'diff' field as\n            generated by ``dump2diffs``.  It's assumed that rev_docs are\n            partitioned by page and otherwise in chronological order.\n        window_size : `int`\n            The size of the window of revisions from which persistence data\n            will be generated.\n        min_persisted : `int`\n            The minimum future revisions that a token must persist in order\n            to be considered \"persistent\".\n        min_visible : `int`\n            The minimum number of seconds that a token must be visible in order\n            to be considered \"persistent\".\n        include : `func`\n            A function that returns `True` when a token should be included in\n            statistical processing\n        exclude : `str` | `re.SRE_Pattern`\n            A function that returns `True` when a token should *not* be\n            included in statistical processing (Takes precedence over\n            'include')\n        verbose : `bool`\n            Prints out dots and stuff to stderr\n\n    :Returns:\n        A generator of rev_docs with a 'persistence' field containing\n        statistics about individual tokens.\n    \"\"\"\n    rev_docs = mwxml.utilities.normalize(rev_docs)\n\n    min_persisted = int(min_persisted)\n    min_visible = int(min_visible)\n    include = include if include is not None else lambda t: True\n    exclude = exclude if exclude is not None else lambda t: False\n\n    for rev_doc in rev_docs:\n        persistence_doc = rev_doc['persistence']\n        stats_doc = {\n            'tokens_added': 0,\n            'persistent_tokens': 0,\n            'non_self_persistent_tokens': 0,\n            'sum_log_persisted': 0,\n            'sum_log_non_self_persisted': 0,\n            'sum_log_seconds_visible': 0,\n            'censored': False,\n            'non_self_censored': False\n        }\n\n        filtered_docs = (t for t in persistence_doc['tokens']\n                         if include(t['text']) and not exclude(t['text']))\n        for token_doc in filtered_docs:\n            if verbose:\n                sys.stderr.write(\".\")\n                sys.stderr.flush()\n\n            stats_doc['tokens_added'] += 1\n            stats_doc['sum_log_persisted'] += log(token_doc['persisted'] + 1)\n            stats_doc['sum_log_non_self_persisted'] += \\\n                log(token_doc['non_self_persisted'] + 1)\n            stats_doc['sum_log_seconds_visible'] += \\\n                log(token_doc['seconds_visible'] + 1)\n\n            # Look for time threshold\n            if token_doc['seconds_visible'] >= min_visible:\n                stats_doc['persistent_tokens'] += 1\n                stats_doc['non_self_persistent_tokens'] += 1\n            else:\n                # Look for review threshold\n                stats_doc['persistent_tokens'] += \\\n                    token_doc['persisted'] >= min_persisted\n\n                stats_doc['non_self_persistent_tokens'] += \\\n                    token_doc['non_self_persisted'] >= min_persisted\n\n                # Check for censoring\n                if persistence_doc['seconds_possible'] < min_visible:\n                    stats_doc['censored'] = True\n                    stats_doc['non_self_censored'] = True\n\n                else:\n                    if persistence_doc['revisions_processed'] < min_persisted:\n                        stats_doc['censored'] = True\n\n                    if persistence_doc['non_self_processed'] < min_persisted:\n                        stats_doc['non_self_censored'] = True\n\n        if verbose:\n            sys.stderr.write(\"\\n\")\n            sys.stderr.flush()\n\n        rev_doc['persistence'].update(stats_doc)\n\n        yield rev_doc"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef healthy(self):\n\t\tstate = None\n\t\tfor sensor in self._sensors.values():\n\t\t\tif sensor.healthy() is False:\n\t\t\t\tif state is None or sensor.severity().value > state.value:\n\t\t\t\t\tstate = sensor.severity()\n\t\t\t\tif state == WTaskHealthSensor.WTaskSensorSeverity.critical:\n\t\t\t\t\tbreak\n\n\t\treturn state", "response": "Return task health. If None - task is healthy otherwise - maximum severity of sensors is critical."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef preproc(self, which='sin', **kwargs):\n        self.app_main(**kwargs)\n        config = self.exp_config\n        config['infile'] = infile = osp.join(config['expdir'], 'input.dat')\n\n        func = getattr(np, which)  # np.sin, np.cos or np.tan\n        data = func(np.linspace(-np.pi, np.pi))\n        self.logger.info('Saving input data to %s', infile)\n        np.savetxt(infile, data)", "response": "Create preprocessing data for the base class"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mounts(cls):\n\t\tresult = []\n\t\twith open(cls.__mounts_file__) as f:\n\t\t\tfor mount_record in f:\n\t\t\t\tresult.append(WMountPoint(mount_record))\n\t\treturn tuple(result)", "response": "Return tuple of current mount points"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mount_point(cls, file_path):\n\t\tmount = None\n\n\t\tfor mp in cls.mounts():\n\t\t\tmp_path = mp.path()\n\t\t\tif file_path.startswith(mp_path) is True:\n\t\t\t\tif mount is None or len(mount.path()) <= len(mp_path):\n\t\t\t\t\tmount = mp\n\n\t\treturn mount", "response": "Return the mount point that where the given path is reside on\n\t\t"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mount(cls, device, mount_directory, fs=None, options=None, cmd_timeout=None, sudo=False):\n\t\tcmd = [] if sudo is False else ['sudo']\n\t\tcmd.extend(['mount', device, os.path.abspath(mount_directory)])\n\t\tif fs is not None:\n\t\t\tcmd.extend(['-t', fs])\n\t\tif options is not None and len(options) > 0:\n\t\t\tcmd.append('-o')\n\t\t\tcmd.extend(options)\n\n\t\tsubprocess.check_output(cmd, timeout=cmd_timeout)", "response": "Mount a device to a given mount directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve all OrganizationTypes in the current session", "response": "def get_org_types(self):\n        \"\"\"\n        Retrieves all current OrganizationType objects\n        \"\"\"\n        if not self.client.session_id:\n            self.client.request_session()\n\n        object_query = \"SELECT Objects() FROM OrganizationType\"\n        result = self.client.execute_object_query(object_query=object_query)\n        msql_result = result['body'][\"ExecuteMSQLResult\"]\n        return self.package_org_types(msql_result[\"ResultValue\"]\n                                      [\"ObjectSearchResult\"]\n                                      [\"Objects\"][\"MemberSuiteObject\"]\n                                      )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef package_org_types(self, obj_list):\n        org_type_list = []\n        for obj in obj_list:\n            sane_obj = convert_ms_object(\n                obj['Fields']['KeyValueOfstringanyType']\n            )\n            org = OrganizationType(sane_obj)\n            org_type_list.append(org)\n        return org_type_list", "response": "Packs the list of OrganizationType objects into a list of OrganizationType objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_individuals_for_primary_organization(self,\n                                                 organization):\n        \"\"\"\n        Returns all Individuals that have `organization` as a primary org.\n\n        \"\"\"\n        if not self.client.session_id:\n            self.client.request_session()\n\n        object_query = (\"SELECT Objects() FROM Individual WHERE \"\n                        \"PrimaryOrganization = '{}'\".format(\n                            organization.membersuite_account_num))\n\n        result = self.client.execute_object_query(object_query)\n\n        msql_result = result[\"body\"][\"ExecuteMSQLResult\"]\n\n        if msql_result[\"Success\"]:\n            membersuite_objects = (msql_result[\"ResultValue\"]\n                                   [\"ObjectSearchResult\"]\n                                   [\"Objects\"])\n        else:\n            raise ExecuteMSQLError(result=result)\n\n        individuals = []\n\n        if membersuite_objects is not None:\n            for membersuite_object in membersuite_objects[\"MemberSuiteObject\"]:\n                individuals.append(\n                    Individual(membersuite_object_data=membersuite_object))\n\n        return individuals", "response": "Returns all Individuals that have organization as a primary org."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts string permission flags into integer permission flags as specified in const. PERM_STRING_MAP.", "response": "def int_flags(flags, mapper=const.PERM_STRING_MAP):\n    \"\"\"\n    Converts string permission flags into integer permission flags as\n    specified in const.PERM_STRING_MAP\n    Arguments:\n        - flags <str>: one or more flags\n            For example: \"crud\" or \"ru\" or \"r\"\n        - mapper <list=const.PERM_STRING_MAP>: a list containing tuples mapping\n            int permission flag to string permission flag. If not specified will\n            default to const.PERM_STRING_MAP.\n    Returns:\n        - int\n    \"\"\"\n\n    r = 0\n    if not flags:\n        return r\n\n    if isinstance(flags, six.integer_types):\n        return flags\n\n    if not isinstance(flags, six.string_types):\n        raise TypeError(\"`flags` needs to be a string or integer type\")\n\n    for f in flags:\n        for f_i, f_s in mapper:\n            if f_s == f:\n                r = r | f_i\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match(self, keys, partial=True):\n        if not partial and len(keys) != self.length:\n            return False\n        c = 0\n        for k in keys:\n            if c >= self.length:\n                return False\n            a = self.keys[c]\n            if a != \"*\" and k != \"*\" and k != a:\n                return False\n            c += 1\n\n        return True", "response": "Check if the value of this namespace is matched by the given list of keys."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the permissionset with a dict of namespace<str>: permission<int|long > pairs.", "response": "def update(self, permissions):\n        \"\"\"\n        Update the permissionset with a dict of namespace<str>:permission<Permission|int|long>\n        pairs\n\n        Example:\n\n            pset.update(\n              {\n                \"a\" : const.PERM_READ,\n                \"b\" : Permission(\"b\", const.PERM_RW)\n              }\n            )\n        \"\"\"\n        for k, v in list(permissions.items()):\n            self.__setitem__(k, v, reindex=False)\n        self.update_index()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_index(self):\n\n        # update index\n\n        idx = {}\n        for _, p in sorted(self.permissions.items(), key=lambda x: str(x[0])):\n            branch = idx\n            parent_p = const.PERM_DENY\n            for k in p.namespace.keys:\n                if not k in branch:\n                    branch[k] = {\"__\": parent_p}\n                    branch[k].update(__implicit=True)\n\n                branch = branch[k]\n                parent_p = branch[\"__\"]\n            branch[\"__\"] = p.value\n            branch[\"__implicit\"] = False\n\n        self.index = idx\n\n        # update read access map\n\n        ramap = {}\n\n        def update_ramap(branch_idx):\n            r = {\"__\": False}\n            for k, v in list(branch_idx.items()):\n                if k != \"__\" and k != \"__implicit\":\n                    r[k] = update_ramap(v)\n\n            if branch_idx[\"__\"] is not None and (branch_idx[\"__\"] & const.PERM_READ) != 0:\n                r[\"__\"] = True\n            return r\n\n        for k, v in list(idx.items()):\n            ramap[k] = update_ramap(v)\n\n        self.read_access_map = ramap\n\n        return self.index", "response": "Updates the index of the permission index for this set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the permissions level for the specified namespace", "response": "def get_permissions(self, namespace, explicit=False):\n        \"\"\"\n        Returns the permissions level for the specified namespace\n\n        Arguments:\n\n        namespace -- permissioning namespace (str)\n        explicit -- require explicitly set permissions to the provided namespace\n\n        Returns:\n\n        int -- permissioning flags\n        \"\"\"\n\n        if not isinstance(namespace, Namespace):\n            namespace = Namespace(namespace)\n        keys = namespace.keys\n        p, _ = self._check(keys, self.index, explicit=explicit)\n        return p"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the permset has permission to the specified namespace at the specified level.", "response": "def check(self, namespace, level, explicit=False):\n        \"\"\"\n        Checks if the permset has permission to the specified namespace\n        at the specified level\n\n        Arguments:\n\n        namespace -- permissioning namespace (str)\n        level -- permissioning level (int) (PERM_READ for example)\n        explicit -- require explicitly set permissions to the provided namespace\n\n        Returns:\n\n        bool\n        \"\"\"\n\n        return (self.get_permissions(namespace, explicit=explicit) & level) != 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply permissions in this set to the provided data.", "response": "def apply(self, data, path=None, applicator=None):\n        \"\"\"\n        Apply permissions in this set to the provided data, effectively\n        removing all keys from it are not permissioned to be viewed\n\n        Arguments:\n\n        data -- dict of data\n\n        Returns:\n\n        Cleaned data\n        \"\"\"\n\n        if applicator:\n            applicator.pset = self\n        else:\n            applicator = Applicator(self)\n\n        return applicator.apply(data, path=path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply(self, data, path=None):\n\n        if path is None:\n            path = []\n\n        if not isinstance(data, dict):\n            return data\n\n        def _enumerate(value):\n            if isinstance(value, list):\n                for k, v in enumerate(value):\n                    yield k, v\n            elif isinstance(value, dict):\n                for k, v in value.items():\n                    yield k, v\n\n        def _set(container, key, value):\n            if isinstance(container, list):\n                container.append(value)\n            else:\n                container[key] = value\n\n        def _apply(ramap, value, status=False, wc=False, path=[]):\n\n\n            if not isinstance(value, dict) and not isinstance(value, list):\n                if status:\n                    return value\n                else:\n                    return None\n\n            if not wc:\n                status = ramap.get(\"__\", status)\n\n            handler = None\n            key_handler = None\n            if path and self.handlers:\n                namespace = Namespace(path)\n                for _handler in self.handlers.values():\n                    if namespace.match(_handler.get(\"namespace\").keys, partial=False):\n                        handler = _handler\n                        key_handler = handler.get(\"key\")\n                        break\n\n            if isinstance(value, list):\n                if not key_handler:\n                    key_handler = list_key_handler\n                rv = []\n            else:\n                rv = {}\n\n            for k, v in _enumerate(value):\n                if key_handler:\n                    k = key_handler(v, k)\n                k = str(k)\n                if isinstance(v, dict) or isinstance(v, list):\n                    if k in ramap:\n                        r = _apply(ramap[k], v, status=status, path=path+[k])\n                        if r:\n                            _set(rv, k, r)\n                    elif \"*\" in ramap:\n                        r = _apply(ramap[\"*\"], v, status=status, wc=True, path=path+[k])\n                        if r:\n                            _set(rv, k, r)\n                    elif status:\n                        _set(rv, k, v)\n                else:\n                    if k in ramap:\n                        if ramap[k].get(\"__\", True):\n                            _set(rv, k, v)\n                    elif \"*\" in ramap and ramap[\"*\"].get(\"__\", True):\n                        _set(rv, k, v)\n                    elif status:\n                        _set(rv, k, v)\n\n            return rv\n\n        # loop through all the handlers that specify the `explicit` arguments\n        # and temprorarily add deny rules for those to the targeted permissionset\n        tmpns = {}\n        for ns, handler in self.handlers.items():\n            if handler.get(\"explicit\"):\n                p = self.pset.get_permissions(ns)\n                if p & const.PERM_READ:\n                    exists = False\n                    for _ns in self.pset.namespaces:\n                        if Namespace(_ns).match(Namespace(ns).keys, partial=False):\n                            exists = True\n                            break\n                    if exists:\n                        continue\n                    tmpns[ns] = p\n                    self.pset[ns] = const.PERM_DENY\n\n\n        # apply permissions\n        rv = _apply(self.pset.read_access_map, data)\n\n        # remove temporarily added deny rules\n        for ns, p in tmpns.items():\n            if p is None:\n                del self.pset[ns]\n            else:\n                self.pset[ns] = p\n\n        return rv", "response": "Applies permissions in this set to the provided data effectively removing all keys from it are not permissioned to be viewed\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hash(self, key, message=None):\n\t\thmac_obj = hmac.HMAC(key, self.__digest_generator, backend=default_backend())\n\t\tif message is not None:\n\t\t\thmac_obj.update(message)\n\t\treturn hmac_obj.finalize()", "response": "Return digest of the given message and key"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_with_search_field(self, name, callback):\n        done = False\n        while not done:\n            def check(*_):\n                if name in self._search_fields:\n                    return True\n\n                # Force a refetch\n                self._found_fields = None\n                return False\n\n            self.util.wait(check)\n            field = self._search_fields[name]\n            try:\n                callback(field)\n                done = True\n            except StaleElementReferenceException:\n                # We force a refetch of the fields\n                self._found_fields = None", "response": "Calls a piece of code with the DOM element that corresponds to the search field of the table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef determine_keymap(qteMain=None):\n    if qteMain is None:\n        # This case should only happen for testing purposes.\n        qte_global.Qt_key_map = default_qt_keymap\n        qte_global.Qt_modifier_map = default_qt_modifier_map\n    else:\n        doc = 'Conversion table from local characters to Qt constants'\n        qteMain.qteDefVar(\"Qt_key_map\", default_qt_keymap, doc=doc)\n        doc = 'Conversion table from local modifier keys to Qt constants'\n        qteMain.qteDefVar(\"Qt_modifier_map\", default_qt_modifier_map, doc=doc)", "response": "Return the conversion from local keys and modifiers to Qt constants."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef func(name):\n    # Raise condition evaluated in same call as exception addition\n    pexdoc.addex(TypeError, \"Argument `name` is not valid\", not isinstance(name, str))\n    return \"My name is {0}\".format(name)", "response": "r Print your name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef disableHook(self, msgObj):\n        # Unpack the data structure.\n        macroName, keysequence = msgObj.data\n        if macroName != self.qteMacroName():\n            self.qteMain.qtesigKeyseqComplete.disconnect(\n                self.disableHook)\n            self.killListIdx = -1", "response": "Disable the yank - pop hook."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef commit(self):\n\n        # Get the number of lines and columns in last line.\n        last_line, last_col = self.qteWidget.getNumLinesAndColumns()\n\n        # If this is the first ever call to this undo/redo element\n        # then backup the current cursor- and marker position because\n        # both will be required for the redo operation.\n        if self.cursorPos is None:\n            # Get the default marker and ensure it points to a\n            # valid location inside the document.\n            self.markerPos = self.qteWidget.qteGetMark()\n            if self.markerPos is None:\n                return\n            if not self.qteWidget.isPositionValid(*self.markerPos):\n                return\n\n            # Backup the current cursor and marker position; swap\n            # one for the other if necessary to ensure the marker\n            # comes first.\n            self.cursorPos = self.qteWidget.getCursorPosition()\n            if self.cursorPos[0] < self.markerPos[0]:\n                self.cursorPos, self.markerPos = self.markerPos, self.cursorPos\n\n        # Shorthand for qteWidget and left/right position of rectangle.\n        wid = self.qteWidget\n        col1 = min((self.markerPos[1], self.cursorPos[1]))\n        col2 = max((self.markerPos[1], self.cursorPos[1]))\n\n        # Insert the specified string at the same position in every line\n        # in between the mark and the cursor (inclusive).\n        self.removedText = []\n        for line in range(self.markerPos[0], self.cursorPos[0] + 1):\n            text = wid.text(line)\n            if col1 >= len(text):\n                # If the line has no text in the specified column\n                # range then ignore it.\n                self.removedText.append('')\n                continue\n            if col2 > len(text):\n                # If the col1-col2 range spans only part of the\n                # line then select only that part.\n                wid.setSelection(line, col1, line, col1)\n                wid.SendScintilla(wid.SCI_LINEENDEXTEND, 0, 0)\n            else:\n                # If the col1-col2 range is a subset of the entire\n                # line then select the entire range.\n                wid.setSelection(line, col1, line, col2)\n\n            # Backup and remove the selected text.\n            self.removedText.append(self.qteWidget.selectedText())\n            self.baseClass.removeSelectedText()\n\n        self.qteWidget.setCursorPosition(self.cursorPos[0], self.markerPos[1])\n\n        # Determine the user selected string length and initialise the global\n        # variable qteKilledTextFromRectangle with an empty dictionary.\n        strlen = col2 - col1\n        global qteKilledTextFromRectangle\n        qteKilledTextFromRectangle = []\n\n        # Copy the removed text into the global variable\n        # 'qteKilledTextFromRectangle' so that YankRectangle can\n        # access it. However, ensure that every element has exactly\n        # the length specified by the user defined rectangle; zero pad\n        # elements that are too short. Note: do not apply this zero\n        # padding to self.removedText because otherwise the text could\n        # not be undone correctly.\n        for el in self.removedText:\n            # Determine how many white space characters are required\n            # to make the string 'strLen' characters long.\n            pad = strlen - len(el)\n\n            # Sanity check.\n            if pad < 0:\n                qteKillTextFromRectangle = None\n                self.qteWidget.setCursorPosition(*self.cursorPos)\n                self.cursorPos = self.markerPos = None\n                msg = 'Padding length cannot be negative --> this is a bug'\n                self.qteLogger.error(msg)\n                return\n\n            # Store the padded version of the string.\n            qteKilledTextFromRectangle.append(el + ' ' * pad)", "response": "Commit the current selection of the element."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reverseCommit(self):\n\n        if self.markerPos is None:\n            return\n\n        # Remove the specified string from the same position in every line\n        # in between the mark and the cursor (inclusive).\n        col = min((self.markerPos[1], self.cursorPos[1]))\n        rng = range(self.markerPos[0], self.cursorPos[0] + 1)\n        for idx, line in enumerate(rng):\n            text = self.removedText[idx]\n            if text != '':\n                self.baseClass.insertAt(text, line, col)\n\n        self.qteWidget.setCursorPosition(*self.cursorPos)", "response": "Re - insert the previously deleted line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef commit(self):\n\n        # Get the number of lines and columns in the last line.\n        last_line, last_col = self.qteWidget.getNumLinesAndColumns()\n\n        # If this is the first ever call to this undo/redo element\n        # then backup the current cursor position because\n        # it will be required for the redo operation.\n        if self.cursorPos is None:\n            if qteKilledTextFromRectangle is None:\n                return\n            self.insertedText = list(qteKilledTextFromRectangle)\n            self.cursorPos = self.qteWidget.getCursorPosition()\n        else:\n            self.qteWidget.setCursorPosition(*self.cursorPos)\n\n        # Insert the killed strings into their respective lines.\n        col = self.cursorPos[1]\n        for ii, text in enumerate(self.insertedText):\n            line = ii + self.cursorPos[0]\n            self.baseClass.insertAt(text, line, col)", "response": "Commit the current cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reverseCommit(self):\n\n        # Loop over all lines in the rectangle to remove the\n        # previously yanked strings.\n        col = self.cursorPos[1]\n        for ii, text in enumerate(self.insertedText):\n            line = ii + self.cursorPos[0]\n\n            # Select as many characters as the string is long and remove\n            # them.\n            self.qteWidget.setSelection(line, col, line, col + len(text))\n            self.baseClass.removeSelectedText()\n\n        # Place the cursor at the original position.\n        self.qteWidget.setCursorPosition(*self.cursorPos)", "response": "Re - insert the previously deleted line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncommit the current state of the current element.", "response": "def commit(self):\n        \"\"\"\n        Insert the specified text in all selected lines, always\n        at the same column position.\n        \"\"\"\n\n        # Get the number of lines and columns in last line.\n        last_line, last_col = self.qteWidget.getNumLinesAndColumns()\n\n        # If this is the first ever call to this undo/redo element\n        # then backup the current cursor- and marker position because\n        # both will be required for the redo operation.\n        if self.cursorPos is None:\n            # Get the default marker and ensure it points to a\n            # valid location inside the document.\n            self.markerPos = self.qteWidget.qteGetMark()\n            if self.markerPos is None:\n                return\n            if not self.qteWidget.isPositionValid(*self.markerPos):\n                return\n\n            # Backup the current cursor and marker position; swap\n            # one for the other if necessary to ensure the marker\n            # comes first.\n            self.cursorPos = self.qteWidget.getCursorPosition()\n            if self.cursorPos[0] < self.markerPos[0]:\n                self.cursorPos, self.markerPos = self.markerPos, self.cursorPos\n\n        # Insert the specified string at the same position in every line\n        # in between the mark and the cursor (inclusive).\n        col = min((self.markerPos[1], self.cursorPos[1]))\n        for line in range(self.markerPos[0], self.cursorPos[0] + 1):\n            self.baseClass.insertAt(self.text, line, col)\n\n        self.qteWidget.setCursorPosition(*self.cursorPos)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reverseCommit(self):\n\n        if self.markerPos is None:\n            return\n\n        # Remove the specified string from the same position in every line\n        # in between the mark and the cursor (inclusive).\n        col = min((self.markerPos[1], self.cursorPos[1]))\n        for line in range(self.markerPos[0], self.cursorPos[0] + 1):\n            self.qteWidget.setSelection(line, col, line, col + len(self.text))\n            self.baseClass.removeSelectedText()\n\n        self.qteWidget.setCursorPosition(*self.cursorPos)", "response": "Re - insert the previously deleted line."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clearHighlighting(self):\n        SCI = self.qteWidget\n        self.qteWidget.SCISetStylingEx(0, 0, self.styleOrig)\n\n        # Clear out the match set and reset the match index.\n        self.selMatchIdx = 1\n        self.matchList = []", "response": "Clears the highlighting of the current item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhighlighting the next possible match in the set of matches.", "response": "def highlightNextMatch(self):\n        \"\"\"\n        Select and highlight the next match in the set of matches.\n        \"\"\"\n        # If this method was called on an empty input field (ie.\n        # if the user hit <ctrl>+s again) then pick the default\n        # selection.\n        if self.qteText.toPlainText() == '':\n            self.qteText.setText(self.defaultChoice)\n            return\n\n        # If the mathIdx variable is out of bounds (eg. the last possible\n        # match is already selected) then wrap it around.\n        if self.selMatchIdx < 0:\n            self.selMatchIdx = 0\n            return\n        if self.selMatchIdx >= len(self.matchList):\n            self.selMatchIdx = 0\n            return\n\n        # Shorthand.\n        SCI = self.qteWidget\n\n        # Undo the highlighting of the previously selected match.\n        start, stop = self.matchList[self.selMatchIdx - 1]\n        line, col = SCI.lineIndexFromPosition(start)\n        SCI.SendScintilla(SCI.SCI_STARTSTYLING, start, 0xFF)\n        SCI.SendScintilla(SCI.SCI_SETSTYLING, stop - start, 30)\n\n        # Highlight the next match.\n        start, stop = self.matchList[self.selMatchIdx]\n        SCI.SendScintilla(SCI.SCI_STARTSTYLING, start, 0xFF)\n        SCI.SendScintilla(SCI.SCI_SETSTYLING, stop - start, 31)\n\n        # Place the cursor at the start of the currently selected match.\n        line, col = SCI.lineIndexFromPosition(start)\n        SCI.setCursorPosition(line, col)\n        self.selMatchIdx += 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qteTextChanged(self):\n        # Remove any previous highlighting.\n        self.clearHighlighting()\n        SCI = self.qteWidget\n\n        # Compile a list of spans that contain the specified string.\n        self.compileMatchList()\n\n        # Return if the substring does not exist in the text.\n        if len(self.matchList) == 0:\n            return\n\n        # ------------------------------------------------------------\n        # Make a copy of the style bits of the document, overwrite\n        # those parts containing a substring, and then write them\n        # back all at once. This is much faster than calling the\n        # styling methods repeatedly.\n        # ------------------------------------------------------------\n\n        # Make a copy of the document style bits and determine the\n        # cursor position in the document.\n        style = bytearray(self.styleOrig)\n        cur = SCI.positionFromLineIndex(*self.cursorPosOrig)\n\n        # Style all matches.\n        self.selMatchIdx = 0\n        for start, stop in self.matchList:\n            if start < cur:\n                self.selMatchIdx += 1\n            style[start:stop] = bytes(b'\\x1e') * (stop - start)\n\n        # If the cursor is after the last possible match (eg. always\n        # the case when the cursor is at the end of the file) then\n        # self.selMatchIdx will point beyond the list.\n        if self.selMatchIdx == len(self.matchList):\n            self.selMatchIdx = 0\n\n        # Style the first match after the current cursor position\n        # differently to indicate that it is the currently\n        # selected one.\n        start, stop = self.matchList[self.selMatchIdx]\n        style[start:stop] = bytes(b'\\x1f') * (stop - start)\n\n        # Place the cursor at the start of the currently selected match.\n        line, col = SCI.lineIndexFromPosition(start)\n        SCI.setCursorPosition(line, col)\n        self.selMatchIdx += 1\n\n        # Apply the modified style array to the document.\n        self.qteWidget.SCISetStylingEx(0, 0, style)", "response": "Update the highlighting of the new text."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qteAbort(self, msgObj):\n        self.qteWidget.setCursorPosition(*self.cursorPosOrig)\n        self.qteMain.qtesigAbort.disconnect(self.qteAbort)", "response": "Disconnect from the abort signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qteToBeKilled(self):\n        self.clearHighlighting()\n        self.qteWidget.qteSetLexer(self.originalLexer)\n        self.qteText.textChanged.disconnect(self.qteTextChanged)", "response": "Mark the widget as killed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nextMode(self):\n        # Terminate the replacement procedure if the no match was found.\n        if len(self.matchList) == 0:\n            self.qteAbort(QtmacsMessage())\n            self.qteMain.qteKillMiniApplet()\n            return\n\n        self.queryMode += 1\n        if self.queryMode == 1:\n            # Disconnect the text-changed slot because no real time\n            # highlighting is necessary when entering the replacement\n            # string, unlike when entering the string to replace.\n            self.qteText.textChanged.disconnect(self.qteTextChanged)\n\n            # Store the string to replace and clear out the query field.\n            self.toReplace = self.qteText.toPlainText()\n            self.qteText.clear()\n            self.qteTextPrefix.setText('mode 1')\n        elif self.queryMode == 2:\n            # Mode two is to replace or skip individual matches. For\n            # this purpose rebind the \"n\", \"!\", and <space> keys\n            # with the respective macros to facilitate it.\n            register = self.qteMain.qteRegisterMacro\n            bind = self.qteMain.qteBindKeyWidget\n\n            # Unbind all keys from the input widget.\n            self.qteMain.qteUnbindAllFromWidgetObject(self.qteText)\n\n            macroName = register(self.ReplaceAll, replaceMacro=True)\n            bind('!', macroName, self.qteText)\n\n            macroName = register(self.ReplaceNext, replaceMacro=True)\n            bind('<space>', macroName, self.qteText)\n\n            macroName = register(self.SkipNext, replaceMacro=True)\n            bind('n', macroName, self.qteText)\n\n            macroName = register(self.Abort, replaceMacro=True)\n            bind('q', macroName, self.qteText)\n            bind('<enter>', macroName, self.qteText)\n\n            self.toReplaceWith = self.qteText.toPlainText()\n            self.qteTextPrefix.setText('mode 2')\n            self.qteText.setText('<space> to replace, <n> to skip, '\n                                 '<!> to replace all.')\n        else:\n            self.qteAbort(QtmacsMessage())\n            self.qteMain.qteKillMiniApplet()", "response": "This method is called by the next stage of the search - replace command."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef replaceAll(self):\n        while self.replaceSelected():\n            pass\n\n        self.qteWidget.SCISetStylingEx(0, 0, self.styleOrig)\n        self.qteMain.qteKillMiniApplet()", "response": "Replace all matches after the current cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compileMatchList(self):\n        # Get the new sub-string to search for.\n        self.matchList = []\n\n        # Return immediately if the input field is empty.\n        numChar = len(self.toReplace)\n        if numChar == 0:\n            return\n\n        # Compile a list of all sub-string spans.\n        stop = 0\n        text = self.qteWidget.text()\n        while True:\n            start = text.find(self.toReplace, stop)\n            if start == -1:\n                break\n            else:\n                stop = start + numChar\n                self.matchList.append((start, stop))", "response": "Compile the list of spans of every match."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef highlightAllMatches(self):\n        # Remove any previous highlighting.\n        self.qteWidget.SCISetStylingEx(0, 0, self.styleOrig)\n        SCI = self.qteWidget\n\n        # Compile a list of spans that contain the specified string.\n        self.compileMatchList()\n\n        # Return if the substring does not exist in the text.\n        if len(self.matchList) == 0:\n            return\n\n        # ------------------------------------------------------------\n        # Make a copy of the style bits of the document, overwrite\n        # those parts containing a substring, and then write them\n        # back all at once. This is much faster than calling the\n        # styling methods repeatedly.\n        # ------------------------------------------------------------\n\n        # Make a copy of the document style bits and determine the\n        # cursor position in the document.\n        style = bytearray(self.styleOrig)\n        pos = SCI.getCursorPosition()\n        cur = SCI.positionFromLineIndex(*pos)\n\n        # Style all matches.\n        self.selMatchIdx = 0\n        for start, stop in self.matchList:\n            if start < cur:\n                self.selMatchIdx += 1\n            style[start:stop] = bytes(b'\\x1e') * (stop - start)\n\n        if self.selMatchIdx >= len(self.matchList):\n            self.selMatchIdx = 0\n\n        # Style the first match after the current cursor position\n        # differently to indicate that it is the currently\n        # selected one.\n        start, stop = self.matchList[self.selMatchIdx]\n        style[start:stop] = bytes(b'\\x1f') * (stop - start)\n\n        # Place the cursor at the start of the currently selected match.\n        line, col = SCI.lineIndexFromPosition(start)\n        SCI.setCursorPosition(line, col)\n\n        # Apply the modified style array to the document.\n        self.qteWidget.SCISetStylingEx(0, 0, style)", "response": "Highlight all matches in the current document."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nabort the current message.", "response": "def qteAbort(self, msgObj):\n        \"\"\"\n        Restore the original cursor position because the user hit abort.\n        \"\"\"\n        self.qteWidget.setCursorPosition(*self.cursorPosOrig)\n        try:\n            self.qteMain.qtesigAbort.disconnect(self.qteAbort)\n        except TypeError:\n            pass\n        try:\n            self.qteText.textChanged.disconnect(self.qteTextChanged)\n        except TypeError:\n            pass\n        self.qteWidget.qteSetLexer(self.originalLexer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qteToBeKilled(self):\n        self.qteWidget.SCISetStylingEx(0, 0, self.styleOrig)\n        self.qteWidget.qteSetLexer(self.originalLexer)", "response": "Mark the current lexer as killed."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreplaces the currently selected string with the new one.", "response": "def replaceSelected(self):\n        \"\"\"\n        Replace the currently selected string with the new one.\n\n        The method return **False** if another match to the right\n        of the cursor exists, and **True** if not (ie. when the\n        end of the document was reached).\n        \"\"\"\n        SCI = self.qteWidget\n\n        # Restore the original styling.\n        self.qteWidget.SCISetStylingEx(0, 0, self.styleOrig)\n\n        # Select the region spanned by the string to replace.\n        start, stop = self.matchList[self.selMatchIdx]\n        line1, col1 = SCI.lineIndexFromPosition(start)\n        line2, col2 = SCI.lineIndexFromPosition(stop)\n        SCI.setSelection(line1, col1, line2, col2)\n\n        text = SCI.selectedText()\n        text = re.sub(self.toReplace, self.toReplaceWith, text)\n\n        # Replace that region with the new string and move the cursor\n        # to the end of that string.\n        SCI.replaceSelectedText(text)\n        line, col = SCI.lineIndexFromPosition(start + len(text))\n        SCI.setCursorPosition(line, col)\n\n        # Backup the new document style bits.\n        line, col = SCI.getNumLinesAndColumns()\n        text, style = self.qteWidget.SCIGetStyledText((0, 0, line, col))\n        self.styleOrig = style\n\n        # Determine if this was the last entry in the match list.\n        if len(self.matchList) == self.selMatchIdx + 1:\n            return False\n        else:\n            self.highlightAllMatches()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef filter(self, value, model=None, context=None):\n        value = str(value)\n        return bleach.clean(text=value, **self.bleach_params)", "response": "Filter the value and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun Kalibrate for a band and return a list of unique identifiers.", "response": "def scan_band(self, band, **kwargs):\n        \"\"\"Run Kalibrate for a band.\n\n        Supported keyword arguments:\n        gain    -- Gain in dB\n        device  -- Index of device to be used\n        error   -- Initial frequency error in ppm\n\n        \"\"\"\n\n        kal_run_line = fn.build_kal_scan_band_string(self.kal_bin,\n                                                     band, kwargs)\n        raw_output = subprocess.check_output(kal_run_line.split(' '),\n                                             stderr=subprocess.STDOUT)\n        kal_normalized = fn.parse_kal_scan(raw_output)\n        return kal_normalized"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter(self, value, model=None, context=None):\n        value = str(value)\n        if self.mode == 'left':\n            return value.lstrip(self.chars)\n        elif self.mode == 'right':\n            return value.rstrip(self.chars)\n        else:\n            return value.strip(self.chars)", "response": "Filter the value of the key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping your iterables with Bar.", "response": "def bar(it, label='', width=32, hide=None, empty_char=' ', filled_char=None, expected_size=None, every=1):\n    \"\"\"\n    Progress iterator. Wrap your iterables with it.\n    @type it: iterator\n    @type label: str\n    @type width: int\n    @type hide: str, None\n    @type empty_char: float\n    @type filled_char: float\n    @type expected_size: int, None\n    @type every: int\n    @return: None\n    \"\"\"\n    if filled_char is None:\n        filled_char_tmp = b'\\xe2\\x96\\x88'.decode()\n        filled_char = \"\\033[0;37m\" + filled_char_tmp + \"\\033[0m\"\n\n    count = len(it) if expected_size is None else expected_size\n    with Bar(label=label, width=width, hide=hide, expected_size=count, every=every, empty_char=empty_char, filled_char=filled_char) as mybar:\n        for i, item in enumerate(it):\n            if isinstance(item, tuple) and len(item) == 2:\n                mybar.label = item[0]\n                item = item[1]\n            yield item\n            mybar.show(i)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a full full", "response": "def coolname():\n    \"\"\"\n    coolname\n    \"\"\"\n\n    happy = False\n    while not happy:\n        names = \"\"\"\n        Aldous\n        Ara\n        Ash\n        Asia\n        Azarias\n        Balthazar\n        Barnaby\n        Bastien\n        Beckett\n        Berlin\n        Birch\n        Booker\n        Bridge\n        Bronwyn\n        Cabe\n        Cabot\n        Calixto\n        Callaghan\n        Calloway\n        Cameron\n        Carlson\n        Christo\n        Chuck\n        Clovis\n        Columbus\n        Connelly\n        Cormac\n        Costello\n        Cruz\n        Cyprian\n        Dashiell\n        Delaney\n        Delilah\n        Dermot\n        Detroit\n        Donovan\n        Drexel\n        Driver\n        Elvis\n        Fergus\n        Finbar\n        Finch\n        Finn\n        Fitzpatrick\n        Gardner\n        Garth\n        Georgia\n        Griffith\n        Grover\n        Gus\n        Hanan\n        Harrington\n        Hawthorne\n        Heron\n        Horatio\n        Huckleberry\n        Hudson\n        Humphrey\n        Hunt\n        Jackson\n        Jude\n        Jupiter\n        Keene\n        Keir\n        Kelso\n        Kermit\n        Kipling\n        Kristof\n        Lambert\n        Lancelot\n        Lanier\n        Lark\n        Laurent\n        Leib\n        Llewellyn\n        Loch\n        Lola\n        Mackson\n        Maisie\n        Matteo\n        Mcgregor\n        Mcguire\n        Mercury\n        Miles\n        Morocco\n        Moss\n        Nicasio\n        Nico\n        Oak\n        Octavion\n        Ogden\n        Oracio\n        Osborn\n        Osias\n        Osric\n        Pacer\n        Paloma\n        Park\n        Phelan\n        Pilot\n        Primo\n        Quint\n        Racer\n        Rafferty\n        Ralston\n        Raoul\n        Redmond\n        Reynolds\n        Romulus\n        Rowan\n        Saber\n        Sadler\n        Sam\n        Sasha\n        Satchel\n        Sender\n        Severus\n        Siena\n        Spence\n        Thurman\n        Topher\n        Violet\n        Wagner\n        Waldo\n        Wally\n        Webster\n        Willa\n        Witt\n        Yale\n        Zane\n        Zed\n        Zoran\n        \"\"\"\n        lastnames = \"\"\"\n        Abernathy\n        Abner\n        Aldaine\n        Amor\n        Amherst\n        Armstrong\n        Angeles\n        Annesley\n        Archer\n        Ash\n        Bancroft\n        Bandini\n        Banner\n        Barringer\n        Blackwood\n        Blood\n        Bloom\n        Boulder\n        Cadwell\n        Cage\n        Carmichael\n        Chase\n        Cobain\n        Cohen\n        Colburn\n        Colt\n        Crabtree\n        Crassus\n        Creed\n        Crew\n        Cullen\n        Dalton\n        Danger\n        Davenport\n        Dillinger\n        Duke\n        East\n        Fall\n        Fawn\n        Freeze\n        Gamble\n        Granger\n        Gryffon\n        Gunn\n        Halifax\n        Harder\n        Havoc\n        Hilton\n        Holly\n        Hope\n        Hunter\n        Ice\n        Iris\n        Iver\n        Ivy\n        Jarvis\n        Joy\n        Kelly\n        Kennicot\n        King\n        Knight\n        Lily\n        Love\n        Mayhem\n        Merry\n        Noble\n        North\n        Paris\n        Pendleton\n        Pevensie\n        Phoenix\n        Poe\n        Potter\n        Power\n        Quake\n        Radcliffe\n        Raven\n        River\n        Rose\n        Savage\n        Slade\n        Slayer\n        Star\n        Stratton\n        Stryker\n        Styles\n        Tatum\n        Tremaine\n        Troublefield\n        Underwood\n        Verbeck\n        Violet\n        Vow\n        Waldgrave\n        Walker\n        Winter\n        Wolf\n        York\n        Young\n        Zedler\n        Zimmerman\n        \"\"\"\n\n        names = [x.strip() for x in names.split(\"\\n\") if x.strip()]\n        lastnames = [x.strip() for x in lastnames.split(\"\\n\") if x.strip()]\n        randomnumbername = random.randint(0, len(names) - 1)\n        randomnumberlastname = random.randint(0, len(lastnames) - 1)\n        coolname = ' '.join([names[randomnumbername], lastnames[randomnumberlastname]])\n        username = coolname.replace(' ', '').lower()\n        print(\"----------\")\n        print(coolname)\n        print(username)\n        print\n        happy = not query_yes_no('again?')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stack_as_string():\n    if sys.version_info.major == 3:\n        stack = io.StringIO()\n    else:\n        stack = io.BytesIO()\n\n    traceback.print_stack(file=stack)\n    stack.seek(0)\n    stack = stack.read()\n    return stack", "response": "Returns a string containing the current stack trace."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef done(self):\n        self.elapsed = time.time() - self.start\n        elapsed_disp = self.format_time(self.elapsed)\n        stream = sys.stderr\n        bar_template = '%s|%s%s| \\033[32m%s/%s - %s\\033[0m\\r'\n        self.last_progress = \"%.1f\" % float(self.last_progress)\n        self.expected_size = \"%.1f\" % float(self.expected_size)\n\n        if not self.hide:\n            # Print completed bar with elapsed time\n            stream.write('\\r')\n            stream.write('                                                                                        \\r')\n\n            if len(remove_color(self.label.strip())) == 0:\n                bar_template = '%s|%s%s| \\033[34m%s/%s\\033[0m\\r'\n                stream.write(bar_template % (\n                    elapsed_disp, self.filled_char * self.width,\n                    self.empty_char * 0, self.last_progress,\n                    self.expected_size))\n            else:\n                stream.write(bar_template % (\n                    self.label, self.filled_char * self.width,\n                    self.empty_char * 0, self.last_progress,\n                    self.expected_size, elapsed_disp))\n\n            stream.write('\\n')\n            stream.flush()", "response": "Print a complete logo of the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef virtual_host(self):\n\t\tif self.headers() is not None:\n\t\t\thost_value = self.headers()['Host']\n\t\t\treturn host_value[0].lower() if host_value is not None else None", "response": "Return request virtual host header value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vars(self):\n\t\tif self.method() != 'GET':\n\t\t\traise RuntimeError('Unable to return get vars for non-get method')\n\t\tre_search = WWebRequestProto.get_vars_re.search(self.path())\n\t\tif re_search is not None:\n\t\t\treturn urllib.parse.parse_qs(re_search.group(1), keep_blank_values=1)", "response": "Parse request path and return GET - vars\n\t : return None or dictionary of names and tuples of values\n\t\t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing request payload and return POST - vars", "response": "def post_vars(self):\n\t\t\"\"\" Parse request payload and return POST-vars\n\n\t\t:return: None or dictionary of names and tuples of values\n\t\t\"\"\"\n\t\tif self.method() != 'POST':\n\t\t\traise RuntimeError('Unable to return post vars for non-get method')\n\n\t\tcontent_type = self.content_type()\n\t\tif content_type is None or content_type.lower() != 'application/x-www-form-urlencoded':\n\t\t\traise RuntimeError('Unable to return post vars with invalid content-type request')\n\n\t\trequest_data = self.request_data()\n\t\trequest_data = request_data.decode() if request_data is not None else ''\n\t\tre_search = WWebRequestProto.post_vars_re.search(request_data)\n\t\tif re_search is not None:\n\t\t\treturn urllib.parse.parse_qs(re_search.group(1), keep_blank_values=1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef join_path(self, *path):\n\t\tpath = self.directory_sep().join(path)\n\t\treturn self.normalize_path(path)", "response": "Join a list of path items into a single path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef session_path(self, path=None):\n\t\tif path is not None:\n\t\t\tif path.startswith(self.directory_sep()) is True:\n\t\t\t\tself.__session_path = self.normalize_path(path)\n\t\t\telse:\n\t\t\t\tself.__session_path = self.join_path(self.__session_path, path)\n\t\treturn self.__session_path", "response": "Set and or get current session path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef full_path(self):\n\t\treturn self.normalize_path(self.directory_sep().join((self.start_path(), self.session_path())))", "response": "Return a full path to a current session directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun the model method", "response": "def run(self, **kwargs):\n        \"\"\"\n        Run the model\n\n        Parameters\n        ----------\n        ``**kwargs``\n            Any other parameter for the\n            :meth:`model_organization.ModelOrganizer.app_main` method\n        \"\"\"\n        from calculate import compute\n        self.app_main(**kwargs)\n\n        # get the default output name\n        output = osp.join(self.exp_config['expdir'], 'output.dat')\n\n        # save the paths in the configuration\n        self.exp_config['output'] = output\n\n        # run the model\n        data = np.loadtxt(self.exp_config['infile'])\n        out = compute(data)\n        # save the output\n        self.logger.info('Saving output data to %s', osp.relpath(output))\n        np.savetxt(output, out)\n\n        # store some additional information in the configuration of the\n        # experiment\n        self.exp_config['mean'] = mean = float(out.mean())\n        self.exp_config['std'] = std = float(out.std())\n        self.logger.debug('Mean: %s, Standard deviation: %s', mean, std)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef postproc(self, close=True, **kwargs):\n        import matplotlib.pyplot as plt\n        import seaborn as sns  # for nice plot styles\n        self.app_main(**kwargs)\n\n        # ---- load the data\n        indata = np.loadtxt(self.exp_config['infile'])\n        outdata = np.loadtxt(self.exp_config['output'])\n        x_data = np.linspace(-np.pi, np.pi)\n\n        # ---- make the plot\n        fig = plt.figure()\n        # plot input data\n        plt.plot(x_data, indata, label='input')\n        # plot output data\n        plt.plot(x_data, outdata, label='squared')\n        # draw a legend\n        plt.legend()\n        # use the description of the experiment as title\n        plt.title(self.exp_config.get('description'))\n\n        # ---- save the plot\n        self.exp_config['plot'] = ofile = osp.join(self.exp_config['expdir'],\n                                                   'plot.png')\n        self.logger.info('Saving plot to %s', osp.relpath(ofile))\n        fig.savefig(ofile)\n\n        if close:\n            plt.close(fig)", "response": "Postprocess and visualize the data for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npushes the command object to the stack.", "response": "def _push(self, undoObj: QtmacsUndoCommand):\n        \"\"\"\n        The actual method that adds the command object onto the stack.\n\n        This method also toggles the ``nextIsRedo`` flag in the\n        command object and, depending on its value, executes either\n        the ``commit`` or ``reverseCommit`` method of the object. This\n        distinction is invisible to the user but if the method is\n        passed a copy of an older ``undoObj`` already on the stack\n        (typically the case when called from ``undo``) then it will\n        call the inverse command (ie a ``commit`` when the previous\n        call was a ``reverseCommit`` and vice versa). In this manner,\n        the undo history will contain just another command object\n        which happens to undo a previous one, irrespective of whether\n        the previous one was already the undoing of an even earlier\n        one.\n        \"\"\"\n        self._qteStack.append(undoObj)\n        if undoObj.nextIsRedo:\n            undoObj.commit()\n        else:\n            undoObj.reverseCommit()\n        undoObj.nextIsRedo = not undoObj.nextIsRedo"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef push(self, undoObj):\n        # Check type of input arguments.\n        if not isinstance(undoObj, QtmacsUndoCommand):\n            raise QtmacsArgumentError('undoObj', 'QtmacsUndoCommand',\n                                      inspect.stack()[0][3])\n\n        # Flag that the last action was not an undo action and push\n        # the command to the stack.\n        self._wasUndo = False\n        self._push(undoObj)", "response": "Push a new command object to the stack and run its commit method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nundoing the last command in the stack.", "response": "def undo(self):\n        \"\"\"\n        Undo the last command by adding its inverse action to the stack.\n\n        This method automatically takes care of applying the correct\n        inverse action when it is called consecutively (ie. without a\n        calling ``push`` in between).\n\n        The ``qtesigSavedState`` signal is triggered whenever enough undo\n        operations have been performed to put the document back into the\n        last saved state.\n\n        ..warning: The ``qtesigSaveState`` is triggered whenever the\n          logic of the undo operations **should** have led back to\n          that state, but since the ``UndoStack`` only stacks and\n          ``QtmacsUndoCommand`` objects it may well be the document is\n          **not** in the last saved state, eg. because not all\n          modifications were protected by undo objects, or because the\n          ``QtmacsUndoCommand`` objects have a bug. It is therefore\n          advisable to check in the calling class if the content is\n          indeed identical by comparing it with a temporarily stored\n          copy.\n\n        |Args|\n\n        * **None**\n\n        |Signals|\n\n        * ``qtesigSavedState``: the document is the last saved state.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n        # If it is the first call to this method after a ``push`` then\n        # reset ``qteIndex`` to the last element, otherwise just\n        # decrease it.\n        if not self._wasUndo:\n            self._qteIndex = len(self._qteStack)\n        else:\n            self._qteIndex -= 1\n\n        # Flag that the last action was an `undo` operation.\n        self._wasUndo = True\n        if self._qteIndex <= 0:\n            return\n\n        # Make a copy of the command and push it to the stack.\n        undoObj = self._qteStack[self._qteIndex - 1]\n        undoObj = QtmacsUndoCommand(undoObj)\n        self._push(undoObj)\n\n        # If the just pushed undo object restored the last saved state\n        # then trigger the ``qtesigSavedState`` signal and set the\n        # _qteLastSaveUndoIndex variable again. This is necessary\n        # because an undo command will not *remove* any elements from\n        # the undo stack but *add* the inverse operation to the\n        # stack. Therefore, when enough undo operations have been\n        # performed to reach the last saved state that means that the\n        # last addition to the stack is now implicitly the new last\n        # save point.\n        if (self._qteIndex - 1) == self._qteLastSavedUndoIndex:\n            self.qtesigSavedState.emit(QtmacsMessage())\n            self.saveState()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef placeCursor(self, pos):\n        if pos > len(self.qteWidget.toPlainText()):\n            pos = len(self.qteWidget.toPlainText())\n\n        tc = self.qteWidget.textCursor()\n        tc.setPosition(pos)\n        self.qteWidget.setTextCursor(tc)", "response": "Place the cursor at the given position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef commit(self):\n        if self.after is None:\n            # If this is the first 'commit' call then do not make\n            # any changes but store the current document state.\n            self.after = self.qteWidget.toHtml()\n        else:\n            # Put the document into the edited state.\n            pos = self.qteWidget.textCursor().position()\n            self.qteWidget.setHtml(self.after)\n            self.placeCursor(pos)", "response": "Commits the current document into the new state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreverse the document to the original state.", "response": "def reverseCommit(self):\n        \"\"\"\n        Reverse the document to the original state.\n        \"\"\"\n        print(self.after == self.before)\n        pos = self.qteWidget.textCursor().position()\n        self.qteWidget.setHtml(self.before)\n        self.placeCursor(pos)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncommitting the current state of the current entry.", "response": "def commit(self):\n        \"\"\"\n        Insert the text at the current cursor position.\n        \"\"\"\n\n        tc = self.qteWidget.textCursor()\n\n        # If this is the first ever call to this undo/redo element then\n        # backup the current cursor position and the selected text (may be\n        # none). This information will be required for the redo operation\n        # to position the cursor (and selected text) where it was at the\n        # very first call.\n        if self.cursorPos0 is None:\n            self.cursorPos0 = tc.position()\n            self.selText = tc.selection().toHtml()\n            self.selStart = tc.selectionStart()\n            self.selEnd = tc.selectionEnd()\n        else:\n            tc.setPosition(self.cursorPos0, QtGui.QTextCursor.MoveAnchor)\n\n        # Remove the originally selected text (may be none).\n        tc.setPosition(self.selStart, QtGui.QTextCursor.MoveAnchor)\n        tc.setPosition(self.selEnd, QtGui.QTextCursor.KeepAnchor)\n        tc.removeSelectedText()\n\n        # Move to the start of the (just deleted) text block and insert\n        # the characters there.\n        if len(self.selText) > 0:\n            pos = self.selStart\n        else:\n            pos = tc.position()\n        tc.setPosition(pos)\n\n        # Backup the cursor position before the insertion operation,\n        # insert the new character(s), move the cursor forward, and\n        # backup the new cursor position as well.\n        self.cursorPos1 = tc.position()\n        tc.insertText(self.text)\n        self.cursorPos2 = tc.position()\n\n        self.qteWidget.setTextCursor(tc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reverseCommit(self):\n\n        tc = self.qteWidget.textCursor()\n\n        # Select the area from before the insertion to after the insertion,\n        # and remove it.\n        tc.setPosition(self.cursorPos1, QtGui.QTextCursor.MoveAnchor)\n        tc.setPosition(self.cursorPos2, QtGui.QTextCursor.KeepAnchor)\n        tc.removeSelectedText()\n\n        # Add the previously selected text (if there was any). Note that the\n        # text will not be 'selected' (ie. highlighted) this time.\n        if len(self.selText) > 0:\n            tc.setPosition(self.selStart)\n            tc.insertHtml(self.selText)", "response": "Reverse the changes made to the current cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef commit(self):\n\n        # Backup and remove the currently selected text (may be none).\n        tc = self.qteWidget.textCursor()\n        self.selText = tc.selection().toHtml()\n        self.selStart = tc.selectionStart()\n        self.selEnd = tc.selectionEnd()\n        tc.removeSelectedText()\n\n        # Move to the start of the (just deleted) text block and insert\n        # the characters there.\n        tc.setPosition(self.selStart)\n\n        # If the MIME data contained an image then create a new HTML\n        # resource for it and insert it with the HTML syntax for adding\n        # an image. On the other hand, if the resource was simply a string,\n        # then just add it.\n        if self.isImage:\n            imgName = \"pastedImage_{}\".format(str(self.pasteCnt))\n            document = self.qteWidget.document()\n            document.addResource(QtGui.QTextDocument.ImageResource,\n                                 QtCore.QUrl(imgName), self.data)\n            self.qteWidget.setDocument(document)\n            tc.insertHtml('<img src={}>'.format(imgName))\n        else:\n            tc.insertText(self.data)\n\n        # Update the text cursor in the document.\n        self.qteWidget.setTextCursor(tc)", "response": "Commits the changes in the current text block and inserts the text at the current cursor position."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete the inserted characters and insert the inserted text.", "response": "def reverseCommit(self):\n        \"\"\"\n        Remove the inserted character(s).\n        \"\"\"\n\n        # Move the cursor to the right of the text to delete.\n        tc = self.qteWidget.textCursor()\n\n        # Delete as many characters as necessary. For an image that would\n        # be exactly 1 even though the HTML code to embed that image is usually\n        # longer. For text, it would be as many characters as the pasted text\n        # was long.\n        if self.isImage:\n            dataLen = 1\n        else:\n            dataLen = len(self.data)\n\n        tc.setPosition(self.selStart + dataLen, QtGui.QTextCursor.MoveAnchor)\n        for ii in range(dataLen):\n            tc.deletePreviousChar()\n\n        # Add the previously selected text (this may be none).\n        tc.insertHtml(self.selText)\n        self.qteWidget.setTextCursor(tc)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninserting a new entry into the list of undone items.", "response": "def insertFromMimeData(self, data):\n        \"\"\"\n        Paste the MIME data at the current cursor position.\n\n        This method also adds another undo-object to the undo-stack.\n        \"\"\"\n        undoObj = UndoPaste(self, data, self.pasteCnt)\n        self.pasteCnt += 1\n        self.qteUndoStack.push(undoObj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef keyPressEvent(self, keyEvent):\n        undoObj = UndoSelfInsert(self, keyEvent.text())\n        self.qteUndoStack.push(undoObj)", "response": "Insert the character at the current cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_schema_version_from_xml(xml):\n    if isinstance(xml, six.string_types):\n        xml = StringIO(xml)\n    try:\n        tree = ElementTree.parse(xml)\n    except ParseError:\n        # Not an XML file\n        return None\n    root = tree.getroot()\n    return root.attrib.get('schemaVersion', None)", "response": "Get schemaVersion attribute from OpenMalaria scenario file\n    xml - open file or content of xml document to be processed\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef filter(self, value, model=None, context=None):\n        value = str(value)\n        return value.lower()", "response": "Filter the value of the key - value pair and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive a service name and a dict of data returns the formatted account for that service.", "response": "def format_account(service_name, data):\n    \"\"\"\n    Given profile data and the name of a\n    social media service, format it for\n    the zone file.\n\n    @serviceName: name of the service\n    @data: legacy profile verification\n\n    Returns the formatted account on success,\n    as a dict.\n    \"\"\"\n\n    if \"username\" not in data:\n        raise KeyError(\"Account is missing a username\")\n\n    account = {\n        \"@type\": \"Account\",\n        \"service\": service_name,\n        \"identifier\": data[\"username\"],\n        \"proofType\": \"http\"\n    }\n\n    if (data.has_key(service_name)\n        and data[service_name].has_key(\"proof\")\n        and data[service_name][\"proof\"].has_key(\"url\")):\n        account[\"proofUrl\"] = data[service_name][\"proof\"][\"url\"]\n\n    return account"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a full profile into a list of persons.", "response": "def get_person_from_legacy_format(profile_record):\n    \"\"\"\n    Given a whole profile, convert it into \n    zone-file format.  In the full profile JSON,\n    this method operates on the 'data_record' object.\n\n    @profile is a dict that contains the legacy profile data\n\n    Return a dict with the zone-file formatting.\n    \"\"\"\n\n    if not is_profile_in_legacy_format(profile_record):\n        raise ValueError(\"Not a legacy profile\")\n\n    profile = profile_record\n\n    try:\n        profile = json.loads(json.dumps(profile))\n    except ValueError:\n        pass\n\n    images = []\n    accounts = []\n    profile_data = {\n        \"@type\": \"Person\"\n    }\n\n    if profile.has_key(\"name\") and type(profile[\"name\"]) == dict \\\n            and profile[\"name\"].has_key(\"formatted\"):\n        profile_data[\"name\"] = profile[\"name\"][\"formatted\"]\n\n    if profile.has_key(\"bio\"):\n        profile_data[\"description\"] = profile[\"bio\"]\n\n    if profile.has_key(\"location\") and type(profile[\"location\"]) == dict \\\n            and profile[\"location\"].has_key(\"formatted\"):\n        profile_data[\"address\"] = {\n            \"@type\": \"PostalAddress\",\n            \"addressLocality\": profile[\"location\"][\"formatted\"]\n        }\n\n    if profile.has_key(\"avatar\") and type(profile[\"avatar\"]) == dict and \\\n            profile[\"avatar\"].has_key(\"url\"):\n        images.append({\n            \"@type\": \"ImageObject\",\n            \"name\": \"avatar\",\n            \"contentUrl\": profile[\"avatar\"][\"url\"]\n        })\n\n    if profile.has_key(\"cover\") and type(profile[\"cover\"]) == dict and \\\n            profile[\"cover\"].has_key(\"url\"):\n        images.append({\n            \"@type\": \"ImageObject\",\n            \"name\": \"cover\",\n            \"contentUrl\": profile[\"cover\"][\"url\"]\n        })\n\n    if len(images) > 0:\n        profile_data[\"image\"] = images\n\n    if profile.has_key(\"website\") and type(profile[\"website\"]) in [str, unicode]:\n        profile_data[\"website\"] = [{\n            \"@type\": \"WebSite\",\n            \"url\": profile[\"website\"]\n        }]\n\n    for service_name in [\"twitter\", \"facebook\", \"github\"]:\n        if profile.has_key(service_name):\n            accounts.append(\n                format_account(service_name, profile[service_name])\n            )\n\n    if profile.has_key(\"bitcoin\") and type(profile[\"bitcoin\"]) == dict and \\\n            profile[\"bitcoin\"].has_key(\"address\"):\n        accounts.append({\n            \"@type\": \"Account\",\n            \"role\": \"payment\",\n            \"service\": \"bitcoin\",\n            \"identifier\": profile[\"bitcoin\"][\"address\"]\n        })\n\n    if profile.has_key(\"auth\"):\n        if len(profile[\"auth\"]) > 0 and type(profile[\"auth\"]) == dict:\n            if profile[\"auth\"][0].has_key(\"publicKeychain\"):\n                accounts.append({\n                    \"@type\": \"Account\",\n                    \"role\": \"key\",\n                    \"service\": \"bip32\",\n                    \"identifier\": profile[\"auth\"][0][\"publicKeychain\"]\n                })\n\n    if profile.has_key(\"pgp\") and type(profile[\"pgp\"]) == dict \\\n            and profile[\"pgp\"].has_key(\"url\") \\\n            and profile[\"pgp\"].has_key(\"fingerprint\"):\n        accounts.append({\n            \"@type\": \"Account\",\n            \"role\": \"key\",\n            \"service\": \"pgp\",\n            \"identifier\": profile[\"pgp\"][\"fingerprint\"],\n            \"contentUrl\": profile[\"pgp\"][\"url\"]\n        })\n\n    profile_data[\"account\"] = accounts \n\n    return profile_data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resize(self, size):\n\t\tif size is not None:\n\t\t\tself.__value = int(WBinArray(self.__value)[:size])\n\t\tself.__size = size", "response": "Resize current array. If size is None, then array became nonfixed-length array. If new size is\n\t\tless then current size and value, then value will be truncated (lesser significant bits will be\n\t\ttruncated).\n\n\t\t:param size:\n\t\t:return:"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsplits array into smaller parts. Each small array is fixed - length WBinArray.", "response": "def split(self, bits_count):\n\t\t\"\"\" Split array into smaller parts. Each small array is fixed-length WBinArray (length of that array is\n\t\tbits_count).\n\n\t\t:param bits_count: array length\n\t\t:return: list of WBinArray\n\t\t\"\"\"\n\t\tresult = []\n\t\tarray = WBinArray(self.__value, self.__size)\n\n\t\tif (len(array) % bits_count) > 0:\n\t\t\tarray.resize(len(array) + (bits_count - (len(array) % bits_count)))\n\n\t\twhile len(array):\n\t\t\tresult.append(WBinArray(array[:bits_count], bits_count))\n\t\t\tarray = array[bits_count:]\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef concat(self, array):\n\t\tif isinstance(array, WBinArray) is False:\n\t\t\traise TypeError('Invalid array type')\n\t\tvalue = ((int(self) << len(array)) | int(array))\n\t\treturn WBinArray(value, len(self) + len(array))", "response": "Return new fixed - length array that is made by creating new array with length of sum of two arrays\n\t"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rconcat(self, array):\n\t\tif isinstance(array, WBinArray) is False:\n\t\t\traise TypeError('Invalid array type')\n\t\treturn array.concat(self)", "response": "'Reverse' concatenation. Works the same as :meth:`.WBinArray.concat`, but in newly created array\n\t\tthe most significant bit of the given array will have an index greater then an index of the least\n\t\tsignificant bit of this array\n\n\t\t:param array: array to concatenate with\n\t\t:return: WBinArray"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconcatenate this array with the given arrays.", "response": "def extend(self, *array_list):\n\t\t\"\"\" Concatenate this array with the given arrays. This method doesn't modify current array. Instead,\n\t\tit creates new one, that have all of arrays. (see :meth:`.WBinArray.concat` method)\n\n\t\t:param array_list: list of WBinArray\n\t\t:return: newly created WBinArray\n\t\t\"\"\"\n\t\tresult = WBinArray(int(self), len(self))\n\t\tfor array in array_list:\n\t\t\tresult = result.concat(array)\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmirroring current array value in reverse.", "response": "def swipe(self):\n\t\t\"\"\" Mirror current array value in reverse. Bits that had greater index will have lesser index, and\n\t\tvice-versa. This method doesn't change this array. It creates a new one and return it as a result.\n\n\t\t:return: WBinArray\n\t\t\"\"\"\n\t\tresult = WBinArray(0, len(self))\n\t\tfor i in range(len(self)):\n\t\t\tresult[len(self) - i - 1] = self[i]\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconcatenate all of the given arrays.", "response": "def join(*args):\n\t\t\"\"\" Concatenate all of the given arrays. (see :meth:`.WBinArray.concat` method)\n\n\t\t:param args: list of WBinArray\n\t\t:return: WBinArray\n\t\t\"\"\"\n\t\tif len(args) == 0:\n\t\t\treturn\n\n\t\tresult = WBinArray(int(args[0]), len(args[0]))\n\t\tif len(args) == 1:\n\t\t\treturn result\n\t\telse:\n\t\t\tresult = result.extend(*(args[1:]))\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_all_models(self, module_instance, exclude_name_list=[]):\n        for class_instance in class_enumerator(module_instance, exclude_name_list):\n            if is_inherit_from_model(class_instance):\n                self.register(class_instance)", "response": "Register all the classes in the specified module instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef etcd(url=DEFAULT_URL, mock=False, **kwargs):\n    if mock:\n        from etc.adapters.mock import MockAdapter\n        adapter_class = MockAdapter\n    else:\n        from etc.adapters.etcd import EtcdAdapter\n        adapter_class = EtcdAdapter\n    return Client(adapter_class(url, **kwargs))", "response": "Creates an etcd client."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef restrict_args(func, *args, **kwargs):\r\n    '''\r\n    Restricts the possible arguements to a method to match the func argument.\r\n\r\n    restrict_args(lambda a: a, 1, 2)\r\n    # => 1\r\n    '''\r\n    callargs = getargspec(func)\r\n    if not callargs.varargs:\r\n        args = args[0:len(callargs.args)]\r\n    return func(*args, **kwargs)", "response": "Restricts the possible arguements to a method to match the func argument."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall the given callable repeatedly until the number of retries times is reached.", "response": "def repeat_call(func, retries, *args, **kwargs):\r\n    '''\r\n    Tries a total of 'retries' times to execute callable before failing.\r\n    '''\r\n    retries = max(0, int(retries))\r\n    try_num = 0\r\n    while True:\r\n        if try_num == retries:\r\n            return func(*args, **kwargs)\r\n        else:\r\n            try:\r\n                return func(*args, **kwargs)\r\n            except Exception as e:\r\n                if isinstance(e, KeyboardInterrupt):\r\n                    raise e\r\n                try_num += 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef type_check(func_handle):\n    def checkType(var_name, var_val, annot):\n        # Retrieve the annotation for this variable and determine\n        # if the type of that variable matches with the annotation.\n        # This annotation is stored in the dictionary ``annot``\n        # but contains only variables for such an annotation exists,\n        # hence the if/else branch.\n        if var_name in annot:\n            # Fetch the type-annotation of the variable.\n            var_anno = annot[var_name]\n\n            # Skip the type check if the variable is none, otherwise\n            # check if it is a derived class. The only exception from\n            # the latter rule are binary values, because in Python\n            #\n            # >> isinstance(False, int)\n            # True\n            #\n            # and warrants a special check.\n            if var_val is None:\n                type_ok = True\n            elif (type(var_val) is bool):\n                type_ok = (type(var_val) in var_anno)\n            else:\n                type_ok = True in [isinstance(var_val, _) for _ in var_anno]\n        else:\n            # Variable without annotation are compatible by assumption.\n            var_anno = 'Unspecified'\n            type_ok = True\n\n        # If the check failed then raise a QtmacsArgumentError.\n        if not type_ok:\n            args = (var_name, func_handle.__name__, var_anno, type(var_val))\n            raise QtmacsArgumentError(*args)\n\n    @functools.wraps(func_handle)\n    def wrapper(*args, **kwds):\n        # Retrieve information about all arguments passed to the function,\n        # as well as their annotations in the function signature.\n        argspec = inspect.getfullargspec(func_handle)\n\n        # Convert all variable annotations that were not specified as a\n        # tuple or list into one, eg. str --> will become (str,)\n        annot = {}\n        for key, val in argspec.annotations.items():\n            if isinstance(val, tuple) or isinstance(val, list):\n                annot[key] = val\n            else:\n                annot[key] = val,       # Note the trailing colon!\n\n        # Prefix the argspec.defaults tuple with **None** elements to make\n        # its length equal to the number of variables (for sanity in the\n        # code below). Since **None** types are always ignored by this\n        # decorator this change is neutral.\n        if argspec.defaults is None:\n            defaults = tuple([None] * len(argspec.args))\n        else:\n            num_none = len(argspec.args) - len(argspec.defaults)\n            defaults = tuple([None] * num_none) + argspec.defaults\n\n        # Shorthand for the number of unnamed arguments.\n        ofs = len(args)\n\n        # Process the unnamed arguments. These are always the first ``ofs``\n        # elements in argspec.args.\n        for idx, var_name in enumerate(argspec.args[:ofs]):\n            # Look up the value in the ``args`` variable.\n            var_val = args[idx]\n            checkType(var_name, var_val, annot)\n\n        # Process the named- and default arguments.\n        for idx, var_name in enumerate(argspec.args[ofs:]):\n            # Extract the argument value. If it was passed to the\n            # function as a named (ie. keyword) argument then extract\n            # it from ``kwds``, otherwise look it up in the tuple with\n            # the default values.\n            if var_name in kwds:\n                var_val = kwds[var_name]\n            else:\n                var_val = defaults[idx + ofs]\n            checkType(var_name, var_val, annot)\n        return func_handle(*args, **kwds)\n    return wrapper", "response": "Decorator to check that the type of the arguments passed in are of the correct type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self):\n\t\ttimeout = self.timeout()\n\t\tif timeout is not None and timeout > 0:\n\t\t\tself.__loop.add_timeout(timedelta(0, timeout), self.stop)\n\t\tself.handler().setup_handler(self.loop())\n\t\tself.loop().start()\n\t\tself.handler().loop_stopped()", "response": "Set up handler and start loop\n\tself."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loop_stopped(self):\n\t\ttransport = self.transport()\n\t\tif self.server_mode() is True:\n\t\t\ttransport.close_server_socket(self.config())\n\t\telse:\n\t\t\ttransport.close_client_socket(self.config())", "response": "Terminate socket connection because of stopping loop"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef discard_queue_messages(self):\n\t\tzmq_stream_queue = self.handler().stream()._send_queue\n\t\twhile not zmq_stream_queue.empty():\n\t\t\ttry:\n\t\t\t\tzmq_stream_queue.get(False)\n\t\t\texcept queue.Empty:\n\t\t\t\tcontinue\n\t\t\tzmq_stream_queue.task_done()", "response": "This method discards undelivered messages from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteRun(self):\n        # Ignore the request if the widget has no keyPressEvent method.\n        if not hasattr(self.qteWidget, 'keyPressEvent'):\n            return\n\n        # Extract the last key and send it to the widget.\n        keyEvent = qte_global.last_key_sequence.toQKeyEventList()[-1]\n        try:\n            self.qteWidget.keyPressEvent(keyEvent)\n        except RuntimeError:\n            pass", "response": "Return the current keyboard sequence and store it in the internal cache."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef eventFilter(self, targetObj, event_qt):\n        # Return immediately if Qtmacs is not interested in it.\n        if event_qt.type() not in self.qteEventList:\n            return False\n\n        # Determine if the widget belongs to the Qtmacs hierarchy and\n        # return immediately if not.\n        if not qteIsQtmacsWidget(targetObj):\n            return False\n\n        # If the event is a mouse click then update the Qtmacs internal\n        # focus state and tell the Qt library that the event was NOT\n        # handled. This ensures the click is propagated to the widget.\n        if event_qt.type() == QtCore.QEvent.MouseButtonPress:\n            self.qteMain._qteMouseClicked(targetObj)\n            return False\n\n        # Make a copy of the QKeyEvent because Qt will delete the\n        # underlying object as soon as the event is handled. However, some\n        # macros might retain a reference which will then become invalid\n        # and result in a difficult to trace bug. Therefore, supply them\n        # with an explicit copy only.\n        event = QtGui.QKeyEvent(event_qt.type(), event_qt.key(),\n                                event_qt.modifiers(), event_qt.text(),\n                                event_qt.isAutoRepeat(), event_qt.count())\n\n        # Abort the input if the user presses <ctrl>-g and declare the\n        # keyboard event handled.\n        mod = event.modifiers()\n        key = event.key()\n        if (mod == QtCore.Qt.ControlModifier) and (key == QtCore.Qt.Key_G):\n            # Furthermore, clear the key sequence and ensure macro execution\n            # is turned on again.\n            self._keysequence.reset()\n            self._qteFlagRunMacro = True\n\n            # Remove the mini applet.\n            self.qteMain.qteKillMiniApplet()\n\n            # Drop all macros and keys left in the respective queues.\n            self.qteMain._qteMacroQueue = []\n            self.qteMain._qteKeyEmulationQueue = []\n\n            # Ensure the focus manager runs once the event loop is idle again.\n            # Also, emit the abort signal.\n            msgObj = QtmacsMessage()\n            msgObj.setSignalName('qtesigAbort')\n            self.qteMain.qtesigAbort.emit(msgObj)\n            return True\n\n        # If the widget is unregistered then parse the key without further\n        # ado and declare the key event handled via the return value.\n        if not hasattr(targetObj, '_qteAdmin'):\n            self.qteProcessKey(event, targetObj)\n            return True\n\n        # Shorthand to the QtmacsApplet that received this event.\n        qteApplet = targetObj._qteAdmin.qteApplet\n\n        # Retrieve information about how the widget wants its keyboard\n        # events processed.\n        tmp = targetObj._qteAdmin.keyFilterPolicy()\n        receiveBefore, useQtmacs, receiveAfter = tmp\n        del tmp\n\n        # If the applet requested the keyboard input before being\n        # processed by Qtmacs then send the event to the applet which\n        # harbours the object (ie. *NOT* the object itself). It is the\n        # responsibility of the applet to enact the desired\n        # behaviour. If this action is the native behaviour of the\n        # widget then the applet should consider using\n        # \"self.qteText.keyPressEvent(keyEvent)\" to achieve this.\n        if receiveBefore:\n            qteApplet.qteKeyPressEventBefore(event, targetObj)\n\n        # If the applet wants Qtmacs to process the keyboard event then do so.\n        if useQtmacs:\n            self.qteProcessKey(event, targetObj)\n\n        # If the applet requested the keyboard input after being\n        # processed by Qtmacs then send the event to the applet which\n        # harbours the object (ie. *NOT* the object itself). It is the\n        # responsibility of the applet to enact the desired behaviour\n        # on the object.\n        if receiveAfter:\n            qteApplet.qteKeyPressEventAfter(event, targetObj)\n\n        # Declare the key event handled.\n        return True", "response": "Filter out keyboard events and return the internal key - value entry for the event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qteProcessKey(self, event, targetObj):\n        # Announce the key and targeted Qtmacs widget.\n        msgObj = QtmacsMessage((targetObj, event), None)\n        msgObj.setSignalName('qtesigKeypressed')\n        self.qteMain.qtesigKeypressed.emit(msgObj)\n\n        # Ignore standalone <Shift>, <Ctrl>, <Win>, <Alt>, and <AltGr>\n        # events.\n        if event.key() in (QtCore.Qt.Key_Shift, QtCore.Qt.Key_Control,\n                           QtCore.Qt.Key_Meta, QtCore.Qt.Key_Alt,\n                           QtCore.Qt.Key_AltGr):\n            return False\n\n        # Add the latest key stroke to the current key sequence.\n        self._keysequence.appendQKeyEvent(event)\n\n        # Determine if the widget was registered with qteAddWidget\n        isRegisteredWidget = hasattr(targetObj, '_qteAdmin')\n\n        if isRegisteredWidget and hasattr(targetObj._qteAdmin, 'keyMap'):\n            keyMap = targetObj._qteAdmin.keyMap\n        else:\n            keyMap = self.qteMain._qteGlobalKeyMapByReference()\n\n        # See if there is a match with an entry from the key map of\n        # the current object. If ``isPartialMatch`` is True then the\n        # key sequence is potentially incomplete, but not invalid.\n        # If ``macroName`` is not **None** then it is indeed complete.\n        (macroName, isPartialMatch) = keyMap.match(self._keysequence)\n\n        # Make a convenience copy of the key sequence.\n        keyseq_copy = QtmacsKeysequence(self._keysequence)\n\n        if isPartialMatch:\n            # Reset the key combination history if a valid macro was\n            # found so that the next key that arrives starts a new key\n            # sequence.\n            if macroName is None:\n                # Report a partially completed key-sequence.\n                msgObj = QtmacsMessage(keyseq_copy, None)\n                msgObj.setSignalName('qtesigKeyseqPartial')\n                self.qteMain.qtesigKeyseqPartial.emit(msgObj)\n            else:\n                # Execute the macro if requested.\n                if self._qteFlagRunMacro:\n                    self.qteMain.qteRunMacro(macroName, targetObj, keyseq_copy)\n\n                # Announce that the key sequence lead to a valid macro.\n                msgObj = QtmacsMessage((macroName, keyseq_copy), None)\n                msgObj.setSignalName('qtesigKeyseqComplete')\n                self.qteMain.qtesigKeyseqComplete.emit(msgObj)\n                self._keysequence.reset()\n        else:\n            if isRegisteredWidget:\n                # Announce (and log) that the key sequence is invalid. However,\n                # format the key string to Html first, eg. \"<ctrl>-x i\" to\n                # \"<b>&lt;Ctrl&gt;+x i</b>\".\n                tmp = keyseq_copy.toString()\n                tmp = tmp.replace('<', '&lt;')\n                tmp = tmp.replace('>', '&gt;')\n                msg = 'No macro is bound to <b>{}</b>.'.format(tmp)\n                self.qteMain.qteLogger.warning(msg)\n                msgObj = QtmacsMessage(keyseq_copy, None)\n                msgObj.setSignalName('qtesigKeyseqInvalid')\n                self.qteMain.qtesigKeyseqInvalid.emit(msgObj)\n            else:\n                # If we are in this branch then the widet is part of the\n                # Qtmacs widget hierachy yet was not registered with\n                # the qteAddWidget method. In this case use the QtDelivery\n                # macro to pass on whatever the event was (assuming\n                # macro processing is enabled).\n                if self._qteFlagRunMacro:\n                    self.qteMain.qteRunMacro(\n                        self.QtDelivery, targetObj, keyseq_copy)\n            self._keysequence.reset()\n\n        # Announce that Qtmacs has processed another key event. The\n        # outcome of this processing is communicated along with the\n        # signal.\n        msgObj = QtmacsMessage((targetObj, keyseq_copy, macroName), None)\n        msgObj.setSignalName('qtesigKeyparsed')\n        self.qteMain.qtesigKeyparsed.emit(msgObj)\n        return isPartialMatch", "response": "Process a key press event."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteAdjustWidgetSizes(self, handlePos: int=None):\n        # Do not adjust anything if there are less than two widgets.\n        if self.count() < 2:\n            return\n        \n        if self.orientation() == QtCore.Qt.Horizontal:\n            totDim = self.size().width() - self.handleWidth()\n        else:\n            totDim = self.size().height() - self.handleWidth()\n\n        # Assign both widgets the same size if no handle position provided.\n        if handlePos is None:\n            handlePos = (totDim + self.handleWidth()) // 2\n\n        # Sanity check.\n        if not (0 <= handlePos <= totDim):\n            return\n\n        # Compute widget sizes according to handle position.\n        newSize = [handlePos, totDim - handlePos]\n\n        # Assign the widget sizes.\n        self.setSizes(newSize)", "response": "Adjust the widget sizes inside the splitter according to handlePos."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qteAddWidget(self, widget):\n        # Add ``widget`` to the splitter.\n        self.addWidget(widget)\n\n        # Show ``widget``. If it is a ``QtmacsSplitter`` instance then its\n        # show() methods has no argument, whereas ``QtmacsApplet`` instances\n        # have overloaded show() methods because they should not be called\n        # unless you really know what you are doing (it will mess with Qtmacs\n        # layout engine).\n        if widget._qteAdmin.widgetSignature == '__QtmacsLayoutSplitter__':\n            widget.show()\n        else:\n            widget.show(True)\n\n        # Adjust the sizes of the widgets inside the splitter according to\n        # the handle position.\n        self.qteAdjustWidgetSizes()", "response": "Add a widget to the splitter and make it visible."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert a widget into the splitter at the specified index.", "response": "def qteInsertWidget(self, idx, widget):\n        \"\"\"\n        Insert ``widget`` to the splitter at the specified ``idx``\n        position and make it visible.\n\n        The only differences between this- and the native\n        ``QSplitter.insertWidget()`` method are\n\n        1. ``widget`` must have a ``QtmacsAdmin`` structure to ensure it is a\n           ``QtmacsApplet`` or a ``QtmacsSplitter``, \n        2. ``widget`` is automatically made visible.\n\n        Both actions are mostly for convenience because adding ``widget`` to\n        a QtmacsSplitter is tantamount to displaying it.\n\n        |Args|\n\n        * ``idx`` (**int**): non-negative index position.\n        * ``widget`` (**QWidget**): the widget to insert into the\n          splitter at position ``idx``.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n        # Insert the widget into the splitter.\n        self.insertWidget(idx, widget)\n\n        # Show ``widget``. If it is a ``QtmacsSplitter`` instance then its\n        # show() methods has no argument, whereas ``QtmacsApplet`` instances\n        # have overloaded show() methods because they should not be called\n        # unless you really know what you are doing (it will mess with Qtmacs\n        # layout engine).\n        if widget._qteAdmin.widgetSignature == '__QtmacsLayoutSplitter__':\n            widget.show()\n        else:\n            widget.show(True)\n\n        # Adjust the sizes of the widgets inside the splitter according to\n        # the handle position.\n        self.qteAdjustWidgetSizes()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef timerEvent(self, event):\n        self.killTimer(event.timerId())\n\n        if event.timerId() == self._qteTimerRunMacro:\n            # Declare the macro execution timer event handled.\n            self._qteTimerRunMacro = None\n\n            # If we are in this branch then the focus manager was just\n            # executed, the event loop has updated all widgets and\n            # cleared out all signals, and there is at least one macro\n            # in the macro queue and/or at least one key to emulate\n            # in the key queue. Execute the macros/keys and trigger\n            # the focus manager after each. The macro queue is cleared\n            # out first and the keys are only emulated if no more\n            # macros are left.\n            while True:\n                if len(self._qteMacroQueue) > 0:\n                    (macroName, qteWidget, event) = self._qteMacroQueue.pop(0)\n                    self._qteRunQueuedMacro(macroName, qteWidget, event)\n                elif len(self._qteKeyEmulationQueue) > 0:\n                    # Determine the recipient of the event. This can\n                    # be, in order of preference, the active widget in\n                    # the active applet, or just the active applet (if\n                    # it has no widget inside), or the active window\n                    # (if no applets are available).\n                    if self._qteActiveApplet is None:\n                        receiver = self.qteActiveWindow()\n                    else:\n                        if self._qteActiveApplet._qteActiveWidget is None:\n                            receiver = self._qteActiveApplet\n                        else:\n                            receiver = self._qteActiveApplet._qteActiveWidget\n\n                    # Call the event filter directly and trigger the focus\n                    # manager again.\n                    keysequence = self._qteKeyEmulationQueue.pop(0)\n                    self._qteEventFilter.eventFilter(receiver, keysequence)\n                else:\n                    # If we are in this branch then no more macros are left\n                    # to run. So trigger the focus manager one more time\n                    # and then leave the while-loop.\n                    self._qteFocusManager()\n                    break\n                self._qteFocusManager()\n        elif event.timerId() == self.debugTimer:\n            #win = self.qteNextWindow()\n            #self.qteMakeWindowActive(win)\n            #self.debugTimer = self.startTimer(1000)\n            pass\n        else:\n            # Should not happen.\n            print('Unknown timer ID')\n            pass", "response": "Trigger the focus manager and work off all queued macros and the key emulation queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _qteFocusManager(self):\n        # Process all but user input events.\n        flag = QtCore.QEventLoop.ExcludeUserInputEvents\n        qApp = QtGui.QApplication.instance()\n        qApp.processEvents(flag)\n\n        # Ensure _qteActiveApplet is not a dangling pointer.\n        if self._qteActiveApplet is not None:\n            if sip.isdeleted(self._qteActiveApplet):\n                self._qteActiveApplet = None\n\n        # Perform sanity checks on all applets.\n        if len(self._qteAppletList) > 0:\n            # Compile a list of visible and invisible applets (include\n            # the mini applet).\n            isVis = [_ for _ in self._qteAppletList if _.qteIsVisible()]\n            isNotVis = [_ for _ in self._qteAppletList if not _.qteIsVisible()]\n\n            # Ensure that the parent of every visible applet is a\n            # QtmacsSplitter instance.\n            for app in isVis:\n                signatureParent = app.parent()._qteAdmin.widgetSignature\n                if signatureParent != '__QtmacsLayoutSplitter__':\n                    msg = 'Applet <b>{}</b> is visible but not in splitter.'\n                    msg = msg.format(app.qteAppletID())\n                    self.qteLogger.error(msg, stack_info=True)\n\n            # Ensure all invisible applets have no parent.\n            for app in isNotVis:\n                if app.parent() is not None:\n                    msg = 'Applet <b>{}</b> is invisible yet has a parent.'\n                    msg = msg.format(app.qteAppletID())\n                    self.qteLogger.error(msg, stack_info=True)\n\n            # Ensure that Qt and Qtmacs agree on whether or not an\n            # applet is visible.\n            isFaulty = False\n            for app in (_ for _ in self._qteAppletList\n                        if(_.isVisible() != _.qteIsVisible())):\n                isFaulty = True\n                msg = 'Inconsistent visibility for applet <b>{}</b>.'\n                msg = msg.format(app.qteAppletID())\n                msg += ' Qt: {}, Qtmacs: {}'\n                msg = msg.format(app.isVisible(), app.qteIsVisible())\n                self.qteLogger.error(msg, stack_info=True)\n\n            # If one or more visibility inconsistencies occurred then\n            # go into damage control and reset the layout as best as\n            # possible.\n            if isFaulty:\n                msg = 'Resetting applet layout due to visibility'\n                msg += ' inconsistencies.'\n                self.qteLogger.critical(msg)\n\n                # Close all but the first window.\n                if len(self._qteWindowList) > 1:\n                    for window in self._qteWindowList[1:]:\n                        window.close()\n\n                # Hide all applets except the mini applet. Note that\n                # the hide() method will reparent the widget to None\n                # which implies that they are also removed from any\n                # they might be in.\n                for app in (_ for _ in self._qteAppletList\n                            if _ is not self._qteMiniApplet):\n                    app.hide(True)\n\n                # Manually insert the first applet into the splitter\n                # and make it visible.\n                if len(self._qteAppletList) > 0:\n                    app = self._qteAppletList[0]\n\n        # ------------------------------------------------------------\n        # If the _qteActiveApplet pointer is void try to assign it\n        # another applet, even if it is just the mini applet. If\n        # nothing is available, then return.\n        # ------------------------------------------------------------\n        if self._qteActiveApplet is None:\n            if len(self._qteAppletList) > 0:\n                self._qteActiveApplet = self.qteNextApplet(\n                    numSkip=0, skipMiniApplet=False)\n            else:\n                win = self._qteWindowList[0]\n                self._qteActiveApplet = None\n\n        if self._qteActiveApplet is None:\n            return\n\n        # ------------------------------------------------------------\n        # Activate the Qt window that harbours the applet and is only\n        # relevant if multiple windows are open. The activation is\n        # necessary because giving the focus to a any widget (an\n        # applet in this case) does not automatically active the\n        # window it is in (see Qt documentation for more details).\n        # This is the only place in Qtmacs where the Qt libraray is\n        # actually instructed to activate a window.\n        # ------------------------------------------------------------\n        try:\n            self._qteActiveApplet.activateWindow()\n        except Exception as err:\n            msg = 'Qt had a serious problem activating a window'\n            msg += ' --> try to reproduce.'\n            print(msg)\n            print('Raised error:', err)\n            print('Current applet', self._qteActiveApplet)\n            self.qteLogger.exception('Tried to focus a non-existing applet.',\n                                     exc_info=True, stack_info=True)\n\n        # Shorthand.\n        app = self._qteActiveApplet\n        self.qteMakeAppletActive(app)\n\n        # ------------------------------------------------------------\n        # Activate the next focusable widget in the applet. Note that\n        # the qteMakeWidgetActive method\n        #   * can cope with nextWidget being None,\n        #   * does not actually set the focus of anything but only\n        #     asks Qtmacs to do it. The actual focussing is done\n        #     a few lines further down.\n        # ------------------------------------------------------------\n        wid = app.qteNextWidget(numSkip=0)\n        app.qteMakeWidgetActive(wid)\n\n        # ------------------------------------------------------------\n        # Actually focus the active widget in the active applet. This\n        # is the only place in Qtmacs where the Qt library is actually\n        # instructed to focus a widget.\n        # ------------------------------------------------------------\n        try:\n            if app._qteActiveWidget is None:\n                app.setFocus(QtCore.Qt.OtherFocusReason)\n            else:\n                app._qteActiveWidget.setFocus(QtCore.Qt.OtherFocusReason)\n        except Exception as err:\n            print('Serious problem activating the applet --> '\n                  'try to reproduce.')\n            print('Raised error:', err)\n            print('Current applet object', app)\n            print('Next widget: ', nextWidget)\n            print('Current applet ID', app.qteAppletID())\n            print('Active widget inside this applet', app._qteActiveWidget)\n            self.qteLogger.exception('Tried to focus a non-existing applet.',\n                                     exc_info=True, stack_info=True)", "response": "This method is used to set the focus to the correct applet and widget. It is called by Qtmacs that actually knows the applet and widget and then the focus manager will update the internal status variables of the applet and widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _qteMouseClicked(self, widgetObj):\n\n        # ------------------------------------------------------------\n        # The following cases for widgetObj have to be distinguished:\n        #   1: not part of the Qtmacs widget hierarchy\n        #   2: part of the Qtmacs widget hierarchy but not registered\n        #   3: registered with Qtmacs and an applet\n        #   4: registered with Qtmacs and anything but an applet\n        # ------------------------------------------------------------\n\n        # Case 1: return immediately if widgetObj is not part of the\n        # Qtmacs widget hierarchy; otherwise, declare the applet\n        # containing the widgetObj active.\n        app = qteGetAppletFromWidget(widgetObj)\n        if app is None:\n            return\n        else:\n            self._qteActiveApplet = app\n\n        # Case 2: unregistered widgets are activated immediately.\n        if not hasattr(widgetObj, '_qteAdmin'):\n            self._qteActiveApplet.qteMakeWidgetActive(widgetObj)\n        else:\n            if app._qteAdmin.isQtmacsApplet:\n                # Case 3: widgetObj is a QtmacsApplet instance; do not\n                # focus any of its widgets as the focus manager will\n                # take care of it.\n                self._qteActiveApplet.qteMakeWidgetActive(None)\n            else:\n                # Case 4: widgetObj was registered with qteAddWidget\n                # and can thus be focused directly.\n                self._qteActiveApplet.qteMakeWidgetActive(widgetObj)\n\n        # Trigger the focus manager.\n        self._qteFocusManager()", "response": "Update the internal focus state as the result of a mouse click."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qteFocusChanged(self, old, new):\n        # Do nothing if new is old.\n        if old is new:\n            return\n\n        # If neither is None but both have the same top level\n        # window then do nothing.\n        if (old is not None) and (new is not None):\n            if old.isActiveWindow() is new.isActiveWindow():\n                return", "response": "Update the entry - point for the focus - changed signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteIsMiniApplet(self, obj):\n        try:\n            ret = obj._qteAdmin.isMiniApplet\n        except AttributeError:\n            ret = False\n\n        return ret", "response": "Return True if the object is a mini applet."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new empty window with the specified position and window ID.", "response": "def qteNewWindow(self, pos: QtCore.QRect=None, windowID: str=None):\n        \"\"\"\n        Create a new, empty window with ``windowID`` at position ``pos``.\n\n        |Args|\n\n        * ``pos`` (**QRect**): size and position of new window.\n        * ``windowID`` (**str**): unique window ID.\n\n        |Returns|\n\n        * **QtmacsWindow**: reference to the just created window instance.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n\n        # Compile a list of all window IDs.\n        winIDList = [_._qteWindowID for _ in self._qteWindowList]\n\n        # If no window ID was supplied simply count until a new and\n        # unique ID was found.\n        if windowID is None:\n            cnt = 0\n            while str(cnt) in winIDList:\n                cnt += 1\n            windowID = str(cnt)\n\n        # If no position was specified use a default one.\n        if pos is None:\n            pos = QtCore.QRect(500, 300, 1000, 500)\n\n        # Raise an error if a window with this ID already exists.\n        if windowID in winIDList:\n            msg = 'Window with ID <b>{}</b> already exists.'.format(windowID)\n            raise QtmacsOtherError(msg)\n\n        # Instantiate a new window object.\n        window = QtmacsWindow(pos, windowID)\n\n        # Add the new window to the window list and make it visible.\n        self._qteWindowList.append(window)\n        window.show()\n\n        # Trigger the focus manager once the event loop is in control again.\n        return window"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteMakeWindowActive(self, windowObj: QtmacsWindow):\n\n        if windowObj in self._qteWindowList:\n            # This will trigger the focusChanged slot which, in\n            # conjunction with the focus manager, will take care of\n            # the rest. Note that ``activateWindow`` is a native Qt\n            # method, not a Qtmacs invention.\n            windowObj.activateWindow()\n        else:\n            self.qteLogger.warning('Window to activate does not exist')", "response": "Make the window active and focus the first applet therein."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the currently active Qtmacs window.", "response": "def qteActiveWindow(self):\n        \"\"\"\n        Return the currently active ``QtmacsWindow`` object.\n\n        If no Qtmacs window is currently active (for instance because\n        the user is working with another application at the moment)\n        then the method returns the first window in the window list.\n\n        The method only returns **None** if the window list is empty,\n        which is definitively a bug.\n\n        |Args|\n\n        * **None**\n\n        |Returns|\n\n        * **QtmacsWindow**: the currently active window or **None** if\n          no window is currently active.\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n        if len(self._qteWindowList) == 0:\n            self.qteLogger.critical('The window list is empty.')\n            return None\n        elif len(self._qteWindowList) == 1:\n            return self._qteWindowList[0]\n        else:\n            # Find the active window.\n            for win in self._qteWindowList:\n                if win.isActiveWindow():\n                    return win\n\n        # Return the first window if none is active.\n        return self._qteWindowList[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qteNextWindow(self):\n        # Get the currently active window.\n        win = self.qteActiveWindow()\n\n        if win in self._qteWindowList:\n            # Find the index of the window in the window list and\n            # cyclically move to the next element in this list to find\n            # the next window object.\n            idx = self._qteWindowList.index(win)\n            idx = (idx + 1) % len(self._qteWindowList)\n            return self._qteWindowList[idx]\n        else:\n            msg = 'qteNextWindow method found a non-existing window.'\n            self.qteLogger.warning(msg)\n            return None", "response": "Return the next window in cyclic order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qteKillWindow(self, windowObj: QtmacsWindow=None):\n        # Use the currently active window if none was specified.\n        if windowObj is None:\n            windowObj = self.qteActiveWindow()\n            if windowObj is None:\n                msg = ('Cannot kill the currently active window because'\n                       ' it does not exist')\n                self.qteLogger.error(msg, stack_info=True)\n                return\n\n        # If Qtmacs shows only one window then do nothing, because\n        # deleting this window is akin to quitting Qtmacs without\n        # going through the proper shutdown process.\n        if len(self._qteWindowList) <= 1:\n            msg = 'The last available window cannot be deleted.'\n            self.qteLogger.error(msg, stack_info=True)\n            return\n\n        # Remove the window from the list.\n        try:\n            self._qteWindowList.remove(windowObj)\n        except ValueError:\n            msg = 'Cannot delete window with ID <b>{}</b> because it'\n            msg += ' does not exist.'.format(windowObj._qteWindowID)\n            self.qteLogger.error(msg, stack_info=True)\n            return\n\n        # Shorthand\n        activeWindow = self.qteActiveWindow()\n\n        # If the window to delete is currently active then switch the\n        # focus to the first window in the list (not particularly\n        # smart, but will do for now).\n        if windowObj is activeWindow:\n            activeWindow = self._qteWindowList[0]\n            self.activeWindow.activateWindow()\n\n            # Since the window with the active applet is deleted,\n            # try to find a new applet to activate instead. It is\n            # ok if there is no such applet.\n            self._qteActiveApplet = self.qteNextApplet(\n                windowObj=self._qteWindowList[0])\n\n        # Move the mini applet if it is currently in the doomed window.\n        if self._qteMiniApplet is not None:\n            if self._qteMiniApplet.qteParentWindow() is windowObj:\n                # Re-parent the mini applet to the splitter in the new\n                # window.\n                activeWindow.qteLayoutSplitter.addWidget(self._qteMiniApplet)\n                self._qteMiniApplet.show(True)\n\n                # Give the focus to the first focusable widget (if any).\n                wid = self._qteMiniApplet.qteNextWidget(numSkip=0)\n                self._qteMiniApplet.qteMakeWidgetActive(wid)\n                self.qteMakeAppletActive(self._qteMiniApplet)\n\n        # Compile the list of visible applets in the doomed window\n        # (use ``qteParentWindow`` to find all applets that have the\n        # doomed window as parent).\n        app_list = [_ for _ in self._qteAppletList\n                    if _.qteParentWindow() == windowObj]\n\n        # Hide all visible applets in the doomed window. Do not use\n        # ``qteRemoveFromLayout`` for this since that method attempts\n        # to replace the removed applet with another one, ie. the\n        # doomed window would once again contain an applet.\n        for app_obj in app_list:\n            if not self.qteIsMiniApplet(app_obj):\n                app_obj.hide(True)\n\n        # Ensure the focus manager is triggered and the window deleted\n        # once the event loop has regained control.\n        windowObj.deleteLater()", "response": "Kill the specified window."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the next applet in the cyclic order.", "response": "def qteNextApplet(self, numSkip: int=1, ofsApp: (QtmacsApplet, str)=None,\n                      skipInvisible: bool=True, skipVisible: bool=False,\n                      skipMiniApplet: bool=True,\n                      windowObj: QtmacsWindow=None):\n        \"\"\"\n        Return the next applet in cyclic order.\n\n        If ``ofsApp=None`` then start cycling at the currently active\n        applet. If ``ofsApp`` does not fit the selection criteria,\n        then the cycling starts at the next applet in cyclic order\n        that does.\n\n        The returned applet is ``numSkip`` items in cyclic order away\n        from the offset applet. If ``numSkip`` is positive traverse\n        the applet list forwards, otherwise backwards.\n\n        The method supports the following Boolean selection criteria:\n\n        * ``skipInvisible``: ignore all invisible applets.\n        * ``skipVisible``: ignore all visible applets.\n        * ``skipMiniApplet``: ignore the mini applet applet.\n\n        The ``ofsApp`` parameter can either be an instance of\n        ``QtmacsApplet`` or a string denoting an applet ID. In the\n        latter case the ``qteGetAppletHandle`` method is used to fetch\n        the respective applet instance.\n\n        |Args|\n\n        * ``numSkip`` (**int**): number of applets to skip.\n        * ``ofsApp`` (**QtmacsApplet**, **str**): applet from where to\n          start counting.\n        * ``skipInvisible`` (**bool**): whether or not to skip currently\n          not shown applets.\n        * ``skipVisible`` (**bool**): whether or not to skip currently\n          shown applets.\n        * ``skipMiniApplet`` (**bool**): whether or not to skip the mini\n          applet.\n        * ``windowObj`` (**QtmacsWindow**): the window to use when looking\n          for applets. If **None**, then search in all windows.\n\n        |Returns|\n\n        * **QtmacsApplet**: either the next applet that fits the criteria,\n          or **None** if no such applet exists.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # If ``applet`` was specified by its ID (ie. a string) then\n        # fetch the associated ``QtmacsApplet`` instance. If\n        # ``applet`` is already an instance of ``QtmacsApplet`` then\n        # use it directly.\n        if isinstance(ofsApp, str):\n            ofsApp = self.qteGetAppletHandle(ofsApp)\n\n        # Return immediately if the applet list is empty.\n        if len(self._qteAppletList) == 0:\n            return None\n\n        # Sanity check: if the user requests applets that are neither\n        # visible nor invisible then return immediately because no\n        # such applet can possibly exist.\n        if skipVisible and skipInvisible:\n            return None\n\n        # Make a copy of the applet list.\n        appList = list(self._qteAppletList)\n\n        # Remove all invisible applets from the list if the\n        # skipInvisible flag is set.\n        if skipInvisible:\n            appList = [app for app in appList if app.qteIsVisible()]\n\n            # From the list of (now guaranteed visible) applets remove\n            # all those that are not in the specified window.\n            if windowObj is not None:\n                appList = [app for app in appList\n                           if app.qteParentWindow() == windowObj]\n\n        # Remove all visible applets from the list if the\n        # skipInvisible flag is set.\n        if skipVisible:\n            appList = [app for app in appList if not app.qteIsVisible()]\n\n        # If the mini-buffer is to be skipped remove it (if a custom\n        # mini applet even exists).\n        if skipMiniApplet:\n            if self._qteMiniApplet in appList:\n                appList.remove(self._qteMiniApplet)\n\n        # Return immediately if no applet satisfied all criteria.\n        if len(appList) == 0:\n            return None\n\n        # If no offset applet was given use the currently active one.\n        if ofsApp is None:\n            ofsApp = self._qteActiveApplet\n\n        if ofsApp in self._qteAppletList:\n            # Determine if the offset applet is part of the pruned\n            # list.\n            if ofsApp in appList:\n                # Yes: determine its index in the list.\n                ofsIdx = appList.index(ofsApp)\n            else:\n                # No: traverse all applets until one is found that is\n                # also part of the pruned list (start at ofsIdx). Then\n                # determine its index in the list.\n                ofsIdx = self._qteAppletList.index(ofsApp)\n                glob_list = self._qteAppletList[ofsIdx:]\n                glob_list += self._qteAppletList[:ofsIdx]\n\n                # Compile the intersection between the global and pruned list.\n                ofsIdx = [appList.index(_) for _ in glob_list if _ in appList]\n                if len(ofsIdx) == 0:\n                    msg = ('No match between global and local applet list'\n                           ' --> Bug.')\n                    self.qteLogger.error(msg, stack_info=True)\n                    return None\n                else:\n                    # Pick the first match.\n                    ofsIdx = ofsIdx[0]\n        else:\n            # The offset applet does not exist, eg. because the user\n            # supplied a handle that does not point to an applet or\n            # we are called from qteKillApplet to replace the just\n            # removed (and active) applet.\n            ofsIdx = 0\n\n        # Compute the index of the next applet and wrap around the\n        # list if necessary.\n        ofsIdx = (ofsIdx + numSkip) % len(appList)\n\n        # Return a handle to the applet that meets the specified\n        # criteria.\n        return appList[ofsIdx]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute a macro in the event loop.", "response": "def qteRunMacro(self, macroName: str, widgetObj: QtGui.QWidget=None,\n                    keysequence: QtmacsKeysequence=None):\n        \"\"\"\n        Queue a previously registered macro for execution once the\n        event loop is idle.\n\n        The reason for queuing macros in the first place, instead of\n        running them straight away, is to ensure that the event loop\n        updates all the widgets in between any two macros. This will\n        avoid many spurious and hard to find bugs due to macros\n        assuming that all user interface elements have been updated\n        when in fact they were not.\n\n        |Args|\n\n        * ``macroName`` (**str**): name of macro.\n        * ``widgetObj`` (**QWidget**): widget (if any) on which the\n          macro should operate.\n        * ``keysequence`` (**QtmacsKeysequence**): key sequence that\n          triggered the macro.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Add the new macro to the queue and call qteUpdate to ensure\n        # that the macro is processed once the event loop is idle again.\n        self._qteMacroQueue.append((macroName, widgetObj, keysequence))\n        self.qteUpdate()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _qteRunQueuedMacro(self, macroName: str,\n                           widgetObj: QtGui.QWidget=None,\n                           keysequence: QtmacsKeysequence=None):\n        \"\"\"\n        Execute the next macro in the macro queue.\n\n        This method is triggered by the ``timerEvent`` in conjunction\n        with the focus manager to ensure the event loop updates the\n        GUI in between any two macros.\n\n        .. warning:: Never call this method directly.\n\n        |Args|\n\n        * ``macroName`` (**str**): name of macro\n        * ``widgetObj`` (**QWidget**): widget (if any) for which the\n          macro applies\n        * ``keysequence* (**QtmacsKeysequence**): key sequence that\n          triggered the macro.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Fetch the applet holding the widget (this may be None).\n        app = qteGetAppletFromWidget(widgetObj)\n\n        # Double check that the applet still exists, unless there is\n        # no applet (can happen when the windows are empty).\n        if app is not None:\n            if sip.isdeleted(app):\n                msg = 'Ignored macro <b>{}</b> because it targeted a'\n                msg += '  nonexistent applet.'.format(macroName)\n                self.qteLogger.warning(msg)\n                return\n\n        # Fetch a signature compatible macro object.\n        macroObj = self.qteGetMacroObject(macroName, widgetObj)\n\n        # Log an error if no compatible macro was found.\n        if macroObj is None:\n            msg = 'No <b>{}</b>-macro compatible with {}:{}-type applet'\n            msg = msg.format(macroName, app.qteAppletSignature(),\n                             widgetObj._qteAdmin.widgetSignature)\n            self.qteLogger.warning(msg)\n            return\n\n        # Update the 'last_key_sequence' variable in case the macros,\n        # or slots triggered by that macro, have access to it.\n        self.qteDefVar('last_key_sequence', keysequence,\n                       doc=\"Last valid key sequence that triggered a macro.\")\n\n        # Set some variables in the macro object for convenient access\n        # from inside the macro.\n        if app is None:\n            macroObj.qteApplet = macroObj.qteWidget = None\n        else:\n            macroObj.qteApplet = app\n            macroObj.qteWidget = widgetObj\n\n        # Run the macro and trigger the focus manager.\n        macroObj.qtePrepareToRun()", "response": "Execute the next macro in the macro queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qteNewApplet(self, appletName: str, appletID: str=None,\n                     windowObj: QtmacsWindow=None):\n        \"\"\"\n        Create a new instance of ``appletName`` and assign it the\n        ``appletID``.\n\n        This method creates a new instance of ``appletName``, as\n        registered by the ``qteRegisterApplet`` method. If an applet\n        with ``appletID`` already exists then the method does nothing\n        and returns **None**, otherwise the newly created instance.\n\n        If ``appletID`` is **None** then the method will create an\n        applet with the next unique ID that fits the format\n        ``appletName_0``, eg. 'RichEditor_0', 'RichEditor_1', etc.\n\n        .. note:: The applet is not automatically made visible.\n\n        |Args|\n\n        * ``appletName`` (**str**): name of applet to create\n          (eg. 'LogViewer')\n        * ``appletID`` (**str**): unique applet identifier.\n        * ``windowObj`` (**QtmacsWindow**): the window in which\n          the applet should be created.\n\n        |Returns|\n\n        * **QtmacsApplet**: applet handle or **None** if no applet\n          was created.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Use the currently active window if none was specified.\n        if windowObj is None:\n            windowObj = self.qteActiveWindow()\n            if windowObj is None:\n                msg = 'Cannot determine the currently active window.'\n                self.qteLogger.error(msg, stack_info=True)\n                return\n\n        # Determine an automatic applet ID if none was provided.\n        if appletID is None:\n            cnt = 0\n            while True:\n                appletID = appletName + '_' + str(cnt)\n                if self.qteGetAppletHandle(appletID) is None:\n                    break\n                else:\n                    cnt += 1\n\n        # Return immediately if an applet with the same ID already\n        # exists.\n        if self.qteGetAppletHandle(appletID) is not None:\n            msg = 'Applet with ID <b>{}</b> already exists'.format(appletID)\n            self.qteLogger.error(msg, stack_info=True)\n            return None\n\n        # Verify that the requested applet class was registered\n        # beforehand and fetch it.\n        if appletName not in self._qteRegistryApplets:\n            msg = 'Unknown applet <b>{}</b>'.format(appletName)\n            self.qteLogger.error(msg, stack_info=True)\n            return None\n        else:\n            cls = self._qteRegistryApplets[appletName]\n\n        # Try to instantiate the class.\n        try:\n            app = cls(appletID)\n        except Exception:\n            msg = 'Applet <b>{}</b> has a faulty constructor.'.format(appletID)\n            self.qteLogger.exception(msg, exc_info=True, stack_info=True)\n            return None\n\n        # Ensure the applet class has an applet signature.\n        if app.qteAppletSignature() is None:\n            msg = 'Cannot add applet <b>{}</b> '.format(app.qteAppletID())\n            msg += 'because it has not applet signature.'\n            msg += ' Use self.qteSetAppletSignature in the constructor'\n            msg += ' of the class to fix this.'\n            self.qteLogger.error(msg, stack_info=True)\n            return None\n\n        # Add the applet to the list of instantiated Qtmacs applets.\n        self._qteAppletList.insert(0, app)\n\n        # If the new applet does not yet have an internal layout then\n        # arrange all its children automatically. The layout used for\n        # this is horizontal and the widgets are added in the order in\n        # which they were registered with Qtmacs.\n        if app.layout() is None:\n            appLayout = QtGui.QHBoxLayout()\n            for handle in app._qteAdmin.widgetList:\n                appLayout.addWidget(handle)\n            app.setLayout(appLayout)\n\n        # Initially, the window does not have a parent. A parent will\n        # be assigned automatically once the applet is made visible,\n        # in which case it is re-parented into a QtmacsSplitter.\n        app.qteReparent(None)\n\n        # Emit the init hook for this applet.\n        self.qteRunHook('init', QtmacsMessage(None, app))\n\n        # Return applet handle.\n        return app", "response": "Create a new applet with the given name and ID."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qteAddMiniApplet(self, appletObj: QtmacsApplet):\n        # Do nothing if a custom mini applet has already been\n        # installed.\n        if self._qteMiniApplet is not None:\n            msg = 'Cannot replace mini applet more than once.'\n            self.qteLogger.warning(msg)\n            return False\n\n        # Arrange all registered widgets inside this applet\n        # automatically if the mini applet object did not install its\n        # own layout.\n        if appletObj.layout() is None:\n            appLayout = QtGui.QHBoxLayout()\n            for handle in appletObj._qteAdmin.widgetList:\n                appLayout.addWidget(handle)\n            appletObj.setLayout(appLayout)\n\n        # Now that we have decided to install this mini applet, keep a\n        # reference to it and set the mini applet flag in the\n        # applet. This flag is necessary for some methods to separate\n        # conventional applets from mini applets.\n        appletObj._qteAdmin.isMiniApplet = True\n        self._qteMiniApplet = appletObj\n\n        # Shorthands.\n        app = self._qteActiveApplet\n        appWin = self.qteActiveWindow()\n\n        # Remember which window and applet spawned this mini applet.\n        self._qteMiniApplet._qteCallingApplet = app\n        self._qteMiniApplet._qteCallingWindow = appWin\n        del app\n\n        # Add the mini applet to the applet registry, ie. for most\n        # purposes the mini applet is treated like any other applet.\n        self._qteAppletList.insert(0, self._qteMiniApplet)\n\n        # Add the mini applet to the respective splitter in the window\n        # layout and show it.\n        appWin.qteLayoutSplitter.addWidget(self._qteMiniApplet)\n        self._qteMiniApplet.show(True)\n\n        # Give focus to first focusable widget in the mini applet\n        # applet (if one exists)\n        wid = self._qteMiniApplet.qteNextWidget(numSkip=0)\n        self._qteMiniApplet.qteMakeWidgetActive(wid)\n        self.qteMakeAppletActive(self._qteMiniApplet)\n\n        # Mini applet was successfully installed.\n        return True", "response": "Install the appletObj as the mini applet."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qteKillMiniApplet(self):\n        # Sanity check: is the handle valid?\n        if self._qteMiniApplet is None:\n            return\n\n        # Sanity check: is it really a mini applet?\n        if not self.qteIsMiniApplet(self._qteMiniApplet):\n            msg = ('Mini applet does not have its mini applet flag set.'\n                   ' Ignored.')\n            self.qteLogger.warning(msg)\n\n        if self._qteMiniApplet not in self._qteAppletList:\n            # Something is wrong because the mini applet is not part\n            # of the applet list.\n            msg = 'Custom mini applet not in applet list --> Bug.'\n            self.qteLogger.warning(msg)\n        else:\n            # Inform the mini applet that it is about to be killed.\n            try:\n                self._qteMiniApplet.qteToBeKilled()\n            except Exception:\n                msg = 'qteToBeKilledRoutine is faulty'\n                self.qteLogger.exception(msg, exc_info=True, stack_info=True)\n\n            # Shorthands to calling window.\n            win = self._qteMiniApplet._qteCallingWindow\n\n            # We need to move the focus from the mini applet back to a\n            # regular applet. Therefore, first look for the next\n            # visible applet in the current window (ie. the last one\n            # that was made active).\n            app = self.qteNextApplet(windowObj=win)\n            if app is not None:\n                # Found another (visible or invisible) applet --> make\n                # it active/visible.\n                self.qteMakeAppletActive(app)\n            else:\n                # No visible applet available in this window --> look\n                # for an invisible one.\n                app = self.qteNextApplet(skipInvisible=False, skipVisible=True)\n                if app is not None:\n                    # Found an invisible applet --> make it\n                    # active/visible.\n                    self.qteMakeAppletActive(app)\n                else:\n                    # There is no other visible applet in this window.\n                    # The focus manager will therefore make a new applet\n                    # active.\n                    self._qteActiveApplet = None\n            self._qteAppletList.remove(self._qteMiniApplet)\n\n        # Close the mini applet applet and schedule it for deletion.\n        self._qteMiniApplet.close()\n        self._qteMiniApplet.deleteLater()\n\n        # Clear the handle to the mini applet.\n        self._qteMiniApplet = None", "response": "Kill the mini applet."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _qteFindAppletInSplitter(self, appletObj: QtmacsApplet,\n                                 split: QtmacsSplitter):\n        \"\"\"\n        Return the splitter that holds ``appletObj``.\n\n        This method recursively searches for ``appletObj`` in the\n        nested splitter hierarchy of the window layout, starting at\n        ``split``. If successful, the method returns a reference to\n        the splitter, otherwise it returns **None**.\n\n        |Args|\n\n        * ``appletObj`` (**QtmacsApplet**): the applet to look for.\n        * ``split`` (**QtmacsSplitter**): the splitter where to begin.\n\n        |Returns|\n\n        * **QtmacsSplitter**: the splitter that holds ``appletObj``\n          or **None**.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        def splitterIter(split):\n            \"\"\"\n            Iterator over all QtmacsSplitters.\n            \"\"\"\n            for idx in range(split.count()):\n                subSplitter = split.widget(idx)\n                subID = subSplitter._qteAdmin.widgetSignature\n                if subID == '__QtmacsLayoutSplitter__':\n                    yield from splitterIter(subSplitter)\n            yield split\n\n        # Traverse all QtmacsSplitter until ``appletObj`` was found.\n        for curSplit in splitterIter(split):\n            if appletObj in curSplit.children():\n                return curSplit\n\n        # No splitter holds ``appletObj``.\n        return None", "response": "This method searches for appletObj in the applet hierarchy starting at\n        and traversing all splitters until appletObj is found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsplitting the applet into two pieces.", "response": "def qteSplitApplet(self, applet: (QtmacsApplet, str)=None,\n                       splitHoriz: bool=True,\n                       windowObj: QtmacsWindow=None):\n        \"\"\"\n        Reveal ``applet`` by splitting the space occupied by the\n        current applet.\n\n        If ``applet`` is already visible then the method does\n        nothing. Furthermore, this method does not change the focus,\n        ie. the currently active applet will remain active.\n\n        If ``applet`` is **None** then the next invisible applet\n        will be shown. If ``windowObj`` is **None** then the\n        currently active window will be used.\n\n        The ``applet`` parameter can either be an instance of\n        ``QtmacsApplet`` or a string denoting an applet ID. In the\n        latter case the ``qteGetAppletHandle`` method is used to fetch\n        the respective applet instance.\n\n        |Args|\n\n        * ``applet`` (**QtmacsApplet**, **str**): the applet to reveal.\n        * ``splitHoriz`` (**bool**): whether to split horizontally\n          or vertically.\n        * ``windowObj`` (**QtmacsWindow**): the window in which to\n          reveal ``applet``.\n\n        |Returns|\n\n        * **bool**: if **True**, ``applet`` was revealed.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # If ``newAppObj`` was specified by its ID (ie. a string) then\n        # fetch the associated ``QtmacsApplet`` instance. If\n        # ``newAppObj`` is already an instance of ``QtmacsApplet``\n        # then use it directly.\n        if isinstance(applet, str):\n            newAppObj = self.qteGetAppletHandle(applet)\n        else:\n            newAppObj = applet\n\n        # Use the currently active window if none was specified.\n        if windowObj is None:\n            windowObj = self.qteActiveWindow()\n            if windowObj is None:\n                msg = 'Cannot determine the currently active window.'\n                self.qteLogger.error(msg, stack_info=True)\n                return\n\n        # Convert ``splitHoriz`` to the respective Qt constant.\n        if splitHoriz:\n            splitOrientation = QtCore.Qt.Horizontal\n        else:\n            splitOrientation = QtCore.Qt.Vertical\n\n        if newAppObj is None:\n            # If no new applet was specified use the next available\n            # invisible applet.\n            newAppObj = self.qteNextApplet(skipVisible=True,\n                                           skipInvisible=False)\n        else:\n            # Do nothing if the new applet is already visible.\n            if newAppObj.qteIsVisible():\n                return False\n\n        # If we still have not found an applet then there are no\n        # invisible applets left to show. Therefore, splitting makes\n        # no sense.\n        if newAppObj is None:\n            self.qteLogger.warning('All applets are already visible.')\n            return False\n\n        # If the root splitter is empty then add the new applet and\n        # return immediately.\n        if windowObj.qteAppletSplitter.count() == 0:\n            windowObj.qteAppletSplitter.qteAddWidget(newAppObj)\n            windowObj.qteAppletSplitter.setOrientation(splitOrientation)\n            return True\n\n        # ------------------------------------------------------------\n        # The root splitter contains at least one widget, if we got\n        # this far.\n        # ------------------------------------------------------------\n\n        # Shorthand to last active applet in the current window. Query\n        # this applet with qteNextApplet method because\n        # self._qteActiveApplet may be a mini applet, and we are only\n        # interested in genuine applets.\n        curApp = self.qteNextApplet(numSkip=0, windowObj=windowObj)\n\n        # Get a reference to the splitter in which the currently\n        # active applet lives. This may be the root splitter, or one\n        # of its child splitters.\n        split = self._qteFindAppletInSplitter(\n            curApp, windowObj.qteAppletSplitter)\n        if split is None:\n            msg = 'Active applet <b>{}</b> not in the layout.'\n            msg = msg.format(curApp.qteAppletID())\n            self.qteLogger.error(msg, stack_info=True)\n            return False\n\n        # If 'curApp' lives in the root splitter, and the root\n        # splitter contains only a single element, then simply add the\n        # new applet as the second element and return.\n        if split is windowObj.qteAppletSplitter:\n            if split.count() == 1:\n                split.qteAddWidget(newAppObj)\n                split.setOrientation(splitOrientation)\n                return True\n\n        # ------------------------------------------------------------\n        # The splitter (root or not) contains two widgets, if we got\n        # this far.\n        # ------------------------------------------------------------\n\n        # Determine the index of the applet inside the splitter.\n        curAppIdx = split.indexOf(curApp)\n\n        # Create a new splitter and populate it with 'curApp' and the\n        # previously invisible ``newAppObj``. Then insert this new splitter at\n        # the position where the old applet was taken from. Note: widgets are\n        # inserted with ``qteAddWidget`` (because they are ``QtmacsApplet``\n        # instances), whereas splitters are added with ``insertWidget``, NOT\n        # ``qteInsertWidget``. The reason is that splitters do not require the\n        # extra TLC necessary for applets in terms of how and where to show\n        # them.\n        newSplit = QtmacsSplitter(splitOrientation, windowObj)\n        curApp.setParent(None)\n        newSplit.qteAddWidget(curApp)\n        newSplit.qteAddWidget(newAppObj)\n        split.insertWidget(curAppIdx, newSplit)\n\n        # Adjust the size of two widgets in ``split`` (ie. ``newSplit`` and\n        # whatever other widget) to take up equal space. The same adjusment is\n        # made for ``newSplit``, but there the ``qteAddWidget`` methods have\n        # already taken care of it.\n        split.qteAdjustWidgetSizes()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteReplaceAppletInLayout(self, newApplet: (QtmacsApplet, str),\n                                 oldApplet: (QtmacsApplet, str)=None,\n                                 windowObj: QtmacsWindow=None):\n        \"\"\"\n        Replace ``oldApplet`` with ``newApplet`` in the window layout.\n\n        If ``oldApplet`` is **None** then the currently active applet\n        will be replaced. If ``windowObj`` is **None** then the\n        currently active window is used.\n\n        The ``oldApplet`` and ``newApplet`` parameters can either be\n        instances of ``QtmacsApplet`` or strings denoting the applet\n        IDs. In the latter case the ``qteGetAppletHandle`` method is\n        used to fetch the respective applet instances.\n\n        |Args|\n\n        * ``newApplet`` (**QtmacsApplet**, **str**): applet to add.\n        * ``oldApplet`` (**QtmacsApplet**, **str**): applet to replace.\n        * ``windowObj`` (**QtmacsWindow**): the window in which to operate.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # If ``oldAppObj`` was specified by its ID (ie. a string) then\n        # fetch the associated ``QtmacsApplet`` instance. If\n        # ``oldAppObj`` is already an instance of ``QtmacsApplet``\n        # then use it directly.\n        if isinstance(oldApplet, str):\n            oldAppObj = self.qteGetAppletHandle(oldApplet)\n        else:\n            oldAppObj = oldApplet\n\n        # If ``newAppObj`` was specified by its ID (ie. a string) then\n        # fetch the associated ``QtmacsApplet`` instance. If\n        # ``newAppObj`` is already an instance of ``QtmacsApplet``\n        # then use it directly.\n        if isinstance(newApplet, str):\n            newAppObj = self.qteGetAppletHandle(newApplet)\n        else:\n            newAppObj = newApplet\n\n        # Use the currently active window if none was specified.\n        if windowObj is None:\n            windowObj = self.qteActiveWindow()\n            if windowObj is None:\n                msg = 'Cannot determine the currently active window.'\n                self.qteLogger.warning(msg, stack_info=True)\n                return\n\n        # If the main splitter contains no applet then just add newAppObj.\n        if windowObj.qteAppletSplitter.count() == 0:\n            windowObj.qteAppletSplitter.qteAddWidget(newAppObj)\n            return\n\n        # If no oldAppObj was specified use the currently active one\n        # instead. Do not use qteActiveApplet to determine it, though,\n        # because it may point to a mini buffer. If it is, then we\n        # need the last active Qtmacs applet. In either case, the\n        # qteNextApplet method will take care of these distinctions.\n        if oldAppObj is None:\n            oldAppObj = self.qteNextApplet(numSkip=0, windowObj=windowObj)\n\n        # Sanity check: the applet to replace must exist.\n        if oldAppObj is None:\n            msg = 'Applet to replace does not exist.'\n            self.qteLogger.error(msg, stack_info=True)\n            return\n\n        # Sanity check: do nothing if the old- and new applet are the\n        # same.\n        if newAppObj is oldAppObj:\n            return\n\n        # Sanity check: do nothing if both applets are already\n        # visible.\n        if oldAppObj.qteIsVisible() and newAppObj.qteIsVisible():\n            return\n\n        # Search for the splitter that contains 'oldAppObj'.\n        split = self._qteFindAppletInSplitter(\n            oldAppObj, windowObj.qteAppletSplitter)\n        if split is None:\n            msg = ('Applet <b>{}</b> not replaced because it is not'\n                   'in the layout.'.format(oldAppObj.qteAppletID()))\n            self.qteLogger.warning(msg)\n            return\n\n        # Determine the position of oldAppObj inside the splitter.\n        oldAppIdx = split.indexOf(oldAppObj)\n\n        # Replace oldAppObj with newAppObj but maintain the widget sizes. To do\n        # so, first insert newAppObj into the splitter at the position of\n        # oldAppObj. Afterwards, remove oldAppObj by re-parenting it, make\n        # it invisible, and restore the widget sizes.\n        sizes = split.sizes()\n        split.qteInsertWidget(oldAppIdx, newAppObj)\n        oldAppObj.hide(True)\n        split.setSizes(sizes)", "response": "Replace applet with newApplet in the window layout."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef qteRemoveAppletFromLayout(self, applet: (QtmacsApplet, str)):\n        # If ``applet`` was specified by its ID (ie. a string) then\n        # fetch the associated ``QtmacsApplet`` instance. If\n        # ``applet`` is already an instance of ``QtmacsApplet`` then\n        # use it directly.\n        if isinstance(applet, str):\n            appletObj = self.qteGetAppletHandle(applet)\n        else:\n            appletObj = applet\n\n        # Return immediately if the applet does not exist in any splitter.\n        for window in self._qteWindowList:\n            split = self._qteFindAppletInSplitter(\n                appletObj, window.qteAppletSplitter)\n            if split is not None:\n                break\n        if split is None:\n            return\n\n        # If the applet lives in the main splitter and is the only\n        # widget there it must be replaced with another applet. This\n        # case needs to be handled separately from the other options\n        # because every other splitter will always contain exactly two\n        # items (ie. two applets, two splitters, or one of each).\n        if (split is window.qteAppletSplitter) and (split.count() == 1):\n            # Remove the existing applet object from the splitter and\n            # hide it.\n            split.widget(0).hide(True)\n\n            # Get the next available applet to focus on. Try to find a\n            # visible applet in the current window, and if none exists\n            # then pick the first invisible one. If there is neither\n            # a visible nor an invisible applet left then do nothing.\n            nextApp = self.qteNextApplet(windowObj=window)\n            if nextApp is None:\n                nextApp = self.qteNextApplet(skipInvisible=False,\n                                             skipVisible=True)\n                if nextApp is None:\n                    return\n\n            # Ok, we found an applet to show.\n            split.qteAddWidget(nextApp)\n            return\n\n        # ------------------------------------------------------------\n        # If we got until here we know that the splitter (root or not)\n        # contains (at least) two elements. Note: if it contains more\n        # than two elements then there is a bug somewhere.\n        # ------------------------------------------------------------\n\n        # Find the index of the object inside the splitter.\n        appletIdx = split.indexOf(appletObj)\n\n        # Detach the applet from the splitter and make it invisible.\n        appletObj.hide(True)\n\n        # Verify that really only one additional element is left in\n        # the splitter. If not, then something is wrong.\n        if split.count() != 1:\n            msg = ('Splitter has <b>{}</b> elements left instead of'\n                   ' exactly one.'.format(split.count()))\n            self.qteLogger.warning(msg)\n\n        # Get a reference to the other widget in the splitter (either\n        # a QtmacsSplitter or a QtmacsApplet).\n        otherWidget = split.widget(0)\n\n        # Is the other widget another splitter?\n        if otherWidget._qteAdmin.widgetSignature == '__QtmacsLayoutSplitter__':\n            # Yes, ``otherWidget`` is a QtmacsSplitter object,\n            # therefore shift all its widgets over to the current\n            # splitter.\n            for ii in range(otherWidget.count()):\n                # Get the next widget from that splitter. Note that we\n                # always pick the widget at the 0'th position because\n                # the splitter will re-index the remaining widgets\n                # after each removal.\n                obj = otherWidget.widget(0)\n                if appletIdx == 0:\n                    split.qteAddWidget(obj)\n                else:\n                    split.qteInsertWidget(1 + ii, obj)\n\n            # Delete the child splitter.\n            otherWidget.setParent(None)\n            otherWidget.close()\n        else:\n            # No, ``otherWidget`` is a QtmacsApplet, therefore move it\n            # to the parent splitter and delete the current one,\n            # unless 'split' is the root splitter in which case\n            # nothing happens.\n            if split is not window.qteAppletSplitter:\n                otherWidget.qteReparent(split.parent())\n                split.setParent(None)\n                split.close()", "response": "Remove applet from the window layout."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qteKillApplet(self, appletID: str):\n        # Compile list of all applet IDs.\n        ID_list = [_.qteAppletID() for _ in self._qteAppletList]\n\n        if appletID not in ID_list:\n            # Do nothing if the applet does not exist.\n            return\n        else:\n            # Get a reference to the actual applet object based on the\n            # name.\n            idx = ID_list.index(appletID)\n            appObj = self._qteAppletList[idx]\n\n        # Mini applets are killed with a special method.\n        if self.qteIsMiniApplet(appObj):\n            self.qteKillMiniApplet()\n            return\n\n        # Inform the applet that it is about to be killed.\n        appObj.qteToBeKilled()\n\n        # Determine the window of the applet.\n        window = appObj.qteParentWindow()\n\n        # Get the previous invisible applet (*may* come in handy a few\n        # lines below).\n        newApplet = self.qteNextApplet(numSkip=-1, skipInvisible=False,\n                                       skipVisible=True)\n\n        # If there is no invisible applet available, or the only available\n        # applet is the one to be killed, then set newApplet to None.\n        if (newApplet is None) or (newApplet is appObj):\n            newApplet = None\n        else:\n            self.qteReplaceAppletInLayout(newApplet, appObj, window)\n\n        # Ensure that _qteActiveApplet does not point to the applet\n        # to be killed as it will otherwise result in a dangling\n        # pointer.\n        if self._qteActiveApplet is appObj:\n            self._qteActiveApplet = newApplet\n\n        # Remove the applet object from the applet list.\n        self.qteLogger.debug('Kill applet: <b>{}</b>'.format(appletID))\n        self._qteAppletList.remove(appObj)\n\n        # Close the applet and schedule it for destruction. Explicitly\n        # call the sip.delete() method to ensure that all signals are\n        # *immediately* disconnected, as otherwise there is a good\n        # chance that Qtmacs segfaults if Python/Qt thinks the slots\n        # are still connected when really the object does not exist\n        # anymore.\n        appObj.close()\n        sip.delete(appObj)", "response": "Kill applet with the given applet ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a hook named hookName and pass on msgObj.", "response": "def qteRunHook(self, hookName: str, msgObj: QtmacsMessage=None):\n        \"\"\"\n        Trigger the hook named ``hookName`` and pass on ``msgObj``.\n\n        This will call all slots associated with ``hookName`` but\n        without calling the event loop in between. Therefore, if\n        one slots changes the state of the GUI, every subsequent slot\n        may have difficulties determining the actual state of the GUI\n        using Qt accessor functions. It is thus usually a good idea\n        to either avoid manipulating the GUI directly, or call macros\n        because Qtmacs will always run the event loop in between any\n        two macros.\n\n        .. note: the slots are executed in the order in which they\n          were registered via ``qteConnectHook``, but there is no\n          guarantee that this is really so. However, it is guaranteed\n          that all slots will be triggered, even if some raise an error\n          during the execution.\n\n        |Args|\n\n        * ``hookName`` (**str**): the name of the hook to trigger.\n        * ``msgObj`` (**QtmacsMessage**): data passed to the function.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Shorthand.\n        reg = self._qteRegistryHooks\n\n        # Do nothing if there are not recipients for the hook.\n        if hookName not in reg:\n            return\n\n        # Create an empty ``QtmacsMessage`` object if none was provided.\n        if msgObj is None:\n            msgObj = QtmacsMessage()\n\n        # Add information about the hook that will deliver ``msgObj``.\n        msgObj.setHookName(hookName)\n\n        # Try to call each slot. Intercept any errors but ensure that\n        # really all slots are called, irrespective of how many of them\n        # raise an error during execution.\n        for fun in reg[hookName]:\n            try:\n                fun(msgObj)\n            except Exception as err:\n                # Format the error message.\n                msg = '<b>{}</b>-hook function <b>{}</b>'.format(\n                    hookName, str(fun)[1:-1])\n                msg += \" did not execute properly.\"\n                if isinstance(err, QtmacsArgumentError):\n                    msg += '<br/>' + str(err)\n\n                # Log the error.\n                self.qteLogger.exception(msg, exc_info=True, stack_info=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qteConnectHook(self, hookName: str,\n                       slot: (types.FunctionType, types.MethodType)):\n        \"\"\"\n        Connect the method or function ``slot`` to ``hookName``.\n\n        |Args|\n\n        * ``hookName`` (**str**): name of the hook.\n        * ``slot`` (**function**, **method**): the routine to execute\n          when the hook triggers.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Shorthand.\n        reg = self._qteRegistryHooks\n        if hookName in reg:\n            reg[hookName].append(slot)\n        else:\n            reg[hookName] = [slot]", "response": "Connect the method or function or slot to hookName."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisconnecting a slot from a hook.", "response": "def qteDisconnectHook(self, hookName: str,\n                          slot: (types.FunctionType, types.MethodType)):\n        \"\"\"\n        Disconnect ``slot`` from ``hookName``.\n\n        If ``hookName`` does not exist, or ``slot`` is not connected\n        to ``hookName`` then return **False**, otherwise disassociate\n        ``slot`` with ``hookName`` and return **True**.\n\n        |Args|\n\n        * ``hookName`` (**str**): name of the hook.\n        * ``slot`` (**function**, **method**): the routine to\n          execute when the hook triggers.\n\n        |Returns|\n\n        * **bool**: **True** if ``slot`` was disconnected from ``hookName``,\n          and **False** in all other cases.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Shorthand.\n        reg = self._qteRegistryHooks\n\n        # Return immediately if no hook with that name exists.\n        if hookName not in reg:\n            msg = 'There is no hook called <b>{}</b>.'\n            self.qteLogger.info(msg.format(hookName))\n            return False\n\n        # Return immediately if the ``slot`` is not connected to the hook.\n        if slot not in reg[hookName]:\n            msg = 'Slot <b>{}</b> is not connected to hook <b>{}</b>.'\n            self.qteLogger.info(msg.format(str(slot)[1:-1], hookName))\n            return False\n\n        # Remove ``slot`` from the list.\n        reg[hookName].remove(slot)\n\n        # If the list is now empty, then remove it altogether.\n        if len(reg[hookName]) == 0:\n            reg.pop(hookName)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nimports the module named fileName at run - time.", "response": "def qteImportModule(self, fileName: str):\n        \"\"\"\n        Import ``fileName`` at run-time.\n\n        If ``fileName`` has no path prefix then it must be in the\n        standard Python module path. Relative path names are possible.\n\n        |Args|\n\n        * ``fileName`` (**str**): file name (with full path) of module\n          to import.\n\n        |Returns|\n\n        * **module**: the imported Python module, or **None** if an\n            error occurred.\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n        # Split the absolute file name into the path- and file name.\n        path, name = os.path.split(fileName)\n        name, ext = os.path.splitext(name)\n\n        # If the file name has a path prefix then search there, otherwise\n        # search the default paths for Python.\n        if path == '':\n            path = sys.path\n        else:\n            path = [path]\n\n        # Try to locate the module.\n        try:\n            fp, pathname, desc = imp.find_module(name, path)\n        except ImportError:\n            msg = 'Could not find module <b>{}</b>.'.format(fileName)\n            self.qteLogger.error(msg)\n            return None\n\n        # Try to import the module.\n        try:\n            mod = imp.load_module(name, fp, pathname, desc)\n            return mod\n        except ImportError:\n            msg = 'Could not import module <b>{}</b>.'.format(fileName)\n            self.qteLogger.error(msg)\n            return None\n        finally:\n            # According to the imp documentation the file pointer\n            # should always be closed explicitly.\n            if fp:\n                fp.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteMacroNameMangling(self, macroCls):\n        # Replace camel bump as hyphenated lower case string.\n        macroName = re.sub(r\"([A-Z])\", r'-\\1', macroCls.__name__)\n\n        # If the first character of the class name was a\n        # capital letter (likely) then the above substitution would have\n        # resulted in a leading hyphen. Remove it.\n        if macroName[0] == '-':\n            macroName = macroName[1:]\n\n        # Return the lower case string.\n        return macroName.lower()", "response": "Return the name mangling for the given macro class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a macro in the system.", "response": "def qteRegisterMacro(self, macroCls, replaceMacro: bool=False,\n                         macroName: str=None):\n        \"\"\"\n        Register a macro.\n\n        If ``macroName`` is **None** then its named is deduced from\n        its class name (see ``qteMacroNameMangling`` for details).\n\n        Multiple macros with the same name can co-exist as long as\n        their applet- and widget signatures, as reported by the\n        ``qteAppletSignature`` and ``qteWidgetSignature`` methods,\n        differ. If ``macroCls`` has the same name and signatures as an\n        already registered macro then the ``replaceMacro`` flag\n        decides:\n\n        * **True**: the existing macro will be replaced for all\n          applet- and widget signatures specified by the new macro\n          ``macroCls``.\n        * **False**: the ``macroCls`` will not be registered.\n\n        The method returns **None** if an error occurred (eg. the\n        macro constructor is faulty), or the macro name as a\n        string. If a macro was already registered and not replaced\n        (ie. ``replaceMacro``) then the macro name is returned\n        nonetheless.\n\n        .. note:: if an existing macro is replaced the old macro\n           is not deleted (it probably should be, though).\n\n        |Args|\n\n        * ``macroCls`` (**QtmacsMacro**): QtmacsMacro or derived\n          (not type checked!)\n        * ``replaceMacro`` (**bool**): whether or not to replace\n          an existing macro.\n        * ``macroName`` (**str**): the name under which the macro\n          should be registered.\n\n        |Returns|\n\n        **str**: the name of the just registered macro, or **None** if\n          that failed.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Check type of input arguments.\n        if not issubclass(macroCls, QtmacsMacro):\n            args = ('macroCls', 'class QtmacsMacro', inspect.stack()[0][3])\n            raise QtmacsArgumentError(*args)\n\n        # Try to instantiate the macro class.\n        try:\n            macroObj = macroCls()\n        except Exception:\n            msg = 'The macro <b>{}</b> has a faulty constructor.'\n            msg = msg.format(macroCls.__name__)\n\n            self.qteLogger.error(msg, stack_info=True)\n            return None\n\n        # The three options to determine the macro name, in order of\n        # precedence, are: passed to this function, specified in the\n        # macro constructor, name mangled.\n        if macroName is None:\n            # No macro name was passed to the function.\n            if macroObj.qteMacroName() is None:\n                # The macro has already named itself.\n                macroName = self.qteMacroNameMangling(macroCls)\n            else:\n                # The macro name is inferred from the class name.\n                macroName = macroObj.qteMacroName()\n\n        # Let the macro know under which name it is known inside Qtmacs.\n        macroObj._qteMacroName = macroName\n\n        # Ensure the macro has applet signatures.\n        if len(macroObj.qteAppletSignature()) == 0:\n            msg = 'Macro <b>{}</b> has no applet signatures.'.format(macroName)\n            self.qteLogger.error(msg, stack_info=True)\n            return None\n\n        # Ensure the macro has widget signatures.\n        if len(macroObj.qteWidgetSignature()) == 0:\n            msg = 'Macro <b>{}</b> has no widget signatures.'.format(macroName)\n            self.qteLogger.error(msg, stack_info=True)\n            return None\n\n        # Flag to indicate that at least one new macro type was\n        # registered.\n        anyRegistered = False\n\n        # Iterate over all applet signatures.\n        for app_sig in macroObj.qteAppletSignature():\n            # Iterate over all widget signatures.\n            for wid_sig in macroObj.qteWidgetSignature():\n                # Infer the macro name from the class name of the\n                # passed macro object.\n                macroNameInternal = (macroName, app_sig, wid_sig)\n\n                # If a macro with this name already exists then either\n                # replace it, or skip the registration process for the\n                # new one.\n                if macroNameInternal in self._qteRegistryMacros:\n                    if replaceMacro:\n                        # Remove existing macro.\n                        tmp = self._qteRegistryMacros.pop(macroNameInternal)\n                        msg = 'Replacing existing macro <b>{}</b> with new {}.'\n                        msg = msg.format(macroNameInternal, macroObj)\n                        self.qteLogger.info(msg)\n                        tmp.deleteLater()\n                    else:\n                        msg = 'Macro <b>{}</b> already exists (not replaced).'\n                        msg = msg.format(macroNameInternal)\n                        self.qteLogger.info(msg)\n                        # Macro was not registered for this widget\n                        # signature.\n                        continue\n\n                # Add macro object to the registry.\n                self._qteRegistryMacros[macroNameInternal] = macroObj\n                msg = ('Macro <b>{}</b> successfully registered.'\n                       .format(macroNameInternal))\n                self.qteLogger.info(msg)\n                anyRegistered = True\n\n        # Return the name of the macro, irrespective of whether or not\n        # it is a newly created macro, or if the old macro was kept\n        # (in case of a name conflict).\n        return macroName"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if a macro with the given name exists.", "response": "def qteIsMacroRegistered(self, macroName: str,\n                             widgetObj: QtGui.QWidget=None):\n        \"\"\"\n        Return **True** if a macro with name ``macroName`` exists.\n\n        If ``widgetObj`` is **None** then only the macro name is\n        matched. Otherwise, only macros that are compatible with\n        ``widgetObj`` are returned.\n\n\n        |Args|\n\n        * ``macroName`` (**str**): name of macro.\n        * ``widgetObj`` (**QWidget**): widget with which the macro\n          must be compatible.\n\n        |Returns|\n\n        * **bool**: whether or not a compatible macro exists.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        if widgetObj is None:\n            # Ignore the applet- and widget signature and simply check\n            # if a macro with the desired name exists.\n            macroList = [_ for _ in self._qteRegistryMacros\n                         if _[0] == macroName]\n            if len(macroList) > 0:\n                return True\n            else:\n                return False\n        else:\n            # Take the applet- and widget signature into account.\n            macroObj = self.qteGetMacroObject(macroName, widgetObj)\n            if macroObj is None:\n                return False\n            else:\n                return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qteGetMacroObject(self, macroName: str, widgetObj: QtGui.QWidget):\n        # Determine the applet- and widget signature. This is trivial\n        # if the widget was registered with Qtmacs because its\n        # '_qteAdmin' attribute will provide this information. If, on\n        # the other hand, the widget was not registered with Qtmacs\n        # then it has no signature, yet its parent applet must because\n        # every applet has one. The only exception when the applet\n        # signature is therefore when there are no applets to begin\n        # with, ie. the the window is empty.\n        if hasattr(widgetObj, '_qteAdmin'):\n            app_signature = widgetObj._qteAdmin.appletSignature\n            wid_signature = widgetObj._qteAdmin.widgetSignature\n\n            # Return immediately if the applet signature is None\n            # (should be impossible).\n            if app_signature is None:\n                msg = 'Applet has no signature.'\n                self.qteLogger.error(msg, stack_info=True)\n                return None\n        else:\n            wid_signature = None\n            app = qteGetAppletFromWidget(widgetObj)\n            if app is None:\n                app_signature = None\n            else:\n                app_signature = app._qteAdmin.appletSignature\n\n        # Find all macros with name 'macroName'. This will produce a list of\n        # tuples with entries (macroName, app_sig, wid_sig).\n        name_match = [m for m in self._qteRegistryMacros if m[0] == macroName]\n\n        # Find all macros with a compatible applet signature. This is\n        # produce another list of tuples with the same format as\n        # the name_match list (see above).\n        app_sig_match = [_ for _ in name_match if _[1] in (app_signature, '*')]\n\n        if wid_signature is None:\n            wid_sig_match = [_ for _ in app_sig_match if _[2] == '*']\n        else:\n            # Find all macros with a compatible widget signature. This is\n            # a list of tuples, each tuple consisting of (macroName,\n            # app_sig, wid_sig).\n            wid_sig_match = [_ for _ in app_sig_match\n                             if _[2] in (wid_signature, '*')]\n\n        # Pick a macro.\n        if len(wid_sig_match) == 0:\n            # No macro is compatible with either the applet- or widget\n            # signature.\n            return None\n        elif len(wid_sig_match) == 1:\n            match = wid_sig_match[0]\n            # Exactly one macro is compatible with either the applet-\n            # or widget signature.\n            return self._qteRegistryMacros[match]\n        else:\n            # Found multiple matches. For any given macro 'name',\n            # applet signature 'app', and widget signature 'wid' there\n            # can be at most four macros in the list: *:*:name,\n            # wid:*:name, *:app:name, and wid:app:name.\n\n            # See if there is a macro for which both the applet and\n            # widget signature match.\n            tmp = [match for match in wid_sig_match if (match[1] != '*')\n                   and (match[2] != '*')]\n            if len(tmp) > 0:\n                match = tmp[0]\n                return self._qteRegistryMacros[match]\n\n            # See if there is a macro with a matching widget signature.\n            tmp = [match for match in wid_sig_match if match[2] != '*']\n            if len(tmp) > 0:\n                match = tmp[0]\n                return self._qteRegistryMacros[match]\n\n            # See if there is a macro with a matching applet signature.\n            tmp = [match for match in wid_sig_match if match[1] != '*']\n            if len(tmp) > 0:\n                match = tmp[0]\n                return self._qteRegistryMacros[match]\n\n            # At this point only one possibility is left, namely a\n            # generic macro that is applicable to arbitrary applets\n            # and widgets, eg. NextApplet.\n            tmp = [match for match in wid_sig_match if (match[1] == '*')\n                   and (match[2] == '*')]\n            if len(tmp) > 0:\n                match = tmp[0]\n                return self._qteRegistryMacros[match]\n\n            # This should be impossible.\n            msg = 'No compatible macro found - should be impossible.'\n            self.qteLogger.error(msg, stack_info=True)", "response": "Return the object that matches the given macroName and widgetObj."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all the macro names known to Qtmacs as a list.", "response": "def qteGetAllMacroNames(self, widgetObj: QtGui.QWidget=None):\n        \"\"\"\n        Return all macro names known to Qtmacs as a list.\n\n        If ``widgetObj`` is **None** then the names of all registered\n        macros are returned as a tuple. Otherwise, only those macro\n        compatible with ``widgetObj`` are returned. See\n        ``qteGetMacroObject`` for the definition of a compatible\n        macro.\n\n        |Args|\n\n        * ``widgetObj`` (**QWidget**): widget with which the macros\n          must be compatible.\n\n        |Returns|\n\n        * **tuple**: tuple of macro names.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # The keys of qteRegistryMacros are (macroObj, app_sig,\n        # wid_sig) tuples. Get them, extract the macro names, and\n        # remove all duplicates.\n        macro_list = tuple(self._qteRegistryMacros.keys())\n        macro_list = [_[0] for _ in macro_list]\n        macro_list = tuple(set(macro_list))\n\n        # If no widget object was supplied then omit the signature\n        # check and return the macro list verbatim.\n        if widgetObj is None:\n            return macro_list\n        else:\n            # Use qteGetMacroObject to compile a list of macros that\n            # are compatible with widgetObj. This list contains\n            # (macroObj, macroName, app_sig, wid_sig) tuples.\n            macro_list = [self.qteGetMacroObject(macroName, widgetObj)\n                          for macroName in macro_list]\n\n            # Remove all elements where macroObj=None. This is the\n            # case if no compatible macro with the specified name\n            # could be found for widgetObj.\n            macro_list = [_.qteMacroName() for _ in macro_list\n                          if _ is not None]\n            return macro_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteBindKeyGlobal(self, keysequence, macroName: str):\n        # Convert the key sequence into a QtmacsKeysequence object, or\n        # raise an QtmacsOtherError if the conversion is impossible.\n        keysequence = QtmacsKeysequence(keysequence)\n\n        # Sanity check: the macro must have been registered\n        # beforehand.\n        if not self.qteIsMacroRegistered(macroName):\n            msg = 'Cannot globally bind key to unknown macro <b>{}</b>.'\n            msg = msg.format(macroName)\n            self.qteLogger.error(msg, stack_info=True)\n            return False\n\n        # Insert/overwrite the key sequence and associate it with the\n        # new macro.\n        self._qteGlobalKeyMap.qteInsertKey(keysequence, macroName)\n\n        # Now update the local key map of every applet. Note that\n        # globally bound macros apply to every applet (hence the loop\n        # below) and every widget therein (hence the \"*\" parameter for\n        # the widget signature).\n        for app in self._qteAppletList:\n            self.qteBindKeyApplet(keysequence, macroName, app)\n        return True", "response": "Bind a keysequence to a global keymap."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteBindKeyApplet(self, keysequence, macroName: str,\n                         appletObj: QtmacsApplet):\n        \"\"\"\n        Bind ``macroName`` to all widgets in ``appletObj``.\n\n        This method does not affect the key bindings of other applets,\n        or other instances of the same applet.\n\n        The ``keysequence`` can be specified either as a string (eg\n        '<ctrl>+x <ctrl>+f'), or a list of tuples containing the\n        constants from the ``QtCore.Qt`` name space\n        (eg. [(ControlModifier, Key_X), (ControlModifier, Key_F)]), or\n        as a ``QtmacsKeysequence`` object.\n\n        |Args|\n\n        * ``keysequence`` (**str**, **list** of **tuples**,\n          **QtmacsKeysequence**):\n          key sequence to activate ``macroName`` for specified\n          ``widgetSignature``.\n        * ``macroName`` (**str**): the macro to associated with\n          ``keysequence``.\n        * ``appletObj`` (**QtmacsApplet**): only widgets in this\n          applet are affected.\n\n        |Returns|\n\n        * **bool**: whether or not at least one widget was\n          successfully bound.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        * **QtmacsKeysequenceError** if the provided ``keysequence``\n          could not be parsed.\n        \"\"\"\n        # Convert the key sequence into a QtmacsKeysequence object, or\n        # raise a QtmacsKeysequenceError if the conversion is\n        # impossible.\n        keysequence = QtmacsKeysequence(keysequence)\n\n        # Verify that Qtmacs knows a macro named 'macroName'.\n        if not self.qteIsMacroRegistered(macroName):\n            msg = ('Cannot bind key because the macro <b>{}</b> does'\n                   'not exist.'.format(macroName))\n            self.qteLogger.error(msg, stack_info=True)\n            return False\n\n        # Bind the key also to the applet itself because it can\n        # receive keyboard events (eg. when it is empty).\n        appletObj._qteAdmin.keyMap.qteInsertKey(keysequence, macroName)\n\n        # Update the key map of every widget inside the applet.\n        for wid in appletObj._qteAdmin.widgetList:\n            self.qteBindKeyWidget(keysequence, macroName, wid)\n        return True", "response": "Bind a keysequence to all widgets in appletObj."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbinds a keysequence to widgetObj and associate it with macroName.", "response": "def qteBindKeyWidget(self, keysequence, macroName: str,\n                         widgetObj: QtGui.QWidget):\n        \"\"\"\n        Bind ``macroName`` to ``widgetObj`` and associate it with\n        ``keysequence``.\n\n        This method does not affect the key bindings of other applets\n        and/or widgets and can be used to individualise the key\n        bindings inside every applet instance and every widget inside\n        that instance. Even multiple instances of the same applet type\n        (eg. multiple text buffers) can all have individual key\n        bindings.\n\n        The ``keysequence`` can be specified either as a string (eg\n        '<ctrl>+x <ctrl>+f'), or a list of tuples containing the\n        constants from the ``QtCore.Qt`` name space\n        (eg. [(ControlModifier, Key_X), (ControlModifier, Key_F)]), or\n        as a ``QtmacsKeysequence`` object.\n\n        |Args|\n\n        * ``keysequence`` (**str**, **list** of **tuples**,\n          **QtmacsKeysequence**):\n          key sequence to activate ``macroName`` for specified\n          ``widgetSignature``.\n        * ``macroName`` (**str**): the macro to associated with\n          ``keysequence``.\n        * ``widgetObj`` (**QWidget**): determines which widgets\n          signature to use.\n\n        |Returns|\n\n        * **bool**: whether or not at least one widget was\n            successfully bound.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        * **QtmacsKeysequenceError** if the provided ``keysequence``\n          could not be parsed.\n        * **QtmacsOtherError** if ``widgetObj`` was not added with\n          ``qteAddWidget``.\n        \"\"\"\n        # Convert the key sequence into a QtmacsKeysequence object, or\n        # raise an QtmacsKeysequenceError if the conversion is\n        # impossible.\n        keysequence = QtmacsKeysequence(keysequence)\n\n        # Check type of input arguments.\n        if not hasattr(widgetObj, '_qteAdmin'):\n            msg = '<widgetObj> was probably not added with <qteAddWidget>'\n            msg += ' method because it lacks the <_qteAdmin> attribute.'\n            raise QtmacsOtherError(msg)\n\n        # Verify that Qtmacs knows a macro named 'macroName'.\n        if not self.qteIsMacroRegistered(macroName):\n            msg = ('Cannot bind key to unknown macro <b>{}</b>.'\n                   .format(macroName))\n            self.qteLogger.error(msg, stack_info=True)\n            return False\n\n        # Associate 'keysequence' with 'macroName' for 'widgetObj'.\n        try:\n            widgetObj._qteAdmin.keyMap.qteInsertKey(keysequence, macroName)\n        except AttributeError:\n            msg = 'Received an invalid macro object.'\n            self.qteLogger.error(msg, stack_info=True)\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qteUnbindKeyApplet(self, applet: (QtmacsApplet, str), keysequence):\n        # If ``applet`` was specified by its ID (ie. a string) then\n        # fetch the associated ``QtmacsApplet`` instance. If\n        # ``applet`` is already an instance of ``QtmacsApplet`` then\n        # use it directly.\n        if isinstance(applet, str):\n            appletObj = self.qteGetAppletHandle(applet)\n        else:\n            appletObj = applet\n\n        # Return immediately if the appletObj is invalid.\n        if appletObj is None:\n            return\n\n        # Convert the key sequence into a QtmacsKeysequence object, or\n        # raise a QtmacsKeysequenceError if the conversion is\n        # impossible.\n        keysequence = QtmacsKeysequence(keysequence)\n\n        # Remove the key sequence from the applet window itself.\n        appletObj._qteAdmin.keyMap.qteRemoveKey(keysequence)\n\n        for wid in appletObj._qteAdmin.widgetList:\n            self.qteUnbindKeyFromWidgetObject(keysequence, wid)", "response": "Remove keybindings from all widgets inside applet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the macro triggered by keysequence from the given widgetObj.", "response": "def qteUnbindKeyFromWidgetObject(self, keysequence,\n                                     widgetObj: QtGui.QWidget):\n        \"\"\"\n        Disassociate the macro triggered by ``keysequence`` from\n        ``widgetObj``.\n\n        The ``keysequence`` can be specified either as a string (eg\n        '<ctrl>+x <ctrl>+f'), or a list of tuples containing the\n        constants from the ``QtCore.Qt`` name space\n        (eg. [(ControlModifier, Key_X), (ControlModifier, Key_F)]), or\n        as a ``QtmacsKeysequence`` object.\n\n        This method does not affect the key bindings of other applets.\n\n        |Args|\n\n        * ``keysequence`` (**str**, **list** of **tuples**,\n          **QtmacsKeysequence**):\n          key sequence to activate ``macroName`` for specified\n          ``widgetSignature``.\n        * ``widgetObj`` (**QWidget**): determines which widgets\n          signature to use.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        * **QtmacsKeysequenceError** if the provided ``keysequence``\n          could not be parsed.\n        * **QtmacsOtherError** if ``widgetObj`` was not added with\n          ``qteAddWidget``.\n        \"\"\"\n        # Convert the key sequence into a QtmacsKeysequence object, or\n        # raise an QtmacsKeysequenceError if the conversion is\n        # impossible.\n        keysequence = QtmacsKeysequence(keysequence)\n\n        # Check type of input arguments.\n        if not hasattr(widgetObj, '_qteAdmin'):\n            msg = '<widgetObj> was probably not added with <qteAddWidget>'\n            msg += ' method because it lacks the <_qteAdmin> attribute.'\n            raise QtmacsOtherError(msg)\n\n        # Remove the key sequence from the local key maps.\n        widgetObj._qteAdmin.keyMap.qteRemoveKey(keysequence)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qteUnbindAllFromApplet(self, applet: (QtmacsApplet, str)):\n        # If ``applet`` was specified by its ID (ie. a string) then\n        # fetch the associated ``QtmacsApplet`` instance. If\n        # ``applet`` is already an instance of ``QtmacsApplet`` then\n        # use it directly.\n        if isinstance(applet, str):\n            appletObj = self.qteGetAppletHandle(applet)\n        else:\n            appletObj = applet\n\n        # Return immediately if the appletObj is invalid.\n        if appletObj is None:\n            return\n\n        # Remove the key sequence from the applet window itself.\n        appletObj._qteAdmin.keyMap = self.qteCopyGlobalKeyMap()\n\n        # Restore the global key-map for every widget.\n        for wid in appletObj._qteAdmin.widgetList:\n            wid._qteAdmin.keyMap = self.qteCopyGlobalKeyMap()", "response": "Unbind all widgets from applet to applet s internal key - map."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nunbinds all keys from the given widgetObj.", "response": "def qteUnbindAllFromWidgetObject(self, widgetObj: QtGui.QWidget):\n        \"\"\"\n        Reset the local key-map of ``widgetObj`` to the current global\n        key-map.\n\n        |Args|\n\n        * ``widgetObj`` (**QWidget**): determines which widgets\n          signature to use.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        * **QtmacsOtherError** if ``widgetObj`` was not added with\n          ``qteAddWidget``.\n        \"\"\"\n        # Check type of input arguments.\n        if not hasattr(widgetObj, '_qteAdmin'):\n            msg = '<widgetObj> was probably not added with <qteAddWidget>'\n            msg += ' method because it lacks the <_qteAdmin> attribute.'\n            raise QtmacsOtherError(msg)\n\n        # Install the global key-map for this widget.\n        widgetObj._qteAdmin.keyMap = self.qteCopyGlobalKeyMap()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qteRegisterApplet(self, cls, replaceApplet: bool=False):\n        # Check type of input arguments.\n        if not issubclass(cls, QtmacsApplet):\n            args = ('cls', 'class QtmacsApplet', inspect.stack()[0][3])\n            raise QtmacsArgumentError(*args)\n\n        # Extract the class name as string, because this is the name\n        # under which the applet will be known.\n        class_name = cls.__name__\n\n        # Issue a warning if an applet with this name already exists.\n        if class_name in self._qteRegistryApplets:\n            msg = 'The original applet <b>{}</b>'.format(class_name)\n            if replaceApplet:\n                msg += ' was redefined.'\n                self.qteLogger.warning(msg)\n            else:\n                msg += ' was not redefined.'\n                self.qteLogger.warning(msg)\n                return class_name\n\n        # Execute the classmethod __qteRegisterAppletInit__ to\n        # allow the applet to make global initialisations that do\n        # not depend on a particular instance, eg. the supported\n        # file types.\n        cls.__qteRegisterAppletInit__()\n\n        # Add the class (not instance!) to the applet registry.\n        self._qteRegistryApplets[class_name] = cls\n        self.qteLogger.info('Applet <b>{}</b> now registered.'\n                            .format(class_name))\n        return class_name", "response": "Register a applet class as an applet."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a handle to applet with ID appletID.", "response": "def qteGetAppletHandle(self, appletID: str):\n        \"\"\"\n        Return a handle to ``appletID``.\n\n        If no applet with ID ``appletID`` exists then **None** is\n        returned.\n\n        |Args|\n\n        * ``appletID`` (**str**): ID of applet.\n\n        |Returns|\n\n        * **QtmacsApplet**: handle to applet with ID ``appletID``.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Compile list of applet Ids.\n        id_list = [_.qteAppletID() for _ in self._qteAppletList]\n\n        # If one of the applets has ``appletID`` then return a\n        # reference to it.\n        if appletID in id_list:\n            idx = id_list.index(appletID)\n            return self._qteAppletList[idx]\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qteMakeAppletActive(self, applet: (QtmacsApplet, str)):\n        # If ``applet`` was specified by its ID (ie. a string) then\n        # fetch the associated ``QtmacsApplet`` instance. If\n        # ``applet`` is already an instance of ``QtmacsApplet`` then\n        # use it directly.\n        if isinstance(applet, str):\n            appletObj = self.qteGetAppletHandle(applet)\n        else:\n            appletObj = applet\n\n        # Sanity check: return if the applet does not exist.\n        if appletObj not in self._qteAppletList:\n            return False\n\n        # If ``appletObj`` is a mini applet then double check that it\n        # is actually installed and visible. If it is a conventional\n        # applet then insert it into the layout.\n        if self.qteIsMiniApplet(appletObj):\n            if appletObj is not self._qteMiniApplet:\n                self.qteLogger.warning('Wrong mini applet. Not activated.')\n                print(appletObj)\n                print(self._qteMiniApplet)\n                return False\n            if not appletObj.qteIsVisible():\n                appletObj.show(True)\n        else:\n            if not appletObj.qteIsVisible():\n                # Add the applet to the layout by replacing the\n                # currently active applet.\n                self.qteReplaceAppletInLayout(appletObj)\n\n        # Update the qteActiveApplet pointer. Note that the actual\n        # focusing is done exclusively in the focus manager.\n        self._qteActiveApplet = appletObj\n        return True", "response": "Make applet active and give it the focus."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qteCloseQtmacs(self):\n        # Announce the shutdown.\n        msgObj = QtmacsMessage()\n        msgObj.setSignalName('qtesigCloseQtmacs')\n        self.qtesigCloseQtmacs.emit(msgObj)\n\n        # Kill all applets and update the GUI.\n        for appName in self.qteGetAllAppletIDs():\n            self.qteKillApplet(appName)\n        self._qteFocusManager()\n\n        # Kill all windows and update the GUI.\n        for window in self._qteWindowList:\n            window.close()\n        self._qteFocusManager()\n\n        # Schedule QtmacsMain for deletion.\n        self.deleteLater()", "response": "Close all Qtmacs and all windows."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qteDefVar(self, varName: str, value, module=None, doc: str=None):\n        # Use the global name space per default.\n        if module is None:\n            module = qte_global\n\n        # Create the documentation dictionary if it does not exist\n        # already.\n        if not hasattr(module, '_qte__variable__docstring__dictionary__'):\n            module._qte__variable__docstring__dictionary__ = {}\n\n        # Set the variable value and documentation string.\n        setattr(module, varName, value)\n        module._qte__variable__docstring__dictionary__[varName] = doc\n        return True", "response": "Define and document a variable in an arbitrary name space."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qteGetVariableDoc(self, varName: str, module=None):\n        # Use the global name space per default.\n        if module is None:\n            module = qte_global\n\n        # No documentation for the variable can exists if the doc\n        # string dictionary is undefined.\n        if not hasattr(module, '_qte__variable__docstring__dictionary__'):\n            return None\n\n        # If the variable is undefined then return **None**.\n        if varName not in module._qte__variable__docstring__dictionary__:\n            return None\n\n        # Return the requested value.\n        return module._qte__variable__docstring__dictionary__[varName]", "response": "Return the documentation string for varName defined in module."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nemulates the key presses that define keysequence.", "response": "def qteEmulateKeypresses(self, keysequence):\n        \"\"\"\n        Emulate the Qt key presses that define ``keysequence``.\n\n        The method will put the keys into a queue and process them one\n        by one once the event loop is idle, ie. the event loop\n        executes all signals and macros associated with the emulated\n        key press first before the next one is emulated.\n\n        |Args|\n\n        * ``keysequence`` (**QtmacsKeysequence**): the key sequence to\n          emulate.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Convert the key sequence into a QtmacsKeysequence object, or\n        # raise an QtmacsOtherError if the conversion is impossible.\n        keysequence = QtmacsKeysequence(keysequence)\n        key_list = keysequence.toQKeyEventList()\n\n        # Do nothing if the key list is empty.\n        if len(key_list) > 0:\n            # Add the keys to the queue which the event timer will\n            # process.\n            for event in key_list:\n                self._qteKeyEmulationQueue.append(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts local datetime and datetime without timezone information to UTC datetime with timezone information.", "response": "def utc_datetime(dt=None, local_value=True):\n\t\"\"\" Convert local datetime and/or datetime without timezone information to UTC datetime with timezone\n\tinformation.\n\n\t:param dt: local datetime to convert. If is None, then system datetime value is used\n\t:param local_value: whether dt is a datetime in system timezone or UTC datetime without timezone information\n\t:return: datetime in UTC with tz set\n\t\"\"\"\n\t# TODO: rename local_value to local_tz or in_local_tz\n\tif dt is None:\n\t\treturn datetime.now(tz=timezone.utc)\n\n\tresult = dt\n\tif result.utcoffset() is None:\n\t\tif local_value is False:\n\t\t\treturn result.replace(tzinfo=timezone.utc)\n\t\telse:\n\t\t\tresult = result.replace(tzinfo=local_tz())\n\n\treturn result.astimezone(timezone.utc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts UTC datetime and or datetime without timezone information to local datetime with timezone information.", "response": "def local_datetime(dt=None, utc_value=True):\n\t\"\"\" Convert UTC datetime and/or datetime without timezone information to local datetime with timezone\n\tinformation\n\n\t:param dt: datetime in UTC to convert. If is None, then system datetime value is used\n\t:param utc_value: whether dt is a datetime in UTC or in system timezone without timezone information\n\t:return: datetime for system (local) timezone with tz set\n\t\"\"\"\n\t# TODO: rename utc_value to utc_tz or in_utc_tz\n\tif dt is None:\n\t\treturn datetime.now(tz=local_tz())\n\n\tresult = dt\n\tif result.utcoffset() is None:\n\t\tif utc_value is False:\n\t\t\treturn result.replace(tzinfo=local_tz())\n\t\telse:\n\t\t\tresult = result.replace(tzinfo=timezone.utc)\n\n\treturn result.astimezone(local_tz())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_property(self, property_name):\n        if property_name in self.properties:\n            return True\n        elif property_name in self.entities:\n            return True\n        elif property_name in self.collections:\n            return True\n        else:\n            return False", "response": "Check if schema has property with given name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_state_validator(self, validator):\n        if not isinstance(validator, AbstractValidator):\n            err = '{} is not a subclass of {}'\n            raise InvalidValidator(err.format(validator, AbstractValidator))\n\n        if validator not in self.state:\n            self.state.append(validator)", "response": "Add a state validator to the list of state validators."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a simple property to the schema.", "response": "def add_property(self, property_name, use_context=True):\n        \"\"\"\n        Add simple property to schema\n        :param property_name: str, property name\n        :param use_context: bool, whether custom context should be used\n        :return: shiftschema.property.SimpleProperty\n        \"\"\"\n        if self.has_property(property_name):\n            err = 'Property \"{}\" already exists'\n            raise PropertyExists(err.format(property_name))\n\n        prop = SimpleProperty(use_context=bool(use_context))\n        self.properties[property_name] = prop\n        return prop"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd entity property to schema", "response": "def add_entity(self, property_name, use_context=True):\n        \"\"\"\n        Add entity property to schema\n        :param property_name: str, property name\n        :param use_context: bool, whether custom context should be used\n        :return: shiftschema.property.EntityProperty\n        \"\"\"\n        if self.has_property(property_name):\n            err = 'Property \"{}\" already exists'\n            raise PropertyExists(err.format(property_name))\n        prop = EntityProperty(use_context=bool(use_context))\n        self.entities[property_name] = prop\n        return prop"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_collection(self, property_name, use_context=True):\n        if self.has_property(property_name):\n            err = 'Property \"{}\" already exists'\n            raise PropertyExists(err.format(property_name))\n\n        prop = CollectionProperty(use_context=bool(use_context))\n        self.collections[property_name] = prop\n        return prop", "response": "Add a collection property to schema\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget property from model. Use getter if possible.", "response": "def get(self, model, property_name):\n        \"\"\"\n        Get property from model. Use getter if possible.\n        :param model: model or dict\n        :param property_name: str, name on the model\n        :return: mixed\n        \"\"\"\n        if type(model) is dict:\n            if property_name not in model:\n                return None\n            else:\n                return model[property_name]\n        elif hasattr(model, 'get_' + property_name):\n            getter = getattr(model, 'get_' + property_name)\n            return getter()\n        else:\n            try:\n                return getattr(model, property_name)\n            except AttributeError:\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set(self, model, property_name, value):\n        if type(model) is dict:\n            model[property_name] = value\n        elif hasattr(model, 'set_' + property_name):\n            setter = getattr(model, 'set_' + property_name)\n            setter(value)\n        else:\n            try:\n                setattr(model, property_name, value)\n            except AttributeError:\n                pass", "response": "Set the value of the specified property in the specified model. Use setter if possible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform validation and filtering at the same time return a validation result object.", "response": "def process(self, model=None, context=None):\n        \"\"\"\n        Perform validation and filtering at the same time, return a\n        validation result object.\n\n        :param model: object or dict\n        :param context: object, dict or None\n        :return: shiftschema.result.Result\n        \"\"\"\n        self.filter(model, context)\n        return self.validate(model, context)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filter(self, model=None, context=None):\n        if model is None:\n            return\n\n        # properties\n        self.filter_properties(model, context=context)\n\n        # entities\n        self.filter_entities(model, context=context)\n\n        # collections\n        self.filter_collections(model, context=context)", "response": "Perform filtering on the model. Will change model in place."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering simple properties based on their value.", "response": "def filter_properties(self, model, context=None):\n        \"\"\"\n        Filter simple properties\n        Runs filters on simple properties changing them in place.\n        :param model:  object or dict\n        :param context: object, dict or None\n        :return: None\n        \"\"\"\n        if model is None:\n            return\n\n        for property_name in self.properties:\n            prop = self.properties[property_name]\n            value = self.get(model, property_name)\n            if value is None:\n                continue\n\n            filtered_value = prop.filter(\n                value=value,\n                model=model,\n                context=context\n            )\n            if value != filtered_value:  # unless changed!\n                self.set(model, property_name, filtered_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters the entity properties of the given model.", "response": "def filter_entities(self, model, context=None):\n        \"\"\"\n        Filter entities\n        Runs filters on entity properties changing them in place.\n        :param model:  object or dict\n        :param context: object, dict or None\n        :return: None\n        \"\"\"\n        if model is None:\n            return\n\n        for property_name in self.entities:\n            prop = self.entities[property_name]\n            value = self.get(model, property_name)\n\n            filtered_value = prop.filter(\n                value=value,\n                model=model,\n                context=context\n            )\n            if value != filtered_value:  # unless changed!\n                self.set(model, property_name, filtered_value)\n\n            prop.filter_with_schema(\n                model=value,\n                context=context\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfiltering collections with schema", "response": "def filter_collections(self, model, context=None):\n        \"\"\"\n        Filter collections\n        Runs filters on collection properties changing them in place.\n        :param model:  object or dict\n        :param context: object, dict or None\n        :return: None\n        \"\"\"\n        if model is None:\n            return\n\n        for property_name in self.collections:\n            prop = self.collections[property_name]\n            collection = self.get(model, property_name)\n            filtered_value = prop.filter(\n                value=collection,\n                model=model,\n                context=context\n            )\n            self.set(model, property_name, filtered_value)\n\n            prop.filter_with_schema(\n                collection,\n                context if prop.use_context else None\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate(self, model=None, context=None):\n\n        # inject with settings\n        result = Result(translator=self.translator, locale=self.locale)\n\n        # validate state\n        state_result = self.validate_state(model, context=context)\n        result.merge(state_result)\n\n        # validate simple properties\n        props_result = self.validate_properties(model, context=context)\n        result.merge(props_result)\n\n        # validate nested entity properties\n        entities_result = self.validate_entities(model, context=context)\n        result.merge(entities_result)\n\n        # validate collection properties\n        collections_result = self.validate_collections(model, context=context)\n        result.merge(collections_result)\n\n        # and return\n        return result", "response": "Validate model and return validation result object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates model state and return and result object.", "response": "def validate_state(self, model, context=None):\n        \"\"\"\n        Validate model state\n        Run state validators and return and result object.\n        :param model:  object or dict\n        :param context: object, dict or None\n        :return: shiftschema.result.Result\n        \"\"\"\n        result = Result()\n        for state_validator in self.state:\n            error = state_validator.run(\n                value=model,\n                model=model,\n                context=context\n            )\n            if error:\n                result.add_state_errors(error)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating simple properties and return a result object.", "response": "def validate_properties(self, model, context=None):\n        \"\"\"\n        Validate simple properties\n        Performs validation on simple properties to return a result object.\n        :param model:  object or dict\n        :param context: object, dict or None\n        :return: shiftschema.result.Result\n        \"\"\"\n        result = Result()\n        for property_name in self.properties:\n            prop = self.properties[property_name]\n            value = self.get(model, property_name)\n            errors = prop.validate(\n                value=value,\n                model=model,\n                context=context\n            )\n\n            if errors:\n                result.add_errors(\n                    errors=errors,\n                    property_name=property_name\n                )\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_entities(self, model, context=None):\n        result = Result()\n        for property_name in self.entities:\n            prop = self.entities[property_name]\n            value = self.get(model, property_name)\n\n            errors = prop.validate(\n                value=value,\n                model=model,\n                context=context\n            )\n            if len(errors):\n                result.add_entity_errors(\n                    property_name=property_name,\n                    direct_errors=errors\n                )\n\n            if value is None:\n                continue\n\n            schema_valid = prop.validate_with_schema(\n                model=value,\n                context=context\n            )\n            if schema_valid == False:\n                result.add_entity_errors(\n                    property_name,\n                    schema_errors=schema_valid.errors\n                )\n\n        return result", "response": "Validate entity properties and return a result object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating collection properties and return a result object.", "response": "def validate_collections(self, model, context=None):\n        \"\"\"\n        Validate collection properties\n        Performs validation on collection properties to return a result object.\n        :param model:  object or dict\n        :param context: object, dict or None\n        :return: shiftschema.result.Result\n        \"\"\"\n        result = Result()\n        for property_name in self.collections:\n            prop = self.collections[property_name]\n            collection = self.get(model, property_name)\n\n            errors = prop.validate(\n                value=collection,\n                model=model,\n                context=context\n            )\n            if len(errors):\n                result.add_collection_errors(\n                    property_name=property_name,\n                    direct_errors=errors\n                )\n\n            collection_errors = prop.validate_with_schema(\n                collection=collection,\n                context=context\n            )\n\n            result.add_collection_errors(\n                property_name=property_name,\n                collection_errors=collection_errors\n            )\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_sys_info():\n    blob = dict()\n    blob[\"OS\"] = platform.system()\n    blob[\"OS-release\"] = platform.release()\n    blob[\"Python\"] = platform.python_version()\n    return blob", "response": "Return system information as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning build and package dependencies as a dict.", "response": "def get_pkg_info(\n    package_name, additional=(\"pip\", \"flit\", \"pbr\", \"setuptools\", \"wheel\")\n):\n    \"\"\"Return build and package dependencies as a dict.\"\"\"\n    dist_index = build_dist_index(pkg_resources.working_set)\n    root = dist_index[package_name]\n    tree = construct_tree(dist_index)\n    dependencies = {pkg.name: pkg.installed_version for pkg in tree[root]}\n    # Add the initial package itself.\n    root = root.as_requirement()\n    dependencies[root.name] = root.installed_version\n    # Retrieve information on additional packages such as build tools.\n    for name in additional:\n        try:\n            pkg = dist_index[name].as_requirement()\n            dependencies[pkg.name] = pkg.installed_version\n        except KeyError:\n            continue\n    return dependencies"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints an information dict to stdout in order.", "response": "def print_info(info):\n    \"\"\"Print an information dict to stdout in order.\"\"\"\n    format_str = \"{:<%d} {:>%d}\" % (\n        max(map(len, info)),\n        max(map(len, info.values())),\n    )\n    for name in sorted(info):\n        print(format_str.format(name, info[name]))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint the formatted information to standard out.", "response": "def print_dependencies(package_name):\n    \"\"\"Print the formatted information to standard out.\"\"\"\n    info = get_sys_info()\n    print(\"\\nSystem Information\")\n    print(\"==================\")\n    print_info(info)\n\n    info = get_pkg_info(package_name)\n    print(\"\\nPackage Versions\")\n    print(\"================\")\n    print_info(info)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef repeat_read_url_request(url, headers=None, data=None, retries=2, logger=None):\r\n    '''\r\n    Allows for repeated http requests up to retries additional times\r\n    '''\r\n    if logger:\r\n        logger.debug(\"Retrieving url content: {}\".format(url))\r\n    req = urllib2.Request(url, data, headers=headers or {})\r\n    return repeat_call(lambda: urllib2.urlopen(req).read(), retries)", "response": "Allows for repeated http requests up to retries additional times"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef repeat_read_json_url_request(url, headers=None, data=None, retries=2, logger=None):\r\n    '''\r\n    Allows for repeated http requests up to retries additional times with convienence\r\n    wrapper on jsonization of response\r\n    '''\r\n    if logger:\r\n        logger.debug(\"Retrieving url json content: {}\".format(url))\r\n    req = urllib2.Request(url, data=data, headers=headers or {})\r\n    return repeat_call(lambda: json.loads(urllib2.urlopen(req).read()), retries)", "response": "This function is used to repeat a json request on a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the data to the object.", "response": "def _save(self, data):\n        \"\"\"\n        Take the data from a dict and commit them to appropriate attributes.\n        \"\"\"\n        self.name = data.get('name')\n        self.type = data.get('type')\n        self.state = data.get('state')\n        self.dataset = data.get('dataset')\n        self.memory = data.get('memory')\n        self.disk = data.get('disk')\n        self._ips = data.get('ips', [])\n        self.metadata = data.get('metadata', {})\n        if not hasattr(self, '_credentials'):\n            self._credentials = {}\n        self._credentials.update(self.metadata.pop('credentials', {}))\n        self.boot_script = self.metadata.pop('user-script', None)\n        self.created = dt_time(data.get('created'))\n        self.updated = dt_time(data.get('updated', data.get('created')))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrefreshing the state of the object.", "response": "def refresh(self, credentials=False):\n        \"\"\"\n        ::\n        \n            GET /:login/machines/:id\n        \n        :param credentials: whether to return machine passwords\n        :type credentials: :py:class:`bool`\n        \n        Fetch the existing state and values for the \n        :py:class:`smartdc.machine.Machine` from the datacenter and commit the \n        values locally.\n        \"\"\"\n        data = self.datacenter.raw_machine_data(self.id, \n                credentials=credentials)\n        self._save(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef credentials(self):\n        if not self._credentials:\n            self.refresh(credentials=True)\n        return self._credentials", "response": "Returns the known login - password pairs for the machine."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self):\n        action = {'action': 'stop'}\n        j, r = self.datacenter.request('POST', self.path, params=action)\n        r.raise_for_status()", "response": "Stop the remote machine."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self):\n        j, r = self.datacenter.request('DELETE', self.path)\n        r.raise_for_status()", "response": "Delete a stopped remote machine."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef poll_while(self, state, interval=2):\n        while self.status() == state:\n            time.sleep(interval)", "response": "This method is used to poll the current state of the object remotely until the state changes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the metadata for the specified machine.", "response": "def get_metadata(self):\n        \"\"\"\n        ::\n        \n            GET /:login/machines/:id/metadata\n        \n        :Returns: machine metadata\n        :rtype: :py:class:`dict`\n        \n        Fetch and return the metadata dict for the machine. The method \n        refreshes the locally cached copy of the metadata kept in the \n        :py:attr:`metadata` attribute and returns it.\n        \"\"\"\n        j, _ = self.datacenter.request('GET', self.path + '/metadata')\n        self.metadata = j\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the metadata dictionary for the current machine.", "response": "def update_metadata(self, **kwargs):\n        \"\"\"\n        ::\n        \n            POST /:login/machines/:id/metadata\n        \n        :Returns: current metadata\n        :rtype: :py:class:`dict`\n        \n        Send an metadata dict update for the machine (following dict.update() \n        semantics) using the keys and values passed in the keyword arguments. \n        The method also refreshes the locally cached copy of the metadata kept \n        in the :py:attr:`metadata` attribute and returns it.\n        \"\"\"\n        j, _ = self.datacenter.request('POST', self.path + '/metadata', \n                    data=kwargs)\n        self.metadata = j\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_metadata_at_key(self, key):\n        j, r = self.datacenter.request('DELETE', self.path + '/metadata/' + \n                    key)\n        r.raise_for_status()\n        return self.get_metadata()", "response": "Delete the metadata at the given key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the boot script for the machine.", "response": "def set_boot_script(self, filename):\n        \"\"\"\n        ::\n        \n            POST /:login/machines/:id/metadata\n        \n        :param filename: file path to the script to be uploaded and executed\n            at boot on the machine\n        :type filename: :py:class:`basestring`\n        \n        Replace the existing boot script for the machine with the data in the \n        named file.\n\n        .. Note:: The SMF service that runs the boot script will kill processes\n           that exceed 60 seconds execution time, so this is not necessarily \n           the best vehicle for long ``pkgin`` installations, for example.\n        \"\"\"\n        data = {}\n        with open(filename) as f:\n            data['user-script'] = f.read()\n        j, r = self.datacenter.request('POST', self.path + '/metadata', \n                    data=data)\n        r.raise_for_status()\n        self.boot_script = data['user-script']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the boot script on the machine.", "response": "def delete_boot_script(self):\n        \"\"\"\n        ::\n        \n            DELETE /:login/machines/:id/metadata/user-script\n        \n        Deletes any existing boot script on the machine.\n        \"\"\"\n        j, r = self.datacenter.request('DELETE', self.path + \n                '/metadata/user-script')\n        r.raise_for_status()\n        self.boot_script = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a complete set of tags for this machine.", "response": "def get_tags(self):\n        \"\"\"\n        ::\n        \n            GET /:login/machines/:id/tags\n        \n        :Returns: complete set of tags for this machine\n        :rtype: :py:class:`dict` \n        \n        A local copy is not kept because these are essentially search keys.\n        \"\"\"\n        j, _ = self.datacenter.request('GET', self.path + '/tags')\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_tags(self, **kwargs):\n        j, _ = self.datacenter.request('POST', self.path + '/tags', \n            data=kwargs)\n        return j", "response": "Adds tags to the set of those products for this machine."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the value for a single tag", "response": "def get_tag(self, tag):\n        \"\"\"\n        ::\n        \n            GET /:login/machines/:id/tags/:tag\n        \n        :Returns: the value for a single tag\n        :rtype: :py:class:`basestring`\n        \"\"\"\n        headers = {'Accept': 'text/plain'}\n        j, _ = self.datacenter.request('GET', self.path + '/tags/' + tag)\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes a tag and its corresponding value on the machine.", "response": "def delete_tag(self, tag):\n        \"\"\"\n        ::\n        \n            DELETE /:login/machines/:id/tags/:tag\n        \n        Delete a tag and its corresponding value on the machine.\n        \"\"\"\n        j, r = self.datacenter.request('DELETE', self.path + '/tags/' + tag)\n        r.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete all tags on the machine.", "response": "def delete_all_tags(self):\n        \"\"\"\n        ::\n        \n            DELETE /:login/machines/:id/tags\n        \n        Delete all tags and their corresponding values on the machine.\n        \"\"\"\n        j, r = self.datacenter.request('DELETE', self.path + '/tags')\n        r.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef raw_snapshot_data(self, name):\n        j, _ = self.datacenter.request('GET', self.path + '/snapshots/' + \n                str(name))\n        return j", "response": "Get the raw data for a single snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef snapshots(self):\n        j, _ = self.datacenter.request('GET', self.path + '/snapshots')\n        return [Snapshot(machine=self, data=s) for s in j]", "response": "Gets all snapshots for the Machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_snapshot(self, name):\n        params = {'name': name}\n        j, _ = self.datacenter.request('POST', self.path + '/snapshots', \n            data=params)\n        return Snapshot(machine=self, data=j, name=name)", "response": "Creates a snapshot for this machine s current state with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart a new machine from a snapshot.", "response": "def start_from_snapshot(self, name):\n        \"\"\"\n        ::\n        \n            POST /:login/machines/:id/snapshots/:name\n        \n        :param name: identifier for snapshot\n        :type name: :py:class:`basestring`\n        \n        Start the machine from the snapshot with the given 'name'.\n        \"\"\"\n        _, r = self.datacenter.request('POST', self.path + '/snapshots/' + \n            str(name))\n        r.raise_for_status()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the data from a dict and commit them to appropriate attributes.", "response": "def _save(self, data):\n        \"\"\"\n        Take the data from a dict and commit them to appropriate attributes.\n        \"\"\"\n        self.state = data.get('state')\n        self.created = dt_time(data.get('created'))\n        self.updated = dt_time(data.get('updated'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrefresh the state of the object.", "response": "def refresh(self):\n        \"\"\"\n        ::\n        \n            GET /:login/machines/:id/snapshots/:name\n        \n        Fetch the existing state and values for the snapshot \n        and commit the values locally.\n        \"\"\"\n        data = self.machine.raw_snapshot_data(self.name)\n        self._save(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting the snapshot from the machine.", "response": "def delete(self):\n        \"\"\"\n        ::\n        \n            DELETE /:login/machines/:id/snapshots/:name\n        \n        Deletes the snapshot from the machine.\n        \"\"\"\n        _, r = self.machine.datacenter.request('DELETE', self.path)\n        r.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef work(self):\n        import time\n        for val in range(200):\n            time.sleep(0.1)\n            self.sigUpdate.emit(val + 1)", "response": "This function is called by the daemon to periodically trigger a signal."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef target_socket(self, config):\n\t\taddress = config[self.__target_socket_config.section][self.__target_socket_config.address_option]\n\t\tport = config.getint(self.__target_socket_config.section, self.__target_socket_config.port_option)\n\n\t\ttarget = WIPV4SocketInfo(address, port)\n\t\tif target.address() is None or target.port() is None:\n\t\t\traise ValueError('Invalid target address or port')\n\t\treturn target", "response": "meth :. WNetworkNativeTransportProto. server_socket method implementation\n\t\t"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bind_socket(self, config):\n\t\taddress = config[self.__bind_socket_config.section][self.__bind_socket_config.address_option]\n\t\tport = config.getint(self.__bind_socket_config.section, self.__bind_socket_config.port_option)\n\t\treturn WIPV4SocketInfo(address, port)", "response": "method implementation for WNetworkNativeTransportProto. bind_socket"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef client_socket(self, config):\n\t\tif self.__client_socket is None:\n\t\t\tself.__client_socket = self.create_client_socket(config)\n\t\treturn self.__client_socket", "response": "method implementation\n\t. client_socket"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef target_socket(self, config):\n\t\ttarget = WNetworkNativeTransport.target_socket(self, config)\n\t\tif isinstance(target.address(), WIPV4Address) is False:\n\t\t\traise ValueError('Invalid address for broadcast transport')\n\t\treturn target", "response": "This method overrides the method to check that the result address is IPv4 address."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates client broadcast socket = 0", "response": "def create_client_socket(self, config):\n\t\t\"\"\" Create client broadcast socket\n\n\t\t:param config: client configuration\n\t\t:return: socket.socket\n\t\t\"\"\"\n\t\tclient_socket = WUDPNetworkNativeTransport.create_client_socket(self, config)\n\t\tclient_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n\t\treturn client_socket"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates server multicast socket.", "response": "def create_server_socket(self, config):\n\t\t\"\"\" Create server multicast socket. Socket will be joined to the multicast-group (same as it is\n\t\tspecified in client configuration, same as client does)\n\n\t\t:param config: server configuration\n\t\t:return: socket.socket\n\t\t\"\"\"\n\t\tserver_socket = WUDPNetworkNativeTransport.create_server_socket(self, config)\n\n\t\tgroup = socket.inet_aton(str(self.target_socket(config).address()))\n\t\tgroup_membership = struct.pack('4sL', group, socket.INADDR_ANY)\n\t\tserver_socket.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, group_membership)\n\t\treturn server_socket"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_long_query(self, base_object_query, limit_to=100, max_calls=None,\n                       start_record=0, verbose=False):\n        \"\"\"\n        Takes a base query for all objects and recursively requests them\n\n        :param str base_object_query: the base query to be executed\n        :param int limit_to: how many rows to query for in each chunk\n        :param int max_calls: the max calls(chunks to request) None is infinite\n        :param int start_record: the first record to return from the query\n        :param bool verbose: print progress to stdout\n        :return: a list of Organization objects\n        \"\"\"\n\n        if verbose:\n            print(base_object_query)\n\n        record_index = start_record\n        result = run_object_query(self.client, base_object_query, record_index,\n                                  limit_to, verbose)\n\n        obj_search_result = (result['body'][\"ExecuteMSQLResult\"][\"ResultValue\"]\n                             [\"ObjectSearchResult\"])\n        if obj_search_result is not None:\n            search_results = obj_search_result[\"Objects\"]\n        else:\n            return []\n\n        if search_results is None:\n            return []\n\n        result_set = search_results[\"MemberSuiteObject\"]\n\n        all_objects = self.result_to_models(result)\n        call_count = 1\n        \"\"\"\n        continue to run queries as long as we\n            - don't exceed the call call_count\n            - don't see results that are less than the limited length (the end)\n        \"\"\"\n        while call_count != max_calls and len(result_set) >= limit_to:\n\n            record_index += len(result_set)  # should be `limit_to`\n            result = run_object_query(self.client, base_object_query,\n                                      record_index, limit_to, verbose)\n\n            obj_search_result = (result['body'][\"ExecuteMSQLResult\"]\n                                 [\"ResultValue\"][\"ObjectSearchResult\"])\n            if obj_search_result is not None:\n                search_results = obj_search_result[\"Objects\"]\n            else:\n                search_results = None\n\n            if search_results is None:\n                result_set = []\n            else:\n                result_set = search_results[\"MemberSuiteObject\"]\n\n            all_objects += self.result_to_models(result)\n            call_count += 1\n\n        return all_objects", "response": "Takes a base query for all objects and returns a list of Organization objects that are in the long query."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the result of the SQL to Models", "response": "def result_to_models(self, result):\n        \"\"\"\n            this is the 'transorm' part of ETL:\n            converts the result of the SQL to Models\n        \"\"\"\n        mysql_result = result['body']['ExecuteMSQLResult']\n\n        if not mysql_result['Errors']:\n            obj_result = mysql_result['ResultValue']['ObjectSearchResult']\n            if not obj_result['Objects']:\n                return []\n            objects = obj_result['Objects']['MemberSuiteObject']\n\n            model_list = []\n            for obj in objects:\n                model = self.ms_object_to_model(obj)\n                model_list.append(model)\n\n            return model_list\n\n        else:\n            raise ExecuteMSQLError(result)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef logger(self):\n        if self._experiment:\n            return logging.getLogger('.'.join([self.name, self.experiment]))\n        elif self._projectname:\n            return logging.getLogger('.'.join([self.name, self.projectname]))\n        else:\n            return logging.getLogger('.'.join([self.name]))", "response": "Returns the logger of this organizer"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(cls, args=None):\n        organizer = cls()\n        organizer.parse_args(args)\n        if not organizer.no_modification:\n            organizer.config.save()", "response": "Run the organizer from the command line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self, **kwargs):\n        ts = {}\n        ret = {}\n        info_parts = {'info', 'get-value', 'get_value'}\n        for cmd in self.commands:\n            parser_cmd = self.parser_commands.get(cmd, cmd)\n            if parser_cmd in kwargs or cmd in kwargs:\n                kws = kwargs.get(cmd, kwargs.get(parser_cmd))\n                if isinstance(kws, Namespace):\n                    kws = vars(kws)\n                func = getattr(self, cmd or 'main')\n                ret[cmd] = func(**kws)\n                if cmd not in info_parts:\n                    ts[cmd] = str(dt.datetime.now())\n        exp = self._experiment\n        project_parts = {'setup'}\n        projectname = self._projectname\n        if (projectname is not None and project_parts.intersection(ts) and\n                projectname in self.config.projects):\n            self.config.projects[projectname]['timestamps'].update(\n                {key: ts[key] for key in project_parts.intersection(ts)})\n        elif not ts:  # don't make modifications for info\n            self.no_modification = True\n        if exp is not None and exp in self.config.experiments:\n            projectname = self.projectname\n            try:\n                ts.update(self.config.projects[projectname]['timestamps'])\n            except KeyError:\n                pass\n            if not self.is_archived(exp):\n                self.config.experiments[exp]['timestamps'].update(ts)\n        return Namespace(**ret)", "response": "Start the commands of this organizer and return the corresponding namespace."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef projectname(self):\n        if self._projectname is None:\n            exps = self.config.experiments\n            if self._experiment is not None and self._experiment in exps:\n                return exps[self._experiment]['project']\n            try:\n                self._projectname = list(self.config.projects.keys())[-1]\n            except IndexError:  # no project has yet been created ever\n                raise ValueError(\n                    \"No experiment has yet been created! Please run setup \"\n                    \"before.\")\n        return self._projectname", "response": "The name of the project that is currently processed"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef experiment(self):\n        if self._experiment is None:\n            self._experiment = list(self.config.experiments.keys())[-1]\n        return self._experiment", "response": "The identifier of the experiment that is currently processed"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_app_main_kwargs(self, kwargs, keep=False):\n        if not keep:\n            return {key: kwargs.pop(key) for key in list(kwargs)\n                    if key in inspect.getargspec(self.app_main)[0]}\n        else:\n            return {key: kwargs[key] for key in list(kwargs)\n                    if key in inspect.getargspec(self.app_main)[0]}", "response": "Extract the keyword arguments for the app_main method."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the A class.", "response": "def setup(self, root_dir, projectname=None, link=False, **kwargs):\n        \"\"\"\n        Perform the initial setup for the project\n\n        Parameters\n        ----------\n        root_dir: str\n            The path to the root directory where the experiments, etc. will\n            be stored\n        projectname: str\n            The name of the project that shall be initialized at `root_dir`. A\n            new directory will be created namely\n            ``root_dir + '/' + projectname``\n        link: bool\n            If set, the source files are linked to the original ones instead\n            of copied\n\n        Other Parameters\n        ----------------\n        ``**kwargs``\n            Are passed to the :meth:`app_main` method\n        \"\"\"\n        projects = self.config.projects\n        if not projects and projectname is None:\n            projectname = self.name + '0'\n        elif projectname is None:  # try to increment a number in the last used\n            try:\n                projectname = utils.get_next_name(self.projectname)\n            except ValueError:\n                raise ValueError(\n                    \"Could not estimate a project name! Please use the \"\n                    \"projectname argument to provide a project name.\")\n        self.app_main(**kwargs)\n        root_dir = osp.abspath(osp.join(root_dir, projectname))\n        projects[projectname] = OrderedDict([\n            ('name', projectname), ('root', root_dir),\n            ('timestamps', OrderedDict())])\n        data_dir = self.config.global_config.get(\n            'data', osp.join(root_dir, 'data'))\n        projects[projectname]['data'] = data_dir\n        self.projectname = projectname\n        self.logger.info(\"Initializing project %s\", projectname)\n        self.logger.debug(\"    Creating root directory %s\", root_dir)\n        if not osp.exists(root_dir):\n            os.makedirs(root_dir)\n        return root_dir"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init(self, projectname=None, description=None, **kwargs):\n        self.app_main(**kwargs)\n        experiments = self.config.experiments\n        experiment = self._experiment\n        if experiment is None and not experiments:\n            experiment = self.name + '_exp0'\n        elif experiment is None:\n            try:\n                experiment = utils.get_next_name(self.experiment)\n            except ValueError:\n                raise ValueError(\n                    \"Could not estimate an experiment id! Please use the \"\n                    \"experiment argument to provide an id.\")\n        self.experiment = experiment\n        if self.is_archived(experiment):\n            raise ValueError(\n                \"The specified experiment has already been archived! Run \"\n                \"``%s -id %s unarchive`` first\" % (self.name, experiment))\n        if projectname is None:\n            projectname = self.projectname\n        else:\n            self.projectname = projectname\n        self.logger.info(\"Initializing experiment %s of project %s\",\n                         experiment, projectname)\n        exp_dict = experiments.setdefault(experiment, OrderedDict())\n        if description is not None:\n            exp_dict['description'] = description\n        exp_dict['project'] = projectname\n        exp_dict['expdir'] = exp_dir = osp.join('experiments', experiment)\n        exp_dir = osp.join(self.config.projects[projectname]['root'], exp_dir)\n        exp_dict['timestamps'] = OrderedDict()\n\n        if not os.path.exists(exp_dir):\n            self.logger.debug(\"    Creating experiment directory %s\", exp_dir)\n            os.makedirs(exp_dir)\n        self.fix_paths(exp_dict)\n        return exp_dict", "response": "Initialize a new object of the class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef archive(self, odir=None, aname=None, fmt=None, projectname=None,\n                experiments=None, current_project=False, no_append=False,\n                no_project_paths=False, exclude=None, keep_exp=False,\n                rm_project=False, dry_run=False, dereference=False, **kwargs):\n        \"\"\"\n        Archive one or more experiments or a project instance\n\n        This method may be used to archive experiments in order to minimize the\n        amount of necessary configuration files\n\n        Parameters\n        ----------\n        odir: str\n            The path where to store the archive\n        aname: str\n            The name of the archive (minus any format-specific extension). If\n            None, defaults to the projectname\n        fmt: { 'gztar' | 'bztar' | 'tar' | 'zip' }\n            The format of the archive. If None, it is tested whether an\n            archived with the name specified by `aname` already exists and if\n            yes, the format is inferred, otherwise ``'tar'`` is used\n        projectname: str\n            If provided, the entire project is archived\n        experiments: str\n            If provided, the given experiments are archived. Note that an error\n            is raised if they belong to multiple project instances\n        current_project: bool\n            If True, `projectname` is set to the current project\n        no_append: bool\n            It True and the archive already exists, it is deleted\n        no_project_paths: bool\n            If True, paths outside the experiment directories are neglected\n        exclude: list of str\n            Filename patterns to ignore (see :func:`glob.fnmatch.fnmatch`)\n        keep_exp: bool\n            If True, the experiment directories are not removed and no\n            modification is made in the configuration\n        rm_project: bool\n            If True, remove all the project files\n        dry_run: bool\n            If True, set, do not actually make anything\n        dereference: bool\n            If set, dereference symbolic links. Note: This is automatically set\n            for ``fmt=='zip'``\n        \"\"\"\n        fnmatch = glob.fnmatch.fnmatch\n\n        def to_exclude(fname):\n            if exclude and (fnmatch(exclude, fname) or\n                            fnmatch(exclude, osp.basename(fname))):\n                return True\n\n        def do_nothing(path, file_obj):\n            return\n\n        def tar_add(path, file_obj):\n            if sys.version_info[:2] < (3, 7):\n                file_obj.add(path, self.relpath(path), exclude=to_exclude)\n            else:\n                file_obj.add(path, self.relpath(path),\n                             filter=lambda f: None if to_exclude(f) else f)\n\n        def zip_add(path, file_obj):\n            # ziph is zipfile handle\n            for root, dirs, files in os.walk(path):\n                for f in files:\n                    abs_file = os.path.join(root, f)\n                    if not to_exclude(abs_file):\n                        file_obj.write(abs_file, self.relpath(abs_file))\n\n        self.app_main(**kwargs)\n        logger = self.logger\n        all_exps = self.config.experiments\n        if current_project or projectname is not None:\n            if current_project:\n                projectname = self.projectname\n            experiments = list(\n                self.config.experiments.project_map[projectname])\n            if not experiments:\n                raise ValueError(\n                    \"Could not find any unarchived experiment for %s\" % (\n                        projectname))\n        elif experiments is None:\n            experiments = [self.experiment]\n        already_archived = list(filter(self.is_archived, experiments))\n        if already_archived:\n            raise ValueError(\n                \"The experiments %s have already been archived or are not \"\n                \"existent!\" % ', '.join(\n                    already_archived))\n        if projectname is None:\n            projectnames = {all_exps[exp]['project'] for exp in experiments}\n            if len(projectnames) > 1:\n                raise ValueError(\n                    \"Experiments belong to multiple projects: %s\" % (\n                        ', '.join(projectnames)))\n            projectname = next(iter(projectnames))\n\n        self.projectname = projectname\n        self.experiment = experiments[-1]\n\n        exps2archive = OrderedDict(\n            (exp, all_exps[exp]) for exp in experiments)\n        project_config = self.config.projects[projectname]\n\n        ext_map, fmt_map = self._archive_extensions()\n        if aname is None:\n            aname = projectname\n        if fmt is None:\n            ext, fmt = next(\n                (t for t in fmt_map.items() if osp.exists(aname + t[0])),\n                ['.tar', 'tar'])\n        else:\n            ext = fmt_map[fmt]\n        if odir is None:\n            odir = getcwd()\n        archive_name = osp.join(odir, aname + ext)\n        exists = osp.exists(archive_name)\n        if exists and no_append:\n            logger.debug('Removing existing archive %s' % archive_name)\n            os.remove(archive_name)\n            exists = False\n        elif exists and fmt not in ['tar', 'zip']:\n            raise ValueError(\n                \"'Cannot append to %s because this is only possible for 'tar' \"\n                \"and 'zip' extension. Not %s\" % (archive_name, fmt))\n        logger.info('Archiving to %s', archive_name)\n\n        paths = self._get_all_paths(exps2archive)\n        root_dir = self.config.projects[projectname]['root']\n        check_path = partial(utils.dir_contains, root_dir)\n        not_included = OrderedDict([\n            (key, list(filterfalse(check_path, utils.safe_list(val))))\n            for key, val in paths.items()])\n\n        for key, key_paths in not_included.items():\n            for p in key_paths:\n                logger.warn(\n                    '%s for key %s lies outside the project directory and '\n                    'will not be included in the archive!', p, key)\n        modes = {'bztar': 'w:bz2', 'gztar': 'w:gz', 'tar': 'w', 'zip': 'w'}\n        mode = 'a' if exists else modes[fmt]\n        atype = 'zip' if fmt == 'zip' else 'tar'\n        if dry_run:\n            add_dir = do_nothing\n            file_obj = None\n        elif atype == 'zip':\n            import zipfile\n            add_dir = zip_add\n            file_obj = zipfile.ZipFile(archive_name, mode)\n        else:\n            import tarfile\n            add_dir = tar_add\n            file_obj = tarfile.open(archive_name, mode,\n                                    dereference=dereference)\n        for exp in experiments:\n            exp_dir = exps2archive[exp]['expdir']\n            logger.debug('Adding %s', exp_dir)\n            add_dir(exp_dir, file_obj)\n\n        now = str(dt.datetime.now())  # current time\n\n        # configuration directory\n        config_dir = osp.join(root_dir, '.project')\n        if not dry_run and not osp.exists(config_dir):\n            os.makedirs(config_dir)\n        for exp in experiments:\n            conf_file = osp.join(config_dir, exp + '.yml')\n            logger.debug('Store %s experiment config to %s', exp, conf_file)\n            if not dry_run:\n                exps2archive[exp].setdefault('timestamps', {})\n                exps2archive[exp]['timestamps']['archive'] = now\n                with open(osp.join(config_dir, exp + '.yml'), 'w') as f:\n                    ordered_yaml_dump(self.rel_paths(\n                        copy.deepcopy(exps2archive[exp])), f)\n        # project configuration file\n        conf_file = osp.join(config_dir, '.project.yml')\n        logger.debug('Store %s project config to %s', projectname, conf_file)\n        if not dry_run:\n            safe_dump(project_config, conf_file)\n\n        logger.debug('Add %s to archive', config_dir)\n        add_dir(config_dir, file_obj)\n\n        if not no_project_paths:\n            for dirname in os.listdir(root_dir):\n                if osp.basename(dirname) not in ['experiments', '.project']:\n                    logger.debug('Adding %s', osp.join(root_dir, dirname))\n                    add_dir(osp.join(root_dir, dirname), file_obj)\n        if not keep_exp:\n            for exp in experiments:\n                exp_dir = exps2archive[exp]['expdir']\n                logger.debug('Removing %s', exp_dir)\n                if not dry_run:\n                    all_exps[exp] = a = Archive(archive_name)\n                    a.project = projectname\n                    a.time = now\n                    shutil.rmtree(exp_dir)\n        if rm_project:\n            logger.debug('Removing %s', root_dir)\n            if not dry_run:\n                shutil.rmtree(root_dir)\n        if not dry_run:\n            file_obj.close()", "response": "Archive the configuration files for a specific project instance or a specific experiment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unarchive(self, experiments=None, archive=None, complete=False,\n                  project_data=False, replace_project_config=False, root=None,\n                  projectname=None, fmt=None, force=False, **kwargs):\n        \"\"\"\n        Extract archived experiments\n\n        Parameters\n        ----------\n        experiments: list of str\n            The experiments to extract. If None the current experiment is used\n        archive: str\n            The path to an archive to extract the experiments from. If None,\n            we assume that the path to the archive has been stored in the\n            configuration when using the :meth:`archive` command\n        complete: bool\n            If True, archives are extracted completely, not only the experiment\n            (implies ``project_data = True``)\n        project_data: bool\n            If True, the data for the project is extracted as well\n        replace_project_config: bool\n            If True and the project does already exist in the configuration, it\n            is updated with what is stored in the archive\n        root: str\n            An alternative root directory to use. Otherwise the experiment will\n            be exctracted to\n\n            1. the root directory specified in the configuration files\n               (if the project exists in it) and `replace_project_config` is\n               False\n            2. the root directory as stored in the archive\n        projectname: str\n            The projectname to use. If None, use the one specified in the\n            archive\n        fmt: { 'gztar' | 'bztar' | 'tar' | 'zip' }\n            The format of the archive. If None, it is inferred\n        force: bool\n            If True, force to overwrite the configuration of all experiments\n            from what is stored in `archive`. Otherwise, the configuration of\n            the experiments in `archive` are only used if missing in the\n            current configuration\n        \"\"\"\n        def extract_file(path):\n            if atype == 'zip':\n                return file_obj.open(path)\n            else:\n                return file_obj.extractfile(path)\n\n        self.app_main(**kwargs)\n\n        logger = self.logger\n\n        project_config = None\n\n        all_exps = self.config.experiments\n        all_projects = self.config.projects\n        # ---- set archive\n        # if archive is None, check for the archives listed in `experiments`\n        # and raise an error if one has not been archived yet or if they belong\n        # to different files\n        if archive is None:\n            # ---- set experiments\n            # if experiments is None, use the current experiment. If complete\n            # is True, this will be replaced below\n            if experiments is None:\n                experiments = [self.experiment]\n            archives = list(filter(utils.isstring,\n                                   map(self.is_archived, experiments)))\n            if len(archives) > 1:\n                raise ValueError(\n                    'The given experiments belong to multiple archives %s!' % (\n                        ', '.join(archives)))\n            archive = next(iter(archives))\n        elif not complete and experiments is None:\n            experiments = [self.experiment]\n\n        logger.info('Unarchiving from %s', archive)\n\n        # --- infer compression type\n        ext_map, fmt_map = self._archive_extensions()\n        if fmt is None:\n            try:\n                fmt = next(fmt for ext, fmt in ext_map.items()\n                           if archive.endswith(ext))\n            except StopIteration:\n                raise IOError(\n                    \"Could not infer archive format of {}! Please specify it \"\n                    \"manually using the `fmt` parameter!\".format(archive))\n\n        # if no root directory is specified but a projectname, we take the root\n        # directory from the configuration if, and only if, the configuration\n        # should not be replaced\n        if (root is None and projectname is not None and\n                not replace_project_config):\n            all_projects.get(projectname, {}).get('root')\n\n        # ---- open the archive\n        modes = {'bztar': 'r:bz2', 'gztar': 'r:gz', 'tar': 'r', 'zip': 'r'}\n        atype = 'zip' if fmt == 'zip' else 'tar'\n        if atype == 'tar':\n            from tarfile import open as open_file\n        else:\n            from zipfile import ZipFile as open_file\n        file_obj = open_file(archive, modes[fmt])\n\n        # ---- if root is None, get it from the archive\n        if root is None:\n            fp = extract_file(osp.join('.project', '.project.yml'))\n            try:\n                project_config = ordered_yaml_load(fp)\n                # use the projectname in archive only, if nothing is specified\n                # here\n                projectname = projectname or project_config['name']\n            except:\n                raise\n            finally:\n                fp.close()\n            # if the projectname is existent in our configuration and already\n            # specified, use this one\n            if (projectname in self.config.projects and\n                    not replace_project_config):\n                root = self.config.projects[projectname].get('root')\n            else:\n                root = project_config.get('root')\n        # if we still don't have it, because it was not specified in the\n        # archive or the configuration, raise an error\n        if root is None:\n            raise ValueError(\"Could not find a root directory path for the \"\n                             \"project. Please specify manually!\")\n\n        logger.info('Root directory for the project: %s', root)\n\n        t = str(dt.datetime.now())  # time at the beginning of extraction\n\n        config_files = []\n\n        def fname_filter(m):\n            fname = get_fname(m)\n            if (dir_contains('.project', fname) and\n                    not osp.basename(fname).startswith('.')):\n                config_files.append(fname)\n            return (\n                complete or fname in config_files or\n                (project_data and not dir_contains('experiments', fname)) or\n                any(dir_contains(d, fname) for d in dirs))\n\n        if not complete:\n            dirs = [osp.join('experiments', exp) for exp in experiments]\n            dirs.append(osp.join('.project', '.project.yml'))\n        dir_contains = partial(utils.dir_contains, exists=False)\n        if atype == 'zip':\n            def get_fname(m):\n                return m\n            members = list(filter(fname_filter, file_obj.namelist()))\n        else:\n            def get_fname(m):\n                return m.name\n            members = list(filter(fname_filter, file_obj.getmembers()))\n        logger.debug('Extracting %s files from archive to %s',\n                     len(members), root)\n        file_obj.extractall(root, members=members)\n\n        # if the project_config yet not has been red, read it now\n        if not project_config:\n            with open(osp.join(root, '.project', '.project.yml')) as fp:\n                project_config = ordered_yaml_load(fp)\n            if projectname:\n                project_config['name'] = projectname\n            else:\n                projectname = project_config['name']\n        if projectname not in all_projects or replace_project_config:\n            all_projects[projectname] = project_config\n        else:\n            all_projects[projectname]['root'] = root\n\n        # get all experiment names in the archive\n        arc_exps = [osp.splitext(osp.basename(f))[0] for f in config_files]\n        if complete:\n            experiments = arc_exps\n        else:\n            for exp in filter(lambda exp: exp not in arc_exps, experiments[:]):\n                logger.warn('Experiment %s was not found in archive!', exp)\n                experiments.remove(exp)\n        for exp in experiments:\n            if force or exp not in self.config.experiments or self.is_archived(\n                    exp):\n                with open(osp.join(root, '.project', exp + '.yml')) as fexp:\n                    exp_config = ordered_yaml_load(fexp)\n                logger.debug('Update configuration for %s', exp)\n                all_exps[exp] = self.fix_paths(exp_config)\n            else:\n                exp_config = all_exps[exp]\n            exp_config['project'] = projectname\n            exp_config['timestamps']['unarchive'] = t\n\n        logger.debug('Done.')", "response": "Unarchives the current project from the given archive."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes an existing experiment and or project.", "response": "def remove(self, projectname=None, complete=False,\n               yes=False, all_projects=False, **kwargs):\n        \"\"\"\n        Delete an existing experiment and/or projectname\n\n        Parameters\n        ----------\n        projectname: str\n            The name for which the data shall be removed. If True, the\n            project will be determined by the experiment. If not None, all\n            experiments for the given project will be removed.\n        complete: bool\n            If set, delete not only the experiments and config files, but also\n            all the project files\n        yes: bool\n            If True/set, do not ask for confirmation\n        all_projects: bool\n            If True/set, all projects are removed\n\n        Warnings\n        --------\n        This will remove the entire folder and all the related informations in\n        the configurations!\n        \"\"\"\n        self.app_main(**kwargs)\n        if projectname in self.config.projects:\n            self.projectname = projectname\n        all_experiments = self.config.experiments\n        projects_info = self.config.projects\n        if all_projects:\n            experiments = list(all_experiments.keys())\n            projects = list(projects_info.keys())\n        elif projectname is not None:\n            experiments = all_experiments.project_map[projectname]\n            projects = [self.projectname]\n        else:\n            experiments = [self.experiment]\n            projects = [self.projectname]\n        if not yes:\n            if complete:\n                msg = ('Are you sure to remove all experiments (%s) and '\n                       'directories for the project instances %s?' % (\n                           ', '.join(experiments), ', '.join(projects)))\n            else:\n                msg = ('Are you sure to remove the experiments %s' % (\n                    ', '.join(experiments)))\n            answer = ''\n            while answer.lower() not in ['n', 'no', 'y', 'yes']:\n                answer = input(msg + '[y/n] ')\n            if answer.lower() in ['n', 'no']:\n                return\n        for exp in experiments:\n            if not self.is_archived(exp):\n                self.logger.debug(\"Removing experiment %s\", exp)\n                try:\n                    exp_dict = self.fix_paths(all_experiments[exp])\n                except KeyError:  # experiment has been removed already\n                    pass\n                else:\n                    if osp.exists(exp_dict['expdir']):\n                        shutil.rmtree(exp_dict['expdir'])\n                    self.config.remove_experiment(exp)\n\n        if complete:\n            for project in projects:\n                self.logger.debug(\"Removing project %s\", project)\n                projectdir = projects_info.pop(project)['root']\n                if osp.exists(projectdir):\n                    shutil.rmtree(projectdir)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting information on the current project and all the experiments in the current project.", "response": "def info(self, exp_path=False, project_path=False, global_path=False,\n             config_path=False, complete=False, no_fix=False,\n             on_projects=False, on_globals=False, projectname=None,\n             return_dict=False, insert_id=True, only_keys=False,\n             archives=False, **kwargs):\n        \"\"\"\n        Print information on the experiments\n\n        Parameters\n        ----------\n        exp_path: bool\n            If True/set, print the filename of the experiment configuration\n        project_path: bool\n            If True/set, print the filename on the project configuration\n        global_path: bool\n            If True/set, print the filename on the global configuration\n        config_path: bool\n            If True/set, print the path to the configuration directory\n        complete: bool\n            If True/set, the information on all experiments are printed\n        no_fix: bool\n            If set, paths are given relative to the root directory of the\n            project\n        on_projects: bool\n            If set, show information on the projects rather than the\n            experiment\n        on_globals: bool\n            If set, show the global configuration settings\n        projectname: str\n            The name of the project that shall be used. If provided and\n            `on_projects` is not True, the information on all experiments for\n            this project will be shown\n        return_dict: bool\n            If True, the dictionary is returned instead of printed\n        insert_id: bool\n            If True and neither `on_projects`, nor `on_globals`, nor\n            `projectname` is given, the experiment id is inserted in the\n            dictionary\n        only_keys: bool\n            If True, only the keys of the given dictionary are printed\n        archives: bool\n            If True, print the archives and the corresponding experiments for\n            the specified project\n        \"\"\"\n        self.app_main(**kwargs)\n\n        def get_archives(project):\n            ret = OrderedDict()\n            for exp, a in self.config.experiments.items():\n                if self.is_archived(exp) and a.project == project:\n                    ret.setdefault(str(a), []).append(exp)\n            return ret\n\n        paths = OrderedDict([\n            ('conf_dir', config_path), ('_globals_file', global_path)])\n        if any(paths.values()):\n            for key, val in paths.items():\n                if val:\n                    return (self.print_ or six.print_)(getattr(\n                        self.config, key))\n            return\n        if archives:\n            base = OrderedDict()\n            current = projectname or self.projectname\n            if complete:\n                for project in self.config.projects.keys():\n                    d = get_archives(project)\n                    if d:\n                        base[project] = d\n            else:\n                base[current] = get_archives(current)\n        elif exp_path:\n            current = self.experiment\n            base = self.config.experiments.exp_files\n        elif project_path:\n            current = self.projectname\n            base = OrderedDict(\n                (key, osp.join(val, '.project', '.project.yml'))\n                for key, val in self.config.projects.project_paths.items())\n        elif on_globals:\n            complete = True\n            no_fix = True\n            base = self.config.global_config\n        elif on_projects:\n            base = OrderedDict(self.config.projects)\n            current = projectname or self.projectname\n        else:\n            current = self.experiment\n            if projectname is None:\n                if insert_id:\n                    base = copy.deepcopy(self.config.experiments)\n                    if not complete:\n                        base[current]['id'] = current\n                        if six.PY3:\n                            base[current].move_to_end('id', last=False)\n                else:\n                    base = self.config.experiments\n                if not only_keys:\n                    # make sure the experiments are loaded\n                    if complete:\n                        base.load()\n                    else:\n                        base[current]\n                # convert to an OrderedDict\n                base = base.as_ordereddict()\n            else:\n                base = OrderedDict(\n                    (exp, self.config.experiments[exp])\n                    for exp in self.config.experiments.project_map[projectname]\n                    )\n                complete = True\n\n        if no_fix and not (archives or on_globals):\n            for key, val in base.items():\n                if isinstance(val, dict):\n                    base[key] = self.rel_paths(copy.deepcopy(val))\n        if not complete:\n            base = base[current]\n        if only_keys:\n            base = list(base.keys())\n        if not return_dict:\n            if isinstance(base, six.string_types):\n                ret = base\n            else:\n                ret = ordered_yaml_dump(base, default_flow_style=False)\n            return (self.print_ or six.print_)(ret.rstrip())\n        else:\n            return base"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting one or more values from the configuration.", "response": "def get_value(self, keys, exp_path=False, project_path=False,\n                  complete=False, on_projects=False, on_globals=False,\n                  projectname=None, no_fix=False, only_keys=False, base='',\n                  return_list=False, archives=False, **kwargs):\n        \"\"\"\n        Get one or more values in the configuration\n\n        Parameters\n        ----------\n        keys: list of str\n            A list of keys to get the values of. %(get_value_note)s\n        %(ModelOrganizer.info.parameters.exp_path|project_path)s\n        %(ModelOrganizer.info.common_params)s\n        %(ModelOrganizer.info.parameters.no_fix|only_keys|archives)s\n        base: str\n            A base string that shall be put in front of each key in `values` to\n            avoid typing it all the time\n        return_list: bool\n            If True, the list of values corresponding to `keys` is returned,\n            otherwise they are printed separated by a new line to the standard\n            output\n        \"\"\"\n        def pretty_print(val):\n            if isinstance(val, dict):\n                if only_keys:\n                    val = list(val.keys())\n                return ordered_yaml_dump(\n                    val, default_flow_style=False).rstrip()\n            return str(val)\n        config = self.info(exp_path=exp_path, project_path=project_path,\n                           complete=complete, on_projects=on_projects,\n                           on_globals=on_globals, projectname=projectname,\n                           no_fix=no_fix, return_dict=True, insert_id=False,\n                           archives=archives, **kwargs)\n        ret = [0] * len(keys)\n        for i, key in enumerate(keys):\n            if base:\n                key = base + key\n            key, sub_config = utils.go_through_dict(key, config)\n            ret[i] = sub_config[key]\n        if return_list:\n            return ret\n        return (self.print_ or six.print_)('\\n'.join(map(pretty_print, ret)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a value in the configuration", "response": "def del_value(self, keys, complete=False, on_projects=False,\n                  on_globals=False, projectname=None, base='', dtype=None,\n                  **kwargs):\n        \"\"\"\n        Delete a value in the configuration\n\n        Parameters\n        ----------\n        keys: list of str\n            A list of keys to be deleted. %(get_value_note)s\n        %(ModelOrganizer.info.common_params)s\n        base: str\n            A base string that shall be put in front of each key in `values` to\n            avoid typing it all the time\n        \"\"\"\n        config = self.info(complete=complete, on_projects=on_projects,\n                           on_globals=on_globals, projectname=projectname,\n                           return_dict=True, insert_id=False, **kwargs)\n        for key in keys:\n            if base:\n                key = base + key\n            key, sub_config = utils.go_through_dict(key, config)\n            del sub_config[key]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconfigure the current instance of the current object.", "response": "def configure(self, global_config=False, project_config=False, ifile=None,\n                  forcing=None, serial=False, nprocs=None, update_from=None,\n                  **kwargs):\n        \"\"\"\n        Configure the project and experiments\n\n        Parameters\n        ----------\n        global_config: bool\n            If True/set, the configuration are applied globally (already\n            existing and configured experiments are not impacted)\n        project_config: bool\n            Apply the configuration on the entire project instance instead of\n            only the single experiment (already existing and configured\n            experiments are not impacted)\n        ifile: str\n            The input file for the project. Must be a netCDF file with\n            population data\n        forcing: str\n            The input file for the project containing variables with population\n            evolution information. Possible variables in the netCDF file are\n            *movement* containing the number of people to move and *change*\n            containing the population change (positive or negative)\n        serial: bool\n            Do the parameterization always serial (i.e. not in parallel on\n            multiple processors). Does automatically impact global settings\n        nprocs: int or 'all'\n            Maximum number of processes to when making the parameterization in\n            parallel. Does automatically impact global settings and disables\n            `serial`\n        update_from: str\n            Path to a yaml configuration file to update the specified\n            configuration with it\n        ``**kwargs``\n            Other keywords for the :meth:`app_main` method\"\"\"\n        if global_config:\n            d = self.config.global_config\n        elif project_config:\n            self.app_main(**kwargs)\n            d = self.config.projects[self.projectname]\n        else:\n            d = self.config.experiments[self.experiment]\n\n        if ifile is not None:\n            d['input'] = osp.abspath(ifile)\n        if forcing is not None:\n            d['forcing'] = osp.abspath(forcing)\n\n        if update_from is not None:\n            with open('update_from') as f:\n                d.update(yaml.load(f))\n\n        global_config = self.config.global_config\n        if serial:\n            global_config['serial'] = True\n        elif nprocs:\n            nprocs = int(nprocs) if nprocs != 'all' else nprocs\n            global_config['serial'] = False\n            global_config['nprocs'] = nprocs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting a value in the configuration", "response": "def set_value(self, items, complete=False, on_projects=False,\n                  on_globals=False, projectname=None, base='', dtype=None,\n                  **kwargs):\n        \"\"\"\n        Set a value in the configuration\n\n        Parameters\n        ----------\n        items: dict\n            A dictionary whose keys correspond to the item in the configuration\n            and whose values are what shall be inserted. %(get_value_note)s\n        %(ModelOrganizer.info.common_params)s\n        base: str\n            A base string that shall be put in front of each key in `values` to\n            avoid typing it all the time\n        dtype: str\n            The name of the data type or a data type to cast the value to\n        \"\"\"\n        def identity(val):\n            return val\n        config = self.info(complete=complete, on_projects=on_projects,\n                           on_globals=on_globals, projectname=projectname,\n                           return_dict=True, insert_id=False, **kwargs)\n        if isinstance(dtype, six.string_types):\n            dtype = getattr(builtins, dtype)\n        elif dtype is None:\n            dtype = identity\n        for key, value in six.iteritems(dict(items)):\n            if base:\n                key = base + key\n            key, sub_config = utils.go_through_dict(key, config,\n                                                    setdefault=OrderedDict)\n            if key in self.paths:\n                if isinstance(value, six.string_types):\n                    value = osp.abspath(value)\n                else:\n                    value = list(map(osp.abspath, value))\n            sub_config[key] = dtype(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fix_paths(self, *args, **kwargs):\n        return self.config.experiments.fix_paths(*args, **kwargs)", "response": "Fix the paths in the given dictionary to get absolute paths"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rel_paths(self, *args, **kwargs):\n        return self.config.experiments.rel_paths(*args, **kwargs)", "response": "Returns a list of relative paths for the given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef abspath(self, path, project=None, root=None):\n        if root is None:\n            root = self.config.projects[project or self.projectname]['root']\n        return osp.join(root, path)", "response": "Returns the absolute path from the current working directory"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef relpath(self, path, project=None, root=None):\n        if root is None:\n            root = self.config.projects[project or self.projectname]['root']\n        return osp.relpath(path, root)", "response": "Returns the relative path from the root directory of the project"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_parser(self, parser=None, subparsers=None):\n        commands = self.commands[:]\n        parser_cmds = self.parser_commands.copy()\n\n        if subparsers is None:\n            if parser is None:\n                parser = FuncArgParser(self.name)\n            subparsers = parser.add_subparsers(chain=True)\n\n        ret = {}\n        for i, cmd in enumerate(commands[:]):\n            func = getattr(self, cmd)\n            parser_cmd = parser_cmds.setdefault(cmd, cmd.replace('_', '-'))\n            ret[cmd] = sp = parser.setup_subparser(\n                func, name=parser_cmd, return_parser=True)\n            sp.setup_args(func)\n            modifier = getattr(self, '_modify_' + cmd, None)\n            if modifier is not None:\n                modifier(sp)\n        self.parser_commands = parser_cmds\n        parser.setup_args(self.app_main)\n        self._modify_app_main(parser)\n        self.parser = parser\n        self.subparsers = ret\n        return parser, subparsers, ret", "response": "Create the argument parser for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the arguments from the command line or directly to the parser", "response": "def parse_args(self, args=None):\n        \"\"\"\n        Parse the arguments from the command line (or directly) to the parser\n        of this organizer\n\n        Parameters\n        ----------\n        args: list\n            A list of arguments to parse. If None, the :attr:`sys.argv`\n            argument is used\n\n        Returns\n        -------\n        %(ModelOrganizer.start.returns)s\n        \"\"\"\n        if self.parser is None:\n            self.setup_parser()\n        if not self._parser_set_up:\n            self._finish_parser()\n        ret = self.start(**vars(self.parser.parse_args(args)))\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_parser(cls):\n        organizer = cls()\n        organizer.setup_parser()\n        organizer._finish_parser()\n        return organizer.parser", "response": "Function returning the command line parser for this class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_archived(self, experiment, ignore_missing=True):\n        if ignore_missing:\n            if isinstance(self.config.experiments.get(experiment, True),\n                          Archive):\n                return self.config.experiments.get(experiment, True)\n        else:\n            if isinstance(self.config.experiments[experiment], Archive):\n                return self.config.experiments[experiment]", "response": "Returns the path to the archive if it has been archived already"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate translations from file extensions to archive format", "response": "def _archive_extensions():\n        \"\"\"Create translations from file extension to archive format\n\n        Returns\n        -------\n        dict\n            The mapping from file extension to archive format\n        dict\n            The mapping from archive format to default file extension\n        \"\"\"\n        if six.PY3:\n            ext_map = {}\n            fmt_map = {}\n            for key, exts, desc in shutil.get_unpack_formats():\n                fmt_map[key] = exts[0]\n                for ext in exts:\n                    ext_map[ext] = key\n        else:\n            ext_map = {'.tar': 'tar',\n                       '.tar.bz2': 'bztar',\n                       '.tar.gz': 'gztar',\n                       '.tar.xz': 'xztar',\n                       '.tbz2': 'bztar',\n                       '.tgz': 'gztar',\n                       '.txz': 'xztar',\n                       '.zip': 'zip'}\n            fmt_map = {'bztar': '.tar.bz2',\n                       'gztar': '.tar.gz',\n                       'tar': '.tar',\n                       'xztar': '.tar.xz',\n                       'zip': '.zip'}\n        return ext_map, fmt_map"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_handler(self, io_loop):\n\t\tWNativeSocketHandler.setup_handler(self, io_loop)\n\t\tif self.server_mode() is False:\n\t\t\tself.io_handler().transport_socket().sendto(\n\t\t\t\tself.io_handler().messenger().request(self.config()),\n\t\t\t\tself.transport().target_socket(self.config()).pair()\n\t\t\t)", "response": "This method is called by the object s setup_handler method."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all available remote tags naturally sorted as version strings", "response": "def remote_tags(url):\n    # type: (str) -> list\n    \"\"\"\n    List all available remote tags naturally sorted as version strings\n    :rtype: list\n    :param url: Remote URL of the repository\n    :return: list of available tags\n    \"\"\"\n    tags = []\n    remote_git = Git()\n    for line in remote_git.ls_remote('--tags', '--quiet', url).split('\\n'):\n        hash_ref = line.split('\\t')\n        tags.append(hash_ref[1][10:].replace('^{}',''))\n    return natsorted(tags)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclone a GitPython repository to a specific directory.", "response": "def clone(url, directory, single_branch=None):\n    print_info('Cloning {0} to {1} {2}'.format(\n        url,\n        directory,\n        '[full clone]' if single_branch is None else '[{0}]'.format(single_branch)\n    ))\n    # type: (str, str, str) -> Repo\n    \"\"\"\n    Clone a repository, optionally using shallow clone\n    :rtype: Repo\n    :param url: URL of the repository\n    :param directory: Directory to clone to\n    :param single_branch: branch to clone if shallow clone is preferred\n    :return: GitPython repository object of the newly cloned repository\n    \"\"\"\n    args = {\n        'url': url,\n        'to_path': directory,\n        'progress': SimpleProgressPrinter(),\n        'recursive': True\n    }\n\n    if single_branch is not None:\n        args['depth'] = 1\n        args['branch'] = single_branch\n        args['single_branch'] = True\n\n    return Repo.clone_from(**args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef repo_url_to_project_name(url, normalize=True):\n    # type: (str, bool) -> str\n    \"\"\"\n    Extract project title from GIT repository URL, either https or ssh.\n    Should work fine with github, bitbucket\n    :rtype: str\n    :param url: Url of the repository\n    :param normalize: Title-case the project name\n    :return: Project name\n    \"\"\"\n    if url.startswith('http'):\n        http_url = urlparse(url)\n        name = http_url.path.replace('.git', '').lstrip('/').strip()\n    else:\n        name = url[url.index(':') + 1:].replace('.git', '').strip()\n    if normalize:\n        return name.replace('/', ' / ').title()\n    return name", "response": "Extract project name from GIT repository URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef loadFile(self, fileName):\n\n        # Test if the file exists.\n        if not QtCore.QFile(fileName).exists():\n            msg = \"File <b>{}</b> does not exist\".format(self.qteAppletID())\n            self.qteLogger.info(msg)\n            self.fileName = None\n            return\n\n        # Store the file name and load the PDF document with the\n        # Poppler library.\n        self.fileName = fileName\n        doc = popplerqt4.Poppler.Document.load(fileName)\n\n        # Enable antialiasing to improve the readability of the fonts.\n        doc.setRenderHint(popplerqt4.Poppler.Document.Antialiasing)\n        doc.setRenderHint(popplerqt4.Poppler.Document.TextAntialiasing)\n\n        # Convert each page to an image, then install that image as the\n        # pixmap of a QLabel, and finally insert that QLabel into a\n        # vertical layout.\n        hbox = QtGui.QVBoxLayout()\n        for ii in range(doc.numPages()):\n            pdf_img = doc.page(ii).renderToImage()\n            pdf_label = self.qteAddWidget(QtGui.QLabel())\n            pdf_label.setPixmap(QtGui.QPixmap.fromImage(pdf_img))\n            hbox.addWidget(pdf_label)\n\n        # Use an auxiliary widget to hold that layout and then place\n        # that auxiliary widget into a QScrollView. The auxiliary\n        # widget is necessary because QScrollArea can only display a\n        # single widget at once.\n        tmp = self.qteAddWidget(QtGui.QWidget(self))\n        tmp.setLayout(hbox)\n        self.qteScroll.setWidget(tmp)", "response": "Load and display the PDF file specified by fileName."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_product(membersuite_id, client=None):\n    if not membersuite_id:\n        return None\n\n    client = client or get_new_client(request_session=True)\n\n    object_query = \"SELECT Object() FROM PRODUCT WHERE ID = '{}'\".format(\n        membersuite_id)\n\n    result = client.execute_object_query(object_query)\n\n    msql_result = result[\"body\"][\"ExecuteMSQLResult\"]\n\n    if msql_result[\"Success\"]:\n        membersuite_object_data = (msql_result[\"ResultValue\"]\n                                   [\"SingleObject\"])\n    else:\n        raise ExecuteMSQLError(result=result)\n\n    return Product(membersuite_object_data=membersuite_object_data)", "response": "Return a Product object by ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __watchers_callbacks_exec(self, signal_name):\n\t\tdef callback_fn():\n\t\t\tfor watcher in self.__watchers_callbacks[signal_name]:\n\t\t\t\tif watcher is not None:\n\t\t\t\t\twatcher.notify()\n\t\treturn callback_fn", "response": "Generate callback for a queue_node"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef watch(self, signal_name):\n\t\twatcher = WSignalSource.Watcher(\n\t\t\tself.__queues[signal_name], lambda x: self.__watchers_callbacks[signal_name].remove(x)\n\t\t)\n\t\tself.__watchers_callbacks[signal_name].add(watcher)\n\t\treturn watcher", "response": "meth :. WSignalSourceProto. watch implementation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_callback(self, signal_name, callback):\n\t\ttry:\n\t\t\tself.__direct_callbacks[signal_name].remove(callback)\n\t\texcept KeyError:\n\t\t\traise ValueError('Signal \"%s\" does not have the specified callback' % signal_name)", "response": "Removes a callback from the list of callbacks for a given signal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a list of channels for the fields of the model.", "response": "def create_channels_for_related_fields_in_model(model_class):\n    \"\"\"\n    Create channel for the fields of the model, the channel name can be got by calling get_ajax_config_for_relation_fields\n    :param model_class:\n    :return:\n    \"\"\"\n    need_to_create_channel = []\n    for field in enum_model_fields(model_class):\n        if type(field) in get_relation_field_types():\n            if field.related_model == 'self':\n                need_to_create_channel.append(model_class)\n            elif field.related_field.model not in need_to_create_channel:\n                need_to_create_channel.append(field.related_field.model)\n\n    for field in enum_model_many_to_many(model_class):\n        if type(field) in get_relation_field_types():\n            if field.related_model not in need_to_create_channel:\n                need_to_create_channel.append(field.related_model)\n\n    for field_model_class in need_to_create_channel:\n        if class_name_to_low_case(field_model_class.__name__) not in registry._registry:\n            register_channel(field_model_class)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntrim a python doc string.", "response": "def py_doc_trim(docstring):\n    \"\"\"Trim a python doc string.\n\n    This example is nipped from https://www.python.org/dev/peps/pep-0257/,\n    which describes how to conventionally format and trim docstrings.\n\n    It has been modified to replace single newlines with a space, but leave\n    multiple consecutive newlines in tact.\n    \"\"\"\n    if not docstring:\n        return ''\n    # Convert tabs to spaces (following the normal Python rules)\n    # and split into a list of lines:\n    lines = docstring.expandtabs().splitlines()\n    # Determine minimum indentation (first line doesn't count):\n    indent = sys.maxint\n    for line in lines[1:]:\n        stripped = line.lstrip()\n        if stripped:\n            indent = min(indent, len(line) - len(stripped))\n    # Remove indentation (first line is special):\n    trimmed = [lines[0].strip()]\n    if indent < sys.maxint:\n        for line in lines[1:]:\n            trimmed.append(line[indent:].rstrip())\n    # Strip off trailing and leading blank lines:\n    while trimmed and not trimmed[-1]:\n        trimmed.pop()\n    while trimmed and not trimmed[0]:\n        trimmed.pop(0)\n    # The single string returned by the original function\n    joined = '\\n'.join(trimmed)\n    # Return a version that replaces single newlines with spaces\n    return newline_substitution_regex.sub(\" \", joined)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding names to all of the Resource fields.", "response": "def _fix_up_fields(cls):\n        \"\"\"Add names to all of the Resource fields.\n\n        This method will get called on class declaration because of\n        Resource's metaclass.  The functionality is based on Google's NDB\n        implementation.\n\n        `Endpoint` does something similar for `arguments`.\n        \"\"\"\n        cls._fields = {}\n        if cls.__module__ == __name__ and cls.__name__ != 'DebugResource':\n            return\n        for name in set(dir(cls)):\n            attr = getattr(cls, name, None)\n            if isinstance(attr, BaseField):\n                if name.startswith('_'):\n                    raise TypeError(\"Resource field %s cannot begin with an \"\n                            \"underscore.  Underscore attributes are reserved \"\n                            \"for instance variables that aren't intended to \"\n                            \"propagate out to the HTTP caller.\" % name)\n                attr._fix_up(cls, name)\n                cls._fields[attr.name] = attr\n        if cls._default_fields is None:\n            cls._default_fields = tuple(cls._fields.keys())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrendering a JSON - serializable version of the object passed in.", "response": "def _render_serializable(self, obj, context):\n        \"\"\"Renders a JSON-serializable version of the object passed in.\n        Usually this means turning a Python object into a dict, but sometimes\n        it might make sense to render a list, or a string, or a tuple.\n\n        In this base class, we provide a default implementation that assumes\n        some things about your application architecture, namely, that your\n        models specified in `underlying_model` have properties with the same\n        name as all of the `_fields` that you've specified on a\n        resource, and that all of those fields are public.\n\n        Obviously this may not be appropriate for your app, so your\n        subclass(es) of Resource should implement this method to serialize\n        your things in the way that works for you.\n\n        Do what you need to do.  The world is your oyster.\n        \"\"\"\n        logging.info(\"\"\"Careful, you're calling ._render_serializable on the\n        base resource, which is probably not what you actually want to be\n        doing!\"\"\")\n        if obj is None:\n            logging.debug(\n                    \"_render_serializable passed a None obj, returning None\")\n            return None\n        output = {}\n        if self._fields_to_render is None:\n            return output\n        for field in self._fields_to_render:\n            renderer = self._fields[field].render\n            output[field] = renderer(obj, field, context)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of JSON - serializable items for the passed in list_of_objs.", "response": "def _render_serializable(self, list_of_objs, context):\n        \"\"\"Iterates through the passed in `list_of_objs` and calls the\n        `_render_serializable` method of each object's Resource type.\n\n        This will probably support heterogeneous types at some point (hence\n        the `item_types` initialization, as opposed to just item_type), but\n        that might be better suited to something else like a ResourceDict.\n\n        This method returns a JSON-serializable list of JSON-serializable\n        dicts.\n        \"\"\"\n        output = []\n        for obj in list_of_objs:\n            if obj is not None:\n                item = self._item_resource._render_serializable(obj, context)\n                output.append(item)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef critical_section_dynamic_lock(lock_fn, blocking=True, timeout=None, raise_exception=True):\n\n\tif blocking is False or timeout is None:\n\t\ttimeout = -1\n\n\tdef first_level_decorator(decorated_function):\n\t\tdef second_level_decorator(original_function, *args, **kwargs):\n\t\t\tlock = lock_fn(*args, **kwargs)\n\t\t\tif lock.acquire(blocking=blocking, timeout=timeout) is True:\n\t\t\t\ttry:\n\t\t\t\t\tresult = original_function(*args, **kwargs)\n\t\t\t\t\treturn result\n\t\t\t\tfinally:\n\t\t\t\t\tlock.release()\n\t\t\telif raise_exception is True:\n\t\t\t\traise WCriticalSectionError('Unable to lock critical section\\n')\n\n\t\treturn decorator(second_level_decorator)(decorated_function)\n\treturn first_level_decorator", "response": "This is a decorator that protects a function with a lock that was get from the specified function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef critical_section_lock(lock=None, blocking=True, timeout=None, raise_exception=True):\n\n\tdef lock_getter(*args, **kwargs):\n\t\treturn lock\n\n\treturn critical_section_dynamic_lock(\n\t\tlock_fn=lock_getter, blocking=blocking, timeout=timeout, raise_exception=raise_exception\n\t)", "response": "A decorator for the critical section dynamic lock function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean_description(string):\n\n    leading_whitespace = re.compile(r\"(\\A\\s+)\")\n    multiple_spaces = re.compile(r\"(\\s+\\s+)\")\n    newlines = re.compile(r\"\\n\")\n    colons = re.compile(r\":(?!//)\")\n    machine_code = re.compile(r\"(<.+>)\")\n    trailing_whitespace = re.compile(r\"(\\s+\\Z)\")\n    punctuation = re.compile(r\"([\\.!?,])\\s*\\Z\")\n\n    result = leading_whitespace.sub(\"\", string, 0)\n    result = newlines.sub(\" \", result, 0)\n    result = colons.sub('=', result, 0)\n    result = machine_code.sub(\"\", result, 0)\n    result = multiple_spaces.sub(\" \", result, 0)\n    result = trailing_whitespace.sub(\"\", result, 0)\n    has_punctuation = punctuation.search(result) != None\n\n    if not has_punctuation and result != \"\":\n        result = result + \".\"\n    else:\n        result = result\n\n    return result", "response": "Clean a string returned from API resources and endpoints"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a JSON string format of a Pale module s documentation.", "response": "def generate_json_docs(module, pretty_print=False, user=None):\n    \"\"\"Return a JSON string format of a Pale module's documentation.\n\n    This string can either be printed out, written to a file, or piped to some\n    other tool.\n\n    This method is a shorthand for calling `generate_doc_dict` and passing\n    it into a json serializer.\n\n    The user argument is optional. If included, it expects the user to be an object with an \"is_admin\"\n    boolean attribute. Any endpoint protected with a \"@requires_permission\" decorator will require\n    user.is_admin == True to display documentation on that endpoint.\n    \"\"\"\n    indent = None\n    separators = (',', ':')\n    if pretty_print:\n        indent = 4\n        separators = (',', ': ')\n\n    module_doc_dict = generate_doc_dict(module, user)\n    json_str = json.dumps(module_doc_dict,\n            indent=indent,\n            separators=separators)\n    return json_str"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_raml_docs(module, fields, shared_types, user=None, title=\"My API\", version=\"v1\", api_root=\"api\", base_uri=\"http://mysite.com/{version}\"):\n    output = StringIO()\n\n    # Add the RAML header info\n    output.write('#%RAML 1.0 \\n')\n    output.write('title: ' + title + ' \\n')\n    output.write('baseUri: ' + base_uri + ' \\n')\n    output.write('version: ' + version + '\\n')\n    output.write('mediaType: application/json\\n\\n')\n    output.write('documentation:\\n')\n    output.write('  - title: Welcome\\n')\n    output.write('    content: |\\n')\n    output.write(\"\"\"\\\n        Welcome to the Loudr API Docs.\\n\n        You'll find comprehensive documentation on our endpoints and resources here.\n        \"\"\")\n    output.write(\"\\n###############\\n# Resource Types:\\n###############\\n\\n\")\n    output.write('types:\\n')\n\n    basic_fields = []\n\n    for field_module in inspect.getmembers(fields, inspect.ismodule):\n        for field_class in inspect.getmembers(field_module[1], inspect.isclass):\n            basic_fields.append(field_class[1])\n\n    pale_basic_types = generate_basic_type_docs(basic_fields, {})\n\n    output.write(\"\\n# Pale Basic Types:\\n\\n\")\n    output.write(pale_basic_types[0])\n\n\n    shared_fields = []\n\n    for shared_type in shared_types:\n\n        for field_class in inspect.getmembers(shared_type, inspect.isclass):\n            shared_fields.append(field_class[1])\n\n    pale_shared_types = generate_basic_type_docs(shared_fields, pale_basic_types[1])\n    output.write(\"\\n# Pale Shared Types:\\n\\n\")\n    output.write(pale_shared_types[0])\n\n\n    raml_resource_types = generate_raml_resource_types(module)\n    output.write(\"\\n# API Resource Types:\\n\\n\")\n    output.write(raml_resource_types)\n\n    raml_resources = generate_raml_resources(module, api_root, user)\n    output.write(\"\\n\\n###############\\n# API Endpoints:\\n###############\\n\\n\")\n    output.write(raml_resources)\n\n    raml_docs = output.getvalue()\n    output.close()\n\n    return raml_docs", "response": "Generates a RAML file of a Pale module s documentation as a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_type_docs(types):\n    output = StringIO()\n\n    indent = \"  \"  # 2\n\n    # loop through the basic types and add them to the RAML formatted output\n    for type_name in types:\n\n        if types[type_name].get(\"type\") != None:\n\n            output.write(indent + type_name + \":\\n\")\n\n            indent += \"  \"  # 4\n\n            type_safe = types[type_name][\"type\"].replace(\" \", \"_\")\n\n            # if we are dealing with a list, set type to array and specify type of items\n            if types[type_name].get(\"items\") != None:\n                items_safe = types[type_name][\"items\"].replace(\" \", \"_\")\n                # if items_safe == \"base\":\n                #     items_safe = \"object\"\n                output.write(indent + \"type: \" + type_safe + \"\\n\")\n                output.write(indent + \"items: \" + items_safe + \"\\n\")\n\n            # otherwise, use the type per normal\n            else:\n                output.write(indent + \"type: \" + type_safe + \"\\n\")\n\n            # add the description\n            if types[type_name].get(\"description\") != None:\n                output.write(indent + \"description: \" + types[type_name][\"description\"] + \"\\n\")\n\n            indent = indent[:-2]    # 2\n\n    type_docs = output.getvalue()\n    output.close()\n    return type_docs", "response": "Parse an object of types and generate RAML documentation for each type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_basic_type_docs(fields, existing_types):\n\n    # These types are standard in RAML 1.0\n    # They should not be defined in the RAML file that we return\n    # We will inherit from them in the types we define\n    raml_built_in_types = {\n        \"any\": {\n            \"parent\": None,\n        },\n        \"time-only\": {\n            \"parent\": \"any\",\n        },\n        \"datetime\": {\n            \"parent\": \"any\",\n            \"pale_children\": [\"timestamp\"],\n        },\n        \"datetime-only\": {\n            \"parent\": \"any\",\n        },\n        \"date-only\": {\n            \"parent\": \"any\",\n            \"pale_children\": [\"date\"],\n        },\n        \"number\": {\n            \"parent\": \"any\",\n        },\n        \"boolean\": {\n            \"parent\": \"any\",\n            \"pale_children\": [\"boolean\"]\n        },\n        \"string\": {\n            \"parent\": \"any\",\n            \"pale_children\": [\"url\", \"string\", \"uri\"],\n        },\n        \"null\": {\n            \"parent\": \"any\",\n        },\n        \"file\": {\n            \"parent\": \"any\",\n        },\n        \"array\": {\n            \"parent\": \"any\",\n            \"pale_children\": [\"list\"],\n        },\n        \"object\": {\n            \"parent\": \"any\",\n        },\n        \"union\": {\n            \"parent\": \"any\",\n        },\n        \"XSD Schema\": {\n            \"parent\": \"any\",\n        },\n        \"JSON Schema\": {\n            \"parent\": \"any\",\n        },\n        \"integer\": {\n            \"parent\": \"number\",\n            \"pale_children\": [\"integer\"],\n        },\n    }\n\n    basic_types = {}\n\n    # Find all classes defined in a set of resources and build up an object with\n    # the relevant details of the basic types\n    for field in fields:\n\n        # if this is a Pale type, it will have a 'value_type' property,\n        if hasattr(field, \"value_type\"):\n            type_name = field.value_type.replace(\" \", \"_\")\n\n            # add this type only if it is not in the built-in raml types and we have\n            # not added it yet\n            if type_name not in raml_built_in_types \\\n                and type_name not in basic_types \\\n                and type_name not in existing_types:\n\n                basic_types[type_name] = {}\n\n                # strip newlines and leading whitespaces from doc string, then add as description\n                if hasattr(field, \"__doc__\"):\n                    modified_description = clean_description(field.__doc__)\n                    basic_types[type_name][\"description\"] = modified_description\n\n                # if this type is listed as the child of a built-in raml type,\n                # use the raml type as its parent type\n                for raml_type in raml_built_in_types:\n                    if \"pale_children\" in raml_built_in_types[raml_type]:\n                        if type_name in raml_built_in_types[raml_type][\"pale_children\"]:\n                            basic_types[type_name][\"type\"] = raml_type\n                            break\n\n                    else:\n                        # if this is not the child of a built-in raml type\n                        # and if this type is a list composed of other items:\n                        if hasattr(field, \"is_list\") and field.is_list:\n                            basic_types[type_name][\"type\"] = \"array\"\n\n                            # and the type is defined, use the defined type\n                            if hasattr(field, \"list_item_type\") and field.list_item_type != None:\n                                basic_types[type_name][\"items\"] = field.list_item_type\n                            # otherwise, use the base type\n                            else:\n                                basic_types[type_name][\"items\"] = \"base\"\n\n\n                        # otherwise use the pale parent class as its type\n                        else:\n                            pale_parent_class = field.__mro__[1]\n\n                            # if we are at the base class, inherit from the RAML \"object\" type\n                            if pale_parent_class.__name__ == \"object\":\n                                basic_types[type_name][\"type\"] = \"object\"\n\n                            # otherwise, inherit from the named parent\n                            else:\n                                basic_types[type_name][\"type\"] = pale_parent_class.value_type\n\n    ordered_basic_types =  OrderedDict(sorted(basic_types.items(), key=lambda t: t[0]))\n\n    basic_docs = generate_type_docs(ordered_basic_types)\n\n    return (basic_docs, basic_types)", "response": "Generate basic type documentation for a resource type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_raml_resource_types(module):\n\n    from pale import extract_endpoints, extract_resources, is_pale_module\n    if not is_pale_module(module):\n        raise ValueError(\n            \"\"\"The passed in `module` (%s) is not a pale module. `paledoc`\n            only works on modules with a `_module_type` set to equal\n            `pale.ImplementationModule`.\"\"\")\n\n    module_resource_types = extract_resources(module)\n    raml_resource_types_unsorted = {}\n\n    for resource in module_resource_types:\n        resource_name = resource.__name__\n        raml_resource_types_unsorted[resource_name] = document_resource(resource)\n        if hasattr(resource, \"_description\"):\n            modified_description = clean_description(resource._description)\n            raml_resource_types_unsorted[resource_name][\"description\"] = modified_description\n\n    raml_resource_types_doc = OrderedDict(sorted(raml_resource_types_unsorted.items(), key=lambda t: t[0]))\n\n    output = StringIO()\n    indent = \"  \"  # 2\n\n    # blacklist of resources to ignore\n    ignored_resources = []\n\n    for resource_type in raml_resource_types_doc:\n\n        this_resource_type = raml_resource_types_doc[resource_type]\n\n        # add the name, ignoring the blacklist\n        if resource_type not in ignored_resources:\n            output.write(indent + resource_type + \":\\n\")\n\n            indent += \"  \"  # 4\n\n            # add the description\n            if this_resource_type.get(\"description\") != None:\n                modified_description = clean_description(this_resource_type[\"description\"])\n                output.write(indent + \"description: \" + modified_description + \"\\n\")\n\n            # if there are no fields, set type directly:\n            if len(this_resource_type[\"fields\"]) == 0:\n                this_type = \"object\"\n                if this_resource_type.get(\"_underlying_model\") != None:\n                    if this_resource_type[\"_underlying_model\"] != object:\n                        if hasattr(this_resource_type._underlying_model, \"_value_type\") \\\n                        and this_resource_type[\"_underlying_model\"]._value_type not in ignored_resources:\n                            this_type = this_resource_type[\"_underlying_model\"]._value_type\n                output.write(indent + \"type: \" + this_type + \"\\n\")\n\n                indent = indent[:-2] # 2\n\n            # if there are fields, use them as the properties, which implies type = object\n            else:\n\n                output.write(indent + \"properties:\\n\")\n                indent += \"  \"  # 6\n\n                sorted_fields = OrderedDict(sorted(this_resource_type[\"fields\"].items(), key=lambda t: t[0]))\n\n\n                # add the field name, a.k.a. RAML type name\n                for field in sorted_fields:\n                    output.write(indent + field + \":\\n\")\n\n                    # add the query parameters, a.k.a. RAML properties\n                    properties = sorted_fields[field]\n\n                    indent += \"  \"  # 8\n\n                    # if this type is a list of other types, set it to type 'array' and note the item types\n                    # if not, add the type from the Pale type\n                    if \"_underlying_model\" in this_resource_type and this_resource_type[\"_underlying_model\"] == object:\n                        output.write(indent + \"type: base\\n\")\n                    elif \"item_type\" in properties:\n                        output.write(indent + \"type: array\\n\")\n                        output.write(indent + \"items: \" + properties[\"item_type\"] + \"\\n\")\n                    elif \"type\" in properties:\n                        output.write(indent + \"type: \" + properties[\"type\"].replace(\" \", \"_\") + \"\\n\")\n\n                    # if extended description exists, strip newlines and whitespace and add as description\n                    if properties.get(\"extended_description\") != None:\n                        modified_description = clean_description(properties[\"extended_description\"])\n                        output.write(indent + \"description: \" + modified_description + \"\\n\")\n                    # otherwise, use description\n                    elif properties.get(\"description\") != None:\n                        modified_description = clean_description(properties[\"description\"])\n                        output.write(indent + \"description: \" + modified_description + \"\\n\")\n\n                    if properties.get(\"default_fields\") != None:\n                        output.write(indent + \"properties:\\n\")\n                        indent += \"  \" # 10\n                        for field_name in sorted(properties[\"default_fields\"]):\n                            # @TODO check if every default field is actually a string type\n                            output.write(indent + field_name + \": string\\n\")\n\n                        indent = indent[:-2] # 8\n\n                    indent = indent[:-2] # 6\n\n                indent = indent[:-4] # 2\n\n\n    raml_resource_types = output.getvalue()\n    output.close()\n    return raml_resource_types", "response": "Generates a RAML resource types list from a Pale module s resource types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a dict of OrderedDicts using the URIs of the Pale endpoints as the structure for the tree.", "response": "def generate_raml_tree(flat_resources, api_root):\n    \"\"\"Generate a dict of OrderedDicts, using the URIs of the Pale endpoints as the structure for the tree.\n    Each level of the tree will contain a \"path\" property and an \"endpoint\" property.\n    The \"path\" will contain further nested endpoints, sorted alphabetically.\n    The \"endpoint\" will contain the documentation on the endpoint that ends at that level.\n    \"\"\"\n\n    def clean_angle_brackets(string):\n        \"\"\"Remove the angle brackets from a string and return the cleaned string\"\"\"\n        if string == None:\n            result = None\n        elif \":\" in string:\n            path = re.search(\"(\\w+/<\\w+)\", string).group(0)\n            result = re.sub(r'[<]','{', path)\n            result += \"}\"\n        else:\n            result = re.sub(r'[>]','}', re.sub(r'[<]','{', string))\n        return result\n\n    def add_or_find_path(input, tree):\n        \"\"\"Recursively add or find a path to an input dict.\n        The tree is a list of directories in nested order.\n        Returns a list, containing 1) the innermost node's \"endpoint\" dict\n        and 2) True if it was added as an empty dict, or False if not.\"\"\"\n\n        # if this is the last branch, return or add and return it\n        if len(tree) == 1:\n            if input.get(tree[0]) != None \\\n                and input.get(tree[0]).get(\"endpoint\") != None \\\n                and len(input.get(tree[0]).get(\"endpoint\")) > 0:\n                return [input[tree[0]], False]\n            else:\n                input[tree[0]] = {}\n                input[tree[0]][\"path\"] = {}\n                input[tree[0]][\"endpoint\"] = {}\n                return [input[tree[0]], True]\n\n        # if this is not the last branch, check if it exists and add if necessary\n        # then recurse on the next one\n        else:\n            if input.get(tree[0]) == None:\n                input[tree[0]] = {}\n                input[tree[0]][\"path\"] = {}\n            return add_or_find_path(input[tree[0]][\"path\"], tree[+1:])\n\n    def sort_tree_alphabetically(tree):\n        \"\"\"Recursively sort a tree by the keys in each \"path\" dict.\n        Each \"path\" dict will be converted to an OrderedDict that is sorted alphabetically.\n        \"\"\"\n\n        if tree.get(\"path\") != None and len(tree[\"path\"]) > 0:\n            sorted_path = OrderedDict(sorted(tree[\"path\"].items(), key=lambda t: t[0]))\n            tree[\"path\"] = sorted_path\n            for branch in tree[\"path\"]:\n                sort_tree_alphabetically(tree[\"path\"][branch])\n\n\n    # use a combination of three regex patterns to find all the components of the path\n    # these will be used to generate the nested dict that we will convert to RAML\n\n    # pattern #1: matches \"path/<id:specialchars>\"\n    re_dir_nested = \"(\\w+/[<>\\w]+:.*>)\"\n    # pattern #2: matches \"path/<id>\"\"\n    re_dir_unique = \"(\\w+/<[\\w\\(\\)\\?\\!\\.\\+]+>)\"\n    # pattern #3: matches \"path\" or \"<id>\" not appearing before \"<\"\n    re_dir_either = \"([<>\\w\\(\\)\\?\\!\\.\\+]+)(?!<)\"\n    # combine the patterns\n    uri_re_pattern = re_dir_nested + \"|\" + re_dir_unique + \"|\" + re_dir_either\n\n\n    resource_tree = {}\n    resource_tree[\"path\"] = {}\n\n    for doc in flat_resources:\n\n        if flat_resources[doc].get(\"uri\") != None:\n            this_uri = flat_resources[doc][\"uri\"]\n            uri_matches = re.findall(uri_re_pattern, flat_resources[doc][\"uri\"])\n            uri_tree = []\n\n            # treat the 'uri' string as a nested path, parsing out each directory and adding\n            # to the 'uri_tree' list from left to right\n            # leftmost element in list is root of path\n            for match in uri_matches:\n                for directory in match:\n                    if directory != \"\" and directory != api_root:\n                        branch = directory\n                        matched_group = re.search('([\\w+/]?[<:!\\?\\+\\(\\.\\*\\)>\\w]+>)', directory)\n                        if matched_group:\n                            nested_prefix = clean_angle_brackets(directory)\n                            if nested_prefix != None:\n                                branch = nested_prefix\n                        elif \"<\" in directory:\n                            branch = clean_angle_brackets(directory)\n                        uri_tree.append(branch)\n\n            # find the path within the tree\n            target = add_or_find_path(resource_tree[\"path\"], uri_tree)\n            # add the endpoint to the tree\n            target[0][\"endpoint\"] = flat_resources[doc]\n\n    sort_tree_alphabetically(resource_tree)\n    return resource_tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a RAML resource file from a Pale module s endpoint documentation.", "response": "def generate_raml_resources(module, api_root, user):\n    \"\"\"Compile a Pale module's endpoint documentation into RAML format.\n\n    RAML calls Pale endpoints 'resources'. This function converts Pale\n    endpoints into RAML resource format.\n\n    The returned string should be appended to the RAML documentation file\n    before it is returned.\n    \"\"\"\n\n    from pale import extract_endpoints, extract_resources, is_pale_module\n    if not is_pale_module(module):\n        raise ValueError(\n                \"\"\"The passed in `module` (%s) is not a pale module. `paledoc`\n                only works on modules with a `_module_type` set to equal\n                `pale.ImplementationModule`.\"\"\")\n\n    raml_resources = extract_endpoints(module)\n    raml_resource_doc_flat = { ep._route_name: document_endpoint(ep) for ep in raml_resources }\n    raml_resource_doc_tree = generate_raml_tree(raml_resource_doc_flat, api_root)\n\n    # @TODO generate this dynamically\n    pale_argument_type_map = {\n        \"StringArgument\": \"string\",\n        \"QueryCursorArgument\": \"string\",\n        \"KeyArgument\": \"string\",\n        \"IntegerArgument\": \"integer\",\n        \"BooleanArgument\": \"boolean\",\n        \"DateArgument\": \"date\",\n        \"StringChoiceArgument\": \"string\",\n        \"QueryKindsArgument\": \"string\",\n        \"StringChoiceArgument\": \"string\",\n        \"ListArgument\": \"array\"\n    }\n\n\n    def check_children_for_public_endpoints(subtree):\n        \"\"\"Recursively check a subtree to see if any of its children require permissions.\n        Returns an object with property \"public\" set to True\n        if there are children that do not require permissions, false if not.\"\"\"\n\n        found_children = {}\n        found_children[\"public\"] = False\n\n        def subroutine(subtree, found_children):\n            if subtree.get(\"path\") != None and len(subtree[\"path\"]) > 0:\n                path = subtree[\"path\"]\n                for branch in path:\n                    if path[branch].get(\"endpoint\") != None and path[branch][\"endpoint\"].get(\"requires_permission\") == None:\n                        found_children[\"public\"] = True\n                    else:\n                        subroutine(path[branch], found_children)\n\n        subroutine(subtree, found_children)\n\n        return found_children\n\n\n    def print_resource_tree(tree, output, indent, user, level=0):\n        \"\"\"Walk the tree and add the endpoint documentation to the output buffer.\n        The user will only see documentation for endpoints they have the appropriate\n        permissions for.\n        \"\"\"\n\n        # check for an endpoint at this level first\n        if tree.get(\"endpoint\") != None:\n\n            this_endpoint = tree[\"endpoint\"]\n\n            # check if user has permission to view this endpoint\n            # this is currently an on/off switch: if any endpoint has a \"@requires_permission\"\n            # decorator, user.is_admin must be True for the user to see documentation\n            # @TODO - make this permission more granular if necessary\n            if this_endpoint.get(\"requires_permission\") != None and user != None and user.is_admin or \\\n                this_endpoint.get(\"requires_permission\") == None:\n\n                indent += \"  \"\n                # add the HTTP method\n                if this_endpoint.get(\"http_method\") != None:\n                    output.write(indent + this_endpoint[\"http_method\"].lower() + \":\\n\")\n                    indent += \"  \"\n\n                    # add the description\n                    if this_endpoint.get(\"description\") != None:\n                        modified_description = clean_description(this_endpoint[\"description\"])\n                        output.write(indent + \"description: \" + modified_description + \"\\n\")\n\n                    # add queryParameters per RAML spec\n                    if this_endpoint.get(\"arguments\") != None and len(this_endpoint[\"arguments\"]) > 0:\n                        output.write(indent + \"queryParameters:\\n\")\n                        sorted_arguments = OrderedDict(sorted(this_endpoint[\"arguments\"].items(), key=lambda t: t[0]))\n                        indent += \"  \"\n\n                        for argument in sorted_arguments:\n                            output.write(indent + argument + \":\\n\")\n                            indent += \"  \"\n                            this_argument = sorted_arguments[argument]\n\n                            for arg_detail in this_argument:\n                                # check for special kinds of queryParameters\n                                this_arg_detail = this_argument[arg_detail]\n\n                                if this_arg_detail != None:\n\n                                    if arg_detail == \"default\":\n                                        default = str(this_arg_detail)\n                                        if default == \"True\" or default == \"False\":\n                                            default = default.lower()\n                                        output.write(indent + arg_detail + \": \" + default + \"\\n\")\n                                    elif arg_detail == \"description\":\n                                        output.write(indent + \"description: \" + this_arg_detail + \"\\n\")\n                                    elif arg_detail == \"type\":\n                                        if pale_argument_type_map.get(this_arg_detail) != None:\n                                            if pale_argument_type_map[this_arg_detail] == \"array\":\n                                                # @TODO set the items dynamically\n                                                output.write(indent + \"type: array\\n\")\n                                                output.write(indent + \"items: string\\n\")\n                                            else:\n                                                output.write(indent + \"type: \" + pale_argument_type_map[this_arg_detail].replace(\" \", \"_\") + \"\\n\")\n                                        else:\n                                            output.write(indent + \"type: \" + this_arg_detail.replace(\" \", \"_\") + \"\\n\")\n                                    elif arg_detail == \"required\":\n                                        output.write(indent + \"required\" + \": \" + str(this_arg_detail).lower() + \"\\n\")\n                                    elif arg_detail == \"min_length\":\n                                        output.write(indent + \"minLength: \" + str(this_arg_detail) + \"\\n\")\n                                    elif arg_detail == \"max_length\":\n                                        output.write(indent + \"maxLength: \" + str(this_arg_detail) + \"\\n\")\n                                    elif arg_detail == \"min_value\":\n                                        output.write(indent + \"minimum: \" + str(this_arg_detail) + \"\\n\")\n                                    elif arg_detail == \"max_value\":\n                                        output.write(indent + \"maximum: \" + str(this_arg_detail) + \"\\n\")\n\n                            indent = indent[:-2]    # reset indent after arg_detail\n\n                        indent = indent[:-2]    # reset indent after argument\n\n                    # add the responses\n                    if this_endpoint.get(\"returns\") != None and len(this_endpoint[\"returns\"]) > 0:\n                        output.write(indent + \"responses:\\n\")\n                        this_response = this_endpoint[\"returns\"]\n                        indent += \"  \"\n\n                        # @TODO refactor the endpoints so that they use a variable called _success\n                        # to determine the HTTP code for a successful response\n                        # (see changes made to history.py)\n\n                        if this_response.get(\"success\") != None:\n                            output.write(indent + str(this_response[\"success\"]) + \":\\n\")\n                        else:\n                            output.write(indent + \"200:\\n\")\n                        indent += \"  \"\n                        output.write(indent + \"body:\\n\")\n                        indent += \"  \"\n\n                        for res_detail in this_response:\n                            if res_detail != \"success\":\n                                if res_detail == \"resource_type\":\n                                    output.write(indent + \"type: \" + this_endpoint[\"returns\"][res_detail].replace(\" \", \"_\") + \"\\n\")\n                                elif res_detail == \"description\":\n                                    modified_description = clean_description(this_endpoint[\"returns\"][res_detail])\n                                    output.write(indent + \"description: \" + modified_description + \"\\n\")\n\n                        indent = indent [:-6]   # resent indent after responses\n\n                    indent = indent [:-2]   # reset indent after endpoint\n\n\n        # check for further branches and recurse on them\n        if tree.get(\"path\") != None and len(tree[\"path\"]) > 0:\n            # only increase the indent if we are not on root level\n            if level > 0:\n                # set the base indentation per the level we are at in the tree\n                indent = level * \"  \"\n\n            subtree = tree[\"path\"]\n\n            admin_user = user!= None and user.is_admin != None and user.is_admin\n\n            for branch in subtree:\n\n                has_public_children = check_children_for_public_endpoints(subtree[branch]).get(\"public\") == True\n\n                is_public_endpoint = subtree[branch].get(\"endpoint\") != None \\\n                    and subtree[branch][\"endpoint\"].get(\"requires_permission\") == None\n\n                # @TODO - make this permission more granular if necessary\n                # if the user is admin or this endpoint is pubic or has public children:\n                if admin_user or has_public_children or is_public_endpoint:\n                    # write branch name\n                    output.write(indent + \"/\" + branch + \":\\n\")\n                    # and continue printing the endpoints\n                    print_resource_tree(subtree[branch], output, indent, user, level=level+1)\n\n\n\n    output = StringIO()\n    indent = \"\"\n\n    print_resource_tree(raml_resource_doc_tree, output, indent, user)\n    raml_resources = output.getvalue()\n    output.close()\n    return raml_resources"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_doc_dict(module, user):\n    from pale import extract_endpoints, extract_resources, is_pale_module\n    if not is_pale_module(module):\n        raise ValueError(\n                \"\"\"The passed in `module` (%s) is not a pale module. `paledoc`\n                only works on modules with a `_module_type` set to equal\n                `pale.ImplementationModule`.\"\"\")\n\n    module_endpoints = extract_endpoints(module)\n    ep_doc = { ep._route_name: document_endpoint(ep) for ep \\\n            in module_endpoints }\n\n    ep_doc_filtered = {}\n\n    for endpoint in ep_doc:\n        # check if user has permission to view this endpoint\n        # this is currently an on/off switch: if any endpoint has a \"@requires_permission\"\n        # decorator, user.is_admin must be True for the user to see documentation\n        # @TODO - make this permission more granular if necessary\n\n        if ep_doc[endpoint].get(\"requires_permission\") != None and user != None and user.is_admin or \\\n            ep_doc[endpoint].get(\"requires_permission\") == None:\n            ep_doc_filtered[endpoint] = ep_doc[endpoint]\n\n    module_resources = extract_resources(module)\n    res_doc = { r._value_type: document_resource(r) for r \\\n            in module_resources }\n\n    return {'endpoints': ep_doc_filtered,\n            'resources': res_doc}", "response": "Compile a Pale module s documentation into a python dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef document_endpoint(endpoint):\n    descr = clean_description(py_doc_trim(endpoint.__doc__))\n    docs = {\n        'name': endpoint._route_name,\n        'http_method': endpoint._http_method,\n        'uri': endpoint._uri,\n        'description': descr,\n        'arguments': extract_endpoint_arguments(endpoint),\n        'returns': format_endpoint_returns_doc(endpoint),\n    }\n    if hasattr(endpoint, \"_success\"):\n        docs[\"success\"] = endpoint._success\n    if hasattr(endpoint, \"_requires_permission\"):\n        docs[\"requires_permission\"] = endpoint._requires_permission\n    return docs", "response": "Extract the full documentation dictionary from the endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts the argument documentation from the endpoint.", "response": "def extract_endpoint_arguments(endpoint):\n    \"\"\"Extract the argument documentation from the endpoint.\"\"\"\n\n    ep_args = endpoint._arguments\n    if ep_args is None:\n        return None\n\n    arg_docs = { k: format_endpoint_argument_doc(a) \\\n            for k, a in ep_args.iteritems() }\n    return arg_docs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn documentation about the argument that an endpoint accepts.", "response": "def format_endpoint_argument_doc(argument):\n    \"\"\"Return documentation about the argument that an endpoint accepts.\"\"\"\n    doc = argument.doc_dict()\n\n    # Trim the strings a bit\n    doc['description'] = clean_description(py_doc_trim(doc['description']))\n    details = doc.get('detailed_description', None)\n    if details is not None:\n        doc['detailed_description'] = clean_description(py_doc_trim(details))\n\n    return doc"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef format_endpoint_returns_doc(endpoint):\n    description = clean_description(py_doc_trim(endpoint._returns._description))\n    return {\n        'description': description,\n        'resource_name': endpoint._returns._value_type,\n        'resource_type': endpoint._returns.__class__.__name__\n    }", "response": "Return documentation about the resource that an endpoint returns."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates formatted version of body text.", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Create formatted version of body text.\n        \"\"\"\n        self.body_formatted = sanetize_text(self.body)\n        super(Contact, self).save()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current membership for this org or None if there is none.", "response": "def get_current_membership_for_org(self, account_num, verbose=False):\n        \"\"\"Return a current membership for this org, or, None if\n        there is none.\n        \"\"\"\n        all_memberships = self.get_memberships_for_org(\n            account_num=account_num,\n            verbose=verbose)\n        # Look for first membership that hasn't expired yet.\n        for membership in all_memberships:\n            if (membership.expiration_date and\n                membership.expiration_date > datetime.datetime.now()):  # noqa\n                return membership  # noqa\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve all memberships associated with an organization.", "response": "def get_memberships_for_org(self, account_num, verbose=False):\n        \"\"\"\n        Retrieve all memberships associated with an organization,\n        ordered by expiration date.\n        \"\"\"\n        if not self.client.session_id:\n            self.client.request_session()\n\n        query = \"SELECT Objects() FROM Membership \" \\\n                \"WHERE Owner = '%s' ORDER BY ExpirationDate\" % account_num\n\n        membership_list = self.get_long_query(query, verbose=verbose)\n        return membership_list or []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget all memberships updated since since_when", "response": "def get_all_memberships(\n            self, limit_to=100, max_calls=None, parameters=None,\n            since_when=None, start_record=0, verbose=False):\n        \"\"\"\n        Retrieve all memberships updated since \"since_when\"\n\n        Loop over queries of size limit_to until either a non-full queryset\n        is returned, or max_depth is reached (used in tests). Then the\n        recursion collapses to return a single concatenated list.\n        \"\"\"\n        if not self.client.session_id:\n            self.client.request_session()\n\n        query = \"SELECT Objects() FROM Membership\"\n\n        # collect all where parameters into a list of\n        # (key, operator, value) tuples\n        where_params = []\n\n        if parameters:\n            for k, v in parameters.items():\n                where_params.append((k, \"=\", v))\n\n        if since_when:\n            d = datetime.date.today() - datetime.timedelta(days=since_when)\n            where_params.append(\n                ('LastModifiedDate', \">\", \"'%s 00:00:00'\" % d))\n\n        if where_params:\n            query += \" WHERE \"\n            query += \" AND \".join(\n                [\"%s %s %s\" % (p[0], p[1], p[2]) for p in where_params])\n\n        query += \" ORDER BY LocalID\"\n\n        # note, get_long_query is overkill when just looking at\n        # one org, but it still only executes once\n        # `get_long_query` uses `ms_object_to_model` to return Organizations\n        membership_list = self.get_long_query(\n            query, limit_to=limit_to, max_calls=max_calls,\n            start_record=start_record, verbose=verbose)\n\n        return membership_list or []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving all membership products", "response": "def get_all_membership_products(self, verbose=False):\n        \"\"\"\n        Retrieves membership product objects\n        \"\"\"\n        if not self.client.session_id:\n            self.client.request_session()\n\n        query = \"SELECT Objects() FROM MembershipDuesProduct\"\n\n        membership_product_list = self.get_long_query(query, verbose=verbose)\n        return membership_product_list or []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef chromedriver_element_center_patch():\n\n    patch_name = \"_selenic_chromedriver_element_center_patched\"\n    if getattr(ActionChains, patch_name, None):\n        return  # We've patched ActionChains already!!\n\n    # This is the patched method, which uses getBoundingClientRect\n    # to get the location of the center.\n    def move_to_element(self, el):\n        pos = self._driver.execute_script(\"\"\"\n        var rect = arguments[0].getBoundingClientRect();\n        return { x: rect.width / 2, y: rect.height / 2};\n        \"\"\", el)\n        self.move_to_element_with_offset(el, pos[\"x\"], pos[\"y\"])\n        return self\n\n    old_init = ActionChains.__init__\n\n    def init(self, driver):\n        old_init(self, driver)\n\n        # Patch the instance, only if the driver needs it.\n        if getattr(driver, CHROMEDRIVER_ELEMENT_CENTER_PATCH_FLAG, None):\n            self.move_to_element = types.MethodType(move_to_element, self)\n\n    ActionChains.__init__ = init\n\n    # Mark ActionChains as patched!\n    setattr(ActionChains, patch_name, True)", "response": "Patch ActionChains to move to the center of the element."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a Selenium driver based on the configuration file passed in.", "response": "def get_driver(self, desired_capabilities=None):\n        \"\"\"\n        Creates a Selenium driver on the basis of the configuration file\n        upon which this object was created.\n\n        :param desired_capabilities: Capabilities that the caller\n            desires to override. This have priority over those\n            capabilities that are set by the configuration file passed\n            to the builder.\n        :type desired_capabilities: class:`dict`\n        :returns: A driver.\n        :raises ValueError: When it can't figure out how to create a\n                            browser as specified by the BROWSER\n                            configuration variable.\n        \"\"\"\n        override_caps = desired_capabilities or {}\n\n        desired_capabilities = \\\n            self.config.make_selenium_desired_capabilities()\n        desired_capabilities.update(override_caps)\n        browser_string = self.config.browser\n\n        chromedriver_version = None\n        if self.remote:\n            driver = self.remote_service.build_driver(desired_capabilities)\n            # There is no equivalent for BrowserStack.\n            if browser_string == \"CHROME\" and \\\n               self.remote_service.name == \"saucelabs\":\n                chromedriver_version = \\\n                    desired_capabilities.get(\"chromedriver-version\", None)\n                if chromedriver_version is None:\n                    raise ValueError(\n                        \"when using Chrome, you must set a \"\n                        \"``chromedriver-version`` capability so that Selenic \"\n                        \"can detect which version of Chromedriver will \"\n                        \"be used.\")\n        else:\n            if browser_string == \"CHROME\":\n                chromedriver_path = self.local_conf[\"CHROMEDRIVER_PATH\"]\n                driver = webdriver.Chrome(\n                    chromedriver_path,\n                    chrome_options=self.local_conf.get(\"CHROME_OPTIONS\"),\n                    desired_capabilities=desired_capabilities,\n                    service_log_path=self.local_conf[\"SERVICE_LOG_PATH\"],\n                    service_args=self.local_conf.get(\"SERVICE_ARGS\"))\n                version_line = subprocess.check_output(\n                    [chromedriver_path, \"--version\"])\n                version_str = re.match(ur\"^ChromeDriver (\\d+\\.\\d+)\",\n                                       version_line).group(1)\n                chromedriver_version = StrictVersion(version_str)\n            elif browser_string == \"FIREFOX\":\n                profile = self.local_conf.get(\"FIREFOX_PROFILE\") or \\\n                    FirefoxProfile()\n                binary = self.local_conf.get(\"FIREFOX_BINARY\") or \\\n                    FirefoxBinary()\n                driver = webdriver.Firefox(profile, binary,\n                                           capabilities=desired_capabilities)\n            elif browser_string == \"INTERNETEXPLORER\":\n                driver = webdriver.Ie()\n            elif browser_string == \"OPERA\":\n                driver = webdriver.Opera()\n            else:\n                # SAFARI\n                # HTMLUNIT\n                # HTMLUNITWITHJS\n                # IPHONE\n                # IPAD\n                # ANDROID\n                # PHANTOMJS\n                raise ValueError(\"can't start a local \" + browser_string)\n\n            # Check that what we get is what the config wanted...\n            driver_caps = NormalizedCapabilities(driver.desired_capabilities)\n            browser_version = \\\n                re.sub(r\"\\..*$\", \"\", driver_caps[\"browserVersion\"])\n\n            if driver_caps[\"platformName\"].upper() != self.config.platform:\n                raise ValueError(\"the platform you want is not the one \"\n                                 \"you are running selenic on\")\n\n            if browser_version != self.config.version:\n                raise ValueError(\"the version installed is not the one \"\n                                 \"you wanted\")\n\n        # On BrowserStack we cannot set the version of chromedriver or\n        # query it. So we make the reasonable assuption that the\n        # version of chromedriver is greater than 2.13. (There have\n        # been at least 7 releases after 2.13 at the time of writing.)\n        if (self.remote_service and\n            self.remote_service.name == \"browserstack\") or \\\n           (chromedriver_version is not None and\n                chromedriver_version > StrictVersion(\"2.13\")):\n            # We patch ActionChains.\n            chromedriver_element_center_patch()\n            # We need to mark the driver as needing the patch.\n            setattr(driver, CHROMEDRIVER_ELEMENT_CENTER_PATCH_FLAG, True)\n\n        driver = self.patch(driver)\n        return driver"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the environment variable used by the Firefox binary instance.", "response": "def update_ff_binary_env(self, variable):\n        \"\"\"\n        If a ``FIREFOX_BINARY`` was specified, this method updates an\n        environment variable used by the ``FirefoxBinary`` instance to\n        the current value of the variable in the environment.\n\n        This method is a no-op if ``FIREFOX_BINARY`` has not been\n        specified or if the configured browser is not Firefox.\n\n        A common use-case for this method is updating ``DISPLAY`` once\n        an Xvfb or Xephyr instance has been launched. Typically, by\n        the time these displays are launched, the configuration file\n        has already been loaded and whatever ``FirefoxBinary``\n        instance was created for ``FIREFOX_BINARY`` has a stale\n        ``DISPLAY`` value.\n\n        :param variable: The name of the variable to update.\n        :type variable: :class:`str`\n        \"\"\"\n        if self.config.browser != 'FIREFOX':\n            return\n\n        binary = self.local_conf.get('FIREFOX_BINARY')\n        if binary is None:\n            return\n\n        # pylint: disable=protected-access\n        binary._firefox_env[variable] = os.environ[variable]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates the value of the key field against the choices and return a new error object.", "response": "def validate(self, value, model=None, context=None):\n        \"\"\"\n        Validate\n        Perform value validation against validation settings and return\n        error object.\n\n        :param value:           str, value to check\n        :param model:           parent model being validated\n        :param context:         object or None, validation context\n        :return:                shiftschema.result.Error\n        \"\"\"\n\n        if value not in self.choices:\n            return Error(self.invalid_choice)\n\n        # success otherwise\n        return Error()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef result_template(self, *command_tokens, **command_env):\n\t\tresult = WCommandResultTemplate(self.template())\n\t\tresult.update_context(**self.template_context())\n\t\treturn result", "response": "Generate template result. command_tokens and command_env arguments are used for template\n\t\tdetailing\n\n\t\t:param command_tokens: same as command_tokens in :meth:`.WCommandProto.match` and \\\n\t\t:meth:`.WCommandProto.exec` methods (so as :meth:`.WCommand._exec`)\n\t\t:param command_env: same as command_env in :meth:`.WCommandProto.match` and \\\n\t\t:meth:`.WCommandProto.exec` methods (so as :meth:`.WCommand._exec`)\n\n\t\t:return: WCommandResultTemplate"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate the value of a key - value pair.", "response": "def validate(self, value, model=None, context=None):\n        \"\"\"\n        Validate\n        Perform value validation and return result\n\n        :param value:           value to check\n        :param model:           parent model being validated\n        :param context:         object or None, validation context\n        :return:                shiftschema.results.SimpleResult\n        \"\"\"\n        value = str(value)\n        regex = self.regex(\n            protocols=self.protocols,\n            localhost=self.localhost\n        )\n\n        regex = re.compile(regex, flags=self.flags)\n        match = regex.match(value)\n\n        # return error\n        if not match:\n            return Error(self.url_invalid)\n\n        # success otherwise\n        return Error()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef regex(self, protocols, localhost=True):\n        p = r\"^\"\n\n        # protocol\n        p += r\"(?:(?:(?:{}):)?//)\".format('|'.join(protocols))\n\n        # basic auth (optional)\n        p += r\"(?:\\S+(?::\\S*)?@)?\"\n\n        p += r\"(?:\"\n\n        # ip exclusion: private and local networks\n        p += r\"(?!(?:10|127)(?:\\.\\d{1,3}){3})\"\n        p += r\"(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})\"\n        p += r\"(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})\"\n\n        # ip excluding loopback (0.0.0.0), reserved space (244.0.0.0)\n        # and network/broadcast addresses\n        p += r\"(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])\"\n        p += r\"(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}\"\n        p += r\"(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))\"\n        p += r\"|\"\n\n        # hostname\n        p += r\"(?:\"\n        p += r\"(?:\"\n        p += r\"[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?\"\n        p += r\"[a-z0-9\\u00a1-\\uffff]\"\n        p += r\"\\.\" if not localhost else r\"[\\.]?|localhost\"\n\n\n        p += r\")+\"\n\n        # tld\n        p += r\"(?:[a-z\\u00a1-\\uffff]{2,}\\.?)\"\n        p += r\")\"\n\n        # port (optional)\n        p += r\"(?::\\d{2,5})?\"\n\n        # path (optional)\n        p += r\"(?:[/?#]\\S*)?\"\n\n        p += r\"$\"\n        return p", "response": "Regex for the URL validation regex."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef layers_names(self):\n\t\treturn list(self.__class__.__builtin_layers__.keys()) + list(self.__layers.keys())", "response": "Return a list of all layers names in this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef layer(self, layer_name):\n\t\tif layer_name in self.__layers.keys():\n\t\t\treturn self.__layers[layer_name]\n\t\telif layer_name in self.__class__.__builtin_layers__:\n\t\t\treturn self.__class__.__builtin_layers__[layer_name]\n\n\t\traise RuntimeError('Invalid layer name')", "response": "returns a layer object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nappending given layers to this onion", "response": "def add_layers(self, *layers):\n\t\t\"\"\" Append given layers to this onion\n\n\t\t:param layers: layer to add\n\t\t:return: None\n\t\t\"\"\"\n\t\tfor layer in layers:\n\t\t\tif layer.name() in self.__layers.keys():\n\t\t\t\traise ValueError('Layer \"%s\" already exists' % layer.name())\n\t\t\tself.__layers[layer.name()] = layer"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndecodes a byte string into a unicode object.", "response": "def safely_decode(unicode_or_str, encoding='utf-8'):\n  ''' Decodes byte <str> into <unicode>. Ignores any non-utf8 chars in <str>s '''\n  if isinstance(unicode_or_str, unicode):\n    ustr = unicode_or_str\n  elif isinstance(unicode_or_str, str):\n    ustr = unicode_or_str.decode(encoding, 'ignore')\n  else:\n    raise Exception(u'Not of type unicode or str')\n\n  return ustr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencoding unicode into byte string.", "response": "def safely_encode(unicode_or_str, encoding='utf-8'):\n  ''' Encodes <unicode> into byte <str>. Replaces any non utf8 chars '''\n  if isinstance(unicode_or_str, unicode):\n    rstr = unicode_or_str.encode(encoding, 'replace')\n  elif isinstance(unicode_or_str, str):\n    rstr = unicode_or_str\n  else:\n    raise Exception(u'Not of type unicode or str')\n\n  return rstr"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a mapping of a list of objects indexed by the given attribute.", "response": "def index(objects, attr):\n    \"\"\"\n    Generate a mapping of a list of objects indexed by the given attr.\n\n    Parameters\n    ----------\n    objects : :class:`list`, iterable\n    attr : string\n        The attribute to index the list of objects by\n\n    Returns\n    -------\n    dictionary : dict\n        keys are the value of each object's attr, and values are from objects\n\n    Example\n    -------\n\n    class Person(object):\n        def __init__(self, name, email, age):\n            self.name = name\n            self.email = email\n            self.age = age\n\n    people = [\n        Person('one', 'one@people.com', 1),\n        Person('two', 'two@people.com', 2),\n        Person('three', 'three@people.com', 3)\n    ]\n\n    by_email = index(people, 'email')\n    by_name = index(people, 'name')\n\n    assert by_name['one'] is people[0]\n    assert by_email['two@people.com'] is people[1]\n\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        return {getattr(obj, attr): obj for obj in objects}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a typedef with this engine.", "response": "def register(self, typedef):\n        \"\"\"\n        Add the typedef to this engine if it is compatible.\n\n        After registering a :class:`~TypeDefinition`, it will not be bound\n        until :meth:`~TypeEngine.bind` is next called.\n\n        Nothing will happen when register is called with a typedef that is\n        pending binding or already bound.  Otherwise, the engine will ensure it\n        is compatible with the type using :meth:`~TypeEngine.is_compatible`\n        before adding it to the set of unbound types.\n\n        Parameters\n        ----------\n        typedef : :class:`~TypeDefinition`\n            The typedef to register with this engine\n\n        Raises\n        ------\n        exc : :class:`ValueError`\n            If :meth:`~TypeEngine.is_compatible` is falsey\n\n        \"\"\"\n        if typedef in self.bound_types:\n            return\n        if not self.is_compatible(typedef):\n            raise ValueError(\"Incompatible type {} for engine {}\".format(\n                typedef, self))\n        if typedef not in self.unbound_types:\n            self.unbound_types.add(typedef)\n            typedef._register(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbind all unbound types to the engine and passes in the config dictionary.", "response": "def bind(self, **config):\n        \"\"\"\n        Bind all unbound types to the engine.\n\n        Bind each unbound typedef to the engine, passing in the engine and\n        :attr:`config`.  The resulting ``load`` and ``dump`` functions can\n        be found under ``self.bound_types[typedef][\"load\"]`` and\n        ``self.bound_types[typedef][\"dump\"], respectively.\n\n        Parameters\n        ----------\n        config : dict, optional\n            Engine-binding configuration to pass to each typedef that will be\n            bound.  Examples include floating-point precision values, maximum\n            lengths for strings, or any other translation constraints/settings\n            that a typedef needs to construct a load/dump function pair.\n\n        \"\"\"\n        while self.unbound_types:\n            typedef = self.unbound_types.pop()\n            try:\n                load, dump = typedef.bind(self, **config)\n                self.bound_types[typedef] = {\n                    \"load\": load, \"dump\": dump\n                }\n            except Exception:\n                self.unbound_types.add(typedef)\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self, typedef, value, **kwargs):\n        try:\n            bound_type = self.bound_types[typedef]\n        except KeyError:\n            raise DeclareException(\n                \"Can't load unknown type {}\".format(typedef))\n        else:\n            # Don't need to try/catch since load/dump are bound together\n            return bound_type[\"load\"](value, **kwargs)", "response": "Loads the value of a typedef into the loaded value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef random_bits(bits_count):\n\tbytes_count = int(math.ceil(bits_count / 8))\n\trandom_value = int.from_bytes(os.urandom(bytes_count), byteorder=sys.byteorder)\n\tresult_bits = bytes_count * 8\n\n\tif result_bits > bits_count:\n\t\trandom_value = (random_value >> (result_bits - bits_count))\n\n\treturn random_value", "response": "Random generator (PyCrypto getrandbits wrapper). The result is a non-negative value.\n\n\t:param bits_count: random bits to generate\n\t:return: int"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef random_int(maximum_value):\n\tif maximum_value == 0:\n\t\treturn 0\n\telif maximum_value == 1:\n\t\treturn random_bits(1)\n\n\tbits = math.floor(math.log2(maximum_value))\n\tresult = random_bits(bits) + random_int(maximum_value - ((2 ** bits) - 1))\n\treturn result", "response": "Random generator (PyCrypto getrandbits wrapper). The result is a non-negative value.\n\n\t:param maximum_value: maximum integer value\n\t:return: int"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_configdir(name):\n    configdir = os.environ.get('%sCONFIGDIR' % name.upper())\n    if configdir is not None:\n        return os.path.abspath(configdir)\n\n    p = None\n    h = _get_home()\n    if ((sys.platform.startswith('linux') or\n         sys.platform.startswith('darwin')) and h is not None):\n        p = os.path.join(h, '.config/' + name)\n    elif h is not None:\n        p = os.path.join(h, '.' + name)\n\n    if not os.path.exists(p):\n        os.makedirs(p)\n    return p", "response": "Returns the string representing the configuration directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_logging(default_path=None, default_level=logging.INFO,\n                  env_key=None):\n    \"\"\"\n    Setup logging configuration\n\n    Parameters\n    ----------\n    default_path: str\n        Default path of the yaml logging configuration file. If None, it\n        defaults to the 'logging.yaml' file in the config directory\n    default_level: int\n        Default: :data:`logging.INFO`. Default level if default_path does not\n        exist\n    env_key: str\n        environment variable specifying a different logging file than\n        `default_path` (Default: 'LOG_CFG')\n\n    Returns\n    -------\n    path: str\n        Path to the logging configuration file\n\n    Notes\n    -----\n    Function taken from\n    http://victorlin.me/posts/2012/08/26/good-logging-practice-in-python\"\"\"\n    path = default_path or os.path.join(\n        os.path.dirname(__file__), 'logging.yaml')\n    value = os.getenv(env_key, None) if env_key is not None else None\n    home = _get_home()\n    if value:\n        path = value\n    if os.path.exists(path):\n        with open(path, 'rt') as f:\n            config = yaml.load(f.read())\n        for handler in config.get('handlers', {}).values():\n            if '~' in handler.get('filename', ''):\n                handler['filename'] = handler['filename'].replace(\n                    '~', home)\n        logging.config.dictConfig(config)\n    else:\n        path = None\n        logging.basicConfig(level=default_level)\n    return path", "response": "Setup logging configuration for the current application."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndumps the stream from an OrderedDict.", "response": "def ordered_yaml_dump(data, stream=None, Dumper=None, **kwds):\n    \"\"\"Dumps the stream from an OrderedDict.\n    Taken from\n\n    http://stackoverflow.com/questions/5121931/in-python-how-can-you-load-yaml-\n    mappings-as-ordereddicts\"\"\"\n    Dumper = Dumper or yaml.Dumper\n\n    class OrderedDumper(Dumper):\n        pass\n\n    def _dict_representer(dumper, data):\n        return dumper.represent_mapping(\n            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,\n            data.items())\n    OrderedDumper.add_representer(OrderedDict, _dict_representer)\n    return yaml.dump(data, stream, OrderedDumper, **kwds)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the file fname and make sure it can be done in parallel", "response": "def safe_load(fname):\n    \"\"\"\n    Load the file fname and make sure it can be done in parallel\n\n    Parameters\n    ----------\n    fname: str\n        The path name\n    \"\"\"\n    lock = fasteners.InterProcessLock(fname + '.lck')\n    lock.acquire()\n    try:\n        with open(fname) as f:\n            return ordered_yaml_load(f)\n    except:\n        raise\n    finally:\n        lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef project_map(self):\n        # first update with the experiments in the memory (the others should\n        # already be loaded within the :attr:`exp_files` attribute)\n        for key, val in self.items():\n            if isinstance(val, dict):\n                l = self._project_map[val['project']]\n            elif isinstance(val, Archive):\n                l = self._project_map[val.project]\n            else:\n                continue\n            if key not in l:\n                l.append(key)\n        return self._project_map", "response": "A mapping from project name to experiments"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exp_files(self):\n        ret = OrderedDict()\n        # restore the order of the experiments\n        exp_file = self.exp_file\n        if osp.exists(exp_file):\n            for key, val in safe_load(exp_file).items():\n                ret[key] = val\n        for project, d in self.projects.items():\n            project_path = d['root']\n            config_path = osp.join(project_path, '.project')\n            if not osp.exists(config_path):\n                continue\n            for fname in glob.glob(osp.join(config_path, '*.yml')):\n                if fname == '.project.yml':\n                    continue\n                exp = osp.splitext(osp.basename(fname))[0]\n                if not isinstance(ret.get(exp), Archive):\n                    ret[exp] = osp.join(config_path, exp + '.yml')\n                if exp not in self._project_map[project]:\n                    self._project_map[project].append(exp)\n        return ret", "response": "A mapping from experiment to configuration file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the experiment configuration to the experiment configuration file.", "response": "def save(self):\n        \"\"\"Save the experiment configuration\n\n        This method stores the configuration of each of the experiments in a\n        file ``'<project-dir>/.project/<experiment>.yml'``, where\n        ``'<project-dir>'`` corresponds to the project directory of the\n        specific ``'<experiment>'``. Furthermore it dumps all experiments to\n        the :attr:`exp_file` configuration file.\n        \"\"\"\n        for exp, d in dict(self).items():\n            if isinstance(d, dict):\n                project_path = self.projects[d['project']]['root']\n                d = self.rel_paths(copy.deepcopy(d))\n                fname = osp.join(project_path, '.project', exp + '.yml')\n                if not osp.exists(osp.dirname(fname)):\n                    os.makedirs(osp.dirname(fname))\n                safe_dump(d, fname, default_flow_style=False)\n        exp_file = self.exp_file\n        # to be 100% sure we do not write to the file from multiple processes\n        lock = fasteners.InterProcessLock(exp_file + '.lck')\n        lock.acquire()\n        safe_dump(OrderedDict((exp, val if isinstance(val, Archive) else None)\n                              for exp, val in self.items()),\n                  exp_file, default_flow_style=False)\n        lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_ordereddict(self):\n        if six.PY2:\n            d = OrderedDict()\n            copied = dict(self)\n            for key in self:\n                d[key] = copied[key]\n        else:\n            d = OrderedDict(self)\n        return d", "response": "Convenience method to convert this object into an OrderedDict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove(self, experiment):\n        try:\n            project_path = self.projects[self[experiment]['project']]['root']\n        except KeyError:\n            return\n        config_path = osp.join(project_path, '.project', experiment + '.yml')\n        for f in [config_path, config_path + '~', config_path + '.lck']:\n            if os.path.exists(f):\n                os.remove(f)\n        del self[experiment]", "response": "Remove the configuration of an experiment"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfixes the paths in the given dictionary to get absolute paths", "response": "def fix_paths(self, d, root=None, project=None):\n        \"\"\"\n        Fix the paths in the given dictionary to get absolute paths\n\n        Parameters\n        ----------\n        %(ExperimentsConfig.fix_paths.parameters)s\n\n        Returns\n        -------\n        %(ExperimentsConfig.fix_paths.returns)s\n\n        Notes\n        -----\n        d is modified in place!\"\"\"\n        if root is None and project is None:\n            project = d.get('project')\n            if project is not None:\n                root = self[project]['root']\n            else:\n                root = d['root']\n        elif root is None:\n            root = self[project]['root']\n        elif project is None:\n            pass\n        paths = self.paths\n        for key, val in d.items():\n            if isinstance(val, dict):\n                d[key] = self.fix_paths(val, root, project)\n            elif key in paths:\n                val = d[key]\n                if isinstance(val, six.string_types) and not osp.isabs(val):\n                    d[key] = osp.join(root, val)\n                elif (isinstance(utils.safe_list(val)[0], six.string_types) and\n                      not osp.isabs(val[0])):\n                    for i in range(len(val)):\n                        val[i] = osp.join(root, val[i])\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self):\n        project_paths = OrderedDict()\n        for project, d in OrderedDict(self).items():\n            if isinstance(d, dict):\n                project_path = d['root']\n                fname = osp.join(project_path, '.project', '.project.yml')\n                if not osp.exists(osp.dirname(fname)):\n                    os.makedirs(osp.dirname(fname))\n                if osp.exists(fname):\n                    os.rename(fname, fname + '~')\n                d = self.rel_paths(copy.deepcopy(d))\n                safe_dump(d, fname, default_flow_style=False)\n                project_paths[project] = project_path\n            else:\n                project_paths = self.project_paths[project]\n        self.project_paths = project_paths\n        safe_dump(project_paths, self.all_projects, default_flow_style=False)", "response": "Save the project configuration for each project and all the project paths that are in the hard drive."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving the entire configuration files", "response": "def save(self):\n        \"\"\"\n        Save the entire configuration files\n        \"\"\"\n        self.projects.save()\n        self.experiments.save()\n        safe_dump(self.global_config, self._globals_file,\n                  default_flow_style=False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reverseCommit(self):\n\n        # Do nothing if no selection was available upon construction.\n        if self.selectionPos is None:\n            return\n\n        # Insert the text at the specified position.\n        line, col = self.selectionPos[:2]\n        self.baseClass.insertAt(self.removedText, line, col)\n\n        # Add the styling information.\n        self.qteWidget.SCISetStylingEx(line, col, self.style)\n\n        # Place the cursor at the end of the selection.\n        line, col = self.selectionPos[2:]\n        self.qteWidget.setCursorPosition(line, col)", "response": "Reinsert the killed word."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reverseCommit(self):\n        if self.selectionPosOld is None:\n            return\n\n        # Shorthand.\n        wid = self.qteWidget\n\n        # Select, backup, and delete the selection.\n        wid.setSelection(*self.selectionPosNew)\n        self.baseClass.replaceSelectedText(self.oldText)\n\n        # Add the styling information.\n        line, col = self.selectionPosNew[0:2]\n        wid.SCISetStylingEx(line, col, self.oldStyle)\n        wid.setCursorPosition(line, col)", "response": "Reinsert the killed word."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreinsert the killed word.", "response": "def reverseCommit(self):\n        \"\"\"\n        Reinsert the killed word.\n        \"\"\"\n        # Ensure that the cursor position is valid.\n        if not self.qteWidget.isSelectionPositionValid(self.selectionPos):\n            msg = ('Cannot undo \"insert\" operation because the selection'\n                   'position is invalid. The document is possibly in '\n                   'an inconsistent state. Please save and re-open.')\n            qteMain.qteLogger.critical(msg)\n            return\n\n        # Select and delete the inserted text.\n        self.qteWidget.setSelection(*self.selectionPos)\n        self.baseClass.removeSelectedText()\n        line, col = self.selectionPos[0:2]\n        self.qteWidget.setCursorPosition(line, col)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reverseCommit(self):\n        self.baseClass.setText(self.oldText)\n        self.qteWidget.SCISetStylingEx(0, 0, self.style)", "response": "Revert the current text to the original text."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef placeCursor(self, line, col):\n        num_lines, num_col = self.qteWidget.getNumLinesAndColumns()\n\n        # Place the cursor at the specified position if possible.\n        if line >= num_lines:\n            line, col = num_lines, num_col\n        else:\n            text = self.qteWidget.text(line)\n            if col >= len(text):\n                col = len(text) - 1\n\n        self.qteWidget.setCursorPosition(line, col)", "response": "Try to place the cursor in line at col. If possible place it at the end."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef commit(self):\n        if self.textAfter is None:\n            # If this is the first 'commit' call then do not make\n            # any changes but store the current document state\n            # and its style.\n            line, col = self.qteWidget.getNumLinesAndColumns()\n            text, style = self.qteWidget.SCIGetStyledText((0, 0, line, col))\n            self.styleAfter = style\n            self.textAfter = text.decode('utf-8')\n        else:\n            # Put the document into the 'after' state.\n            self.baseClass.setText(self.textAfter)\n            self.qteWidget.SCISetStylingEx(0, 0, self.styleAfter)\n        self.placeCursor(*self.origPosition)", "response": "Commit the current state of the current state of the current class."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreverses the changes made to the base class.", "response": "def reverseCommit(self):\n        \"\"\"\n        Put the document into the 'before' state.\n        \"\"\"\n        # Put the document into the 'before' state.\n        self.baseClass.setText(self.textBefore)\n        self.qteWidget.SCISetStylingEx(0, 0, self.styleBefore)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qteSetMark(self, markerID=0, line: int=None, col: int=None):\n\n        # Query the line- and column number unless provided.\n        if (line is None) and (col is None):\n            line, col = self.getCursorPosition()\n        elif line is None:\n            line, _ = self.getCursorPosition()\n        elif col is None:\n            _, col = self.getCursorPosition()\n        else:\n            pass\n\n        self.qteMarkers[markerID] = (line, col)\n        return (line, col)", "response": "Set the line and column index of a specific marker."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an empty element from the given MIME data.", "response": "def fromMimeData(self, data):\n        \"\"\"\n        Paste the clipboard data at the current cursor position.\n\n        This method also adds another undo-object to the undo-stack.\n\n        ..note: This method forcefully interrupts the ``QsciInternal``\n                pasting mechnism by returning an empty MIME data element.\n                This is not an elegant implementation, but the best I\n                could come up with at the moment.\n\n        \"\"\"\n        # Only insert the element if it is available in plain text.\n        if data.hasText():\n            self.insert(data.text())\n\n        # Tell the underlying QsciScintilla object that the MIME data\n        # object was indeed empty.\n        return (QtCore.QByteArray(), False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the given line and column denote a valid entry in the document.", "response": "def isPositionValid(self, line: int, column: int):\n        \"\"\"\n        Return **True** if ``line`` and ``column`` denote a valid\n        position.\n\n        |Args|\n\n        * ``line`` (**int**): line number\n        * ``column`` (**int**): column in line ``line``\n\n        |Returns|\n\n        **bool**: **True** if ``line`` and ``column`` specify a\n          valid point in the document, **False** otherwise.\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n        if (line < 0) or (column < 0):\n            return False\n\n        last_line, last_col = self.getNumLinesAndColumns()\n        if line > last_line:\n            return False\n\n        if column <= len(self.text(line)):\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isSelectionPositionValid(self, selPos: tuple):\n        if selPos is None:\n            return False\n        if len(selPos) != 4:\n            return False\n        check1 = self.isPositionValid(*selPos[:2])\n        check2 = self.isPositionValid(*selPos[2:])\n        if check1 and check2:\n            return True\n        else:\n            return False", "response": "Returns True if the start - and end position denote valid\n        positions within the document."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nundoes safe wrapper for the native keyPressEvent method.", "response": "def keyPressEvent(self, keyEvent: QtGui.QKeyEvent):\n        \"\"\"\n        Undo safe wrapper for the native ``keyPressEvent`` method.\n\n        |Args|\n\n        * ``keyEvent`` (**QKeyEvent**): the key event to process.\n\n        |Returns|\n\n        **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        undoObj = UndoInsert(self, keyEvent.text())\n        self.qteUndoStack.push(undoObj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replaceSelectedText(self, text: str):\n        undoObj = UndoReplaceSelectedText(self, text)\n        self.qteUndoStack.push(undoObj)", "response": "Undo safe wrapper for the native replaceSelectedText method."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef insert(self, text: str):\n        undoObj = UndoInsert(self, text)\n        self.qteUndoStack.push(undoObj)", "response": "Insert a new entry in the current entry set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insertAt(self, text: str, line: int, col: int):\n        undoObj = UndoInsertAt(self, text, line, col)\n        self.qteUndoStack.push(undoObj)", "response": "Wrapper for the native insertAt method."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, text: str):\n        pos = self.getCursorPosition()\n        line, col = self.getNumLinesAndColumns()\n        undoObj = UndoInsertAt(self, text, line, col)\n        self.qteUndoStack.push(undoObj)\n        self.setCursorPosition(*pos)", "response": "Wrapper for the native append method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setText(self, text: str):\n        undoObj = UndoSetText(self, text)\n        self.qteUndoStack.push(undoObj)", "response": "Set the text at the specified position."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the styled text of the current line and column.", "response": "def SCIGetStyledText(self, selectionPos: tuple):\n        \"\"\"\n        Pythonic wrapper for the SCI_GETSTYLEDTEXT command.\n\n        For example, to get the raw text and styling bits\n        for the first five characters in the widget use::\n\n            text, style = SCIGetStyledText((0, 0, 0, 5))\n            print(text.decode('utf-8'))\n\n        |Args|\n\n        * ``selectionPos`` (**tuple**): selection position in the\n          form of (start_line, start_col, end_line, end_col).\n\n        |Returns|\n\n        **tuple** of two ``bytearrays``. The first contains the\n          the character bytes and the second the Scintilla styling\n          information.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n\n        # Sanity check.\n        if not self.isSelectionPositionValid(selectionPos):\n            return None\n\n        # Convert the start- and end point of the selection into\n        # stream offsets. Ensure that start comes before end.\n        start = self.positionFromLineIndex(*selectionPos[:2])\n        end = self.positionFromLineIndex(*selectionPos[2:])\n        if start > end:\n            start, end = end, start\n\n        # Allocate a large enough buffer.\n        bufSize = 2 * (end - start) + 2\n        buf = bytearray(bufSize)\n\n        # Fetch the text- and styling information.\n        numRet = self.SendScintilla(self.SCI_GETSTYLEDTEXT, start, end, buf)\n\n        # The last two bytes are always Zero according to the\n        # Scintilla documentation, so remove them.\n        buf = buf[:-2]\n\n        # Double check that we did not receive more bytes than the buffer\n        # was long.\n        if numRet > bufSize:\n            qteMain.qteLogger.error('SCI_GETSTYLEDTEX function returned more'\n                                    ' bytes than expected.')\n        text = buf[0::2]\n        style = buf[1::2]\n        return (text, style)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef SCISetStyling(self, line: int, col: int,\n                      numChar: int, style: bytearray):\n        \"\"\"\n        Pythonic wrapper for the SCI_SETSTYLING command.\n\n        For example, the following code applies style #3\n        to the first five characters in the second line\n        of the widget:\n\n            SCISetStyling((0, 1), 5, 3)\n\n        |Args|\n\n        * ``line`` (**int**): line number where to start styling.\n        * ``col`` (**int**): column number where to start styling.\n        * ``numChar`` (**int**): number of characters to style.\n        * ``style`` (**int**): Scintilla style number.\n\n        |Returns|\n\n        **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        if not self.isPositionValid(line, col):\n            return\n\n        pos = self.positionFromLineIndex(line, col)\n        self.SendScintilla(self.SCI_STARTSTYLING, pos, 0xFF)\n        self.SendScintilla(self.SCI_SETSTYLING, numChar, style)", "response": "This function is a wrapper for the SCI_SETSTYLING command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteSetLexer(self, lexer):\n        if (lexer is not None) and (not issubclass(lexer, Qsci.QsciLexer)):\n            QtmacsOtherError('lexer must be a class object and derived from'\n                             ' <b>QsciLexer</b>')\n            return\n\n        # Install and backup the lexer class.\n        self.qteLastLexer = lexer\n        if lexer is None:\n            self.setLexer(None)\n        else:\n            self.setLexer(lexer())\n\n        # Make all fonts in the style mono space.\n        self.setMonospace()", "response": "Set the lexer class for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setMonospace(self):\n        font = bytes('courier new', 'utf-8')\n        for ii in range(32):\n            self.SendScintilla(self.SCI_STYLESETFONT, ii, font)", "response": "Fix the fonts of the first 32 styles to a mono space one."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setModified(self, isModified: bool):\n        if not isModified:\n            self.qteUndoStack.saveState()\n        super().setModified(isModified)", "response": "Set the modified state to isModified."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef attribute(func):\n\n    def inner(self):\n        name, attribute_type = func(self)\n        if not name:\n            name = func.__name__\n        try:\n            return attribute_type(self.et.attrib[name])\n        except KeyError:\n            raise AttributeError\n    return inner", "response": "Decorator used to declare that property is a tag attribute"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef section(func):\n    def inner(self):\n        return func(self)(self.et.find(func.__name__))\n    return inner", "response": "Decorator used to declare that the property is xml section"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tag_value(func):\n    def inner(self):\n        tag, attrib, attrib_type = func(self)\n        tag_obj = self.et.find(tag)\n\n        if tag_obj is not None:\n            try:\n                return attrib_type(self.et.find(tag).attrib[attrib])\n            except KeyError:\n                raise AttributeError\n\n    return inner", "response": "Decorator used to declare that the property is attribute of embedded tag\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef xml(self):\n        if six.PY3:\n            data = ElementTree.tostring(self.et, encoding=\"unicode\")\n        else:\n            data = ElementTree.tostring(self.et)\n        return data", "response": "returns the xml representation of the current object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun validation Wraps concrete implementation to ensure custom validators return proper type of result. :param value: a value to validate :param model: parent model of the property :param context: parent model or custom context :return: shiftschema.result.Error", "response": "def run(self, value, model=None, context=None):\n        \"\"\"\n        Run validation\n        Wraps concrete implementation to ensure custom validators return\n        proper type of result.\n\n        :param value:               a value to validate\n        :param model:               parent model of the property\n        :param context:             parent model or custom context\n        :return:                    shiftschema.result.Error\n        \"\"\"\n        res = self.validate(value, model, context)\n        if not isinstance(res, Error):\n            err = 'Validator \"{}\" result must be of type \"{}\", got \"{}\"'\n            raise InvalidErrorType(err.format(\n                self.__class__.__name__,\n                Error,\n                type(res))\n            )\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of all the data gathered from the engine iterable.", "response": "def _collect_data(self):\n        \"\"\"\n        Returns a list of all the data gathered from the engine\n        iterable.\n        \"\"\"\n        all_data = []\n        for line in self.engine.run_engine():\n            logging.debug(\"Adding {} to all_data\".format(line))\n            all_data.append(line.copy())\n            logging.debug(\"all_data is now {}\".format(all_data))\n\n        return all_data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget module name from module file name.", "response": "def _get_module_name_from_fname(fname):\n    \"\"\"Get module name from module file name.\"\"\"\n    fname = fname.replace(\".pyc\", \".py\")\n    for mobj in sys.modules.values():\n        if (\n            hasattr(mobj, \"__file__\")\n            and mobj.__file__\n            and (mobj.__file__.replace(\".pyc\", \".py\") == fname)\n        ):\n            module_name = mobj.__name__\n            return module_name\n    raise RuntimeError(\"Module could not be found\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the arguments of a function.", "response": "def get_function_args(func, no_self=False, no_varargs=False):\n    \"\"\"\n    Return tuple of the function argument names in the order of the function signature.\n\n    :param func: Function\n    :type  func: function object\n\n    :param no_self: Flag that indicates whether the function argument *self*,\n                    if present, is included in the output (False) or not (True)\n    :type  no_self: boolean\n\n    :param no_varargs: Flag that indicates whether keyword arguments are\n                       included in the output (True) or not (False)\n    :type  no_varargs: boolean\n\n    :rtype: tuple\n\n    For example:\n\n        >>> import pexdoc.pinspect\n        >>> class MyClass(object):\n        ...     def __init__(self, value, **kwargs):\n        ...         pass\n        ...\n        >>> pexdoc.pinspect.get_function_args(MyClass.__init__)\n        ('self', 'value', '**kwargs')\n        >>> pexdoc.pinspect.get_function_args(\n        ...     MyClass.__init__, no_self=True\n        ... )\n        ('value', '**kwargs')\n        >>> pexdoc.pinspect.get_function_args(\n        ...     MyClass.__init__, no_self=True, no_varargs=True\n        ... )\n        ('value',)\n        >>> pexdoc.pinspect.get_function_args(\n        ...     MyClass.__init__, no_varargs=True\n        ... )\n        ('self', 'value')\n    \"\"\"\n    par_dict = signature(func).parameters\n    # Mark positional and/or keyword arguments (if any)\n    pos = lambda x: x.kind == Parameter.VAR_POSITIONAL\n    kw = lambda x: x.kind == Parameter.VAR_KEYWORD\n    opts = [\"\", \"*\", \"**\"]\n    args = [\n        \"{prefix}{arg}\".format(prefix=opts[pos(value) + 2 * kw(value)], arg=par)\n        for par, value in par_dict.items()\n    ]\n    # Filter out 'self' from parameter list (optional)\n    self_filtered_args = (\n        args if not args else (args[1 if (args[0] == \"self\") and no_self else 0 :])\n    )\n    # Filter out positional or keyword arguments (optional)\n    pos = lambda x: (len(x) > 1) and (x[0] == \"*\") and (x[1] != \"*\")\n    kw = lambda x: (len(x) > 2) and (x[:2] == \"**\")\n    varargs_filtered_args = [\n        arg\n        for arg in self_filtered_args\n        if (not no_varargs) or all([no_varargs, not pos(arg), not kw(arg)])\n    ]\n    return tuple(varargs_filtered_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_module_name(module_obj):\n    if not is_object_module(module_obj):\n        raise RuntimeError(\"Argument `module_obj` is not valid\")\n    name = module_obj.__name__\n    msg = \"Module object `{name}` could not be found in loaded modules\"\n    if name not in sys.modules:\n        raise RuntimeError(msg.format(name=name))\n    return name", "response": "r Returns the module name from a module object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nyielding private properties of an object.", "response": "def private_props(obj):\n    \"\"\"\n    Yield private properties of an object.\n\n    A private property is defined as one that has a single underscore\n    (:code:`_`) before its name\n\n    :param obj: Object\n    :type  obj: object\n\n    :returns: iterator\n    \"\"\"\n    # Get private properties but NOT magic methods\n    props = [item for item in dir(obj)]\n    priv_props = [_PRIVATE_PROP_REGEXP.match(item) for item in props]\n    call_props = [callable(getattr(obj, item)) for item in props]\n    iobj = zip(props, priv_props, call_props)\n    for obj_name in [prop for prop, priv, call in iobj if priv and (not call)]:\n        yield obj_name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking that intersection of two objects has the same information.", "response": "def _check_intersection(self, other):\n        \"\"\"Check that intersection of two objects has the same information.\"\"\"\n        # pylint: disable=C0123\n        props = [\"_callables_db\", \"_reverse_callables_db\", \"_modules_dict\"]\n        for prop in props:\n            self_dict = getattr(self, prop)\n            other_dict = getattr(other, prop)\n            keys_self = set(self_dict.keys())\n            keys_other = set(other_dict.keys())\n            for key in keys_self & keys_other:\n                svalue = self_dict[key]\n                ovalue = other_dict[key]\n                same_type = type(svalue) == type(ovalue)\n                if same_type:\n                    list_comp = isinstance(svalue, list) and any(\n                        [item not in svalue for item in ovalue]\n                    )\n                    str_comp = isinstance(svalue, str) and svalue != ovalue\n                    dict_comp = isinstance(svalue, dict) and svalue != ovalue\n                    comp = any([list_comp, str_comp, dict_comp])\n                if (not same_type) or (same_type and comp):\n                    emsg = \"Conflicting information between objects\"\n                    raise RuntimeError(emsg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the callable that the line number belongs to.", "response": "def get_callable_from_line(self, module_file, lineno):\n        \"\"\"Get the callable that the line number belongs to.\"\"\"\n        module_name = _get_module_name_from_fname(module_file)\n        if module_name not in self._modules_dict:\n            self.trace([module_file])\n        ret = None\n        # Sort callables by starting line number\n        iobj = sorted(self._modules_dict[module_name], key=lambda x: x[\"code_id\"][1])\n        for value in iobj:\n            if value[\"code_id\"][1] <= lineno <= value[\"last_lineno\"]:\n                ret = value[\"name\"]\n            elif value[\"code_id\"][1] > lineno:\n                break\n        return ret if ret else module_name"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef refresh(self):\n        self.trace(list(self._fnames.keys()), _refresh=True)", "response": "Re - traces modules modified since the time they were traced."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, callables_fname):\n        # Validate file name\n        _validate_fname(callables_fname)\n        # JSON keys have to be strings but the reverse callables dictionary\n        # keys are tuples, where the first item is a file name and the\n        # second item is the starting line of the callable within that file\n        # (dictionary value), thus need to convert the key to a string\n        items = self._reverse_callables_db.items()\n        fdict = {\n            \"_callables_db\": self._callables_db,\n            \"_reverse_callables_db\": dict([(str(k), v) for k, v in items]),\n            \"_modules_dict\": self._modules_dict,\n            \"_fnames\": self._fnames,\n            \"_module_names\": self._module_names,\n            \"_class_names\": self._class_names,\n        }\n        with open(callables_fname, \"w\") as fobj:\n            json.dump(fdict, fobj)", "response": "r Save traced modules information to a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _close_callable(self, node, force=False):\n        # Only nodes that have a line number can be considered for closing\n        # callables. Similarly, only nodes with lines greater than the one\n        # already processed can be considered for closing callables\n        try:\n            lineno = node.lineno\n        except AttributeError:\n            return\n        if lineno <= self._processed_line:\n            return\n        # [[[cog\n        # code = \"\"\"\n        # print(pcolor('Close callable @ line = {0}'.format(lineno), 'green'))\n        # \"\"\"\n        # cog.out(code)\n        # ]]]\n        # [[[end]]]\n        # Extract node name for property closing. Once a property is found,\n        # it can only be closed out by a node type that has a name\n        name = \"\"\n        try:\n            name = (\n                node.name\n                if hasattr(node, \"name\")\n                else (\n                    node.targets[0].id\n                    if hasattr(node.targets[0], \"id\")\n                    else node.targets[0].value.id\n                )\n            )\n        except AttributeError:\n            pass\n        # Traverse backwards through call stack and close callables as needed\n        indent = self._get_indent(node)\n        count = -1\n        # [[[cog\n        # code = \"\"\"\n        # print(\n        #     pcolor(\n        #         '    Name {0} @ {1}, indent = {2}'.format(\n        #             name if name else 'None', lineno, indent\n        #         ),\n        #         'yellow'\n        #     )\n        # )\n        # \"\"\"\n        # cog.out(code)\n        # ]]]\n        # [[[end]]]\n        dlist = []\n        while count >= -len(self._indent_stack):\n            element_full_name = self._indent_stack[count][\"full_name\"]\n            edict = self._callables_db.get(element_full_name, None)\n            stack_indent = self._indent_stack[count][\"level\"]\n            open_callable = element_full_name and (not edict[\"last_lineno\"])\n            # [[[cog\n            # code = \"\"\"\n            # print(\n            #     pcolor(\n            #         '    Name {0}, indent, {1}, stack_indent {2}'.format(\n            #             element_full_name, indent, stack_indent\n            #         ),\n            #         'yellow'\n            #     )\n            # )\n            # \"\"\"\n            # cog.out(code)\n            # ]]]\n            # [[[end]]]\n            if open_callable and (\n                force\n                or (indent < stack_indent)\n                or (\n                    (indent == stack_indent)\n                    and (\n                        (edict[\"type\"] != \"prop\")\n                        or (\n                            (edict[\"type\"] == \"prop\")\n                            and (name and (name != element_full_name))\n                        )\n                    )\n                )\n            ):\n                # [[[cog\n                # code = \"\"\"\n                # print(\n                #     pcolor(\n                #         '    Closing {0} @ {1}'.format(\n                #             element_full_name, lineno-1\n                #         ),\n                #         'yellow'\n                #     )\n                # )\n                # \"\"\"\n                # cog.out(code)\n                # ]]]\n                # [[[end]]]\n                edict[\"last_lineno\"] = lineno - 1\n                dlist.append(count)\n            if indent > stack_indent:\n                break\n            count -= 1\n        # Callables have to be removed from stack when they are closed,\n        # otherwise if a callable is subsequently followed after a few\n        # lines by another callable at a further indentation level (like a for\n        # loop) the second callable would incorrectly appear within the scope\n        # of the first callable\n        stack = self._indent_stack\n        stack_length = len(self._indent_stack)\n        dlist = [item for item in dlist if stack[item][\"type\"] != \"module\"]\n        for item in dlist:\n            del self._indent_stack[stack_length + item]", "response": "Record last line number of callable."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget node indentation level.", "response": "def _get_indent(self, node):\n        \"\"\"Get node indentation level.\"\"\"\n        lineno = node.lineno\n        if lineno > len(self._lines):\n            return -1\n        wsindent = self._wsregexp.match(self._lines[lineno - 1])\n        return len(wsindent.group(1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds if callable is function or method.", "response": "def _in_class(self, node):\n        \"\"\"Find if callable is function or method.\"\"\"\n        # Move left one indentation level and check if that callable is a class\n        indent = self._get_indent(node)\n        for indent_dict in reversed(self._indent_stack):  # pragma: no branch\n            if (indent_dict[\"level\"] < indent) or (indent_dict[\"type\"] == \"module\"):\n                return indent_dict[\"type\"] == \"class\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _pop_indent_stack(self, node, node_type=None, action=None):\n        indent = self._get_indent(node)\n        indent_stack = copy.deepcopy(self._indent_stack)\n        # Find enclosing scope\n        while (len(indent_stack) > 1) and (\n            (\n                (indent <= indent_stack[-1][\"level\"])\n                and (indent_stack[-1][\"type\"] != \"module\")\n            )\n            or (indent_stack[-1][\"type\"] == \"prop\")\n        ):\n            self._close_callable(node)\n            indent_stack.pop()\n        # Construct new callable name\n        name = (\n            (\n                node.targets[0].id\n                if hasattr(node.targets[0], \"id\")\n                else node.targets[0].value.id\n            )\n            if node_type == \"prop\"\n            else node.name\n        )\n        element_full_name = \".\".join(\n            [self._module]\n            + [\n                indent_dict[\"prefix\"]\n                for indent_dict in indent_stack\n                if indent_dict[\"type\"] != \"module\"\n            ]\n            + [name]\n        ) + (\"({0})\".format(action) if action else \"\")\n        # Add new callable entry to indentation stack\n        self._indent_stack = indent_stack\n        self._indent_stack.append(\n            {\n                \"level\": indent,\n                \"prefix\": name,\n                \"type\": node_type,\n                \"full_name\": element_full_name,\n                \"lineno\": node.lineno,\n            }\n        )\n        return element_full_name", "response": "Get callable full name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef visit_Assign(self, node):\n        # [[[cog\n        # cog.out(\"print(pcolor('Enter assign visitor', 'magenta'))\")\n        # ]]]\n        # [[[end]]]\n        # ###\n        # Class-level assignment may also be a class attribute that is not\n        # a managed attribute, record it anyway, no harm in doing so as it\n        # is not attached to a callable\n        if self._in_class(node):\n            element_full_name = self._pop_indent_stack(node, \"prop\")\n            code_id = (self._fname, node.lineno)\n            self._processed_line = node.lineno\n            self._callables_db[element_full_name] = {\n                \"name\": element_full_name,\n                \"type\": \"prop\",\n                \"code_id\": code_id,\n                \"last_lineno\": None,\n            }\n            self._reverse_callables_db[code_id] = element_full_name\n            # [[[cog\n            # code = \"\"\"\n            # print(\n            #     pcolor(\n            #         'Visiting property {0} @ {1}'.format(\n            #             element_full_name, code_id[1]\n            #         ),\n            #         'green'\n            #     )\n            # )\n            # \"\"\"\n            # cog.out(code)\n            # ]]]\n            # [[[end]]]\n            # Get property actions\n        self.generic_visit(node)", "response": "Implement assignment walker.\n\n        Parse class properties defined via the property() function"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef visit_FunctionDef(self, node):\n        # [[[cog\n        # cog.out(\"print(pcolor('Enter function visitor', 'magenta'))\")\n        # ]]]\n        # [[[end]]]\n        in_class = self._in_class(node)\n        decorator_list = [\n            dobj.id if hasattr(dobj, \"id\") else dobj.attr\n            for dobj in node.decorator_list\n            if hasattr(dobj, \"id\") or hasattr(dobj, \"attr\")\n        ]\n        node.decorator_list = []\n        # Callable can be:\n        # a) A class property defined via decorated methods\n        # b) A class method\n        # c) A function\n        # Get callable information (name, line number, etc.)\n        action = (\n            \"getter\"\n            if \"property\" in decorator_list\n            else (\n                \"setter\"\n                if \"setter\" in decorator_list\n                else (\"deleter\" if \"deleter\" in decorator_list else None)\n            )\n        )\n        element_type = \"meth\" if in_class else \"func\"\n        element_full_name = self._pop_indent_stack(node, element_type, action=action)\n        code_id = (self._fname, node.lineno)\n        self._processed_line = node.lineno\n        self._callables_db[element_full_name] = {\n            \"name\": element_full_name,\n            \"type\": element_type,\n            \"code_id\": code_id,\n            \"last_lineno\": None,\n        }\n        self._reverse_callables_db[code_id] = element_full_name\n        # [[[cog\n        # code = \"\"\"\n        # print(\n        #     pcolor(\n        #         'Visiting callable {0}  @ {1}'.format(\n        #             element_full_name, code_id[1]\n        #         ),\n        #         'green'\n        #     )\n        # )\n        # print(pcolor('    in_class = {}'.format(in_class), 'yellow'))\n        # \"\"\"\n        # cog.out(code)\n        # ]]]\n        # [[[end]]]\n        self.generic_visit(node)", "response": "Implement function or method walker."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(task_creators, args, task_selectors=[]):\n    if args.reset_dep:\n        sys.exit(DoitMain(WrapitLoader(args, task_creators)).run(['reset-dep']))\n    else:\n        sys.exit(DoitMain(WrapitLoader(args, task_creators)).run(task_selectors))", "response": "run doit using task_creators\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, task_cls):\n\n\t\tregistry_tag = task_cls.__registry_tag__\n\t\tif registry_tag not in self.__registry.keys():\n\t\t\tself.__registry[registry_tag] = [task_cls]\n\t\telif self.__multiple_tasks_per_tag__ is True:\n\t\t\tself.__registry[registry_tag].append(task_cls)\n\t\telse:\n\t\t\traise RuntimeError('Multiple tasks with same tag appended')", "response": "Adds a task to this storage."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove(self, task_cls):\n\t\tregistry_tag = task_cls.__registry_tag__\n\t\tif registry_tag in self.__registry.keys():\n\t\t\tself.__registry[registry_tag] = \\\n\t\t\t\tlist(filter(lambda x: x != task_cls, self.__registry[registry_tag]))\n\t\t\tif len(self.__registry[registry_tag]) == 0:\n\t\t\t\tself.__registry.pop(registry_tag)", "response": "Removes a task from the storage."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tasks_by_tag(self, registry_tag):\n\t\tif registry_tag not in self.__registry.keys():\n\t\t\treturn None\n\t\ttasks = self.__registry[registry_tag]\n\t\treturn tasks if self.__multiple_tasks_per_tag__ is True else tasks[0]", "response": "Get tasks from registry by its tag"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tasks(self, task_cls=None):\n\t\tresult = []\n\t\tfor tasks in self.__registry.values():\n\t\t\tresult.extend(tasks)\n\n\t\tif task_cls is not None:\n\t\t\tresult = filter(lambda x: issubclass(x, task_cls), result)\n\t\treturn tuple(result)", "response": "method for retrieving all tasks in the registry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef count(self):\n\t\tresult = 0\n\t\tfor tasks in self.__registry.values():\n\t\t\tresult += len(tasks)\n\t\treturn result", "response": "Count the number of tasks registered in the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets registry storage : return: WTaskRegistryBase", "response": "def registry_storage(cls):\n\t\t\"\"\" Get registry storage\n\n\t\t:return: WTaskRegistryBase\n\t\t\"\"\"\n\t\tif cls.__registry_storage__ is None:\n\t\t\traise ValueError('__registry_storage__ must be defined')\n\t\tif isinstance(cls.__registry_storage__, WTaskRegistryBase) is False:\n\t\t\traise TypeError(\"Property '__registry_storage__' is invalid (must derived from WTaskRegistryBase)\")\n\n\t\treturn cls.__registry_storage__"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds task class to storage", "response": "def add(cls, task_cls):\n\t\t\"\"\" Add task class to storage\n\n\t\t:param task_cls: task to add\n\t\t:return: None\n\t\t\"\"\"\n\n\t\tif task_cls.__registry_tag__ is None and cls.__skip_none_registry_tag__ is True:\n\t\t\treturn\n\n\t\tcls.registry_storage().add(task_cls)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(self, value, model=None, context=None):\n\n        regex = self.regex()\n        match = regex.match(value)\n        if not match:\n            return Error(self.not_email)\n\n        # success otherwise\n        return Error()", "response": "Validates the value for the key - value pair and returns a SimpleResult object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef regex(self):\n\n        qtext = '[^\\\\x0d\\\\x22\\\\x5c\\\\x80-\\\\xff]'\n        dtext = '[^\\\\x0d\\\\x5b-\\\\x5d\\\\x80-\\\\xff]'\n\n        atom = '[^\\\\x00-\\\\x20\\\\x22\\\\x28\\\\x29\\\\x2c\\\\x2e\\\\x3a-\\\\x3c\\\\x3e\\\\x40'\n        atom += '\\\\x5b-\\\\x5d\\\\x7f-\\\\xff]+'\n\n        quoted_pair = '\\\\x5c[\\\\x00-\\\\x7f]'\n        domain_literal = \"\\\\x5b(?:%s|%s)*\\\\x5d\" % (dtext, quoted_pair)\n        quoted_string = \"\\\\x22(?:%s|%s)*\\\\x22\" % (qtext, quoted_pair)\n        domain_ref = atom\n        sub_domain = \"(?:%s|%s)\" % (domain_ref, domain_literal)\n        word = \"(?:%s|%s)\" % (atom, quoted_string)\n        domain = \"%s(?:\\\\x2e%s)*\" % (sub_domain, sub_domain)\n        local_part = \"%s(?:\\\\x2e%s)*\" % (word, word)\n        addr_spec = \"%s\\\\x40%s\" % (local_part, domain)\n\n        email_address = re.compile('\\A%s\\Z' % addr_spec)\n        return email_address", "response": "RFC822 Email Address Regex"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match(self, *command_tokens, **command_env):\n\t\tcommand = self.command()\n\t\tif len(command_tokens) >= len(command):\n\t\t\treturn command_tokens[:len(command)] == command\n\t\treturn False", "response": "Implementation of WCommandProto. match method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nselect suitable command that matches the given tokens.", "response": "def select(self, *command_tokens, **command_env):\n\t\t\"\"\" Select suitable command, that matches the given tokens. Each new command to check is fetched with\n\t\tthis object iterator (:meth:`.WCommandSelector.__iter__`)\n\n\t\t:param command_tokens: command\n\t\t:param command_env: command environment\n\t\t:return: WCommandProto\n\t\t\"\"\"\n\t\tfor command_obj in self:\n\t\t\tif command_obj.match(*command_tokens, **command_env):\n\t\t\t\treturn command_obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a command with the specified priority to the list of commands that are currently being executed.", "response": "def add_prioritized(self, command_obj, priority):\n\t\t\"\"\" Add command with the specified priority\n\n\t\t:param command_obj: command to add\n\t\t:param priority: command priority\n\t\t:return: None\n\t\t\"\"\"\n\t\tif priority not in self.__priorities.keys():\n\t\t\tself.__priorities[priority] = []\n\n\t\tself.__priorities[priority].append(command_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting the given command", "response": "def exec(self, command_str, **command_env):\n\t\t\"\"\" Execute the given command (command will be split into tokens, every space that is a part of a token\n\t\tmust be quoted)\n\n\t\t:param command_str: command to execute\n\t\t:param command_env: command environment\n\t\t:return: WCommandResultProto\n\t\t\"\"\"\n\t\tenv = self.__vars.copy()\n\t\tenv.update(command_env)\n\n\t\tcommand_tokens = WCommandProto.split_command(command_str)\n\t\tcommand_obj = self.commands().select(*command_tokens, **env)\n\t\tif command_obj is None:\n\t\t\traise WCommandSet.NoCommandFound('No suitable command found: \"%s\"' % command_str)\n\n\t\tresult = command_obj.exec(*command_tokens, **env)\n\t\tself.__track_vars(result)\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __track_vars(self, command_result):\n\t\tcommand_env = command_result.environment()\n\t\tfor var_name in self.tracked_vars():\n\t\t\tif var_name in command_env.keys():\n\t\t\t\tself.__vars[var_name] = command_env[var_name]", "response": "Check if there are any tracked variable inside the result and keep them for future use."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a decorator that registers function as capability.", "response": "def capability(cap, *wrap_exceptions):\n\t\t\"\"\" Return a decorator, that registers function as capability. Also, all specified exceptions are\n\t\tcaught and instead of them the :class:`.WClientCapabilityError` exception is raised\n\n\t\t:param cap: target function capability (may be a str or :class:`.WNetworkClientCapabilities` class )\n\t\t:param wrap_exceptions: exceptions to caught\n\n\t\t:return: decorator\n\t\t\"\"\"\n\t\tif isinstance(cap, WNetworkClientCapabilities) is True:\n\t\t\tcap = cap.value\n\t\telif isinstance(cap, str) is False:\n\t\t\traise TypeError('Invalid capability type')\n\n\t\tdef first_level_decorator(decorated_function):\n\t\t\tdef second_level_decorator(original_function, *args, **kwargs):\n\n\t\t\t\tif len(wrap_exceptions) == 0:\n\t\t\t\t\treturn original_function(*args, **kwargs)\n\t\t\t\ttry:\n\t\t\t\t\treturn original_function(*args, **kwargs)\n\t\t\t\texcept wrap_exceptions as e:\n\t\t\t\t\traise WClientCapabilityError(\n\t\t\t\t\t\t'Error during \"%s\" capability execution' % cap\n\t\t\t\t\t) from e\n\t\t\tresult_fn = decorator(second_level_decorator)(decorated_function)\n\t\t\tresult_fn.__capability_name__ = cap\n\t\t\treturn result_fn\n\t\treturn first_level_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef capability(self, cap_name):\n\t\tif isinstance(cap_name, WNetworkClientCapabilities) is True:\n\t\t\tcap_name = cap_name.value\n\t\treturn WCapabilitiesHolder.capability(self, cap_name)", "response": "Overrides original WCapabilitiesHolder. capability method to support\n\tCapabilities as a capability value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteStartRecordingHook(self, msgObj):\n        if self.qteRecording:\n            self.qteMain.qteStatus('Macro recording already enabled')\n            return\n\n        # Update status flag.\n        self.qteRecording = True\n\n        # Reset the variables.\n        self.qteMain.qteStatus('Macro recording started')\n        self.recorded_keysequence = QtmacsKeysequence()\n\n        # Connect the 'keypressed' and 'abort' signals.\n        self.qteMain.qtesigKeyparsed.connect(self.qteKeyPress)\n        self.qteMain.qtesigAbort.connect(self.qteStopRecordingHook)", "response": "Start the macro recording."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstop macro recording. The signals from the event handler are disconnected and the event handler policy set to default.", "response": "def qteStopRecordingHook(self, msgObj):\n        \"\"\"\n        Stop macro recording.\n\n        The signals from the event handler are disconnected and the\n        event handler policy set to default.\n        \"\"\"\n        # Update status flag and disconnect all signals.\n        if self.qteRecording:\n            self.qteRecording = False\n            self.qteMain.qteStatus('Macro recording stopped')\n            self.qteMain.qtesigKeyparsed.disconnect(self.qteKeyPress)\n            self.qteMain.qtesigAbort.disconnect(self.qteStopRecordingHook)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qteReplayKeysequenceHook(self, msgObj):\n\n        # Quit if there is nothing to replay.\n        if self.recorded_keysequence.toString() == '':\n            return\n\n        # Stop the recording before the replay, if necessary.\n        if self.qteRecording:\n            return\n\n        # Simulate the key presses.\n        self.qteMain.qteEmulateKeypresses(self.recorded_keysequence)", "response": "Replay the macro sequence."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteKeyPress(self, msgObj):\n        # Unpack the data structure.\n        (srcObj, keysequence, macroName) = msgObj.data\n\n        # Append the last QKeyEvent object to the so far recorded\n        # sequence. Note that both ``keysequence`` and\n        # ``self.recorded_keysequence`` are ``QtmacsKeysequence``\n        # instances.\n        last_key = keysequence.toQKeyEventList()[-1]\n        self.recorded_keysequence.appendQKeyEvent(last_key)", "response": "Record the key presses reported by the key handler."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrecord the key presses reported by the key handler.", "response": "def qteKeyPress(self, msgObj):\n        \"\"\"\n        Record the key presses reported by the key handler.\n        \"\"\"\n        # Unpack the data structure.\n        (srcObj, keysequence, macroName) = msgObj.data\n        key = keysequence.toQKeyEventList()[-1]\n\n        # If the current key did not complete a macro ignore it.\n        if macroName is None:\n            return\n\n        if self.input_complete:\n            # The user has terminated reading digits by calling this\n            # macro directly, ie. the 'macroName ==\n            # self.qteMacroName()' branch below ran previously.\n            self.qteRepeatTheMacro(msgObj)\n        elif (macroName == 'self-insert') and (key.text().isdigit()):\n            # User typed a digit.\n            self.repeat_cnt += key.text()\n        elif macroName == self.qteMacroName():\n            # User called us again. This completes reading the\n            # digits. The next macro is executed self.prefix_num\n            # times.\n            self.input_complete = True\n        else:\n            # If we got until here we know that a macro is supposed to\n            # be executed, that it is not the self-insert macro for a\n            # digit, and that it was not another call to this macro to\n            # complete the input explicitly.\n            self.qteRepeatTheMacro(msgObj)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrecord the key presses.", "response": "def qteKeyPress(self, msgObj):\n        \"\"\"\n        Record the key presses.\n        \"\"\"\n        # Unpack the data structure.\n        (srcObj, keysequence, macroName) = msgObj.data\n\n        # Return immediately if the key sequence does not specify a\n        # macro (yet).\n        if macroName is None:\n            return\n\n        # If the macro to repeat is this very macro then disable the\n        # macro proxy, otherwise execute the macro that would have run\n        # originally.\n        if macroName == self.qteMacroName():\n            self.abort()\n        else:\n            msg = 'Executing macro {} through {}'\n            msg = msg.format(macroName, self.qteMacroName())\n            self.qteMain.qteStatus(msg)\n            self.qteMain.qteRunMacro(macroName, srcObj, keysequence)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef abort(self, msgObj):\n        self.qteMain.qtesigKeyparsed.disconnect(self.qteKeyPress)\n        self.qteMain.qtesigAbort.disconnect(self.abort)\n        self.qteActive = False\n        self.qteMain.qteEnableMacroProcessing()", "response": "Disconnect all signals and turn macro processing in the event\n        handler back on."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new ConciergeClient with the secrets from the environment.", "response": "def get_new_client(request_session=False):\n    \"\"\"Return a new ConciergeClient, pulling secrets from the environment.\n\n    \"\"\"\n    from .client import ConciergeClient\n    client = ConciergeClient(access_key=os.environ[\"MS_ACCESS_KEY\"],\n                             secret_key=os.environ[\"MS_SECRET_KEY\"],\n                             association_id=os.environ[\"MS_ASSOCIATION_ID\"])\n    if request_session:\n        client.request_session()\n    return client"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef submit_msql_object_query(object_query, client=None):\n    client = client or get_new_client()\n    if not client.session_id:\n        client.request_session()\n\n    result = client.execute_object_query(object_query)\n    execute_msql_result = result[\"body\"][\"ExecuteMSQLResult\"]\n\n    membersuite_object_list = []\n\n    if execute_msql_result[\"Success\"]:\n\n        result_value = execute_msql_result[\"ResultValue\"]\n\n        if result_value[\"ObjectSearchResult\"][\"Objects\"]:\n            # Multiple results.\n            membersuite_object_list = []\n            for obj in (result_value[\"ObjectSearchResult\"][\"Objects\"]\n                        [\"MemberSuiteObject\"]):\n                membersuite_object = membersuite_object_factory(obj)\n                membersuite_object_list.append(membersuite_object)\n        elif result_value[\"SingleObject\"][\"ClassType\"]:\n            # Only one result.\n            membersuite_object = membersuite_object_factory(\n                execute_msql_result[\"ResultValue\"][\"SingleObject\"])\n            membersuite_object_list.append(membersuite_object)\n        elif (result_value[\"ObjectSearchResult\"][\"Objects\"] is None and\n              result_value[\"SingleObject\"][\"ClassType\"] is None):\n            raise NoResultsError(result=execute_msql_result)\n\n        return membersuite_object_list\n\n    else:\n        # @TODO Fix - exposing only the first of possibly many errors here.\n        raise ExecuteMSQLError(result=execute_msql_result)", "response": "Submit an object query to MemberSuite returning a list of MemberSuiteObjects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef value_for_key(membersuite_object_data, key):\n    key_value_dicts = {\n        d['Key']: d['Value'] for d\n        in membersuite_object_data[\"Fields\"][\"KeyValueOfstringanyType\"]}\n    return key_value_dicts[key]", "response": "Return the value for key of membersuite_object_data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef booleanize(truthy):\r\n    '''\r\n    Smartly converts argument to true or false. Strings and variants of\r\n    'true' and 'false' convert to appropriate types, along with normal\r\n    bool() like conversions.\r\n    '''\r\n    if truthy is None:\r\n        return False\r\n    elif isinstance(truthy, basestring):\r\n        if truthy:\r\n            try:\r\n                return bool(distutils.util.strtobool(truthy))\r\n            except ValueError:\r\n                return True\r\n        else:\r\n            return False\r\n    elif is_collection(truthy):\r\n        return not is_empty(truthy)\r\n    else:\r\n        return bool(truthy)", "response": "Smartly converts argument to true or false. Strings and variants of\r\n    true and false convert to appropriate types along with normal\r\n    bool like conversions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new logger that outputs messages in the same format as default Flask applications.", "response": "def build_flask_like_logger(\r\n    logger_name='logger',\r\n    log_level=None,\r\n    log_dir=None,\r\n    console_enabled=True,\r\n    max_log_size=5*1024*1024,\r\n    max_backup_logs=5,\r\n    host=None):\r\n    '''\r\n    Generates a logger that outputs messages in the same format as default Flask applications.\r\n    '''\r\n    old_logger_class = logging.getLoggerClass()\r\n    logging.setLoggerClass(FlaskLikeLogger)\r\n    logger = logging.getLogger(logger_name)\r\n    logging.setLoggerClass(old_logger_class)\r\n\r\n    if log_level:\r\n        logger.setLevel(log_level)\r\n    if host:\r\n        logger.set_host(host)\r\n    logger.apply_default_handlers(log_dir, console_enabled, max_log_size, max_backup_logs)\r\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the format uses the creation time of the record.", "response": "def usesTime(self, fmt=None):\r\n        '''\r\n        Check if the format uses the creation time of the record.\r\n        '''\r\n        if fmt is None:\r\n            fmt = self._fmt\r\n        if not isinstance(fmt, basestring):\r\n            fmt = fmt[0]\r\n        return fmt.find('%(asctime)') >= 0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteIsQtmacsWidget(widgetObj):\n    if widgetObj is None:\n        return False\n\n    if hasattr(widgetObj, '_qteAdmin'):\n        return True\n\n    # Keep track of the already visited objects to avoid infinite loops.\n    visited = [widgetObj]\n\n    # Traverse the hierarchy until a parent features the '_qteAdmin'\n    # attribute, the parent is None, or the parent is an already\n    # visited widget.\n    wid = widgetObj.parent()\n    while wid not in visited:\n        if hasattr(wid, '_qteAdmin'):\n            return True\n        elif wid is None:\n            return False\n        else:\n            visited.append(wid)\n            wid = wid.parent()\n    return False", "response": "Return True if a widget is part of Qtmacs widget hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qteGetAppletFromWidget(widgetObj):\n    if widgetObj is None:\n        return None\n\n    if hasattr(widgetObj, '_qteAdmin'):\n        return widgetObj._qteAdmin.qteApplet\n\n    # Keep track of the already visited objects to avoid infinite loops.\n    visited = [widgetObj]\n\n    # Traverse the hierarchy until a parent features the '_qteAdmin'\n    # attribute, the parent is None, or the parent is an already\n    # visited widget.\n    wid = widgetObj.parent()\n    while wid not in visited:\n        if hasattr(wid, '_qteAdmin'):\n            return wid._qteAdmin.qteApplet\n        elif wid is None:\n            return None\n        else:\n            visited.append(wid)\n            wid = wid.parent()\n    return None", "response": "Return applet that contains widgetObj."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setHookName(self, name: str):\n        self.isHook = True\n        self.messengerName = name", "response": "Sets the name of the message that will be delivered with the hook name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setSignalName(self, name: str):\n        self.isHook = False\n        self.messengerName = name", "response": "Sets the name of the messenger that will be delivered with the signal name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qteSetKeyFilterPolicy(self, receiveBefore: bool=False,\n                              useQtmacs: bool=None,\n                              receiveAfter: bool=False):\n        \"\"\"\n        Set the policy on how Qtmacs filters keyboard events for a\n        particular widgets.\n\n        The options can be arbitrarily combined, eg. ::\n\n            widget.qteSetKeyFilterPolicy(True, True, False)\n\n        will first pass the event to the applet's ``keyPressEvent``\n        method and afterwards pass the same event to Qtmacs' keyboard\n        filter.\n\n        For all text-processing widgets (eg. ``QLineEdit``,\n        ``QTextEdit``, ``QWebView``, etc.) it is almost always a good\n        idea to use the default, ie. (False, True, False, False),\n        which lets Qtmacs process everything. In this case the only\n        way to interact with the widget is via macros (and the mouse).\n\n        If ``receiveBefore`` and/or ``receiveAfter`` is set then\n        ``qteKeyPressEventBefore`` and/or ``qteKeyPressEventAfter`` of\n        the QtmacsApplet (not widget) is called to inspect the event.\n\n        .. note:: The default behaviour is to let Qtmacs handle all\n           keyboard events and interact with the applet only via\n           macros. It may be more convenient for a programmer to\n           handle keyboard events directly in the keyPressEvent\n           routine, as is customary with Qt applications, but this\n           compromises the customisation ability of Qtmacs. As a rule\n           of thumb, applet classes should not implement keyPressEvent\n           at all. However, since there is an exception to every rule\n           Qtmacs allows it.\n\n        .. note:: This method must be part of the qteAdmin object\n                  because which is attached to every object under the\n                  control of Qtmacs.\n\n        |Args|\n\n        * ``receiveBefore`` (**bool**): pass the keyEvent to the applet\n          before Qtmacs processes it.\n        * ``useQtmacs`` (**bool**): let Qtmacs parse the key.\n        * ``receiveAfter`` (**bool**): pass the keyEvent to the applet\n          after Qtmacs processed it.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Store key filter policy flags.\n        self.filterKeyEvents = useQtmacs\n        self.receiveBeforeQtmacsParser = receiveBefore\n        self.receiveAfterQtmacsParser = receiveAfter", "response": "Set the policy on how Qtmacs filters keyboard events for a particular widget."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list2key(self, keyList):\n        for keyCombo in keyList:\n            if not (isinstance(keyCombo, list) or isinstance(keyCombo, tuple)):\n                msg = ('Format of native key list is invalid.'\n                       ' Must be a list/tuple of list/tuples.')\n                raise QtmacsKeysequenceError(msg)\n            if len(keyCombo) != 2:\n                msg = 'Format of native key list is invalid.'\n                msg += 'Each element must have exactly 2 entries.'\n                raise QtmacsKeysequenceError(msg)\n\n            # Construct a new QKeyEvent. Note that the general\n            # modifier (ie. <ctrl> and <alt>) still need to be\n            # combined with shift modifier (which is never a general\n            # modifier) if the key demands it. This combination is a\n            # simple \"or\" on the QFlags structure. Also note that the\n            # \"text\" argument is omitted because Qt is smart enough to\n            # fill it internally. Furthermore, the QKeyEvent method\n            # will raise an error if the provided key sequence makes\n            # no sense, but to avoid raising an exception inside an\n            # exception the QtmacsKeysequenceError is not raised\n            # inside the exception block.\n            key_event = QtGui.QKeyEvent(QtCore.QEvent.KeyPress, keyCombo[1],\n                                        keyCombo[0])\n            try:\n                key_event = QtGui.QKeyEvent(QtCore.QEvent.KeyPress,\n                                            keyCombo[1], keyCombo[0])\n                err = False\n            except TypeError:\n                err = True\n\n            if err:\n                msg = ('Format of native key list is invalid. '\n                       'Must be a list/tuple of list/tuples.')\n                raise QtmacsKeysequenceError(msg)\n            else:\n                self.appendQKeyEvent(key_event)", "response": "Convert a list of native key sequences into a key sequence."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a human readable key sequence into a list of key combinations.", "response": "def str2key(self, keyString):\n        \"\"\"\n        Parse a human readable key sequence.\n\n        If no error is raised, then ``keyString`` could be\n        successfully converted into a valid key sequence and is\n        henceforth represented by this object.\n\n        |Args|\n\n        * ``keyString`` (**QtmacsKeysequence**): eg. \"<ctrl>+f\"\n\n        |Returns|\n\n        **None**\n\n        |Raises|\n\n        * **QtmacsKeysequenceError** if ``keyString`` could not be parsed.\n        \"\"\"\n\n        # Ensure the string is non-empty.\n        if keyString == '':\n            raise QtmacsKeysequenceError('Cannot parse empty string')\n\n        tmp = str(keyString)\n        tmp = tmp.replace('<', '&lt;')\n        tmp = tmp.replace('>', '&gt;')\n        keyStringHtml = '<b>{}</b>.'.format(tmp)\n        del tmp\n\n        # Remove leading and trailing white spaces, and reduce\n        # sequences of white spaces to a single white space. If this\n        # results in an emtpy string (typically the case when the user\n        # tries to register a white space with ' ' instead of with\n        # '<space>') then raise an error.\n        rawKeyStr = keyString.strip()\n        if len(rawKeyStr) == 0:\n            msg = 'Cannot parse the key combination {}.'.format(keyStringHtml)\n            raise QtmacsKeysequenceError(msg)\n\n        # Split the string at these white spaces and convert eg.\n        # \" <ctrl>+x <ctrl>+f \" first into\n        # \"<ctrl>+x <ctrl>+f\" and from there into the list of\n        # individual key combinations [\"<ctrl>+x\", \"<ctrl>+f\"].\n        rawKeyStr = re.sub(' +', ' ', rawKeyStr)\n        rawKeyStr = rawKeyStr.split(' ')\n\n        # Now process the key combinations one by one. By definition.\n        for key in rawKeyStr:\n            # Find all bracketed keys in the key combination\n            # (eg. <ctrl>, <space>).\n            desc_keys = re.findall('<.*?>', key)\n\n            # There are four possibilities:\n            #   * no bracketed key (eg. \"x\" or \"X\")\n            #   * one bracketed key (eg. \"<ctrl>+x\", or just \"<space>\")\n            #   * two bracketed keys (eg. \"<ctrl>+<space>\" or \"<ctrl>+<alt>+f\")\n            #   * three bracketed keys (eg. <ctrl>+<alt>+<space>).\n            if len(desc_keys) == 0:\n                # No bracketed key means no modifier, so the key must\n                # stand by itself.\n                modStr = ['<NONE>']\n                keyStr = key\n            elif len(desc_keys) == 1:\n                if '+' not in key:\n                    # If no '+' sign is present then it must be\n                    # bracketed key without any modifier\n                    # (eg. \"<space>\").\n                    modStr = ['<NONE>']\n                    keyStr = key\n                else:\n                    # Since a '+' sign and exactly one bracketed key\n                    # is available, it must be a modifier plus a\n                    # normal key (eg. \"<ctrl>+f\", \"<alt>++\").\n                    idx = key.find('+')\n                    modStr = [key[:idx]]\n                    keyStr = key[idx + 1:]\n            elif len(desc_keys) == 2:\n                # There are either two modifiers and a normal key\n                # (eg. \"<ctrl>+<alt>+x\") or one modifier and one\n                # bracketed key (eg. \"<ctrl>+<space>\").\n                if (key.count('+') == 0) or (key.count('+') > 3):\n                    # A valid key combination must feature at least\n                    # one- and at most three \"+\" symbols.\n                    msg = 'Cannot parse the key combination {}.'\n                    msg = msg.format(keyStringHtml)\n                    raise QtmacsKeysequenceError(msg)\n                elif key.count('+') == 1:\n                    # One modifier and one bracketed key\n                    # (eg. \"<ctrl>+<space>\").\n                    idx = key.find('+')\n                    modStr = [key[:idx]]\n                    keyStr = key[idx + 1:]\n                elif (key.count('+') == 2) or (key.count('+') == 3):\n                    # Two modifiers and one normal key\n                    # (eg. \"<ctrl>+<alt>+f\", \"<ctrl>+<alt>++\").\n                    idx1 = key.find('+')\n                    idx2 = key.find('+', idx1 + 1)\n                    modStr = [key[:idx1], key[idx1 + 1:idx2]]\n                    keyStr = key[idx2 + 1:]\n            elif len(desc_keys) == 3:\n                if key.count('+') == 2:\n                    # There are two modifiers and one bracketed key\n                    # (eg. \"<ctrl>+<alt>+<space>\").\n                    idx1 = key.find('+')\n                    idx2 = key.find('+', idx1 + 1)\n                    modStr = [key[:idx1], key[idx1 + 1:idx2]]\n                    keyStr = key[idx2 + 1:]\n                else:\n                    # A key combination with three bracketed entries\n                    # must have exactly two '+' symbols. It cannot be\n                    # valid otherwise.\n                    msg = 'Cannot parse the key combination {}.'\n                    msg = msg.format(keyStringHtml)\n                    raise QtmacsKeysequenceError(msg)\n            else:\n                msg = 'Cannot parse the key combination {}.'\n                msg = msg.format(keyStringHtml)\n                raise QtmacsKeysequenceError(msg)\n\n            # The dictionary keys that map the modifiers and bracketed\n            # keys to Qt constants are all upper case by\n            # convention. Therefore, convert all modifier keys and\n            # bracketed normal keys.\n            modStr = [_.upper() for _ in modStr]\n            if (keyStr[0] == '<') and (keyStr[-1] == '>'):\n                keyStr = keyStr.upper()\n\n            # Convert the text version of the modifier key into the\n            # QFlags structure used by Qt by \"or\"ing them\n            # together. The loop is necessary because more than one\n            # modifier may be active (eg. <ctrl>+<alt>).\n            modQt = QtCore.Qt.NoModifier\n            for mod in modStr:\n                # Ensure that the modifier actually exists (eg. the\n                # user might have made type like \"<ctlr>\" instead of\n                # \"<ctrl>\"). Also, the keys in the dictionary consist\n                # of only upper case letter for the modifier keys.\n                if mod not in self.modDict:\n                    msg = 'Cannot parse the key combination {}.'\n                    msg = msg.format(keyStringHtml)\n                    raise QtmacsKeysequenceError(msg)\n\n                # Since the modifier exists in the dictionary, \"or\"\n                # them with the other flags.\n                modQt = modQt | self.modDict[mod]\n\n            # Repeat the modifier procedure for the key. However,\n            # unlike for the modifiers, no loop is necessary here\n            # because only one key can be pressed at the same time.\n            if keyStr in self.keyDict:\n                modQt_shift, keyQt = self.keyDict[keyStr]\n            else:\n                msg = 'Cannot parse the key combination {}.'\n                msg = msg.format(keyStringHtml)\n                raise QtmacsKeysequenceError(msg)\n\n            # Construct a new QKeyEvent. Note that the general\n            # modifier (ie. <ctrl> and <alt>) still need to be\n            # combined with shift modifier if the key demands it. This\n            # combination is a simple \"or\" on the QFlags structure.\n            # Also note that the \"text\" argument is omitted because Qt\n            # is smart enough to determine it internally.\n            key_event = QtGui.QKeyEvent(QtCore.QEvent.KeyPress, keyQt,\n                                        modQt | modQt_shift)\n\n            # Finally, append this key to the key sequence represented\n            # by this object.\n            self.appendQKeyEvent(key_event)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nappend another key to the key sequence represented by this object.", "response": "def appendQKeyEvent(self, keyEvent: QtGui.QKeyEvent):\n        \"\"\"\n        Append another key to the key sequence represented by this object.\n\n        |Args|\n\n        * ``keyEvent`` (**QKeyEvent**): the key to add.\n\n        |Returns|\n\n        **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Store the QKeyEvent.\n        self.keylistKeyEvent.append(keyEvent)\n\n        # Convenience shortcuts.\n        mod = keyEvent.modifiers()\n        key = keyEvent.key()\n\n        # Add the modifier and key to the list. The modifier is a\n        # QFlag structure and must by typecast to an integer to avoid\n        # difficulties with the hashing in the ``match`` routine of\n        # the ``QtmacsKeymap`` object.\n        self.keylistQtConstants.append((int(mod), key))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef toString(self):\n        # Initialise the final output string.\n        retVal = ''\n\n        for mod, key in self.keylistQtConstants:\n            out = ''\n            # Check for any modifiers except <shift> and add the\n            # corresponding string.\n            if (mod & QtCore.Qt.ControlModifier):\n                out += '<Ctrl>+'\n            if (mod & QtCore.Qt.AltModifier):\n                out += '<Alt>+'\n            if (mod & QtCore.Qt.MetaModifier):\n                out += '<Meta>+'\n            if (mod & QtCore.Qt.KeypadModifier):\n                out += '<Keypad>+'\n            if (mod & QtCore.Qt.GroupSwitchModifier):\n                out += '<GroupSwitch>+'\n\n            # Format the string representation depending on whether or\n            # not <Shift> is active.\n            if (mod & QtCore.Qt.ShiftModifier):\n                # If the key with the shift modifier exists in the\n                # reverse dictionary then use that string, otherwise\n                # construct it manually be printing the modifier and\n                # the key name. The first case is typically\n                # encountered for upper case characters, where eg. 'F'\n                # is preferable over '<Shift>+f'.\n                if (QtCore.Qt.ShiftModifier, key) in self.keyDictReverse:\n                    # The shift-combined key exists in the dictionary,\n                    # so use it.\n                    out += self.keyDictReverse[(QtCore.Qt.ShiftModifier, key)]\n                elif (QtCore.Qt.NoModifier, key) in self.keyDictReverse:\n                    # The shift-combined key does not exists in the\n                    # dictionary, so assemble the modifier and key by\n                    # hand.\n                    out += ('<Shift>+' +\n                            self.keyDictReverse[(QtCore.Qt.NoModifier, key)])\n                else:\n                    out += '<Unknown>'\n            else:\n                if (QtCore.Qt.NoModifier, key) in self.keyDictReverse:\n                    out += self.keyDictReverse[(QtCore.Qt.NoModifier, key)]\n                else:\n                    out += '<Unknown>'\n\n            # Add a spacer.\n            retVal += out + ' '\n\n        # Return the final string (minus the last spacer).\n        return retVal[:-1]", "response": "Return the key sequence as a human readable string eg. \"<Ctrl > + x or <Alt > + f or <GroupSwitch > + x."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninserting a new key into the key - map.", "response": "def qteInsertKey(self, keysequence: QtmacsKeysequence, macroName: str):\n        \"\"\"\n        Insert a new key into the key map and associate it with a\n        macro.\n\n        If the key sequence is already associated with a macro then it\n        will be overwritten.\n\n        |Args|\n\n        * ``keysequence`` (**QtmacsKeysequence**): associate a macro with\n          a key sequence in this key map.\n        * ``macroName`` (**str**): macro name.\n\n        |Returns|\n\n        **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Get a dedicated reference to self to facilitate traversing\n        # through the key map.\n        keyMap = self\n\n        # Get the key sequence as a list of tuples, where each tuple\n        # contains the the control modifier and the key code, and both\n        # are specified as Qt constants.\n        keysequence = keysequence.toQtKeylist()\n\n        # Traverse the shortcut sequence and generate new keys as\n        # necessary.\n        for key in keysequence[:-1]:\n            # If the key does not yet exist add an empty dictionary\n            # (it will be filled later).\n            if key not in keyMap:\n                keyMap[key] = {}\n\n            # Similarly, if the key does exist but references anything\n            # other than a dictionary (eg. a previously installed\n            # ``QtmacdMacro`` instance), then delete it.\n            if not isinstance(keyMap[key], dict):\n                keyMap[key] = {}\n\n            # Go one level down in the key-map tree.\n            keyMap = keyMap[key]\n\n        # Assign the new macro object associated with this key.\n        keyMap[keysequence[-1]] = macroName"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qteRemoveKey(self, keysequence: QtmacsKeysequence):\n        # Get a dedicated reference to self to facilitate traversing\n        # through the key map.\n        keyMap = self\n\n        # Keep a reference to the root element in the key map.\n        keyMapRef = keyMap\n\n        # Get the key sequence as a list of tuples, where each tuple\n        # contains the the control modifier and the key code, and both\n        # are specified as Qt constants.\n        keysequence = keysequence.toQtKeylist()\n\n        # ------------------------------------------------------------\n        # Remove the leaf element from the tree.\n        # ------------------------------------------------------------\n        for key in keysequence[:-1]:\n            # Quit if the key does not exist. This can happen if the\n            # user tries to remove a key that has never been\n            # registered.\n            if key not in keyMap:\n                return\n\n            # Go one level down in the key-map tree.\n            keyMap = keyMap[key]\n\n        # The specified key sequence does not exist if the leaf\n        # element (ie. last entry in the key sequence) is missing.\n        if keysequence[-1] not in keyMap:\n            return\n        else:\n            # Remove the leaf.\n            keyMap.pop(keysequence[-1])\n\n        # ------------------------------------------------------------\n        # Prune the prefix path defined by ``keysequence`` and remove\n        # all empty dictionaries. Start at the leaf level.\n        # ------------------------------------------------------------\n\n        # Drop the last element in the key sequence, because it was\n        # removed in the above code fragment already.\n        keysequence = keysequence[:-1]\n\n        # Now successively remove the key sequence in reverse order.\n        while(len(keysequence)):\n            # Start at the root and move to the last branch level\n            # before the leaf level.\n            keyMap = keyMapRef\n            for key in keysequence[:-1]:\n                keyMap = keyMap[key]\n\n            # If the leaf is a non-empty dictionary then another key\n            # with the same prefix still exists. In this case do\n            # nothing. However, if the leaf is now empty it must be\n            # removed.\n            if len(keyMap[key]):\n                return\n            else:\n                keyMap.pop(key)", "response": "Remove a key from the key - map."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef match(self, keysequence: QtmacsKeysequence):\n        try:\n            # Look up the ``keysequence`` in the current key map (ie.\n            # this very object which inherits from ``dict``). If\n            # ``keysequence`` does not lead to a valid macro then\n            # return **None**.\n            macroName = self\n            for _ in keysequence.toQtKeylist():\n                macroName = macroName[_]\n        except KeyError:\n            # This error occurs if the keyboard sequence does not lead\n            # to any macro and is therefore invalid.\n            return (None, False)\n\n        # At this point we know that the key sequence entered so far\n        # exists. Two possibilities from here on forward: 1) the key\n        # sequence now points to a macro or 2) the key sequence is\n        # still incomplete.\n        if isinstance(macroName, dict):\n            # Another dictionary --> key sequence is still incomplete.\n            return (None, True)\n        else:\n            # Macro object --> return it.\n            return (macroName, True)", "response": "Returns a tuple of the key sequence and whether the key sequence entered in this key map corresponds to the key sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an instance of a QLabel with the correct colour scheme.", "response": "def _qteGetLabelInstance(self):\n        \"\"\"\n        Return an instance of a ``QLabel`` with the correct color scheme.\n\n        |Args|\n\n        * **None**\n\n        |Returns|\n\n        * **QLabel**\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n        # Create a label with the proper colour appearance.\n        layout = self.layout()\n        label = QtGui.QLabel(self)\n        style = 'QLabel { background-color : white; color : blue; }'\n        label.setStyleSheet(style)\n        return label"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the width of all the widgets in the list of items in the QT_MODE_LIST.", "response": "def _qteUpdateLabelWidths(self):\n        \"\"\"\n        Ensure all but the last ``QLabel`` are only as wide as necessary.\n\n        The width of the last label is manually set to a large value to\n        ensure that it stretches as much as possible. The height of all\n        widgets is also set appropriately. The method also takes care\n        or rearranging the widgets in the correct order, ie. in the\n        order specified by ``self._qteModeList``.\n\n        |Args|\n\n        * **None**\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n        layout = self.layout()\n        # Remove all labels from the list and add them again in the\n        # new order.\n        for ii in range(layout.count()):\n            label = layout.itemAt(ii)\n            layout.removeItem(label)\n\n        # Add all labels and ensure they have appropriate width.\n        for item in self._qteModeList:\n            label = item[2]\n            width = label.fontMetrics().size(0, str(item[1])).width()\n            label.setMaximumWidth(width)\n            label.setMinimumWidth(width)\n            layout.addWidget(label)\n\n        # Remove the width constraint from the last label so that\n        # it can expand to the right.\n        _, _, label = self._qteModeList[-1]\n        label.setMaximumWidth(1600000)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the mode value and the associated QLabel instance.", "response": "def qteGetMode(self, mode: str):\n        \"\"\"\n        Return a tuple containing the ``mode``, its value, and\n        its associated ``QLabel`` instance.\n\n        |Args|\n\n        * ``mode`` (**str**): size and position of new window.\n\n        |Returns|\n\n        * (**str**, **object**, **QLabel**: (mode, value, label).\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        for item in self._qteModeList:\n            if item[0] == mode:\n                return item\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteAddMode(self, mode: str, value):\n        # Add the label to the layout and the local mode list.\n        label = self._qteGetLabelInstance()\n        label.setText(value)\n        self._qteModeList.append((mode, value, label))\n        self._qteUpdateLabelWidths()", "response": "Add a mode to the local mode list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging the value of the mode of the current data record.", "response": "def qteChangeModeValue(self, mode: str, value):\n        \"\"\"\n        Change the value of ``mode`` to ``value``.\n\n        If ``mode`` does not exist then nothing happens and the method\n        returns **False**, otherwise **True**.\n\n        |Args|\n\n        * ``mode`` (**str**): mode of mode.\n        * ``value`` (**object**): value of mode.\n\n        |Returns|\n\n        * **bool**: **True** if the item was removed and **False** if there\n          was an error (most likely ``mode`` does not exist).\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Search through the list for ``mode``.\n        for idx, item in enumerate(self._qteModeList):\n            if item[0] == mode:\n                # Update the displayed value in the label.\n                label = item[2]\n                label.setText(value)\n\n                # Overwrite the old data record with the updated one\n                # and adjust the widths of the modes.\n                self._qteModeList[idx] = (mode, value, label)\n                self._qteUpdateLabelWidths()\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef qteInsertMode(self, pos: int, mode: str, value):\n        # Add the label to the list.\n        label = self._qteGetLabelInstance()\n        label.setText(value)\n        self._qteModeList.insert(pos, (mode, value, label))\n        self._qteUpdateLabelWidths()", "response": "Insert a mode at the given position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qteRemoveMode(self, mode: str):\n        # Search through the list for ``mode``.\n        for idx, item in enumerate(self._qteModeList):\n            if item[0] == mode:\n                # Remove the record and delete the label.\n                self._qteModeList.remove(item)\n                item[2].hide()\n                item[2].deleteLater()\n                self._qteUpdateLabelWidths()\n                return True\n        return False", "response": "Remove the mode and associated label."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the base and metaclasses to use in creating a subclass of the given type.", "response": "def _get_bases(type_):\n        # type: (type) -> Tuple[type, type]\n        \"\"\"Get the base and meta classes to use in creating a subclass.\n\n        Args:\n            type_: The type to subclass.\n\n        Returns:\n            A tuple containing two values: a base class, and a metaclass.\n        \"\"\"\n        try:\n\n            class _(type_):  # type: ignore\n                \"\"\"Check if type_ is subclassable.\"\"\"\n\n            BaseClass = type_\n        except TypeError:\n            BaseClass = object\n\n        class MetaClass(_ValidationMeta, BaseClass.__class__):  # type: ignore\n            \"\"\"Use the type_ meta and include base validation functionality.\"\"\"\n\n        return BaseClass, MetaClass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a string representation of the class using the slice parameters.", "response": "def _get_class_repr(cls, type_, bound, keyfunc, keyfunc_name):\n        # type: (Any, slice, Callable, str) -> str\n        \"\"\"Return a class representation using the slice parameters.\n\n        Args:\n            type_: The type the class was sliced with.\n            bound: The boundaries specified for the values of type_.\n            keyfunc: The comparison function used to check the value\n                boundaries.\n            keyfunc_name: The name of keyfunc.\n\n        Returns:\n            A string representing the class.\n        \"\"\"\n        if keyfunc is not cls._default:\n            return \"{}.{}[{}, {}, {}]\".format(\n                cls.__module__,\n                cls.__name__,\n                cls._get_fullname(type_),\n                cls._get_bound_repr(bound),\n                keyfunc_name,\n            )\n        return \"{}.{}[{}, {}]\".format(\n            cls.__module__,\n            cls.__name__,\n            cls._get_fullname(type_),\n            cls._get_bound_repr(bound),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_args(cls, args):\n        # type: (tuple) -> Tuple[Any, slice, Callable]\n        \"\"\"Return the parameters necessary to check type boundaries.\n\n        Args:\n            args: A tuple with two or three elements: a type, a slice\n                representing the minimum and maximum lengths allowed for values\n                of that type and, optionally, a function to use on values\n                before comparing against the bounds.\n\n        Returns:\n            A tuple with three elements: a type, a slice, and a function to\n            apply to objects of the given type. If no function was specified,\n            it returns the identity function.\n        \"\"\"\n        if not isinstance(args, tuple):\n            raise TypeError(\n                \"{}[...] takes two or three arguments.\".format(cls.__name__)\n            )\n        elif len(args) == 2:\n            type_, bound = args\n            keyfunc = cls._identity\n        elif len(args) == 3:\n            type_, bound, keyfunc = args\n        else:\n            raise TypeError(\n                \"Too many parameters given to {}[...]\".format(cls.__name__)\n            )\n        if not isinstance(bound, slice):\n            bound = slice(bound)\n        return eval_type(type_), bound, keyfunc", "response": "Returns the parameters needed to check type boundaries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the full name of an object including the module.", "response": "def _get_fullname(obj):\n        # type: (Any) -> str\n        \"\"\"Get the full name of an object including the module.\n\n        Args:\n            obj: An object.\n\n        Returns:\n            The full class name of the object.\n        \"\"\"\n        if not hasattr(obj, \"__name__\"):\n            obj = obj.__class__\n        if obj.__module__ in (\"builtins\", \"__builtin__\"):\n            return obj.__name__\n        return \"{}.{}\".format(obj.__module__, obj.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the parameters needed to check type boundaries.", "response": "def _get_args(cls, args):\n        # type: (tuple) -> Tuple[type, slice, Callable]\n        \"\"\"Return the parameters necessary to check type boundaries.\n\n        Args:\n            args: A tuple with two parameters: a type, and a slice representing\n                the minimum and maximum lengths allowed for values of that\n                type.\n\n        Returns:\n            A tuple with three parameters: a type, a slice, and the len\n            function.\n        \"\"\"\n        if not isinstance(args, tuple) or not len(args) == 2:\n            raise TypeError(\n                \"{}[...] takes exactly two arguments.\".format(cls.__name__)\n            )\n        return super(_LengthBoundedMeta, cls)._get_args(args + (len,))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_args(cls, args):\n        # type: (tuple) -> Tuple[type, slice, Callable]\n        \"\"\"Return the parameters necessary to check type boundaries.\n\n        Args:\n            args: A tuple with one or two parameters: A type to cast the\n                value passed, and a predicate function to use for bounds\n                checking.\n\n        Returns:\n            A tuple with three parameters: a type, a slice, and the predicate\n            function. If no type was passed in args, the type defaults to Any.\n        \"\"\"\n        if isinstance(args, tuple):\n            if not len(args) == 2:\n                raise TypeError(\n                    \"{}[...] takes one or two argument.\".format(cls.__name__)\n                )\n            return super(_ValidationBoundedMeta, cls)._get_args(\n                (args[0], None, args[1])\n            )\n        return super(_ValidationBoundedMeta, cls)._get_args((Any, None, args))", "response": "Return the parameters needed to check type boundaries."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a string representation of the class.", "response": "def _get_class_repr(cls, type_, bound, keyfunc, keyfunc_name):\n        # type: (Any, slice, Callable, str) -> str\n        \"\"\"Return a class representation using the slice parameters.\n\n        Args:\n            type_: The type the class was sliced with.\n            bound: The boundaries specified for the values of type_.\n            keyfunc: The comparison function used to check the value\n                boundaries.\n            keyfunc_name: The name of keyfunc.\n\n        Returns:\n            A string representing the class.\n        \"\"\"\n        if type_ is not Any:\n            return \"{}.{}[{}, {}]\".format(\n                cls.__module__,\n                cls.__name__,\n                cls._get_fullname(type_),\n                keyfunc_name,\n            )\n        return \"{}.{}[{}]\".format(cls.__module__, cls.__name__, keyfunc_name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the parameters necessary to check type boundaries.", "response": "def _get_args(cls, args):\n        # type: (tuple) -> Tuple[type, slice, Callable]\n        \"\"\"Return the parameters necessary to check type boundaries.\n\n        Args:\n            args: A slice representing the minimum and maximum lengths allowed\n                for values of that string.\n\n        Returns:\n            A tuple with three parameters: a type, a slice, and the len\n            function.\n        \"\"\"\n        if isinstance(args, tuple):\n            raise TypeError(\n                \"{}[...] takes exactly one argument.\".format(cls.__name__)\n            )\n        return super(_StringMeta, cls)._get_args((_STR_TYPE, args))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_class_repr(cls, type_, bound, keyfunc, keyfunc_name):\n        # type: (Any, slice, Callable, str) -> str\n        \"\"\"Return a class representation using the slice parameters.\n\n        Args:\n            type_: The type the class was sliced with. This will always be\n                _STR_TYPE.\n            bound: The boundaries specified for the values of type_.\n            keyfunc: The comparison function used to check the value\n                boundaries. This will always be builtins.len().\n            keyfunc_name: The name of keyfunc. This will always be 'len'.\n\n        Returns:\n            A string representing the class.\n        \"\"\"\n        return \"{}.{}[{}]\".format(\n            cls.__module__, cls.__name__, cls._get_bound_repr(bound)\n        )", "response": "Return a string representation of the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, key, recursive=False, sorted=False, quorum=False,\n            timeout=None):\n        \"\"\"Gets a value of key.\"\"\"\n        return self.adapter.get(key, recursive=recursive, sorted=sorted,\n                                quorum=quorum, timeout=timeout)", "response": "Gets a value of a key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwaits until a node changes.", "response": "def wait(self, key, index=0, recursive=False, sorted=False, quorum=False,\n             timeout=None):\n        \"\"\"Waits until a node changes.\"\"\"\n        return self.adapter.get(key, recursive=recursive, sorted=sorted,\n                                quorum=quorum, wait=True, wait_index=index,\n                                timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef refresh(self, key, ttl, prev_value=None, prev_index=None,\n                timeout=None):\n        \"\"\"Sets only a TTL of a key.  The waiters doesn't receive notification\n        by this operation.\n        \"\"\"\n        return self.adapter.set(key, ttl=ttl, refresh=True,\n                                prev_value=prev_value, prev_index=prev_index,\n                                timeout=timeout)", "response": "Refreshes the TTL of a key."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new key.", "response": "def create(self, key, value=None, dir=False, ttl=None, timeout=None):\n        \"\"\"Creates a new key.\"\"\"\n        return self.adapter.set(key, value, dir=dir, ttl=ttl,\n                                prev_exist=False, timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, key, value=None, dir=False, ttl=None, refresh=False,\n               prev_value=None, prev_index=None, timeout=None):\n        \"\"\"Updates an existing key.\"\"\"\n        return self.adapter.set(key, value, dir=dir, ttl=ttl, refresh=refresh,\n                                prev_value=prev_value, prev_index=prev_index,\n                                prev_exist=True, timeout=timeout)", "response": "Updates an existing key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new automatically increasing key in the given directory key.", "response": "def append(self, key, value=None, dir=False, ttl=None, timeout=None):\n        \"\"\"Creates a new automatically increasing key in the given directory\n        key.\n        \"\"\"\n        return self.adapter.append(key, value, dir=dir, ttl=ttl,\n                                   timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _process(self, envelope, session, mode, **kwargs):\n\t\tif mode == WMessengerOnionPackerLayerProto.Mode.pack:\n\t\t\treturn self.pack(envelope, session, **kwargs)\n\t\telse:  # mode == WMessengerOnionPackerLayerProto.Mode.unpack\n\t\t\treturn self.unpack(envelope, session, **kwargs)", "response": "Implementation of the process method."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a linear list of timestamps and a list of integers specifying the sequence and the number of levels.", "response": "def create_timing_signals(timings,ranges=[3,8]):\n    \"\"\"\n        Creates a linear list/np.array of timestamps and a list of integers, specifying the sequence \n        and number of levels.\n\n        The levels are first rotated on the first dimension, then the second and so on. If the \n        last dimension is -1, the number of levels is computed from the timestamps.\n\n        returns a 2 dimensional array with len(ranges) + 1 columns\n            * the timestamp is in the first column\n            * the following columns contain the specific level for this time stamp\n\n        Example:\n\n            utils.create_timing_signals(range(100),[2,5,-1])\n\n        will return a matrix with the first column being the nubmers from 0 to 99, \n        the second alternates between 0 and 1 (eg. whether the number is odd), the third column \n        contains numbers 0 to 4, each bracketing a block of 2*5 = 10 numbers. The last column is\n        computed according to the length of the timeseries (in this case 100/(2*5) is 10, ie the \n        column counts blocks of 10 numbers).\n    \"\"\"\n    if ranges[-1] == -1:\n        ranges[-1] = np.floor(len(timings)/float(np.prod(ranges[:-1]))) + 1\n    return np.array([([t]+[cc for cc in c]) for t,c in zip(timings,icartesian([range(int(r)) for r in ranges]))]).transpose()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds a spike container in a multi spike containers collection", "response": "def find(self,cell_designation,cell_filter=lambda x,c: 'c' in x and x['c'] == c):\n        \"\"\"\n            finds spike containers in a multi spike containers collection\n        \"\"\"\n        res = [i for i,sc in enumerate(self.spike_containers) if cell_filter(sc.meta,cell_designation)]\n        if len(res) > 0:\n            return res[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a new SpikeContainerCollection with the same attributes as self but with the given time signals.", "response": "def label_by_time(self,time_signals,label_names=[],copy=False, **kwargs):\n        \"\"\"\n            creates a labeled spike data structure\n\n                time_label_array is list of lists (or matrix), containing a timestamp in the \n                first column (or first element of each element) and indizes that are to be \n                applied to the data in the remaining columns / elements.\n\n            This function will not add or remove spikes, but only shift spikes according to the \n            adjecent time signals.\n\n            If you want to get spikes relative to a time signal with fixed limits, use `label_peri_signals`,\n            which will leave out and duplicate spikes, but can manage overlapping time signals.\n\n\n        \"\"\"\n        new_containers = []\n        for sc in self.spike_containers:\n            new_sc = sc.label_by_time(time_signals=time_signals,copy=True, label_names=label_names, **kwargs)\n            new_containers.append(new_sc)\n        return SpikeContainerCollection(new_containers,\n                        units=self.units,\n                        min_t=self.min_t,\n                        max_t=self.max_t, \n                        copy_from=self, \n                        label_names = label_names, \n                        index_dimensions = np.max(time_signals[1:,:],1)+1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef len(self,resolution=1.0,units=None,conversion_function=convert_time, end_at_end=True):\n        if units is not None:\n            resolution = conversion_function(resolution,from_units=units,to_units=self.units)\n        else:\n            units = self.units\n        if self.min is None:\n            return int(self.max / resolution)\n        if self.max is None:\n            return 0\n        if units != '1' and end_at_end:\n            return int(np.ceil((self.max - self.min) / resolution))\n        return int(np.ceil((self.max - self.min) / resolution) + 1)", "response": "Calculates the length of the Label Dimension from its minimum maximum and wether it is discrete."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a spikes for the dimension.", "response": "def space(self,bins=None,units=None,conversion_function=convert_time,resolution=None,end_at_end=True,scale=None):\n        \"\"\"\n            Computes adequat binning for the dimension (on the values).\n\n                bins: number of bins or None\n                units: str or None\n                conversion_function: function to convert units to other units\n                resolution: step size or None\n                end_at_end: Boolean\n                    only if `unit == 1`\n                    whether or not the last point should be the last data point (True) or one after the last valid point (False)\n                scale: 'lin','log' or None\n                    a spike container can also use 'unique', but not the LabelDimension itself!\n                    if the LabelDimension.scale is 'unique', .bins() will return a linear spacing\n        \"\"\"\n        if scale in ['log'] or (scale is None and self.scale in ['log']):\n            return self.logspace(bins=bins,units=units,conversion_function=conversion_function,resolution=resolution,end_at_end=end_at_end)\n        return self.linspace(bins=bins,units=units,conversion_function=conversion_function,resolution=resolution,end_at_end=end_at_end)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute adequat binning for the label.", "response": "def bins(self,bins=None,units=None,conversion_function=convert_time,resolution=None,scale=None):\n        \"\"\"\n            Computes adequat binning for the dimension (between the values).\n\n                bins: number of bins or None\n                units: str or None\n                conversion_function: function to convert units to other units\n                resolution: step size or None\n                scale: 'lin','log' or None\n                    a spike container can also use 'unique', but not the LabelDimension itself!\n                    if the LabelDimension.scale is 'unique', .bins() will return a linear spacing\n        \"\"\"\n        if scale in ['log'] or (scale is None and self.scale in ['log']):\n            return self.logspace_bins(bins=bins,units=units,conversion_function=conversion_function,resolution=resolution)\n        #if scale in ['lin','linear'] or (scale is None and self.scale in ['lin','linear']):\n        return self.linspace_bins(bins=bins,units=units,conversion_function=conversion_function,resolution=resolution)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate bin edges for a linspace tiling", "response": "def linspace_bins(self,bins=None,units=None,conversion_function=convert_time,resolution=None,end_at_end=True,extra_bins=0):\n        \"\"\"Generates bin edges for a linspace tiling: there is one edge more than bins and each bin is in the middle between two edges\"\"\"\n        bins = self.linspace(bins=bins,units=units,conversion_function=conversion_function,resolution=resolution,end_at_end=end_at_end,extra_bins=extra_bins)\n        resolution = bins[1] - bins[0]\n        bins = np.concatenate([bins,bins[-1:]+resolution]) - 0.5*resolution\n        return bins"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logspace(self,bins=None,units=None,conversion_function=convert_time,resolution=None,end_at_end=True):\n        if type(bins) in [list, np.ndarray]:\n            return bins\n        min = conversion_function(self.min,from_units=self.units,to_units=units)\n        max = conversion_function(self.max,from_units=self.units,to_units=units)\n        if units is None:\n            units = self.units\n        if resolution is None:\n            resolution = 1.0\n        if bins is None:\n            bins = self.len(resolution=resolution,units=units,conversion_function=conversion_function)# + 1\n        if units != '1' and end_at_end:\n            # continuous variable behaviour:\n            #   we end with the last valid value at the outer edge\n            return np.logspace(np.log10(min),np.log10(max),bins+1)[:-1]\n        # discrete variable behaviour:\n        #   we end with the last valid value as its own bin\n        return np.logspace(np.log10(min),np.log10(max),bins)", "response": "Return a numpy array of log10 values in the specified bins."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate bin edges for a logspace tiling", "response": "def logspace_bins(self,bins=None,units=None,conversion_function=convert_time,resolution=None):\n        \"\"\"Generates bin edges for a logspace tiling: there is one edge more than bins and each bin is between two edges\"\"\"\n        bins = self.logspace(bins=bins,units=units,conversion_function=conversion_function,resolution=resolution,end_at_end=False)\n        resolution = np.mean((bins[:-1]) / (bins[1:]))\n        bins = np.concatenate([bins*np.sqrt(resolution),bins[-1:]/np.sqrt(resolution)])\n        return bins"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of dictionaries which each give a constraint for a certain section of the dimension.", "response": "def constraint_range_dict(self,*args,**kwargs):\n        \"\"\" \n            Creates a list of dictionaries which each give a constraint for a certain\n            section of the dimension.\n\n            bins arguments overwrites resolution\n        \"\"\"\n        bins = self.bins(*args,**kwargs)\n        return [{self.name+'__gte': a,self.name+'__lt': b} for a,b in zip(bins[:-1],bins[1:])]\n        space = self.space(*args,**kwargs)\n        resolution = space[1] - space[0]\n        return [{self.name+'__gte': s,self.name+'__lt': s+resolution} for s in space]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_labels(self,key,find_in_name=True,find_in_units=False):\n        if type(key) is str:\n            found_keys = []\n            if key.startswith('~'):\n                for label_no,label in enumerate(self.labels):\n                    if find_in_name and key[1:] in label.name:\n                        found_keys.append(label_no)\n                    if find_in_units and key[1:] in label.units:\n                        found_keys.append(label_no)\n            else:\n                for label_no,label in enumerate(self.labels):\n                    if find_in_name and key == label.name:\n                        return [label_no]\n                    if find_in_units and key == label.units:\n                        return [label_no]\n            return found_keys\n        if hasattr(key, '__call__'):\n            found_keys = []\n            for label_no,label in enumerate(self.labels):\n                    if key(label):\n                        found_keys.append(label_no)\n            return found_keys\n        if type(key) is int:\n            return [key] if key < self.matrix.shape[1] else []\n        return [key]", "response": "Given a string or a function to find a set of label indizes \n            that match."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef table(self,x,*args,**kwargs):\n        reduce_func = kwargs.get('reduce',lambda x: x)\n        data = []\n        for i,d in enumerate(self.generate(*args)):\n            if len(d) > 0:\n                data.append(reduce_func(d[x]))\n            else:\n                data.append(0)\n        try:\n            return np.reshape(data,[len(self.space(a)) for a in args])\n        except:\n            return np.reshape(data,[-1]+[len(self.space(a)) for a in args])", "response": "returns the values of column x\n            in an n - dimensional array each dimension being the values from the generated column x\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a dimension in place", "response": "def convert(self,label,units=None,conversion_function=convert_time):\n        \"\"\" converts a dimension in place \"\"\"\n        label_no = self.get_label_no(label)\n        new_label, new_column = self.get_converted(label_no,units,conversion_function)\n        labels = [LabelDimension(l) for l in self.labels]\n        labels[label_no] = new_label\n        matrix = self.matrix.copy()\n        matrix[:,label_no] = new_column\n        return LabeledMatrix(matrix,labels)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_constrained_labels(self,remove_dimensions=False,**kwargs):\n        new_labels = []\n        for label_no,label in enumerate(self.labels):\n            new_label = LabelDimension(label)\n            remove = False\n            for k in kwargs:\n                if k == label.name:\n                    new_label.max = kwargs[k]\n                    new_label.min = kwargs[k]\n                    remove = True\n                if k == label.name+'__lt':\n                    if new_label.units == '1':\n                        new_label.max = np.min([new_label.max,kwargs[k]-1]) # is this right?\n                    else:\n                        new_label.max = np.min([new_label.max,kwargs[k]])\n                    #remove = True\n                if k == label.name+'__lte':\n                    new_label.max = np.min([new_label.max,kwargs[k]])\n                    #remove = True\n                if k == label.name+'__gt':\n                    if new_label.units == '1':\n                        new_label.min = np.max([new_label.min,kwargs[k]+1])\n                    else:\n                        new_label.min = np.max([new_label.min,kwargs[k]])\n                    #remove = True\n                if k == label.name+'__gte':\n                    new_label.min = np.max([new_label.min,kwargs[k]])\n                    #remove = True\n                if k == label.name+'__evals':\n                    remove = True\n            if remove_dimensions:\n                if remove:\n                    # skipping removed labels\n                    continue\n            new_labels.append(new_label)\n        return new_labels", "response": "Returns a list of labels which have updated minima and maxima depending on the kwargs supplied to this object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate(self,*args,**kwargs):\n        constraints = []\n        remove_dimensions = kwargs.pop('remove_dimensions',False)\n        resolution = kwargs.get('resolution',None) \n        bins = kwargs.get('bins',None) \n        if len(args) == 0:\n            generator_indizes = range(1,len(self.labels))\n        else:\n            if kwargs.get(\"fuzzy\",False):\n                generator_indizes = [kk for k in args for kk in self.find_labels('~'+k)]\n            else:\n                generator_indizes = [kk for k in args for kk in self.find_labels(k)]\n        if kwargs.get(\"reversed\",True):\n            generator_indizes = list(reversed(generator_indizes))\n        kwargs.pop('reversed',None)\n        kwargs.pop('fuzzy',None)\n        generator_ranges = cartesian([self.constraint_range_dict(i,**kwargs) for i in generator_indizes])\n        remaining_label_dimensions = [i for i,l in enumerate(self.labels) if i not in generator_indizes]\n        for generator_t in generator_ranges:\n            constraints = {}\n            for ri, i in enumerate(generator_indizes):\n                constraints.update(generator_t[ri])\n            yield self(remove_dimensions=remove_dimensions,**constraints)", "response": "Generates an iterator over the object s index dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a copy of the current object.", "response": "def copy(self,**kwargs):\n        \"\"\"\n            Copies the spikes and optionally converts the spike times.\n            (when the keyword units is not None)\n        \"\"\"\n        new_spike_times = LabeledMatrix(self.spike_times.matrix,self.spike_times.labels) # copies the data\n        return SpikeContainer(new_spike_times, copy_from=self,**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef label_by_time(self,time_signals,label_names=[],time_units='ms',time_dimension=0,copy=True,backup_original_spike_times_to=None,**kwargs):\n        if self.data_format == 'empty':\n            return SpikeContainer(None,units=self.units,copy_from=self)\n        spike_times = self.spike_times.get_converted(time_dimension, units=time_units)[1].copy() # this is read only\n        time_signals = np.array(time_signals)\n        re_zeroed_spike_times = spike_times.copy() # this will be modified\n        indizes = np.zeros((len(spike_times),time_signals.shape[0] -1 ))\n        maximal_time_gap = np.max(np.diff(time_signals[0]))\n        for t in range(len(time_signals[0])):\n            if t + 1 < len(time_signals[0]):\n                # we are past the last time signal\n                spike_range = (spike_times > time_signals[0][t]) * (spike_times <= time_signals[0][t+1])\n                indizes[spike_range,:] = [time_signals[_i][t] for _i in range(1,time_signals.shape[0])]\n                re_zeroed_spike_times[spike_range] = (\n                        spike_times[spike_range] - time_signals[0][t]\n                    )\n            else:\n                # we move all spikes in the future back by this time signal\n                # (this will overwrite the spike times multiple times)\n                indizes[spike_times > time_signals[0][t],:] = [time_signals[_i][t] for _i in range(1,time_signals.shape[0])]\n                re_zeroed_spike_times[spike_times > time_signals[0][t]] = (\n                        spike_times[spike_times > time_signals[0][t]] - time_signals[0][t]\n                    )\n        new_spike_times = LabeledMatrix(self.spike_times.matrix,self.spike_times.labels)\n        new_spike_times.add_label_dimension(label_names,indizes)\n        new_spike_times.labels[0].units = time_units\n        new_spike_times.matrix[:,0] = re_zeroed_spike_times\n        new_spike_times.labels[0].min = 0\n        new_spike_times.labels[0].max = maximal_time_gap\n        if kwargs.get('recalculate_time_extent',False):\n            new_spike_times.labels[0].min = np.min(re_zeroed_spike_times)\n            new_spike_times.labels[0].max = np.max(re_zeroed_spike_times)\n        if backup_original_spike_times_to is not None:\n            new_spike_times.add_label_dimension(backup_original_spike_times_to,self[time_dimension])\n        if copy:\n            s = SpikeContainer(new_spike_times, copy_from=self)\n            #if backup_original_spike_times_to is not None:\n            #    # copying spikes\n            #    time_label = self.get_label(time_dimension)\n            #    s[backup_original_spike_times_to] = {'data':self[time_dimension],'label': time_label}\n            return s\n        else:\n            #if backup_original_spike_times_to is not None:\n            #    # copying spikes\n            #    time_label = self.get_label(time_dimension)\n            #    self[backup_original_spike_times_to] = {'data':self[time_dimension],'label': time_label}\n            self.set_spike_times(new_spike_times)\n            return self", "response": "Returns a new SpikeContainer with the labelled spikes in the given time_signals."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _absolute_spike_times_from_labels(self,time_dimension=0,*args,**kwargs):\n        x = self[time_dimension].copy()\n        #x = self.spike_times.get_converted(time_dimension,kwargs.get('units',None))\n        factor = self.len(time_dimension,units=kwargs.get('units',None),resolution=kwargs.get('resolution',1.0))\n        for a in args:\n            if a in self:\n                x += factor * self[a]\n                factor *= self.len(a)\n        for k in kwargs.keys():\n            if k in self:\n                x += factor * self[k]\n                if kwargs[k] is not None:\n                    factor *= kwargs[k]\n                else:\n                    factor *= self.len(k)\n        return x,factor", "response": "internal function that gives absolute_spike_times_from_labels as well as \n            the factor"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef absolute_spike_times_from_labels(self,time_dimension=0,*args,**kwargs):\n        return self._absolute_spike_times_from_labels(time_dimension,*args,**kwargs)[0]", "response": "Returns a list of spike times for the given time dimension and arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a labeled spike container for each time signal.", "response": "def label_peri_signals(self,time_signals,label_names=[],units=None,data_units=None,copy=True, pre_signal = 100.0, post_signal = 1000.0, **kwargs):\n        \"\"\"\n            creates a labeled spike data structure\n\n            time_label_array is list of lists (or matrix), containing a timestamp in the \n            first column (or first element of each element) and indizes that are to be \n            applied to the data in the remaining columns / elements.\n\n\n            This function will leave out and duplicate spikes to manage overlapping time signals.\n\n            If you want to get spikes relative to a time signal with felxible limits, use `label_by_time`,\n            which will not add or remove spikes, but only shift spikes according to the \n            adjecent time signals.\n\n        \"\"\"\n        if self.data_format == 'empty':\n            return SpikeContainer(None,units=self.units,copy_from=self)\n        time_signals[0] = convert_time(time_signals[0],from_units=data_units,to_units=units)\n        spike_times = self.spike_times.convert(0,units).matrix.copy() # this is read only\n        new_matrix = []\n        for t in range(len(time_signals[0])):\n            condition = (spike_times[:,0] >= time_signals[0][t] - pre_signal)*(spike_times[:,0] < time_signals[0][t] + post_signal)\n            new_spikes = (spike_times[condition,0] - time_signals[0][t])[:,np.newaxis]\n            old_labels = spike_times[condition,1:]\n            new_labels = [[time_signals[_i][t] for _i in range(1,time_signals.shape[0])]] * np.sum(condition)\n            if np.sum(condition) > 0:\n                new_matrix.append(np.concatenate([new_spikes,old_labels,new_labels],axis=1))\n        if len(new_matrix) == 0:\n            return SpikeContainer(None,copy_from=self)\n        new_matrix = np.concatenate(new_matrix,0)\n        if copy:\n            new_spike_times = LabeledMatrix(new_matrix,self.spike_times.labels + label_names)\n            new_spike_times.labels[0].units = units\n            new_spike_times.labels[0].min = pre_signal\n            new_spike_times.labels[0].max = post_signal\n            s = SpikeContainer(new_spike_times, copy_from=self)\n            return s\n        else:\n            new_spike_times = LabeledMatrix(new_matrix,self.spike_times.labels + label_names)\n            new_spike_times.labels[0].units = units\n            new_spike_times.labels[0].min = pre_signal\n            new_spike_times.labels[0].max = post_signal\n            self.set_spike_times(new_spike_times)\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the inter - spike times in the specified units", "response": "def ISIs(self,time_dimension=0,units=None,min_t=None,max_t=None):\n        \"\"\"\n            returns the Inter Spike Intervals\n\n                `time_dimension`: which dimension contains the spike times (by default the first)\n\n                `units`,`min_t`,`max_t`: define the units of the output and the range of spikes that should be considered\n        \"\"\"\n        units = self._default_units(units)\n        converted_dimension,st = self.spike_times.get_converted(time_dimension,units)\n        if min_t is None:\n            min_t = converted_dimension.min\n        if max_t is None:\n            max_t = converted_dimension.max\n        return np.diff(sorted(st[(st>min_t) * (st <max_t)]))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the spatial firing rate of a neuron.", "response": "def spatial_firing_rate(self,label_x='x',label_y='y',bins=None,resolution=1.0,geometry=None,weight_function=None,normalize_time=True,normalize_n=False,start_units_with_0=True):\n        \"\"\"\n                `bins` can be either a number of bins (has to be int) or a list of edges.\n                `bins` can be a tuple (for x and y respectively).\n\n                imshow(s.spatial_firing_rate(weight_function=lambda x: (x[:,1]>0.5)*(x[:,1]<0.6)))\n\n        \"\"\"\n        if bool(self):\n            if type(bins) is tuple:\n                if type(bins[0]) is int:\n                    bins_x = self.spike_times.get_label(label_y).linspace_bins(bins=bins[0])\n                else:\n                    bins_x = bins[0]\n                if type(bins[1]) is int:\n                    bins_y = self.spike_times.get_label(label_x).linspace_bins(bins=bins[1])\n                else:\n                    bins_y = bins[1]\n            else:\n                if type(bins) is int:\n                    bins_x = self.spike_times.get_label(label_y).linspace_bins(bins=bins)\n                    bins_y = self.spike_times.get_label(label_x).linspace_bins(bins=bins)\n                else:\n                    bins_x = bins\n                    bins_y = bins\n            if weight_function is None:\n                H,xed,yed = np.histogram2d(self.spike_times[label_x],self.spike_times[label_y],bins=(bins_x,bins_y))\n            else:\n                if start_units_with_0:\n                    ## TODO : reintroduce a neuron number thing\n                    spike_numbers = np.transpose([self.spikes[:,0]-self.n_range[0],self.spikes[:,1]])\n                    weights = weight_function(spike_numbers)\n                else:\n                    weights = weight_function(self.spike_times[label_x],self.spike_times[label_y])\n                H,xed,yed = np.histogram2d(self.spike_times[label_x],self.spike_times[label_y],bins=(bins_x,bins_y),weights=weights)\n            if normalize_time:\n                H = H/(self.spike_times.labels[0].convert('s').len())\n            if normalize_n:\n                H = H/cells_per_bin\n            return H,xed,yed\n        else:\n            return (np.array([[0]]),np.array([0]),np.array([0]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots a 2D histogram of the firing rates of the spike.", "response": "def plot_spatial_firing_rate(self,label_x='x',label_y='y',bins=None,resolution=1.0,geometry=None,weight_function=None,normalize_time=True,normalize_n=False,start_units_with_0=True,**kwargs):\n        \"\"\"\n            Plots a two dimensional representation of the firing rates.\n            Each spike is binned according to two labels (`label_x`='x' and `label_y`='y'),\n            which give a 2d histogram with `bins` many bins in each direction.\n            By default, the number of bins orients itself on the dimensions of the \n            respective labels, sampling them from the minimum to the maximum with \n            `resolution`, which defaults to 1. \n\n            `bins` and `resolution` can be tuples corresponding to the x and y values.\n\n        \"\"\"\n        if bool(self):\n            import matplotlib.pylab as plt\n            if bins is None:\n                if type(resolution) is tuple:\n                    bins = (self.linspace_bins(label_x,resolution=resolution[0]),self.linspace_bins(label_y,resolution=resolution[1]))\n                else:\n                    bins = (self.linspace_bins(label_x,resolution=resolution),self.linspace_bins(label_y,resolution=resolution))\n            H,xed,yed = self.spatial_firing_rate(label_x=label_x,label_y=label_y,bins=bins,geometry=geometry,weight_function=weight_function,normalize_time=normalize_time,normalize_n=False,start_units_with_0=start_units_with_0)\n            Y, X = np.meshgrid(yed, xed)\n            kwargs['cmap'] = kwargs.get('cmap','gray')\n            plt.pcolormesh(X, Y, H,**kwargs)\n            plt.gca().set_aspect('equal')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef temporal_firing_rate(self,time_dimension=0,resolution=1.0,units=None,\n                             min_t=None,max_t=None,weight_function=None,normalize_time=False,\n                             normalize_n=False,start_units_with_0=True,cell_dimension='N'):\n        \"\"\"\n            Outputs a time histogram of spikes.\n\n            `bins`: number of bins (default is 1ms bins from 0 to t_max)\n            `weight_function`: if set, computes a weighted histogram, dependent on the (index, time) tuples of each spike\n\n                    weight_function = lambda x: weight_map.flatten()[array(x[:,0],dtype=int)]\n\n            `normalize_time`\n            `normalize_n`:  normalize by the length of time (such that normal output is Hz) and/or number of units (such that output is Hz/unit, determined with unique values in cell_dimension)\n                            Generally does not make sense when using a weight_function other than 'count'.\n\n            `start_units_with_0`: starts indizes from 0 instead from the actual index\n        \"\"\"\n        units = self._default_units(units)\n        if self.data_format == 'spike_times':\n            converted_dimension,st = self.spike_times.get_converted(0,units)\n            if min_t is None:\n                min_t = converted_dimension.min\n            if max_t is None:\n                max_t = converted_dimension.max\n            st = st[(st>=min_t)*(st<max_t)]\n            bins = converted_dimension.linspace_by_resolution(resolution,end_at_end=True,extra_bins=0)\n            H,edg = np.histogram(st,bins=bins)\n            if normalize_time:\n                H = H/(convert_time(resolution,from_units=units,to_units='s')) # make it Hertz\n            if normalize_n:\n                H = H/(len(np.unique(self.spike_times[cell_dimension])))\n            return H,edg", "response": "Outputs a time histogram of spikes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting a temporal firing rate plot.", "response": "def plot_temporal_firing_rate(self,time_dimension=0,resolution=1.0,units=None,min_t=None,max_t=None,weight_function=None,normalize_time=False,normalize_n=False,start_units_with_0=True,cell_dimension='N',**kwargs):\n        \"\"\"\n            Plots a firing rate plot.\n\n            Accepts the same keyword arguments as :func:`matplotlib.pylab.plot()` for lines (:class:`~matplotlib.lines.Line2D`), eg `color`, `linewidth` (or `lw`), `linestyle` (or `ls`).\n            See help for :func:`matplotlib.pylab.plot()`.\n        \"\"\"\n        if bool(self):\n            import matplotlib.pylab as plt\n            H,ed = self.temporal_firing_rate(time_dimension=time_dimension,resolution=resolution,units=units,min_t=min_t,max_t=max_t,weight_function=weight_function,normalize_time=normalize_time,normalize_n=normalize_n,start_units_with_0=start_units_with_0,cell_dimension=cell_dimension)\n            plt.plot(ed[1:],H,**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_raster(self,cell_dimension='N',time_dimension=0,\n                         resolution=1.0,units=None,min_t=None,max_t=None,\n                         weight_function=None,normalize_time=True,normalize_n=True,\n                         start_units_with_0=True,**kwargs):\n        \"\"\"Plots a raster plot with `cell_dimension` as y and `time_dimension` as x (default: 'N' and 0).\n\n            Accepts the same keyword arguments as matplotlib.pylab.plot() for points, eg. `marker`,\n            `markerfacecolor`, `markersize` (or `ms`), `markeredgecolor`.\n            See help for :func:`matplotlib.pylab.plot()`.\n\n            Examples\n            --------\n\n            \n                >>> import numpy as np\n                >>> from litus import spikes\n                >>> spiking_data = np.random.rand(2000,20,20) < 0.01\n                >>> s = spikes.SpikeContainer(np.transpose(np.where(spiking_data)),labels='txy')\n                >>> s['N'] = s['x']+20*s['y']\n                >>> s.plot_raster('N','t')\n                >>> s(t__gt=1000,t__lt=1500,x__lt=2).plot_raster(ms=10,marker='$\\\\alpha$') # default: 'N'\n                >>> s(t__gt=1000,t__lt=1500,y__lt=2).plot_raster(ms=10,marker='$\\\\beta$')  # default: 'N'\n                >>> s(n=350).plot_raster('n','t_rescaled',ms=10,marker='$\\\\gamma$')\n\n        \"\"\"\n        if bool(self):\n            import matplotlib.pylab as plt\n            plt.plot(self[time_dimension],self[cell_dimension],'.',**kwargs)\n            plt.xlim(min_t, max_t)", "response": "Plots a raster plot with the specified time dimension and units."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate(self,*args,**kwargs):\n        for st in self.spike_times.generate(*args,**kwargs):\n            yield SpikeContainer(st, copy_from=self)", "response": "Generates a new object of the correct type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef len(self,*args,**kwargs):\n        if len(args) == 0 or args == None:\n            return self.spike_times.matrix.shape[0]\n        if len(args) == 1:\n            return self.spike_times.get_label(args[0]).len(**kwargs)\n        return [self.spike_times.get_label(a).len(**kwargs) for a in args]", "response": "Returns the number of spikes or neurons in the respective unit."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_units(self,*args,**kwargs):\n        if len(args) == 1:\n            return self.spike_times.get_label(args[0]).units\n        return [self.spike_times.get_label(a).units for a in args]", "response": "Returns the units of a Dimension\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the minimum of a Dimension", "response": "def get_min(self,*args,**kwargs):\n        \"\"\"\n            Returns the minimum of a Dimension\n\n            TODO: conversion is not implemented yet but should be\n        \"\"\"\n        if len(args) == 1:\n            return self.spike_times.get_label(args[0]).min\n        return [self.spike_times.get_label(a).max for a in args]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_max(self,*args,**kwargs):\n        if len(args) == 1:\n            return self.spike_times.get_label(args[0]).max\n        return [self.spike_times.get_label(a).max for a in args]", "response": "Returns the maximum of a Dimension\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a range of values for a specific dimension that go from its minimum to its maximum either in certain steps or in fixed number of bins.", "response": "def linspace(self,dim,*args,**kwargs):\n        \"\"\"\n            Creates a range of values for a specific dimension that go from its minimum to its \n            maximum either in certain steps (resolution != None) or a fixed number of bins \n            (bins != None). The output can be converted into a different unit (eg. into 'seconds').\n\n            bins=None\n            units=None\n            conversion_function=convert_time\n            resolution=None\n\n            .. note::\n\n                Discrete Labels (units='1') will behave differently than continuous Labels (units='1.0' or 's' etc.)\n                To emulate the discrete behaviour, you can pass `end_at_end=False` to the function,\n                The default behaviour is continuous if `units != '1'` (that is the output units if specified).\n\n                A linspace from 0...5 will give 0, 1, 2, 3, 4, 5 (6 steps) for a discrete variable while\n                a continuous variable will be split into: 0.0-1.0,1.0-2.0,2.0-3.0,3.0-4.0,4.0-5.0\n                in 5 bins (at a resolution of 1.0).\n        \"\"\"\n        return self.spike_times.get_label(dim).linspace(*args,**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlike linspace but shifts the space to create edges for histograms.", "response": "def linspace_bins(self,dim,*args,**kwargs):\n        \"\"\"\n            Like linspace, but shifts the space to create edges for histograms.\n        \"\"\"\n        return self.spike_times.get_label(dim).linspace_bins(*args,**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_SpikeGeneratorGroup(self,time_label=0,index_label=1,reorder_indices=False,index_offset=True):\n        import brian2\n        spike_times = self.spike_times.convert(time_label,'s')[time_label]*brian2.second\n        indices = [0] * len(spike_times)\n        if len(self.spike_times.find_labels(index_label)):\n            indices = self.spike_times[index_label]\n        if index_offset is not False:\n            if index_offset is True:\n                indices = indices - self.spike_times.get_label(index_label).min\n            else:\n                indices = indices - index_offset\n            N = np.max(indices)\n        else:\n            N = self.spike_times.get_label(index_label).max\n        if reorder_indices:\n            indices_levels = np.sort(np.unique(indices)).tolist()\n            indices = np.array([indices_levels.index(i) for i in indices])\n            N = len(indices_levels)\n        return brian2.SpikeGeneratorGroup(N+1,indices = indices,\n                                            times = spike_times)", "response": "Creates a brian 2 create_SpikeGeneratorGroup object that contains the spikes in this container."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a neo. Segment containing the spike trains.", "response": "def to_neo(self,index_label='N',time_label=0,name='segment of exported spikes',index=0):\n        \"\"\"\n            Returns a `neo` Segment containing the spike trains.\n\n            Example usage::\n\n                import quantities as pq\n\n                seg = sp.to_neo()\n\n                fig = pyplot.figure()\n                trains = [st.rescale('s').magnitude for st in seg.spiketrains]\n                colors = pyplot.cm.jet(np.linspace(0, 1, len(seg.spiketrains)))\n                gca().eventplot(trains, colors=colors)\n                gca().set_title(seg.file_origin)\n\n                f = neo.io.AsciiSpikeTrainIO('a_spike_file.txt')\n                f.write_segment(seg)\n\n        \"\"\"\n        import neo\n        from quantities import s\n        seq = neo.Segment(name=name,index=index)\n        t_start = None\n        t_stop = None\n        if self.min_t is not None:\n            t_start = convert_time(self.min_t,from_units=self.units,to_units='s')*s\n        if self.max_t is not None:\n            t_stop = convert_time(self.max_t,from_units=self.units,to_units='s')*s\n        for train in self.generate(index_label):\n            seq.spiketrains.append(neo.SpikeTrain(train.spike_times.get_converted(time_label,'s')[1]*s,t_start=t_start,t_stop=t_stop))\n        return seq"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the modification status in the mode bar.", "response": "def qteModificationChanged(self, mod):\n        \"\"\"\n        Update the modification status in the mode bar.\n\n        This slot is Connected to the ``modificationChanged`` signal\n        from the ``QtmacsScintilla`` widget.\n        \"\"\"\n        if mod:\n            s = '*'\n        else:\n            s = '-'\n        self._qteModeBar.qteChangeModeValue('MODIFIED', s)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loadFile(self, fileName):\n\n        self.fileName = fileName\n        # Assign QFile object with the current name.\n        self.file = QtCore.QFile(fileName)\n        if self.file.exists():\n            # Load the file into the widget and reset the undo stack\n            # to delete the undo object create by the setText method.\n            # Without it, an undo operation would delete the content\n            # of the widget which is intuitive.\n            self.qteScintilla.setText(open(fileName).read())\n            self.qteScintilla.qteUndoStack.reset()\n        else:\n            msg = \"File <b>{}</b> does not exist\".format(self.qteAppletID())\n            self.qteLogger.info(msg)", "response": "Load the file into the applet and set the text to the current state of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef conv(arg,default=None,func=None):\n    '''\n    essentially, the generalization of\n    \n    arg if arg else default\n\n    or\n\n    func(arg) if arg else default\n    '''\n    if func:\n        return func(arg) if arg else default;\n    else:\n        return arg if arg else default;", "response": "conv is the generalization of\n    \n    arg if arg else default ;"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchunking l in n sized bits", "response": "def chunks(l,n):\n    '''chunk l in n sized bits'''\n    #http://stackoverflow.com/a/3226719\n    #...not that this is hard to understand.\n    return [l[x:x+n] for x in range(0, len(l), n)];"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filelines(fname,strip=False):\n    '''read lines from a file into lines...optional strip'''\n    with open(fname,'r') as f:\n        lines = f.readlines();\n    if strip:\n        lines[:] = [line.strip() for line in lines]\n    return lines;", "response": "read lines from a file into lines... optional strip"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a string into a list of a uniform type", "response": "def parse_utuple(s,urx,length=2):\n    '''parse a string into a list of a uniform type'''\n    if type(urx) != str:\n        urx=urx.pattern;\n    if length is not None and length < 1:\n        raise ValueError(\"invalid length: {}\".format(length));\n    if length == 1:\n        rx = r\"^ *\\( *{urx} *,? *\\) *$\".format(urx=urx);\n    elif length is None:\n        rx = r\"^ *\\( *(?:{urx} *, *)*{urx} *,? *\\) *$\".format(urx=urx);\n    else:\n        rx = r\"^ *\\( *(?:{urx} *, *){{{rep1}}}{urx} *,? *\\) *$\".format(\n            rep1=length-1,\n            urx=urx);\n    return re.match(rx,s);"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_numtuple(s,intype,length=2,scale=1):\n    '''parse a string into a list of numbers of a type'''\n    if intype == int:\n        numrx = intrx_s;\n    elif intype == float:\n        numrx = fltrx_s;\n    else:\n        raise NotImplementedError(\"Not implemented for type: {}\".format(\n            intype));\n    if parse_utuple(s, numrx, length=length) is None:\n        raise ValueError(\"{} is not a valid number tuple.\".format(s));\n    return [x*scale for x in evalt(s)];", "response": "parse a string into a list of numbers of a type"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a string of acceptable colors into matplotlib that is either strings or three tuples of rgb. Don t quote strings.", "response": "def parse_ctuple(s,length=2):\n    '''parse a string of acceptable colors into matplotlib, that is, either\n       strings, or three tuples of rgb. Don't quote strings.\n    '''\n    if parse_utuple(s, colrx_s, length=length) is None:\n        raise ValueError(\"{} is not a valid color tuple.\".format(s));\n    #quote strings\n    s=quote_subs(s,colorfix=True);\n    return evalt(s);"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a string of strings. Don t quote strings", "response": "def parse_stuple(s,length=2):\n    '''parse a string of strings. Don't quote strings'''\n    if parse_utuple(s, isrx_s, length=length) is None:\n        raise ValueError(\"{} is not a valid string tuple.\".format(s));\n    s = quote_subs(s);\n    return evalt(s);"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_qs(s, rx, parsef=None, length=2, quote=False):\n    '''helper for parsing a string that can both rx or parsef\n       which is obstensibly the parsef for rx.\n\n       Use parse colors for color tuples. This won't work with\n       those.\n    '''\n    if type(rx) != str:\n        rx = rx.pattern;\n    if re.match(\" *\\(.*\\)\", s):\n        if not parsef:\n            if parse_utuple(s,rx,length=length):\n                if quote:\n                    s=quote_subs(s);\n                return evalt(s);\n            else:\n                raise ValueError(\"{} did is not a valid tuple of {}\".format(\n                    s, rx));\n        else:\n            return parsef(s,length=length);\n    elif re.match('^ *{} *$'.format(rx), s):\n        if quote:\n            return eval('[\"{}\"]'.format(s));\n        return eval('[{}]'.format(s));\n    else:\n        raise ValueError(\"{} does not match '{}' or the passed parsef\".format(\n            s,rx));", "response": "helper for parsing a string that can both rx or parsef\n       Use parse colors for color tuples. This will not work with any color tuples."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef takef(d,l,val=None):\n    '''take(f) a list of keys and fill in others with val'''\n    return {i:(d[i] if i in d else val)\n            for i in l};", "response": "take a list of keys and fill in others with val"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mk_getkw(kw, defaults,prefer_passed=False):\n    '''\n    a helper for generating a function for reading keywords in\n    interface functions with a dictionary with defaults\n\n    expects the defaults dictionary to have keywords you request.\n\n    example:\n    defaults = dict(a='a',b=3);\n    def bigfunc(**kw):\n        getkw=mk_getkw(kw,defaults);\n\n        # I want the callers' `a', or the default if s/he doesn't\n        # supply it\n        a=getkw('a');\n        c = [a]*getkw('b');\n        return c,c[0]; \n\n    Option:\n        prefer_passed -- use \"l in kw\" only, not test.\n    '''\n    def getkw(*ls):\n        r = [ kw[l] if test(kw,l) else defaults[l]\n              for l in ls ];\n        if len(r) == 1: return r[0];\n        return r;\n    def getkw_prefer_passed(*ls):\n        r = [ kw[l] if l in kw else defaults[l]\n              for l in ls ];\n        if len(r) == 1: return r[0];\n        return r;\n    return getkw if not prefer_passed else getkw_prefer_passed;", "response": "creates a helper for generating a function for reading keywords in\n    interface functions with a dictionary with defaults dictionary with keywords you request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading resource data from server", "response": "def _load_resource(self):\n        \"\"\"Load resource data from server\"\"\"\n\n        url = self._url\n        if self._params:\n            url += '?{0}'.format(six.moves.urllib_parse.urlencode(self._params))\n\n        r = getattr(self._session, self._meta.get_method.lower())(url)\n\n        if r.status_code == 404:\n            raise NotFoundException('Server returned 404 Not Found for the URL {0}'.format(self._url))\n        elif not 200 <= r.status_code < 400:\n            raise HTTPException('Server returned {0} ({1})'.format(r.status_code, r.reason), r)\n\n        data = self._meta.deserializer.to_dict(r.text)\n        self.populate_field_values(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload resource data and populate field values", "response": "def populate_field_values(self, data):\n        \"\"\"Load resource data and populate field values\"\"\"\n\n        if not self._meta.case_sensitive_fields:\n            data = {k.lower(): v for k, v in six.iteritems(data)}\n\n        if self._meta.match_fuzzy_keys:\n            # String any non-alphanumeric chars from each key\n            data = {''.join(x for x in k if x in ALPHANUMERIC).lower(): v for k, v in six.iteritems(data)}\n\n        for field in self._meta.fields:\n            name = field.name if self._meta.case_sensitive_fields else field.name.lower()\n            value = None\n\n            if self._meta.match_fuzzy_keys:\n                name = ''.join(x for x in name if x in ALPHANUMERIC).lower()\n\n            if name in data:\n                value = field.to_python(data[name], self)\n            elif field.required and field.default is None:\n                message = \"Response from {0} is missing required field '{1}'\".format(self._url, field.name)\n                if self._strict:\n                    raise MissingFieldException(message)\n                else:\n                    logger.warn(message)\n            elif field.default is not None:\n                value = copy.copy(field.default)\n\n            setattr(self, field._attr_name, value)\n\n        self._populated_field_values = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef close_thread(self):\n\t\tif self.__thread is not None and self.__thread.is_alive() is True:\n\t\t\traise WThreadJoiningTimeoutError('Thread is still alive. Thread name: %s' % self.__thread.name)\n\t\tself.start_event().clear()\n\t\tself.__thread = None", "response": "Closes all object descriptors for stopped task."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stop(self):\n\t\tthread = self.thread()\n\t\tif thread is not None:\n\t\t\tif self.stop_event() is not None:\n\t\t\t\tself.stop_event().set()\n\n\t\t\tself.thread_stopped()\n\n\t\t\tif self.stop_event() is not None:\n\t\t\t\tthread.join(self.join_timeout())\n\t\t\t\tself.close_thread()", "response": "stop method for this object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_events(self):\n\t\treturn (\n\t\t\tself.ready_event().is_set() is True or\n\t\t\tself.stop_event().is_set() is True or\n\t\t\tself.exception_event().is_set() is True\n\t\t)", "response": "Check if any of the events in the queue are set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef thread_stopped(self):\n\t\ttask = self.task()\n\t\tif isinstance(task, WStoppableTask) is True:\n\t\t\ttask.stop()", "response": "Stop thread if task is stoppable"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef thread_started(self):\n\t\twhile self.check_events() is False:\n\t\t\tself._polling_iteration()\n\t\t\tself.stop_event().wait(self.polling_timeout())", "response": "Start polling for a stop event or ready event via\n\t. _polling_iteration method"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstopping the current thread if it is running.", "response": "def thread_stopped(self):\n\t\t\"\"\" :meth:`.WThreadTask._polling_iteration` implementation\n\t\t\"\"\"\n\t\tif self.__current_task is not None:\n\t\t\ttask = self.__task_chain[self.__current_task]\n\t\t\ttask.stop()\n\t\t\tself.__current_task = None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking header name for validity. Return True if name is valid otherwise False", "response": "def header_name_check(header_name):\n\t\t\"\"\" Check header name for validity. Return True if name is valid\n\n\t\t:param header_name: name to check\n\t\t:return: bool\n\t\t\"\"\"\n\t\theader_match = WHTTPHeaders.header_name_re.match(header_name.encode('us-ascii'))\n\t\treturn len(header_name) > 0 and header_match is not None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_headers(self, header_name):\n\t\tif self.__ro_flag:\n\t\t\traise RuntimeError('ro')\n\t\theader_name = self.normalize_name(header_name)\n\t\tif header_name in self.__headers.keys():\n\t\t\tself.__headers.pop(header_name)", "response": "Removes a header by its name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd new header to the response", "response": "def add_headers(self, header_name, value, *values):\n\t\t\"\"\" Add new header\n\n\t\t:param header_name: name of the header to add\n\t\t:param value: header value\n\t\t:param values: additional header values (in a result request/response must be concatenated by the coma \\\n\t\tor by the separate header string)\n\t\t:return: None\n\t\t\"\"\"\n\t\tif self.__ro_flag:\n\t\t\traise RuntimeError('ro')\n\t\theader_name = self.normalize_name(header_name)\n\t\tif header_name not in self.__headers.keys():\n\t\t\tself.__headers[header_name] = [value]\n\t\telse:\n\t\t\tself.__headers[header_name].append(value)\n\n\t\tfor single_value in values:\n\t\t\tself.__headers[header_name].append(single_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces header value with specified value and or values and return None", "response": "def replace_headers(self, header_name, value, *values):\n\t\t\"\"\" Replace header value with specified value and/or values\n\n\t\t:param header_name: target header\n\t\t:param value: new header value\n\t\t:param values: additional header values (in a result request/response must be concatenated by the coma \\\n\t\tor by the separate header string)\n\t\t:return: None\n\t\t\"\"\"\n\t\tif self.__ro_flag:\n\t\t\traise RuntimeError('ro')\n\t\theader_name = self.normalize_name(header_name)\n\t\tself.remove_headers(header_name)\n\t\tself.add_headers(header_name, value, *values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns header value by its name header", "response": "def get_headers(self, header_name):\n\t\t\"\"\" Return header value by its name\n\n\t\t:param header_name: header name\n\t\t:return: tuple of str\n\t\t\"\"\"\n\t\theader_name = self.normalize_name(header_name)\n\t\tif header_name in self.__headers.keys():\n\t\t\treturn tuple(self.__headers[header_name])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn header name as it is recommended by corresponding http protocol. For HTTP version 0. 9 - 2 and 0. 1 - 1. 1 are supported.", "response": "def normalize_name(self, header_name):\n\t\t\"\"\" Return header name as it is recommended (required) by corresponding http protocol. For\n\t\tprotocol switching use :meth:`.WHTTPHeaders.switch_name_style` method.\n\n\t\tAll current available protocols (0.9-2) compare header names in a case-insensitive fashion. However,\n\t\tprevious protocol versions (0.9-1.1) recommends to use camel-case names like Foo or Foo-Bar. But\n\t\tHTTP/2 (RFC 7540) strictly requires lowercase only header names.\n\n\t\t:param header_name: name to convert\n\t\t:return: str\n\t\t\"\"\"\n\t\tif self.__normalization_mode in ['0.9', '1.0', '1.1']:\n\t\t\treturn '-'.join([x.capitalize() for x in header_name.split('-')])\n\t\telif self.__normalization_mode == '2':\n\t\t\treturn header_name.lower()\n\t\traise RuntimeError('Internal error: unknown http protocol: %s' % self.__normalization_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef switch_name_style(self, http_protocol_version):\n\t\tnew_headers = WHTTPHeaders()\n\t\tnew_headers.__normalization_mode = http_protocol_version\n\t\tnames = self.headers()\n\t\tfor name in names:\n\t\t\tnew_headers.add_headers(name, *self.get_headers(name))\n\t\tfor cookie_name in self.__set_cookies.cookies():\n\t\t\tnew_headers.__set_cookies.add_cookie(self.__set_cookies[cookie_name].copy())\n\t\treturn new_headers", "response": "Return object copy with header names saved as it is described in the given HTTP protocol version."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ro(self):\n\t\tro_headers = WHTTPHeaders()\n\t\tnames = self.headers()\n\t\tfor name in names:\n\t\t\tro_headers.add_headers(name, *self.get_headers(name))\n\t\tro_headers.__cookies = self.__set_cookies.ro()\n\t\tro_headers.__ro_flag = True\n\t\treturn ro_headers", "response": "Return read - only copy of this object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef content_type(self, value=None):\n\t\tcontent_type = self.normalize_name('Content-Type')\n\t\tif value is not None:\n\t\t\tself.replace_headers(content_type, value)\n\t\tif content_type in self.__headers.keys():\n\t\t\treturn self.__headers[content_type][0]", "response": "Set or get Content - Type header value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef client_cookie_jar(self):\n\t\tcookie_jar = WHTTPCookieJar()\n\t\tcookie_header = self.get_headers('Cookie')\n\t\tfor cookie_string in (cookie_header if cookie_header is not None else tuple()):\n\t\t\tfor single_cookie in WHTTPCookieJar.import_header_text(cookie_string):\n\t\t\t\tcookie_jar.add_cookie(single_cookie)\n\n\t\treturn cookie_jar.ro()", "response": "Return internal cookie jar that must be used as HTTP - request cookies\n\t\tsee : class :. WHTTPCookieJar"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_headers(cls, http_code):\n\t\theaders = WHTTPHeaders()\n\t\tmessage = email.message_from_file(StringIO(http_code))\n\t\tfor header_name, header_value in message.items():\n\t\t\theaders.add_headers(header_name, header_value)\n\n\t\tcookie_header = headers.get_headers('Set-Cookie')\n\t\tif cookie_header is not None:\n\t\t\tfor cookie_string in cookie_header:\n\t\t\t\tfor single_cookie in WHTTPCookieJar.import_header_text(cookie_string):\n\t\t\t\t\theaders.set_cookie_jar().add_cookie(single_cookie)\n\t\t\theaders.remove_headers('Set-Cookie')\n\n\t\treturn headers", "response": "Create WHTTPHeaders by the given HTTP code."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_request_line(cls, session, request_line):\n\t\tr = cls.request_line_re.search(request_line)\n\t\tif r is not None:\n\t\t\tmethod, path, protocol_sentence, protocol_version = r.groups()\n\t\t\treturn WWebRequest(session, method, path)\n\t\traise ValueError('Invalid request line')", "response": "Parse given request line like GET POST or HTTP 1. 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing HTTP - code and retrieve it", "response": "def parse_headers(self, http_code):\n\t\t\"\"\" Parse http-code (like 'Header-X: foo\\r\\nHeader-Y: bar\\r\\n') and retrieve (save) HTTP-headers\n\n\t\t:param http_code: code to parse\n\t\t:return: None\n\t\t\"\"\"\n\t\tif self.__ro_flag:\n\t\t\traise RuntimeError('Read-only object changing attempt')\n\t\tself.__headers = WHTTPHeaders.import_headers(http_code)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate read - only copy of this object", "response": "def ro(self):\n\t\t\"\"\" Create read-only copy\n\n\t\t:return: WWebRequest\n\t\t\"\"\"\n\t\trequest = WWebRequest(\n\t\t\tself.session(), self.method(), self.path(),\n\t\t\theaders=self.headers().ro(), request_data=self.request_data()\n\t\t)\n\t\trequest.__ro_flag = True\n\t\treturn request"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef simple_contact(request, username=\"\"):\r\n    site = Site.objects.get_current()\r\n    form = ContactForm(request.POST or None)\r\n    UserModel = get_user_model()\r\n    recipients = []\r\n    site_form = False\r\n\r\n    logger.debug('Recipients should be empty: %s' % recipients)\r\n\r\n    # if we know, fill in the user name and email\r\n    if request.user.is_authenticated:\r\n        # first, resolve username for tango and non-tango sites\r\n        try:\r\n            name = request.user.display_name\r\n        except AttributeError:\r\n            name = request.user.username\r\n        form.fields['sender_name'].widget.attrs['readonly'] = 'true'\r\n        form.fields['sender_name'].initial = name\r\n        form.fields['sender_email'].widget.attrs['readonly'] = 'true'\r\n        form.fields['sender_email'].initial = request.user.email\r\n\r\n    if username:\r\n        member = get_object_or_404(UserModel, username=username)\r\n        recipients = [member.email, ]\r\n        logger.debug('Recipients should be a single user: %s' % recipients)\r\n\r\n    else:\r\n        # site contact form.\r\n        # Use first of settings.DEFAULT_CONTACTS or all superusers\r\n        site_form = True\r\n        member = None\r\n        recipients = getattr(settings, \"DEFAULT_CONTACTS\", None)\r\n        logger.debug('Recipients should be match DEFAULT_CONTACTS: %s' % recipients)\r\n\r\n        if not recipients:\r\n            recipients = UserModel.objects.filter(is_superuser=True).values_list('email', flat=True)\r\n            warnings.warn(\r\n                \"settings.DEFAULT_CONTACTS does not exist. You may want to create it.\",\r\n                RuntimeWarning\r\n            )\r\n            logger.debug('Recipients should be superusers: %s' % recipients)\r\n\r\n    if form.is_valid():\r\n        if site_form:\r\n            subject = \"A {} contact form submission from {}\".format(\r\n                site.name, form.cleaned_data['sender_name']\r\n            )\r\n        else:\r\n            subject = \"A message from {} on {}\".format(form.cleaned_data['sender_name'], site.name)\r\n        body = form.cleaned_data['body']\r\n\r\n        sender_email = form.cleaned_data['sender_email']\r\n\r\n        if 'send_a_copy' in request.POST:\r\n            recipients.append(sender_email)\r\n            logger.debug('Recipients should be match prior + sender email: %s' % recipients)\r\n\r\n        mail = EmailMessage(\r\n            subject=subject,\r\n            body=body,\r\n            from_email=sender_email,\r\n            to=recipients\r\n        )\r\n        mail.send()\r\n        return HttpResponseRedirect(success_url)\r\n    return render(request, 'contact/simple_form.html', {\r\n        'form': form,\r\n        'site': site,\r\n        'member': member\r\n    })", "response": "Returns a new contact form that can be used to contact a single site member."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild appropriate contact form based on options", "response": "def build_contact(request, slug=\"\"):\r\n    \"\"\"\r\n    Builds appropriate contact form based on options\r\n    set in the contact_form controller.\r\n    \"\"\"\r\n    controller = get_object_or_404(ContactFormController, slug=slug)\r\n    site = Site.objects.get_current()\r\n    UserModel = get_user_model()\r\n    user = request.user\r\n    form = ContactForm(request.POST or None, request.FILES or None, controller=controller)\r\n\r\n    # if we know, fill in the user name and email\r\n    if user.is_authenticated:\r\n        # first, resolve username for tango and non-tango sites\r\n        try:\r\n            name = user.display_name\r\n        except AttributeError:\r\n            name = user.username\r\n        form.fields['sender_name'].widget.attrs['readonly'] = 'true'\r\n        form.fields['sender_name'].initial = name\r\n        form.fields['sender_email'].widget.attrs['readonly'] = 'true'\r\n        form.fields['sender_email'].initial = user.email\r\n\r\n    if form.is_valid():\r\n        if controller.store_in_db:\r\n            # To do: sanitize submission.\r\n            new_msg = Contact(**form.cleaned_data)\r\n            new_msg.controller = controller\r\n            new_msg.site = site\r\n            if controller.override_subject:  # we're overriding the subject\r\n                new_msg.subject = controller.override_subject\r\n            new_msg.save()\r\n\r\n        if controller.send_emails:\r\n            form_data = form.cleaned_data\r\n            if controller.override_subject:\r\n                subject = controller.override_subject\r\n            elif 'subject' in form_data:\r\n                subject = form_data['subject']\r\n            else:\r\n                subject = \"{} message from {}\".format(controller.name, form_data['sender_name'])\r\n\r\n            body = \"{} \\n\\n {}\".format(form_data['body'], form_data['sender_name'])\r\n            if controller.request_contact_info:\r\n                body += \"\\nAddress: {} \\nCity: {} \\nState: {} \\nPhone: {}\".format(\r\n                    form_data['contact_address'],\r\n                    form_data['contact_city'],\r\n                    form_data['contact_state'],\r\n                    form_data['contact_phone']\r\n                )\r\n\r\n            if controller.email_options == '2':  # Create selectable list from recipients\r\n                try:\r\n                    to = [UserModel.objects.get(username=form.cleaned_data['to']).email]\r\n                except Exception:\r\n                    to = [form.cleaned_data['to']]\r\n\r\n            if controller.email_options == '1':\r\n                to = [r.email for r in controller.recipients.all()]\r\n                for r in controller.other_recipients.all():\r\n                    to.append(r.email)\r\n\r\n            if 'send_a_copy' in form.cleaned_data:\r\n                to.append(form.cleaned_data['sender_email'])\r\n\r\n            mail = EmailMessage(\r\n                subject=subject,\r\n                body=body,\r\n                from_email=form.cleaned_data['sender_email'],\r\n                to=to\r\n            )\r\n            if 'photo' in request.FILES:\r\n                photo = request.FILES['photo']\r\n                mail.attach(photo.name, photo.read(), photo.content_type)\r\n            mail.send()\r\n        return render(request, 'success_url', {'controller': controller})\r\n\r\n    return render(request, 'contact/form.html', {\r\n        'form': form,\r\n        'site': site,\r\n        'controller': controller\r\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pale_webapp2_request_handler_generator(pale_endpoint):\n    def pale_handler(self, *args, **kwargs):\n        if self.request.method == \"OPTIONS\":\n            origin = self.request.headers.get(\"Origin\", None)\n            self.response.headers['Access-Control-Allow-Origin'] = origin\n            self.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept'\n            self.response.headers['Access-Control-Allow-Methods'] = 'POST, GET, PUT, DELETE'\n            self.response.headers['Access-Control-Allow-Credentials'] = 'true'\n            return self.response\n\n        try:\n            return pale_endpoint._execute(self.request)\n        finally:\n            pale_endpoint._finally()\n\n    cls = type(pale_endpoint._route_name,\n            (webapp2.RequestHandler,),\n            dict(pale_handler=pale_handler))\n    return cls", "response": "Generate a webapp2. RequestHandler class for the pale endpoint."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bind_pale_to_webapp2(pale_app_module,\n        webapp_wsgiapplication,\n        route_prefix=None):\n    \"\"\"Binds a Pale API implementation to a webapp2 WSGIApplication\"\"\"\n\n    if not isinstance(webapp_wsgiapplication, webapp2.WSGIApplication):\n        raise TypeError(\"pale.adapters.webapp2.bind_pale_to_webapp2 expected \"\n                \"the passed in webapp_wsgiapplication to be an instance of \"\n                \"WSGIApplication, but it was an instance of %s instead.\"\n                % (type(webapp_wsgiapplication), ))\n\n    if not pale.is_pale_module(pale_app_module):\n        raise TypeError(\"pale.adapters.webapp2.bind_pale_to_webapp2 expected \"\n                \"the passed in pale_app_module to be a Python module with a \"\n                \"`_module_type` value equal to `pale.ImplementationModule`, \"\n                \"but it found an instance of %s instead.\"\n                % (type(pale_app_module), ))\n\n    endpoints = pale.extract_endpoints(pale_app_module)\n\n    for endpoint in endpoints:\n        endpoint._set_response_class(RESPONSE_CLASS)\n        method = endpoint._http_method\n        name = endpoint._route_name\n\n        req_handler = pale_webapp2_request_handler_generator(endpoint)\n\n        route_uri = endpoint._uri\n        if route_prefix is not None:\n            route_uri = \"%s%s\" % (route_prefix, route_uri)\n\n        route = webapp2.Route(\n                route_uri,\n                handler=req_handler,\n                name=name,\n                handler_method='pale_handler',\n                methods=[method, \"OPTIONS\"])\n        webapp_wsgiapplication.router.add(route)", "response": "Binds a Pale API implementation to a webapp2 WSGIApplication."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode(self, envelope, session, target=None, modification_code=None, **kwargs):\n\t\tself.__args_check(envelope, target, modification_code)\n\n\t\tif isinstance(envelope, WMessengerTextEnvelope):\n\t\t\ttarget_envelope_cls = WMessengerTextEnvelope\n\t\telse:  # isinstance(envelope, WMessengerBytesEnvelope)\n\t\t\ttarget_envelope_cls = WMessengerBytesEnvelope\n\n\t\tif target == WMessengerFixedModificationLayer.Target.head:\n\t\t\treturn target_envelope_cls(modification_code + envelope.message(), meta=envelope)\n\t\telse:  # target == WMessengerFixedModificationLayer.Target.tail\n\t\t\treturn target_envelope_cls(envelope.message() + modification_code, meta=envelope)", "response": "Method appends modification_code to the specified envelope."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode(self, envelope, session, encoding=None, **kwargs):\n\t\tmessage = envelope.message()\n\t\tmessage = message.encode() if encoding is None else message.encode(encoding)\n\t\treturn WMessengerBytesEnvelope(message, meta=envelope)", "response": ":meth:`.WMessengerOnionCoderLayerProto.encode` method implementation.\n\n\t\t:param envelope: original envelope\n\t\t:param session: original session\n\t\t:param encoding: encoding to use (default is 'utf-8')\n\t\t:param kwargs: additional arguments\n\n\t\t:return: WMessengerBytesEnvelope"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode(self, envelope, session, **kwargs):\n\t\treturn WMessengerBytesEnvelope(bytes(WUnHex(envelope.message())), meta=envelope)", "response": ":meth:`.WMessengerOnionCoderLayerProto.decode` method implementation.\n\n\t\t:param envelope: original envelope\n\t\t:param session: original session\n\t\t:param kwargs: additional arguments\n\n\t\t:return: WMessengerBytesEnvelope"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode(self, envelope, session, **kwargs):\n\t\treturn WMessengerBytesEnvelope(b64encode(envelope.message()), meta=envelope)", "response": "method implementation. encode method implementation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode(self, envelope, session, **kwargs):\n\t\treturn WMessengerBytesEnvelope(b64decode(envelope.message()), meta=envelope)", "response": ":meth:`.WMessengerOnionCoderLayerProto.decode` method implementation.\n\n\t\t:param envelope: original envelope\n\t\t:param session: original session\n\t\t:param kwargs: additional arguments\n\n\t\t:return: WMessengerBytesEnvelope"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encode(self, envelope, session, aes_cipher=None, **kwargs):\n\t\treturn WMessengerBytesEnvelope(aes_cipher.encrypt(envelope.message()), meta=envelope)", "response": ":meth:`.WMessengerOnionCoderLayerProto.encode` method implementation.\n\n\t\t:param envelope: original envelope\n\t\t:param session: original session\n\t\t:param aes_cipher: cipher to use\n\t\t:param kwargs: additional arguments\n\n\t\t:return: WMessengerBytesEnvelope"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decode(self, envelope, session, private_key=None, oaep_hash_fn_name=None, mgf1_hash_fn_name=None, **kwargs):\n\t\tmessage = private_key.decrypt(\n\t\t\tenvelope.message(), oaep_hash_fn_name=oaep_hash_fn_name, mgf1_hash_fn_name=mgf1_hash_fn_name\n\t\t)\n\t\treturn WMessengerBytesEnvelope(message, meta=envelope)", "response": ":meth:`.WMessengerOnionCoderLayerProto.decode` method implementation.\n\n\t\t:param envelope: original envelope\n\t\t:param session: original session\n\t\t:param private_key: private key to decrypt\n\t\t:param oaep_hash_fn_name: hash function name\n\t\t:param mgf1_hash_fn_name: MGF1 hash function name\n\t\t:param kwargs: additional arguments\n\n\t\t:return: WMessengerBytesEnvelope"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks dependency of task for irresolvable conflicts", "response": "def dependency_check(self, task_cls, skip_unresolved=False):\n\t\t\"\"\" Check dependency of task for irresolvable conflicts (like task to task mutual dependency)\n\n\t\t:param task_cls: task to check\n\t\t:param skip_unresolved: flag controls this method behaviour for tasks that could not be found. \\\n\t\tWhen False, method will raise an exception if task tag was set in dependency and the related task \\\n\t\twasn't found in registry. When True that unresolvable task will be omitted\n\n\t\t:return: None\n\t\t\"\"\"\n\n\t\tdef check(check_task_cls, global_dependencies):\n\t\t\tif check_task_cls.__registry_tag__ in global_dependencies:\n\t\t\t\traise RuntimeError('Recursion dependencies for %s' % task_cls.__registry_tag__)\n\n\t\t\tdependencies = global_dependencies.copy()\n\t\t\tdependencies.append(check_task_cls.__registry_tag__)\n\n\t\t\tfor dependency in check_task_cls.__dependency__:\n\t\t\t\tdependent_task = self.tasks_by_tag(dependency)\n\t\t\t\tif dependent_task is None and skip_unresolved is False:\n\t\t\t\t\traise RuntimeError(\n\t\t\t\t\t\t\"Task '%s' dependency unresolved (%s)\" %\n\t\t\t\t\t\t(task_cls.__registry_tag__, dependency)\n\t\t\t\t\t)\n\n\t\t\t\tif dependent_task is not None:\n\t\t\t\t\tcheck(dependent_task, dependencies)\n\n\t\tcheck(task_cls, [])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef started_tasks(self, task_registry_id=None, task_cls=None):\n\n\t\tif task_registry_id is not None:\n\t\t\ttask = None\n\t\t\tfor registered_task in self.__started:\n\t\t\t\tif registered_task.__registry_tag__ == task_registry_id:\n\t\t\t\t\ttask = registered_task\n\n\t\t\tif task_cls is not None and task is not None:\n\t\t\t\tif isinstance(task, task_cls) is True:\n\t\t\t\t\treturn task\n\t\t\t\treturn None\n\t\t\treturn task\n\n\t\tresult = filter(lambda x: x is not None, self.__started)\n\t\tif task_cls is not None:\n\t\t\tresult = filter(lambda x: isinstance(x, task_cls), result)\n\t\treturn tuple(result)", "response": "Return tasks that were started. Result way be filtered by the given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking dependency for the given task_tag and start task.", "response": "def start_task(self, task_tag, skip_unresolved=False):\n\t\t\"\"\" Check dependency for the given task_tag and start task. For dependency checking see\n\t\t:meth:`.WTaskDependencyRegistryStorage.dependency_check`. If task is already started then it must be\n\t\tstopped before it will be started again.\n\n\t\t:param task_tag: task to start. Any required dependencies will be started automatically.\n\t\t:param skip_unresolved: flag controls this method behaviour for tasks that could not be found. \\\n\t\tWhen False, method will raise an exception if task tag was set in dependency and the related task \\\n\t\twasn't found in registry. When True that unresolvable task will be omitted\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tif self.started_tasks(task_registry_id=task_tag) is not None:\n\t\t\treturn\n\n\t\ttask_cls = self.tasks_by_tag(task_tag)\n\t\tif task_cls is None:\n\t\t\traise RuntimeError(\"Task '%s' wasn't found\" % task_tag)\n\n\t\tself.dependency_check(task_cls, skip_unresolved=skip_unresolved)\n\n\t\tdef start_dependency(start_task_cls):\n\t\t\tfor dependency in start_task_cls.__dependency__:\n\n\t\t\t\tif self.started_tasks(task_registry_id=dependency) is not None:\n\t\t\t\t\tcontinue\n\n\t\t\t\tdependent_task = self.tasks_by_tag(dependency)\n\n\t\t\t\tif dependent_task is not None:\n\t\t\t\t\tstart_dependency(dependent_task)\n\n\t\t\tself.__started.append(start_task_cls.start_dependent_task())\n\n\t\tstart_dependency(task_cls)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstops a task with the given task tag.", "response": "def stop_task(self, task_tag, stop_dependent=True, stop_requirements=False):\n\t\t\"\"\" Stop task with the given task tag. If task already stopped, then nothing happens.\n\n\t\t:param task_tag: task to stop\n\t\t:param stop_dependent: if True, then every task, that require the given task as dependency, will be \\\n\t\tstopped before.\n\t\t:param stop_requirements: if True, then every task, that is required as dependency for the given task, \\\n\t\twill be stopped after.\n\t\t:return: None\n\t\t\"\"\"\n\t\t# TODO: \"coverage\" requires more tests\n\n\t\ttask = self.started_tasks(task_registry_id=task_tag)\n\n\t\tif task is None:\n\t\t\treturn\n\n\t\tdef stop(task_to_stop):\n\t\t\tif task_to_stop in self.__started:\n\t\t\t\tif isinstance(task_to_stop, WStoppableTask) is True:\n\t\t\t\t\ttask_to_stop.stop()\n\t\t\t\tself.__started.remove(task_to_stop)\n\n\t\tdef stop_dependency(task_to_stop):\n\t\t\tdeeper_dependencies = []\n\t\t\tfor dependent_task in self.__started:\n\t\t\t\tif task_to_stop.__registry_tag__ in dependent_task.__class__.__dependency__:\n\t\t\t\t\tdeeper_dependencies.append(dependent_task)\n\n\t\t\tfor dependent_task in deeper_dependencies:\n\t\t\t\tstop_dependency(dependent_task)\n\n\t\t\tstop(task_to_stop)\n\n\t\tdef calculate_requirements(task_to_stop, cross_requirements=False):\n\t\t\trequirements = set()\n\n\t\t\tfor dependent_task in self.__started:\n\t\t\t\tif dependent_task.__class__.__registry_tag__ in task_to_stop.__class__.__dependency__:\n\t\t\t\t\trequirements.add(dependent_task)\n\n\t\t\tif cross_requirements is True:\n\t\t\t\treturn requirements\n\n\t\t\tresult = set()\n\t\t\tfor task_a in requirements:\n\t\t\t\trequirement_match = False\n\t\t\t\tfor task_b in requirements:\n\t\t\t\t\tif task_a.__class__.__registry_tag__ in task_b.__class__.__dependency__:\n\t\t\t\t\t\trequirement_match = True\n\t\t\t\t\t\tbreak\n\t\t\t\tif requirement_match is False:\n\t\t\t\t\tresult.add(task_a)\n\t\t\treturn result\n\n\t\tdef calculate_priorities(task_to_stop, *extra_tasks, current_result=None, requirements_left=None):\n\t\t\tif current_result is None:\n\t\t\t\tcurrent_result = []\n\n\t\t\ttasks_to_stop = [task_to_stop]\n\t\t\tif len(extra_tasks) > 0:\n\t\t\t\ttasks_to_stop.extend(extra_tasks)\n\n\t\t\tcurrent_result.append(list(tasks_to_stop))\n\n\t\t\tall_requirements = calculate_requirements(tasks_to_stop[0], cross_requirements=True)\n\t\t\tnested_requirements = calculate_requirements(tasks_to_stop[0])\n\n\t\t\tfor dependent_task in tasks_to_stop[1:]:\n\t\t\t\tnested_requirements = nested_requirements.union(calculate_requirements(dependent_task))\n\t\t\t\tall_requirements.update(calculate_requirements(dependent_task, cross_requirements=True))\n\n\t\t\tall_requirements = all_requirements.difference(nested_requirements)\n\n\t\t\tif requirements_left is not None:\n\t\t\t\trequirements_left = requirements_left.difference(all_requirements)\n\t\t\t\tnested_requirements.update(requirements_left)\n\n\t\t\tif len(nested_requirements) == 0:\n\t\t\t\treturn current_result\n\n\t\t\treturn calculate_priorities(\n\t\t\t\t*list(nested_requirements), current_result=current_result, requirements_left=all_requirements\n\t\t\t)\n\n\t\tif stop_dependent is True:\n\t\t\tstop_dependency(task)\n\n\t\tif stop_requirements is True:\n\t\t\tfor task_list in calculate_priorities(task):\n\t\t\t\tfor single_task in task_list:\n\t\t\t\t\tstop(single_task)\n\n\t\tif stop_dependent is not True:  # check if we've already stopped this task\n\t\t\tstop(task)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets registry storage : return: WTaskDependencyRegistryStorage", "response": "def registry_storage(cls):\n\t\t\"\"\" Get registry storage\n\n\t\t:return: WTaskDependencyRegistryStorage\n\t\t\"\"\"\n\t\tif cls.__registry_storage__ is None:\n\t\t\traise ValueError('__registry_storage__ must be defined')\n\t\tif isinstance(cls.__registry_storage__, WTaskDependencyRegistryStorage) is False:\n\t\t\traise TypeError(\n\t\t\t\t\"Property '__registry_storage__' is invalid (must derived from WTaskRegistryBase)\"\n\t\t\t)\n\n\t\treturn cls.__registry_storage__"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart task from registry", "response": "def start_task(cls, task_tag, skip_unresolved=False):\n\t\t\"\"\" Start task from registry\n\n\t\t:param task_tag: same as in :meth:`.WTaskDependencyRegistryStorage.start_task` method\n\t\t:param skip_unresolved: same as in :meth:`.WTaskDependencyRegistryStorage.start_task` method\n\t\t:return: None\n\t\t\"\"\"\n\t\tregistry = cls.registry_storage()\n\t\tregistry.start_task(task_tag, skip_unresolved=skip_unresolved)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstops started task from registry", "response": "def stop_task(cls, task_tag, stop_dependent=True, stop_requirements=False):\n\t\t\"\"\" Stop started task from registry\n\n\t\t:param task_tag: same as in :meth:`.WTaskDependencyRegistryStorage.stop_task` method\n\t\t:param stop_dependent: same as in :meth:`.WTaskDependencyRegistryStorage.stop_task` method\n\t\t:param stop_requirements: same as in :meth:`.WTaskDependencyRegistryStorage.stop_task` method\n\t\t:return: None\n\t\t\"\"\"\n\t\tregistry = cls.registry_storage()\n\t\tregistry.stop_task(task_tag, stop_dependent=stop_dependent, stop_requirements=stop_requirements)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef figure(path,display=False,close=True):\n    return Figure(path,display=display,close=close)", "response": "Returns a figure object with the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef alert(msg,body=\"\",icon=None):\n    if type(body) == str:\n        body = body[:200]\n    if call([\"which\",\"notify-send\"]) == 0:\n        if icon is not None:\n            call([\"notify-send\",msg,\"-i\",icon,body])\n        else:\n            call([\"notify-send\",msg,body])\n    else:\n        print((\"ALERT: \", msg))", "response": "alerts the user of something happening via notify - send."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef natural_sorted(l):\n    ll = copy(l)\n    ll.sort(key=_natural_keys)\n    return ll", "response": "sorts a sortable in human order"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fillzip(*l):\n    maximum = max(len(el) for el in l)\n    return zip(*[el + [el[-1]]*(maximum-len(el)) for el in l])", "response": "like zip but repeats the last element of all shorter lists."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate through generators recursively and flattens them.", "response": "def recgen_enumerate(gen,n=tuple(), fix_type_errors=True):\n    \"\"\"\n        Iterates through generators recursively and flattens them. (see `recgen`)\n\n        This function adds a tuple with enumerators on each generator visited.\n    \"\"\"\n    if not hasattr(gen,'__iter__'):\n        yield (n,gen)\n    else:\n        try:\n            for i_,i in enumerate(gen):\n                for element in recgen_enumerate(i,n+(i_,)):\n                    yield element\n        except TypeError:\n            if not fix_type_errors:\n                raise\n            yield (n,gen)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes a list of dictionaries and creates a dictionary of lists for each key in each dicitonary.", "response": "def list_of_dicts_to_dict_of_lists(list_of_dictionaries):\n    \"\"\"\n        Takes a list of dictionaries and creates a dictionary with the combined values for \n        each key in each dicitonary.\n        Missing values are set to `None` for each dicitonary that does not contain a key \n        that is present in at least one other dicitonary.\n\n            >>> litus.list_of_dicts_to_dict_of_lists([{'a':1,'b':2,'c':3},{'a':3,'b':4,'c':5},{'a':1,'b':2,'c':3}])\n\n            {'a': [1, 3, 1], 'b': [2, 4, 2], 'c': [3, 5, 3]}\n\n        Shorthand: `litus.ld2dl(..)`\n    \"\"\"\n    result = {}\n    all_keys = set([k for d in  list_of_dictionaries for k in d.keys()])\n    for d in list_of_dictionaries:\n        for k in all_keys:\n            result.setdefault(k,[]).append(d.get(k,None))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a dictionary of lists and creates a list of dictionaries.", "response": "def dict_of_lists_to_list_of_dicts(dictionary_of_lists):\n    \"\"\"\n        Takes a dictionary of lists and creates a list of dictionaries.\n        If the lists are of unequal length, the remaining entries are set to `None`.\n\n        Shorthand: `litus.dl2ld(..)`:\n\n            >>> litus.dl2ld({'a': [1, 3, 1], 'b': [2, 4, 2], 'c': [3, 5, 3]})\n\n            [{'a': 1, 'b': 2, 'c': 3}, {'a': 3, 'b': 4, 'c': 5}, {'a': 1, 'b': 2, 'c': 3}]\n\n    \"\"\"\n    return [{key: dictionary_of_lists[key][index] if len(dictionary_of_lists[key]) > index else None for key in dictionary_of_lists.keys()}\n         for index in range(max(map(len,dictionary_of_lists.values())))]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nliking enumerate but with colors", "response": "def colorate(sequence, colormap=\"\", start=0, length=None):\n    \"\"\" like enumerate, but with colors \"\"\"\n    n = start\n    colors = color_space(colormap, sequence, start=0.1, stop=0.9, length=length)\n    for elem in sequence:\n        yield n, colors[n-start], elem\n        n += 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun once to create all children containers for each combination of the keywords", "response": "def generate(self,**kwargs):\n        \"\"\"run once to create all children containers for each combination of the keywords\"\"\"\n        import collections\n        all_params = cartesian_dicts({k:kwargs[k] for k in kwargs.keys() if isinstance(kwargs[k], collections.Iterable)})\n        for pi,p in enumerate(all_params):\n            if self.name_mode == 'int':\n                n = str(len(self.containers))\n            else:\n                n = None\n            self.containers.append(PDContainer(name=n,params=p,parent=self))\n        self.parameters.update({ k: kwargs[k] for k in kwargs.keys() if not isinstance(kwargs[k], collections.Iterable) })\n        self.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a numpy array created from the list that was closed last n", "response": "def array(self,n=-1):\n        \"\"\"returns a numpy array created from the list that was closed last (if `n`=-1).\n        If `n` is None, the lists of the current level are returned as an array.\n        Other lists in the current level can also be accessed with `n` as the specific index.\n        \"\"\"\n        if n is None:\n            return np.array(self.list)\n        return np.array(self.list)[n]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generator(self,gen,*args,**kwargs):\n        with self(*args,**kwargs):\n            for i in gen:\n                yield i", "response": "Generator function that yields all the available items in the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates that the URL is valid raises an argument error if it s not.", "response": "def validate_url(self, original_string):\n        \"\"\"Returns the original string if it was valid, raises an argument\n        error if it's not.\n        \"\"\"\n\n        # nipped from stack overflow: http://stackoverflow.com/questions/827557/how-do-you-validate-a-url-with-a-regular-expression-in-python\n        # I preferred this to the thorough regex approach for simplicity and\n        # readability\n        pieces = urlparse.urlparse(original_string)\n        try:\n            if self.path_only:\n                assert not any([pieces.scheme, pieces.netloc])\n                assert pieces.path\n            else:\n                assert all([pieces.scheme, pieces.netloc])\n                valid_chars = set(string.letters + string.digits + \":-_.\")\n                assert set(pieces.netloc) <= valid_chars\n                assert pieces.scheme in ['http', 'https']\n\n        except AssertionError as e:\n            raise ArgumentError(self.item_name,\n                    \"The input you've provided is not a valid URL.\")\n        return pieces"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate(self, value, model=None, context=None):\n        import re\n\n        value = str(value)\n        match = re.match(r'^\\d+', value)\n        if not match or value != match.group():\n            return Error(self.not_digital)\n\n        # success otherwise\n        return Error()", "response": "Validates the value of a key - value pair and returns a SimpleResult object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the online. recoveryversion. bible URL for the given book name and chapter.", "response": "def build_recovery_online_url(self, book_name, book_chapter):\n        \"\"\"\n        Returns a string composing the url of the online.recoveryversion.bible\n        of the given book name and chapter\n        TODO: Write notes here about how that URL is composed, and what is expected\n        by online.recoveryversion.bible\n        \"\"\"\n        base_url = \"http://online.recoveryversion.bible/txo\"\n        return \"{}/{}_{}{}.htm\".format(\n                                base_url,\n                                self.get_book_number(book_name),\n                                # Spaces are removed to deal with book names\n                                # that include a number. i.e. 1 Corinthians\n                                book_name.replace(\" \", \"\"),\n                                book_chapter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_chapter(self, book_name, book_chapter, cache_chapter = True):\n\n        try:\n            logging.debug(\"Attempting to read chapter from disk\")\n            verses_list = self._get_ondisk_chapter(book_name, book_chapter)\n        except Exception as e:\n            logging.debug(\"Could not read file from disk. Attempting the internet..\")\n            logging.debug(e.message)\n            verses_list = self._get_online_chapter(book_name, book_chapter,\n                cache_chapter = cache_chapter)\n        return verses_list", "response": "Returns a list of chapter verses for a given book."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving the bible chapter from the given bible chapter on disk location.", "response": "def _get_ondisk_chapter(self, book_name, book_chapter):\n        \"\"\"\n        Retrieves the given bible chapter from it's on disk location.\n        Currently, the location `~/.diyr/<book_name>/` is supported\n        \"\"\"\n        # First attempt to look up the chapter on the disk\n        verses_list = []\n        filename = os.path.expanduser(\"~/.diyr/{}/{}\").format(\n            book_name,\n            book_chapter)\n        if os.path.isfile(filename):\n            # Read the file into a list\n            try:\n                f = open(filename)\n            except OSError as e:\n                logging.error(\"Could not read {}\".format(filename))\n                return [\"ERROR! Could not read {}\".format(filename)]\n\n            for line in f.readlines():\n                verses_list.append(line)\n\n            return verses_list\n        else:\n            # If the file is not cached, raise an Exception\n            raise Exception(\"The file {} is not cached!\".format(filename))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets an online chapter of a book in the Bible.", "response": "def _get_online_chapter(self, book_name, book_chapter,\n        cache_chapter):\n        \"\"\"\n        Retrieves an entire chapter of a book in the Bible in the form of a\n        list.\n        If cache_chapter is \"True\", this method will cache the chapter\n        in \"~/.diyr/bible/<book>/<chapter>.txt\".\n        \"\"\"\n        url = self.build_recovery_online_url(book_name, book_chapter)\n        logging.debug(\"Looking up chapter at URL: {}\".format(url))\n        r = requests.get(url)\n        if r.status_code != 200:\n            logging.error(\"Could not look up {} {} at URL {}\".format(\n                book_name,\n                book_chapter,\n                url))\n            raise Exception(\"Could not look up {} {} at URL {}\".format(\n                book_name,\n                book_chapter,\n                url))\n        chapter_html = r.text\n        soup = BeautifulSoup(chapter_html, 'html.parser')\n        verses_list_soup = soup.get_text().split('\\n')\n        # Clean up verses list. This is being done because some\n        # non-alphanumeric ASCII characters might have been picked up from the\n        # web scraper\n        verses_list = []\n        verse_num = 1\n        for verse in verses_list_soup:\n            verse = self._remove_non_ascii(verse)\n            if re.search(r'[0-9]+:[0-9]+', verse):\n                verses_list.append(\n                    re.sub(r'[0-9]+:[0-9]+',\n                           str(verse_num) + \".\",\n                           verse))\n                verse_num += 1\n\n        logging.debug(\"Successfully built list for {} chapter {}\".format(\n            book_name,\n            book_chapter))\n\n        # If cache_chapter is True, then write it to disk\n        if cache_chapter:\n            base_dir = os.path.expanduser(\"~/.diyr\")\n            book_dir = \"{}/{}\".format(base_dir, book_name)\n            chapter_file = \"{}/{}\".format(book_dir, book_chapter)\n            # Ensure ~/.diyr/ directory exists\n            if not os.path.isdir(base_dir):\n                os.mkdir(base_dir)\n            # Ensure the chapter directory exists\n            if not os.path.isdir(book_dir):\n                os.mkdir(book_dir)\n            # If the file doesn't already exists, then write to it the\n            # contents of the chapter\n            if not os.path.isfile(chapter_file):\n                f = open(chapter_file, 'w')\n                f.write(\"\\n\".join(verses_list))\n                f.close()\n\n        return verses_list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlook up a verse from online. recoveryversion. bible then returns it.", "response": "def verse_lookup(self, book_name, book_chapter, verse, cache_chapter = True):\n        \"\"\"\n        Looks up a verse from online.recoveryversion.bible, then returns it.\n        \"\"\"\n        verses_list = self.get_chapter(\n            book_name,\n            str(book_chapter),\n            cache_chapter = cache_chapter)\n        return verses_list[int(verse) - 1]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextend validate on submit to allow validation with schema", "response": "def validate_on_submit(self):\n        \"\"\" Extend validate on submit to allow validation with schema \"\"\"\n\n        # validate form\n        valid = FlaskWtf.validate_on_submit(self)\n\n        # return in case no schema or not submitted\n        if not self._schema or not self.is_submitted():\n            return valid\n\n        # validate data with schema if got one and form was submitted\n        data = dict()\n        for field in self._fields:\n            data[field] = self._fields[field].data\n\n        result = self.schema.process(data, context=self._force_context)\n        self.set_errors(result)\n\n        # set filtered data back to form\n        for field in data:\n            self._fields[field].data = data[field]\n\n        return valid and not bool(self.errors)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_errors(self, result):\n\n        # todo: use wtf locale\n        errors = result.get_messages()\n\n        for property_name in errors:\n            if not hasattr(self, property_name):\n                continue # ignore errors for missing fields\n\n            prop_errors = errors[property_name]\n            if type(prop_errors) is not list:\n                prop_errors = ['<Nested schema result following...>']\n            if property_name in self.errors:\n                self.errors[property_name].extend(prop_errors)\n            else:\n                self.errors[property_name] = prop_errors", "response": "Populate the errors field with errors from schema validation"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a list of revision documents and returns a generator of all the revision documents in order of their revision - related persistence fields.", "response": "def diffs2persistence(rev_docs, window_size=50, revert_radius=15, sunset=None,\n                      verbose=False):\n    \"\"\"\n    Processes a sorted and page-partitioned sequence of revision documents into\n    and adds a 'persistence' field to them containing statistics about how each\n    token \"added\" in the revision persisted through future revisions.\n\n    :Parameters:\n        rev_docs : `iterable` ( `dict` )\n            JSON documents of revision data containing a 'diff' field as\n            generated by ``dump2diffs``.  It's assumed that rev_docs are\n            partitioned by page and otherwise in chronological order.\n        window_size : `int`\n            The size of the window of revisions from which persistence data\n            will be generated.\n        revert_radius : `int`\n            The number of revisions back that a revert can reference.\n        sunset : :class:`mwtypes.Timestamp`\n            The date of the database dump we are generating from.  This is\n            used to apply a 'time visible' statistic.  If not set, now() will\n            be assumed.\n        keep_diff : `bool`\n            Do not drop the `diff` field from the revision document after\n            processing is complete.\n        verbose : `bool`\n            Prints out dots and stuff to stderr\n\n    :Returns:\n        A generator of rev_docs with a 'persistence' field containing\n        statistics about individual tokens.\n    \"\"\"\n    rev_docs = mwxml.utilities.normalize(rev_docs)\n    window_size = int(window_size)\n    revert_radius = int(revert_radius)\n    sunset = Timestamp(sunset) if sunset is not None \\\n                               else Timestamp(time.time())\n\n    # Group the docs by page\n    page_docs = groupby(rev_docs, key=lambda d: d['page']['title'])\n\n    for page_title, rev_docs in page_docs:\n\n        if verbose:\n            sys.stderr.write(page_title + \": \")\n\n        # We need a look-ahead to know how long this revision was visible\n        rev_docs = peekable(rev_docs)\n\n        # The window allows us to manage memory\n        window = deque(maxlen=window_size)\n\n        # The state does the actual processing work\n        state = DiffState(revert_radius=revert_radius)\n\n        while rev_docs:\n            rev_doc = next(rev_docs)\n            next_doc = rev_docs.peek(None)\n\n            if next_doc is not None:\n                seconds_visible = Timestamp(next_doc['timestamp']) - \\\n                                  Timestamp(rev_doc['timestamp'])\n            else:\n                seconds_visible = sunset - Timestamp(rev_doc['timestamp'])\n\n            if seconds_visible < 0:\n                logger.warn(\"Seconds visible {0} is less than zero.\"\n                            .format(seconds_visible))\n                seconds_visible = 0\n\n            _, tokens_added, _ = \\\n                state.update_opdocs(rev_doc['sha1'], rev_doc['diff']['ops'],\n                                    (rev_doc['user'], seconds_visible))\n\n            if len(window) == window_size:\n                # Time to start writing some stats\n                old_doc, old_added = window[0]\n                window.append((rev_doc, tokens_added))\n                persistence = token_persistence(old_doc, old_added, window,\n                                                None)\n                old_doc['persistence'] = persistence\n                yield old_doc\n                if verbose:\n                    sys.stderr.write(\".\")\n                    sys.stderr.flush()\n            else:\n                window.append((rev_doc, tokens_added))\n\n        while len(window) > 0:\n            old_doc, old_added = window.popleft()\n            persistence = token_persistence(old_doc, old_added, window, sunset)\n            old_doc['persistence'] = persistence\n            yield old_doc\n            if verbose:\n                sys.stderr.write(\"_\")\n                sys.stderr.flush()\n\n        if verbose:\n            sys.stderr.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the salt for the current session.", "response": "def salt(self):\n        \"\"\"\n        Generates a salt via pgcrypto.gen_salt('algorithm').\n        \"\"\"\n        cursor = connections[PGCRYPTOAUTH_DATABASE].cursor()\n        cursor.execute(\"SELECT gen_salt('%s')\" % PGCRYPTOAUTH_ALGORITHM)\n        return cursor.fetchall()[0][0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_channel(model_class, search_fields=()):\n    if len(search_fields) == 0:\n        search_fields = get_fields_with_icontains_filter(model_class)\n    channel_class = type(model_class.__name__ + \"LookupChannel\",\n                         (AutoLookupChannelBase,),\n                         {\"model\": model_class,\n                          \"dynamical_search_fields\": search_fields,\n                          })\n    channel_name = class_name_to_low_case(model_class.__name__)\n    registry.register({channel_name: channel_class})", "response": "Register a new channel for a given model class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generator(name):\n\t\tname = name.upper()\n\t\tif name not in WHash.__hash_map__.keys():\n\t\t\traise ValueError('Hash generator \"%s\" not available' % name)\n\t\treturn WHash.__hash_map__[name]", "response": "Return generator by its name\n\t\t"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns generator by family name and digest size", "response": "def generator_by_digest(family, digest_size):\n\t\t\"\"\" Return generator by hash generator family name and digest size\n\n\t\t:param family: name of hash-generator family\n\n\t\t:return: WHashGeneratorProto class\n\t\t\"\"\"\n\t\tfor generator_name in WHash.available_generators(family=family):\n\t\t\tgenerator = WHash.generator(generator_name)\n\t\t\tif generator.generator_digest_size() == digest_size:\n\t\t\t\treturn generator\n\t\traise ValueError('Hash generator is not available')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef available_generators(family=None, name=None):\n\t\tgenerators = WHash.__hash_map__.values()\n\n\t\tif family is not None:\n\t\t\tfamily = family.upper()\n\t\t\tgenerators = filter(lambda x: x.generator_family() == family, generators)\n\n\t\tif name is not None:\n\t\t\tname = name.upper()\n\t\t\tgenerators = filter(lambda x: x.generator_name() == name, generators)\n\n\t\treturn tuple([x.generator_name() for x in generators])", "response": "Return names of available hash - generators"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning names of available generators", "response": "def available_digests(family=None, name=None):\n\t\t\"\"\" Return names of available generators\n\n\t\t:param family: name of hash-generator family to select\n\t\t:param name: name of hash-generator to select\n\n\t\t:return: set of int\n\t\t\"\"\"\n\t\tgenerators = WHash.available_generators(family=family, name=name)\n\t\treturn set([WHash.generator(x).generator_digest_size() for x in generators])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sequence(cls, *info):\n\t\tif len(info) == 0:\n\t\t\treturn\n\n\t\tinfo = list(info)\n\t\tinfo.reverse()\n\n\t\tresult = WMessengerOnionSessionFlowProto.Iterator(\n\t\t\tinfo[0].layer_name(), **info[0].layer_args()\n\t\t)\n\n\t\tfor i in range(1, len(info)):\n\t\t\tresult = WMessengerOnionSessionFlowProto.Iterator(\n\t\t\t\tinfo[i].layer_name(), next_iterator=result, **info[i].layer_args()\n\t\t\t)\n\n\t\treturn result", "response": "This method returns a new iterator that can be used to chain the given info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iterator(self, envelope):\n\t\tfor pair in self.__pairs:\n\t\t\tif pair.comparator().match(envelope) is True:\n\t\t\t\treturn pair.flow().iterator(envelope)\n\n\t\tif self.__default_flow is not None:\n\t\t\treturn self.__default_flow.iterator(envelope)", "response": "implementation\n\tProto. iterator implementation\n\tProto. iterator"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a temporary directory optionally by placing a subdirectory.", "response": "def create_temporary_workspace(version=None, mode=0700):\n    # type: (str, int) -> str\n    \"\"\"\n    Create a temporary directory, optionally by placing a subdirectory: version\n    :rtype: str\n    :return: Directory path\n    \"\"\"\n    workspace = mkdtemp('hemp_')\n    if version is not None:\n        workspace = join(workspace, version)\n        mkdir(workspace, mode)\n    chmod(workspace, mode)\n    return workspace"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_string(address):\n\t\tstr_address = None\n\n\t\tif WMACAddress.re_dash_format.match(address):\n\t\t\tstr_address = \"\".join(address.split(\"-\"))\n\t\telif WMACAddress.re_colon_format.match(address):\n\t\t\tstr_address = \"\".join(address.split(\":\"))\n\t\telif WMACAddress.re_cisco_format.match(address):\n\t\t\tstr_address = \"\".join(address.split(\".\"))\n\t\telif WMACAddress.re_spaceless_format.match(address):\n\t\t\tstr_address = address\n\n\t\tif str_address is None:\n\t\t\traise ValueError(\"Invalid MAC address format: \" + address)\n\n\t\tresult = WMACAddress()\n\t\tfor octet_index in range(WMACAddress.octet_count):\n\t\t\toctet = str_address[:2]\n\t\t\tresult.__address[octet_index] = int(octet, 16)\n\t\t\tstr_address = str_address[2:]\n\n\t\treturn result", "response": "Return new object by the given MAC - address"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_string(address):\n\t\taddress = address.split('.')\n\t\tif len(address) != WIPV4Address.octet_count:\n\t\t\traise ValueError('Invalid ip address: %s' % address)\n\n\t\tresult = WIPV4Address()\n\t\tfor i in range(WIPV4Address.octet_count):\n\t\t\tresult.__address[i] = WBinArray(int(address[i]), WFixedSizeByteArray.byte_size)\n\t\treturn result", "response": "Parse IPv4 address from string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting WIPV4Address to string", "response": "def to_string(address, dns_format=False):\n\t\t\"\"\" Convert address to string\n\n\t\t:param address: WIPV4Address to convert\n\t\t:param dns_format: whether to use arpa-format or not\n\t\t:return:\n\t\t\"\"\"\n\t\tif isinstance(address, WIPV4Address) is False:\n\t\t\traise TypeError('Invalid address type')\n\n\t\taddress = [str(int(x)) for x in address.__address]\n\t\tif dns_format is False:\n\t\t\treturn '.'.join(address)\n\t\taddress.reverse()\n\t\treturn ('.'.join(address) + '.in-addr.arpa')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the first IP address of this network", "response": "def first_address(self, skip_network_address=True):\n\t\t\"\"\" Return the first IP address of this network\n\n\t\t:param skip_network_address: this flag specifies whether this function returns address of the network \\\n\t\tor returns address that follows address of the network (address, that a host could have)\n\t\t:return: WIPV4Address\n\t\t\"\"\"\n\t\tbin_address = self.__address.bin_address()\n\t\tbin_address_length = len(bin_address)\n\t\tif self.__mask > (bin_address_length - 2):\n\t\t\tskip_network_address = False\n\n\t\tfor i in range(bin_address_length - self.__mask):\n\t\t\tbin_address[self.__mask + i] = 0\n\n\t\tif skip_network_address:\n\t\t\tbin_address[bin_address_length - 1] = 1\n\n\t\treturn WIPV4Address(bin_address)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the last IP address of this network.", "response": "def last_address(self, skip_broadcast_address=True):\n\t\t\"\"\" Return the last IP address of this network\n\n\t\t:param skip_broadcast_address: this flag specifies whether to skip the very last address (that is \\\n\t\tusually used as broadcast address) or not.\n\t\t:return: WIPV4Address\n\t\t\"\"\"\n\t\tbin_address = self.__address.bin_address()\n\t\tbin_address_length = len(bin_address)\n\t\tif self.__mask > (bin_address_length - 2):\n\t\t\tskip_broadcast_address = False\n\n\t\tfor i in range(bin_address_length - self.__mask):\n\t\t\tbin_address[self.__mask + i] = 1\n\n\t\tif skip_broadcast_address:\n\t\t\tbin_address[bin_address_length - 1] = 0\n\n\t\treturn WIPV4Address(bin_address)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iterator(self, skip_network_address=True, skip_broadcast_address=True):\n\t\treturn WNetworkIPV4Iterator(self, skip_network_address, skip_broadcast_address)", "response": "Return iterator that can iterate over network addresses"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting doted - written FQDN address to WFQDN object", "response": "def from_string(address):\n\t\t\"\"\" Convert doted-written FQDN address to WFQDN object\n\n\t\t:param address: address to convert\n\t\t:return: WFQDN\n\t\t\"\"\"\n\t\tif len(address) == 0:\n\t\t\treturn WFQDN()\n\n\t\tif address[-1] == '.':\n\t\t\taddress = address[:-1]\n\n\t\tif len(address) > WFQDN.maximum_fqdn_length:\n\t\t\traise ValueError('Invalid address')\n\n\t\tresult = WFQDN()\n\t\tfor label in address.split('.'):\n\t\t\tif isinstance(label, str) and WFQDN.re_label.match(label):\n\t\t\t\tresult._labels.append(label)\n\t\t\telse:\n\t\t\t\traise ValueError('Invalid address')\n\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_string(address, leading_dot=False):\n\n\t\tif isinstance(address, WFQDN) is False:\n\t\t\traise TypeError('Invalid type for FQDN address')\n\n\t\tresult = '.'.join(address._labels)\n\t\treturn result if leading_dot is False else (result + '.')", "response": "Return a doted - written address by the given WFQDN object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pair(self):\n\t\taddress = str(self.__address) if self.__address is not None else ''\n\t\tport = int(self.__port) if self.__port is not None else 0\n\t\treturn address, port", "response": "Return tuple of address and port of this socket"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_address(address):\n\n\t\tif len(address) == 0:\n\t\t\treturn None\n\n\t\ttry:\n\t\t\treturn WIPV4Address(address)\n\t\texcept ValueError:\n\t\t\tpass\n\n\t\ttry:\n\t\t\treturn WFQDN(address)\n\t\texcept ValueError:\n\t\t\tpass\n\n\t\traise ValueError('Unable to parse address string. It must be an IP address or FQDN')", "response": "Parse string and return WIPV4Address or WFQDN object if an IP address is specified and None otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse string that is formed like [ address : port ] and return corresponding : class :. WIPV4ScketInfo object", "response": "def parse_socket_info(cls, info):\n\t\t\"\"\" Parse string that is formed like '[address]<:port>' and return corresponding\n\t\t:class:`.WIPV4ScketInfo` object\n\n\t\t:param info: string to parse\n\n\t\t:return: WIPV4ScketInfo\n\t\t\"\"\"\n\t\tinfo = info.split(':')\n\t\tif len(info) > 2:\n\t\t\traise ValueError('Incorrect socket info specified')\n\t\taddress = info[0].strip()\n\t\tport = int(info[1].strip()) if len(info) == 2 else None\n\t\treturn WIPV4SocketInfo(address=address, port=port)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a widget to the object.", "response": "def qteAddWidget(self, widgetObj: QtGui.QWidget, isFocusable: bool=True,\n                     widgetSignature: str=None, autoBind: bool=True):\n        \"\"\"\n        Augment the standard Qt ``widgetObj`` with Qtmacs specific fields.\n\n        Example: from a programmers perspective there is no difference\n        between::\n\n            wid = QtGui.QTextEdit(self)\n\n        and::\n\n            wid = self.qteAddWidget(QtGui.QTextEdit(self))\n\n        Both return a handle to a Qt widget (a ``QTextEdit`` in this\n        case). However, the ``qteAddWidget`` adds the following fields\n        to the object:\n\n        * ``_qteAdmin``: this is an instance of the ``QtmacsAdminStructure``\n          to tell Qtmacs how to treat the widget.\n        * ``qteSignature``: an attribute that returns the signature of the\n          widget and equals ``widgetSignature``. If no such signature was\n          specified it defaults to the Qt internal name as a string, eg.\n          for a push button this would be 'QPushButton'.\n        * ``qteSetKeyFilterPolicy``: this points directly to the equally\n          named method inside the _qteAdmin object. This is a convenience\n          shortcut to avoid using the _qteAdmin structure directly in\n          macro/applet code, because only Qtmacs itself should temper\n          with it.\n\n        |Args|\n\n        * ``widgetObj`` (**QWidget**): any widget from the QtGui library.\n        * ``isFocusable`` (**bool**): whether or not the widget can\n          receive the focus.\n        * ``widgetSignature`` (**str**): specify the widget signature\n          (defaults to class name)\n        * ``autoBind`` (**bool**): if **True** and ``widgetSignature``\n          is a recognisable name (eg. **QTextEdit**) then automatically\n          load the appropriate key-bindings for this widget.\n\n        |Returns|\n\n        * **QWidget**: handle to widget object (or **None** if it could\n          not be added).\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        # Add a Qtmacs data structure to the widget to allow their\n        # event administration. Note that, in all likelihood, the\n        # widget is an arbitrary Qt widget (eg. QLineEdit,\n        # QPushButton, etc).\n        widgetObj._qteAdmin = QtmacsAdminStructure(\n            self, isFocusable=isFocusable)\n        widgetObj._qteAdmin.appletID = self._qteAdmin.appletID\n\n        # Specify that this widget is not a QtmacsApplet.\n        widgetObj._qteAdmin.isQtmacsApplet = False\n\n        # Remember the signature of the applet containing this widget.\n        widgetObj._qteAdmin.appletSignature = self.qteAppletSignature()\n\n        # Set the widget signature. If none was specified, use the\n        # class name (eg. QLineEdit).\n        if widgetSignature is None:\n            widgetObj._qteAdmin.widgetSignature = widgetObj.__class__.__name__\n        else:\n            widgetObj._qteAdmin.widgetSignature = widgetSignature\n\n        # For convenience, as it is otherwise difficult for the macro\n        # programmer to determine the widget signature used by Qtmacs.\n        # Note: the \"wo\" is only a shorthand to avoid too long lines.\n        wo = widgetObj\n        wo.qteSignature = wo._qteAdmin.widgetSignature\n        wo.qteSetKeyFilterPolicy = wo._qteAdmin.qteSetKeyFilterPolicy\n        del wo\n\n        # Add the widget to the widgetList of this QtmacsApplet.\n        # Important: this MUST happen before macros and key-bindings are loaded\n        # and bound automatically (see code below) because the method to\n        # bind the keys will verify that the widget exists in ``widgetList``.\n        self._qteAdmin.widgetList.append(widgetObj)\n\n        # If a widget has a default key-bindings file then the global\n        # dictionary ``default_widget_keybindings`` will contain its\n        # name.\n        default_bind = qte_global.default_widget_keybindings\n        if autoBind and (widgetObj.qteSignature in default_bind):\n            # Shorthand.\n            module_name = default_bind[widgetObj.qteSignature]\n\n            # Import the module with the default key-bindings for the\n            # current widget type.\n            try:\n                mod = importlib.import_module(module_name)\n            except ImportError:\n                msg = ('Module <b>{}</b> could not be imported.'.format(\n                       module_name))\n                self.qteLogger.exception(msg, stack_info=True)\n                return\n\n            if hasattr(mod, 'install_macros_and_bindings'):\n                # By convention, the module has an\n                # install_macros_and_bindings method. If an error\n                # occurs intercept it, but do not abort the method\n                # since the error only relates to a failed attempt to\n                # apply default key-bindings, not to register the\n                # widget (the main purpose of this method).\n                try:\n                    mod.install_macros_and_bindings(widgetObj)\n                except Exception:\n                    msg = ('<b>install_macros_and_bindings</b> function'\n                           ' in <b>{}</b> did not execute properly.')\n                    msg = msg.format(module_name)\n                    self.qteLogger.error(msg, stack_info=True)\n            else:\n                msg = ('Module <b>{}</b> has no '\n                       '<b>install_macros_and_bindings</b>'\n                       ' method'.format(module_name))\n                self.qteLogger.error(msg)\n\n        return widgetObj"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the applet signature at run time.", "response": "def qteSetAppletSignature(self, signature: str):\n        \"\"\"\n        Specify the applet signature.\n\n        This signature is used by Qtmacs at run time to determine\n        which macros are compatible with the apple. Macros have an\n        identically called method so that Qtmacs can determine which\n        macros are compatible with which applets. This method is\n        typically called only in the applet constructor, but changing\n        the macro signature at run time, is possible.\n\n        The signature must be a non-empty string and not contain the\n        '*' symbol.\n\n        Note: the default signature is the class name as a string,\n        eg. if the applet class is called MyAppClass, then the initial\n        macro signature is the string 'MyAppClass'.\n\n        |Args|\n\n        * ``signature`` (**str**): the signature of this applet to\n          determine compatible macros run time.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        * **QtmacsOtherError** if the signature is empty or contains\n          the '*' wildcard symbol.\n        \"\"\"\n        if '*' in signature:\n            raise QtmacsOtherError('The applet signature must not contain \"*\"')\n\n        if signature == '':\n            raise QtmacsOtherError('The applet signature must be non-empty')\n\n        self._qteAdmin.appletSignature = signature"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qteAutoremoveDeletedWidgets(self):\n        widget_list = self._qteAdmin.widgetList\n        deleted_widgets = [_ for _ in widget_list if sip.isdeleted(_)]\n        for widgetObj in deleted_widgets:\n            self._qteAdmin.widgetList.remove(widgetObj)", "response": "Remove all deleted widgets from the internal widget list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nchange the focus order of the widgets in this applet.", "response": "def qteSetWidgetFocusOrder(self, widList: tuple):\n        \"\"\"\n        Change the focus order of the widgets in this applet.\n\n        This method re-arranges the internal (cyclic) widget list so\n        that all widgets specified in ``widList`` will be focused in\n        the given order.\n\n        |Args|\n\n        * ``widList`` (**tuple**): a tuple of widget objects.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n        # A list with less than two entries cannot be re-ordered.\n        if len(widList) < 2:\n            return\n\n        # Housekeeping: remove non-existing widgets from the admin structure.\n        self.qteAutoremoveDeletedWidgets()\n\n        # Remove all **None** widgets.\n        widList = [_ for _ in widList if _ is not None]\n\n        # Ensure that all widgets exist in the current applet.\n        for wid in widList:\n            if wid not in self._qteAdmin.widgetList:\n                msg = 'Cannot change focus order because some '\n                msg += 'widgets do not exist.'\n                self.qteLogger.warning(msg)\n                return\n\n        # Remove all duplicates from the user supplied list.\n        newList = [widList[0]]\n        for wid in widList[1:]:\n            if wid not in newList:\n                newList.append(wid)\n\n        # If the duplicate free list has only one entry then there is\n        # nothing left to reorder.\n        if len(newList) < 2:\n            return\n\n        # The purpose of the code is the following: suppose\n        # _qteAdmin.widgetList = [0,1,2,3,4,5] and newList=[2,5,1].\n        # Then change _qteAdmin.widgetList to [0,1,2,5,1,3,4]. Step\n        # 1: remove all but the first widget in newList from\n        # _qteAdmin.widgetList.\n        for wid in newList[1:]:\n            self._qteAdmin.widgetList.remove(wid)\n\n        # 2: re-insert the removed elements as a sequence again.\n        startIdx = self._qteAdmin.widgetList.index(newList[0]) + 1\n        for idx, wid in enumerate(newList[1:]):\n            self._qteAdmin.widgetList.insert(startIdx + idx, wid)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the next widget in the internal widget list.", "response": "def qteNextWidget(self, numSkip: int=1, ofsWidget: QtGui.QWidget=None,\n                      skipVisible: bool=False, skipInvisible: bool=True,\n                      skipFocusable: bool=False,\n                      skipUnfocusable: bool=True):\n        \"\"\"\n        Return the next widget in cyclic order.\n\n        If ``ofsWidget`` is **None** then start counting at the\n        currently active widget and return the applet ``numSkip``\n        items away in cyclic order in the internal widget list. If\n        ``numSkip`` is positive traverse the applet list forwards,\n        otherwise backwards. The methods supports the following\n        selection criteria:\n\n        * ``skipVisible``: only invisible widgets are considered.\n        * ``skipInvisible``: only visible widgets are considered.\n        * ``skipFocusable``: only unfocusable widgets are considered.\n        * ``skipUnfocusable``: only unfocusable widgets are considered.\n\n        |Args|\n\n        * ``numSkip`` (**int**): number of applets to skip.\n        * ``ofsWidget`` (**QWidget**): widget from where to start counting.\n        * ``skipVisible`` (**bool**): whether or not to skip currently\n          shown widgets.\n        * ``skipInvisible`` (**bool**): whether or not to skip currently\n          not shown widgets.\n        * ``skipFocusable`` (**bool**): whether or not to skip focusable\n          widgets.\n        * ``skipUnfocusable`` (**bool**): whether or not to skip unfocusable\n          widgets.\n\n        |Returns|\n\n        * **QWidget**: either the next widget that fits the criteria, or\n          **None** if no such widget exists.\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        * **QtmacsOtherError** if ``ofsWidget`` was not added with\n          ``qteAddWidget``.\n        \"\"\"\n        # Check type of input arguments.\n        if not hasattr(ofsWidget, '_qteAdmin') and (ofsWidget is not None):\n            msg = '<ofsWidget> was probably not added with <qteAddWidget>'\n            msg += ' method because it lacks the <_qteAdmin> attribute.'\n            raise QtmacsOtherError(msg)\n\n        # Housekeeping: remove non-existing widgets from the admin structure.\n        self.qteAutoremoveDeletedWidgets()\n\n        # Make a copy of the widget list.\n        widList = list(self._qteAdmin.widgetList)\n\n        # Return immediately if the widget list is empty. The actual\n        # return value is either self._qteActiveWidget (if it points\n        # to a child widget of the current applet), or None.\n        if not len(widList):\n            if qteGetAppletFromWidget(self._qteActiveWidget) is self:\n                return self._qteActiveWidget\n            else:\n                return None\n\n        if skipInvisible:\n            # Remove all invisible widgets.\n            widList = [wid for wid in widList if wid.isVisible()]\n\n        if skipVisible:\n            # Remove all visible widgets.\n            widList = [wid for wid in widList if not wid.isVisible()]\n\n        if skipFocusable:\n            # Remove all visible widgets.\n            widList = [wid for wid in widList if not wid._qteAdmin.isFocusable]\n\n        if skipUnfocusable:\n            # Remove all unfocusable widgets.\n            widList = [wid for wid in widList if wid._qteAdmin.isFocusable]\n\n        # Return immediately if the list is empty. This is typically\n        # the case at startup before any applet has been added.\n        if not len(widList):\n            return None\n\n        # If no offset widget was given then use the currently active one.\n        if ofsWidget is None:\n            ofsWidget = self._qteActiveWidget\n\n        if (ofsWidget is not None) and (numSkip == 0):\n            if qteIsQtmacsWidget(ofsWidget):\n                return ofsWidget\n\n        # Determine the index of the offset widget; assume it is zero\n        # if the widget does not exist, eg. if the currently active\n        # applet is not part of the pruned widList list.\n        try:\n            ofsIdx = widList.index(ofsWidget)\n        except ValueError:\n            ofsIdx = 0\n\n        # Compute the index of the next widget and wrap around the\n        # list if necessary.\n        ofsIdx = (ofsIdx + numSkip) % len(widList)\n\n        # Return the widget.\n        return widList[ofsIdx]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking the widgetObj active.", "response": "def qteMakeWidgetActive(self, widgetObj: QtGui.QWidget):\n        \"\"\"\n        Give keyboard focus to ``widgetObj``.\n\n        If ``widgetObj`` is **None** then the internal focus state\n        is reset, but the focus manger will automatically\n        activate the first available widget again.\n\n        |Args|\n\n        * ``widgetObj`` (**QWidget**): the widget to focus on.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsOtherError** if ``widgetObj`` was not added with\n            ``qteAddWidget``.\n        \"\"\"\n        # Void the active widget information.\n        if widgetObj is None:\n            self._qteActiveWidget = None\n            return\n\n        # Ensure that this applet is an ancestor of ``widgetObj``\n        # inside the Qt hierarchy.\n        if qteGetAppletFromWidget(widgetObj) is not self:\n            msg = 'The specified widget is not inside the current applet.'\n            raise QtmacsOtherError(msg)\n\n        # If widgetObj is not registered with Qtmacs then simply declare\n        # it active and return.\n        if not hasattr(widgetObj, '_qteAdmin'):\n            self._qteActiveWidget = widgetObj\n            return\n\n        # Do nothing if widgetObj refers to an applet.\n        if widgetObj._qteAdmin.isQtmacsApplet:\n            self._qteActiveWidget = None\n            return\n\n        # Housekeeping: remove non-existing widgets from the admin structure.\n        self.qteAutoremoveDeletedWidgets()\n\n        # Verify the widget is registered for this applet.\n        if widgetObj not in self._qteAdmin.widgetList:\n            msg = 'Widget is not registered for this applet.'\n            self.qteLogger.error(msg, stack_info=True)\n            self._qteActiveWidget = None\n            return\n\n        # The focus manager in QtmacsMain will hand the focus to\n        # whatever the _qteActiveWidget variable of the active applet\n        # points to.\n        self.qteSetWidgetFocusOrder((self._qteActiveWidget, widgetObj))\n        self._qteActiveWidget = widgetObj"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef loadFile(self, fileName: str=None):\n        msg = ('The <b>{}</b> applet has not implemented the '\n               '<b>LoadFile</b> method')\n        self.qteLogger.info(msg.format(self.qteAppletSignature()))", "response": "Overload this method with applet specific code that can make\n        sense of the passed file name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing the applet with the applet s current entry.", "response": "def show(self, fromQtmacs: bool=False):\n        \"\"\"\n        Overloaded ``show()`` function to avoid calling it\n        accidentally.\n\n        This method is a (weak) security mechanism to prevent\n        programmers from using the ``show`` method as originally\n        intended by Qt, ie. to show a window. In Qtmacs, applets can\n        only be made visible with either ``qteMakeAppletActive`` or by\n        replacing another window in the layout with eg\n        ``qteReplaceWindowInLayout``. Using the Qt native ``show()``\n        method messes with the Qtmacs layout engine and can lead to\n        unexpected visual results and more serious errors.\n\n        This method should only be used by ``QtmacsMain`` to implement\n        the layout but not by any applets or macros, unless it is for\n        a widget not under the control of Qtmacs (probably a bad\n        idea).\n\n        The user should call the ``qteNewApplet`` method to create and\n        show a applet.\n\n        |Args|\n\n        * ``fromQtmacs`` (**bool**): if **True** then the original\n          ``show()`` method is called\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **QtmacsArgumentError** if at least one argument has an invalid type.\n        \"\"\"\n        if not fromQtmacs:\n            # Log a warning message if someone tries to call the\n            # native show() method.\n            msg = 'show() command for applet <b>{}</b> ignored. '\n            msg += ' Use qteNewApplet instead.'.format(self.qteAppletID())\n            self.qteLogger.warning(msg)\n        else:\n            # Sanity check: the parent of this applet *must* be a\n            # ``QtmacsLayoutSplitter`` as otherwise it cannot be\n            # shown.\n            sig_ = self.parent()._qteAdmin.widgetSignature\n            if sig_ != '__QtmacsLayoutSplitter__':\n                msg = 'show() command for applet <b>{}</b> ignored'\n                msg = msg.format(self.qteAppletID())\n                msg += ' because its parent is not a '\n                msg += 'QtmacsLayoutSplitter --> Bug.'\n                return\n\n            # Before the applet is actually shown update the\n            # ``parentWindow`` reference in the admin structure. To\n            # obtain this reference, query the parent of this very\n            # applet (which is a QtmacsSplitter instance) for its\n            # parent window since both must necessarily be shown in\n            # the same window and thus have the same parent window.\n            self._qteAdmin.parentWindow = self.parent().qteParentWindow()\n\n            # Update the Qtmacs internal visibility flag (used in the\n            # focus manager to ensure that Qt and Qtmacs agree on\n            # which applets are visible and which are not) and then\n            # tell Qt to make the applet visible once the event loop\n            # regains control.\n            self._qteAdmin.isVisible = True\n            QtGui.QWidget.show(self)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hide(self, fromQtmacs: bool=False):\n        if not fromQtmacs:\n            # Log a warning message if someone tries to call the\n            # native hide() method.\n            msg = ('hide() command for applet <b>{}</b> ignored. Use '\n                   ' qteNewApplet instead.'.format(self.qteAppletID()))\n            self.qteLogger.warning(msg)\n        else:\n            # If we are explicitly requested to hide() the widget,\n            # then clear the Qtmacs internal visibility flag (will be\n            # used in the focus manager to double check that Qtmacs\n            # and Qt agree on which widgets are visible), remove the\n            # applet from the QtmacsSplitter by re-parenting it to\n            # **None**, and tell Qt to actually hide the widget as\n            # soon as the event loop is in control again.\n            self._qteAdmin.isVisible = False\n            self.qteReparent(None)\n            QtGui.QWidget.hide(self)", "response": "Hide the applet with the given internal key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating the value of the key in the object.", "response": "def validate(self, value, model=None, context=None):\n        \"\"\"\n        Validate\n        Perform value validation and return result\n\n        :param value:           value to check\n        :param model:           parent model being validated\n        :param context:         object or None, validation context\n        :return:                shiftschema.results.SimpleResult\n        \"\"\"\n\n        # ok if non-empty string\n        if type(value) is str:\n            value = value.strip()\n            if value != '':\n                return Error()\n\n        # ok if has value\n        if value:\n            return Error()\n\n        # ok if false, but false is allowed\n        if value is False and self.allow_false:\n            return Error()\n\n        # ok if 0, but zero is allowed\n        if value == 0 and self.allow_zero:\n            return Error()\n\n        # error otherwise\n        return Error(self.value_required)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split_key(key):\n    if key == KEY_SEP:\n        return ()\n    key_chunks = tuple(key.strip(KEY_SEP).split(KEY_SEP))\n    if key_chunks[0].startswith(KEY_SEP):\n        return (key_chunks[0][len(KEY_SEP):],) + key_chunks[1:]\n    else:\n        return key_chunks", "response": "Splits a node key into a list of node names."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the node data.", "response": "def set(self, index, value=None, dir=False, ttl=None, expiration=None):\n        \"\"\"Updates the node data.\"\"\"\n        if bool(dir) is (value is not None):\n            raise TypeError('Choose one of value or directory')\n        if (ttl is not None) is (expiration is None):\n            raise TypeError('Both of ttl and expiration required')\n        self.value = value\n        if self.dir != dir:\n            self.dir = dir\n            self.nodes = {} if dir else None\n        self.ttl = ttl\n        self.expiration = expiration\n        self.modified_index = index"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a canonical : class : etc. Node object from this mock node.", "response": "def canonicalize(self, include_nodes=True, sorted=False):\n        \"\"\"Generates a canonical :class:`etc.Node` object from this mock node.\n        \"\"\"\n        node_class = Directory if self.dir else Value\n        kwargs = {attr: getattr(self, attr) for attr in node_class.__slots__}\n        if self.dir:\n            if include_nodes:\n                nodes = [node.canonicalize() for node in\n                         six.viewvalues(kwargs['nodes'])]\n                if sorted:\n                    nodes.sort(key=lambda n: n.key)\n                kwargs['nodes'] = nodes\n            else:\n                kwargs['nodes'] = []\n        return node_class(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_result(self, result_class, node=None, prev_node=None,\n                    remember=True, key_chunks=None, notify=True, **kwargs):\n        \"\"\"Makes an etcd result.\n\n        If `remember` is ``True``, it keeps the result in the history and\n        triggers events if waiting.  `key_chunks` is the result of\n        :func:`split_key` of the `node.key`.  It is not required if `remember`\n        is ``False``.  Otherwise, it is optional but recommended to eliminate\n        waste if the key chunks are already supplied.\n\n        \"\"\"\n        def canonicalize(node, **kwargs):\n            return None if node is None else node.canonicalize(**kwargs)\n        index = self.index\n        result = result_class(canonicalize(node, **kwargs),\n                              canonicalize(prev_node, **kwargs), index)\n        if not remember:\n            return result\n        self.history[index] = result_class(\n            canonicalize(node, include_nodes=False),\n            canonicalize(prev_node, include_nodes=False), index)\n        key_chunks = key_chunks or split_key(node.key)\n        asymptotic_key_chunks = (key_chunks[:x + 1]\n                                 for x in xrange(len(key_chunks)))\n        event_keys = [(False, key_chunks)]\n        for _key_chunks in asymptotic_key_chunks:\n            exact = _key_chunks == key_chunks\n            self.indices.setdefault(_key_chunks, []).append((index, exact))\n            event_keys.append((True, _key_chunks))\n        if notify:\n            for event_key in event_keys:\n                try:\n                    event = self.events.pop(event_key)\n                except KeyError:\n                    pass\n                else:\n                    event.set()\n        return result", "response": "Makes an etcd result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompare the node with the previous value and index.", "response": "def compare(self, node, prev_value=None, prev_index=None):\n        \"\"\"Raises :exc:`TestFailed` if the node is not matched with\n        `prev_value` or `prev_index`.\n        \"\"\"\n        if prev_value is not None and node.value != prev_value or \\\n           prev_index is not None and node.index != prev_index:\n            raise TestFailed(index=self.index)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect(self, host='localhost'):\n\n        # Connect\n\n        get_logger().info(\"Connecting to RabbitMQ server...\")\n\n        self._conn = pika.BlockingConnection(\n            pika.ConnectionParameters(host=host))\n        self._channel = self._conn.channel()\n\n        # Exchanger\n\n        get_logger().info(\"Declaring topic exchanger {}...\".format(\n            self.exchange))\n\n        self._channel.exchange_declare(exchange=self.exchange, type='topic')\n\n        # Create queue\n\n        get_logger().info(\"Creating RabbitMQ queue...\")\n        result = self._channel.queue_declare(exclusive=True)\n\n        self._queue_name = result.method.queue\n\n        # Binding\n\n        if self.listen_all:\n            get_logger().info(\n                \"Binding queue to exchanger {} (listen all)...\".format(\n                    self.exchange\n                )\n            )\n            self._channel.queue_bind(\n                exchange=self.exchange,\n                queue=self._queue_name,\n                routing_key='*'\n            )\n        else:\n            for routing_key in self.topics:\n                get_logger().info(\n                    \"Binding queue to exchanger {} \"\n                    \"with routing key {}...\".format(\n                        self.exchange, routing_key)\n                )\n\n                self._channel.queue_bind(\n                    exchange=self.exchange,\n                    queue=self._queue_name,\n                    routing_key=routing_key\n                )\n\n        # Callback\n\n        get_logger().info(\"Binding callback...\")\n        self._channel.basic_consume(\n            self._callback, queue=self._queue_name, no_ack=True)", "response": "Connect to the server and set everything up."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef publish(self, topic, dct):\n        get_logger().info(\"Publishing message {} on routing key \"\n                          \"{}...\".format(dct, topic))\n\n        self._channel.basic_publish(\n            exchange=self.exchange,\n            routing_key=topic,\n            body=json.dumps(dct)\n        )", "response": "Send a dict with internal routing key to the exchange."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_ping(client, topic, dct):\n        if dct['type'] == 'request':\n            resp = {\n                'type': 'answer',\n                'name': client.name,\n                'source': dct\n            }\n\n            client.publish('ping', resp)", "response": "Internal method that will be called when receiving ping message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_to_sys_with_admin_list(class_inst, admin_list=None, is_normal_admin_needed=False):\n    if admin_list is None:\n        admin_class = get_valid_admin_class_with_list([], class_inst)\n    else:\n        admin_class = get_valid_admin_class_with_list(admin_list, class_inst)\n    if is_normal_admin_needed:\n        register_all_type_of_admin(admin_class, class_inst)\n    else:\n        register_admin(admin_class, class_inst)", "response": "register to sys admin list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_all_in_module(module_instance, exclude_name_list=[], admin_class_list=None):\n    class_list = []\n    for name, obj in inspect.getmembers(module_instance):\n        if inspect.isclass(obj):\n            if obj.__name__ in exclude_name_list:\n                continue\n            class_list.append(obj)\n    #print class_list, admin_class_list\n    register_all(class_list, admin_class_list)", "response": "Registers all the classes in a module."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates dictionary with argument names as keys and their passed values as values.", "response": "def _create_argument_value_pairs(func, *args, **kwargs):\n    \"\"\"\n    Create dictionary with argument names as keys and their passed values as values.\n\n    An empty dictionary is returned if an error is detected, such as more\n    arguments than in the function definition, argument(s) defined by position\n    and keyword, etc.\n    \"\"\"\n    # Capture parameters that have been explicitly specified in function call\n    try:\n        arg_dict = signature(func).bind_partial(*args, **kwargs).arguments\n    except TypeError:\n        return dict()\n    # Capture parameters that have not been explicitly specified\n    # but have default values\n    arguments = signature(func).parameters\n    for arg_name in arguments:\n        if (arguments[arg_name].default != Parameter.empty) and (\n            arguments[arg_name].name not in arg_dict\n        ):\n            arg_dict[arguments[arg_name].name] = arguments[arg_name].default\n    return arg_dict"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating one exception specification contract tuple or list.", "response": "def _format_arg(arg):\n    \"\"\"Validate one exception specification contract tuple/list.\"\"\"\n    # Check that the argument conforms to one of the acceptable types, a string\n    # (when the default exception type is used), an exception type (when the\n    # default exception message is used) or a list/tuple to specify both\n    # exception type and exception message\n    if not (_isexception(arg) or isinstance(arg, (str, tuple, list))):\n        raise TypeError(\"Illegal custom contract exception definition\")\n    # Check that when the argument is a list or tuple, they only have at most\n    # 2 items, the exception type and the exception message\n    if isinstance(arg, (tuple, list)) and ((not arg) or (len(arg) > 2)):\n        raise TypeError(\"Illegal custom contract exception definition\")\n    # When only an exception message is given (and the default RuntimeError\n    # exception type is used), check that the message is not empty\n    if isinstance(arg, str) and (not arg):\n        raise ValueError(\"Empty custom contract exception message\")\n    # When only an exception message is defined,\n    # use the default exception type\n    if isinstance(arg, str):\n        return {\"msg\": arg, \"type\": RuntimeError}\n    # When only an exception type is defined,\n    # use the default exception message\n    if _isexception(arg):\n        return {\"msg\": \"Argument `*[argument_name]*` is not valid\", \"type\": arg}\n    # If a list/tuple definition is used, check that if is not a string, it is\n    # a valid exception type (i.e. that it actually raises an exception)\n    if (len(arg) == 1) and (not isinstance(arg[0], str)) and (not _isexception(arg[0])):\n        raise TypeError(\"Illegal custom contract exception definition\")\n    if (len(arg) == 2) and (\n        not (\n            (isinstance(arg[0], str) and _isexception(arg[1]))\n            or (isinstance(arg[1], str) and _isexception(arg[0]))\n        )\n    ):\n        raise TypeError(\"Illegal custom contract exception definition\")\n    # Check that the exception definition has a non-empty exception message\n    # when a list/tuple definition is used\n    if (len(arg) == 1) and isinstance(arg[0], str) and (not arg[0]):\n        raise ValueError(\"Empty custom contract exception message\")\n    if (len(arg) == 2) and (\n        (isinstance(arg[0], str) and (not arg[0]))\n        or (isinstance(arg[1], str) and (not arg[1]))\n    ):\n        raise ValueError(\"Empty custom contract exception message\")\n    # Return conforming dictionary with default exception type and exception\n    # message applied (if necessary)\n    if len(arg) == 1:\n        return {\n            \"msg\": (\n                arg[0]\n                if isinstance(arg[0], str)\n                else \"Argument `*[argument_name]*` is not valid\"\n            ),\n            \"type\": arg[0] if _isexception(arg[0]) else RuntimeError,\n        }\n    # len(arg) == 2\n    return {\n        \"msg\": arg[0] if isinstance(arg[0], str) else arg[1],\n        \"type\": arg[0] if _isexception(arg[0]) else arg[1],\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_contract_exception_dict(contract_msg):\n    # A pcontract-defined custom exception message is wrapped in a string\n    # that starts with '[START CONTRACT MSG:' and ends with\n    # '[STOP CONTRACT MSG]'. This is done to easily detect if an\n    # exception raised is from a custom contract and thus be able\n    # to easily retrieve the actual exception message\n    start_token = \"[START CONTRACT MSG: \"\n    stop_token = \"[STOP CONTRACT MSG]\"\n    # No custom contract\n    if contract_msg.find(start_token) == -1:\n        return {\n            \"num\": 0,\n            \"msg\": \"Argument `*[argument_name]*` is not valid\",\n            \"type\": RuntimeError,\n            \"field\": \"argument_name\",\n        }\n    # Custom contract\n    msg_start = contract_msg.find(start_token) + len(start_token)\n    contract_msg = contract_msg[msg_start:]\n    contract_name = contract_msg[: contract_msg.find(\"]\")]\n    contract_msg = contract_msg[\n        contract_msg.find(\"]\") + 1 : contract_msg.find(stop_token)\n    ]\n    exdict = _CUSTOM_CONTRACTS[contract_name]\n    for exvalue in exdict.values():  # pragma: no branch\n        if exvalue[\"msg\"] == contract_msg:\n            return exvalue", "response": "Generate message for exception."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if parameter contract is a custom contract False otherwise.", "response": "def _get_custom_contract(param_contract):\n    \"\"\"Return True if parameter contract is a custom contract, False otherwise.\"\"\"\n    if not isinstance(param_contract, str):\n        return None\n    for custom_contract in _CUSTOM_CONTRACTS:\n        if re.search(r\"\\b{0}\\b\".format(custom_contract), param_contract):\n            return custom_contract\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_exdesc():\n    # First frame is own function (get_exdesc), next frame is the calling\n    # function, of which its name is needed\n    fname = inspect.getframeinfo(sys._getframe(1))[2]\n    # Find function object in stack\n    count = 0\n    fobj = None\n    while not (fobj and hasattr(fobj, \"exdesc\")):\n        count = count + 1\n        try:\n            sitem = sys._getframe(count)\n        except ValueError:\n            # Got to top of stack\n            raise RuntimeError(\n                \"Function object could not be found for function `{0}`\".format(fname)\n            )\n        fobj = (\n            sitem.f_locals[fname]\n            if fname in sitem.f_locals\n            else (sitem.f_globals[fname] if fname in sitem.f_globals else None)\n        )\n    # Return function attribute created by new contract decorator\n    exdesc = getattr(fobj, \"exdesc\")\n    return exdesc if len(exdesc) > 1 else exdesc[next(iter(exdesc))]", "response": "Retrieve exception message and exception names."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the number of simple or default contracts.", "response": "def _get_num_contracts(contracts_list, param_name):\n    \"\"\"\n    Return the number of simple/default contracts.\n\n    Simple contracts are the ones which raise a RuntimeError with message\n    'Argument `*[argument_name]*` is not valid'\n    \"\"\"\n    msg = \"Argument `*[argument_name]*` is not valid\"\n    return sum(\n        [\n            1 if item[\"msg\"] == msg.replace(\"*[argument_name]*\", param_name) else 0\n            for item in contracts_list\n        ]\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts replacement token from exception message.", "response": "def _get_replacement_token(msg):\n    \"\"\"Extract replacement token from exception message.\"\"\"\n    return (\n        None\n        if not re.search(r\"\\*\\[[\\w|\\W]+\\]\\*\", msg)\n        else re.search(r\"\\*\\[[\\w|\\W]+\\]\\*\", msg).group()[2:-2]\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_new_contract_args(*args, **kwargs):\n    # No arguments\n    if (not args) and (not kwargs):\n        return [\n            {\n                \"name\": \"argument_invalid\",\n                \"msg\": \"Argument `*[argument_name]*` is not valid\",\n                \"type\": RuntimeError,\n            }\n        ]\n    # Process args\n    if (len(args) > 1) or ((len(args) == 1) and kwargs):\n        raise TypeError(\"Illegal custom contract exception definition\")\n    if len(args) == 1:\n        return [dict([(\"name\", \"default\")] + list(_format_arg(args[0]).items()))]\n    # Process kwargs\n    return [\n        dict([(\"name\", name)] + list(_format_arg(kwargs[name]).items()))\n        for name in sorted(list(kwargs.keys()))\n    ]", "response": "Parse argument for new_contract() function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _register_custom_contracts(contract_name, contract_exceptions):\n    # pylint: disable=W0602,W0603\n    global _CUSTOM_CONTRACTS\n    # Validate arguments and homogenize contract exceptions\n    if not isinstance(contract_name, str):\n        raise TypeError(\"Argument `contract_name` is of the wrong type\")\n    # A contract exception can be a string (only one exception, default\n    # exception type) or a dictionary of exception definitions, if there is\n    # more than one or if the type if different than the default\n    if (\n        (not isinstance(contract_exceptions, list))\n        and (not isinstance(contract_exceptions, str))\n        and (not isinstance(contract_exceptions, dict))\n    ):\n        raise TypeError(\"Argument `contract_exceptions` is of the wrong type\")\n    if isinstance(contract_exceptions, dict):\n        contract_exceptions = [contract_exceptions]\n    if isinstance(contract_exceptions, list) and any(\n        [\n            not isinstance(key, str)\n            for item in contract_exceptions\n            for key in item.keys()\n        ]\n    ):\n        raise TypeError(\"Contract exception definition is of the wrong type\")\n    # Validate individual exception definitions\n    if isinstance(contract_exceptions, list) and any(\n        [\n            not (\n                (set(item.keys()) == set([\"name\", \"msg\"]))\n                or (set(item.keys()) == set([\"name\", \"msg\", \"type\"]))\n            )\n            for item in contract_exceptions\n        ]\n    ):\n        raise TypeError(\"Contract exception definition is of the wrong type\")\n    extype = type(ValueError)\n    if isinstance(contract_exceptions, list) and any(\n        [\n            (not isinstance(item[\"name\"], str))\n            or (not isinstance(item[\"msg\"], str))\n            or (not isinstance(item.get(\"type\", extype), extype))\n            for item in contract_exceptions\n        ]\n    ):\n        raise TypeError(\"Contract exception definition is of the wrong type\")\n    # Homogenize exception definitions\n    if isinstance(contract_exceptions, list):\n        homogenized_exdict = dict(\n            (\n                exdict[\"name\"],\n                {\n                    \"num\": exnum,\n                    \"msg\": exdict[\"msg\"],\n                    \"type\": exdict.get(\"type\", RuntimeError),\n                    \"field\": _get_replacement_token(exdict[\"msg\"]),\n                },\n            )\n            for exnum, exdict in enumerate(contract_exceptions)\n        )\n    else:\n        homogenized_exdict = {\n            \"default\": {\n                \"num\": 0,\n                \"msg\": contract_exceptions,\n                \"type\": RuntimeError,\n                \"field\": _get_replacement_token(contract_exceptions),\n            }\n        }\n    # Verify exception names are unique\n    if isinstance(contract_exceptions, list) and (\n        len(homogenized_exdict) != len(contract_exceptions)\n    ):\n        raise ValueError(\"Contract exception names are not unique\")\n    # Verify that exception messages are unique\n    msgs = [exvalue[\"msg\"] for exvalue in homogenized_exdict.values()]\n    if len(set(msgs)) != len(msgs):\n        raise ValueError(\"Contract exception messages are not unique\")\n    # Verify that a custom contract is not being redefined\n    if (contract_name in _CUSTOM_CONTRACTS) and (\n        _CUSTOM_CONTRACTS[contract_name] != contract_exceptions\n    ):\n        raise RuntimeError(\n            \"Attempt to redefine custom contract `{0}`\".format(contract_name)\n        )\n    # Verify that there are at most only two replacement fields, and one of\n    # them should be argument_name\n    fields = [\n        exdict[\"field\"]\n        for exdict in homogenized_exdict.values()\n        if exdict[\"field\"] is not None\n    ]\n    if (len(fields) > 2) or (\n        (len(fields) == 2)\n        and (fields[0] != \"argument_name\")\n        and (fields[1] != \"argument_name\")\n    ):\n        raise ValueError(\n            \"Multiple replacement fields to be substituted by argument value\"\n        )\n    # Register new contract\n    _CUSTOM_CONTRACTS[contract_name] = homogenized_exdict\n    return contract_exceptions", "response": "Homogenize custom contract exception definition."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfilter the value of the key - value pair and returns the result.", "response": "def filter(self, value, model=None, context=None):\n        \"\"\"\n        Filter\n        Performs value filtering and returns filtered result.\n\n        :param value:               input value\n        :param model:               parent model being validated\n        :param context:             object, filtering context\n        :return:                    filtered value\n        \"\"\"\n        value = str(value)\n        return value.upper()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a displayable name for the type.", "response": "def _get_type_name(type_):\n    # type: (type) -> str\n    \"\"\"Return a displayable name for the type.\n\n    Args:\n        type_: A class object.\n\n    Returns:\n        A string value describing the class name that can be used in a natural\n        language sentence.\n    \"\"\"\n    name = repr(type_)\n    if name.startswith(\"<\"):\n        name = getattr(type_, \"__qualname__\", getattr(type_, \"__name__\", \"\"))\n    return name.rsplit(\".\", 1)[-1] or repr(type_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the source code for a class from the stack.", "response": "def _get_class_frame_source(class_name):\n    # type: (str) -> Optional[str]\n    \"\"\"Return the source code for a class by checking the frame stack.\n\n    This is necessary because it is not possible to get the source of a class\n    being created by a metaclass directly.\n\n    Args:\n        class_name: The class to look for on the stack.\n\n    Returns:\n        The source code for the requested class if the class was found and the\n        source was accessible.\n    \"\"\"\n    for frame_info in inspect.stack():\n        try:\n            with open(frame_info[1]) as fp:\n                src = \"\".join(fp.readlines()[frame_info[2] - 1 :])\n        except IOError:\n            continue\n        if re.search(r\"\\bclass\\b\\s+\\b{}\\b\".format(class_name), src):\n            reader = six.StringIO(src).readline\n            tokens = tokenize.generate_tokens(reader)\n            source_tokens = []\n            indent_level = 0\n            base_indent_level = 0\n            has_base_level = False\n            for token, value, _, _, _ in tokens:  # type: ignore\n                source_tokens.append((token, value))\n                if token == tokenize.INDENT:\n                    indent_level += 1\n                elif token == tokenize.DEDENT:\n                    indent_level -= 1\n                    if has_base_level and indent_level <= base_indent_level:\n                        return (\n                            tokenize.untokenize(source_tokens),\n                            frame_info[0].f_globals,\n                            frame_info[0].f_locals,\n                        )\n                elif not has_base_level:\n                    has_base_level = True\n                    base_indent_level = indent_level\n    raise TypeError(\n        'Unable to retrieve source for class \"{}\"'.format(class_name)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if an attribute can be replaced with a property.", "response": "def _is_propertyable(\n    names,  # type: List[str]\n    attrs,  # type: Dict[str, Any]\n    annotations,  # type: Dict[str, type]\n    attr,  # Dict[str, Any]\n):\n    # type: (...) -> bool\n    \"\"\"Determine if an attribute can be replaced with a property.\n\n    Args:\n        names: The complete list of all attribute names for the class.\n        attrs: The attribute dict returned by __prepare__.\n        annotations: A mapping of all defined annotations for the class.\n        attr: The attribute to test.\n\n    Returns:\n        True if the attribute can be replaced with a property; else False.\n    \"\"\"\n    return (\n        attr in annotations\n        and not attr.startswith(\"_\")\n        and not attr.isupper()\n        and \"__{}\".format(attr) not in names\n        and not isinstance(getattr(attrs, attr, None), types.MethodType)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a metaclass that reads annotations from a class definition and creates a property getter method for an object.", "response": "def _create_typed_object_meta(get_fset):\n    # type: (Callable[[str, str, Type[_T]], Callable[[_T], None]]) -> type\n    \"\"\"Create a metaclass for typed objects.\n\n    Args:\n        get_fset: A function that takes three parameters: the name of an\n            attribute, the name of the private attribute that holds the\n            property data, and a type. This function must an object method that\n            accepts a value.\n\n    Returns:\n        A metaclass that reads annotations from a class definition and creates\n        properties for annotated, public, non-constant, non-method attributes\n        that will guarantee the type of the stored value matches the\n        annotation.\n    \"\"\"\n\n    def _get_fget(attr, private_attr, type_):\n        # type: (str, str, Type[_T]) -> Callable[[], Any]\n        \"\"\"Create a property getter method for an attribute.\n\n        Args:\n            attr: The name of the attribute that will be retrieved.\n            private_attr: The name of the attribute that will store any data\n                related to the attribute.\n            type_: The annotated type defining what values can be stored in the\n                attribute.\n\n        Returns:\n            A function that takes self and retrieves the private attribute from\n            self.\n        \"\"\"\n\n        def _fget(self):\n            # type: (...) -> Any\n            \"\"\"Get attribute from self without revealing the private name.\"\"\"\n            try:\n                return getattr(self, private_attr)\n            except AttributeError:\n                raise AttributeError(\n                    \"'{}' object has no attribute '{}'\".format(\n                        _get_type_name(type_), attr\n                    )\n                )\n\n        return _fget\n\n    class _AnnotatedObjectMeta(type):\n        \"\"\"A metaclass that reads annotations from a class definition.\"\"\"\n\n        def __new__(\n            mcs,  # type: Type[_AnnotatedObjectMeta]\n            name,  # type: str\n            bases,  # type: List[type]\n            attrs,  # type: Dict[str, Any]\n            **kwargs  # type: Dict[str, Any]\n        ):\n            # type: (...) -> type\n            \"\"\"Create class objs that replaces annotated attrs with properties.\n\n            Args:\n                mcs: The class object being created.\n                name: The name of the class to create.\n                bases: The list of all base classes for the new class.\n                attrs: The list of all attributes for the new class from the\n                    definition.\n\n            Returns:\n                A new class instance with the expected base classes and\n                attributes, but with annotated, public, non-constant,\n                non-method attributes replaced by property objects that\n                validate against the annotated type.\n            \"\"\"\n            annotations = attrs.get(\"__annotations__\", {})\n            use_comment_type_hints = (\n                not annotations and attrs.get(\"__module__\") != __name__\n            )\n            if use_comment_type_hints:\n                frame_source = _get_class_frame_source(name)\n                annotations = get_type_hints(*frame_source)\n            names = list(attrs) + list(annotations)\n            typed_attrs = {}\n            for attr in names:\n                typed_attrs[attr] = attrs.get(attr)\n                if _is_propertyable(names, attrs, annotations, attr):\n                    private_attr = \"__{}\".format(attr)\n                    if attr in attrs:\n                        typed_attrs[private_attr] = attrs[attr]\n                    type_ = (\n                        Optional[annotations[attr]]\n                        if not use_comment_type_hints\n                        and attr in attrs\n                        and attrs[attr] is None\n                        else annotations[attr]\n                    )\n                    typed_attrs[attr] = property(\n                        _get_fget(attr, private_attr, type_),\n                        get_fset(attr, private_attr, type_),\n                    )\n            properties = [\n                attr\n                for attr in annotations\n                if _is_propertyable(names, attrs, annotations, attr)\n            ]\n            typed_attrs[\"_tp__typed_properties\"] = properties\n            typed_attrs[\"_tp__required_typed_properties\"] = [\n                attr\n                for attr in properties\n                if (\n                    attr not in attrs\n                    or attrs[attr] is None\n                    and use_comment_type_hints\n                )\n                and NoneType not in getattr(annotations[attr], \"__args__\", ())\n            ]\n            return super(_AnnotatedObjectMeta, mcs).__new__(  # type: ignore\n                mcs, name, bases, typed_attrs, **kwargs\n            )\n\n    return _AnnotatedObjectMeta"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _strict_object_meta_fset(_, private_attr, type_):\n    # type: (str, str, Type[_T]) -> Callable[[_T], None]\n    \"\"\"Create a property setter method for the attribute.\n\n    Args:\n        _: The name of the attribute to set. Unused.\n        private_attr: The name of the attribute that will store any data\n            related to the attribute.\n        type_: The annotated type defining what values can be stored in the\n            attribute.\n\n    Returns:\n        A method that takes self and a value and stores that value on self\n        in the private attribute iff the value is an instance of type_.\n    \"\"\"\n\n    def _fset(self, value):  # type: Any\n        # type: (...) -> None\n        \"\"\"Set the value on self iff the value is an instance of type_.\n\n        Args:\n            value: The value to set.\n\n        Raises:\n            TypeError: Raised when the value is not an instance of type_.\n        \"\"\"\n        rtype = type_\n        if isinstance(type_, TypeVar):\n            type_map = dict(\n                zip(self.__parameters__, self.__orig_class__.__args__)\n            )\n            rtype = type_map[type_]\n        if not is_instance(value, rtype):\n            raise TypeError(\n                \"Cannot assign type of {} to attribute of type {}.\".format(\n                    _get_type_name(type(value)), _get_type_name(rtype)\n                )\n            )\n        vars(self)[private_attr] = value\n\n    return _fset", "response": "Create a property setter method for the object meta class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _object_meta_fset(_, private_attr, type_):\n    # type: (str, str, Type[_T]) -> Callable[[_T], None]\n    \"\"\"Create a property setter method for the attribute.\n\n    Args:\n        _: The name of the attribute to set. Unused.\n        private_attr: The name of the attribute that will store any data\n            related to the attribute.\n        type_: The annotated type defining what values can be stored in the\n            attribute.\n\n    Returns:\n        A method that takes self and a value and stores that value on self\n        in the private attribute if the value is not an instance of type_\n        and cannot be cast into type_.\n    \"\"\"\n\n    def _fset(self, value):  # type: Any\n        # type: (...) -> None\n        \"\"\"Set the value on self and coerce it to type_ if necessary.\n\n        Args:\n            value: The value to set.\n\n        Raises:\n            TypeError: Raised when the value is not an instance of type_\n                and cannot be cast into a compatible object of type_.\n        \"\"\"\n        rtype = type_\n        if isinstance(type_, TypeVar):\n            type_map = dict(\n                zip(self.__parameters__, self.__orig_class__.__args__)\n            )\n            rtype = type_map[type_]\n        vars(self)[private_attr] = cast(rtype, value)\n\n    return _fset", "response": "Create a property setter method for the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _tp__get_typed_properties(self):\n        try:\n            return tuple(getattr(self, p) for p in self._tp__typed_properties)\n        except AttributeError:\n            raise NotImplementedError", "response": "Return a tuple of typed attrs that can be used for comparisons."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(cls, routes, *args, **kwargs): # pragma: no cover\n\n    app = init(cls, routes, *args, **kwargs)\n\n    HOST = os.getenv('HOST', '0.0.0.0')\n    PORT = int(os.getenv('PORT', 8000))\n\n    aiohttp.web.run_app(app, port=PORT, host=HOST)", "response": "Run a web application."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of monthly values.", "response": "def monthlyValues(self):\n        \"\"\"\n        Description of seasonality from monthly values. Multiple smoothing methods are possible\n        (see smoothing attribute).\n        List should contain twelve entries: January to December.\n        :rtype: list\n\n        https://github.com/SwissTPH/openmalaria/wiki/GeneratedSchema32Doc#list-of-monthly-values\n        \"\"\"\n        monthly_values = []\n        for value in self.et.find(\"monthlyValues\").findall(\"value\"):\n            monthly_values.append(float(value.text))\n        return monthly_values"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, vector, InterventionAnophelesParams=None):\n        # TODO\n        # 1. If there are GVI interventions, for every GVI, add anophelesParams section.\n        # (gvi_anophelesParams field in AnophelesSnippets models)\n        # 2. If there are ITN interventions, for every ITN, add anophelesParams section\n        # (itn_anophelesParams field in AnophelesSnippets models)\n        # 3. If there are IRS interventions, for every IRS section add anophelesParams section\n        # (irs_anophelesParams field in AnophelesSnippets models)\n\n        assert isinstance(vector, six.string_types)\n        et = ElementTree.fromstring(vector)\n        # check if it is valid vector\n        mosquito = Vector(et)\n        assert isinstance(mosquito.mosquito, str)\n        assert isinstance(mosquito.propInfected, float)\n        assert len(mosquito.seasonality.monthlyValues) == 12\n        index = len(self.et.findall(\"anopheles\"))\n        self.et.insert(index, et)", "response": "Add a vector to an entomology section."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary of all the anopheles in the log.", "response": "def vectors(self):\n        \"\"\"\n        :rtype: dict\n        \"\"\"\n        vectors = {}\n        for anopheles in self.et.findall(\"anopheles\"):\n            vectors[anopheles.attrib[\"mosquito\"]] = Vector(anopheles)\n        return vectors"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _format_msg(text, width, indent=0, prefix=\"\"):\n    text = repr(text).replace(\"`\", \"\\\\`\").replace(\"\\\\n\", \" ``\\\\n`` \")\n    sindent = \" \" * indent if not prefix else prefix\n    wrapped_text = textwrap.wrap(text, width, subsequent_indent=sindent)\n    # [1:-1] eliminates quotes generated by repr in first line\n    return (\"\\n\".join(wrapped_text))[1:-1].rstrip()", "response": "r Format exception message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _validate_fname(fname, arg_name):\n    if fname is not None:\n        msg = \"Argument `{0}` is not valid\".format(arg_name)\n        if (not isinstance(fname, str)) or (isinstance(fname, str) and (\"\\0\" in fname)):\n            raise RuntimeError(msg)\n        try:\n            if not os.path.exists(fname):\n                os.access(fname, os.W_OK)\n        except (TypeError, ValueError):  # pragma: no cover\n            raise RuntimeError(msg)", "response": "Validate that a string is a valid file name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _build_ex_tree(self):\n        # Load exception data into tree structure\n        sep = self._exh_obj.callables_separator\n        data = self._exh_obj.exceptions_db\n        if not data:\n            raise RuntimeError(\"Exceptions database is empty\")\n        # Add root node to exceptions, needed when tracing done\n        # through test runner which is excluded from callable path\n        for item in data:\n            item[\"name\"] = \"root{sep}{name}\".format(sep=sep, name=item[\"name\"])\n        self._tobj = ptrie.Trie(sep)\n        try:\n            self._tobj.add_nodes(data)\n        except ValueError as eobj:\n            if str(eobj).startswith(\"Illegal node name\"):\n                raise RuntimeError(\"Exceptions do not have a common callable\")\n            raise\n        # Find closest root node to first multi-leaf branching or first\n        # callable with exceptions and make that the root node\n        node = self._tobj.root_name\n        while (len(self._tobj.get_children(node)) == 1) and (\n            not self._tobj.get_data(node)\n        ):\n            node = self._tobj.get_children(node)[0]\n        if not self._tobj.is_root(node):  # pragma: no branch\n            self._tobj.make_root(node)\n            nsep = self._tobj.node_separator\n            prefix = nsep.join(node.split(self._tobj.node_separator)[:-1])\n            self._tobj.delete_prefix(prefix)\n        self._print_ex_tree()", "response": "Construct exception tree from trace."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild the database of module callables sorted by line number.", "response": "def _build_module_db(self):\n        \"\"\"\n        Build database of module callables sorted by line number.\n\n        The database is a dictionary whose keys are module file names and\n        whose values are lists of dictionaries containing name and line\n        number of callables in that module\n        \"\"\"\n        tdict = collections.defaultdict(lambda: [])\n        for callable_name, callable_dict in self._exh_obj.callables_db.items():\n            fname, line_no = callable_dict[\"code_id\"]\n            cname = (\n                \"{cls_name}.__init__\".format(cls_name=callable_name)\n                if callable_dict[\"type\"] == \"class\"\n                else callable_name\n            )\n            tdict[fname].append({\"name\": cname, \"line\": line_no})\n        for fname in tdict.keys():\n            self._module_obj_db[fname] = sorted(\n                tdict[fname], key=lambda idict: idict[\"line\"]\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves raised info from exception message and create separate list for it.", "response": "def _process_exlist(self, exc, raised):\n        \"\"\"Remove raised info from exception message and create separate list for it.\"\"\"\n        if (not raised) or (raised and exc.endswith(\"*\")):\n            return exc[:-1] if exc.endswith(\"*\") else exc\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngrowing this array to specified length. This array can t be shrinked raise ValueError if the size is out of bound.", "response": "def resize(self, size):\n\t\t\"\"\" Grow this array to specified length. This array can't be shrinked\n\n\t\t:param size: new length\n\t\t:return: None\n\t\t\"\"\"\n\t\tif size < len(self):\n\t\t\traise ValueError(\"Value is out of bound. Array can't be shrinked\")\n\t\tcurrent_size = self.__size\n\t\tfor i in range(size - current_size):\n\t\t\tself.__array.append(WBinArray(0, self.__class__.byte_size))\n\t\tself.__size = size"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef swipe(self):\n\t\tresult = WFixedSizeByteArray(len(self))\n\t\tfor i in range(len(self)):\n\t\t\tresult[len(self) - i - 1] = self[i]\n\t\treturn result", "response": "Mirror current array value in reverse. Bytes that had greater index will have lesser index and and\n\tvice - versa will have lesser index and and\n\tvice - versa."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nguess mime type for the given file name.", "response": "def mime_type(filename):\n\t\"\"\" Guess mime type for the given file name\n\n\tNote: this implementation uses python_magic package which is not thread-safe, as a workaround global lock is\n\tused for the ability to work in threaded environment\n\n\t:param filename: file name to guess\n\t:return: str\n\t\"\"\"\n\t# TODO: write lock-free mime_type function\n\ttry:\n\t\t__mime_lock.acquire()\n\n\t\textension = filename.split(\".\")\n\t\textension = extension[len(extension) - 1]\n\n\t\tif extension == \"woff2\":\n\t\t\treturn \"application/font-woff2\"\n\t\tif extension == \"css\":\n\t\t\treturn \"text/css\"\n\n\t\tm = magic.from_file(filename, mime=True)\n\t\tm = m.decode() if isinstance(m, bytes) else m  # compatibility fix, some versions return bytes some - str\n\t\tif m == \"text/plain\":\n\t\t\tguessed_type = mimetypes.guess_type(filename)[0]  # for js-detection\n\t\t\tif guessed_type:\n\t\t\t\treturn guessed_type\n\t\treturn m\n\tfinally:\n\t\t__mime_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating the item against allowed_types.", "response": "def _validate_type(self, item, name):\n        \"\"\"Validate the item against `allowed_types`.\"\"\"\n        if item is None:\n            # don't validate None items, since they'll be caught by the portion\n            # of the validator responsible for handling `required`ness\n            return\n\n        if not isinstance(item, self.allowed_types):\n            item_class_name = item.__class__.__name__\n            raise ArgumentError(name,\n                \"Expected one of %s, but got `%s`\" % (\n                    self.allowed_types, item_class_name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates that the item is present if it s required.", "response": "def _validate_required(self, item, name):\n        \"\"\"Validate that the item is present if it's required.\"\"\"\n        if self.required is True and item is None:\n            raise ArgumentError(name, \"This argument is required.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the documentation dictionary for this argument.", "response": "def doc_dict(self):\n        \"\"\"Returns the documentation dictionary for this argument.\"\"\"\n        doc = {\n            'type': self.__class__.__name__,\n            'description': self.description,\n            'default': self.default,\n            'required': self.required\n        }\n        if hasattr(self, 'details'):\n            doc['detailed_description'] = self.details\n        return doc"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_items(self, input_list):\n        output_list = []\n        for item in input_list:\n            valid = self.list_item_type.validate(item, self.item_name)\n            output_list.append(valid)\n\n            # this might lead to confusing error messages.  tbh, we need to\n            # figure out a better way to do validation and error handling here,\n            # but i'm brute forcing this a bit so that we have something\n            # workable\n        return output_list", "response": "Validates that items in the list are of the type specified. Returns the input list if it s valid raises an ArgumentError if it s not valid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef startserver(self, hostname=\"localhost\", port=8080,\n                    daemon=False, handle_sigint=True):\n        \"\"\"Start json-rpc service.\"\"\"\n        if daemon:\n            print(\"Sorry daemon server not supported just yet.\")\n            # TODO start as daemon similar to bitcoind\n        else:\n            print(\"Starting %s json-rpc service at http://%s:%s\" % (\n                self.__class__.__name__, hostname, port\n            ))\n            self._http_server = HTTPServer(\n                server_address=(hostname, int(port)),\n                RequestHandlerClass=self.get_http_request_handler()\n            )\n\n            if handle_sigint:\n                def sigint_handler(signum, frame):\n                    self._post_shutdown()\n                    sys.exit(0)\n                signal.signal(signal.SIGINT, sigint_handler)\n            self._http_server.serve_forever()", "response": "Start json - rpc service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies a default value to a dictionary.", "response": "def apply_dict_default(dictionary, arg, default):\r\n    '''\r\n    Used to avoid generating a defaultdict object, or assigning defaults to a dict-like object\r\n\r\n    apply_dict_default({}, 'test', list)\r\n    # => {'test': []}\r\n\r\n    apply_dict_default({'test': 'ok'}, 'test', list)\r\n    # => {'test': 'ok'}\r\n    '''\r\n    if arg not in dictionary:\r\n        if hasattr(default, '__call__'):\r\n            # Don't try/catch because the method could raise a TypeError and we'd hide it\r\n            default = restrict_args(default, arg)\r\n        dictionary[arg] = default\r\n    return dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_area_data(self):\n        \n        if self.mode == '1n':\n            data = [self.hist['NBMF+'].data,\\\n                    self.hist['NBMF-'].data,\\\n                    self.hist['NBMB+'].data,\\\n                    self.hist['NBMB-'].data]\n            \n        elif self.area == 'BNMR':\n            data = [self.hist['F+'].data,\\\n                    self.hist['F-'].data,\\\n                    self.hist['B+'].data,\\\n                    self.hist['B-'].data]\n        \n        elif self.area == 'BNQR':\n            data = [self.hist['R+'].data,\\\n                    self.hist['R-'].data,\\\n                    self.hist['L+'].data,\\\n                    self.hist['L-'].data]\n        else:\n            data = []\n        \n        if self.mode == '2h':\n            data.extend([self.hist['AL1+'].data,self.hist['AL1-'].data,\n                        self.hist['AL0+'].data,self.hist['AL0-'].data,\n                        self.hist['AL3+'].data,self.hist['AL3-'].data,\n                        self.hist['AL2+'].data,self.hist['AL2-'].data])\n        \n        # copy\n        return [np.copy(d) for d in data]", "response": "Get histogram list based on area type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the asymmetry of each helicity.", "response": "def _get_asym_hel(self,d):\n        \"\"\"\n            Find the asymmetry of each helicity. \n        \"\"\"\n        \n        # get data 1+ 2+ 1- 2-\n        d0 = d[0]; d1 = d[2]; d2 = d[1]; d3 = d[3]\n\n        # pre-calcs\n        denom1 = d0+d1; \n        denom2 = d2+d3\n        \n        # check for div by zero\n        denom1[denom1==0] = np.nan          \n        denom2[denom2==0] = np.nan\n        \n        # asymmetries in both helicities\n        asym_hel = [(d0-d1)/denom1,\n                    (d2-d3)/denom2]\n                    \n        # errors \n        # https://www.wolframalpha.com/input/?i=%E2%88%9A(F*(derivative+of+((F-B)%2F(F%2BB))+with+respect+to+F)%5E2+%2B+B*(derivative+of+((F-B)%2F(F%2BB))+with+respect+to+B)%5E2)\n        asym_hel_err = [2*np.sqrt(d0*d1/np.power(denom1,3)),\n                        2*np.sqrt(d2*d3/np.power(denom2,3))]\n        \n        # remove nan            \n        for i in range(2):\n            asym_hel[i][np.isnan(asym_hel[i])] = 0.\n            asym_hel_err[i][np.isnan(asym_hel_err[i])] = 0.\n        \n        # exit\n        return [[asym_hel[1],asym_hel_err[1]],  # something wrong with file?\n                [asym_hel[0],asym_hel_err[0]]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_asym_comb(self,d):\n        \n        # get data\n        d0 = d[0]; d1 = d[2]; d2 = d[1]; d3 = d[3]\n        \n        # pre-calcs\n        r_denom = d0*d3\n        r_denom[r_denom==0] = np.nan\n        r = np.sqrt((d1*d2/r_denom))\n        r[r==-1] = np.nan\n    \n        # combined asymmetry\n        asym_comb = (r-1)/(r+1)\n        \n        # check for div by zero\n        d0[d0==0] = np.nan                  \n        d1[d1==0] = np.nan\n        d2[d2==0] = np.nan\n        d3[d3==0] = np.nan\n        \n        # error in combined asymmetry\n        asym_comb_err = r*np.sqrt(1/d1 + 1/d0 + 1/d3 + 1/d2)/np.square(r+1)\n        \n        # replace nan with zero \n        asym_comb[np.isnan(asym_comb)] = 0.\n        asym_comb_err[np.isnan(asym_comb_err)] = 0.\n        \n        return [asym_comb,asym_comb_err]", "response": "Find the combined asymmetry for slr runs. Elegant 4 - counter method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding asymmetry and error ratios from cryo oven with alpha detectors.", "response": "def _get_asym_alpha(self,a,b):\n        \"\"\"\n            Find alpha diffusion ratios from cryo oven with alpha detectors. \n            a: list of alpha detector histograms (each helicity)\n            b: list of beta  detector histograms (each helicity)\n        \"\"\"\n        \n        # just  use AL0\n        try:\n            a = a[2:4]\n        except IndexError:\n            a = a[:2]\n            \n        # sum counts in alpha detectors\n        asum = np.sum(a,axis=0)\n        \n        # sum counts in beta detectors\n        bsum = np.sum(b,axis=0)\n        \n        # check for dividing by zero \n        asum[asum == 0] = np.nan\n        bsum[bsum == 0] = np.nan\n        \n        # asym calcs\n        asym = asum/bsum\n        \n        # errors\n        dasym = asym*np.sqrt(1/asum + 1/bsum)\n        \n        return [asym,dasym]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_1f_sum_scans(self,d,freq):\n        \n        # combine scans: values with same frequency \n        unique_freq = np.unique(freq)\n        \n        sum_scans = [[] for i in range(len(d))]\n        \n        for f in unique_freq: \n            tag = freq==f\n            for i in range(len(d)):\n                sum_scans[i].append(np.sum(d[i][tag]))\n            \n        return (np.array(unique_freq),np.array(sum_scans))", "response": "Get 1f sum counts over 1f scans."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting asymmetries for 2e random - frequency scan.", "response": "def _get_2e_asym(self):\n        \"\"\"\n            Get asymmetries for 2e random-frequency scan. \n            Based on bnmr_2e.cpp by rmlm (Oct 4, 2017).\n        \"\"\"\n        \n        # get needed PPG parameters for splitting 1D histos into 2D histos\n        try:        \n            # get frequency vector\n            freq = np.arange(self.ppg['freq_start'].mean,\\\n                             self.ppg['freq_stop'].mean+\\\n                                    self.ppg['freq_incr'].mean,\\\n                             self.ppg['freq_incr'].mean)\n                             \n            # number of dwelltimes per frequency bin \n            ndwell = 2*int(self.ppg['ndwell_per_f'].mean)-1\n            \n            # number of RF on delays for the start bin. \n            start_bin = int(self.ppg['rf_on_delay'].mean)\n            \n            # get bin centers in ms\n            time = self.ppg['rf_on_ms'].mean*(np.arange(ndwell)+0.5-ndwell/2.)\n            \n            # get the time and index of the middle time \n            mid_time_i = int(np.floor(ndwell/2.))\n            mid_time = time[mid_time_i]\n        \n            # beam off time after pulse in ms\n            beam_off = int(self.ppg['beam_off_ms'].mean)\n        \n        except KeyError:\n            raise RuntimeError(\"Not all dictionary variables read out to \"+\\\n                               \"proper locations\")\n            \n        # setup output\n        out = bdict()\n        out['freq'] = freq\n        out['time'] = time\n            \n        # get data\n        data = np.array(self._get_area_data()) # [[fp], [bfm], [bp], [bm]]\n        \n        # discared initial bad bins, and beam-off trailing bins\n        data = data[:,start_bin:len(freq)*ndwell+start_bin]\n        \n        # split data by frequency\n        nsplit = len(data[0])/ndwell\n        \n        fp = np.array(np.split(data[0],nsplit))\n        fm = np.array(np.split(data[1],nsplit))\n        bp = np.array(np.split(data[2],nsplit))\n        bm = np.array(np.split(data[3],nsplit))\n        \n        # get raw asymmetries \n        asym_p_2cntr = (bp-fp)/(bp+fp)      # two counter\n        asym_m_2cntr = (bm-fm)/(bm+fm)      # two counter\n        r = np.sqrt(bp*fm/(bm*fp))\n        asym_4cntr = (r-1)/(r+1)            # four counter\n        \n        # get raw asymmetry errors\n        asym_p_2cntr_err = 2*np.sqrt(bp*fp)/((bp+fp)**1.5)\n        asym_m_2cntr_err = 2*np.sqrt(bm*fm)/((bm+fm)**1.5)\n        asym_4cntr_err = r*np.sqrt(1./bp+1./bm+1./fp+1./fm)/((r+1)**2)\n\n        # save to output\n        out['raw_p'] = np.array([asym_p_2cntr,asym_p_2cntr_err])\n        out['raw_n'] = np.array([asym_m_2cntr,asym_m_2cntr_err])\n        out['raw_c'] = np.array([asym_4cntr,asym_4cntr_err])\n\n        # wrap asymmetry arrays into one for calculations [p,m,4]\n        # indexing is now [pm4][freq][time bin]\n        asym     = np.array([asym_p_2cntr,    asym_m_2cntr,    asym_4cntr])\n        asym_err = np.array([asym_p_2cntr_err,asym_m_2cntr_err,asym_4cntr_err])\n\n        # compute differenced asymmetries via slopes from weighted least squares \n        # minimization.\n        if ndwell >= 5:\n            \n            # calculate needed components element-wise\n            w = asym_err**-2\n            x = time\n            y = asym\n            \n            wx = w*x\n            wy = w*y\n            wxy = w*x*y\n            wxx = w*x*x\n        \n            # sum over values i < mid_time_i within each asymmetry and frequency \n            # Indexing: [pm4][freq]\n            w_pre   = np.sum(w  [:,:,:mid_time_i],2)    \n            wx_pre  = np.sum(wx [:,:,:mid_time_i],2)\n            wy_pre  = np.sum(wy [:,:,:mid_time_i],2)\n            wxy_pre = np.sum(wxy[:,:,:mid_time_i],2)\n            wxx_pre = np.sum(wxx[:,:,:mid_time_i],2)\n            \n            # sum over values i > mid_time_i\n            w_pst   = np.sum(w  [:,:,-mid_time_i:],2)\n            wx_pst  = np.sum(wx [:,:,-mid_time_i:],2)\n            wy_pst  = np.sum(wy [:,:,-mid_time_i:],2)\n            wxy_pst = np.sum(wxy[:,:,-mid_time_i:],2)\n            wxx_pst = np.sum(wxx[:,:,-mid_time_i:],2)\n            \n            # calculate slopes and intercepts\n            delta_pre = w_pre*wxx_pre - wx_pre**2\n            delta_pst = w_pst*wxx_pst - wx_pst**2\n            \n            sl_pre = (w_pre*wxy_pre - wx_pre*wy_pre)/delta_pre\n            sl_pst = (w_pst*wxy_pst - wx_pst*wy_pst)/delta_pst\n            dsl_pre = np.sqrt(w_pre/delta_pre)\n            dsl_pst = np.sqrt(w_pst/delta_pst)\n            \n            intr_pre = (wy_pre*wxx_pre - wx_pre*wxy_pre)/delta_pre\n            intr_pst = (wy_pst*wxx_pst - wx_pst*wxy_pst)/delta_pst\n            dintr_pre = np.sqrt(wxx_pre/delta_pre)\n            dintr_pst = np.sqrt(wxx_pst/delta_pst)\n            \n            # extrapolate to middle time bin\n            asym_slopes = intr_pst-intr_pre+(sl_pst-sl_pre)*mid_time\n            asym_slopes_err = np.sqrt(dintr_pre**2 + dintr_pst**2 + \\\n                                      (dsl_pre**2 + dsl_pst**2) * mid_time**2)\n            \n            # save to output        \n            out['sl_p'] = np.array([asym_slopes[0],asym_slopes_err[0]])\n            out['sl_n'] = np.array([asym_slopes[1],asym_slopes_err[1]])\n            out['sl_c'] = np.array([asym_slopes[2],asym_slopes_err[2]])\n        \n        # calculate asymmetry using differences\n        asym_diff = asym[:,:,mid_time_i+1] - asym[:,:,mid_time_i-1]\n        asym_diff_err = np.sqrt(asym_err[:,:,mid_time_i+1]**2+\\\n                                asym_err[:,:,mid_time_i-1]**2)\n        \n        # save to output\n        out['dif_p'] = np.array([asym_diff[0],asym_diff_err[0]])\n        out['dif_n'] = np.array([asym_diff[1],asym_diff_err[1]])\n        out['dif_c'] = np.array([asym_diff[2],asym_diff_err[2]])   \n            \n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _rebin(self,xdx,rebin):\n\n        x = xdx[0]\n        dx = xdx[1]\n        rebin = int(rebin)\n        \n        # easy end condition\n        if rebin <= 1:\n            return (x,dx)\n        \n        # Rebin Discard unused bins\n        lenx = len(x)\n        x_rebin = []\n        dx_rebin = []\n        \n        # avoid dividing by zero\n        dx[dx==0] = np.inf\n        \n        # weighted mean\n        for i in np.arange(0,lenx,rebin):\n            w = 1./dx[i:i+rebin-1]**2\n            wsum = np.sum(w)\n            \n            if wsum == 0:\n                x_rebin.append(np.mean(x[i:i+rebin-1]))\n                dx_rebin.append(np.std(x[i:i+rebin-1]))\n            else:\n                x_rebin.append(np.sum(x[i:i+rebin-1]*w)/wsum)\n                dx_rebin.append(1./wsum**0.5)\n        return np.array([x_rebin,dx_rebin])", "response": "Rebin array x with weights 1 / dx**2 by factor rebin."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef asym(self,option=\"\",omit=\"\",rebin=1,hist_select=''):\n        \n        # check rebin factor\n        if type(rebin) not in (int,np.int64) or rebin < 1:\n            raise RuntimeError('Rebinning factor must be int >= 1.')\n        \n        # check for additonal options (1F)\n        if omit != '':\n            further_options = list(map(str.strip,omit.split(' ')))\n        else:\n            further_options = list(map(str.strip,option.split(' ')[1:]))\n        option = option.split(' ')[0].strip()\n        \n        # Option reduction\n        option = option.lower()\n        if option == \"\"                                     : pass\n        elif option in ['+','up','u','p','pos','positive']  : option = 'positive'\n        elif option in ['-','down','d','n','neg','negative']: option = 'negative'\n        elif option in [\"c\",\"com\",\"combined\"]               : option = \"combined\"\n        elif option in [\"h\",\"hel\",\"helicity\"]               : option = 'helicity'\n        elif option in [\"r\",\"raw\"]                          : option = 'raw'\n        elif option in ['adif','ad','adiff']                : option = 'alpha_diffusion'\n        elif option in ['atag','at']                        : option = 'alpha_tagged'\n        else:\n            raise RuntimeError(\"Option not recognized.\")\n        \n        # get data\n        if hist_select != '':\n            \n            # split into parts\n            hist_select_temp = []\n            for histname in hist_select.split(','):\n                hist_select_temp.extend(histname.split(';'))\n            hist_select = [h.strip() for h in hist_select_temp]\n            \n            # check for user error\n            if len(hist_select) < 4:\n                raise RuntimeError('hist_select must be a string of at least '+\\\n                        'four [,]-seperated or [;]-seperated histogram names')\n            \n            # get data\n            d = [self.hist[h].data for h in hist_select]\n            d_all = d\n            \n        # get default data\n        else:\n            d = self._get_area_data() # 1+ 2+ 1- 2-\n            d_all = d\n            \n        # get alpha diffusion data\n        if self.mode == '2h':\n            d_alpha = d[4:]\n            d = d[:4]\n        \n        # SLR -----------------------------------------------------------------\n        if self.mode in [\"20\",'2h']:\n            \n            # calculate background\n            n_prebeam = int(self.ppg['prebeam'].mean)\n            bkgd = np.sum(np.asarray(d_all)[:,:n_prebeam],axis=1)\n            bkgd_err = np.sqrt(bkgd)/n_prebeam\n            bkgd /= n_prebeam\n            \n            # subtract background from counts, remove negative count values,\n            # delete prebeam entries\n            for i in range(len(d)):\n                d[i] = d[i]-bkgd[i]\n                d[i][d[i]<0] = 0.\n                d[i] = np.delete(d[i],np.arange(n_prebeam))\n\n            # do alpha background subtractions\n            if self.mode == '2h':    \n                for i in range(len(d_alpha)):\n                    d_alpha[i] = d_alpha[i]-bkgd[i+len(d)]\n                    d_alpha[i][d_alpha[i]<0] = 0.\n                    d_alpha[i] = np.delete(d_alpha[i],np.arange(n_prebeam))\n                \n            # get helicity data\n            if option != 'combined':\n                h = np.array(self._get_asym_hel(d))\n                \n            # rebin time\n            time = (np.arange(len(d[0]))+0.5)*self.ppg['dwelltime'].mean/1000\n            if rebin > 1:\n                len_t = len(time)\n                new_time = (np.average(time[i:i+rebin-1]) for i in np.arange(0,len_t,rebin))\n                time = np.fromiter(new_time,dtype=float,count=int(len_t/rebin))\n\n            # mode switching\n            if option == 'positive': # ---------------------------------------\n                return np.vstack([time,self._rebin(h[0],rebin)])\n                \n            elif option == 'negative': # -------------------------------------\n                return np.vstack([time,self._rebin(h[1],rebin)])\n\n            elif option == 'helicity': # -------------------------------------\n                out = bdict()\n                out['p'] = self._rebin(h[0],rebin)\n                out['n'] = self._rebin(h[1],rebin)\n                out['time_s'] = time\n                return out\n\n            elif option == 'combined': # -------------------------------------\n                c = np.array(self._get_asym_comb(d))\n                return np.vstack([time,self._rebin(c,rebin)])\n                \n            elif option == 'alpha_diffusion': # ------------------------------\n                try:\n                    asym = self._get_asym_alpha(d_alpha,d)\n                except UnboundLocalError as err:\n                    if self.mode != '2h':\n                        raise RuntimeError('Run is not in 2h mode.')\n                return np.vstack([time,self._rebin(asym,rebin)])\n            \n            elif option == 'alpha_tagged': # ---------------------------------\n                try:\n                    asym = self._get_asym_alpha_tag(d_alpha,d)  \n                except UnboundLocalError as err:\n                    if self.mode != '2h':\n                        raise RuntimeError('Run is not in 2h mode.')\n                    else:\n                        raise err\n                \n                out = bdict()\n                out['p_wiA'] = self._rebin(asym[0][0],rebin)\n                out['n_wiA'] = self._rebin(asym[0][1],rebin)\n                out['p_noA'] = self._rebin(asym[1][0],rebin)\n                out['n_noA'] = self._rebin(asym[1][1],rebin)\n                out['p_noT'] = self._rebin(asym[2][0],rebin)\n                out['n_noT'] = self._rebin(asym[2][1],rebin)\n                out['c_wiA'] = self._rebin(asym[3],rebin)\n                out['c_noA'] = self._rebin(asym[4],rebin)\n                out['c_noT'] = self._rebin(asym[5],rebin)\n                out['time_s'] = time\n                \n                return out\n            \n            else:\n                c = np.array(self._get_asym_comb(d))\n                \n                out = bdict()\n                out['p'] = self._rebin(h[0],rebin)\n                out['n'] = self._rebin(h[1],rebin)\n                out['c'] = self._rebin(c,rebin)  \n                out['time_s'] = time\n                return out\n        \n        # 1F ------------------------------------------------------------------\n        elif self.mode in ['1f','1n']:\n            \n            # get xaxis label and data key\n            if self.mode == '1f':\n                xlabel = 'Frequency'\n                xlab = 'freq'\n            elif self.mode == '1n':\n                xlabel = 'Rb Cell mV set'\n                xlab = 'mV'\n            \n            # get bins to kill\n            bin_ranges_str = further_options \n            bin_ranges = []\n            for b in bin_ranges_str:\n                if not '-' in b:\n                    bin_ranges.append(int(b))\n                else:\n                    one = int(b.split('-')[0])\n                    two = int(b.split('-')[1])\n                    bin_ranges.extend(np.arange(one,two+1))\n            \n            # kill bins\n            for i in range(len(d)):\n\n                # get good bin range\n                if len(bin_ranges) > 0:\n                    bin_ranges = np.array(bin_ranges)\n                    idx = (bin_ranges>=0)*(bin_ranges<len(d[i]))\n                    bin_ranges = bin_ranges[idx]\n\n                # kill\n                d[i][bin_ranges] = 0.\n            \n            # get frequency\n            freq = self.hist[xlabel].data\n            \n            # mode switching\n            if option =='raw':\n                a = self._get_asym_hel(d)\n                out = bdict()\n                out['p'] = np.array(a[0])\n                out['n'] = np.array(a[1])\n                out[xlab] = np.array(freq)\n                return out \n            else:\n                freq,d = self._get_1f_sum_scans(d,freq)\n                                       \n            # rebin frequency\n            if rebin>1:\n                len_f = len(freq)\n                newf = (np.average(freq[i:i+rebin-1]) for i in np.arange(0,len_f,rebin))\n                freq = np.fromiter(newf,dtype=float,count=int(np.ceil(len_f/rebin)))\n                                       \n            # swtich between remaining modes\n            if option == 'helicity':\n                a = self._get_asym_hel(d)\n                out = bdict()\n                out['p'] = self._rebin(a[0],rebin)\n                out['n'] = self._rebin(a[1],rebin)\n                out[xlab] = np.array(freq)\n                return out\n            \n            elif option == 'positive':\n                a = self._get_asym_hel(d)\n                return np.vstack([freq,self._rebin(a[0],rebin)])\n            \n            elif option == 'negative':\n                a = self._get_asym_hel(d)\n                return np.vstack([freq,self._rebin(a[1],rebin)])\n            \n            elif option in ['combined']:\n                a = self._get_asym_comb(d)\n                return np.vstack([freq,self._rebin(a,rebin)])\n            else:\n                ah = self._get_asym_hel(d)\n                ac = self._get_asym_comb(d)\n                \n                out = bdict()\n                out['p'] = self._rebin(ah[0],rebin)\n                out['n'] = self._rebin(ah[1],rebin)\n                out['c'] = self._rebin(ac,rebin)  \n                out[xlab] = np.array(freq)\n                return out\n            \n        # 2E ------------------------------------------------------------------\n        elif self.mode in ['2e']:\n            return self._get_2e_asym()\n        \n        # unknown entry -------------------------------------------------------\n        else:\n            print(\"Unknown run type.\")\n            return", "response": "This function calculates the asymmetry of a single object in a single file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef beam_kev(self,get_error=False):\n        \n        # get epics pointer\n        epics = self.epics\n        \n        # fetch stds\n        if get_error:\n            attr = 'std'\n        else:\n            attr = 'mean'\n        \n        # get inital beam energy in keV\n        beam = getattr(epics.target_bias,attr)/1000.\n            \n        # get RB cell voltage\n        bias15 = getattr(epics.bias15,attr)/1000.\n        \n        # get platform bias \n        if self.area == 'BNMR':\n            platform = getattr(epics.nmr_bias,attr)\n        elif self.area == 'BNQR':\n            platform = getattr(epics.nqr_bias,attr)/1000.\n        else:\n            raise RuntimeError('Area not recognized')\n        \n        if get_error:\n            return np.sqrt(np.sum(np.square((beam,bias15,platform)))) # keV\n        else:\n            return beam-bias15-platform", "response": "Get the beam energy in kev based on typical biases itw or ite bias."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting pulse duration in seconds for pulsed measurements.", "response": "def get_pulse_s(self):\n        \"\"\"Get pulse duration in seconds, for pulsed measurements.\"\"\"\n        \n        try:\n            dwelltime = self.ppg.dwelltime.mean\n            beam_on = self.ppg.beam_on.mean\n        except AttributeError:\n            raise AttributeError(\"Missing logged ppg parameter: dwelltime \"+\\\n                    \"or beam_on\")\n        return dwelltime*beam_on/1000."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef chain_sub_regexes(phrase, *regex_sub_pairs):\r\n    '''\r\n    Allow for a series of regex substitutions to occur\r\n\r\n    chain_sub_regexes('test ok', (' ', '_'), ('k$', 'oo'))\r\n    # => 'test_ooo'\r\n    '''\r\n    for regex, substitution in regex_sub_pairs:\r\n        if isinstance(regex, basestring):\r\n            regex = re.compile(regex)\r\n        phrase = regex.sub(substitution, phrase)\r\n    return phrase", "response": "Given a phrase and a list of regex substitutions return a new phrase."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extract_endpoints(api_module):\n    if not hasattr(api_module, 'endpoints'):\n        raise ValueError((\"pale.extract_endpoints expected the passed in \"\n            \"api_module to have an `endpoints` attribute, but it didn't!\"))\n\n    endpoints = api_module.endpoints\n    if isinstance(endpoints, types.ModuleType):\n        classes = [v for (k,v) in inspect.getmembers(endpoints,\n                                                     inspect.isclass)]\n    elif isinstance(endpoints, (list, tuple)):\n        classes = endpoints\n    else:\n        raise ValueError(\"Endpoints is not a module or list type!\")\n\n    instances = []\n\n    for cls in classes:\n        if cls not in (Endpoint, PatchEndpoint, PutResourceEndpoint) and \\\n                Endpoint in inspect.getmro(cls):\n            source_code = inspect.getsource(cls)\n            if \"@requires_permission\" in source_code:\n                permission_match = re.search(r\"@requires_permission\\(\\[?[\\'\\\"]+(\\w+)[\\'\\\"]+\", source_code)\n                if permission_match != None:\n                    cls._requires_permission = permission_match.group(1)\n            instances.append(cls())\n    return instances", "response": "Return the endpoints from an API implementation module."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_resources(api_module):\n    endpoints = extract_endpoints(api_module)\n    resource_classes = [ e._returns.__class__ for e in endpoints ]\n\n    return list(set(resource_classes))", "response": "Return the resources from an API implementation module."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntemplates loader that loads templates from zipped modules.", "response": "def load_template_source(self, template_name, template_dirs=None):\n        \"\"\"Template loader that loads templates from zipped modules.\"\"\"\n        #Get every app's folder\n        log.error(\"Calling zip loader\")\n        for folder in app_template_dirs:\n            if \".zip/\" in folder.replace(\"\\\\\", \"/\"):\n                lib_file, relative_folder = get_zip_file_and_relative_path(folder)\n                log.error(lib_file, relative_folder)\n                try:\n                    z = zipfile.ZipFile(lib_file)\n                    log.error(relative_folder + template_name)\n                    template_path_in_zip = os.path.join(relative_folder, template_name).replace(\"\\\\\", \"/\")\n                    source = z.read(template_path_in_zip)\n                except (IOError, KeyError) as e:\n                    import traceback\n                    log.error(traceback.format_exc())\n                    try:\n                        z.close()\n                    except:\n                        pass\n                    continue\n                z.close()\n                # We found a template, so return the source.\n                template_path = \"%s:%s\" % (lib_file, template_path_in_zip)\n                return (source, template_path)\n\n        # If we reach here, the template couldn't be loaded\n        raise TemplateDoesNotExist(template_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noverloading emit function from the logger module.", "response": "def emit(self, record):\n        \"\"\"\n        Overloaded emit() function from the logger module.\n\n        The supplied log record is added to the log buffer and the\n        sigNewLog signal triggered.\n\n        .. note:: this method is always only called from the\n          ``logger`` module.\n        \"\"\"\n        self.log.append(record)\n\n        # Do not trigger the signal again if no one has fetched any\n        # data since it was last set.\n        if not self.waitForFetch:\n            self.waitForFetch = True\n            self.sigNewLog.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self, start=None, stop=None):\n\n        # Set defaults if no explicit indices were provided.\n        if not start:\n            start = 0\n        if not stop:\n            stop = len(self.log)\n\n        # Sanity check: indices must be valid.\n        if start < 0:\n            start = 0\n        if stop > len(self.log):\n            stop = len(self.log)\n\n        # Clear the fetch flag. It will be set again in the emit()\n        # method once new data arrives.\n        self.waitForFetch = False\n\n        # Return the specified range of log records.\n        return self.log[start:stop]", "response": "Fetch log records and return them as a list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bind_blueprint(pale_api_module, flask_blueprint):\n\n    if not isinstance(flask_blueprint, Blueprint):\n        raise TypeError((\"pale.flask_adapter.bind_blueprint expected the \"\n                         \"passed in flask_blueprint to be an instance of \"\n                         \"Blueprint, but it was an instance of %s instead.\")\n                        % (type(flask_blueprint),))\n\n    if not pale.is_pale_module(pale_api_module):\n        raise TypeError((\"pale.flask_adapter.bind_blueprint expected the \"\n                         \"passed in pale_api_module to be a module, and to \"\n                         \"have a _module_type defined to equal \"\n                         \"pale.ImplementationModule, but it was an instance of \"\n                         \"%s instead.\")\n                        % (type(pale_api_module),))\n\n    endpoints = pale.extract_endpoints(pale_api_module)\n\n    for endpoint in endpoints:\n        endpoint._set_response_class(RESPONSE_CLASS)\n        method = [endpoint._http_method]\n        name = endpoint._route_name\n        handler = endpoint._execute\n\n        flask_blueprint.add_url_rule(\n                endpoint._uri,\n                name,\n                view_func=ContextualizedHandler(handler),\n                methods=method)", "response": "Binds an implemented pale API module to a Flask Blueprint."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cookie_name_check(cookie_name):\n\t\tcookie_match = WHTTPCookie.cookie_name_non_compliance_re.match(cookie_name.encode('us-ascii'))\n\t\treturn len(cookie_name) > 0 and cookie_match is None", "response": "Check cookie name for validity. Return True if name is valid otherwise False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cookie_attr_value_check(attr_name, attr_value):\n\t\tattr_value.encode('us-ascii')\n\t\treturn WHTTPCookie.cookie_attr_value_compliance[attr_name].match(attr_value) is not None", "response": "Check cookie attribute value for validity. Return True if value is valid otherwise False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning cookie value. Cookie value can be updated, when new_value is not None. Cookie value couldn't be changed if cookie is in read-only mode (RuntimeError exception is raised). :param new_value: new value to set :return: str", "response": "def value(self, new_value=None):\n\t\t\"\"\" Return cookie value. Cookie value can be updated, when new_value is not None. Cookie value\n\t\tcouldn't be changed if cookie is in read-only mode (RuntimeError exception is raised).\n\n\t\t:param new_value: new value to set\n\t\t:return: str\n\t\t\"\"\"\n\t\tif new_value is not None:\n\t\t\tif self.__ro_flag:\n\t\t\t\traise RuntimeError('Read-only cookie changing attempt')\n\t\t\tself.__value = new_value\n\t\treturn self.__value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning suitable and valid attribute name. This method replaces dash char to underscore.", "response": "def __attr_name(self, name):\n\t\t\"\"\" Return suitable and valid attribute name. This method replaces dash char to underscore. If name\n\t\tis invalid ValueError exception is raised\n\n\t\t:param name: cookie attribute name\n\t\t:return: str\n\t\t\"\"\"\n\t\tif name not in self.cookie_attr_value_compliance.keys():\n\t\t\tsuggested_name = name.replace('_', '-').lower()\n\t\t\tif suggested_name not in self.cookie_attr_value_compliance.keys():\n\t\t\t\traise ValueError('Invalid attribute name is specified')\n\t\t\tname = suggested_name\n\t\treturn name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn attribute value. Attribute value can be updated with this method. In order to update attribute value attr_value must be set. Cookie attribute value couldn't be changed if cookie is in read-only mode (RuntimeError exception is raised). :param attr_name: target attribute name :param attr_value: new value to set :return: str", "response": "def attr(self, attr_name, attr_value=None):\n\t\t\"\"\" Return attribute value. Attribute value can be updated with this method. In order to update\n\t\tattribute value attr_value must be set. Cookie attribute value couldn't be changed if cookie is\n\t\tin read-only mode (RuntimeError exception is raised).\n\n\t\t:param attr_name: target attribute name\n\t\t:param attr_value: new value to set\n\t\t:return: str\n\t\t\"\"\"\n\t\tname = self.__attr_name(attr_name)\n\t\tif attr_value is not None:\n\t\t\tif WHTTPCookie.cookie_attr_value_check(name, attr_value) is not True:\n\t\t\t\traise ValueError('Unacceptable value passed')\n\t\t\tif self.__ro_flag:\n\t\t\t\traise RuntimeError('Read-only cookie changing attempt')\n\t\t\tself.__attrs[name] = attr_value\n\t\t\treturn attr_value\n\t\treturn self.__attrs[name]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the specified attribute from the cookie.", "response": "def remove_attr(self, attr_name):\n\t\t\"\"\" Remove cookie attribute. Cookie attribute couldn't be removed if cookie is in read-only mode\n\t\t(RuntimeError exception is raised).\n\n\t\t:param attr_name: name of attribute to remove\n\t\t:return: None\n\t\t\"\"\"\n\t\tif self.__ro_flag:\n\t\t\traise RuntimeError('Read-only cookie changing attempt')\n\t\tname = self.__attr_name(attr_name)\n\t\tif name in self.__attrs.keys():\n\t\t\tself.__attrs.pop(attr_name)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef copy(self):\n\t\tcopy_cookie = WHTTPCookie(self.__name, self.__value)\n\t\tcopy_cookie.__attrs = self.__attrs.copy()\n\t\treturn copy_cookie", "response": "Return a copy of this cookie."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a cookie to the cookie jar.", "response": "def add_cookie(self, cookie):\n\t\t\"\"\" Add new cookie (or replace if there is cookie with the same name already)\n\n\t\t:param cookie: cookie to add\n\t\t:return: None\n\t\t\"\"\"\n\t\tif self.__ro_flag:\n\t\t\traise RuntimeError('Read-only cookie-jar changing attempt')\n\t\tself.__cookies[cookie.name()] = cookie"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_cookie(self, cookie_name):\n\t\tif self.__ro_flag:\n\t\t\traise RuntimeError('Read-only cookie-jar changing attempt')\n\t\tif cookie_name in self.__cookies.keys():\n\t\t\tself.__cookies.pop(cookie_name)", "response": "Removes a cookie by its name"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ro(self):\n\t\tro_jar = WHTTPCookieJar()\n\t\tfor cookie in self.__cookies.values():\n\t\t\tro_jar.add_cookie(cookie.ro())\n\t\tro_jar.__ro_flag = True\n\t\treturn ro_jar", "response": "Return read - only copy of this cookie jar"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_simple_cookie(cls, simple_cookie):\n\t\tcookie_jar = WHTTPCookieJar()\n\t\tfor cookie_name in simple_cookie.keys():\n\t\t\tcookie_attrs = {}\n\t\t\tfor attr_name in WHTTPCookie.cookie_attr_value_compliance.keys():\n\t\t\t\tattr_value = simple_cookie[cookie_name][attr_name]\n\t\t\t\tif attr_value != '':\n\t\t\t\t\tcookie_attrs[attr_name] = attr_value\n\n\t\t\tcookie_jar.add_cookie(WHTTPCookie(\n\t\t\t\tcookie_name, simple_cookie[cookie_name].value, **cookie_attrs\n\t\t\t))\n\t\treturn cookie_jar", "response": "Create cookie jar from SimpleCookie object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate cookie jar from HTTP header text like Set - Cookie = value", "response": "def import_header_text(cls, cookie_text):\n\t\t\"\"\" Create cookie jar from HTTP Header text like 'Set-Cookie: cookie=value'\n\n\t\t:param cookie_text: http header code\n\t\t:return: WHTTPCookieJar\n\t\t\"\"\"\n\t\tsimple_cookie = SimpleCookie()\n\t\tsimple_cookie.load(cookie_text)\n\t\treturn cls.import_simple_cookie(simple_cookie)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if n is a prime number", "response": "def is_prime(n):\n    \"\"\"\n    Check if n is a prime number\n    \"\"\"\n    if n % 2 == 0 and n > 2:\n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scheme_specification(cls):\n\t\treturn WSchemeSpecification(\n\t\t\t'file',\n\t\t\tWURIComponentVerifier(WURI.Component.path, WURIComponentVerifier.Requirement.optional)\n\t\t)", "response": "returns a WSchemeSpecification object that can be used to create a URL scheme."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upload_file(self, file_name, file_obj, *args, **kwargs):\n\t\tprevious_path = self.session_path()\n\t\ttry:\n\t\t\tself.session_path(file_name)\n\t\t\twith open(self.full_path(), mode='wb') as f:\n\t\t\t\tchunk = file_obj.read(io.DEFAULT_BUFFER_SIZE)\n\t\t\t\twhile len(chunk) > 0:\n\t\t\t\t\tf.write(chunk)\n\t\t\t\t\tchunk = file_obj.read(io.DEFAULT_BUFFER_SIZE)\n\t\tfinally:\n\t\t\tself.session_path(previous_path)", "response": "method implementation\n\t. upload_file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef loadFile(self, fileName):\n\n        # Assign QFile object with the current name.\n        self.file = QtCore.QFile(fileName)\n        if self.file.exists():\n            self.qteText.append(open(fileName).read())\n        else:\n            msg = \"File <b>{}</b> does not exist\".format(self.qteAppletID())\n            self.qteLogger.info(msg)", "response": "Load the file and display it in the appletID."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisplay the startup screen of the Qtmacs application.", "response": "def displayStartupScreen(self):\n        \"\"\"\n        Display the Qtmacs logo (Max) together with the GPL.\n        \"\"\"\n        # Determine the path of the Qtmacs application because this is\n        # also where the image file is located.\n        path, _ = os.path.split(qtmacs.qtmacsmain.__file__)\n\n        # Load the image and insert it at the current position.\n        img = QtGui.QImage(path + '/misc/Max.png')\n        tc = self.qteText.textCursor()\n        tc.insertImage(img)\n        self.qteText.setTextCursor(tc)\n\n        # Display the GPL text.\n        gpl_text = open(path + '/misc/gpl.txt').readlines()\n        gpl_text = ''.join(gpl_text)\n        self.qteText.append('\\n\\n' + gpl_text)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _encode(self):\n        obj = {k: v for k, v in self.__dict__.items()\n               if not k.startswith('_') and type(v) in SAFE_TYPES}\n        obj.update({k: v._encode() for k, v in self.__dict__.items()\n                   if isinstance(v, Ent)})\n        return obj", "response": "Generate a recursive JSON representation of the ent."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(cls, data, promote=False):\n        t = type(data)\n\n        if t == cls:\n            # same class, create new copy\n            return cls({k: cls.load(v, promote)\n                        for k, v in data.__dict__.items()})\n\n        elif isinstance(data, cls):\n            # child class, always use directly\n            return data.copy()\n\n        elif isinstance(data, Ent):\n            # parent class, promote or preserve\n            if promote:\n                return cls({k: cls.load(v, promote)\n                            for k, v in data.__dict__.items()})\n            else:\n                return data.copy()\n\n        elif t not in SAFE_TYPES:\n            return None\n\n        elif t in (tuple, list, set):\n            return t(cls.load(i) for i in data)\n\n        elif t == dict:\n            return cls({k: cls.load(v) for k, v in data.items()})\n\n        else:\n            return data", "response": "Create a new Ent instance from an existing value."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new Ent from one or more existing Ents.", "response": "def merge(cls, *args, **kwargs):\n        \"\"\"Create a new Ent from one or more existing Ents.  Keys in the\n        later Ent objects will overwrite the keys of the previous Ents.\n        Later keys of different type than in earlier Ents will be bravely\n        ignored.\n\n        The following keyword arguments are recognized:\n\n        newkeys: boolean value to determine whether keys from later Ents\n        should be included if they do not exist in earlier Ents.\n\n        ignore: list of strings of key names that should not be overridden by\n        later Ent keys.\n\n        \"\"\"\n        newkeys = bool(kwargs.get('newkeys', False))\n        ignore = kwargs.get('ignore', list())\n\n        if len(args) < 1:\n            raise ValueError('no ents given to Ent.merge()')\n        elif not all(isinstance(s, Ent) for s in args):\n            raise ValueError('all positional arguments to Ent.merge() must '\n                             'be instances of Ent')\n\n        ent = args[0]\n        data = cls.load(ent)\n\n        for ent in args[1:]:\n            for key, value in ent.__dict__.items():\n                if key in ignore:\n                    continue\n\n                if key in data.__dict__:\n                    v1 = data.__dict__[key]\n                    if type(value) == type(v1):\n                        if isinstance(v1, Ent):\n                            data.__dict__[key] = cls.merge(v1, value, **kwargs)\n                        else:\n                            data.__dict__[key] = cls.load(value)\n\n                elif newkeys:\n                    data.__dict__[key] = value\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new Ent representing the differences in two or more Ents.", "response": "def diff(cls, *args, **kwargs):\n        \"\"\"Create a new Ent representing the differences in two or more\n        existing Ents.  Keys in the later Ents with values that differ\n        from the earlier Ents will be present in the final Ent with the\n        latest value seen for that key.  Later keys of different type than in\n        earlier Ents will be bravely ignored.\n\n        The following keywoard arguments are recognized:\n\n        newkeys: boolean value to determine whether keys from later Ents\n        should be included if they do not exist in earlier Ents.\n\n        ignore: list of strings of key names that will not be included.\n\n        \"\"\"\n        newkeys = bool(kwargs.get('newkeys', False))\n        ignore = kwargs.get('ignore', list())\n\n        if len(args) < 2:\n            raise ValueError('less than two ents given to Ent.diff()')\n        elif not all(isinstance(s, Ent) for s in args):\n            raise ValueError('all positional arguments to Ent.diff() must '\n                             'be instances of Ent')\n\n        s1 = args[0]\n        differences = Ent()\n\n        for s2 in args[1:]:\n            for key, value in s2.__dict__.items():\n                if key in ignore:\n                    continue\n\n                if key in s1.__dict__:\n                    v1 = s1.__dict__[key]\n                    if type(value) == type(v1):\n                        if isinstance(v1, Ent):\n                            delta = cls.diff(v1, value, **kwargs)\n                            if len(delta.__dict__):\n                                differences.__dict__[key] = delta\n                        elif v1 != value:\n                            differences.__dict__[key] = cls.load(value)\n\n                elif newkeys:\n                    differences.__dict__[key] = cls.load(value)\n\n            s1 = s2\n\n        return differences"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a set of all Ent subclasses recursively.", "response": "def subclasses(cls):\n        \"\"\"Return a set of all Ent subclasses, recursively.\"\"\"\n        seen = set()\n        queue = set([cls])\n\n        while queue:\n            c = queue.pop()\n            seen.add(c)\n\n            sc = c.__subclasses__()\n            for c in sc:\n                if c not in seen:\n                    queue.add(c)\n\n        seen.remove(cls)\n        return seen"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deprecated(func):\n    '''This is a decorator which can be used to mark functions\n    as deprecated. It will result in a warning being emitted\n    when the function is used.\n    \n    https://wiki.python.org/moin/PythonDecoratorLibrary#Generating_Deprecation_Warnings\n    '''\n    def new_func(*args, **kwargs):\n        warn(\"Call to deprecated function {}.\".format(func.__name__),\n                      category=DeprecationWarning)\n        return func(*args, **kwargs)\n    new_func.__name__ = func.__name__\n    new_func.__doc__ = func.__doc__\n    new_func.__dict__.update(func.__dict__)\n    return new_func", "response": "A function decorator which marks functions\n    as deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the base URL for the given resource.", "response": "def base_url(self):\n        \"\"\"Protocol + hostname\"\"\"\n        if self.location in self.known_locations:\n            return self.known_locations[self.location]\n        elif '.' in self.location or self.location == 'localhost':\n            return 'https://' + self.location\n        else:\n            return 'https://' + self.location + API_HOST_SUFFIX"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nauthenticate with a key_id and secret.", "response": "def authenticate(self, key_id=None, secret=None, allow_agent=False):\n        \"\"\"\n        :param key_id: SmartDC identifier for the ssh key\n        :type key_id: :py:class:`basestring`\n        \n        :param secret: path to private rsa key\n        :type secret: :py:class:`basestring`\n        \n        :param allow_agent: whether or not to try ssh-agent\n        :type allow_agent: :py:class:`bool`\n        \n        If no `key_id` or `secret` were entered on initialization, or there is\n        a need to change the existing authentication credentials, one may \n        authenticate with a `key_id` and `secret`.\n        \"\"\"\n        if key_id and secret:\n            self.auth = HTTPSignatureAuth(key_id=key_id, secret=secret, \n                allow_agent=allow_agent)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a programmatically - generated API summary using HTTP verbs and URL templates", "response": "def api(self):\n        \"\"\"\n        .. warning:: Deprecated: will be withdrawn since JPC doesn't appear \n           to return the nice documentation object any more\n        \n        ::\n        \n            GET /\n        \n        :Returns: a programmatically-generated API summary using HTTP verbs \n            and URL templates\n        :rtype: :py:class:`dict`\n        \"\"\"\n        if self.verbose:\n            print(\"%s\\t%s\\t%s\" % \n                (datetime.now().isoformat(), 'GET', self.base_url), \n                file=self.verbose)\n        resp = requests.request('GET', self.base_url, verify=self.verify)\n        if 400 <= resp.status_code < 499:\n            resp.raise_for_status()\n        if resp.content:\n            return json.loads(resp.content)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef account(self):\n        j, _ = self.request('GET', '')\n        if 'login' in j and self.login == 'my':\n            self.login = j['login']\n        return j", "response": "Returns basic information about the authenticated account"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the account info in the current node.", "response": "def update_account(self, email=None, company_name=None, first_name=None, \n            last_name=None, address=None, postal_code=None, city=None,\n            state=None, country=None, phone=None):\n        \"\"\"\n        ::\n        \n            POST /:login\n        \n        :param email: Email address\n        :type email: :py:class:`basestring`\n        \n        :param company_name: Company name\n        :type company_name: :py:class:`basestring`\n        \n        :param first_name: First name\n        :type first_name: :py:class:`basestring`\n        \n        :param last_name: Last name\n        :type last_name: :py:class:`basestring`\n        \n        :param address: Address\n        :type address: :py:class:`basestring`\n        \n        :param postal_code: Postal code\n        :type postal_code: :py:class:`basestring`\n        \n        :param city: City\n        :type city: :py:class:`basestring`\n        \n        :param state: State\n        :type state: :py:class:`basestring`\n        \n        :param country: Country\n        :type country: :py:class:`basestring`\n        \n        :param phone: Phone\n        :type phone: :py:class:`basestring`\n        \n        :Returns: a dictionary with updated account info\n        :rtype: :py:class:`dict`\n        \"\"\"\n        params = {}\n        if email:\n            params['email'] = email\n        if company_name:\n            params['companyName'] = company_name\n        if first_name:\n            params['firstName'] = first_name\n        if last_name:\n            params['lastName'] = last_name\n        if address:\n            params['address'] = address\n        if postal_code:\n            params['postalCode'] = postal_code\n        if city:\n            params['city'] = city\n        if state:\n            params['state'] = state\n        if country:\n            params['country'] = country\n        if phone:\n            params['phone'] = phone\n        j, _ = self.request('POST', '', params=params)\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the details of a key record for a given key id", "response": "def key(self, key_id):\n        \"\"\"\n        ::\n        \n            GET /:login/keys/:key\n        \n        :param key_id: identifier for an individual key record for the account\n        :type key_id: :py:class:`basestring`\n        \n        :returns: details of the key\n        :rtype: :py:class:`dict`\n        \"\"\"\n        j, _ = self.request('GET', '/keys/' + str(key_id))\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a public key to the account s credentials.", "response": "def add_key(self, key_id, key):\n        \"\"\"\n        ::\n        \n            POST /:login/keys\n        \n        :param key_id: label for the new key\n        :type key_id: :py:class:`basestring`\n        \n        :param key: the full SSH RSA public key\n        :type key: :py:class:`str`\n        \n        Uploads a public key to be added to the account's credentials.\n        \"\"\"\n        data = {'name': str(key_id), 'key': str(key)}\n        j, _ = self.request('POST', '/keys', data=data)\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_key(self, key_id):\n        j, r = self.request('DELETE', '/keys/' + str(key_id))\n        r.raise_for_status()\n        return j", "response": "This method deletes an SSH key from the server identified by key_id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef datacenters(self):\n        j, _ = self.request('GET', '/datacenters')\n        self.known_locations.update(j)\n        return j", "response": "This method returns a dictionary of all datacenters that this cloud is aware of."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new object with the given location key.", "response": "def datacenter(self, name):\n        \"\"\"\n        :param name: location key\n        :type name: :py:class:`basestring`\n        \n        :Returns: a new DataCenter object\n        \n        This method treats the 'name' argument as a location key (on the \n        `known_locations` attribute dict) or FQDN, and keeps existing \n        authentication and other configuration from this object.\n        \"\"\"\n        # The base form of this, as below, simply sets up a redirect. \n        # j, _ = self.request('GET', 'datacenters/' + str(name))\n        if name not in self.known_locations and '.' not in name:\n            self.datacenters()\n        dc = DataCenter(location=name, headers=self.default_headers, \n                login=self.login, verbose=self.verbose, \n                verify=self.verify, known_locations=self.known_locations)\n        dc.auth = self.auth\n        return dc"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the packages of the specified resource.", "response": "def packages(self, name=None, memory=None, disk=None, swap=None,\n                version=None, vcpus=None, group=None):\n        \"\"\"\n        ::\n        \n            GET /:login/packages\n        \n        :param name: the label associated with the resource package\n        :type name: :py:class:`basestring`\n        \n        :param memory: amount of RAM (in MiB) that the package provisions\n        :type memory: :py:class:`int`\n        \n        :param disk: amount of disk storage (in MiB) the package provisions\n        :type disk: :py:class:`int`\n        \n        :param swap: amount of swap (in MiB) the package provisions\n        :type swap: :py:class:`int`\n        \n        :param version: the version identifier associated with the package\n        :type version: :py:class:`basestring`\n        \n        :param vcpus: the number of virtual CPUs provisioned with the package\n        :type vcpus: :py:class:`int`\n        \n        :param group: the group to which the package belongs\n        :type group: :py:class:`basestring`\n        \n        :Returns: packages (machine \"sizes\", with resource types and values) \n            available in this datacenter.\n        :rtype: :py:class:`list` of :py:class:`dict`\\s\n        \"\"\"\n        params = {}\n        if name:\n            params['name'] = name\n        if memory:\n            params['memory'] = memory\n        if disk:\n            params['disk'] = disk\n        if swap:\n            params['swap'] = swap\n        if version:\n            params['version'] = version\n        if vcpus:\n            params['vcpus'] = vcpus\n        if group:\n            params['group'] = group\n        j, _ = self.request('GET', '/packages', params=params)\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef default_package(self):\n        packages = [pk for pk in self.packages() \n                        if pk.get('default') == 'true']\n        if packages:\n            return packages[0]\n        else:\n            return None", "response": "Returns the default package for this datacenter if it has been defined."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef package(self, name):\n        if isinstance(name, dict):\n            name = name.get('id', name.get('name'))\n        j, _ = self.request('GET', '/packages/' + str(name))\n        return j", "response": "Gets the resource values for a package by name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef num_machines(self, machine_type=None, dataset=None, state=None, \n            memory=None, tombstone=None, tags=None):\n        \"\"\"\n        ::\n        \n            HEAD /:login/machines\n        \n        Counts the number of machines total, or that match the predicates as\n        with :py:meth:`machines`.\n        \n        :param machine_type: virtualmachine or smartmachine\n        :type machine_type: :py:class:`basestring`\n        \n        :param dataset: unique ID or URN for a dataset\n        :type dataset: :py:class:`basestring` or :py:class:`dict`\n        \n        :param state: current running state\n        :type state: :py:class:`basestring`\n        \n        :param memory: current size of the RAM deployed for the machine (Mb)\n        :type memory: :py:class:`int`\n        \n        :param tombstone: include machines destroyed in the last N minutes\n        :type tombstone: :py:class:`int`\n        \n        :param tags: keys and values to query in the machines' tag space\n        :type tags: :py:class:`dict`\n        \n        :Returns: a count of the number of machines (matching the predicates) \n            owned by the user at this datacenter\n        :rtype: :py:class:`int`\n        \"\"\"\n        _, r = self.request('HEAD', '/machines')\n        num = r.headers.get('x-resource-count', 0)\n        return int(num)", "response": "Count the number of machines in this datacenter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef raw_machine_data(self, machine_id, credentials=False):\n        params = {}\n        if isinstance(machine_id, dict):\n            machine_id = machine_id['id']\n        if credentials:\n            params['credentials'] = True\n        j, _ = self.request('GET', '/machines/' + str(machine_id), \n                params=params)\n        return j", "response": "Get the raw data for a single machine."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_machine(self, name=None, package=None, dataset=None,\n            metadata=None, tags=None, boot_script=None, credentials=False,\n            image=None, networks=None):\n        \"\"\"\n        ::\n        \n            POST /:login/machines\n        \n        Provision a machine in the current \n        :py:class:`smartdc.datacenter.DataCenter`, returning an instantiated \n        :py:class:`smartdc.machine.Machine` object. All of the parameter \n        values are optional, as they are assigned default values by the \n        datacenter's API itself.\n        \n        :param name: a human-readable label for the machine\n        :type name: :py:class:`basestring`\n        \n        :param package: cluster of resource values identified by name\n        :type package: :py:class:`basestring` or :py:class:`dict`\n        \n        :param image: an identifier for the base operating system image\n            (formerly a ``dataset``)\n        :type image: :py:class:`basestring` or :py:class:`dict`\n        \n        :param dataset: base operating system image identified by a globally \n            unique ID or URN (deprecated)\n        :type dataset: :py:class:`basestring` or :py:class:`dict`\n        \n        :param metadata: keys & values with arbitrary supplementary \n            details for the machine, accessible from the machine itself\n        :type metadata: :py:class:`dict`\n        \n        :param tags: keys & values with arbitrary supplementary \n            identifying information for filtering when querying for machines\n        :type tags: :py:class:`dict`\n\n        :param networks: list of networks where this machine will belong to\n        :type networks: :py:class:`list`\n        \n        :param boot_script: path to a file to upload for execution on boot\n        :type boot_script: :py:class:`basestring` as file path\n        \n        :rtype: :py:class:`smartdc.machine.Machine`\n        \n        If `package`, `image`, or `dataset` are passed a :py:class:`dict` containing a \n        `name` key (in the case of `package`) or an `id` key (in the case of\n        `image` or `dataset`), it passes the corresponding value. The server API \n        appears to resolve incomplete or ambiguous dataset URNs with the \n        highest version number.\n        \"\"\"\n        params = {}\n        if name:\n            assert re.match(r'[a-zA-Z0-9]([a-zA-Z0-9\\-\\.]*[a-zA-Z0-9])?$',\n                name), \"Illegal name\"\n            params['name'] = name\n        if package:\n            if isinstance(package, dict):\n                package = package['name']\n            params['package'] = package\n        if image:\n            if isinstance(image, dict):\n                image = image['id']\n            params['image'] = image\n        if dataset and not image:\n            if isinstance(dataset, dict):\n                dataset = dataset.get('id', dataset['urn'])\n            params['dataset'] = dataset\n        if metadata:\n            for k, v in metadata.items():\n                params['metadata.' + str(k)] = v\n        if tags:\n            for k, v in tags.items():\n                params['tag.' + str(k)] = v\n        if boot_script:\n            with open(boot_script) as f:\n                params['metadata.user-script'] = f.read()\n        if networks:\n            if isinstance(networks, list):\n                params['networks'] = networks\n            elif isinstance(networks, basestring):\n                params['networks'] = [networks]\n        j, r = self.request('POST', 'machines', data=params)\n        if r.status_code >= 400:\n            print(j, file=sys.stderr)\n            r.raise_for_status()\n        return Machine(datacenter=self, data=j)", "response": "Create a new machine in the current active resource store."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a single machine from the given ID.", "response": "def machine(self, machine_id, credentials=False):\n        \"\"\"\n        ::\n        \n            GET /:login/machines/:id\n        \n        :param machine_id: unique identifier for a machine to be found in the \n            datacenter\n        :type machine_id: :py:class:`basestring`\n        \n        :rtype: :py:class:`smartdc.machine.Machine`\n        \"\"\"\n        if isinstance(machine_id, dict):\n            machine_id = machine_id['id']\n        elif isinstance(machine_id, Machine):\n            machine_id = machine_id.id\n        return Machine(datacenter=self, machine_id=machine_id, \n                credentials=credentials)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef networks(self, search=None, fields=('name,')):\n        \n        j, _ = self.request('GET', '/networks')\n        if search:\n            return list(search_dicts(j, search, fields))\n        else:\n            return j", "response": "GET / : login / networks\n            GET / : login / networks\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef network(self, identifier):\n        \n        if isinstance(identifier, dict):\n            identifier = identifier.get('id')\n        j, _ = self.request('GET', '/networks/' + str(identifier))\n        return j", "response": "Gets the characteristics of the specified network."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef images(self, name=None, os=None, version=None, \n                public=None, state=None, owner=None, type=None):\n        \"\"\"\n        ::\n        \n            GET /:login/images\n        \n        :param name: match on the listed name\n        :type name: :py:class:`basestring`\n        \n        :param os: match on the selected os\n        :type os: :py:class:`basestring`\n        \n        :param version: match on the selected version\n        :type version: :py:class:`basestring`\n        \n        :param public: match on the visibility\n        :type public: :py:class:`basestring` (\"public\"/\"private\")\n        \n        :param state: Filter on image state. By default only active images are shown. Use \"all\" to list all images.\n        :type state: :py:class:`basestring`\n        \n        :param owner: match on the owner UUID\n        :type owner: :py:class:`basestring`\n        \n        :param machinetype: match on the selected type (e.g., \"smartmachine\")\n        :type machinetype: :py:class:`basestring`\n        \n        :Returns: available machine images in this datacenter\n        :rtype: :py:class:`list` of :py:class:`dict`\\s\n        \"\"\"\n        \n        params = {}\n        if name:\n            params['name'] = name\n        if os:\n            params['os'] = os\n        if version:\n            params['version'] = version\n        if public:\n            params['public'] = public\n        if state:\n            params['state'] = state\n        if owner:\n            params['owner'] = owner\n        if machinetype:\n            params['type'] = machinetype\n        j, _ = self.request('GET', '/images', params=params)\n        \n        return j", "response": "This method returns a list of available machine images in this datacenter."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding file names list of modules to exclude from exception handling.", "response": "def _build_exclusion_list(exclude):\n    \"\"\"Build file names list of modules to exclude from exception handling.\"\"\"\n    mod_files = []\n    if exclude:\n        for mod in exclude:\n            mdir = None\n            mod_file = None\n            for token in mod.split(\".\"):\n                try:\n                    mfile, mdir, _ = imp.find_module(token, mdir and [mdir])\n                    if mfile:\n                        mod_file = mfile.name\n                        mfile.close()\n                except ImportError:\n                    msg = \"Source for module {mod_name} could not be found\"\n                    raise ValueError(msg.format(mod_name=mod))\n            if mod_file:\n                mod_files.append(mod_file.replace(\".pyc\", \".py\"))\n    return mod_files"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _invalid_frame(fobj):\n    fin = fobj.f_code.co_filename\n    invalid_module = any([fin.endswith(item) for item in _INVALID_MODULES_LIST])\n    return invalid_module or (not os.path.isfile(fin))", "response": "Select valid stack frame to process."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _merge_cdicts(self, clut, exdict, separator):\n    if not self._full_cname:\n        return\n    # Find all callables that are not in self exceptions dictionary\n    # and create new tokens for them\n    repl_dict = {}\n    for key, value in _sorted_keys_items(clut):\n        otoken = self._clut.get(key, None)\n        if not otoken:\n            otoken = str(len(self._clut))\n            self._clut[key] = otoken\n        repl_dict[value] = otoken\n    # Update other dictionaries to the mapping to self\n    # exceptions dictionary\n    for fdict in exdict.values():\n        for entry in fdict.values():\n            olist = []\n            for item in entry[\"function\"]:\n                if item is None:\n                    # Callable name is None when callable is\n                    # part of exclude list\n                    olist.append(None)\n                else:\n                    itokens = item.split(separator)\n                    itokens = [repl_dict.get(itoken) for itoken in itokens]\n                    olist.append(separator.join(itokens))\n            entry[\"function\"] = olist", "response": "Merge callable look - up tables from two objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmerges callable look - up tables from two objects.", "response": "def _merge_ex_dicts(sexdict, oexdict):\n    \"\"\"Merge callable look-up tables from two objects.\"\"\"\n    # pylint: disable=R0101\n    for okey, ovalue in oexdict.items():\n        # Keys in other dictionary are callable paths or\n        # callables ids depending on the full_cname argument\n        # of the handler\n        if okey in sexdict:\n            svalue = sexdict[okey]\n            # Each callable dictionary entry is itself a dictionary where the\n            # key is (exception type, exception message) and the value is a\n            # dictionary with keys 'function' (a list of callable paths to\n            # the function), 'raised' (list of booleans indicating whether the\n            # exception though each callable path was raised or not) and name\n            for fkey, fvalue in ovalue.items():\n                if fkey not in svalue:\n                    # The other dictionary has a callable path not present in\n                    # the self dictionary, add it unmodified\n                    sexdict[okey][fkey] = fvalue\n                else:\n                    # The other dictionary has a callable and exception\n                    # present in the self dictionary, have to check whether\n                    # the callable path is the same (in which case update\n                    # raise flag) or not (in which case add to 'function' and\n                    # 'raise' keys\n                    iobj = zip(fvalue[\"function\"], fvalue[\"raised\"])\n                    for func, raised in iobj:\n                        if func not in sexdict[okey][fkey][\"function\"]:\n                            sexdict[okey][fkey][\"function\"].append(func)\n                            sexdict[okey][fkey][\"raised\"].append(raised)\n                        else:\n                            idx = sexdict[okey][fkey][\"function\"].index(func)\n                            sraised = sexdict[okey][fkey][\"raised\"][idx]\n                            if sraised or raised:\n                                sexdict[okey][fkey][\"raised\"][idx] = True\n        else:\n            sexdict[okey] = ovalue"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn dictionary items sorted by key.", "response": "def _sorted_keys_items(dobj):\n    \"\"\"Return dictionary items sorted by key.\"\"\"\n    keys = sorted(dobj.keys())\n    for key in keys:\n        yield key, dobj[key]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addai(argname, condition=None):\n    # pylint: disable=C0123\n    if not isinstance(argname, str):\n        raise RuntimeError(\"Argument `argname` is not valid\")\n    if (condition is not None) and (type(condition) != bool):\n        raise RuntimeError(\"Argument `condition` is not valid\")\n    obj = _ExObj(RuntimeError, \"Argument `{0}` is not valid\".format(argname), condition)\n    return obj.craise", "response": "r Add an AI exception in the global exception handler."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_or_create_exh_obj(full_cname=False, exclude=None, callables_fname=None):\n    if not hasattr(__builtin__, \"_EXH\"):\n        set_exh_obj(\n            ExHandle(\n                full_cname=full_cname, exclude=exclude, callables_fname=callables_fname\n            )\n        )\n    return get_exh_obj()", "response": "r Returns global exception handler if set otherwise create a new one and return it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef craise(self, condition, edata=None):\n        self._exh.raise_exception_if(\n            self._exname, condition, edata, _keys=self._ex_data\n        )", "response": "r\"\"\"\n        Raise exception conditionally.\n\n        :param condition: Flag that indicates whether the exception is\n                          raised *(True)* or not *(False)*\n        :type  condition: boolean\n\n        :param edata: Replacement values for fields in the exception message\n                      (see :py:meth:`pexdoc.ExHandle.add_exception` for how\n                      to define fields). Each dictionary entry can only have\n                      these two keys:\n\n                      * **field** *(string)* -- Field name\n\n                      * **value** *(any)* -- Field value, to be converted into\n                        a string with the `format\n                        <https://docs.python.org/2/library/stdtypes.html#\n                        str.format>`_ string method\n\n                      If None no field replacement is done\n        :type  edata: dictionary, iterable of dictionaries or None\n\n        :raises:\n         * RuntimeError (Argument \\\\`condition\\\\` is not valid)\n\n         * RuntimeError (Argument \\\\`edata\\\\` is not valid)\n\n         * RuntimeError (Argument \\\\`exname\\\\` is not valid)\n\n         * RuntimeError (Field *[field_name]* not in exception message)\n\n         * ValueError (Exception name *[name]* not found')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _flatten_ex_dict(self):\n        odict = {}\n        for _, fdict in self._ex_dict.items():\n            for (extype, exmsg), value in fdict.items():\n                key = value[\"name\"]\n                odict[key] = copy.deepcopy(value)\n                del odict[key][\"name\"]\n                odict[key][\"type\"] = extype\n                odict[key][\"msg\"] = exmsg\n        return odict", "response": "Flatten structure of exceptions dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _format_msg(self, msg, edata):\n        edata = edata if isinstance(edata, list) else [edata]\n        for fdict in edata:\n            if \"*[{token}]*\".format(token=fdict[\"field\"]) not in msg:\n                raise RuntimeError(\n                    \"Field {token} not in exception message\".format(\n                        token=fdict[\"field\"]\n                    )\n                )\n            msg = msg.replace(\n                \"*[{token}]*\".format(token=fdict[\"field\"]), \"{value}\"\n            ).format(value=fdict[\"value\"])\n        return msg", "response": "Substitute parameters in exception message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_callable_full_name(self, fob, fin, uobj):\n        # Check if object is a class property\n        name = self._property_search(fob)\n        if name:\n            del fob, fin, uobj\n            return name\n        if os.path.isfile(fin):\n            lineno = fob.f_lineno\n            ret = self._callables_obj.get_callable_from_line(fin, lineno)\n            del fob, fin, uobj, name, lineno\n            return ret\n        # Code executed in doctests does not have an actual callable object\n        # exec-based callables do not have a valid file name\n        fname = uobj and _get_func_code(uobj).co_filename\n        if (not fname) or (fname and (not os.path.isfile(fname))):\n            del fob, fin, uobj, name, fname\n            return \"dynamic\"\n        code_id = (\n            inspect.getfile(uobj).replace(\".pyc\", \"py\"),\n            inspect.getsourcelines(uobj)[1],\n        )\n        self._callables_obj.trace([code_id[0]])\n        ret = self._callables_obj.reverse_callables_db[code_id]\n        del fob, fin, uobj, name, fname, code_id\n        return ret", "response": "Get full path of callable."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of dictionaries suitable to be used with ptrie module module.", "response": "def _get_exceptions_db(self):\n        \"\"\"Return a list of dictionaries suitable to be used with ptrie module.\"\"\"\n        template = \"{extype} ({exmsg}){raised}\"\n        if not self._full_cname:\n            # When full callable name is not used the calling path is\n            # irrelevant and there is no function associated with an\n            # exception\n            ret = []\n            for _, fdict in self._ex_dict.items():\n                for key in fdict.keys():\n                    ret.append(\n                        {\n                            \"name\": fdict[key][\"name\"],\n                            \"data\": template.format(\n                                extype=_ex_type_str(key[0]),\n                                exmsg=key[1],\n                                raised=\"*\" if fdict[key][\"raised\"][0] else \"\",\n                            ),\n                        }\n                    )\n            return ret\n        # When full callable name is used, all calling paths are saved\n        ret = []\n        for fdict in self._ex_dict.values():\n            for key in fdict.keys():\n                for func_name in fdict[key][\"function\"]:\n                    rindex = fdict[key][\"function\"].index(func_name)\n                    raised = fdict[key][\"raised\"][rindex]\n                    ret.append(\n                        {\n                            \"name\": self.decode_call(func_name),\n                            \"data\": template.format(\n                                extype=_ex_type_str(key[0]),\n                                exmsg=key[1],\n                                raised=\"*\" if raised else \"\",\n                            ),\n                        }\n                    )\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning hierarchical function name.", "response": "def _get_ex_data(self):\n        \"\"\"Return hierarchical function name.\"\"\"\n        func_id, func_name = self._get_callable_path()\n        if self._full_cname:\n            func_name = self.encode_call(func_name)\n        return func_id, func_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _property_search(self, fobj):\n        # Get class object\n        scontext = fobj.f_locals.get(\"self\", None)\n        class_obj = scontext.__class__ if scontext is not None else None\n        if not class_obj:\n            del fobj, scontext, class_obj\n            return None\n        # Get class properties objects\n        class_props = [\n            (member_name, member_obj)\n            for member_name, member_obj in inspect.getmembers(class_obj)\n            if isinstance(member_obj, property)\n        ]\n        if not class_props:\n            del fobj, scontext, class_obj\n            return None\n        class_file = inspect.getfile(class_obj).replace(\".pyc\", \".py\")\n        class_name = self._callables_obj.get_callable_from_line(\n            class_file, inspect.getsourcelines(class_obj)[1]\n        )\n        # Get properties actions\n        prop_actions_dicts = {}\n        for prop_name, prop_obj in class_props:\n            prop_dict = {\"fdel\": None, \"fget\": None, \"fset\": None}\n            for action in prop_dict:\n                action_obj = getattr(prop_obj, action)\n                if action_obj:\n                    # Unwrap action object. Contracts match the wrapped\n                    # code object while exceptions registered in the\n                    # body of the function/method which has decorators\n                    # match the unwrapped object\n                    prev_func_obj, next_func_obj = (\n                        action_obj,\n                        getattr(action_obj, \"__wrapped__\", None),\n                    )\n                    while next_func_obj:\n                        prev_func_obj, next_func_obj = (\n                            next_func_obj,\n                            getattr(next_func_obj, \"__wrapped__\", None),\n                        )\n                    prop_dict[action] = [\n                        id(_get_func_code(action_obj)),\n                        id(_get_func_code(prev_func_obj)),\n                    ]\n            prop_actions_dicts[prop_name] = prop_dict\n        # Create properties directory\n        func_id = id(fobj.f_code)\n        desc_dict = {\"fget\": \"getter\", \"fset\": \"setter\", \"fdel\": \"deleter\"}\n        for prop_name, prop_actions_dict in prop_actions_dicts.items():\n            for action_name, action_id_list in prop_actions_dict.items():\n                if action_id_list and (func_id in action_id_list):\n                    prop_name = \".\".join([class_name, prop_name])\n                    del fobj, scontext, class_obj, class_props\n                    return \"{prop_name}({prop_action})\".format(\n                        prop_name=prop_name, prop_action=desc_dict[action_name]\n                    )\n        return None", "response": "Search for a class property in a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _raise_exception(self, eobj, edata=None):\n        _, _, tbobj = sys.exc_info()\n        if edata:\n            emsg = self._format_msg(eobj[\"msg\"], edata)\n            _rwtb(eobj[\"type\"], emsg, tbobj)\n        else:\n            _rwtb(eobj[\"type\"], eobj[\"msg\"], tbobj)", "response": "Raise exception by name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating edata argument of raise_exception_if method.", "response": "def _validate_edata(self, edata):\n        \"\"\"Validate edata argument of raise_exception_if method.\"\"\"\n        # pylint: disable=R0916\n        if edata is None:\n            return True\n        if not (isinstance(edata, dict) or _isiterable(edata)):\n            return False\n        edata = [edata] if isinstance(edata, dict) else edata\n        for edict in edata:\n            if (not isinstance(edict, dict)) or (\n                isinstance(edict, dict)\n                and (\n                    (\"field\" not in edict)\n                    or (\"field\" in edict and (not isinstance(edict[\"field\"], str)))\n                    or (\"value\" not in edict)\n                )\n            ):\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode a callable name into a list of callable names.", "response": "def decode_call(self, call):\n        \"\"\"\n        Replace callable tokens with callable names.\n\n        :param call: Encoded callable  name\n        :type  call: string\n\n        :rtype: string\n        \"\"\"\n        # Callable name is None when callable is part of exclude list\n        if call is None:\n            return None\n        itokens = call.split(self._callables_separator)\n        odict = {}\n        for key, value in self._clut.items():\n            if value in itokens:\n                odict[itokens[itokens.index(value)]] = key\n        return self._callables_separator.join([odict[itoken] for itoken in itokens])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode_call(self, call):\n        # Callable name is None when callable is part of exclude list\n        if call is None:\n            return None\n        itokens = call.split(self._callables_separator)\n        otokens = []\n        for itoken in itokens:\n            otoken = self._clut.get(itoken, None)\n            if not otoken:\n                otoken = str(len(self._clut))\n                self._clut[itoken] = otoken\n            otokens.append(otoken)\n        return self._callables_separator.join(otokens)", "response": "Encodes a callable name with tokens to reduce object memory footprint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd names to all of the Endpoint s Arguments.", "response": "def _fix_up_fields(cls):\n        \"\"\"Add names to all of the Endpoint's Arguments.\n\n        This method will get called on class declaration because of\n        Endpoint's metaclass.  The functionality is based on Google's NDB\n        implementation.\"\"\"\n        cls._arguments = dict()\n        if cls.__module__ == __name__: # skip the classes in this file\n            return\n        for name in set(dir(cls)):\n            attr = getattr(cls, name, None)\n            if isinstance(attr, BaseArgument):\n                if name.startswith('_'):\n                    raise TypeError(\"Endpoint argument %s cannot begin with \"\n                            \"an underscore, as these attributes are reserved \"\n                            \"for instance variables of the endpoint object, \"\n                            \"rather than for arguments to your HTTP Endpoint.\"\n                            % name)\n                attr._fix_up(cls, name)\n                cls._arguments[attr.name] = attr"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _execute(self, request, **kwargs):\n        try:\n            self._create_context(request)\n            self._authenticate()\n\n            context = get_current_context()\n\n            self._parse_args()\n\n            if hasattr(self, '_before_handlers') and \\\n                    isinstance(self._before_handlers, (list, tuple)):\n                for handler in self._before_handlers:\n                    handler(context)\n\n            context.handler_result = self._handle(context)\n\n            if hasattr(self, '_after_handlers') and \\\n                    isinstance(self._after_handlers, (list, tuple)):\n                for handler in self._after_handlers:\n                    handler(context)\n\n            self._render()\n            response = context.response\n            # After calling ._render(), the response is ready to go, so we\n            # shouldn't need to handle any other exceptions beyond this point.\n        except AuthenticationError as e:\n            if hasattr(e, 'message') and e.message is not None:\n                message = e.message\n            else:\n                message = \"You don't have permission to do that.\"\n            err = APIError.Forbidden(message)\n            response = self._response_class(*err.response)\n            response.headers[\"Content-Type\"] = 'application/json'\n        except ArgumentError as e:\n            err = APIError.UnprocessableEntity(e.message)\n            response = self._response_class(*err.response)\n            response.headers[\"Content-Type\"] = 'application/json'\n        except APIError as e:\n            response = self._response_class(*e.response)\n            response.headers[\"Content-Type\"] = 'application/json'\n        except PaleRaisedResponse as r:\n            response = self._response_class(*r.response)\n            response.headers[\"Content-Type\"] = 'application/json'\n        except Exception as e:\n            logging.exception(\"Failed to handle Pale Endpoint %s: %r\", self.__class__.__name__,\n                e)\n            err = APIError.Exception(repr(e))\n            response = self._response_class(*err.response)\n            response.headers[\"Content-Type\"] = 'application/json'\n\n        allow_cors = getattr(self, \"_allow_cors\", None)\n        if allow_cors is True:\n            response.headers['Access-Control-Allow-Origin'] = '*'\n        elif isinstance(allow_cors, basestring):\n            response.headers['Access-Control-Allow-Origin'] = allow_cors\n\n        context.response = response\n\n        try:\n            if hasattr(self, '_after_response_handlers') and \\\n                    isinstance(self._after_response_handlers, (list, tuple)):\n                for handler in self._after_response_handlers:\n                    handler(context, response)\n        except Exception as e:\n            logging.exception(\n                \"Failed to process _after_response_handlers for Endpoint %s\",\n                self.__class__.__name__)\n            raise\n\n        return response", "response": "The main execute method for the endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_handler_result(self, result):\n        if isinstance(result, (list, tuple)):\n            payload = result[0]\n            list_result = list(result)\n        else:\n            payload = result\n            list_result = [\"\"]\n        return payload, list_result", "response": "Parses the item returned by the handler implementation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmove a list element to a new index while preserving order.", "response": "def order_preserving_single_index_shift(arr, index, new_index):\n    \"\"\"Moves a list element to a new index while preserving order.\n\n    Parameters\n    ---------\n    arr : list\n        The list in which to shift an element.\n    index : int\n        The index of the element to shift.\n    new_index : int\n        The index to which to shift the element.\n\n    Returns\n    -------\n    list\n        The list with the element shifted.\n\n    Example\n    -------\n    >>> arr = ['a', 'b', 'c', 'd']\n    >>> order_preserving_single_index_shift(arr, 2, 0)\n    ['c', 'a', 'b', 'd']\n    >>> order_preserving_single_index_shift(arr, 2, 3)\n    ['a', 'b', 'd', 'c']\n    \"\"\"\n    if new_index == 0:\n        return [arr[index]] + arr[0:index] + arr[index+1:]\n    if new_index == len(arr) - 1:\n        return arr[0:index] + arr[index+1:] + [arr[index]]\n    if index < new_index:\n        return arr[0:index] + arr[index+1:new_index+1] + [arr[index]] + arr[\n            new_index+1:]\n    if new_index <= index:\n        return arr[0:new_index] + [arr[index]] + arr[new_index:index] + arr[\n            index+1:]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmove a list element to a new index while preserving order.", "response": "def order_preserving_single_element_shift(arr, value, new_index):\n    \"\"\"Moves a list element to a new index while preserving order.\n\n    Parameters\n    ---------\n    arr : list\n        The list in which to shift an element.\n    value : object\n        The value of the element to shift.\n    new_index : int\n        The index to which to shift the element.\n\n    Returns\n    -------\n    list\n        The list with the element shifted.\n\n    Example\n    -------\n    >>> arr = ['a', 'b', 'c', 'd']\n    >>> order_preserving_single_element_shift(['a', 'b', 'c', 'd'], 'c', 0)\n    ['c', 'a', 'b', 'd']\n    \"\"\"\n    return order_preserving_single_index_shift(\n        arr=arr, index=arr.index(value), new_index=new_index)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_hashed_signature(self, url):\n        data = \"%s%s\" % (url, self.association_id)\n        if self.session_id:\n            data = \"%s%s\" % (data, self.session_id)\n        data_b = bytearray(data, 'utf-8')\n        secret_key = base64.b64decode(self.secret_key)\n        secret_b = bytearray(secret_key)\n\n        hashed = hmac.new(secret_b, data_b, sha1).digest()\n        return base64.b64encode(hashed).decode(\"utf-8\")", "response": "Return the hashed signature for the given URL."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking initial request to initialize session and get session id necessary to construct all future requests.", "response": "def request_session(self):\n        \"\"\"\n        Performs initial request to initialize session and get session id\n        necessary to construct all future requests.\n        :return: Session ID to be placed in header of all other requests.\n        \"\"\"\n        concierge_request_header = self.construct_concierge_header(\n            url=\"http://membersuite.com/contracts/IConciergeAPIService/WhoAmI\")\n\n        result = self.client.service.WhoAmI(\n            _soapheaders=[concierge_request_header])\n\n        self.session_id = get_session_id(result=result)\n\n        if not self.session_id:\n            raise MembersuiteLoginError(\n                result[\"body\"][\"WhoAmIResult\"][\"Errors\"])\n\n        return self.session_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing the Concierge Request Header lxml object to be used as the _soapheaders argument for WSDL methods.", "response": "def construct_concierge_header(self, url):\n        \"\"\"\n        Constructs the Concierge Request Header lxml object to be used as the\n        '_soapheaders' argument for WSDL methods.\n        \"\"\"\n        concierge_request_header = (\n            etree.Element(\n                etree.QName(XHTML_NAMESPACE, \"ConciergeRequestHeader\"),\n                nsmap={'sch': XHTML_NAMESPACE}))\n\n        if self.session_id:\n            session = (\n                etree.SubElement(concierge_request_header,\n                                 etree.QName(XHTML_NAMESPACE, \"SessionId\")))\n            session.text = self.session_id\n\n        access_key = (\n            etree.SubElement(concierge_request_header,\n                             etree.QName(XHTML_NAMESPACE, \"AccessKeyId\")))\n        access_key.text = self.access_key\n\n        association_id = (etree.SubElement(concierge_request_header,\n                                           etree.QName(XHTML_NAMESPACE,\n                                                       \"AssociationId\")))\n        association_id.text = self.association_id\n\n        signature = (\n            etree.SubElement(concierge_request_header,\n                             etree.QName(XHTML_NAMESPACE, \"Signature\")))\n        signature.text = self.get_hashed_signature(url=url)\n\n        return concierge_request_header"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scheme_specification(cls):\n\t\treturn WSchemeSpecification(\n\t\t\tcls.scheme_name(),\n\n\t\t\tWURIComponentVerifier(WURI.Component.username, WURIComponentVerifier.Requirement.optional),\n\t\t\tWURIComponentVerifier(WURI.Component.password, WURIComponentVerifier.Requirement.optional),\n\t\t\tWURIComponentVerifier(WURI.Component.hostname, WURIComponentVerifier.Requirement.required),\n\t\t\tWURIComponentVerifier(WURI.Component.port, WURIComponentVerifier.Requirement.optional),\n\t\t\tWURIComponentVerifier(WURI.Component.path, WURIComponentVerifier.Requirement.optional),\n\t\t\tWURIQueryVerifier(\n\t\t\t\tWURIComponentVerifier.Requirement.optional,\n\t\t\t\tWStrictURIQuery.ParameterSpecification(\n\t\t\t\t\t'remote_path', nullable=False, multiple=False, optional=False\n\t\t\t\t),\n\t\t\t\textra_parameters=False\n\t\t\t)\n\t\t)", "response": "returns a new instance of the class WSchemeSpecification"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef change_directory(self, path, *args, **kwargs):\n\t\tclient = self.dav_client()\n\t\tprevious_path = self.session_path()\n\t\ttry:\n\t\t\tif client.is_dir(self.session_path(path)) is False:\n\t\t\t\traise ValueError('Unable to change current working directory to non-directory entry')\n\t\texcept Exception:\n\t\t\tself.session_path(previous_path)\n\t\t\traise", "response": "method implementation\n\t self. session_path = path"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_directory(self, *args, **kwargs):\n\t\treturn tuple(self.dav_client().list(self.session_path()))", "response": "method implementation for list_directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_directory(self, directory_name, *args, **kwargs):\n\t\tclient = self.dav_client()\n\t\tremote_path = self.join_path(self.session_path(), directory_name)\n\n\t\tif client.is_dir(remote_path) is False:\n\t\t\traise ValueError('Unable to remove non-directory entry')\n\t\tclient.clean(remote_path)", "response": "method implementation\n\t. remove_directory"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_file(self, file_name, *args, **kwargs):\n\t\tclient = self.dav_client()\n\t\tremote_path = self.join_path(self.session_path(), file_name)\n\t\tif client.is_dir(remote_path) is True:\n\t\t\traise ValueError('Unable to remove non-file entry')\n\t\tclient.clean(remote_path)", "response": "method implementation\n\t. remove_file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwalks nested list - like elements as though they were sequentially available", "response": "def recursive_iter(enumerables):\r\n    '''\r\n    Walks nested list-like elements as though they were sequentially available\r\n\r\n    recursive_iter([[1,2], 3])\r\n    # => 1, 2, 3\r\n    '''\r\n    if not is_collection(enumerables) or isinstance(enumerables, (basestring, dict)):\r\n        yield enumerables\r\n    else:\r\n        for elem in enumerables:\r\n            for sub_elem in recursive_iter(elem):\r\n                yield sub_elem"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef degenerate(enumerable):\r\n    '''\r\n    Converts generators to lists\r\n\r\n    degenerate(xrange(2))\r\n    # => [0, 1]\r\n    '''\r\n    if (isinstance(enumerable, xrange) or\r\n        inspect.isgeneratorfunction(enumerable) or\r\n        inspect.isgenerator(enumerable)):\r\n        return list(enumerable)\r\n    return enumerable", "response": "Converts generator functions to lists"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge_dicts(*dicts, **copy_check):\r\n    '''\r\n    Combines dictionaries into a single dictionary. If the 'copy' keyword is passed\r\n    then the first dictionary is copied before update.\r\n\r\n    merge_dicts({'a': 1, 'c': 1}, {'a': 2, 'b': 1})\r\n    # => {'a': 2, 'b': 1, 'c': 1}\r\n    '''\r\n    merged = {}\r\n    if not dicts:\r\n        return merged\r\n    for index, merge_dict in enumerate(dicts):\r\n        if index == 0 and not copy_check.get('copy'):\r\n            merged = merge_dict\r\n        else:\r\n            merged.update(merge_dict)\r\n    return merged", "response": "Merges multiple dictionaries into a single dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef batch(enumerable, batch_size):\r\n    '''\r\n    Breaks enumerable argument into batch size enumerable pieces. The last chunk can\r\n    be of any length up to batch_size.\r\n\r\n    batch(xrange(5), 3)\r\n    # => [0, 1, 2], [3, 4]\r\n    '''\r\n    batch_size = max(int(batch_size), 1)\r\n    try:\r\n        enumerable.__getitem__\r\n        total_size = len(enumerable)\r\n    except (TypeError, AttributeError):\r\n        enumerable = list(enumerable)\r\n        total_size = len(enumerable)\r\n    if total_size == 0:\r\n        yield tuple()\r\n    try:\r\n        for batch_index in xrange(0, total_size, batch_size):\r\n            yield enumerable[batch_index:min(batch_index + batch_size, total_size)]\r\n    except TypeError:\r\n        # Fall back on islice, though it's not as efficient the way we're using it\r\n        for batch_start in xrange(0, total_size, batch_size):\r\n            yield tuple(islice(enumerable, batch_start, min(batch_start + batch_size, total_size)))", "response": "Yields the first batch of size 5 pieces of the given enumerable."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of all age groups in the archive", "response": "def group(self):\n        \"\"\"\n        :rtype: list\n        \"\"\"\n        lowerbound = self.lowerbound\n        age_group_list = []\n        for age_group in self.et.findall(\"group\"):\n            upperbound = age_group.attrib[\"upperbound\"]\n            try:\n                poppercent = age_group.attrib[\"poppercent\"]\n            except KeyError:\n                poppercent = None\n            age_group_list.append({\"lowerbound\": lowerbound,\n                                   \"upperbound\": upperbound,\n                                   \"poppercent\": poppercent})\n            lowerbound = upperbound\n        return age_group_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of all continuous EIR and GVI measures in the section containing the set of continuous EIR and GVI measures.", "response": "def continuous(self):\n        \"\"\"\n        List of measures in <continuous> section\n        Example: [\"simulated EIR\", \"GVI coverage\"]\n        :rtype: list\n        \"\"\"\n        list_of_measures = []\n        if self.et.find(\"continuous\") is None:\n            return list_of_measures\n        return self._get_measures(self.et.find(\"continuous\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef SurveyOptions(self):\n        list_of_measures = []\n        if self.et.find(\"SurveyOptions\") is None:\n            return list_of_measures\n        return self._get_measures(self.et.find(\"SurveyOptions\"))", "response": "Returns a list of measures in <SurveyOpions > section containing the names of the survey options."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detectionLimit(self):\n        surveys_elem = self.et.find(\"surveys\")\n        if surveys_elem is None:\n            return None\n\n        try:\n            detectionLimit = float(surveys_elem.attrib[\"detectionLimit\"])\n        except KeyError:\n            detectionLimit = None\n        return detectionLimit", "response": "Returns the detection limit for parasitaemia\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef surveys(self):\n        survey_time_list = list()\n        # Extract surveyTimes from /scenario/monitoring/surveys section\n        # Using root element instead of xpath to avoid problems with namespaces\n        # (root tag was <scenario> prior to schema 32, and then it was switched to <om:scenario>)\n        try:\n            for item in self.et.find(\"surveys\").findall(\"surveyTime\"):\n                # Converting to float first to allow values like 730.0\n                survey_time_list.append(int(item.text))\n        except AttributeError:\n            return None\n        return survey_time_list", "response": "Returns the list of timesteps when survey measures have been captured\n        None if xml document is mailformed\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_measures(self, et):\n        list_of_measures = []\n        for tag in et.findall(\"option\"):\n            if tag.attrib.get(\"value\", \"true\") == \"true\":\n                list_of_measures.append(tag.attrib[\"name\"])\n        return list_of_measures", "response": "Get a list of measures in continuous or survey options section"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _replace_measures(self, et, list_of_measures):\n        for measure in et.findall(\"option\"):\n            et.remove(measure)\n\n        for measure_name in list_of_measures:\n            tag = Element(\"option\")\n            tag.attrib[\"name\"] = measure_name\n            tag.attrib[\"value\"] = \"true\"\n            et.append(tag)", "response": "Replace the measure names in the XML element et with the list of measures."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_current_directory():\n    settings_directory=project_path+'/.dry'\n    settings_file=settings_directory+'/config.py'\n    if os.path.isdir(settings_directory):\n\t# already initialized\n\tprint(\"directory already initialized.\")\n\treturn\n    # init\n    os.makedirs(settings_directory)\n    f = open(settings_file,'w')\n    print(sample_config_file, file=f)\n    f.close()", "response": "Initialize and create dry config file inside current directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef options_string_builder(option_mapping, args):\n    options_string = \"\"\n    for option, flag in option_mapping.items():\n        if option in args:\n            options_string += str(\" %s %s\" % (flag, str(args[option])))\n    return options_string", "response": "Return arguments for CLI invocation of kal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild a string for CLI invocation of kal for band scan.", "response": "def build_kal_scan_band_string(kal_bin, band, args):\n    \"\"\"Return string for CLI invocation of kal, for band scan.\"\"\"\n    option_mapping = {\"gain\": \"-g\",\n                      \"device\": \"-d\",\n                      \"error\": \"-e\"}\n    if not sanity.scan_band_is_valid(band):\n        err_txt = \"Unsupported band designation: %\" % band\n        raise ValueError(err_txt)\n    base_string = \"%s -v -s %s\" % (kal_bin, band)\n    base_string += options_string_builder(option_mapping, args)\n    return(base_string)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_kal_scan_channel_string(kal_bin, channel, args):\n    option_mapping = {\"gain\": \"-g\",\n                      \"device\": \"-d\",\n                      \"error\": \"-e\"}\n    base_string = \"%s -v -c %s\" % (kal_bin, channel)\n    base_string += options_string_builder(option_mapping, args)\n    return(base_string)", "response": "Build a string for CLI invocation of kal for channel scan."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef herz_me(val):\n    result = 0\n    if val.endswith(\"MHz\"):\n        stripped = val.replace(\"MHz\", \"\")\n        strip_fl = float(stripped)\n        result = strip_fl * 1000000\n    elif val.endswith(\"kHz\"):\n        stripped = val.replace(\"kHz\", \"\")\n        strip_fl = float(stripped)\n        result = strip_fl * 1000\n    elif val.endswith(\"Hz\"):\n        stripped = val.replace(\"Hz\", \"\")\n        result = float(stripped)\n    return(result)", "response": "Return integer value for Hz translated from ( MHz | kHz |Hz."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns integer for frequency.", "response": "def determine_final_freq(base, direction, modifier):\n    \"\"\"Return integer for frequency.\"\"\"\n    result = 0\n    if direction == \"+\":\n        result = base + modifier\n    elif direction == \"-\":\n        result = base - modifier\n    return(result)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_eng(num_in):\n    x = decimal.Decimal(str(num_in))\n    eng_not = x.normalize().to_eng_string()\n    return(eng_not)", "response": "Return number in engineering notation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef determine_device(kal_out):\n    device = \"\"\n    while device == \"\":\n        for line in kal_out.splitlines():\n            if \"Using device \" in line:\n                device = str(line.split(' ', 2)[-1])\n        if device == \"\":\n            device = None\n    return device", "response": "Extract and return device from scan results."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts value from kal output.", "response": "def extract_value_from_output(canary, split_offset, kal_out):\n    \"\"\"Return value parsed from output.\n\n    Args:\n        canary(str): This string must exist in the target line.\n        split_offset(int): Split offset for target value in string.\n        kal_out(int): Output from kal.\n    \"\"\"\n    retval = \"\"\n    while retval == \"\":\n        for line in kal_out.splitlines():\n            if canary in line:\n                retval = str(line.split()[split_offset])\n        if retval == \"\":\n            retval = None\n    return retval"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef determine_chan_detect_threshold(kal_out):\n    channel_detect_threshold = \"\"\n    while channel_detect_threshold == \"\":\n        for line in kal_out.splitlines():\n            if \"channel detect threshold: \" in line:\n                channel_detect_threshold = str(line.split()[-1])\n        if channel_detect_threshold == \"\":\n            print(\"Unable to parse sample rate\")\n            channel_detect_threshold = None\n    return channel_detect_threshold", "response": "Return channel detect threshold from kal output."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef determine_band_channel(kal_out):\n    band = \"\"\n    channel = \"\"\n    tgt_freq = \"\"\n    while band == \"\":\n        for line in kal_out.splitlines():\n            if \"Using \" in line and \" channel \" in line:\n                band = str(line.split()[1])\n                channel = str(line.split()[3])\n                tgt_freq = str(line.split()[4]).replace(\n                    \"(\", \"\").replace(\")\", \"\")\n        if band == \"\":\n            band = None\n    return(band, channel, tgt_freq)", "response": "Return band channel target frequency from kal output."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_kal_scan(kal_out):\n    kal_data = []\n    scan_band = determine_scan_band(kal_out)\n    scan_gain = determine_scan_gain(kal_out)\n    scan_device = determine_device(kal_out)\n    sample_rate = determine_sample_rate(kal_out)\n    chan_detect_threshold = determine_chan_detect_threshold(kal_out)\n    for line in kal_out.splitlines():\n        if \"chan:\" in line:\n            p_line = line.split(' ')\n            chan = str(p_line[1])\n            modifier = str(p_line[3])\n            power = str(p_line[5])\n            mod_raw = str(p_line[4]).replace(')\\tpower:', '')\n            base_raw = str((p_line[2]).replace('(', ''))\n            mod_freq = herz_me(mod_raw)\n            base_freq = herz_me(base_raw)\n            final_freq = to_eng(determine_final_freq(base_freq, modifier,\n                                                     mod_freq))\n            kal_run = {\"channel\": chan,\n                       \"base_freq\": base_freq,\n                       \"mod_freq\": mod_freq,\n                       \"modifier\": modifier,\n                       \"final_freq\": final_freq,\n                       \"power\": power,\n                       \"band\": scan_band,\n                       \"gain\": scan_gain,\n                       \"device\": scan_device,\n                       \"sample_rate\": sample_rate,\n                       \"channel_detect_threshold\": chan_detect_threshold}\n            kal_data.append(kal_run.copy())\n    return kal_data", "response": "Parse kal band scan output."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses kal channel scan output.", "response": "def parse_kal_channel(kal_out):\n    \"\"\"Parse kal channel scan output.\"\"\"\n    scan_band, scan_channel, tgt_freq = determine_band_channel(kal_out)\n    kal_data = {\"device\": determine_device(kal_out),\n                \"sample_rate\": determine_sample_rate(kal_out),\n                \"gain\": determine_scan_gain(kal_out),\n                \"band\": scan_band,\n                \"channel\": scan_channel,\n                \"frequency\": tgt_freq,\n                \"avg_absolute_error\": determine_avg_absolute_error(kal_out),\n                \"measurements\" : get_measurements_from_kal_scan(kal_out),\n                \"raw_scan_result\": kal_out}\n    return kal_data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_measurements_from_kal_scan(kal_out):\n    result = []\n    for line in kal_out.splitlines():\n        if \"offset \" in line:\n            p_line = line.split(' ')\n            result.append(p_line[-1])\n    return result", "response": "Return a list of all measurements from kalibrate channel scan."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef doc_dict(self):\n        doc = {\n            'type': self.value_type,\n            'description': self.description,\n            'extended_description': self.details\n        }\n        return doc", "response": "Generate the documentation for this field."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef capability(self, cap_name):\n\t\tif cap_name in self.__class_capabilities__:\n\t\t\tfunction_name = self.__class_capabilities__[cap_name]\n\t\t\treturn getattr(self, function_name)", "response": "Return a bounded method by its name\n\t\t"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_capabilities(self, *cap_names):\n\t\tfor name in cap_names:\n\t\t\tif name not in self.__class_capabilities__:\n\t\t\t\treturn False\n\t\treturn True", "response": "Check if class has all of the specified capabilities."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding state errors to the errors object", "response": "def add_state_errors(self, errors):\n        \"\"\"\n        Add state errors\n        Accepts a list of errors (or a single Error) coming from validators\n        applied to entity as whole that are used for entity state validation\n        The errors will exist on a  __state__ property of the errors object.\n\n        :param errors: list or Error, list of entity state validation errors\n        :return: shiftschema.result.Result\n        \"\"\"\n        if not self.errors:\n            self.errors = dict()\n        if '__state__' not in self.errors:\n            self.errors['__state__'] = []\n\n        if type(errors) is not list:\n            errors = [errors]\n        for error in errors:\n            if not isinstance(error, Error):\n                err = 'Error must be of type {}'\n                raise x.InvalidErrorType(err.format(Error))\n\n            self.errors['__state__'].append(error)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd one or several errors to properties.", "response": "def add_errors(self, property_name, errors):\n        \"\"\"\n        Add one or several errors to properties.\n        :param property_name: str, property name\n        :param errors: list or Error, error object(s)\n        :return: shiftschema.result.Result\n        \"\"\"\n        if type(errors) is not list:\n            errors = [errors]\n        for error in errors:\n            if not isinstance(error, Error):\n                err = 'Error must be of type {}'\n                raise x.InvalidErrorType(err.format(Error))\n\n        if property_name in self.errors:\n            self.errors[property_name].extend(errors)\n        else:\n            self.errors[property_name] = errors\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_entity_errors(\n        self,\n        property_name,\n        direct_errors=None,\n        schema_errors=None\n    ):\n        \"\"\"\n        Attach nested entity errors\n        Accepts a list errors coming from validators attached directly,\n        or a dict of errors produced by a nested schema.\n\n        :param property_name: str, property name\n        :param direct_errors: list, errors from validators attached directly\n        :param schema_errors: dict, errors from nested schema\n        :return: shiftschema.result.Result\n        \"\"\"\n        if direct_errors is None and schema_errors is None:\n            return self\n\n        # direct errors\n        if direct_errors is not None:\n            if property_name not in self.errors:\n                self.errors[property_name] = dict()\n\n            if 'direct' not in self.errors[property_name]:\n                self.errors[property_name]['direct'] = []\n\n            if type(direct_errors) is not list:\n                direct_errors = [direct_errors]\n\n            for error in direct_errors:\n                if not isinstance(error, Error):\n                    err = 'Error must be of type {}'\n                    raise x.InvalidErrorType(err.format(Error))\n                self.errors[property_name]['direct'].append(error)\n\n        # schema errors\n        if schema_errors is not None:\n            if isinstance(schema_errors, Result):\n                schema_errors = schema_errors.errors\n\n            if not schema_errors:\n                return self\n\n            if property_name not in self.errors:\n                self.errors[property_name] = dict()\n\n            if 'schema' not in self.errors[property_name]:\n                self.errors[property_name]['schema'] = schema_errors\n            else:\n                self.errors[property_name]['schema'] = self.merge_errors(\n                    self.errors[property_name]['schema'],\n                    schema_errors\n                )\n\n        return self", "response": "Adds nested entity errors to the errors dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds collection errors to the error dictionary.", "response": "def add_collection_errors(\n        self,\n        property_name,\n        direct_errors=None,\n        collection_errors=None\n    ):\n        \"\"\"\n        Add collection errors\n        Accepts a list errors coming from validators attached directly,\n        or a list of schema results for each item in the collection.\n\n        :param property_name: str, property name\n        :param direct_errors: list, errors from validators attached directly\n        :param collection_errors: list of results for collection members\n        :return: shiftschema.result.Result\n        \"\"\"\n        if direct_errors is None and collection_errors is None:\n            return self\n\n        # direct errors\n        if direct_errors is not None:\n            if type(direct_errors) is not list:\n                direct_errors = [direct_errors]\n            if property_name not in self.errors:\n                self.errors[property_name] = dict()\n            if 'direct' not in self.errors[property_name]:\n                self.errors[property_name]['direct'] = []\n            for error in direct_errors:\n                if not isinstance(error, Error):\n                    err = 'Error must be of type {}'\n                    raise x.InvalidErrorType(err.format(Error))\n                self.errors[property_name]['direct'].append(error)\n\n        # collection errors\n        if collection_errors:\n            enum = enumerate(collection_errors)\n            errors_dict = {i: e for i, e in enum if not bool(e)}\n            if not errors_dict:\n                return self\n\n            if property_name not in self.errors:\n                self.errors[property_name] = dict()\n            if 'collection' not in self.errors[property_name]:\n                self.errors[property_name]['collection'] = errors_dict\n            else:\n                local = self.errors[property_name]['collection']\n                remote = errors_dict\n                for index, result in remote.items():\n                    if index not in local:\n                        self.errors[property_name]['collection'][index] = result\n                    else:\n                        merged = self.merge_errors(\n                            local[index].errors,\n                            remote[index].errors\n                        )\n                        self.errors[property_name]['collection'][index] = merged\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmerging errors from local to remote errors into local errors.", "response": "def merge_errors(self, errors_local, errors_remote):\n        \"\"\"\n        Merge errors\n        Recursively traverses error graph to merge remote errors into local\n        errors to return a new joined graph.\n\n        :param errors_local: dict, local errors, will be updated\n        :param errors_remote: dict, remote errors, provides updates\n        :return: dict\n        \"\"\"\n        for prop in errors_remote:\n\n            # create if doesn't exist\n            if prop not in errors_local:\n                errors_local[prop] = errors_remote[prop]\n                continue\n\n            local = errors_local[prop]\n            local = local.errors if isinstance(local, Result) else local\n            remote = errors_remote[prop]\n            remote = remote.errors if isinstance(remote, Result) else remote\n\n            # check compatibility\n            if not isinstance(local, type(remote)):\n                msg = 'Type mismatch on property [{}] when merging errors. '\n                msg += 'Unable to merge [{}] into [{}]'\n                raise x.UnableToMergeResultsType(msg.format(\n                    prop,\n                    type(errors_remote[prop]),\n                    type(self.errors[prop])\n                ))\n\n            mismatch = 'Unable to merge nested entity errors with nested '\n            mismatch += 'collection errors on property [{}]'\n            if 'schema' in local and 'collection' in remote:\n                raise x.UnableToMergeResultsType(mismatch.format(prop))\n            if 'collection' in local and 'schema' in remote:\n                raise x.UnableToMergeResultsType(mismatch.format(prop))\n\n            # merge simple & state\n            if type(remote) is list:\n                errors_local[prop].extend(remote)\n                continue\n\n            # merge direct errors on nested entities and collection\n            if 'direct' in remote and 'direct' in local:\n                errors_local[prop]['direct'].extend(remote['direct'])\n\n            # merge nested schema errors\n            if 'schema' in remote and 'schema' in local:\n                errors_local[prop]['schema'] = self.merge_errors(\n                    errors_local[prop]['schema'],\n                    remote['schema']\n                )\n\n            # merge nested collections errors\n            if 'collection' in remote and 'collection' in local:\n                for index, result in remote['collection'].items():\n                    if index not in local['collection']:\n                        errors_local[prop]['collection'][index] = result\n                    else:\n                        merged = self.merge_errors(\n                            errors_local[prop]['collection'][index].errors,\n                            errors_remote[prop]['collection'][index].errors,\n                        )\n                        errors_local[prop]['collection'][index] = merged\n\n        # and return\n        return errors_local"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmerging another validation result graph into itself", "response": "def merge(self, another):\n        \"\"\" Merges another validation result graph into itself\"\"\"\n        if isinstance(another, Result):\n            another = another.errors\n        self.errors = self.merge_errors(self.errors, another)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_messages(self, locale=None):\n        if locale is None:\n            locale = self.locale\n\n        if self.translator:\n            def translate(error):\n                return self.translator.translate(error, locale)\n        else:\n            def translate(error):\n                return error\n\n        errors = deepcopy(self.errors)\n        errors = self._translate_errors(errors, translate)\n        return errors", "response": "Get a dictionary of translated messages"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_error(self, error, args=None):\n        if type(args) is dict:\n            return error.format(**args)\n        if type(args) is list or type(args) is tuple:\n            return error.format(*args)\n\n        return error", "response": "Format error with positional or named arguments"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfilter the value and returns the result.", "response": "def filter(self, value, model=None, context=None):\n        \"\"\"\n        Filter\n        Performs value filtering and returns filtered result.\n\n        :param value:               input value\n        :param model:               parent model being validated\n        :param context:             object, filtering context\n        :return:                    filtered value\n        \"\"\"\n        value = str(value)\n        linker = Linker(**self.linkify_params)\n        return linker.linkify(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a full URL from just path.", "response": "def make_url(self, path, api_root=u'/v2/'):\n        \"\"\"Gets a full URL from just path.\"\"\"\n        return urljoin(urljoin(self.url, api_root), path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a URL for a key.", "response": "def make_key_url(self, key):\n        \"\"\"Gets a URL for a key.\"\"\"\n        if type(key) is bytes:\n            key = key.decode('utf-8')\n        buf = io.StringIO()\n        buf.write(u'keys')\n        if not key.startswith(u'/'):\n            buf.write(u'/')\n        buf.write(key)\n        return self.make_url(buf.getvalue())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef erred():\n        exc_type, exc, tb = sys.exc_info()\n        if issubclass(exc_type, socket.timeout):\n            raise TimedOut\n        elif issubclass(exc_type, requests.ConnectionError):\n            internal_exc = exc.args[0]\n            if isinstance(internal_exc, ReadTimeoutError):\n                raise TimedOut\n            else:\n                raise ConnectionError(exc)\n        elif issubclass(exc_type, requests.RequestException):\n            raise EtcException(exc)\n        reraise(exc_type, exc, tb)", "response": "Wraps errors in except clause."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrequest to get a node by the given key.", "response": "def get(self, key, recursive=False, sorted=False, quorum=False,\n            wait=False, wait_index=None, timeout=None):\n        \"\"\"Requests to get a node by the given key.\"\"\"\n        url = self.make_key_url(key)\n        params = self.build_args({\n            'recursive': (bool, recursive or None),\n            'sorted': (bool, sorted or None),\n            'quorum': (bool, quorum or None),\n            'wait': (bool, wait or None),\n            'waitIndex': (int, wait_index),\n        })\n        if timeout is None:\n            # Try again when :exc:`TimedOut` thrown.\n            while True:\n                try:\n                    try:\n                        res = self.session.get(url, params=params)\n                    except:\n                        self.erred()\n                except (TimedOut, ChunkedEncodingError):\n                    continue\n                else:\n                    break\n        else:\n            try:\n                res = self.session.get(url, params=params, timeout=timeout)\n            except ChunkedEncodingError:\n                raise TimedOut\n            except:\n                self.erred()\n        return self.wrap_response(res)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set(self, key, value=None, dir=False, refresh=False, ttl=None,\n            prev_value=None, prev_index=None, prev_exist=None, timeout=None):\n        \"\"\"Requests to create an ordered node into a node by the given key.\"\"\"\n        url = self.make_key_url(key)\n        data = self.build_args({\n            'value': (six.text_type, value),\n            'dir': (bool, dir or None),\n            'refresh': (bool, refresh or None),\n            'ttl': (int, ttl),\n            'prevValue': (six.text_type, prev_value),\n            'prevIndex': (int, prev_index),\n            'prevExist': (bool, prev_exist),\n        })\n        try:\n            res = self.session.put(url, data=data, timeout=timeout)\n        except:\n            self.erred()\n        return self.wrap_response(res)", "response": "Requests to create an ordered node into a node by the given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrequests to create an ordered node into a node by the given key.", "response": "def append(self, key, value=None, dir=False, ttl=None, timeout=None):\n        \"\"\"Requests to create an ordered node into a node by the given key.\"\"\"\n        url = self.make_key_url(key)\n        data = self.build_args({\n            'value': (six.text_type, value),\n            'dir': (bool, dir or None),\n            'ttl': (int, ttl),\n        })\n        try:\n            res = self.session.post(url, data=data, timeout=timeout)\n        except:\n            self.erred()\n        return self.wrap_response(res)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequests to delete a node by the given key.", "response": "def delete(self, key, dir=False, recursive=False,\n               prev_value=None, prev_index=None, timeout=None):\n        \"\"\"Requests to delete a node by the given key.\"\"\"\n        url = self.make_key_url(key)\n        params = self.build_args({\n            'dir': (bool, dir or None),\n            'recursive': (bool, recursive or None),\n            'prevValue': (six.text_type, prev_value),\n            'prevIndex': (int, prev_index),\n        })\n        try:\n            res = self.session.delete(url, params=params, timeout=timeout)\n        except:\n            self.erred()\n        return self.wrap_response(res)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs username into the MemberSuite Portal.", "response": "def login_to_portal(username, password, client, retries=2, delay=0):\n    \"\"\"Log `username` into the MemberSuite Portal.\n\n    Returns a PortalUser object if successful, raises\n    LoginToPortalError if not.\n\n    Will retry logging in if a GeneralException occurs, up to `retries`.\n    Will pause `delay` seconds between retries.\n    \"\"\"\n    if not client.session_id:\n        client.request_session()\n\n    concierge_request_header = client.construct_concierge_header(\n        url=(\"http://membersuite.com/contracts/IConciergeAPIService/\"\n             \"LoginToPortal\"))\n\n    attempts = 0\n    while attempts < retries:\n        if attempts:\n            time.sleep(delay)\n\n        result = client.client.service.LoginToPortal(\n            _soapheaders=[concierge_request_header],\n            portalUserName=username,\n            portalPassword=password)\n\n        login_to_portal_result = result[\"body\"][\"LoginToPortalResult\"]\n\n        if login_to_portal_result[\"Success\"]:\n            portal_user = login_to_portal_result[\"ResultValue\"][\"PortalUser\"]\n\n            session_id = get_session_id(result=result)\n\n            return PortalUser(membersuite_object_data=portal_user,\n                              session_id=session_id)\n        else:\n            attempts += 1\n            try:\n                error_code = login_to_portal_result[\n                    \"Errors\"][\"ConciergeError\"][0][\"Code\"]\n            except IndexError:  # Not a ConciergeError\n                continue\n            else:\n                if attempts < retries and error_code == \"GeneralException\":\n                    continue\n\n    raise LoginToPortalError(result=result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef logout(client):\n    if not client.session_id:\n        client.request_session()\n\n    concierge_request_header = client.construct_concierge_header(\n        url=(\"http://membersuite.com/contracts/IConciergeAPIService/\"\n             \"Logout\"))\n\n    logout_result = client.client.service.Logout(\n        _soapheaders=[concierge_request_header])\n\n    result = logout_result[\"body\"][\"LogoutResult\"]\n\n    if result[\"SessionID\"] is None:  # Success!\n        client.session_id = None\n    else:  # Failure . . .\n        raise LogoutError(result=result)", "response": "Log out the currently logged - in user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_user_for_membersuite_entity(membersuite_entity):\n    user = None\n    user_created = False\n\n    # First, try to match on username.\n    user_username = generate_username(membersuite_entity)\n    try:\n        user = User.objects.get(username=user_username)\n    except User.DoesNotExist:\n        pass\n\n    # Next, try to match on email address.\n    if not user:\n        try:\n            user = User.objects.filter(\n                email=membersuite_entity.email_address)[0]\n        except IndexError:\n            pass\n\n    # No match? Create one.\n    if not user:\n        user = User.objects.create(\n            username=user_username,\n            email=membersuite_entity.email_address,\n            first_name=membersuite_entity.first_name,\n            last_name=membersuite_entity.last_name)\n        user_created = True\n\n    return user, user_created", "response": "Returns a User object for the given membersuite_entity."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef process(self, envelope, session, mode=None, composer_factory=None, **kwargs):\n\t\tif mode == WMessengerComposerLayer.Mode.compose:\n\t\t\treturn self.compose(envelope, session, composer_factory, **kwargs)\n\t\telif mode == WMessengerComposerLayer.Mode.decompose:\n\t\t\treturn self.decompose(envelope, session, composer_factory, **kwargs)\n\t\traise RuntimeError('Invalid mode was specified')", "response": "Implementation of WMessengerOnionLayerProto. process method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_filter(self, filter):\n        if not isinstance(filter, AbstractFilter):\n            err = 'Filters must be of type {}'.format(AbstractFilter)\n            raise InvalidFilter(err)\n\n        if filter not in self.filters:\n            self.filters.append(filter)\n        return self", "response": "Add filter to property\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a validator to the property AttributeNames", "response": "def add_validator(self, validator):\n        \"\"\"\n        Add validator to property\n\n        :param validator: object, extending from AbstractValidator\n        :return: None\n        \"\"\"\n        if not isinstance(validator, AbstractValidator):\n            err = 'Validator must be of type {}'.format(AbstractValidator)\n            raise InvalidValidator(err)\n\n        self.validators.append(validator)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform model filtering with schema", "response": "def filter_with_schema(self, model=None, context=None):\n        \"\"\" Perform model filtering with schema \"\"\"\n        if model is None or self.schema is None:\n            return\n\n        self._schema.filter(\n            model=model,\n            context=context if self.use_context else None\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms model validation with schema", "response": "def validate_with_schema(self, model=None, context=None):\n        \"\"\" Perform model validation with schema\"\"\"\n        if self._schema is None or model is None:\n            return\n\n        result = self._schema.validate(\n            model=model,\n            context=context if self.use_context else None\n        )\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms collection items filtering with schema", "response": "def filter_with_schema(self, collection=None, context=None):\n        \"\"\" Perform collection items filtering with schema \"\"\"\n        if collection is None or self.schema is None:\n            return\n\n        try:\n            for item in collection:\n                self._schema.filter(\n                    model=item,\n                    context=context if self.use_context else None\n                )\n        except TypeError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates each item in collection with our schema", "response": "def validate_with_schema(self, collection=None, context=None):\n        \"\"\" Validate each item in collection with our schema\"\"\"\n        if self._schema is None or not collection:\n            return\n\n        result = []\n        try:\n            for index, item in enumerate(collection):\n                item_result = self._schema.validate(\n                    model=item,\n                    context=context if self.use_context else None\n                )\n                result.append(item_result)\n        except TypeError:\n            pass\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing a cross - kernel stable hash value for the given object.", "response": "def json_based_stable_hash(obj):\n    \"\"\"Computes a cross-kernel stable hash value for the given object.\n\n    The supported data structure are the built-in list, tuple and dict types.\n\n    Any included tuple or list, whether outer or nested, may only contain\n    values of the following built-in types: bool, int, float, complex, str,\n    list, tuple and dict.\n\n    Any included dict, whether outer or nested, may only contain keys of a\n    single type, which can be one the following built-in types: bool, int,\n    float, str, and may only contain values of only the following built-in\n    types: bool, int, float, complex, str, list, tuple, dict.\n\n    Parameters\n    ---------\n    obj : bool/int/float/complex/str/dict/list/tuple\n        The object for which to compute a hash value.\n\n    Returns\n    -------\n    int\n        The computed hash value.\n    \"\"\"\n    encoded_str = json.dumps(\n        obj=obj,\n        skipkeys=False,\n        ensure_ascii=False,\n        check_circular=True,\n        allow_nan=True,\n        cls=None,\n        indent=0,\n        separators=(',', ':'),\n        default=None,\n        sort_keys=True,\n    ).encode('utf-8')\n    return hashlib.sha256(encoded_str).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_request_line(self, request_line):\n\n\t\trequest = self.__request_cls.parse_request_line(self, request_line)\n\n\t\tprotocol_version = self.protocol_version()\n\t\tif protocol_version == '0.9':\n\t\t\tif request.method() != 'GET':\n\t\t\t\traise Exception('HTTP/0.9 standard violation')\n\t\telif protocol_version == '1.0' or protocol_version == '1.1':\n\t\t\tpass\n\t\telif protocol_version == '2':\n\t\t\tpass\n\t\telse:\n\t\t\traise RuntimeError('Unsupported HTTP-protocol')", "response": "Read HTTP - request line from request_line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_local_key(module_and_var_name, default_module=None):\n    if \"-\" in module_and_var_name:\n        raise ModuleAndVarNameShouldNotHaveDashCharacter\n    key_name_module_path = module_and_var_name.split(\".\")\n    module_name = \".\".join(key_name_module_path[0:-1])\n    attr_name = key_name_module_path[-1]\n    c = ConfigurableAttributeGetter(module_name, default_module)\n    return c.get_attr(attr_name)", "response": "Get the local key for the given module and variable name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates the class using all metaclasses. Args: metaclasses: A tuple of metaclasses that will be used to generate and replace a specified class. Returns: A decorator that will recreate the class using the specified metaclasses.", "response": "def metaclass(*metaclasses):\n    # type: (*type) -> Callable[[type], type]\n    \"\"\"Create the class using all metaclasses.\n\n    Args:\n        metaclasses: A tuple of metaclasses that will be used to generate and\n            replace a specified class.\n\n    Returns:\n        A decorator that will recreate the class using the specified\n        metaclasses.\n    \"\"\"\n\n    def _inner(cls):\n        # pragma pylint: disable=unused-variable\n        metabases = tuple(\n            collections.OrderedDict(  # noqa: F841\n                (c, None) for c in (metaclasses + (type(cls),))\n            ).keys()\n        )\n        # pragma pylint: enable=unused-variable\n        _Meta = metabases[0]\n        for base in metabases[1:]:\n\n            class _Meta(base, _Meta):  # pylint: disable=function-redefined\n                pass\n\n        return six.add_metaclass(_Meta)(cls)\n\n    return _inner"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfilters the value for the current object based on its parent model and context.", "response": "def filter(self, value, model=None, context=None):\n        \"\"\"\n        Filter\n        Performs value filtering and returns filtered result.\n\n        :param value:           input value\n        :param model:           parent model being validated\n        :param context:         object, filtering context\n        :return:                filtered value\n        \"\"\"\n        http = ['http://', 'https://']\n        if all(not str(value).startswith(s) for s in http):\n            value = 'http://{}'.format(value)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of HealthSystems together with timestep when they are applied", "response": "def changeHS(self):\n        \"\"\"\n        Change health system interventions\n        https://github.com/SwissTPH/openmalaria/wiki/GeneratedSchema32Doc#change-health-system\n        Returns: list of HealthSystems together with timestep when they are applied\n        \"\"\"\n        health_systems = []\n        change_hs = self.et.find(\"changeHS\")\n        if change_hs is None:\n            return health_systems\n        for health_system in change_hs.findall(\"timedDeployment\"):\n            health_systems.append([int(health_system.attrib(\"time\")), HealthSystem(self.et)])\n        return health_systems"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef anophelesParams(self):\n        list_of_anopheles = []\n        for anophelesParams in self.itn.findall(\"anophelesParams\"):\n            list_of_anopheles.append(AnophelesParams(anophelesParams))\n        return list_of_anopheles", "response": "returns a list of AnophelesParams"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the attrition in years for the Basic UI", "response": "def get_attrition_in_years(self):\n        \"\"\"\n        Function for the Basic UI\n        \"\"\"\n        attrition_of_nets = self.itn.find(\"attritionOfNets\")\n        function = attrition_of_nets.attrib[\"function\"]\n        if function != \"step\":\n            return None\n        L = attrition_of_nets.attrib[\"L\"]\n        return L"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of AnophelesParams", "response": "def anophelesParams(self):\n        \"\"\"\n        :rtype: AnophelesParams\n        \"\"\"\n        list_of_anopheles = []\n        for anophelesParams in self.gvi.findall(\"anophelesParams\"):\n            list_of_anopheles.append(AnophelesParams(anophelesParams))\n        return list_of_anopheles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an intervention to the intervention section.", "response": "def add(self, intervention, id=None):\n        \"\"\"\n        Add an intervention to intervention/human section.\n        intervention is either ElementTree or xml snippet\n        \"\"\"\n        if self.et is None:\n            return\n\n        assert isinstance(intervention, six.string_types)\n        et = ElementTree.fromstring(intervention)\n        component = None\n\n        if et.find(\"ITN\") is not None:\n            component = ITN(et)\n        elif et.find(\"GVI\") is not None:\n            component = GVI(et)\n        elif et.find(\"MDA\") is not None:\n            component = MDA(et)\n        elif et.find(\"TBV\") is not None or et.find(\"PEV\") is not None or et.find(\"BSV\") is not None:\n            component = Vaccine(et)\n        else:\n            return\n\n        assert isinstance(component.name, six.string_types)\n\n        if id is not None:\n            assert isinstance(id, six.string_types)\n            et.attrib[\"id\"] = id\n\n        index = len(self.et.findall(\"component\"))\n        self.et.insert(index, et)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all anopheles in the archive", "response": "def anopheles(self):\n        \"\"\"\n        :rtype: Anopheles\n        \"\"\"\n        list_of_anopheles = []\n        desc = self.et.find(\"description\")\n\n        if desc is not None:\n            for anopheles in desc.findall(\"anopheles\"):\n                list_of_anopheles.append(Anopheles(anopheles))\n\n        return list_of_anopheles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of time - steps at which this intervention occurs starting from 0.", "response": "def timesteps(self):\n        \"\"\"\n        Time-step at which this intervention occurs, starting from 0, the first intervention-period time-step.\n        https://github.com/SwissTPH/openmalaria/wiki/GeneratedSchema32Doc#-deploy-1\n        rtype: list\n        \"\"\"\n        timesteps = []\n        timed = self.et.find(\"timed\")\n\n        if timed is not None:\n            for deploy in timed.findall(\"deploy\"):\n                timesteps.append(deploy.attrib[\"time\"])\n\n        return timesteps"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an intervention to vectorPop section.", "response": "def add(self, intervention, name=None):\n        \"\"\"\n        Add an intervention to vectorPop section.\n        intervention is either ElementTree or xml snippet\n        \"\"\"\n        if self.et is None:\n            return\n\n        assert isinstance(intervention, six.string_types)\n        et = ElementTree.fromstring(intervention)\n        vector_pop = VectorPopIntervention(et)\n\n        assert isinstance(vector_pop.name, six.string_types)\n\n        if name is not None:\n            assert isinstance(name, six.string_types)\n            et.attrib[\"name\"] = name\n\n        index = len(self.et.findall(\"intervention\"))\n        self.et.insert(index, et)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef interventions(self):\n        interventions = {}\n        if self.et is None:\n            return interventions\n        for intervention in self.et.findall(\"intervention\"):\n            interventions[intervention.attrib['name']] = VectorPopIntervention(intervention)\n        return interventions", "response": "Dictionary of interventions in vectorPop section"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget current and set history cursor position", "response": "def position(self, pos=None):\n\t\t\"\"\" Get current and/or set history cursor position\n\n\t\t:param pos: if value is not None, then current position is set to pos and new value is returned\n\n\t\t:return: int or None (if position have never been changed)\n\t\t\"\"\"\n\t\tif pos is not None:\n\t\t\tif pos >= len(self.__history):\n\t\t\t\traise IndexError('History position is out of bound')\n\t\t\tself.__history_position = pos\n\t\treturn self.__history_position"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add(self, value):\n\t\tindex = len(self.__history)\n\t\tself.__history.append(value)\n\t\treturn index", "response": "Add new record to history."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start_session(self):\n\t\tself.__current_row = ''\n\t\tself.__history_mode = False\n\t\tself.__editable_history = deepcopy(self.__history)\n\t\tself.__prompt_show = True\n\t\tself.refresh_window()", "response": "Start new session and prepare environment for new row editing"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fin_session(self):\n\t\tself.__prompt_show = False\n\t\tself.__history.add(self.row())\n\t\tself.exec(self.row())", "response": "Finalize current session\n\n\t\t:return: None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchanges row with new value", "response": "def update_row(self, value):\n\t\t\"\"\" Change row\n\n\t\t:param value: new row\n\t\t:return: None\n\t\t\"\"\"\n\t\tif not self.__history_mode:\n\t\t\tself.__current_row = value\n\t\telse:\n\t\t\tself.history().update(value, self.history().position())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets row in history", "response": "def row(self):\n\t\t\"\"\" Get row\n\n\t\t:return: str\n\t\t\"\"\"\n\t\tif not self.__history_mode:\n\t\t\treturn self.__current_row\n\t\telse:\n\t\t\treturn self.history().entry(self.history().position())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn list of strings. Where each string is fitted to windows width.", "response": "def list_data(\n\t\tself, previous_data=False, prompt=False, console_row=False,\n\t\tconsole_row_to_cursor=False, console_row_from_cursor=False\n\t):\n\t\t\"\"\" Return list of strings. Where each string is fitted to windows width. Parameters are the same as\n\t\tthey are in :meth:`.WConsoleWindow.data` method\n\n\t\t:return: list of str\n\t\t\"\"\"\n\t\treturn self.split(self.data(\n\t\t\tprevious_data, prompt, console_row, console_row_to_cursor, console_row_from_cursor\n\t\t))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting data to the specified line in the screen.", "response": "def write_data(self, data, start_position=0):\n\t\t\"\"\" Write data from the specified line\n\n\t\t:param data: string to write, each one on new line\n\t\t:param start_position: starting line\n\t\t:return:\n\t\t\"\"\"\n\t\tif len(data) > self.height():\n\t\t\traise ValueError('Data too long (too many strings)')\n\n\t\tfor i in range(len(data)):\n\t\t\tself.write_line(start_position + i, data[i])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsplits data into list of string each length or less.", "response": "def split(self, data):\n\t\t\"\"\" Split data into list of string, each (self.width() - 1) length or less. If nul-length string\n\t\tspecified then empty list is returned\n\n\t\t:param data: data to split\n\t\t:return: list of str\n\t\t\"\"\"\n\t\tline = deepcopy(data)\n\t\tline_width = (self.width() - 1)\n\n\t\tlines = []\n\t\twhile len(line):\n\n\t\t\tnew_line = line[:line_width]\n\n\t\t\tnew_line_pos = new_line.find('\\n')\n\t\t\tif new_line_pos >= 0:\n\t\t\t\tnew_line = line[:new_line_pos]\n\t\t\t\tline = line[(new_line_pos + 1):]\n\t\t\telse:\n\t\t\t\tline = line[line_width:]\n\n\t\t\tlines.append(new_line)\n\n\t\treturn lines"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstoring feedback. Keep specified feedback as previous output :param feedback: data to store :param cr: whether to write carriage return to the end or not :return: None", "response": "def write_feedback(self, feedback, cr=True):\n\t\t\"\"\" Store feedback. Keep specified feedback as previous output\n\n\t\t:param feedback: data to store\n\t\t:param cr: whether to write carriage return to the end or not\n\t\t:return: None\n\t\t\"\"\"\n\t\tself.__previous_data += feedback\n\t\tif cr is True:\n\t\t\tself.__previous_data += '\\n'"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrefresh current window. Clear current window and redraw all drawers that are available.", "response": "def refresh(self, prompt_show=True):\n\t\t\"\"\" Refresh current window. Clear current window and redraw it with one of drawers\n\n\t\t:param prompt_show: flag, that specifies, whether to show prompt and current row at the\n\t\twindows end, or not\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tself.clear()\n\t\tfor drawer in self.__drawers:\n\t\t\tif drawer.suitable(self, prompt_show=prompt_show):\n\t\t\t\tdrawer.draw(self, prompt_show=prompt_show)\n\t\t\t\treturn\n\n\t\traise RuntimeError('No suitable drawer was found')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write(self, result, cr=True):\n\t\tself.window().write_feedback(result, cr=cr)", "response": "Shortcut for self. window. write_feedback"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndetermine if a Path or string is a directory on the file system.", "response": "def is_dir(path):\n    \"\"\"Determine if a Path or string is a directory on the file system.\"\"\"\n    try:\n        return path.expanduser().absolute().is_dir()\n    except AttributeError:\n        return os.path.isdir(os.path.abspath(os.path.expanduser(str(path))))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_file(path):\n    try:\n        return path.expanduser().absolute().is_file()\n    except AttributeError:\n        return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))", "response": "Determine if a Path or string is a file on the file system."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exists(path):\n    try:\n        return path.expanduser().absolute().exists()\n    except AttributeError:\n        return os.path.exists(os.path.abspath(os.path.expanduser(str(path))))", "response": "Determine if a Path or string is an existing path on the file system."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncommits the changes to the current document.", "response": "def commit(self):\n        \"\"\"\n        Delete the rest of the line.\n        \"\"\"\n\n        # Get the text cursor for the current document and unselect everything.\n        tc = self.qteWidget.textCursor()\n        tc.clearSelection()\n\n        # If this is the first ever call to this undo/redo element then\n        # backup the current cursor position and the selected text (may be\n        # none). This information will be required for the redo operation\n        # to position the cursor (and selected text) where it was at the\n        # very first call.\n        if self.cursorPos0 is None:\n            self.cursorPos0 = tc.position()\n\n        # Ensure nothing is selected.\n        tc.setPosition(self.cursorPos0, QtGui.QTextCursor.MoveAnchor)\n\n        # Mark the rest of the line, store its content in this very object\n        # and the global kill-list, and remove it.\n        tc.movePosition(QtGui.QTextCursor.EndOfLine,\n                        QtGui.QTextCursor.KeepAnchor)\n        self.cursorPos1 = tc.selectionEnd()\n        self.killedText = tc.selection().toHtml()\n        data = qtmacs.kill_list.KillListElement(\n            tc.selection().toPlainText(),\n            tc.selection().toHtml(),\n            'QtmacsTextEdit-Html')\n        qte_global.kill_list.append(data)\n        tc.removeSelectedText()\n\n        # Apply the changes.\n        self.qteWidget.setTextCursor(tc)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nre-insert the previously deleted line.", "response": "def reverseCommit(self):\n        \"\"\"\n        Re-insert the previously deleted line.\n        \"\"\"\n\n        # Get the text cursor for the current document.\n        tc = self.qteWidget.textCursor()\n\n        # Re-insert the deleted text at the correct position.\n        tc.setPosition(self.cursorPos0)\n        tc.insertHtml(self.killedText)\n\n        # Apply the changes.\n        self.qteWidget.setTextCursor(tc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncommits the changes to the current line and deletes the rest of the line.", "response": "def commit(self):\n        \"\"\"\n        Delete the rest of the line.\n        \"\"\"\n\n        # Get the text cursor for the current document and unselect\n        # everything.\n        tc = self.qteWidget.textCursor()\n        tc.clearSelection()\n\n        # If this is the first ever call to this undo/redo element then\n        # backup the current cursor position and the selected text (may be\n        # none). This information will be required for the redo operation\n        # to position the cursor (and selected text) where it was at the\n        # very first call.\n        if self.cursorPos0 is None:\n            self.cursorPos0 = tc.position()\n        else:\n            tc.setPosition(self.cursorPos0, QtGui.QTextCursor.MoveAnchor)\n\n        # Insert the element and keep track of how much the cursor has\n        # moved. This is trivial to determine automatically if\n        # `yankText` is pure text, but if it is HTML code then it is\n        # safer to rely on Qt's builtin ``position`` method.\n        if self.textType:\n            tc.insertText(self.yankText)\n        else:\n            tc.insertHtml(self.yankText)\n        self.cursorPos1 = tc.position()\n\n        # Apply the changes.\n        self.qteWidget.setTextCursor(tc)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nre-insert the previously removed character(s).", "response": "def reverseCommit(self):\n        \"\"\"\n        Re-insert the previously removed character(s).\n        \"\"\"\n        # Get the text cursor for the current document.\n        tc = self.qteWidget.textCursor()\n\n        # Mark the previously inserted text and remove it.\n        tc.setPosition(self.cursorPos0, QtGui.QTextCursor.MoveAnchor)\n        tc.setPosition(self.cursorPos1, QtGui.QTextCursor.KeepAnchor)\n        tc.removeSelectedText()\n        tc.setPosition(self.cursorPos0, QtGui.QTextCursor.MoveAnchor)\n\n        # Apply the changes.\n        self.qteWidget.setTextCursor(tc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nenables hook for yank - pop only.", "response": "def enableHook(self, msgObj):\n        \"\"\"\n        Enable yank-pop.\n\n        This method is connected to the 'yank-qtmacs_text_edit' hook\n        (triggered by the yank macro) to ensure that yank-pop only\n        gets activated afterwards.\n        \"\"\"\n        self.killListIdx = len(qte_global.kill_list) - 2\n        self.qteMain.qtesigKeyseqComplete.connect(self.disableHook)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the highlighting. This is an overloaded version of the native Qt slot of ``QTextEdit``. In this class, the purpose of this slot is to check if the character to the right of the cursor needs highlighting, assuming there is a second character to pair with it. |Args| * **None** |Returns| * **None** |Raises| * **None**", "response": "def cursorPositionChangedEvent(self):\n        \"\"\"\n        Update the highlighting.\n\n        This is an overloaded version of the native Qt slot of\n        ``QTextEdit``.\n\n        In this class, the purpose of this slot is to check if the\n        character to the right of the cursor needs highlighting,\n        assuming there is a second character to pair with it.\n\n        |Args|\n\n        * **None**\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n\n        # Determine the sender and cursor position.\n        qteWidget = self.sender()\n        tc = qteWidget.textCursor()\n        origin = tc.position()\n\n        # Remove all the highlighting. Since this will move the\n        # cursor, first disconnect this very routine to avoid an\n        # infinite recursion.\n        qteWidget.cursorPositionChanged.disconnect(\n            self.cursorPositionChangedEvent)\n        self.qteRemoveHighlighting(qteWidget)\n        qteWidget.cursorPositionChanged.connect(\n            self.cursorPositionChangedEvent)\n\n        # If we are beyond the last character (for instance because\n        # the cursor was explicitly moved to the end of the buffer)\n        # then there is no character to the right and will result in\n        # an error when trying to fetch it.\n        if origin >= len(qteWidget.toPlainText()):\n            return\n        else:\n            # It is save to retrieve the character to the right of the\n            # cursor.\n            char = qteWidget.toPlainText()[origin]\n\n        # Return if the character is not in the matching list.\n        if char not in self.charToHighlight:\n            return\n\n        # Disconnect the 'cursorPositionChanged' signal from this\n        # function because it will make changes to the cursor position\n        # and would therefore immediately trigger itself, resulting in\n        # an infinite recursion.\n        qteWidget.cursorPositionChanged.disconnect(\n            self.cursorPositionChangedEvent)\n\n        # If we got until here \"char\" must be one of the two\n        # characters to highlight.\n        if char == self.charToHighlight[0]:\n            start = origin\n            # Found the first character, so now look for the second\n            # one. If this second character does not exist the\n            # function returns '-1' which is safe because the\n            # ``self.highlightCharacter`` method can deal with this.\n            stop = qteWidget.toPlainText().find(self.charToHighlight[1],\n                                                start + 1)\n        else:\n            # Found the second character so the start index is indeed\n            # the stop index.\n            stop = origin\n\n            # Search for the preceeding first character.\n            start = qteWidget.toPlainText().rfind(self.charToHighlight[0],\n                                                  0, stop)\n\n        # Highlight the characters.\n        oldCharFormats = self.highlightCharacters(qteWidget, (start, stop),\n                                                  QtCore.Qt.blue, 100)\n\n        # Store the positions of the changed character in the\n        # macroData structure of this widget.\n        data = self.qteMacroData(qteWidget)\n        data.matchingPositions = (start, stop)\n        data.oldCharFormats = oldCharFormats\n        self.qteSaveMacroData(data, qteWidget)\n\n        # Reconnect the 'cursorPositionChanged' signal.\n        qteWidget.cursorPositionChanged.connect(\n            self.cursorPositionChangedEvent)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the highlighting from previously highlighted characters.", "response": "def qteRemoveHighlighting(self, widgetObj):\n        \"\"\"\n        Remove the highlighting from previously highlighted characters.\n\n        The method access instance variables to determine which\n        characters are currently highlighted and have to be converted\n        to non-highlighted ones.\n\n        |Args|\n\n        * ``widgetObj`` (**QWidget**): the ``QTextEdit`` to use.\n\n        |Returns|\n\n        * **None**\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n\n        # Retrieve the widget specific macro data.\n        data = self.qteMacroData(widgetObj)\n        if not data:\n            return\n\n        # If the data structure is empty then no previously\n        # highlighted characters exist in this particular widget, so\n        # do nothing.\n        if not data.matchingPositions:\n            return\n\n        # Restore the original character formats, ie. undo the\n        # highlighting changes.\n        self.highlightCharacters(widgetObj, data.matchingPositions,\n                                 QtCore.Qt.black, 50, data.oldCharFormats)\n\n        # Clear the data structure to indicate that no further\n        # highlighted characters exist in this particular widget.\n        data.matchingPositions = None\n        data.oldCharFormats = None\n        self.qteSaveMacroData(data, widgetObj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhighlight the characters in the specified set of characters.", "response": "def highlightCharacters(self, widgetObj, setPos, colorCode,\n                            fontWeight, charFormat=None):\n        \"\"\"\n        Change the character format of one or more characters.\n\n        If ``charFormat`` is **None** then only the color and font\n        weight of the characters are changed to ``colorCode`` and\n        ``fontWeight``, respectively.\n\n        |Args|\n\n        * ``widgetObj`` (**QWidget**): the ``QTextEdit`` holding\n          the characters.\n        * ``setPos`` (**tuple** of **int**): character positions\n          inside the widget.\n        * ``colorCode`` (**QColor**): eg. ``QtCore.Qt.blue``\n        * ``fontWeight`` (**int**): font weight.\n        * ``charFormat`` (**QTextCharFormat**): the character\n          format to apply (see Qt documentation for details.)\n\n        |Returns|\n\n        * **list**: the original character format of the replaced\n          characters. This list has the same length as ``setPos``.\n\n        |Raises|\n\n        * **None**\n        \"\"\"\n\n        # Get the text cursor and character format.\n        textCursor = widgetObj.textCursor()\n        oldPos = textCursor.position()\n        retVal = []\n\n        # Change the character formats of all the characters placed at\n        # the positions ``setPos``.\n        for ii, pos in enumerate(setPos):\n            # Extract the position of the character to modify.\n            pos = setPos[ii]\n\n            # Ignore invalid positions. This can happen if the second\n            # character does not exist and the find-functions in the\n            # ``cursorPositionChangedEvent`` method returned\n            # '-1'. Also, store **None** as the format for this\n            # non-existent character.\n            if pos < 0:\n                retVal.append(None)\n                continue\n\n            # Move the text cursor to the specified character position\n            # and store its original character format (necessary to\n            # \"undo\" the highlighting once the cursor was moved away\n            # again).\n            textCursor.setPosition(pos)\n            retVal.append(textCursor.charFormat())\n\n            # Change the character format. Either use the supplied\n            # one, or use a generic one.\n            if charFormat:\n                # Use a specific character format (usually used to\n                # undo the changes a previous call to\n                # 'highlightCharacters' has made).\n                fmt = charFormat[ii]\n            else:\n                # Modify the color and weight of the current character format.\n                fmt = textCursor.charFormat()\n\n                # Get the brush and specify its foreground color and\n                # style. In order to see the characters it is\n                # necessary to explicitly specify a solidPattern style\n                # but I have no idea why.\n                myBrush = fmt.foreground()\n                myBrush.setColor(colorCode)\n                myBrush.setStyle(QtCore.Qt.SolidPattern)\n                fmt.setForeground(myBrush)\n                fmt.setFontWeight(fontWeight)\n\n            # Select the character and apply the selected format.\n            textCursor.movePosition(QtGui.QTextCursor.NextCharacter,\n                                    QtGui.QTextCursor.KeepAnchor)\n            textCursor.setCharFormat(fmt)\n\n        # Apply the textcursor to the current element.\n        textCursor.setPosition(oldPos)\n        widgetObj.setTextCursor(textCursor)\n        return retVal"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scenarios(self, generate_seed=False):\n        seed = prime_numbers(1000)\n        sweeps_all = self.experiment[\"sweeps\"].keys()\n        if \"combinations\" in self.experiment:\n            if isinstance(self.experiment[\"combinations\"], list):\n                # For backward compatibility with experiments1-4s\n                combinations_in_experiment = {\" \": self.experiment[\"combinations\"]}\n                # if self.experiment[\"combinations\"] == []:\n                #    # Special notation for fully-factorial experiments\n                #    combinations_in_experiment = {\" \":[[],[]]}\n            else:\n                # Combinations must be a dictionary in this particular case\n                combinations_in_experiment = self.experiment[\"combinations\"]\n        else:\n            # Support no combinations element:\n            combinations_in_experiment = dict()    # empty dict \n\n        # 1) calculate combinations_sweeps (depends on ALL combinations_ items)\n        # Get the list of fully factorial sweeps\n        all_combinations_sweeps = []\n        all_combinations = []\n        for key, combinations_ in combinations_in_experiment.items():\n            # generate all permutations of all combinations\n            if not combinations_:\n                # Fully factorial experiment, shortcut for \"combinations\":[[],[]]\n                combinations_sweeps = []\n                combinations = [[]]\n            else:\n                # First item in combinations list is a list of sweeps\n                combinations_sweeps = combinations_[0]\n                # then - all combinations\n                combinations = combinations_[1:]\n            for item in combinations_sweeps:\n                # TODO: error if sweep is already in this list?\n                all_combinations_sweeps.append(item)\n            all_combinations.append((combinations_sweeps, combinations))\n        \n        sweeps_fully_factorial = list(set(sweeps_all) - set(all_combinations_sweeps))\n        # print \"fully fact: %s\" % sweeps_fully_factorial\n        \n        # 2) produce a list of all combinations of fully factorial sweeps\n        # First sets of \"combinations\": the fully-factorial sweeps\n        for sweep in sweeps_fully_factorial:\n            all_combinations.append(([sweep], [[x] for x in self.experiment[\"sweeps\"][sweep].keys()]))\n        \n        # 3) take the dot (inner) product of the list above (fully factorial arm combinations)\n        #   with the first combinations list, that with the second combination list, ...\n        # step-by-step reduce the list of combinations to a single item\n        # (dot-product of each list of combinations)\n        # this could use a lot of memory...\n        red_iter = 0\n        # print \"all combinations:\", red_iter, all_combinations\n        while len(all_combinations) > 1:\n            comb1 = all_combinations[0]\n            comb2 = all_combinations[1]\n            new_sweeps = comb1[0] + comb2[0]\n            new_combinations = [x+y for x in comb1[1] for y in comb2[1]]\n            all_combinations = [(new_sweeps, new_combinations)] + all_combinations[2:]\n            red_iter += 1\n            # print \"all combinations:\", red_iter, all_combinations\n        \n        # 4) write out the document for each in (3), which should specify one arm for each\n        #   sweep with no repetition of combinations\n        sweep_names = all_combinations[0][0]\n        combinations = all_combinations[0][1]\n        for combination in combinations:\n            scenario = Scenario(self._apply_combination(self.experiment[\"base\"], sweep_names, combination))\n            scenario.parameters = dict(zip(sweep_names, combination))\n\n            if generate_seed:\n                # Replace seed if requested by the user\n                if \"@seed@\" in scenario.xml:\n                    scenario.xml = scenario.xml.replace(\"@seed@\", str(next(seed)))\n                else:\n                    raise(RuntimeError(\"@seed@ placeholder is not found\"))\n            yield scenario", "response": "Generates all scenarios for this experiment."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lvm_info(self, name=None):\n\t\tcmd = [] if self.sudo() is False else ['sudo']\n\t\tcmd.extend([self.command(), '-c'])\n\t\tif name is not None:\n\t\t\tcmd.append(name)\n\n\t\toutput = subprocess.check_output(cmd, timeout=self.cmd_timeout())\n\t\toutput = output.decode()\n\t\tresult = []\n\t\tfields_count = self.fields_count()\n\t\tfor line in output.split('\\n'):\n\t\t\tline = line.strip()\n\t\t\tfields = line.split(':')\n\t\t\tif len(fields) == fields_count:\n\t\t\t\tresult.append(fields)\n\t\tif name is not None and len(result) != 1:\n\t\t\traise RuntimeError('Unable to parse command result')\n\t\treturn tuple(result)", "response": "Call a program\n\t if name is not None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef uuid(self):\n\t\tuuid_file = '/sys/block/%s/dm/uuid' % os.path.basename(os.path.realpath(self.volume_path()))\n\t\tlv_uuid = open(uuid_file).read().strip()\n\t\tif lv_uuid.startswith('LVM-') is True:\n\t\t\treturn lv_uuid[4:]\n\t\treturn lv_uuid", "response": "Return UUID of logical volume"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a snapshot of this logical volume.", "response": "def create_snapshot(self, snapshot_size, snapshot_suffix):\n\t\t\"\"\" Create snapshot for this logical volume.\n\n\t\t:param snapshot_size: size of newly created snapshot volume. This size is a fraction of the source \\\n\t\tlogical volume space (of this logical volume)\n\t\t:param snapshot_suffix: suffix for logical volume name (base part is the same as the original volume \\\n\t\tname)\n\n\t\t:return: WLogicalVolume\n\t\t\"\"\"\n\t\tsize_extent = math.ceil(self.extents_count() * snapshot_size)\n\t\tsize_kb = self.volume_group().extent_size() * size_extent\n\t\tsnapshot_name = self.volume_name() + snapshot_suffix\n\n\t\tlvcreate_cmd = ['sudo'] if self.lvm_command().sudo() is True else []\n\n\t\tlvcreate_cmd.extend([\n\t\t\t'lvcreate', '-L', '%iK' % size_kb, '-s', '-n', snapshot_name, '-p', 'r', self.volume_path()\n\t\t])\n\t\tsubprocess.check_output(lvcreate_cmd, timeout=self.__class__.__lvm_snapshot_create_cmd_timeout__)\n\t\treturn WLogicalVolume(self.volume_path() + snapshot_suffix, sudo=self.lvm_command().sudo())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_volume(self):\n\t\tlvremove_cmd = ['sudo'] if self.lvm_command().sudo() is True else []\n\t\tlvremove_cmd.extend(['lvremove', '-f', self.volume_path()])\n\t\tsubprocess.check_output(lvremove_cmd, timeout=self.__class__.__lvm_snapshot_remove_cmd_timeout__)", "response": "Remove this volume\n\n\t\t:return: None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef snapshot_allocation(self):\n\t\tcheck_cmd = ['lvs', self.volume_path(), '-o', 'snap_percent', '--noheadings']\n\t\toutput = subprocess.check_output(check_cmd, timeout=self.__class__.__lvm_snapshot_check_cmd_timeout__)\n\t\toutput = output.decode().strip()\n\t\tif len(output) == 0:\n\t\t\traise RuntimeError('Unable to check general logical volume')\n\t\treturn float(output.replace(',', '.', 1))", "response": "Return allocated size of the logical volume."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef logical_volume(cls, file_path, sudo=False):\n\t\tmp = WMountPoint.mount_point(file_path)\n\t\tif mp is not None:\n\t\t\tname_file = '/sys/block/%s/dm/name' % mp.device_name()\n\t\t\tif os.path.exists(name_file):\n\t\t\t\tlv_path = '/dev/mapper/%s' % open(name_file).read().strip()\n\t\t\t\treturn WLogicalVolume(lv_path, sudo=sudo)", "response": "Return a WLogicalVolume that stores the given path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencrypting and write data self. Write data to the output buffer.", "response": "def write(self, b):\n\t\t\"\"\" Encrypt and write data\n\n\t\t:param b: data to encrypt and write\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tself.__buffer += bytes(b)\n\t\tbytes_written = 0\n\t\twhile len(self.__buffer) >= self.__cipher_block_size:\n\t\t\tio.BufferedWriter.write(self, self.__cipher.encrypt_block(self.__buffer[:self.__cipher_block_size]))\n\t\t\tself.__buffer = self.__buffer[self.__cipher_block_size:]\n\t\t\tbytes_written += self.__cipher_block_size\n\t\treturn len(b)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef component(self, component, value=None):\n\t\tif isinstance(component, str) is True:\n\t\t\tcomponent = WURI.Component(component)\n\t\tif value is not None:\n\t\t\tself.__components[component] = value\n\t\t\treturn value\n\t\treturn self.__components[component]", "response": "Set and or get component value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting the component in this URI", "response": "def reset_component(self, component):\n\t\t\"\"\" Unset component in this URI\n\n\t\t:param component: component name (or component type) to reset\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tif isinstance(component, str) is True:\n\t\t\tcomponent = WURI.Component(component)\n\t\tself.__components[component] = None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse URI - string and return WURI object", "response": "def parse(cls, uri):\n\t\t\"\"\" Parse URI-string and return WURI object\n\n\t\t:param uri: string to parse\n\t\t:return: WURI\n\t\t\"\"\"\n\t\turi_components = urlsplit(uri)\n\t\tadapter_fn = lambda x: x if x is not None and (isinstance(x, str) is False or len(x)) > 0 else None\n\n\t\treturn cls(\n\t\t\tscheme=adapter_fn(uri_components.scheme),\n\t\t\tusername=adapter_fn(uri_components.username),\n\t\t\tpassword=adapter_fn(uri_components.password),\n\t\t\thostname=adapter_fn(uri_components.hostname),\n\t\t\tport=adapter_fn(uri_components.port),\n\t\t\tpath=adapter_fn(uri_components.path),\n\t\t\tquery=adapter_fn(uri_components.query),\n\t\t\tfragment=adapter_fn(uri_components.fragment),\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_parameter(self, name, value=None):\n\t\tif name not in self.__query:\n\t\t\tself.__query[name] = [value]\n\t\telse:\n\t\t\tself.__query[name].append(value)", "response": "Add new parameter value to this query."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_parameter(self, name):\n\t\tif name in self.__query:\n\t\t\tself.__query.pop(name)", "response": "Removes the specified parameter from this query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(cls, query_str):\n\t\tparsed_query = parse_qs(query_str, keep_blank_values=True, strict_parsing=True)\n\t\tresult = cls()\n\t\tfor parameter_name in parsed_query.keys():\n\t\t\tfor parameter_value in parsed_query[parameter_name]:\n\t\t\t\tresult.add_parameter(\n\t\t\t\t\tparameter_name,\n\t\t\t\t\tparameter_value if len(parameter_value) > 0 else None\n\t\t\t\t)\n\t\treturn result", "response": "Parse string that represent query component from URI\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new query parameter specification.", "response": "def add_specification(self, specification):\n\t\t\"\"\" Add a new query parameter specification. If this object already has a specification for the\n\t\tspecified parameter - exception is raised. No checks for the specified or any parameter are made\n\t\tregarding specification appending\n\n\t\t:param specification: new specification that will be added\n\t\t:return: None\n\t\t\"\"\"\n\t\tname = specification.name()\n\t\tif name in self.__specs:\n\t\t\traise ValueError('WStrictURIQuery object already has specification for parameter \"%s\" ' % name)\n\t\tself.__specs[name] = specification"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a specification that matches a query parameter.", "response": "def remove_specification(self, name):\n\t\t\"\"\" Remove a specification that matches a query parameter. No checks for the specified or any parameter\n\t\tare made regarding specification removing\n\n\t\t:param name: parameter name to remove\n\t\t:return: None\n\t\t\"\"\"\n\t\tif name in self.__specs:\n\t\t\tself.__specs.pop(name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreplacing a query parameter value with a new value.", "response": "def replace_parameter(self, name, value=None):\n\t\t\"\"\" Replace a query parameter values with a new value. If a new value does not match current\n\t\tspecifications, then exception is raised\n\n\t\t:param name: parameter name to replace\n\t\t:param value: new parameter value. None is for empty (null) value\n\t\t:return: None\n\t\t\"\"\"\n\t\tspec = self.__specs[name] if name in self.__specs else None\n\t\tif self.extra_parameters() is False and spec is None:\n\t\t\traise ValueError('Extra parameters are forbidden for this WStrictURIQuery object')\n\n\t\tif spec is not None and spec.nullable() is False and value is None:\n\t\t\traise ValueError('Nullable values is forbidden for parameter \"%s\"' % name)\n\n\t\tif spec is not None and value is not None:\n\t\t\tre_obj = spec.re_obj()\n\t\t\tif re_obj is not None and re_obj.match(value) is None:\n\t\t\t\traise ValueError('Value does not match regular expression')\n\n\t\tWURIQuery.replace_parameter(self, name, value=value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a parameter from this query.", "response": "def remove_parameter(self, name):\n\t\t\"\"\" Remove parameter from this query. If a parameter is mandatory, then exception is raised\n\n\t\t:param name: parameter name to remove\n\t\t:return: None\n\t\t\"\"\"\n\t\tspec = self.__specs[name] if name in self.__specs else None\n\t\tif spec is not None and spec.optional() is False:\n\t\t\traise ValueError('Unable to remove a required parameter \"%s\"' % name)\n\n\t\tWURIQuery.remove_parameter(self, name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef strict_parse(cls, query_str, *specs, extra_parameters=True):\n\t\tplain_result = cls.parse(query_str)\n\t\treturn WStrictURIQuery(plain_result, *specs, extra_parameters=extra_parameters)", "response": "Parse a query string and return a WStrictURIQuery object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate(self, uri):\n\t\trequirement = self.requirement()\n\t\turi_component = uri.component(self.component())\n\n\t\tif uri_component is None:\n\t\t\treturn requirement != WURIComponentVerifier.Requirement.required\n\t\tif requirement == WURIComponentVerifier.Requirement.unsupported:\n\t\t\treturn False\n\n\t\tre_obj = self.re_obj()\n\t\tif re_obj is not None:\n\t\t\treturn re_obj.match(uri_component) is not None\n\t\treturn True", "response": "Check an URI for compatibility with this specification. Return True if the URI is compatible. Return False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that an URI is compatible with this descriptor. Return True if the URI is not compatible.", "response": "def validate(self, uri):\n\t\t\"\"\" Check that an query part of an URI is compatible with this descriptor. Return True if the URI is\n\t\tcompatible.\n\n\t\t:param uri: an URI to check\n\n\t\t:return: bool\n\t\t\"\"\"\n\t\tif WURIComponentVerifier.validate(self, uri) is False:\n\t\t\treturn False\n\t\ttry:\n\t\t\tWStrictURIQuery(\n\t\t\t\tWURIQuery.parse(uri.component(self.component())),\n\t\t\t\t*self.__specs,\n\t\t\t\textra_parameters=self.__extra_parameters\n\t\t\t)\n\t\texcept ValueError:\n\t\t\treturn False\n\t\treturn True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_compatible(self, uri):\n\t\tfor component, component_value in uri:\n\t\t\tif self.verifier(component).validate(uri) is False:\n\t\t\t\treturn False\n\n\t\treturn True", "response": "Check if URI is compatible with this specification."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning handler which scheme name matches the specified one", "response": "def handler(self, scheme_name=None):\n\t\t\"\"\" Return handler which scheme name matches the specified one\n\n\t\t:param scheme_name: scheme name to search for\n\t\t:return: WSchemeHandler class or None (if matching handler was not found)\n\t\t\"\"\"\n\t\tif scheme_name is None:\n\t\t\treturn self.__default_handler_cls\n\t\tfor handler in self.__handlers_cls:\n\t\t\tif handler.scheme_specification().scheme_name() == scheme_name:\n\t\t\t\treturn handler"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns handler instance that matches the specified URI.", "response": "def open(self, uri, **kwargs):\n\t\t\"\"\" Return handler instance that matches the specified URI. WSchemeCollection.NoHandlerFound and\n\t\tWSchemeCollection.SchemeIncompatible may be raised.\n\n\t\t:param uri: URI to search handler for\n\t\t:param kwargs: additional arguments that may be used by a handler specialization\n\t\t:return: WSchemeHandler\n\t\t\"\"\"\n\t\thandler = self.handler(uri.scheme())\n\t\tif handler is None:\n\t\t\traise WSchemeCollection.NoHandlerFound(uri)\n\n\t\tif uri.scheme() is None:\n\t\t\turi.component('scheme', handler.scheme_specification().scheme_name())\n\n\t\tif handler.scheme_specification().is_compatible(uri) is False:\n\t\t\traise WSchemeCollection.SchemeIncompatible(uri)\n\n\t\treturn handler.create_handler(uri, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loadFile(self, fileName):\n        self.fileName = fileName\n        self.qteWeb.load(QtCore.QUrl(fileName))", "response": "Load the file with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_to_response(self, context, **response_kwargs):\n        context[\"ajax_form_id\"] = self.ajax_form_id\n        # context[\"base_template\"] = \"towel_bootstrap/modal.html\"\n        return self.response_class(\n            request=self.request,\n            template=self.get_template_names(),\n            context=context,\n            **response_kwargs\n        )", "response": "Returns a response with a template rendered with the given context."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting to unicode if self. encoding!= None otherwise returns input without attempting to decode", "response": "def to_python(self, value, resource):\n        \"\"\"Converts to unicode if `self.encoding != None`, otherwise returns input without attempting to decode\"\"\"\n\n        if value is None:\n            return self._transform(value)\n\n        if isinstance(value, six.text_type):\n            return self._transform(value)\n\n        if self.encoding is None and isinstance(value, (six.text_type, six.binary_type)):\n            return self._transform(value)\n\n        if self.encoding is not None and isinstance(value, six.binary_type):\n            return self._transform(value.decode(self.encoding))\n\n        return self._transform(six.text_type(value))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_value(self, obj, resource, visited=set()):\n\n        if id(obj) in visited:\n            raise ValueError('Circular reference detected when attempting to serialize object')\n\n        if isinstance(obj, (list, tuple, set)):\n            return [self.to_value(x, resource) if hasattr(x, '__dict__') else x for x in obj]\n        elif hasattr(obj, '__dict__'):\n            attrs = obj.__dict__.copy()\n            for key in six.iterkeys(obj.__dict__):\n                if key.startswith('_'):\n                    del attrs[key]\n\n            return {\n                self.reverse_aliases.get(k, k):\n                    self.to_value(v, resource) if hasattr(v, '__dict__') or isinstance(v, (list, tuple, set)) else v\n                for k, v in six.iteritems(attrs)\n            }\n        else:\n            return obj", "response": "Convert a Python object to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hello_message(self, invert_hello=False):\n\t\tif invert_hello is False:\n\t\t\treturn self.__gouverneur_message\n\n\t\thello_message = []\n\t\tfor i in range(len(self.__gouverneur_message) - 1, -1, -1):\n\t\t\thello_message.append(self.__gouverneur_message[i])\n\t\treturn bytes(hello_message)", "response": "Return message header.\n\n\t\t:param invert_hello: whether to return the original header (in case of False value) or reversed \\\n\t\tone (in case of True value).\n\t\t:return: bytes"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates request or response message.", "response": "def _message(self, beacon_config, invert_hello=False):\n\t\t\"\"\" Generate request/response message.\n\n\t\t:param beacon_config: server or client configuration. Client configuration is used for request and \\\n\t\tserver configuration for response\n\t\t:param invert_hello: return message with reverse header when this argument is set to True.\n\t\t:return: bytes\n\t\t\"\"\"\n\n\t\tmessage = self.hello_message(invert_hello=invert_hello) + self._message_address_generate(beacon_config)\n\t\treturn message"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating address for request or response message.", "response": "def _message_address_generate(self, beacon_config):\n\t\t\"\"\" Generate address for request/response message.\n\n\t\t:param beacon_config: server or client configuration. Client configuration is used for request and \\\n\t\tserver configuration for response\n\t\t:return: bytes\n\t\t\"\"\"\n\n\t\taddress = None\n\n\t\tif beacon_config['wasp-general::network::beacon']['public_address'] != '':\n\t\t\taddress = str(WIPV4SocketInfo.parse_address(\n\t\t\t\tbeacon_config['wasp-general::network::beacon']['public_address']\n\t\t\t)).encode('ascii')\n\n\t\tif address is not None:\n\t\t\taddress = WBeaconGouverneurMessenger.__message_splitter__ + address\n\n\t\t\tif beacon_config['wasp-general::network::beacon']['public_port'] != '':\n\t\t\t\tport = beacon_config.getint('wasp-general::network::beacon', 'public_port')\n\t\t\t\taddress += WBeaconGouverneurMessenger.__message_splitter__ + str(port).encode('ascii')\n\n\t\treturn address if address is not None else b''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread address from beacon message.", "response": "def _message_address_parse(self, message, invert_hello=False):\n\t\t\"\"\" Read address from beacon message. If no address is specified then \"nullable\" WIPV4SocketInfo returns\n\n\t\t:param message: message to parse\n\t\t:param invert_hello: defines whether message header is the original one or reversed.\n\t\t:return: WIPV4SocketInfo\n\t\t\"\"\"\n\t\tmessage_header = self.hello_message(invert_hello=invert_hello)\n\n\t\tif message[:len(message_header)] != message_header:\n\t\t\traise ValueError('Invalid message header')\n\n\t\tmessage = message[len(message_header):]\n\t\tmessage_parts = message.split(WBeaconGouverneurMessenger.__message_splitter__)\n\n\t\taddress = None\n\t\tport = None\n\n\t\tif len(message_parts) > 3:\n\t\t\traise ValueError('Invalid message. Too many separators')\n\t\telif len(message_parts) == 3:\n\t\t\taddress = WIPV4SocketInfo.parse_address(message_parts[1].decode('ascii'))\n\t\t\tport = WIPPort(int(message_parts[2]))\n\t\telif len(message_parts) == 2 and len(message_parts[1]) > 0:\n\t\t\taddress = WIPV4SocketInfo.parse_address(message_parts[1].decode('ascii'))\n\n\t\treturn WIPV4SocketInfo(address, port)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_response(self, beacon_config, request, client_address):\n\t\ttry:\n\t\t\tself._message_address_parse(request, invert_hello=self.__invert_hello)\n\t\t\treturn True\n\t\texcept ValueError:\n\t\t\tpass\n\t\treturn False", "response": "This method is used to check if beacon_config. beacon_config."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef response_address(self, beacon_config, request, client_address):\n\t\tsi = self._message_address_parse(request, invert_hello=self.__invert_hello)\n\t\taddress = si.address()\n\t\tport = si.port()\n\t\treturn WIPV4SocketInfo(\n\t\t\taddress if address is not None else client_address.address(),\n\t\t\tport if port is not None else client_address.port()\n\t\t)", "response": ":meth:`.WBeaconMessengerBase.request` method implementation.\n\n\t\tsee :class:`.WBeaconGouverneurMessenger`"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef valid_response(self, beacon_config, response, server_address):\n\t\ttry:\n\t\t\tself._message_address_parse(response, invert_hello=self.__invert_hello)\n\t\t\treturn True\n\t\texcept ValueError:\n\t\t\tpass\n\t\treturn False", "response": "This method is used to check if response is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverrides method. Appends encoded host group names to requests and responses.", "response": "def _message(self, beacon_config, invert_hello=False):\n\t\t\"\"\" Overridden :meth:`.WBeaconGouverneurMessenger._message` method. Appends encoded host group names\n\t\tto requests and responses.\n\n\t\t:param beacon_config: beacon configuration\n\t\t:return: bytes\n\t\t\"\"\"\n\t\tm = WBeaconGouverneurMessenger._message(self, beacon_config, invert_hello=invert_hello)\n\t\thostgroups = self._message_hostgroup_generate()\n\t\tif len(hostgroups) > 0:\n\t\t\tm += (WHostgroupBeaconMessenger.__message_groups_splitter__ + hostgroups)\n\t\treturn m"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _message_hostgroup_parse(self, message):\n\t\tsplitter_count = message.count(WHostgroupBeaconMessenger.__message_groups_splitter__)\n\t\tif splitter_count == 0:\n\t\t\treturn [], WBeaconGouverneurMessenger._message_address_parse(self, message)\n\t\telif splitter_count == 1:\n\t\t\tsplitter_pos = message.find(WHostgroupBeaconMessenger.__message_groups_splitter__)\n\t\t\tgroups = []\n\t\t\tgroup_splitter = WHostgroupBeaconMessenger.__group_splitter__\n\t\t\tfor group_name in message[(splitter_pos + 1):].split(group_splitter):\n\t\t\t\tgroups.append(group_name.strip())\n\t\t\taddress = WBeaconGouverneurMessenger._message_address_parse(self, message[:splitter_pos])\n\t\t\treturn groups, address\n\t\telse:\n\t\t\traise ValueError('Invalid message. Too many separators')", "response": "Parse given message and return list of group names and socket information."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef response_address(self, beacon_config, request, client_address):\n\t\tsi = self._message_hostgroup_parse(request)[1]\n\t\taddress = si.address()\n\t\tport = si.port()\n\t\treturn WIPV4SocketInfo(\n\t\t\taddress if address is not None else client_address.address(),\n\t\t\tport if port is not None else client_address.port()\n\t\t)", "response": "This method is used to get the response address from the beacon config. It just removes host group names\n\tpart and returns WIPV4SocketInfo object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pad(self, data, block_size):\n\t\tpadding_symbol = self.padding_symbol()\n\n\t\tblocks_count = (len(data) // block_size)\n\t\tif (len(data) % block_size) != 0:\n\t\t\tblocks_count += 1\n\n\t\ttotal_length = blocks_count * block_size\n\t\treturn self._fill(data, total_length, padding_symbol)", "response": "method implementation for padding"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _fill(self, data, total_length, padding_symbol):\n\n\t\tdelta = total_length - len(data)\n\t\treturn ((padding_symbol * random_int(delta)) + data).ljust(total_length, padding_symbol)", "response": "Overridden :meth:`.WSimplePadding._fill` method. This methods adds padding symbol at the beginning\n\t\tand at the end of the specified data.\n\n\t\t:param data: data to append to\n\t\t:param total_length: target length\n\t\t:param padding_symbol: symbol to pad\n\t\t:return: bytes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reverse_pad(self, data, block_size):\n\t\tpad_byte = data[-1]\n\t\tif pad_byte > block_size:\n\t\t\traise ValueError('Invalid padding')\n\n\t\tpadding = bytes([pad_byte] * pad_byte)\n\t\tif data[-pad_byte:] != padding:\n\t\t\traise ValueError('Invalid padding')\n\n\t\treturn data[:-pad_byte]", "response": "Method implementation for reverse_pad"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a name like AES_256_CBC or AES - 128 - CBC or AES - CBC.", "response": "def parse_cipher_name(cls, name):\n\t\t\"\"\" Parse cipher name (name like 'aes_256_cbc' or 'AES-128-CTR'). Also this method validates If the\n\t\tcipher is supported by this class. If no - exception is raised\n\n\t\t:param name: name to parse\n\n\t\t:return: tuple where the first element is a key size in bytes (int) and the second element - block cipher mode\n\t\tof operation (str) (for example: (16, 'AES-CTR') or (24, 'AES-CBC'))\n\t\t\"\"\"\n\t\tr = cls.__mode_re__.match(name.upper())\n\t\tif r is None:\n\t\t\traise ValueError('Unable to find suitable cipher for: \"%s\"' % name)\n\t\tkey_size = int(int(r.group(2)) / 8)\n\t\tblock_mode = 'AES-%s' % r.group(4)\n\t\tif key_size not in cls.__valid_key_sizes__:\n\t\t\traise ValueError('Unsupported secret length: \"%i\"' % key_size)\n\t\tif block_mode not in cls.__modes_descriptor__.keys():\n\t\t\traise ValueError('Unsupported block cipher mode of operation: \"%s\"' % block_mode)\n\t\treturn key_size, block_mode"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate AES - cipher", "response": "def cipher(self):\n\t\t\"\"\" Generate AES-cipher\n\n\t\t:return: Crypto.Cipher.AES.AESCipher\n\t\t\"\"\"\n\t\t#cipher = pyAES.new(*self.mode().aes_args(), **self.mode().aes_kwargs())\n\t\tcipher = Cipher(*self.mode().aes_args(), **self.mode().aes_kwargs())\n\t\treturn WAES.WAESCipher(cipher)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encrypt(self, data):\n\t\tpadding = self.mode().padding()\n\t\tif padding is not None:\n\t\t\tdata = padding.pad(data, WAESMode.__data_padding_length__)\n\n\t\treturn self.cipher().encrypt_block(data)", "response": "Encrypt the given data with cipher that is got from AES. cipher call."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decrypt(self, data, decode=False):\n\n\t\t#result = self.cipher().decrypt(data)\n\t\tresult = self.cipher().decrypt_block(data)\n\n\t\tpadding = self.mode().padding()\n\t\tif padding is not None:\n\t\t\tresult = padding.reverse_pad(result, WAESMode.__data_padding_length__)\n\n\t\treturn result.decode() if decode else result", "response": "Decrypt the given data with cipher that is got from AES. cipher call."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef thread_exception(self, raised_exception):\n\t\ttracker = self.tracker_storage()\n\t\tif tracker is not None:\n\t\t\ttry:\n\t\t\t\tif self.track_exception() is True:\n\t\t\t\t\tdetails = self.event_details(WTrackerEvents.exception)\n\t\t\t\t\ttracker.register_exception(\n\t\t\t\t\t\tself,\n\t\t\t\t\t\traised_exception,\n\t\t\t\t\t\ttraceback.format_exc(),\n\t\t\t\t\t\tevent_details=details\n\t\t\t\t\t)\n\t\t\texcept Exception as e:\n\t\t\t\tself.thread_tracker_exception(e)", "response": "method for registering unhandled exception by a tracker storage object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_start(self, task, event_details=None):\n\t\tif self.record_start() is True:\n\t\t\trecord_type = WTrackerEvents.start\n\t\t\trecord = WSimpleTrackerStorage.Record(record_type, task, event_details=event_details)\n\t\t\tself.__store_record(record)", "response": "This method is used to register a start event for the given task."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving record in a internal storage.", "response": "def __store_record(self, record):\n\t\t\"\"\" Save record in a internal storage\n\n\t\t:param record: record to save\n\n\t\t:return: None\n\t\t\"\"\"\n\t\tif isinstance(record, WSimpleTrackerStorage.Record) is False:\n\t\t\traise TypeError('Invalid record type was')\n\t\tlimit = self.record_limit()\n\t\tif limit is not None and len(self.__registry) >= limit:\n\t\t\tself.__registry.pop(0)\n\t\tself.__registry.append(record)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches over registered : class :. WScheduleTask instances and return the last record that matches the requested_events.", "response": "def last_record(self, task_uid, *requested_events):\n\t\t\"\"\" Search over registered :class:`.WScheduleTask` instances and return the last record that matches\n\t\tsearch criteria.\n\n\t\t:param task_uid: uid of :class:`.WScheduleTask` instance\n\t\t:param requested_events: target events types\n\n\t\t:return: WSimpleTrackerStorage.Record or None\n\t\t\"\"\"\n\t\tfor record in self:\n\t\t\tif isinstance(record.thread_task, WScheduleTask) is False:\n\t\t\t\tcontinue\n\t\t\tif record.thread_task.uid() == task_uid:\n\t\t\t\tif len(requested_events) == 0 or record.record_type in requested_events:\n\t\t\t\t\treturn record"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef task_postponed(self):\n\t\ttracker = self.task().tracker_storage()\n\t\tif tracker is not None and self.track_wait() is True:\n\t\t\tdetails = self.task().event_details(WTrackerEvents.wait)\n\t\t\ttracker.register_wait(self.task(), event_details=details)\n\t\tWScheduleRecord.task_postponed(self)", "response": "Track if required ) postponing event and do the same job as : meth :. WScheduleRecord. task_postponed"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef task_dropped(self):\n\t\ttracker = self.task().tracker_storage()\n\t\tif tracker is not None and self.track_drop() is True:\n\t\t\tdetails = self.task().event_details(WTrackerEvents.drop)\n\t\t\ttracker.register_drop(self.task(), event_details=details)\n\t\tWScheduleRecord.task_dropped(self)", "response": "Track drop event and do the same job as :meth :. WScheduleRecord. task_dropped"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nested_val(key_tuple, dict_obj):\n    if len(key_tuple) == 1:\n        return dict_obj[key_tuple[0]]\n    return get_nested_val(key_tuple[1:], dict_obj[key_tuple[0]])", "response": "Return a value from nested dicts by the given keys tuple."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a value from nested dicts by the given keys tuple.", "response": "def safe_nested_val(key_tuple, dict_obj, default_value=None):\n    \"\"\"Return a value from nested dicts by the order of the given keys tuple.\n\n    Parameters\n    ----------\n    key_tuple : tuple\n        The keys to use for extraction, in order.\n    dict_obj : dict\n        The outer-most dict to extract from.\n    default_value : object, default None\n        The value to return when no matching nested value is found.\n\n    Returns\n    -------\n    value : object\n        The extracted value, if exists. Otherwise, the given default_value.\n\n    Example\n    -------\n    >>> dict_obj = {'a': {'b': 7}}\n    >>> safe_nested_val(('a', 'b'), dict_obj)\n    7\n    >>> safe_nested_val(('a', 'c'), dict_obj)\n\n    >>> safe_nested_val(('a', 'c'), dict_obj, 5)\n    5\n    >>> safe_nested_val(('d'), dict_obj, 5)\n    5\n    \"\"\"\n    try:\n        return get_nested_val(key_tuple, dict_obj)\n    except (KeyError, IndexError, TypeError):\n        return default_value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef put_nested_val(dict_obj, key_tuple, value):\n    current_dict = dict_obj\n    for key in key_tuple[:-1]:\n        try:\n            current_dict = current_dict[key]\n        except KeyError:\n            current_dict[key] = {}\n            current_dict = current_dict[key]\n    current_dict[key_tuple[-1]] = value", "response": "Put a value into nested dicts by the order of the given keys tuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_alternative_nested_val(key_tuple, dict_obj):\n    # print('key_tuple: {}'.format(key_tuple))\n    # print('dict_obj: {}'.format(dict_obj))\n    top_keys = key_tuple[0] if isinstance(key_tuple[0], (list, tuple)) else [\n        key_tuple[0]]\n    for key in top_keys:\n        try:\n            if len(key_tuple) < 2:\n                return dict_obj[key]\n            return get_alternative_nested_val(key_tuple[1:], dict_obj[key])\n        except (KeyError, TypeError, IndexError):\n            pass\n    raise KeyError", "response": "Get a value from nested dicts by any path in the given keys tuple."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef subdict_by_keys(dict_obj, keys):\n    return {k: dict_obj[k] for k in set(keys).intersection(dict_obj.keys())}", "response": "Returns a sub - dict composed solely of the given keys."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef increment_dict_val(dict_obj, key, value, zero_value=0):\n    dict_obj[key] = dict_obj.get(key, zero_value) + value", "response": "Increments the value mapped by the given key by the given val."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef increment_nested_val(dict_obj, key_tuple, value, zero_value=0):\n    inc_val = value + safe_nested_val(\n        key_tuple=key_tuple,\n        dict_obj=dict_obj,\n        default_value=zero_value,\n    )\n    put_nested_val(\n        dict_obj=dict_obj,\n        key_tuple=key_tuple,\n        value=inc_val,\n    )", "response": "Increments the value mapped by the given key by the given val."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the given val to the set mapped by the given key.", "response": "def add_to_dict_val_set(dict_obj, key, val):\n    \"\"\"Adds the given val to the set mapped by the given key.\n    If the key is missing from the dict, the given mapping is added.\n\n    Example\n    -------\n    >>> dict_obj = {'a': set([1, 2])}\n    >>> add_to_dict_val_set(dict_obj, 'a', 2)\n    >>> print(dict_obj['a'])\n    {1, 2}\n    >>> add_to_dict_val_set(dict_obj, 'a', 3)\n    >>> print(dict_obj['a'])\n    {1, 2, 3}\n    \"\"\"\n    try:\n        dict_obj[key].add(val)\n    except KeyError:\n        dict_obj[key] = set([val])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the given value list to the set mapped by the given key.", "response": "def add_many_to_dict_val_set(dict_obj, key, val_list):\n    \"\"\"Adds the given value list to the set mapped by the given key.\n    If the key is missing from the dict, the given mapping is added.\n\n    Example\n    -------\n    >>> dict_obj = {'a': set([1, 2])}\n    >>> add_many_to_dict_val_set(dict_obj, 'a', [2, 3])\n    >>> print(dict_obj['a'])\n    {1, 2, 3}\n    >>> add_many_to_dict_val_set(dict_obj, 'b', [2, 3])\n    >>> print(dict_obj['b'])\n    {2, 3}\n    \"\"\"\n    try:\n        dict_obj[key].update(val_list)\n    except KeyError:\n        dict_obj[key] = set(val_list)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_many_to_dict_val_list(dict_obj, key, val_list):\n    try:\n        dict_obj[key].extend(val_list)\n    except KeyError:\n        dict_obj[key] = list(val_list)", "response": "Adds the given value list to the list mapped by the given key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_keys_of_max_n(dict_obj, n):\n    return sorted([\n        item[0]\n        for item in sorted(\n            dict_obj.items(), key=lambda item: item[1], reverse=True\n        )[:n]\n    ])", "response": "Returns the keys that maps to the top n max values in the given dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef norm_int_dict(int_dict):\n    norm_dict = int_dict.copy()\n    val_sum = sum(norm_dict.values())\n    for key in norm_dict:\n        norm_dict[key] = norm_dict[key] / val_sum\n    return norm_dict", "response": "Normalizes values in the given dict with int values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsum the given dicts into a single dict mapping each key to the sum of its mappings in all given dicts.", "response": "def sum_num_dicts(dicts, normalize=False):\n    \"\"\"Sums the given dicts into a single dict mapping each key to the sum\n    of its mappings in all given dicts.\n\n    Parameters\n    ----------\n    dicts : list\n        A list of dict objects mapping each key to an numeric value.\n    normalize : bool, default False\n        Indicated whether to normalize all values by value sum.\n\n    Returns\n    -------\n    dict\n        A dict where each key is mapped to the sum of its mappings in all\n        given dicts.\n\n    Example\n    -------\n    >>> dict1 = {'a': 3, 'b': 2}\n    >>> dict2 = {'a':7, 'c': 8}\n    >>> result = sum_num_dicts([dict1, dict2])\n    >>> print(sorted(result.items()))\n    [('a', 10), ('b', 2), ('c', 8)]\n    >>> result = sum_num_dicts([dict1, dict2], normalize=True)\n    >>> print(sorted(result.items()))\n    [('a', 0.5), ('b', 0.1), ('c', 0.4)]\n    \"\"\"\n    sum_dict = {}\n    for dicti in dicts:\n        for key in dicti:\n            sum_dict[key] = sum_dict.get(key, 0) + dicti[key]\n    if normalize:\n        return norm_int_dict(sum_dict)\n    return sum_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sum_dicts(dicts, normalize=False):\n    sum_dict = {}\n    for dicti in dicts:\n        for key in dicti:\n            val = dicti[key]\n            if isinstance(val, numbers.Number):\n                sum_dict[key] = sum_dict.get(key, 0) + val\n            else:\n                sum_dict[key] = val\n    if normalize:\n        return norm_int_dict(sum_dict)\n    return sum_dict", "response": "Sums the given dicts into a single dict mapping each numberic - valued\n    key to the sum of its mappings in all given dicts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreversing a dict so each value in it maps to a sorted list of its keys.", "response": "def reverse_dict(dict_obj):\n    \"\"\"Reverse a dict, so each value in it maps to a sorted list of its keys.\n\n    Parameters\n    ----------\n    dict_obj : dict\n        A key-value dict.\n\n    Returns\n    -------\n    dict\n        A dict where each value maps to a sorted list of all the unique keys\n        that mapped to it.\n\n    Example\n    -------\n    >>> dicti = {'a': 1, 'b': 3, 'c': 1}\n    >>> reverse_dict(dicti)\n    {1: ['a', 'c'], 3: ['b']}\n    \"\"\"\n    new_dict = {}\n    for key in dict_obj:\n        add_to_dict_val_set(dict_obj=new_dict, key=dict_obj[key], val=key)\n    for key in new_dict:\n        new_dict[key] = sorted(new_dict[key], reverse=False)\n    return new_dict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreversing a dict so each value in it maps to one of its keys.", "response": "def reverse_dict_partial(dict_obj):\n    \"\"\"Reverse a dict, so each value in it maps to one of its keys.\n\n    Parameters\n    ----------\n    dict_obj : dict\n        A key-value dict.\n\n    Returns\n    -------\n    dict\n        A dict where each value maps to the key that mapped to it.\n\n    Example\n    -------\n    >>> dicti = {'a': 1, 'b': 3}\n    >>> reverse_dict_partial(dicti)\n    {1: 'a', 3: 'b'}\n    \"\"\"\n    new_dict = {}\n    for key in dict_obj:\n        new_dict[dict_obj[key]] = key\n    return new_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreverse a list - valued dict so each element in a list maps to its key.", "response": "def reverse_list_valued_dict(dict_obj):\n    \"\"\"Reverse a list-valued dict, so each element in a list maps to its key.\n\n    Parameters\n    ----------\n    dict_obj : dict\n        A dict where each key maps to a list of unique values. Values are\n        assumed to be unique across the entire dict, on not just per-list.\n\n    Returns\n    -------\n    dict\n        A dict where each element in a value list of the input dict maps to\n        the key that mapped to the list it belongs to.\n\n    Example\n    -------\n    >>> dicti = {'a': [1, 2], 'b': [3, 4]}\n    >>> reverse_list_valued_dict(dicti)\n    {1: 'a', 2: 'a', 3: 'b', 4: 'b'}\n    \"\"\"\n    new_dict = {}\n    for key in dict_obj:\n        for element in dict_obj[key]:\n            new_dict[element] = key\n    return new_dict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nflatten the given dict into a single - level dict with flattend keys.", "response": "def flatten_dict(dict_obj, separator='.', flatten_lists=False):\n    \"\"\"Flattens the given dict into a single-level dict with flattend keys.\n\n    Parameters\n    ----------\n    dict_obj : dict\n        A possibly nested dict.\n    separator : str, optional\n        The character to use as a separator between keys. Defaults to '.'.\n    flatten_lists : bool, optional\n        If True, list values are also flattened. False by default.\n\n    Returns\n    -------\n    dict\n        A shallow dict, where no value is a dict in itself, and keys are\n        concatenations of original key paths separated with the given\n        separator.\n\n    Example\n    -------\n    >>> dicti = {'a': 1, 'b': {'g': 4, 'o': 9}, 'x': [4, 'd']}\n    >>> flat = flatten_dict(dicti)\n    >>> sorted(flat.items())\n    [('a', 1), ('b.g', 4), ('b.o', 9), ('x.0', 4), ('x.1', 'd')]\n    \"\"\"\n    reducer = _get_key_reducer(separator)\n    flat = {}\n\n    def _flatten_key_val(key, val, parent):\n        flat_key = reducer(parent, key)\n        try:\n            _flatten(val, flat_key)\n        except TypeError:\n            flat[flat_key] = val\n\n    def _flatten(d, parent=None):\n        try:\n            for key, val in d.items():\n                _flatten_key_val(key, val, parent)\n        except AttributeError:\n            if isinstance(d, (str, bytes)):\n                raise TypeError\n            for i, value in enumerate(d):\n                _flatten_key_val(str(i), value, parent)\n    _flatten(dict_obj)\n    return flat"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting the given dict with int values in a nice way.", "response": "def pprint_int_dict(int_dict, indent=4, descending=False):\n    \"\"\"Prints the given dict with int values in a nice way.\n\n    Parameters\n    ----------\n    int_dict : list\n        A dict object mapping each key to an int value.\n    \"\"\"\n    sorted_tup = sorted(int_dict.items(), key=lambda x: x[1])\n    if descending:\n        sorted_tup.reverse()\n    print('{')\n    for tup in sorted_tup:\n        print('{}{}: {}'.format(' '*indent, tup[0], tup[1]))\n    print('}')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the duplicated model from class_inst to new_class_name", "response": "def get_duplicated_model(class_inst, new_class_name):\n    \"\"\"\n    Duplicate the model fields from class_inst to new_class_name, example:\n    NewClass = get_duplicated_model(OldClass, \"NewClass\")\n    :param class_inst:\n    :param new_class_name:\n    :return:\n    \"\"\"\n    # Ref: http://www.cnblogs.com/Jerryshome/archive/2012/12/21/2827492.html\n    # get caller stack frame\n    # caller_frame = inspect.currentframe()\n    caller_frame_record = inspect.stack()[1]\n\n    # parse module name\n    module = inspect.getmodule(caller_frame_record[0])\n    return ModelDuplicator(module.__name__).get_duplicated_model(class_inst, new_class_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new model class that is duplicated from the given class_inst to the given new_class_name.", "response": "def get_duplicated_model(self, class_inst, new_class_name):\n        \"\"\"\n        Duplicate the model fields from class_inst to new_class_name, example:\n        NewClass = get_duplicated_model(OldClass, \"NewClass\")\n        :param class_inst:\n        :param new_class_name:\n        :return:\n        \"\"\"\n        # Ref: http://www.cnblogs.com/Jerryshome/archive/2012/12/21/2827492.html\n        attr_dict = {'__module__': self.module_name}\n        for field in class_inst.__dict__['_meta'].fields:\n            if self.is_relation_field_needed:\n                attr_dict[field.name] = copy_field(field)\n            elif not is_relation_field(field):\n                attr_dict[field.name] = copy_field(field)\n        # duplicated_model_class = type(\"Meta\", (), {\"abstract\": True})\n        duplicated_model_class = type(new_class_name, (models.Model,), attr_dict)\n        # The following codes are not working\n        # if hasattr(class_inst, \"__str__\"):\n        #     setattr(duplicated_model_class, \"__str__\", getattr(class_inst, \"__str__\"))\n        # if hasattr(class_inst, \"__str__\"):\n        #     str_func = getattr(class_inst, \"__str__\")\n        #     duplicated_model_class.__str__ = str_func\n        return duplicated_model_class"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister the current options to the global ConfigOpts object.", "response": "def register(self):\n        \"\"\"Register the current options to the global ConfigOpts object.\"\"\"\n        group = cfg.OptGroup(\n            self.group_name,\n            title=\"HNV (Hyper-V Network Virtualization) Options\")\n        self._config.register_group(group)\n        self._config.register_opts(self._options, group=group)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets nodeConstraint. nodeKind if any", "response": "def visitNodeConstraintNonLiteral(self, ctx: ShExDocParser.NodeConstraintNonLiteralContext):\n        \"\"\" nodeConstraint: nonLiteralKind stringFacet*  # nodeConstraintNonLiteral \"\"\"\n        self.nodeconstraint.nodeKind = 'iri' if ctx.nonLiteralKind().KW_IRI() \\\n            else 'bnode' if ctx.nonLiteralKind().KW_BNODE() \\\n            else 'nonliteral' if ctx.nonLiteralKind().KW_NONLITERAL() \\\n            else 'undefined'\n        self.visitChildren(ctx)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef visitNodeConstraintDatatype(self, ctx: ShExDocParser.NodeConstraintDatatypeContext):\n        self.nodeconstraint.datatype = self.context.iri_to_iriref(ctx.datatype().iri())\n        self.visitChildren(ctx)", "response": "nodeConstraint: datatype xsFacet* # nodeConstraintDatatype"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef visitNodeConstraintValueSet(self, ctx: ShExDocParser.NodeConstraintValueSetContext):\n        self.nodeconstraint.values = []\n        self.visitChildren(ctx)", "response": "Set node constraint values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef visitValueSetValue(self, ctx: ShExDocParser.ValueSetValueContext):\n        if ctx.iriRange() or ctx.literalRange() or ctx.languageRange():\n            self.visitChildren(ctx)\n        else:                               # '.' branch - wild card with exclusions\n            if ctx.iriExclusion():\n                vs_value = IriStemRange(Wildcard(), [])\n                self._iri_exclusions(vs_value, ctx.iriExclusion())\n            elif ctx.literalExclusion():\n                vs_value = LiteralStemRange(Wildcard(), [])\n                self._literal_exclusions(vs_value, ctx.literalExclusion())\n            else:\n                vs_value = LanguageStemRange(Wildcard(), [])\n                self._language_exclusions(vs_value, ctx.languageExclusion())\n            self.nodeconstraint.values.append(vs_value)", "response": "valueSetValue: iriRange | literalRange | languageRange | \n            '.' (iriExclusion+ | literalExclusion+ | languageExclusion+)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef visitIriRange(self, ctx: ShExDocParser.IriRangeContext):\n        baseiri = self.context.iri_to_iriref(ctx.iri())\n        if not ctx.STEM_MARK():\n            vsvalue = baseiri                   # valueSetValue = objectValue  / objectValue = IRI\n        else:\n            if ctx.iriExclusion():              # valueSetValue = IriStemRange / iriStemRange = stem + exclusions\n                vsvalue = IriStemRange(baseiri, exclusions=[])\n                self._iri_exclusions(vsvalue, ctx.iriExclusion())\n            else:\n                vsvalue = IriStem(baseiri)      # valueSetValue = IriStem  /  IriStem: {stem:IRI}\n        self.nodeconstraint.values.append(vsvalue)", "response": "visitIriRange : Add a value to nodeconstraint"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd literal exclusion to the stem.", "response": "def _literal_exclusions(self, stem: LiteralStemRange,\n                            exclusions: List[ShExDocParser.LiteralExclusionContext]) -> None:\n        \"\"\" ShExC: literalExclusion = '-' literal STEM_MARK?\n            ShExJ: exclusions: [STRING|LiteralStem +]\n                   literalStem: {stem:STRING}\n        \"\"\"\n        for excl in exclusions:\n            excl_literal_v = self.context.literal_to_ObjectLiteral(excl.literal()).value\n            stem.exclusions.append(LiteralStem(excl_literal_v) if excl.STEM_MARK() else excl_literal_v)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvisiting a LanguageRange node.", "response": "def visitLanguageRange(self, ctx: ShExDocParser.LanguageRangeContext):\n        \"\"\" ShExC: languageRange : LANGTAG (STEM_MARK languagExclusion*)? \n            ShExJ: valueSetValue = objectValue | LanguageStem | LanguageStemRange \"\"\"\n        baselang = ctx.LANGTAG().getText()\n        if not ctx.STEM_MARK():                 # valueSetValue = objectValue / objectValue = ObjectLiteral\n            vsvalue = Language()\n            vsvalue.languageTag = baselang[1:]\n        else:\n            if ctx.languageExclusion():\n                vsvalue = LanguageStemRange(LANGTAG(baselang[1:]), exclusions=[])\n                self._language_exclusions(vsvalue, ctx.languageExclusion())\n            else:\n                vsvalue = LanguageStem(LANGTAG(baselang[1:]))\n        self.nodeconstraint.values.append(vsvalue)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _language_exclusions(stem: LanguageStemRange,\n                             exclusions: List[ShExDocParser.LanguageExclusionContext]) -> None:\n        \"\"\" languageExclusion = '-' LANGTAG STEM_MARK?\"\"\"\n        for excl in exclusions:\n            excl_langtag = LANGTAG(excl.LANGTAG().getText()[1:])\n            stem.exclusions.append(LanguageStem(excl_langtag) if excl.STEM_MARK() else excl_langtag)", "response": "Add language exclusion to the stem."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef visitStringFacet(self, ctx: ShExDocParser.StringFacetContext):\n        if ctx.stringLength():\n            slen = jsg.Integer(ctx.INTEGER().getText())\n            if ctx.stringLength().KW_LENGTH():\n                self.nodeconstraint.length = slen\n            elif ctx.stringLength().KW_MINLENGTH():\n                self.nodeconstraint.minlength = slen\n            else:\n                self.nodeconstraint.maxlength = slen\n\n        else:\n            self.nodeconstraint.pattern = jsg.String(self.context.fix_re_escapes(ctx.REGEXP().getText()[1:-1]))\n            if ctx.REGEXP_FLAGS():\n                self.nodeconstraint.flags = jsg.String(ctx.REGEXP_FLAGS().getText())", "response": "visitStringFacet : returns a stringFacet node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvisiting numericFacet returns a nodeconstraint for numericFacet", "response": "def visitNumericFacet(self, ctx: ShExDocParser.NumericFacetContext):\n        \"\"\" numericFacet: numericRange numericLiteral | numericLength INTEGER\n            numericRange: KW_MINEXCLUSIVE | KW_MININCLUSIVE | KW_MAXEXCLUSIVE | KW_MAXINCLUSIVE \n            numericLength: KW_TOTALDIGITS | KW_FRACTIONDIGITS \"\"\"\n        if ctx.numericRange():\n            numlit = self.context.numeric_literal_to_type(ctx.numericLiteral())\n            if ctx.numericRange().KW_MINEXCLUSIVE():\n                self.nodeconstraint.minexclusive = numlit\n            elif ctx.numericRange().KW_MAXEXCLUSIVE():\n                self.nodeconstraint.maxexclusive = numlit\n            elif ctx.numericRange().KW_MININCLUSIVE():\n                self.nodeconstraint.mininclusive = numlit\n            elif ctx.numericRange().KW_MAXINCLUSIVE():\n                self.nodeconstraint.maxinclusive = numlit\n        else:\n            nlen = jsg.Integer(ctx.INTEGER().getText())\n            if ctx.numericLength().KW_TOTALDIGITS():\n                self.nodeconstraint.totaldigits = nlen\n            elif ctx.numericLength().KW_FRACTIONDIGITS():\n                self.nodeconstraint.fractiondigits = nlen"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_thumbnail(self, image, geometry,\n                         upscale=True, crop=None, colorspace='RGB'):\n        \"\"\"\n        This serves as a really basic example of a thumbnailing method. You\n        may want to implement your own logic, but this will work for\n        simple cases.\n\n        :param Image image: This is your engine's ``Image`` object. For\n            PIL it's PIL.Image.\n        :param tuple geometry: Geometry of the image in the format of (x,y).\n        :keyword str crop: A cropping offset string. This is either one or two\n            space-separated values. If only one value is specified, the cropping\n            amount (pixels or percentage) for both X and Y dimensions is the\n            amount given. If two values are specified, X and Y dimension cropping\n            may be set independently. Some examples: '50% 50%', '50px 20px',\n            '50%', '50px'.\n        :keyword str colorspace: The colorspace to set/convert the image to.\n            This is typically 'RGB' or 'GRAY'.\n        :returns: The thumbnailed image. The returned type depends on your\n            choice of Engine.\n        \"\"\"\n        image = self.colorspace(image, colorspace)\n        image = self.scale(image, geometry, upscale, crop)\n        image = self.crop(image, geometry, crop)\n\n        return image", "response": "This method creates a thumbnail of the image."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nscales the image down or up.", "response": "def scale(self, image, geometry, upscale, crop):\n        \"\"\"\n        Given an image, scales the image down (or up, if ``upscale`` equates\n        to a boolean ``True``).\n\n        :param Image image: This is your engine's ``Image`` object. For\n            PIL it's PIL.Image.\n        :param tuple geometry: Geometry of the image in the format of (x,y).\n        :returns: The scaled image. The returned type depends on your\n            choice of Engine.\n        \"\"\"\n        x_image, y_image = map(float, self.get_image_size(image))\n\n        # Calculate scaling factor.\n        factors = (geometry[0] / x_image, geometry[1] / y_image)\n        factor = max(factors) if crop else min(factors)\n        if factor < 1 or upscale:\n            width = toint(x_image * factor)\n            height = toint(y_image * factor)\n            image = self._scale(image, width, height)\n\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crop(self, image, geometry, crop):\n        if not crop:\n            return image\n\n        x_image, y_image = self.get_image_size(image)\n        x_offset, y_offset = parse_crop(crop, (x_image, y_image), geometry)\n\n        return self._crop(image, geometry[0], geometry[1], x_offset, y_offset)", "response": "Crops the given image according to the value in crop."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping for _write method that writes the image to dest_fobj.", "response": "def write(self, image, dest_fobj, quality=95, format=None):\n        \"\"\"\n        Wrapper for ``_write``\n\n        :param Image image: This is your engine's ``Image`` object. For\n            PIL it's PIL.Image.\n        :keyword int quality: A quality level as a percent. The lower, the\n            higher the compression, the worse the artifacts.\n        :keyword str format: The format to save to. If omitted, guess based\n            on the extension. We recommend specifying this. Typical values\n            are 'JPEG', 'GIF', 'PNG'. Other formats largely depend on your\n            choice of Engine.\n        \"\"\"\n        if isinstance(format, basestring) and format.lower() == 'jpg':\n            # This mistake is made all the time. Let's just effectively alias\n            # this, since it's commonly used.\n            format = 'JPEG'\n\n        raw_data = self._get_raw_data(image, format, quality)\n        dest_fobj.write(raw_data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the image ratio.", "response": "def get_image_ratio(self, image):\n        \"\"\"\n        Calculates the image ratio (X to Y).\n\n        :param Image image: This is your engine's ``Image`` object. For\n            PIL it's PIL.Image.\n        :rtype: float\n        :returns: The X to Y ratio of your image's dimensions.\n        \"\"\"\n        x, y = self.get_image_size(image)\n        return float(x) / y"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuses this feature you can register a customer\u2019s credit card data and get a token sequential number. Args: payer_id: name: identification_number: payment_method: number: expiration_date: Returns:", "response": "def create_single_token(self, *, payer_id, name, identification_number, payment_method, number, expiration_date):\n        \"\"\"\n        Using this feature you can register a customer\u2019s credit card data and get a token sequential number.\n\n        Args:\n            payer_id:\n            name:\n            identification_number:\n            payment_method:\n            number:\n            expiration_date:\n\n        Returns:\n\n        \"\"\"\n        payload = {\n            \"language\": self.client.language.value,\n            \"command\": PaymentCommand.CREATE_TOKEN.value,\n            \"merchant\": {\n                \"apiLogin\": self.client.api_login,\n                \"apiKey\": self.client.api_key\n            },\n            \"creditCardToken\": {\n                \"payerId\": payer_id,\n                \"name\": name,\n                \"identificationNumber\": identification_number,\n                \"paymentMethod\": payment_method,\n                \"number\": number,\n                \"expirationDate\": expiration_date\n            },\n            \"test\": self.client.is_test\n        }\n        return self.client._post(self.url, json=payload)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_token(self, *, payer_id, credit_card_token_id):\n        payload = {\n            \"language\": self.client.language.value,\n            \"command\": PaymentCommand.REMOVE_TOKEN.value,\n            \"merchant\": {\n                \"apiLogin\": self.client.api_login,\n                \"apiKey\": self.client.api_key\n            },\n            \"removeCreditCardToken\": {\n                \"payerId\": payer_id,\n                \"creditCardTokenId\": credit_card_token_id\n            },\n            \"test\": self.client.is_test\n        }\n        return self.client._post(self.url, json=payload)", "response": "This feature allows you to delete a tokenized credit card register."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_file_path(self, filePath):\n        if filePath is not None:\n            assert isinstance(filePath, basestring), \"filePath must be None or string\"\n            filePath = str(filePath)\n        self.__filePath = filePath", "response": "Sets the file path that needs to be locked."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_lock_pass(self, lockPass):\n        assert isinstance(lockPass, basestring), \"lockPass must be string\"\n        lockPass = str(lockPass)\n        assert '\\n' not in lockPass, \"lockPass must be not contain a new line\"\n        self.__lockPass = lockPass", "response": "Sets the locking pass for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the managing lock file path.", "response": "def set_lock_path(self, lockPath):\n        \"\"\"\n        Set the managing lock file path.\n\n        :Parameters:\n            #. lockPath (None, path): The locking file path. If None is given the locking file\n               will be automatically created to '.lock' in the filePath directory. If\n               filePath is None, '.lock' will be created in the current working directory.\n        \"\"\"\n        if lockPath is not None:\n            assert isinstance(lockPath, basestring), \"lockPath must be None or string\"\n            lockPath = str(lockPath)\n        self.__lockPath = lockPath\n        if self.__lockPath is None:\n            if self.__filePath is None:\n                self.__lockPath = os.path.join(os.getcwd(), \".lock\")\n            else:\n                self.__lockPath = os.path.join( os.path.dirname(self.__filePath), '.lock')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the timeout for the current lock.", "response": "def set_timeout(self, timeout):\n        \"\"\"\n        set the timeout limit.\n\n        :Parameters:\n            #. timeout (number): The maximum delay or time allowed to successfully set the\n               lock. When timeout is exhausted before successfully setting the lock,\n               the lock ends up not acquired.\n        \"\"\"\n        try:\n            timeout = float(timeout)\n            assert timeout>=0\n            assert timeout>=self.__wait\n        except:\n            raise Exception('timeout must be a positive number bigger than wait')\n        self.__timeout  = timeout"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_wait(self, wait):\n        try:\n            wait = float(wait)\n            assert wait>=0\n        except:\n            raise Exception('wait must be a positive number')\n        self.__wait = wait", "response": "set the waiting time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the dead lock time.", "response": "def set_dead_lock(self, deadLock):\n        \"\"\"\n        Set the dead lock time.\n\n        :Parameters:\n            #. deadLock (number): The time delay judging if the lock was left out mistakenly\n               after a system crash or other unexpected reasons. Normally Locker is stable\n               and takes care of not leaving any locking file hanging even it crashes or it\n               is forced to stop by a user signal.\n        \"\"\"\n        try:\n            deadLock = float(deadLock)\n            assert deadLock>=0\n        except:\n            raise Exception('deadLock must be a positive number')\n        self.__deadLock = deadLock"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef acquire_lock(self, verbose=VERBOSE, raiseError=RAISE_ERROR):\n        #### ON WINDOWS MUST LOOK INTO THAT IN ORDER TO GET RID OF os.rename\n        #### http://code.activestate.com/recipes/577794-win32-named-mutex-class-for-system-wide-mutex/\n        # set acquire flag\n        code         = 0\n        acquired     = False\n        t0 = t1      = time.time()\n        LP           = self.__lockPass+'\\n'\n        bytesLP      = LP.encode()\n        _lockingText = LP+'%.6f'+('\\n%s'%self.__pid)\n        _timeout     = self.__timeout\n        # set general while loop with timeout condition\n        while (t1-t0)<=_timeout:\n            # try to set acquired to True by reading an empty lock file\n            try:\n                while not acquired and (t1-t0)<=_timeout:\n                    if os.path.isfile(self.__lockPath):\n                        try:\n                            with open(self.__lockPath, 'rb') as fd:\n                                lock = fd.readlines()\n                        except:\n                            # for the few time when lockPath got deleted or not available for reading\n                            pass\n                        else:\n                            # lock file is empty or wrong\n                            if len(lock) != 3:\n                                code     = 0\n                                acquired = True\n                                break\n                            if lock[0] == bytesLP:\n                                code     = 1\n                                acquired = True\n                                break\n                            if t1-float(lock[1]) > self.__deadLock: # check dead lock\n                                acquired = True\n                                code     = 2\n                                break\n                            if not pid_exists(int(lock[2])): # check for dead process which means lock is dead\n                                acquired = True\n                                code     = 2\n                                break\n                        # wait a bit\n                        if self.__wait:\n                            time.sleep(self.__wait)\n                        t1 = time.time()\n                    else:\n                        acquired = True\n                        break\n            except Exception as err:\n                code     = Exception( \"Failed to check the lock (%s)\"%(str(err),) )\n                acquired = False\n                if verbose: print(str(code))\n                if raiseError: raise code\n            # impossible to acquire because of an error or timeout.\n            if not acquired:\n                break\n            # try to write lock\n            try:\n                tic = time.time()\n                tmpFile = self.__lockPath\n                # this is how to avoid multiple file writing os lock\n                # must be tried on nt (windows) and tested for solution\n                # os.rename on nt will crash if destination exists.\n                if os.name=='posix':\n                    tmpFile = '%s_%s'%(self.__lockPath,self.__uniqueID)\n                with open(tmpFile, 'wb') as fd:\n                    fd.write( str(_lockingText%t1).encode() )\n                    fd.flush()\n                    os.fsync(fd.fileno())\n                if os.name=='posix':\n                    os.rename(tmpFile,self.__lockPath)\n                toc = time.time()\n                if toc-tic >1:\n                    print(\"PID '%s' writing '%s' is delayed by os for %s seconds. Lock timeout adjusted. MUST FIND A WAY TO FIX THAT\"%(self.__pid,self.__lockPath,str(toc-tic)))\n                    _timeout += toc-tic\n            except Exception as err:\n                code     = Exception(\"Failed to write the lock (%s)\"%(str(err),) )\n                acquired = False\n                if verbose: print(str(code))\n                if raiseError: raise code\n                break\n            # sleep for double tic-toc or 0.1 ms which ever one is bigger\n            s = max([(toc-tic), 0.0001])\n            time.sleep(s)\n            # check if lock is still acquired by the same lock pass\n            try:\n                with open(self.__lockPath, 'rb') as fd:\n                    lock = fd.readlines()\n            except:\n                lock = []\n            if len(lock) >= 1:\n                if lock[0] == bytesLP:\n                    acquired = True\n                    break\n                else:\n                    acquired = False\n                    t1  = time.time()\n                    continue\n            else:\n                acquired = False\n                t1 = time.time()\n                continue\n        # return whether it is acquired or not\n        if not acquired and not code:\n            code = 3\n        return acquired, code", "response": "Attempts to acquire the lock for the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef release_lock(self, verbose=VERBOSE, raiseError=RAISE_ERROR):\n        if not os.path.isfile(self.__lockPath):\n            released = True\n            code     = 0\n        else:\n            try:\n                with open(self.__lockPath, 'rb') as fd:\n                    lock = fd.readlines()\n            except Exception as err:\n                code     = Exception( \"Unable to read release lock file '%s' (%s)\"%(self.__lockPath,str(err)) )\n                released = False\n                if verbose: print(str(code))\n                if raiseError: raise code\n            else:\n                if not len(lock):\n                    code     = 1\n                    released = True\n                elif lock[0].rstrip() == self.__lockPass.encode():\n                    try:\n                        with open(self.__lockPath, 'wb') as f:\n                            #f.write( ''.encode('utf-8') )\n                            f.write( ''.encode() )\n                            f.flush()\n                            os.fsync(f.fileno())\n                    except Exception as err:\n                        released = False\n                        code     = Exception( \"Unable to write release lock file '%s' (%s)\"%(self.__lockPath,str(err)) )\n                        if verbose: print(str(code))\n                        if raiseError: raise code\n                    else:\n                        released = True\n                        code     = 2\n                else:\n                    code     = 4\n                    released = False\n        # close file descriptor if lock is released and descriptor is not None\n        if released and self.__fd is not None:\n            try:\n                if not self.__fd.closed:\n                    self.__fd.flush()\n                    os.fsync(self.__fd.fileno())\n                    self.__fd.close()\n            except Exception as err:\n                code = Exception( \"Unable to close file descriptor of locked file '%s' (%s)\"%(self.__filePath,str(err)) )\n                if verbose: print(str(code))\n                if raiseError: raise code\n            else:\n                code = 3\n        # return\n        return released, code", "response": "Release the lock when set and close file descriptor if opened."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_syscal_bin(self, filename, **kwargs):\n        timestep = kwargs.get('timestep', None)\n        if 'timestep' in kwargs:\n            del (kwargs['timestep'])\n        self.logger.info('IRIS Syscal Pro bin import')\n        with LogDataChanges(self, filter_action='import'):\n            data, electrodes, topography = reda_syscal.import_bin(\n                filename, **kwargs\n            )\n            if timestep is not None:\n                data['timestep'] = timestep\n            self._add_to_container(data)\n        if kwargs.get('verbose', False):\n            print('Summary:')\n            self._describe_data(data)", "response": "Imports the Syscal bin file and adds it to the current container."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nimports BERT OHM file into a container.", "response": "def import_bert(self, filename, **kwargs):\n        \"\"\"BERT .ohm file import\"\"\"\n        timestep = kwargs.get('timestep', None)\n        if 'timestep' in kwargs:\n            del (kwargs['timestep'])\n\n        self.logger.info('Unified data format (BERT/pyGIMLi) file import')\n        with LogDataChanges(self, filter_action='import',\n                            filter_query=os.path.basename(filename)):\n            data, electrodes, topography = reda_bert_import.import_ohm(\n                filename, **kwargs)\n            if timestep is not None:\n                data['timestep'] = timestep\n            self._add_to_container(data)\n            self.electrode_positions = electrodes  # See issue #22\n        if kwargs.get('verbose', False):\n            print('Summary:')\n            self._describe_data(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a copy of the data inside a TDIP container", "response": "def to_ip(self):\n        \"\"\"Return of copy of the data inside a TDIP container\n        \"\"\"\n        if 'chargeability' in self.data.columns:\n            tdip = reda.TDIP(data=self.data)\n        else:\n            raise Exception('Missing column \"chargeability\"')\n        return tdip"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sub_filter(self, subset, filter, inplace=True):\n        # build the full query\n        full_query = ''.join(('not (', subset, ') or not (', filter, ')'))\n        with LogDataChanges(self, filter_action='filter', filter_query=filter):\n            result = self.data.query(full_query, inplace=inplace)\n        return result", "response": "Apply a filter to subset of the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter(self, query, inplace=True):\n        with LogDataChanges(self, filter_action='filter', filter_query=query):\n            result = self.data.query(\n                'not ({0})'.format(query),\n                inplace=inplace,\n            )\n        return result", "response": "Use a query statement to filter the data for the specified log entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compute_K_analytical(self, spacing):\n        K = redaK.compute_K_analytical(self.data, spacing=spacing)\n        self.data = redaK.apply_K(self.data, K)\n        redafixK.fix_sign_with_K(self.data)", "response": "Compute geometrical factors over the homogeneous half - space with electrode spacing"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots a pseudosection of the given column.", "response": "def pseudosection(self, column='r', filename=None, log10=False, **kwargs):\n        \"\"\"Plot a pseudosection of the given column. Note that this function\n        only works with dipole-dipole data at the moment.\n\n        Parameters\n        ----------\n        column : string, optional\n            Column to plot into the pseudosection, default: r\n        filename : string, optional\n            if not None, save the resulting figure directory to disc\n        log10 : bool, optional\n            if True, then plot values in log10, default: False\n        **kwargs : dict\n            all additional parameters are directly provided to\n            :py:func:`reda.plotters.pseudoplots.PS.plot_pseudosection_type2`\n\n        Returns\n        -------\n        fig : :class:`matplotlib.Figure`\n            matplotlib figure object\n            ax : :class:`matplotlib.axes`\n            matplotlib axes object\n        cb : colorbar object\n            matplotlib colorbar object\n        \"\"\"\n        fig, ax, cb = PS.plot_pseudosection_type2(\n                self.data, column=column, log10=log10, **kwargs\n        )\n        if filename is not None:\n            fig.savefig(filename, dpi=300)\n        return fig, ax, cb"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots a histogram of one data column", "response": "def histogram(self, column='r', filename=None, log10=False, **kwargs):\n        \"\"\"Plot a histogram of one data column\"\"\"\n        return_dict = HS.plot_histograms(self.data, column)\n        if filename is not None:\n            return_dict['all'].savefig(filename, dpi=300)\n        return return_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes one or more measurements by index of the DataFrame.", "response": "def delete_measurements(self, row_or_rows):\n        \"\"\"Delete one or more measurements by index of the DataFrame.\n\n        Resets the DataFrame index.\n\n        Parameters\n        ----------\n        row_or_rows : int or list of ints\n            Row numbers (starting with zero) of the data DataFrame (ert.data)\n            to delete\n\n        Returns\n        -------\n\n        None\n        \"\"\"\n        self.data.drop(self.data.index[row_or_rows], inplace=True)\n        self.data = self.data.reset_index()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_configs(self):\n        config_obj = reda.configs.configManager.ConfigManager()\n        config_obj.add_to_configs(self.data[['a', 'b', 'm', 'n']].values)\n        return config_obj", "response": "Return a config object that contains the measurement configurations\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_image(self, source):\n        buf = StringIO(source.read())\n        return Image.open(buf)", "response": "Loads an image from a file - like object and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if the supplied raw data is valid image data.", "response": "def is_valid_image(self, raw_data):\n        \"\"\"\n        Checks if the supplied raw data is valid image data.\n\n        :param str raw_data: A string representation of the image data.\n        :rtype: bool\n        :returns: ``True`` if ``raw_data`` is valid, ``False`` if not.\n        \"\"\"\n        buf = StringIO(raw_data)\n        try:\n            trial_image = Image.open(buf)\n            trial_image.verify()\n        except Exception:\n            # TODO: Get more specific with this exception handling.\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _colorspace(self, image, colorspace):\n        if colorspace == 'RGB':\n            if image.mode == 'RGBA':\n                # RGBA is just RGB + Alpha\n                return image\n            if image.mode == 'P' and 'transparency' in image.info:\n                return image.convert('RGBA')\n            return image.convert('RGB')\n        if colorspace == 'GRAY':\n            return image.convert('L')\n        return image", "response": "Sets the image s colorspace."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the raw data from the image which can be directly written to a file - like object or a database.", "response": "def _get_raw_data(self, image, format, quality):\n        \"\"\"\n        Returns the raw data from the Image, which can be directly written\n        to a something, be it a file-like object or a database.\n\n        :param PIL.Image image: The image to get the raw data for.\n        :param str format: The format to save to. If this value is ``None``,\n            PIL will attempt to guess. You're almost always better off\n            providing this yourself. For a full list of formats, see the PIL\n            handbook at:\n            http://www.pythonware.com/library/pil/handbook/index.htm\n            The *Appendixes* section at the bottom, in particular.\n        :param int quality: A quality level as a percent. The lower, the\n            higher the compression, the worse the artifacts. Check the\n            format's handbook page for what the different values for this mean.\n            For example, JPEG's max quality level is 95, with 100 completely\n            disabling JPEG quantization.\n        :rtype: str\n        :returns: A string representation of the image.\n        \"\"\"\n        ImageFile.MAXBLOCK = 1024 * 1024\n        buf = StringIO()\n\n        try:\n            # ptimize makes the encoder do a second pass over the image, if\n            # the format supports it.\n            image.save(buf, format=format, quality=quality, optimize=1)\n        except IOError:\n            # optimize is a no-go, omit it this attempt.\n            image.save(buf, format=format, quality=quality)\n\n        raw_data = buf.getvalue()\n        buf.close()\n        return raw_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all permissions for a given list of identifiers.", "response": "def get_permissions_query(session, identifier_s):\n    \"\"\"\n    :type identifier_s: list\n    \"\"\"\n    thedomain = case([(Domain.name == None, '*')], else_=Domain.name)\n    theaction = case([(Action.name == None, '*')], else_=Action.name)\n    theresource = case([(Resource.name == None, '*')], else_=Resource.name)\n\n    action_agg = func.group_concat(theaction.distinct())\n    resource_agg = func.group_concat(theresource.distinct())\n\n    return (session.query(thedomain + ':' + action_agg + ':' + resource_agg).\n            select_from(User).\n            join(role_membership, User.pk_id == role_membership.c.user_id).\n            join(role_permission, role_membership.c.role_id == role_permission.c.role_id).\n            join(Permission, role_permission.c.permission_id == Permission.pk_id).\n            outerjoin(Domain, Permission.domain_id == Domain.pk_id).\n            outerjoin(Action, Permission.action_id == Action.pk_id).\n            outerjoin(Resource, Permission.resource_id == Resource.pk_id).\n            filter(User.identifier.in_(identifier_s)).\n            group_by(Permission.domain_id, Permission.resource_id))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nemit the specified event (notify listeners)", "response": "def emit_event(self, event):\n        \"\"\"Emit the specified event (notify listeners)\"\"\"\n        with self._lock:\n            listeners = list(self._event_listeners)\n\n        for cb in list(self._event_listeners):\n            # noinspection PyBroadException\n            try:\n                cb(event)\n            except:\n                # Don't let exceptions from callbacks kill our thread of execution\n                logger.exception(\"Event callback resulted in unhandled exception\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nenables the stream thread This operation will ensure that the thread that is responsible is connected to the WVA and that the event listener thread is started.", "response": "def enable(self):\n        \"\"\"Enable the stream thread\n\n        This operation will ensure that the thread that is responsible\n        for connecting to the WVA and triggering event callbacks is started.\n        This thread will continue to run and do what it needs to do to\n        maintain a connection to the WVA.\n\n        The status of the thread can be monitored by calling :meth:`get_status`.\n        \"\"\"\n        with self._lock:\n            if self._event_listener_thread is None:\n                self._event_listener_thread = WVAEventListenerThread(self, self._http_client)\n                self._event_listener_thread.start()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef disable(self):\n        with self._lock:\n            if self._event_listener_thread is not None:\n                self._event_listener_thread.stop()\n                self._event_listener_thread = None", "response": "Disconnect from the event stream"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_status(self):\n        with self._lock:\n            if self._event_listener_thread is None:\n                return EVENT_STREAM_STATE_DISABLED\n            else:\n                return self._event_listener_thread.get_state()", "response": "Get the current status of the event stream system."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_one_event(self):\n        # WVA includes \\r\\n between messages which the parser doesn't like, so we\n        # throw away any data before a opening brace\n        try:\n            open_brace_idx = self._buf.index('{')\n        except ValueError:\n            self._buf = six.u('')  # no brace found\n        else:\n            if open_brace_idx > 0:\n                self._buf = self._buf[open_brace_idx:]\n\n        try:\n            event, idx = self._decoder.raw_decode(self._buf)\n            self._buf = self._buf[idx:]\n            return event\n        except ValueError:\n            return None", "response": "Parse the stream buffer and return either a single event or None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlook at file contents and guess its correct encoding.", "response": "def guess_codec(file, errors=\"strict\", require_char=False):\n    \"\"\"Look at file contents and guess its correct encoding.\n\n    File must be open in binary mode and positioned at offset 0. If BOM\n    record is present then it is assumed to be UTF-8 or UTF-16 encoded\n    file. GEDCOM header is searched for CHAR record and encoding name\n    is extracted from it, if BOM record is present then CHAR record\n    must match BOM-defined encoding.\n\n    :param file: File object, must be open in binary mode.\n    :param str errors: Controls error handling behavior during string\n        decoding, accepts same values as standard `codecs.decode` method.\n    :param bool require_char: If True then exception is thrown if CHAR\n        record is not found in a header, if False and CHAR is not in the\n        header then codec determined from BOM or \"gedcom\" is returned.\n    :returns: Tuple (codec_name, bom_size)\n    :raises: :py:class:`CodecError` when codec name in file is unknown or\n        when codec name in file contradicts codec determined from BOM.\n    :raises: :py:class:`UnicodeDecodeError` when codec fails to decode\n        input lines and `errors` is set to \"strict\" (default).\n    \"\"\"\n\n    # mapping of gedcom character set specifiers to Python encoding names\n    gedcom_char_to_codec = {\n        'ansel': 'gedcom',\n    }\n\n    # check BOM first\n    bom_codec = check_bom(file)\n    bom_size = file.tell()\n    codec = bom_codec or 'gedcom'\n\n    # scan header until CHAR or end of header\n    while True:\n\n        # this stops at '\\n'\n        line = file.readline()\n        if not line:\n            raise IOError(\"Unexpected EOF while reading GEDCOM header\")\n\n        # do not decode bytes to strings here, reason is that some\n        # stupid apps split CONC record at byte level (in middle of\n        # of multi-byte characters). This implies that we can only\n        # work with encodings that have ASCII as single-byte subset.\n\n        line = line.lstrip().rstrip(b\"\\r\\n\")\n        words = line.split()\n\n        if len(words) >= 2 and words[0] == b\"0\" and words[1] != b\"HEAD\":\n            # past header but have not seen CHAR\n            if require_char:\n                raise CodecError(\"GEDCOM header does not have CHAR record\")\n            else:\n                break\n        elif len(words) >= 3 and words[0] == b\"1\" and words[1] == b\"CHAR\":\n            try:\n                encoding = words[2].decode(codec, errors)\n                encoding = gedcom_char_to_codec.get(encoding.lower(),\n                                                    encoding.lower())\n                new_codec = codecs.lookup(encoding).name\n            except LookupError:\n                raise CodecError(\"Unknown codec name {0}\".format(encoding))\n            if bom_codec is None:\n                codec = new_codec\n            elif new_codec != bom_codec:\n                raise CodecError(\"CHAR codec {0} is different from BOM \"\n                                 \"codec {1}\".format(new_codec, bom_codec))\n            break\n\n    return codec, bom_size"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dialect(self):\n        if self._dialect is None:\n            self._dialect = model.DIALECT_DEFAULT\n            if self.header:\n                source = self.header.sub_tag(\"SOUR\")\n                if source:\n                    if source.value == \"MYHERITAGE\":\n                        self._dialect = model.DIALECT_MYHERITAGE\n                    elif source.value == \"ALTREE\":\n                        self._dialect = model.DIALECT_ALTREE\n                    elif source.value == \"ANCESTRIS\":\n                        self._dialect = model.DIALECT_ANCESTRIS\n        return self._dialect", "response": "Return the file dialect as one of model. DIALECT_* constants\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef records0(self, tag=None):\n        _log.debug(\"in records0\")\n        for offset, xtag in self.index0:\n            _log.debug(\"    records0: offset: %s; xtag: %s\", offset, xtag)\n            if tag is None or tag == xtag:\n                yield self.read_record(offset)", "response": "Iterator over all level = 0 records."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_record(self, offset):\n        _log.debug(\"in read_record(%s)\", offset)\n        stack = []  # stores per-level current records\n        reclevel = None\n        for gline in self.gedcom_lines(offset):\n            _log.debug(\"    read_record, gline: %s\", gline)\n            level = gline.level\n\n            if reclevel is None:\n                # this is the first record, remember its level\n                reclevel = level\n            elif level <= reclevel:\n                # stop at the record of the same or higher (smaller) level\n                break\n\n            # All previously seen records at this level and below can\n            # be finalized now\n            for rec in reversed(stack[level:]):\n                # decode bytes value into string\n                if rec:\n                    if rec.value is not None:\n                        rec.value = rec.value.decode(self._encoding,\n                                                     self._errors)\n                    rec.freeze()\n#                    _log.debug(\"    read_record, rec: %s\", rec)\n            del stack[level + 1:]\n\n            # extend stack to fit this level (and make parent levels if needed)\n            stack.extend([None] * (level + 1 - len(stack)))\n\n            # make Record out of it (it can be updated later)\n            parent = stack[level - 1] if level > 0 else None\n            rec = self._make_record(parent, gline)\n\n            # store as current record at this level\n            stack[level] = rec\n\n        for rec in reversed(stack[reclevel:]):\n            if rec:\n                if rec.value is not None:\n                    rec.value = rec.value.decode(self._encoding, self._errors)\n                rec.freeze()\n                _log.debug(\"    read_record, rec: %s\", rec)\n\n        return stack[reclevel] if stack else None", "response": "Reads next complete record from a file starting at given position."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _make_record(self, parent, gline):\n\n        if parent and gline.tag in (\"CONT\", \"CONC\"):\n            # concatenate, only for non-BLOBs\n            if parent.tag != \"BLOB\":\n                # have to be careful concatenating empty/None values\n                value = gline.value\n                if gline.tag == \"CONT\":\n                    value = b\"\\n\" + (value or b\"\")\n                if value is not None:\n                    parent.value = (parent.value or b\"\") + value\n            return None\n\n        # avoid infinite cycle\n        dialect = model.DIALECT_DEFAULT\n        if not (gline.level == 0 and gline.tag == \"HEAD\") and self._header:\n            dialect = self.dialect\n        rec = model.make_record(level=gline.level, xref_id=gline.xref_id,\n                                tag=gline.tag, value=gline.value,\n                                sub_records=[], offset=gline.offset,\n                                dialect=dialect, parser=self)\n\n        # add to parent's sub-records list\n        if parent:\n            parent.sub_records.append(rec)\n\n        return rec", "response": "This method creates a new record from the line read from file if needed and updates its parent record."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_options(subscription_key, text):\n    if not subscription_key or len(subscription_key) == 0:\n        print 'Error: Warning the option subscription_key should contain a string.'\n        print USAGE\n        sys.exit(3)\n    if not text or len(text) == 0:\n        print 'Error: Warning the option text should contain a string.'\n        print USAGE\n        sys.exit(3)", "response": "Perform sanity checks on threshold values\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse options and process text to Microsoft Translate", "response": "def main():\n    \"\"\"\n    Parse options and process text to Microsoft Translate\n    \"\"\"\n\n    # Parse arguments\n    parser = OptionParser()\n    parser.add_option('-n', '--subscription_key', dest='subscription_key',\n                      help='subscription_key for authentication')\n    parser.add_option('-t', '--text', dest='text',\n                      help='text to synthesize')\n    parser.add_option('-l', '--language', dest='language',\n                      help='language')\n    parser.add_option('-g', '--gender', dest='gender',\n                      help='gender')\n    parser.add_option('-d', '--directory', dest='directory',\n                      help='directory to store the file')\n    (options, args) = parser.parse_args()\n    subscription_key = options.subscription_key\n    text = options.text\n    language = options.language\n    gender = options.gender\n    directory = options.directory\n\n    # Perform sanity checks on options\n    validate_options(subscription_key, text)\n\n    if not directory:\n        directory = default_directory\n\n    if not language:\n        language = default_language\n\n    if not gender:\n        gender = default_gender\n\n    # format = 'riff-16khz-16bit-mono-pcm'\n    format = 'riff-8khz-8bit-mono-mulaw'\n\n    # lang = 'en-AU'\n    # gender = 'Female'\n    tts_msspeak = MSSpeak(subscription_key, '/tmp/')\n    tts_msspeak.set_cache(False)\n    output_filename = tts_msspeak.speak(text, language, gender, format)\n\n    print 'Recorded TTS to %s%s' % (directory, output_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sample(self):\n        # Response: {'VehicleSpeed': {'timestamp': '2015-03-20T18:00:49Z', 'value': 223.368515}}\n        data = self._http_client.get(\"vehicle/data/{}\".format(self.name))[self.name]\n        dt = arrow.get(data[\"timestamp\"]).datetime\n        value = data[\"value\"]\n        return VehicleDataSample(value, dt)", "response": "Get the current value of this vehicle data element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning correctly formatted host name for the given region.", "response": "def _get_host(self, region):\n        \"\"\"\n        Returns correctly formatted host. Accepted formats:\n\n            * simple region name, eg 'us-west-1' (see list in AWS_REGIONS)\n            * full host name, eg 's3-us-west-1.amazonaws.com'.\n        \"\"\"\n        if 'us-east-1' in region:\n            return 's3.amazonaws.com'\n        elif region in AWS_REGIONS:\n            return 's3-%s.amazonaws.com' % region\n        elif region and not REGION_RE.findall(region):\n            raise ImproperlyConfigured('AWS_REGION improperly configured!')\n        # can be full host or empty string, default region\n        return  region"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a bucket if it exists otherwise creates it.", "response": "def _get_or_create_bucket(self, name):\n        \"\"\"Retrieves a bucket if it exists, otherwise creates it.\"\"\"\n        try:\n            return self.connection.get_bucket(name)\n        except S3ResponseError, e:\n            if AUTO_CREATE_BUCKET:\n                return self.connection.create_bucket(name)\n            raise ImproperlyConfigured, (\"Bucket specified by \"\n            \"AWS_STORAGE_BUCKET_NAME does not exist. Buckets can be \"\n            \"automatically created by setting AWS_AUTO_CREATE_BUCKET=True\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef url(self, name):\n        name = urllib.quote_plus(self._clean_name(name), safe='/')\n\n        if self.bucket_cname:\n            return \"http://%s/%s\" % (self.bucket_cname, name)\n        elif self.host:\n            return \"http://%s/%s/%s\" % (self.host, self.bucket_name, name)\n        # No host ? Then it's the default region\n        return \"http://s3.amazonaws.com/%s/%s\" % (self.bucket_name, name)", "response": "Return the URL for the given key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalize_weekly(data):\n    if \"tblMenu\" not in data[\"result_data\"][\"Document\"]:\n        data[\"result_data\"][\"Document\"][\"tblMenu\"] = []\n    if isinstance(data[\"result_data\"][\"Document\"][\"tblMenu\"], dict):\n        data[\"result_data\"][\"Document\"][\"tblMenu\"] = [data[\"result_data\"][\"Document\"][\"tblMenu\"]]\n    for day in data[\"result_data\"][\"Document\"][\"tblMenu\"]:\n        if \"tblDayPart\" not in day:\n            continue\n        if isinstance(day[\"tblDayPart\"], dict):\n            day[\"tblDayPart\"] = [day[\"tblDayPart\"]]\n        for meal in day[\"tblDayPart\"]:\n            if isinstance(meal[\"tblStation\"], dict):\n                meal[\"tblStation\"] = [meal[\"tblStation\"]]\n            for station in meal[\"tblStation\"]:\n                if isinstance(station[\"tblItem\"], dict):\n                    station[\"tblItem\"] = [station[\"tblItem\"]]\n    return data", "response": "Normalizes for dining menu data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_meals(v2_response, building_id):\n    result_data = v2_response[\"result_data\"]\n    meals = []\n    day_parts = result_data[\"days\"][0][\"cafes\"][building_id][\"dayparts\"][0]\n    for meal in day_parts:\n        stations = []\n        for station in meal[\"stations\"]:\n            items = []\n            for item_id in station[\"items\"]:\n                item = result_data[\"items\"][item_id]\n                new_item = {}\n                new_item[\"txtTitle\"] = item[\"label\"]\n                new_item[\"txtPrice\"] = \"\"\n                new_item[\"txtNutritionInfo\"] = \"\"\n                new_item[\"txtDescription\"] = item[\"description\"]\n                new_item[\"tblSide\"] = \"\"\n                new_item[\"tblFarmToFork\"] = \"\"\n                attrs = [{\"description\": item[\"cor_icon\"][attr]} for attr in item[\"cor_icon\"]]\n                if len(attrs) == 1:\n                    new_item[\"tblAttributes\"] = {\"txtAttribute\": attrs[0]}\n                elif len(attrs) > 1:\n                    new_item[\"tblAttributes\"] = {\"txtAttribute\": attrs}\n                else:\n                    new_item[\"tblAttributes\"] = \"\"\n                if isinstance(item[\"options\"], list):\n                    item[\"options\"] = {}\n                if \"values\" in item[\"options\"]:\n                    for side in item[\"options\"][\"values\"]:\n                        new_item[\"tblSide\"] = {\"txtSideName\": side[\"label\"]}\n                items.append(new_item)\n            stations.append({\"tblItem\": items, \"txtStationDescription\": station[\"label\"]})\n        meals.append({\"tblStation\": stations, \"txtDayPartDescription\": meal[\"label\"]})\n    return meals", "response": "Extract meals from a DiningV2 JSON response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef menu(self, venue_id, date):\n        query = \"&date=\" + date\n        response = self._request(V2_ENDPOINTS['MENUS'] + venue_id + query)\n        return response", "response": "Get the menu for the venue corresponding to venue_id on date."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef venues(self):\n        response = self._request(V2_ENDPOINTS['VENUES'])\n        # Normalize `dateHours` to array\n        for venue in response[\"result_data\"][\"document\"][\"venue\"]:\n            if venue.get(\"id\") in VENUE_NAMES:\n                venue[\"name\"] = VENUE_NAMES[venue.get(\"id\")]\n            if isinstance(venue.get(\"dateHours\"), dict):\n                venue[\"dateHours\"] = [venue[\"dateHours\"]]\n            if \"dateHours\" in venue:\n                for dh in venue[\"dateHours\"]:\n                    if isinstance(dh.get(\"meal\"), dict):\n                        dh[\"meal\"] = [dh[\"meal\"]]\n        return response", "response": "Get a list of all venue objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef menu_daily(self, building_id):\n        today = str(datetime.date.today())\n        v2_response = DiningV2(self.bearer, self.token).menu(building_id, today)\n        response = {'result_data': {'Document': {}}}\n        response[\"result_data\"][\"Document\"][\"menudate\"] = datetime.datetime.strptime(today, '%Y-%m-%d').strftime('%-m/%d/%Y')\n        if building_id in VENUE_NAMES:\n            response[\"result_data\"][\"Document\"][\"location\"] = VENUE_NAMES[building_id]\n        else:\n            response[\"result_data\"][\"Document\"][\"location\"] = v2_response[\"result_data\"][\"days\"][0][\"cafes\"][building_id][\"name\"]\n        response[\"result_data\"][\"Document\"][\"tblMenu\"] = {\"tblDayPart\": get_meals(v2_response, building_id)}\n        return response", "response": "Get a daily menu for the given building_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef menu_weekly(self, building_id):\n        din = DiningV2(self.bearer, self.token)\n        response = {'result_data': {'Document': {}}}\n        days = []\n        for i in range(7):\n            date = str(datetime.date.today() + datetime.timedelta(days=i))\n            v2_response = din.menu(building_id, date)\n            if building_id in VENUE_NAMES:\n                response[\"result_data\"][\"Document\"][\"location\"] = VENUE_NAMES[building_id]\n            else:\n                response[\"result_data\"][\"Document\"][\"location\"] = v2_response[\"result_data\"][\"days\"][0][\"cafes\"][building_id][\"name\"]\n            formatted_date = datetime.datetime.strptime(date, '%Y-%m-%d').strftime('%-m/%d/%Y')\n            days.append({\"tblDayPart\": get_meals(v2_response, building_id), \"menudate\": formatted_date})\n        response[\"result_data\"][\"Document\"][\"tblMenu\"] = days\n        return normalize_weekly(response)", "response": "Return an array of menu objects corresponding to the weekly menu for the given building_id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlook up the latitude and longitude coordinates of a given location using the Google Maps API.", "response": "def latlon(location, throttle=0.5, center=True, round_digits=2):\n    '''Look up the latitude/longitude coordinates of a given location using the\n    Google Maps API. The result is cached to avoid redundant API requests.\n    \n    throttle: send at most one request in this many seconds\n    center: return the center of the region; if False, returns the region\n            (lat1, lon1, lat2, lon2)\n    round_digits: round coordinates to this many digits\n    '''\n\n    global last_read\n\n    if isinstance(location, list):\n        return map(lambda x: latlon(x, throttle=throttle, center=center, round_digits=round_digits),\n                   location)\n\n    if location in _latlons:\n        result = _latlons[location]\n        if center:\n            lat1, lon1, lat2, lon2 = result\n            result = (lat1+lat2)/2, (lon1+lon2)/2\n        return tuple([round(n, round_digits) for n in result])\n\n    while time.time() - last_read < throttle:\n        pass\n    last_read = time.time()\n\n    try:\n        url = \"http://maps.google.com/maps/api/geocode/json?address=%s&sensor=false\" % location.replace(' ', '+')\n        data = json.loads(urllib.urlopen(url).read())\n        if data['status'] == 'OVER_QUERY_LIMIT':\n            raise QueryLimitError('Google Maps API query limit exceeded. (Use the throttle keyword to control the request rate.')\n            \n        try:\n            bounds = data['results'][0]['geometry']['bounds']\n            result1 = bounds['northeast']\n            lat1, lon1 = result1['lat'], result1['lng']\n            result2 = bounds['southwest']\n            lat2, lon2 = result2['lat'], result2['lng']        \n        except KeyError:\n            bounds = data['results'][0]['geometry']['location']\n            lat1 = bounds['lat']\n            lon1 = bounds['lng']\n            lat2 = lat1\n            lon2 = lon1\n        except IndexError:\n            raise NoResultError('No result was found for location %s' % location)\n\n        _latlons[location] = (lat1, lon1, lat2, lon2)\n        save_cache()\n\n        if center: return round((lat1+lat2)/2, round_digits), round((lon1+lon2)/2, round_digits)\n        else: return tuple([round(n, round_digits) for n in (lat1, lon1, lat2, lon2)])\n        \n    except Exception as e:\n        raise\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_decay_curve(self, filename=None, index_nor=None, index_rec=None,\n                         nr_id=None, abmn=None,\n                         return_fig=False):\n        \"\"\"Plot decay curve\n\n        Input scheme: We recognize three ways to specify the quadrupoles to\n        plot (in descending priority):\n\n            1) indices for normal/reciprocal\n            2) by specifying the id\n            3) by specifying abmn (note that here the exact quadrupole must be\n               present. For example, when (1,2,4,3) is requested, (2,1,4,3)\n               will not be used).\n\n        Parameters\n        ----------\n        filename : string, optional\n            If given, filename to plot to.\n\n        Returns\n        -------\n        fig : :class:`matplotlib.Figure`\n            Figure object, only returned if return_fig=True\n\n        \"\"\"\n        def get_indices_for_id(norrec_id):\n            subquery_nor = self.data.query(\n                'id == {} and norrec == \"nor\"'.format(norrec_id)\n            )\n            if subquery_nor.shape[0] >= 1:\n                indices = [subquery_nor.index.values[0], ]\n            else:\n                indices = [None, ]\n\n            subquery_rec = self.data.query(\n                'id == {} and norrec == \"rec\"'.format(norrec_id)\n            )\n            if subquery_rec.shape[0] >= 1:\n                indices = indices + [subquery_rec.index.values[0], ]\n            else:\n                indices = indices + [None, ]\n            return indices\n\n        # select data to plot\n        # 1: indices\n        if index_nor is not None or index_rec is not None:\n            indices = [index_nor, index_rec]\n        elif nr_id is not None:\n            # reset the index\n            self.data.reset_index(drop=True, inplace=True)\n            indices = get_indices_for_id(nr_id)\n        elif abmn is not None:\n            subquery = self.data.query(\n                'a == {} and b == {} and m == {} and n == {}'.format(*abmn)\n            )\n            # print(abmn)\n            # print('subquery', subquery)\n            # import IPython\n            # IPython.embed()\n            if subquery.shape[0] > 0:\n                self.data.reset_index(drop=True, inplace=True)\n                indices = get_indices_for_id(subquery['id'].values[0])\n            else:\n                raise Exception(\n                    'configuration not found. Perhaps electrodes were ' +\n                    'switched due to negative geometric factors?'\n                )\n        else:\n            raise Exception('No selection method successful!')\n\n        # plot\n        fig, axes = plt.subplots(1, 3, figsize=(15 / 2.54, 8 / 2.54))\n        labels = ('normal', 'reciprocal')\n\n        # gather data\n        data_list = []\n        data_normed_list = []\n        for nr, index in enumerate(indices):\n            if index is not None:\n                data = self.data.loc[index, 'Mx']\n                data_norm = data / self.data.loc[index, 'Iab']\n                data_list.append(data)\n                data_normed_list.append(data_norm)\n            else:\n                data_list.append(None)\n                data_normed_list.append(None)\n\n        for nr, index in enumerate(indices):\n            if index is None:\n                continue\n            mdelay = self.data.loc[index, 'mdelay']\n            times = self.data.loc[index, 'Tm']\n            mtime = mdelay + np.cumsum(times)\n\n            ax = axes[0]\n            ax.plot(mtime, data_list[nr], '.-', label=labels[nr])\n\n            ax = axes[1]\n            ax.plot(\n                mtime, data_normed_list[nr], '.-', label=labels[nr] +\n                ' I: {:.1f}mA'.format(self.data.loc[index, 'Iab'])\n            )\n\n        ax = axes[2]\n        if indices[0] is not None and indices[1] is not None:\n            residuals = np.array(data_list[1]) - np.array(data_list[0])\n            ax.plot(mtime, residuals, '.-', color='r')\n            ax.set_xlabel('time [ms]')\n            ax.set_ylabel('residual [mV]')\n        else:\n            ax.set_visible(False)\n\n        # set labels etc.\n        ax = axes[0]\n        ax.legend(loc='best', fontsize=6.0)\n        ax.set_xlabel('time [ms]')\n        ax.set_ylabel('m [mV/V]')\n\n        ax = axes[1]\n        ax.set_ylabel('normalized decay curve [-]', fontsize=7.0)\n        ax.set_title(r'normed on current', fontsize=6.0)\n        ax.legend(loc='best', fontsize=6.0)\n\n        fig.tight_layout()\n        if filename is not None:\n            fig.savefig(filename, dpi=300)\n\n        if return_fig:\n            return fig\n        else:\n            fig.clf()\n            plt.close(fig)", "response": "Plot the decay curve for the current language."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_cr(self):\n        data_new = self.data.copy()\n        data_new['rpha'] = -1.5 * data_new['chargeability']\n        # now that we have magnitude and phase, compute the impedance Zt\n        data_new['Zt'] = data_new['r'] * np.exp(data_new['rpha'] * 1j / 1000.0)\n        cr = reda.CR(data=data_new)\n        return cr", "response": "Convert the current state of the object to a complex resistivity container."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmanufacturing decorator that filters return value with given function.", "response": "def apply(filter):\n    \"\"\"Manufacture decorator that filters return value with given function.\n\n    ``filter``:\n      Callable that takes a single parameter.\n    \"\"\"\n    def decorator(callable):\n        return lambda *args, **kwargs: filter(callable(*args, **kwargs))\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat an output filename pattern for the given transaction.", "response": "def format_outpat(outpat, xn):\n    \"\"\"\n    Format an outpat for the given transaction.\n\n    Format the given output filename pattern.  The pattern should\n    be a format string with any combination of the following named\n    fields:\n\n    ``year``\n      The year of the transaction.\n    ``month``\n      The month of the transaction, with leading zero for\n      single-digit months.\n    ``fy``\n      The financial year of the transaction (being the year in\n      which the financial year of the transaction *ends*).\n      A financial year runs from 1 July to 30 June.\n    ``date``\n      The date object itself.  The format string may specify\n      any attribute of the date object, e.g. ``{date.day}``.\n      This field is deprecated.\n    \"\"\"\n    return outpat.format(\n        year=str(xn.date.year),\n        month='{:02}'.format(xn.date.month),\n        fy=str(xn.date.year if xn.date.month < 7 else xn.date.year + 1),\n        date=xn.date\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, name, acc=None, default=None):\n        if acc in self.data['accounts'] and name in self.data['accounts'][acc]:\n            return self.data['accounts'][acc][name]\n        if name in self.data:\n            return self.data[name]\n        return default", "response": "Return the named config for the given account."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef outdir(self, acc=None):\n        rootdir = self.rootdir()\n        outdir = self.get('outdir', acc=acc)\n        dir = os.path.join(rootdir, outdir) if rootdir and outdir else None\n        if not os.path.exists(dir):\n            os.makedirs(dir)\n        return dir", "response": "Return the outdir for the given account."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine the full outfile pattern for the given account.", "response": "def outpat(self, acc=None):\n        \"\"\"\n        Determine the full outfile pattern for the given account.\n\n        Return None if not specified.\n        \"\"\"\n        outdir = self.outdir(acc)\n        outpat = self.get('outpat', acc=acc)\n        return os.path.join(outdir, outpat) if outdir and outpat else None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rulesdir(self, acc=None):\n        rootdir = self.rootdir()\n        rulesdir = self.get('rulesdir', acc=acc, default=[])\n        return os.path.join(rootdir, rulesdir) \\\n            if rootdir and rulesdir else None", "response": "Return the rulesdir for the given account."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of rulefiles for the given account.", "response": "def rulefiles(self, acc=None):\n        \"\"\"Return a list of rulefiles for the given account.\n\n        Returns an empty list if none specified.\n        \"\"\"\n        rulesdir = self.rulesdir(acc)\n        rules = [os.path.join(rulesdir, x) for x in self.get('rules', acc, [])]\n        if acc is not None:\n            rules += self.rulefiles(acc=None)\n        return rules"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload data from a separate data repository for testing.", "response": "def download_data(identifier, outdir):\n    \"\"\"Download data from a separate data repository for testing.\n\n    Parameters\n    ----------\n    identifier: string\n        The identifier used to find the data set\n    outdir: string\n        unzip the data in this directory\n    \"\"\"\n    # determine target\n    if use_local_data_repository is not None:\n        url_base = 'file:' + request.pathname2url(\n            use_local_data_repository + os.sep)\n    else:\n        url_base = repository_url\n\n    print('url_base: {}'.format(url_base))\n    url = url_base + inventory_filename\n    # download inventory file\n    filename, headers =request.urlretrieve(url)\n\n    df = pd.read_csv(\n        filename,\n        delim_whitespace=True,\n        comment='#',\n        header=None,\n        names=['identifier', 'rel_path'],\n    )\n\n    # find relative path to data file\n    rel_path_query = df.query('identifier == \"{}\"'.format(identifier))\n    if rel_path_query.shape[0] == 0:\n        raise Exception('identifier not found')\n    rel_path = rel_path_query['rel_path'].values[0]\n\n    # download the file\n    url = url_base + rel_path\n    print('data url: {}'.format(url))\n    filename, headers =request.urlretrieve(url)\n\n    if not os.path.isdir(outdir):\n        os.makedirs(outdir)\n\n    zip_obj = zipfile.ZipFile(filename)\n    zip_obj.extractall(outdir)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef visitAnnotation(self, ctx: ShExDocParser.AnnotationContext):\n        # Annotations apply to the expression, NOT the shape (!)\n        annot = Annotation(self.context.predicate_to_IRI(ctx.predicate()))\n        if ctx.iri():\n            annot.object = self.context.iri_to_iriref(ctx.iri())\n        else:\n            annot.object = self.context.literal_to_ObjectLiteral(ctx.literal())\n        self.annotations.append(annot)", "response": "Annotation is an annotation that is a predicate iri | literal"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvisit CodeDeclContext - > add semact to self. semacts", "response": "def visitCodeDecl(self, ctx: ShExDocParser.CodeDeclContext):\n        \"\"\" codeDecl: '%' iri (CODE | '%') \n            CODE: : '{' (~[%\\\\] | '\\\\' [%\\\\] | UCHAR)* '%' '}' \"\"\"\n        semact = SemAct()\n        semact.name = self.context.iri_to_iriref(ctx.iri())\n        if ctx.CODE():\n            semact.code = ctx.CODE().getText()[1:-2].replace('\\\\%', '%').encode('utf-8').decode('unicode-escape')\n        self.semacts.append(semact)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, item):\n        if item in self:\n            self.items[item[0]].append(item[1])\n        else:\n            self.items[item[0]] = [item[1]]", "response": "Append an item to the score set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scores(self):\n        return map(\n            lambda x: (x[0], sum(x[1]) * len(x[1]) ** -.5),\n            iter(self.items.viewitems())\n        )", "response": "Return a list of the items with their final scores."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the items with the higest score.", "response": "def highest(self):\n        \"\"\"Return the items with the higest score.\n\n        If this ScoreSet is empty, returns None.\n        \"\"\"\n        scores = self.scores()\n        if not scores:\n            return None\n        maxscore = max(map(score, scores))\n        return filter(lambda x: score(x) == maxscore, scores)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting an IRIREF to a string.", "response": "def iriref_to_str(self, ref: ShExDocParser.IRIREF) -> str:\n        \"\"\" IRIREF: '<' (~[\\u0000-\\u0020=<>\\\"{}|^`\\\\] | UCHAR)* '>' \"\"\"\n        rval = ref.getText()[1:-1].encode('utf-8').decode('unicode-escape')\n        return rval if ':' in rval or not self.base else self.base.val + rval"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a ShExDocParser. IRIREF to a ShExJ. IRIREF", "response": "def iriref_to_shexj_iriref(self, ref: ShExDocParser.IRIREF) -> ShExJ.IRIREF:\n        \"\"\"  IRIREF: '<' (~[\\u0000-\\u0020=<>\\\"{}|^`\\\\] | UCHAR)* '>'\n             IRI: (PN_CHARS | '!' | ''.' | ':' | '/' | '\\\\' | '#' | '@' | '%' | '&' | UCHAR)* \"\"\"\n        return ShExJ.IRIREF(self.iriref_to_str(ref))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prefixedname_to_str(self, prefix: ShExDocParser.PrefixedNameContext) -> str:\n        if prefix.PNAME_NS():\n            return self._lookup_prefix(prefix.PNAME_NS().getText())\n        else:\n            prefix, local = prefix.PNAME_LN().getText().split(':', 1)\n            return self._lookup_prefix(prefix + ':') + (local if local else \"\")", "response": "Returns the string representation of a prefixed name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef prefixedname_to_iriref(self, prefix: ShExDocParser.PrefixedNameContext) -> ShExJ.IRIREF:\n        return ShExJ.IRIREF(self.prefixedname_to_str(prefix))", "response": "Converts a prefixed name to an IRIREF."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef shapeRef_to_iriref(self, ref: ShExDocParser.ShapeRefContext) -> ShExJ.IRIREF:\n        if ref.ATPNAME_NS():\n            return ShExJ.IRIREF(self._lookup_prefix(ref.ATPNAME_NS().getText()[1:]))\n        elif ref.ATPNAME_LN():\n            prefix, local = ref.ATPNAME_LN().getText()[1:].split(':', 1)\n            return ShExJ.IRIREF(self._lookup_prefix(prefix + ':') + (local if local else \"\"))\n        else:\n            return self.shapeexprlabel_to_IRI(ref.shapeExprLabel())", "response": "Convert a ShExShapeRefContext to an IRIREF."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iri_to_str(self, iri_: ShExDocParser.IriContext) -> str:\n        if iri_.IRIREF():\n            return self.iriref_to_str(iri_.IRIREF())\n        else:\n            return self.prefixedname_to_str(iri_.prefixedName())", "response": "Converts an IRI to a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iri_to_iriref(self, iri_: ShExDocParser.IriContext) -> ShExJ.IRIREF:\n        return ShExJ.IRIREF(self.iri_to_str(iri_))", "response": "Converts an IRI to an IRIREF."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a triple expression label to an IRIREF.", "response": "def tripleexprlabel_to_iriref(self, tripleExprLabel: ShExDocParser.TripleExprLabelContext) \\\n            -> Union[ShExJ.BNODE, ShExJ.IRIREF]:\n        \"\"\" tripleExprLabel: iri | blankNode \"\"\"\n        if tripleExprLabel.iri():\n            return self.iri_to_iriref(tripleExprLabel.iri())\n        else:\n            return ShExJ.BNODE(tripleExprLabel.blankNode().getText())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef predicate_to_IRI(self, predicate: ShExDocParser.PredicateContext) -> ShExJ.IRIREF:\n        if predicate.iri():\n            return self.iri_to_iriref(predicate.iri())\n        else:\n            return RDF_TYPE", "response": "Converts predicate to IRIREF"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a numeric literal to a type in the format of Int Decimal or Double.", "response": "def numeric_literal_to_type(numlit: ShExDocParser.NumericLiteralContext) -> Union[jsg.Integer, jsg.Number]:\n        \"\"\" numericLiteral: INTEGER | DECIMAL | DOUBLE \"\"\"\n        if numlit.INTEGER():\n            rval = jsg.Integer(str(int(numlit.INTEGER().getText())))\n        elif numlit.DECIMAL():\n            rval = jsg.Number(str(float(numlit.DECIMAL().getText())))\n        else:\n            rval = jsg.Number(str(float(numlit.DOUBLE().getText())))\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a literal to an object literal.", "response": "def literal_to_ObjectLiteral(self, literal: ShExDocParser.LiteralContext) -> ShExJ.ObjectLiteral:\n        \"\"\" literal: rdfLiteral | numericLiteral | booleanLiteral \"\"\"\n        rval = ShExJ.ObjectLiteral()\n        if literal.rdfLiteral():\n            rdflit = literal.rdfLiteral()\n            txt = rdflit.string().getText()\n            quote_char = ''\n            if len(txt) > 5 and (txt.startswith(\"'''\") and txt.endswith(\"'''\") or\n                                 txt.startswith('\"\"\"') and txt.endswith('\"\"\"')):\n                txt = txt[3:-3]\n            else:\n                quote_char = txt[0]\n                txt = txt[1:-1]\n\n            txt = self.fix_text_escapes(txt, quote_char)\n            rval.value = jsg.String(txt)\n            if rdflit.LANGTAG():\n                rval.language = ShExJ.LANGTAG(rdflit.LANGTAG().getText()[1:].lower())\n            if rdflit.datatype():\n                rval.type = self.iri_to_str(rdflit.datatype().iri())\n        elif literal.numericLiteral():\n            numlit = literal.numericLiteral()\n            if numlit.INTEGER():\n                rval.value = jsg.String(numlit.INTEGER().getText())\n                rval.type = RDF_INTEGER_TYPE\n            elif numlit.DECIMAL():\n                rval.value = jsg.String(numlit.DECIMAL().getText())\n                rval.type = RDF_DECIMAL_TYPE\n            elif numlit.DOUBLE():\n                rval.value = jsg.String(numlit.DOUBLE().getText())\n                rval.type = RDF_DOUBLE_TYPE\n        elif literal.booleanLiteral():\n            rval.value = jsg.String(literal.booleanLiteral().getText().lower())\n            rval.type = RDF_BOOL_TYPE\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_empty_shape(sh: ShExJ.Shape) -> bool:\n        return sh.closed is None and sh.expression is None and sh.extra is None and \\\n            sh.semActs is None", "response": "Determines whether the shape is empty."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fix_text_escapes(self, txt: str, quote_char: str) -> str:\n        def _subf(matchobj):\n            return matchobj.group(0).translate(self.re_trans_table)\n        if quote_char:\n            txt = re.sub(r'\\\\'+quote_char, quote_char, txt)\n        return re.sub(r'\\\\.', _subf, txt, flags=re.MULTILINE + re.DOTALL + re.UNICODE)", "response": "Fix the various text escapes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfixing the escape sequences in the text.", "response": "def fix_re_escapes(self, txt: str) -> str:\n        \"\"\" The ShEx RE engine allows escaping any character.  We have to remove that escape for everything except those\n        that CAN be legitimately escaped\n\n        :param txt: text to be escaped\n        \"\"\"\n        def _subf(matchobj):\n            # o = self.fix_text_escapes(matchobj.group(0))\n            o = matchobj.group(0).translate(self.re_trans_table)\n            if o[1] in '\\b\\f\\n\\t\\r':\n                return o[0] + 'bfntr'['\\b\\f\\n\\t\\r'.index(o[1])]\n            else:\n                return o if o[1] in '\\\\.?*+^$()[]{|}' else o[1]\n\n        return re.sub(r'\\\\.', _subf, txt, flags=re.MULTILINE + re.DOTALL + re.UNICODE)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cli(ctx, hpo_term, check_terms, output, p_value_limit, verbose, username, \n        password, to_json):\n    \"Give hpo terms either on the form 'HP:0001623', or '0001623'\"    \n    loglevel = LEVELS.get(min(verbose, 3))\n    configure_stream(level=loglevel)\n    \n    if not hpo_term:\n        logger.info(\"Please specify at least one hpo term with '-t/--hpo_term'.\")\n        ctx.abort()\n\n    if not (username and password):\n        logger.info(\"Please specify username with -u and password with -p.\")\n        logger.info(\"Contact sebastian.koehler@charite.de.\")\n        ctx.abort()\n    \n    hpo_list = []\n    for term in hpo_term:\n        if len(term.split(':')) < 2:\n            term = ':'.join(['HP', term])\n        hpo_list.append(term)\n    \n    logger.info(\"HPO terms used: {0}\".format(','.join(hpo_list)))\n    \n    if check_terms:\n        for term in hpo_list:\n            try:\n                if not validate_term(username, password, term):\n                    logger.info(\"HPO term : {0} does not exist\".format(term))\n                else:\n                    logger.info(\"HPO term : {0} does exist!\".format(term))\n            except RuntimeError as err:\n                click.echo(err)\n                ctx.abort()\n        ctx.abort()\n    else:\n        try:\n            for result in query(username, password, *hpo_list):\n                if to_json:\n                    click.echo(json.dumps(result))\n                else:\n                    print_string = \"{0}\\t{1}:{2}\\t{3}\\t{4}\".format(\n                        result['p_value'], \n                        result['disease_source'],\n                        result['disease_nr'],\n                        result['description'],\n                        ','.join(result['gene_symbols'])\n                    )\n                    p_value = result['p_value']\n                    if p_value <= p_value_limit:\n                        click.echo(print_string)\n                \n        except RuntimeError as e:\n            click.echo(e)\n            ctx.abort()", "response": "Give hpo terms either on the form HP :0001623 or HP :0001623"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _iter_response(self, url, params=None):\n        if params is None:\n            params = {}\n        params['page_number'] = 1\n\n        # Last page lists itself as next page\n        while True:\n            response = self._request(url, params)\n\n            for item in response['result_data']:\n                yield item\n\n            # Last page lists itself as next page\n            if response['service_meta']['next_page_number'] == params['page_number']:\n                break\n\n            params['page_number'] += 1", "response": "Return an enumerable that iterates through a multi - page API request"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search(self, params, validate=False):\n        if self.val_info is None:\n            self.val_info = self.search_params()\n\n        if validate:\n            errors = self.validate(self.val_info, params)\n        if not validate or len(errors) == 0:\n            return self._iter_response(ENDPOINTS['SEARCH'], params)\n        else:\n            return {'Errors': errors}", "response": "Search for a set of course entries."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef course(self, dept, course_number):\n        response = self._request(path.join(ENDPOINTS['CATALOG'], dept, course_number))\n        return response['result_data'][0]", "response": "Return an object of semester - independent course info. All arguments are strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a single section object for the given section. All arguments should be strings. Throws a ValueError if the section is not found.", "response": "def section(self, dept, course_number, sect_number):\n        \"\"\"Return a single section object for the given section. All arguments\n        should be strings. Throws a `ValueError` if the section is not found.\n\n        >>> lgst101_bfs = r.course('lgst', '101', '301')\n        \"\"\"\n        section_id = dept + course_number + sect_number\n        sections = self.search({'course_id': section_id})\n        try:\n            return next(sections)\n        except StopIteration:\n            raise ValueError('Section %s not found' % section_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(self, sentence):\n        self.asa.stdin.write(sentence.encode(self.encoding) + b'\\n')\n        self.asa.stdin.flush()\n        result = []\n        while not result:\n            with open(self.tempfile, 'r', encoding=self.encoding) as out:\n                asa_return = out.read()\n            if asa_return and asa_return.splitlines()[-1].startswith('input'):\n                result = self._parse_asa_return(asa_return)\n            time.sleep(0.1)\n        open(self.tempfile, 'w').close()  # Initialize temp file\n        return result", "response": "Parse the sentence into a list of dict."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_to_gvid(v):\n    from geoid.civick import GVid\n    from geoid.acs import AcsGeoid\n\n    m1 = ''\n\n    try:\n        return GVid.parse(v)\n    except ValueError as e:\n        m1 = str(e)\n\n    try:\n        return AcsGeoid.parse(v).convert(GVid)\n    except ValueError as e:\n        raise ValueError(\"Failed to parse to either ACS or GVid: {}; {}\".format(m1, str(e)))", "response": "Parse an ACS Geoid or a GVID to a GVID"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef base62_decode(string):\n\n    alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n    base = len(alphabet)\n    strlen = len(string)\n    num = 0\n\n    idx = 0\n    for char in string:\n        power = (strlen - (idx + 1))\n        num += alphabet.index(char) * (base ** power)\n        idx += 1\n\n    return int(num)", "response": "Decode a Base X encoded string into a number of base X words."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef augment(module_name, base_class):\n\n    for name, cls in inspect.getmembers(sys.modules[module_name],\n                                        lambda x : inspect.isclass(x) and  issubclass(x, base_class) ):\n        if cls == base_class:\n            continue\n\n        cls.augment()", "response": "Call the augment method for all derived classes in the module with the given name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate derived classes and put them into the same module as the base class.", "response": "def make_classes(base_class, module):\n    \"\"\"Create derived classes and put them into the same module as the base class.\n\n    This function is called at the end of each of the derived class modules, acs, census, civik and tiger.\n    It will create a set of new derived class in the module, one for  each of the enries in the `summary_levels`\n    dict.\n\n    \"\"\"\n    from functools import partial\n\n    for k in names:\n\n        cls = base_class.class_factory(k.capitalize())\n\n        cls.augment()\n\n        setattr(module, k.capitalize(), cls)\n\n    setattr(module, 'get_class', partial(get_class, module))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_all(sumlevel, d):\n\n    from geoid.civick import GVid\n    from geoid.tiger import TigerGeoid\n    from geoid.acs import AcsGeoid\n\n    sumlevel = int(sumlevel)\n\n    d = dict(d.items())\n\n    # Map common name variants\n    if 'cousub' in d:\n        d['cosub'] = d['cousub']\n        del d['cousub']\n\n    if 'blkgrp' in d:\n        d['blockgroup'] = d['blkgrp']\n        del d['blkgrp']\n\n    if 'zcta5' in d:\n        d['zcta'] = d['zcta5']\n        del d['zcta5']\n\n    gvid_class = GVid.resolve_summary_level(sumlevel)\n\n    if not gvid_class:\n        return {}\n\n    geoidt_class = TigerGeoid.resolve_summary_level(sumlevel)\n    geoid_class = AcsGeoid.resolve_summary_level(sumlevel)\n\n    try:\n        return dict(\n            gvid=str(gvid_class(**d)),\n            geoid=str(geoid_class(**d)),\n            geoidt=str(geoidt_class(**d))\n        )\n    except:\n        raise", "response": "Generate a dict that includes all of the available geoid values with keys\n    for the most common names for those values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncoding to generate the state and county names for the county and county", "response": "def _generate_names():\n    \"\"\" Code to generate the state and county names\n\n    >>> python -c 'import geoid; geoid._generate_names()'\n\n    \"\"\"\n\n    from ambry import get_library\n\n    l = get_library()\n\n    counties = l.partition('census.gov-acs-geofile-2009-geofile50-20095-50')\n    states = l.partition('census.gov-acs-geofile-2009-geofile40-20095-40')\n\n    names = {}\n    for row in counties.remote_datafile.reader:\n        names[(row.state, row.county)] = row.name\n\n    for row in states.remote_datafile.reader:\n        if row.component == '00':\n            names[(row.state, 0)] = row.name\n\n    pprint.pprint(names)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef division_name(self):\n        try:\n            return next(e for e in self.type_names_re.search(self.name).groups() if e is not None)\n        except AttributeError:\n            # The search will fail for 'District of Columbia'\n            return ''", "response": "The type designation for the county or county equivalent such as Parish Borough or District of Columbia"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naugment the class with computed formats regexes and other things. This is a utility function that is used to augment the class with computed formats and regexes and other things.", "response": "def augment(cls):\n        \"\"\"Augment the class with computed formats, regexes, and other things. This caches these values so\n        they don't have to be created for every instance. \"\"\"\n\n        import re\n\n        level_name = cls.__name__.lower()\n\n        cls.sl = names[level_name]\n\n        cls.class_map[cls.__name__.lower()] = cls\n\n        cls.sl_map[cls.sl] = cls\n\n        cls.fmt = cls.make_format_string(cls.__name__.lower())\n\n        cls.regex_str = cls.make_regex(cls.__name__.lower())\n        cls.regex = re.compile(cls.regex_str)\n\n        # List of field names\n        cls.level = level_name\n        cls.fields = segments[cls.sl]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a derived class based on the class name or the summary level", "response": "def get_class(cls, name_or_sl):\n        \"\"\"Return a derived class based on the class name or the summary_level\"\"\"\n        try:\n            return cls.sl_map[int(name_or_sl)]\n\n        except TypeError as e:\n            raise TypeError(\"Bad name or sl: {} : {}\".format(name_or_sl, e))\n        except ValueError:\n            try:\n                return cls.class_map[name_or_sl.lower()]\n            except (KeyError, ValueError):\n                raise NotASummaryName(\"Value '{}' is not a valid summary level\".format(name_or_sl))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef geo_name(self):\n        if self.level == 'county':\n            return str(self.county_name)\n\n        elif self.level == 'state':\n            return self.state_name\n\n        else:\n            if hasattr(self, 'county'):\n                return \"{} in {}\".format(self.level,str(self.county_name))\n\n            elif hasattr(self, 'state'):\n                return \"{} in {}\".format(self.level, self.state_name)\n\n            else:\n                return \"a {}\".format(self.level)", "response": "Return a name of the state or county or the other lowever levels."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a string value into the geoid of this class.", "response": "def parse(cls, gvid, exception=True):\n        \"\"\"\n        Parse a string value into the geoid of this class.\n\n        :param gvid: String value to parse.\n        :param exception: If true ( default) raise an eception on parse erorrs. If False, return a\n        'null' geoid.\n        :return:\n        \"\"\"\n\n        if gvid == 'invalid':\n            return cls.get_class('null')(0)\n\n        if not bool(gvid):\n            return None\n\n        if not isinstance(gvid, six.string_types):\n            raise TypeError(\"Can't parse; not a string. Got a '{}' \".format(type(gvid)))\n\n        try:\n            if not cls.sl:\n                # Civick and ACS include the SL, so can call from base type.\n                if six.PY3:\n                    fn = cls.decode\n                else:\n                    fn = cls.decode.__func__\n\n                sl = fn(gvid[0:cls.sl_width])\n            else:\n                sl = cls.sl  # Otherwise must use derived class.\n\n        except ValueError as e:\n            if exception:\n                raise ValueError(\"Failed to parse gvid '{}': {}\".format(gvid, str(e)))\n            else:\n                return cls.get_class('null')(0)\n\n        try:\n            cls = cls.sl_map[sl]\n        except KeyError:\n            if exception:\n                raise ValueError(\"Failed to parse gvid '{}': Unknown summary level '{}' \".format(gvid, sl))\n            else:\n                return cls.get_class('null')(0)\n\n        m = cls.regex.match(gvid)\n\n        if not m:\n            raise ValueError(\"Failed to match '{}' to '{}' \".format(gvid, cls.regex_str))\n\n        d = m.groupdict()\n\n        if not d:\n            return None\n\n        if six.PY3:\n            fn = cls.decode\n        else:\n            fn = cls.decode.__func__\n\n        d = {k: fn(v) for k, v in d.items()}\n\n        try:\n            del d['sl']\n        except KeyError:\n            pass\n\n        return cls(**d)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert to another derived class.", "response": "def convert(self, root_cls):\n        \"\"\"Convert to another derived class. cls is the base class for the derived type,\n        ie AcsGeoid, TigerGeoid, etc. \"\"\"\n\n        d = self.__dict__\n        d['sl'] = self.sl\n\n        try:\n            cls = root_cls.get_class(root_cls.sl)\n        except (AttributeError, TypeError):\n            # Hopefully because root_cls is a module\n            cls = root_cls.get_class(self.sl)\n\n        return cls(**d)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef promote(self, level=None):\n\n        if level is None:\n\n            if len(self.fields) < 2:\n                if self.level in ('region', 'division', 'state', 'ua'):\n                    cls = self.get_class('us')\n                else:\n                    return None\n            else:\n                cls = self.get_class(self.fields[-2])\n        else:\n            cls = self.get_class(level)\n\n        d = dict(self.__dict__.items())\n        d['sl'] = self.sl\n\n        return cls(**d)", "response": "Convert to the next higher level summary level"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef allval(self):\n\n        d = dict(self.__dict__.items())\n        d['sl'] = self.sl\n\n        d[self.level] = 0\n\n        cls = self.get_class(self.sl)\n\n        return cls(**d)", "response": "Convert the last value to zero. This form represents the entire higher summary level at the granularity\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new instance where all of the values are 0", "response": "def nullval(cls):\n        \"\"\"Create a new instance where all of the values are 0\"\"\"\n\n        d = dict(cls.__dict__.items())\n\n        for k in d:\n            d[k] = 0\n\n        d['sl'] = cls.sl\n        d[cls.level] = 0\n\n        return cls(**d)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsplit a full name into pieces of name.", "response": "def split_name(name):\n    \"\"\"Extracts pieces of name from full name string.\n\n    Full name can have one of these formats:\n        <NAME_TEXT> |\n        /<NAME_TEXT>/ |\n        <NAME_TEXT> /<NAME_TEXT>/ |\n        /<NAME_TEXT>/ <NAME_TEXT> |\n        <NAME_TEXT> /<NAME_TEXT>/ <NAME_TEXT>\n\n    <NAME_TEXT> can include almost anything excluding commas, numbers,\n    special characters (though some test files use numbers for the names).\n    Text between slashes is considered a surname, outside slashes - given\n    name.\n\n    This method splits full name into pieces at slashes, e.g.:\n\n        \"First /Last/\" -> (\"First\", \"Last\", \"\")\n        \"/Last/ First\" -> (\"\", \"Last\", \"First\")\n        \"First /Last/ Jr.\" -> (\"First\", \"Last\", \"Jr.\")\n        \"First Jr.\" -> (\"First Jr.\", \"\", \"\")\n\n    :param str name: Full name string.\n    :return: 2-tuple `(given1, surname, given2)`, `surname` or `given` will\n        be empty strings if they are not present in full string.\n    \"\"\"\n    given1, _, rem = name.partition(\"/\")\n    surname, _, given2 = rem.partition(\"/\")\n    return given1.strip(), surname.strip(), given2.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse NAME record assuming ALTREE dialect.", "response": "def parse_name_altree(record):\n    \"\"\"Parse NAME structure assuming ALTREE dialect.\n\n    In ALTREE dialect maiden name (if present) is saved as SURN sub-record\n    and is also appended to family name in parens. Given name is saved in\n    GIVN sub-record. Few examples:\n\n    No maiden name:\n\n        1 NAME John /Smith/\n        2 GIVN John\n\n    With maiden name:\n\n        1 NAME Jane /Smith (Ivanova)/\n        2 GIVN Jane\n        2 SURN Ivanova\n\n    No maiden name\n\n        1 NAME Mers /Daimler (-Benz)/\n        2 GIVN Mers\n\n    Because family name can also contain parens it's not enough to parse\n    family name and guess maiden name from it, we also have to check for\n    SURN record.\n\n    ALTREE also replaces empty names with question mark, we undo that too.\n\n    :param record: NAME record\n    :return: tuple with 3 or 4 elements, first three elements of tuple are\n        the same as returned from :py:meth:`split_name` method, fourth element\n        (if present) denotes maiden name.\n    \"\"\"\n    name_tuple = split_name(record.value)\n    if name_tuple[1] == '?':\n        name_tuple = (name_tuple[0], '', name_tuple[2])\n    maiden = record.sub_tag_value(\"SURN\")\n    if maiden:\n        # strip \"(maiden)\" from family name\n        ending = '(' + maiden + ')'\n        surname = name_tuple[1]\n        if surname.endswith(ending):\n            surname = surname[:-len(ending)].rstrip()\n            if surname == '?':\n                surname = ''\n        name_tuple = (name_tuple[0], surname, name_tuple[2], maiden)\n    return name_tuple"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_name_myher(record):\n    name_tuple = split_name(record.value)\n    married = record.sub_tag_value(\"_MARNM\")\n    if married:\n        maiden = name_tuple[1]\n        name_tuple = (name_tuple[0],\n                      married,\n                      name_tuple[2],\n                      maiden)\n    return name_tuple", "response": "Parse NAME structure assuming MYHERITAGE dialect."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmaps numbering onto given values", "response": "def number(items):\n    \"\"\"Maps numbering onto given values\"\"\"\n    n = len(items)\n    if n == 0:\n        return items\n    places = str(int(math.log10(n) // 1 + 1))\n    format = '[{0[0]:' + str(int(places)) + 'd}] {0[1]}'\n    return map(\n        lambda x: format.format(x),\n        enumerate(items)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if yes False if no or the default.", "response": "def filter_yn(string, default=None):\n    \"\"\"Return True if yes, False if no, or the default.\"\"\"\n    if string.startswith(('Y', 'y')):\n        return True\n    elif string.startswith(('N', 'n')):\n        return False\n    elif not string and default is not None:\n        return True if default else False\n    raise InvalidInputError"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_int(string, default=None, start=None, stop=None):\n    try:\n        i = int(string)\n        if start is not None and i < start:\n            raise InvalidInputError(\"value too small\")\n        if stop is not None and i >= stop:\n            raise InvalidInputError(\"value too large\")\n        return i\n    except ValueError:\n        if not string and default is not None:\n            # empty string, default was given\n            return default\n        else:\n            raise InvalidInputError", "response": "Return the input integer or the default."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the input decimal number or the default.", "response": "def filter_decimal(string, default=None, lower=None, upper=None):\n    \"\"\"Return the input decimal number, or the default.\"\"\"\n    try:\n        d = decimal.Decimal(string)\n        if lower is not None and d < lower:\n            raise InvalidInputError(\"value too small\")\n        if upper is not None and d >= upper:\n            raise InvalidInputError(\"value too large\")\n        return d\n    except decimal.InvalidOperation:\n        if not string and default is not None:\n            # empty string, default was given\n            return default\n        else:\n            raise InvalidInputError(\"invalid decimal number\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncoerces to a date not beyond the current date", "response": "def filter_pastdate(string, default=None):\n    \"\"\"Coerce to a date not beyond the current date\n\n    If only a day is given, assumes the current month if that day has\n    passed or is the current day, otherwise assumes the previous month.\n    If a day and month are given, but no year, assumes the current year\n    if the given date has passed (or is today), otherwise the previous\n    year.\n    \"\"\"\n    if not string and default is not None:\n        return default\n\n    today = datetime.date.today()\n\n    # split the string\n    try:\n        parts = map(int, re.split('\\D+', string))  # split the string\n    except ValueError:\n        raise InvalidInputError(\"invalid date; use format: DD [MM [YYYY]]\")\n\n    if len(parts) < 1 or len(parts) > 3:\n        raise InvalidInputError(\"invalid date; use format: DD [MM [YYYY]]\")\n\n    if len(parts) == 1:\n        # no month or year given; append month\n        parts.append(today.month - 1 if parts[0] > today.day else today.month)\n        if parts[1] < 1:\n            parts[1] = 12\n\n    if len(parts) == 2:\n        # no year given; append year\n        if parts[1] > today.month \\\n          or parts[1] == today.month and parts[0] > today.day:\n            parts.append(today.year - 1)\n        else:\n            parts.append(today.year)\n\n    parts.reverse()\n\n    try:\n        date = datetime.date(*parts)\n        if date > today:\n            raise InvalidInputError(\"cannot choose a date in the future\")\n        return date\n    except ValueError:\n        print parts\n        raise InvalidInputError(\"invalid date; use format: DD [MM [YYYY]]\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprompt user until valid input is received.", "response": "def input(self, filter_fn, prompt):\n        \"\"\"Prompt user until valid input is received.\n\n        RejectWarning is raised if a KeyboardInterrupt is caught.\n        \"\"\"\n        while True:\n            try:\n                return filter_fn(raw_input(prompt))\n            except InvalidInputError as e:\n                if e.message:\n                    self.show('ERROR: ' + e.message)\n            except KeyboardInterrupt:\n                raise RejectWarning"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef text(self, prompt, default=None):\n        prompt = prompt if prompt is not None else 'Enter some text'\n        prompt += \" [{0}]: \".format(default) if default is not None else ': '\n        return self.input(curry(filter_text, default=default), prompt)", "response": "Prompts the user for some text with optional default"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decimal(self, prompt, default=None, lower=None, upper=None):\n        prompt = prompt if prompt is not None else \"Enter a decimal number\"\n        prompt += \" [{0}]: \".format(default) if default is not None else ': '\n        return self.input(\n            curry(filter_decimal, default=default, lower=lower, upper=upper),\n            prompt\n        )", "response": "Prompts user to input a decimal number with optional default and bounds."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprompts user to input a date in the past.", "response": "def pastdate(self, prompt, default=None):\n        \"\"\"Prompts user to input a date in the past.\"\"\"\n        prompt = prompt if prompt is not None else \"Enter a past date\"\n        if default is not None:\n            prompt += \" [\" + default.strftime('%d %m %Y') + \"]\"\n        prompt += ': '\n        return self.input(curry(filter_pastdate, default=default), prompt)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef yn(self, prompt, default=None):\n        if default is True:\n            opts = \" [Y/n]: \"\n        elif default is False:\n            opts = \" [y/N]: \"\n        else:\n            opts = \" [y/n]: \"\n        prompt += opts\n        return self.input(curry(filter_yn, default=default), prompt)", "response": "Prompts the user for yes or no confirmation with optional default"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprompts the user to choose one item from a list.", "response": "def choose(self, prompt, items, default=None):\n        \"\"\"Prompts the user to choose one item from a list.\n\n        The default, if provided, is an index; the item of that index will\n        be returned.\n        \"\"\"\n        if default is not None and (default >= len(items) or default < 0):\n            raise IndexError\n        prompt = prompt if prompt is not None else \"Choose from following:\"\n        self.show(prompt + '\\n')\n        self.show(\"\\n\".join(number(items)))  # show the items\n        prompt = \"Enter number of chosen item\"\n        prompt += \" [{0}]: \".format(default) if default is not None else ': '\n        return items[self.input(\n            curry(filter_int, default=default, start=0, stop=len(items)),\n            prompt\n        )]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _tokenize(sentence):\n    '''Tokenizer and Stemmer'''\n\n    _tokens = nltk.word_tokenize(sentence)\n    tokens = [stemmer.stem(tk) for tk in _tokens]\n    return tokens", "response": "Tokenize a string and return a list of tokens."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn tf - idf matrix", "response": "def _normalize(sentences):\n    '''returns tf-idf matrix\n       (unigrams+bigrams)'''\n\n    tfidf = TfidfVectorizer(tokenizer=_tokenize,\n                            stop_words='english',\n                            decode_error='ignore',\n                            ngram_range=(1,2))\n    return tfidf.fit_transform(sentences)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn tuple of scored sentences in order of appearance", "response": "def _intertext_score(full_text):\n    '''returns tuple of scored sentences\n       in order of appearance\n       Note: Doing an A/B test to\n       compare results, reverting to \n       original algorithm.'''\n\n    sentences = sentence_tokenizer(full_text)\n    norm = _normalize(sentences)\n    similarity_matrix = pairwise_kernels(norm, metric='cosine')\n    scores = _textrank(similarity_matrix)\n    scored_sentences = []\n    for i, s in enumerate(sentences):\n        scored_sentences.append((scores[i],i,s))\n    top_scorers = sorted(scored_sentences,\n                         key=lambda tup: tup[0], \n                         reverse=True)\n    return top_scorers"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _eval_meta_as_summary(meta):\n\n    if meta == '':\n        return False\n    if len(meta)>500:\n        return False\n    if 'login' in meta.lower():\n        return False\n    return True", "response": "Check if meta is a summary of what is in the base64 encoded alphabet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef summarize_url(url, num_sentences=4, fmt='default'):\n    '''returns: tuple containing\n       * single-line summary candidate \n       * key points\n       in the format specified.\n    '''\n\n    title, meta, full_text = goose_extractor(url)\n\n    if not full_text:\n        raise ArticleExtractionFail(\"Couldn't extract: {}\".format(url))\n\n    its = _intertext_score(full_text)\n    tss = _title_similarity_score(full_text,title)\n\n    if _eval_meta_as_summary(meta):\n        summ = meta\n        if tss[0][2].lower() in summ.lower():\n            its, tss = _remove_title_from_tuples(its, tss)\n        elif summ.lower() in tss[0][2].lower():\n            summ = tss[0][2]\n            its, tss = _remove_title_from_tuples(its, tss)\n    else:\n        summ = tss[0][2]\n        its, tss = _remove_title_from_tuples(its, tss)\n\n    scores = [score[2] for score in _aggregrate_scores(its, tss, num_sentences)]\n    formatted = Formatter(scores, fmt).frmt()\n    return summ, formatted", "response": "returns tuple containing the summary candidate \n       title meta score and text of the candidate object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a dictionary mapping names to VehicleData instances", "response": "def get_vehicle_data_elements(self):\n        \"\"\"Get a dictionary mapping names to :class:`VehicleData` instances\n\n        This result is based on the results of `GET /ws/vehicle/data` that returns a list\n        of URIs to each vehicle data element.  The value is a handle for accessing\n        additional information about a particular data element.\n\n        :raises WVAError: In the event of a problem retrieving the list of data elements\n        :returns: A dictionary of element names mapped to :class:`VehicleDataElement` instances.\n        \"\"\"\n        # Response looks like: { \"data\": ['vehicle/data/ParkingBrake', ...] }\n        elements = {}\n        for uri in self.get_http_client().get(\"vehicle/data\").get(\"data\", []):\n            name = uri.split(\"/\")[-1]\n            elements[name] = self.get_vehicle_data_element(name)\n        return elements"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_subscriptions(self):\n        # Example: {'subscriptions': ['subscriptions/TripDistance~sub', 'subscriptions/FuelRate~sub', ]}\n        subscriptions = []\n        for uri in self.get_http_client().get(\"subscriptions\").get('subscriptions'):\n            subscriptions.append(self.get_subscription(uri.split(\"/\")[-1]))\n        return subscriptions", "response": "Returns a list of all subscriptions currently active for this WVA device"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the event stream associated with this WVA.", "response": "def get_event_stream(self):\n        \"\"\"Get the event stream associated with this WVA\n\n        Note that this event stream is shared across all users of this WVA device\n        as the WVA only supports a single event stream.\n\n        :return: a new :class:`WVAEventStream` instance\n        \"\"\"\n        if self._event_stream is None:\n            self._event_stream = WVAEventStream(self._http_client)\n        return self._event_stream"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _populateHistogram(self):\n        try :\n            buildHistogram.populate1DHist(self._data, self.histogram,\n                self.minValue, self.maxValue, self.binWidth)\n        except:\n            if ((self._data.max() - self._data.min()) < self.binWidth):\n                raise ValueError(\"In histogram1d class, the binWidth is \"\n                                 \"greater than the data range of the array \"\n                                 \"object.\")\n            else:\n                raise SystemError(\"An error processing the array object \"\n                                  \"information occured in the buildHistogram \"\n                                  \"module of histogram1d.\")", "response": "Call the C - code that actually populates the histogram"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getCenters(self):\n        return np.arange(self.histogram.size) * self.binWidth + self.minValue", "response": "Returns a list of the centers of the histogram."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of location IDs and names.", "response": "def get_reservations(self, sessionid, timeout=None):\n        \"\"\"Returns a list of location IDs and names.\"\"\"\n        url = \"{}{}\".format(BASE_URL, \"/reservations/\")\n        cookies = dict(sessionid=sessionid)\n\n        try:\n            resp = requests.get(url, timeout=timeout, cookies=cookies)\n        except resp.exceptions.HTTPError as error:\n            raise APIError(\"Server Error: {}\".format(error))\n        except requests.exceptions.ConnectTimeout:\n            raise APIError(\"Timeout Error\")\n\n        html = resp.content.decode(\"utf8\")\n\n        if \"https://weblogin.pennkey.upenn.edu\" in html:\n            raise APIError(\"Wharton Auth Failed. Session ID is not valid.\")\n\n        soup = BeautifulSoup(html, \"html5lib\")\n        reservations = []\n        media = soup.find_all(\"div\", {'class': \"Media-body\"})\n        for res in media:\n            times = res.find_all(\"span\", {'class': \"list-view-item__end-time\"})\n            reservation = {\n                \"date\": res.find(\"span\", {'class': \"list-view-item__start-time u-display-block\"}).get_text(),\n                \"startTime\": times[0].get_text(),\n                \"endTime\": times[1].get_text(),\n                \"location\": res.find(\"span\", {'class': \"list-view-item-building\"}).get_text(),\n                \"booking_id\": int(res.find(\"a\")['href'].split(\"delete/\")[1][:-1])\n            }\n            reservations.append(reservation)\n        return reservations"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef book_reservation(self, sessionid, roomid, start, end):\n        duration = int((end - start).seconds / 60)\n        format = \"%Y-%m-%dT%H:%M:%S-{}\".format(self.get_dst_gmt_timezone())\n        booking_url = \"{}/reserve/{}/{}/?d={}\".format(BASE_URL, roomid, start.strftime(format), duration)\n        resp = requests.get(booking_url, cookies={\"sessionid\": sessionid})\n\n        if resp.status_code == 403:\n            return {\"success\": False, \"error\": \"Your account does not have permission to book Wharton GSRs!\"}\n\n        resp.raise_for_status()\n\n        csrfheader = re.search(r\"csrftoken=(.*?);\", resp.headers[\"Set-Cookie\"]).group(1)\n        csrftoken = re.search(r\"<input name=\\\"csrfmiddlewaretoken\\\" type=\\\"hidden\\\" value=\\\"(.*?)\\\"/>\", resp.content.decode(\"utf8\")).group(1)\n\n        start_string = start.strftime(\"%I:%M %p\")\n        if start_string[0] == \"0\":\n            start_string = start_string[1:]\n\n        resp = requests.post(\n            booking_url,\n            cookies={\"sessionid\": sessionid, \"csrftoken\": csrfheader},\n            headers={\"Referer\": booking_url},\n            data={\n                \"csrfmiddlewaretoken\": csrftoken,\n                \"room\": roomid,\n                \"start_time\": start_string,\n                \"end_time\": end.strftime(\"%a %b %d %H:%M:%S %Y\"),\n                \"date\": start.strftime(\"%B %d, %Y\")\n            }\n        )\n        resp.raise_for_status()\n        content = resp.content.decode(\"utf8\")\n        if \"errorlist\" in content:\n            error_msg = re.search(r\"class=\\\"errorlist\\\"><li>(.*?)</li>\", content).group(1)\n            return {\"success\": False, \"error\": error_msg}\n\n        return {\"success\": True}", "response": "Book a reservation given the session id the room id and the start and end time as datetimes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting a Wharton GSR Booking for a given session id.", "response": "def delete_booking(self, sessionid, booking_id):\n        \"\"\" Deletes a Wharton GSR Booking for a given booking and session id. \"\"\"\n        url = \"{}{}{}/\".format(BASE_URL, \"/delete/\", booking_id)\n        cookies = dict(sessionid=sessionid)\n\n        try:\n            resp = requests.get(url, cookies=cookies, headers={'Referer': '{}{}'.format(BASE_URL, \"/reservations/\")})\n        except resp.exceptions.HTTPError as error:\n            raise APIError(\"Server Error: {}\".format(error))\n\n        if resp.status_code == 404:\n            raise APIError(\"Booking could not be found on server.\")\n\n        html = resp.content.decode(\"utf8\")\n        if \"https://weblogin.pennkey.upenn.edu\" in html:\n            raise APIError(\"Wharton Auth Failed. Session ID is not valid.\")\n\n        resp.raise_for_status()\n\n        soup = BeautifulSoup(html, \"html5lib\")\n        middleware_token = soup.find(\"input\", {'name': \"csrfmiddlewaretoken\"}).get('value')\n\n        csrftoken = resp.cookies['csrftoken']\n        cookies2 = {'sessionid': sessionid, 'csrftoken': csrftoken}\n        headers = {'Referer': url}\n        payload = {'csrfmiddlewaretoken': middleware_token}\n\n        try:\n            resp2 = requests.post(url, cookies=cookies2, data=payload, headers=headers)\n        except resp2.exceptions.HTTPError as error:\n            raise APIError(\"Server Error: {}\".format(error))\n\n        return {\"success\": True}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_wharton_gsrs(self, sessionid, date=None):\n        if date:\n            date += \" {}\".format(self.get_dst_gmt_timezone())\n        else:\n            date = datetime.datetime.utcnow().strftime(\"%Y-%m-%d %H:%S\")\n        resp = requests.get('https://apps.wharton.upenn.edu/gsr/api/app/grid_view/', params={\n            'search_time': date\n        }, cookies={\n            'sessionid': sessionid\n        })\n        if resp.status_code == 200:\n            return resp.json()\n        else:\n            raise APIError('Remote server returned status code {}.'.format(resp.status_code))", "response": "Get Wharton GSR listings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef switch_format(self, gsr):\n        if \"error\" in gsr:\n            return gsr\n        categories = {\n            \"cid\": 1,\n            \"name\": \"Huntsman Hall\",\n            \"rooms\": []\n        }\n\n        for time in gsr[\"times\"]:\n            for entry in time:\n                entry[\"name\"] = entry[\"room_number\"]\n                del entry[\"room_number\"]\n                start_time_str = entry[\"start_time\"]\n                end_time = datetime.datetime.strptime(start_time_str[:-6], '%Y-%m-%dT%H:%M:%S') + datetime.timedelta(minutes=30)\n                end_time_str = end_time.strftime(\"%Y-%m-%dT%H:%M:%S\") + \"-{}\".format(self.get_dst_gmt_timezone())\n                time = {\n                    \"available\": not entry[\"reserved\"],\n                    \"start\": entry[\"start_time\"],\n                    \"end\": end_time_str,\n                }\n                exists = False\n                for room in categories[\"rooms\"]:\n                    if room[\"name\"] == entry[\"name\"]:\n                        room[\"times\"].append(time)\n                        exists = True\n                if not exists:\n                    del entry[\"booked_by_user\"]\n                    del entry[\"building\"]\n                    if \"reservation_id\" in entry:\n                        del entry[\"reservation_id\"]\n                    entry[\"lid\"] = 1\n                    entry[\"gid\"] = 1\n                    entry[\"capacity\"] = 5\n                    entry[\"room_id\"] = int(entry[\"id\"])\n                    del entry[\"id\"]\n                    entry[\"times\"] = [time]\n                    del entry[\"reserved\"]\n                    del entry[\"end_time\"]\n                    del entry[\"start_time\"]\n                    categories[\"rooms\"].append(entry)\n        return {\"categories\": [categories], \"rooms\": categories[\"rooms\"]}", "response": "Convert the Wharton GSR format into the studyspaces API format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_wharton_gsrs_formatted(self, sessionid, date=None):\n        gsrs = self.get_wharton_gsrs(sessionid, date)\n        return self.switch_format(gsrs)", "response": "Return the wharton GSR listing formatted in studyspaces format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncollect all the options info from the other modules.", "response": "def get_options():\n    \"\"\"Collect all the options info from the other modules.\"\"\"\n    options = collections.defaultdict(list)\n    for opt_class in config_factory.get_options():\n        if not issubclass(opt_class, config_base.Options):\n            continue\n        config_options = opt_class(None)\n        options[config_options.group_name].extend(config_options.list())\n    return [(key, value) for key, value in options.items()]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_hall_to_link_mapping(self):\n        laundry_path = pkg_resources.resource_filename(\"penn\", \"data/laundry.csv\")\n        with open(laundry_path, \"r\") as f:\n            reader = csv.reader(f)\n            for row in reader:\n                hall_id, hall_name, location, uuid = row\n                hall_id = int(hall_id)\n                self.hall_to_link[hall_name] = ALL_URL + uuid\n                self.id_to_hall[hall_id] = hall_name\n                self.id_to_location[hall_id] = location\n                self.hall_id_list.append({\"hall_name\": hall_name, \"id\": hall_id, \"location\": location})", "response": "Creates mapping from hall name to associated link in SUDS. Creates inverted index from id to hall name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of names hall numbers washers and dryers available for a certain hall.", "response": "def parse_a_hall(self, hall):\n        \"\"\"Return names, hall numbers, and the washers/dryers available for a certain hall.\n\n        :param hall:\n            The ID of the hall to retrieve data for.\n        :type hall: int\n        \"\"\"\n        if hall not in self.hall_to_link:\n            return None  # change to to empty json idk\n        page = requests.get(self.hall_to_link[hall], timeout=60)\n        soup = BeautifulSoup(page.content, 'html.parser')\n        soup.prettify()\n        washers = {\"open\": 0, \"running\": 0, \"out_of_order\": 0, \"offline\": 0, \"time_remaining\": []}\n        dryers = {\"open\": 0, \"running\": 0, \"out_of_order\": 0, \"offline\": 0, \"time_remaining\": []}\n\n        detailed = []\n\n        rows = soup.find_all('tr')\n        for row in rows:\n            cols = row.find_all('td')\n            if len(cols) > 1:\n                machine_type = cols[1].getText()\n                if machine_type == \"Washer\":\n                    washers = Laundry.update_machine_object(cols, washers)\n                elif machine_type == \"Dryer\":\n                    dryers = Laundry.update_machine_object(cols, dryers)\n                if machine_type in [\"Washer\", \"Dryer\"]:\n                    try:\n                        time = int(cols[3].getText().split(\" \")[0])\n                    except ValueError:\n                        time = 0\n                    detailed.append({\n                        \"id\": int(cols[0].getText().split(\" \")[1][1:]),\n                        \"type\": cols[1].getText().lower(),\n                        \"status\": cols[2].getText(),\n                        \"time_remaining\": time\n                    })\n\n        machines = {\"washers\": washers, \"dryers\": dryers, \"details\": detailed}\n        return machines"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef all_status(self):\n        laundry_rooms = {}\n        for room in self.hall_to_link:\n            laundry_rooms[room] = self.parse_a_hall(room)\n\n        return laundry_rooms", "response": "Return the names hall numbers and washers and dryers available for all available system entries."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hall_status(self, hall_id):\n        if hall_id not in self.id_to_hall:\n            raise ValueError(\"No hall with id %s exists.\" % hall_id)\n\n        hall_name = self.id_to_hall[hall_id]\n        location = self.id_to_location[hall_id]\n        machines = self.parse_a_hall(hall_name)\n\n        return {\n            'machines': machines,\n            'hall_name': hall_name,\n            'location': location\n        }", "response": "Return the status of each specific washer or dryer in a particular hall."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_is_working(self):\n        try:\n            r = requests.post(\"http://{}/\".format(LAUNDRY_DOMAIN), timeout=60, data={\n                \"locationid\": \"5faec7e9-a4aa-47c2-a514-950c03fac460\",\n                \"email\": \"pennappslabs@gmail.com\",\n                \"washers\": 0,\n                \"dryers\": 0,\n                \"locationalert\": \"OK\"\n            })\n            r.raise_for_status()\n            return \"The transaction log for database 'QuantumCoin' is full due to 'LOG_BACKUP'.\" not in r.text\n        except requests.exceptions.HTTPError:\n            return False", "response": "Returns True if the wash alert web interface seems to be\n        working properly or False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef machine_usage(self, hall_no):\n\n        try:\n            num = int(hall_no)\n        except ValueError:\n            raise ValueError(\"Room Number must be integer\")\n        r = requests.get(USAGE_BASE_URL + str(num), timeout=60)\n        parsed = BeautifulSoup(r.text, 'html5lib')\n        usage_table = parsed.find_all('table', width='504px')[0]\n        rows = usage_table.find_all('tr')\n        usages = {}\n        for i, row in enumerate(rows):\n            day = []\n            hours = row.find_all('td')\n            for hour in hours:\n                day.append(self.busy_dict[str(hour['class'][0])])\n            usages[self.days[i]] = day\n        return usages", "response": "Returns the average usage of laundry machines every hour\n        for a given hall."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a message object for sending email", "response": "def create_message(from_addr, to_addr, subject, body, encoding=None):\n    \"\"\"\n    Create message object for sending email\n\n    Parameters\n    ----------\n    from_addr : string\n        An email address used for 'From' attribute\n    to_addr : string\n        An email address used for 'To' attribute\n    subject : string\n        An email subject string\n    body : string\n        An email body string\n    encoding : string\n        An email encoding string (Default: utf8)\n\n    Returns\n    -------\n    object\n        An instance of email.mime.text.MIMEText\n    \"\"\"\n    if encoding == \"None\":\n        encoding = None\n    if not encoding:\n        encoding = 'utf-8'\n    msg = MIMEText(body.encode(encoding), 'plain', encoding)\n    msg['Subject'] = Header(subject.encode(encoding), encoding)\n    msg['From'] = from_addr\n    msg['To'] = to_addr\n    msg['Date'] = formatdate()\n    return msg"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending an email via TLS", "response": "def send_email(msg, host='localhost', port=25,\n         username=None, password=None):\n    \"\"\"\n    Send an email (via TLS when username and password are specified)\n\n    Parameters\n    ----------\n    msg : object\n        An instance of MIMEText. Create this with :func:`create_message`\n        function.\n    host : string\n        A mail user agent host name (Default: localhost)\n    port : int\n        A mail user agent port number (Default: 25)\n    username : string\n        A username string used to login MUA via TLS authentication\n    password : string\n        A password string used to login MUA via TLS authentication\n    debug : boolean\n        True for displaying debug messages\n    \"\"\"\n    s = smtplib.SMTP(host, port)\n    if username and password:\n        s.ehlo()\n        s.starttls()\n        s.ehlo()\n        s.login(user, passwd)\n    s.sendmail(msg['From'], [msg['To']], msg.as_string())\n    s.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pull_3year(self):\n        events = []\n        for term in [\"fall\", \"summer\", \"spring\"]:\n            url = \"{}{}{}term.ics\".format(BASE_URL, datetime.datetime.now().year, term)\n            resp = requests.get(url)\n            resp.raise_for_status()\n            r = resp.text\n            lines = r.split(\"\\n\")\n            d = {}\n            for line in lines:\n                if line == \"BEGIN:VEVENT\":\n                    d = {}\n                elif line.startswith(\"DTSTART\"):\n                    raw_date = line.split(\":\")[1]\n                    start_date = datetime.datetime.strptime(raw_date, '%Y%m%d').date()\n                    d['start'] = start_date.strftime('%Y-%m-%d')\n                elif line.startswith(\"DTEND\"):\n                    raw_date = line.split(\":\")[1]\n                    end_date = datetime.datetime.strptime(raw_date, '%Y%m%d').date()\n                    d['end'] = end_date.strftime('%Y-%m-%d')\n                elif line.startswith(\"SUMMARY\"):\n                    name = line.split(\":\")[1]\n                    d['name'] = str(name).strip()\n                elif line == \"END:VEVENT\":\n                    events.append(d)\n\n        events.sort(key=lambda d: d['start'])\n        return events", "response": "Pulls all the events from the Penn iCal Calendar and returns a list of dictionaries containing all the events in chronological order."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nobtaining an auth token from client id and client secret.", "response": "def _obtain_token(self):\n        \"\"\"Obtain an auth token from client id and client secret.\"\"\"\n\n        # don't renew token if hasn't expired yet\n        if self.expiration and self.expiration > datetime.datetime.now():\n            return\n\n        resp = requests.post(\"{}/1.1/oauth/token\".format(API_URL), data={\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"grant_type\": \"client_credentials\"\n        }).json()\n\n        if \"error\" in resp:\n            raise APIError(\"LibCal Auth Failed: {}, {}\".format(resp[\"error\"], resp.get(\"error_description\")))\n\n        self.expiration = datetime.datetime.now() + datetime.timedelta(seconds=resp[\"expires_in\"])\n        self.token = resp[\"access_token\"]\n        print(self.token)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _request(self, *args, **kwargs):\n        if not self.token:\n            self._obtain_token()\n\n        headers = {\n            \"Authorization\": \"Bearer {}\".format(self.token)\n        }\n\n        # add authorization headers\n        if \"headers\" in kwargs:\n            kwargs[\"headers\"].update(headers)\n        else:\n            kwargs[\"headers\"] = headers\n\n        # add api site to url\n        args = list(args)\n        if not args[1].startswith(\"http\"):\n            args[1] = \"{}{}\".format(API_URL, args[1])\n\n        has_no_token = kwargs.get(\"no_token\")\n        if has_no_token:\n            del kwargs[\"no_token\"]\n        resp = requests.request(*args, **kwargs)\n        if resp.status_code == 401 and not has_no_token:\n            self._obtain_token()\n            kwargs[\"no_token\"] = True\n            self._request(*args, **kwargs)\n        return resp", "response": "Make a signed request to the libcal API."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_buildings(self):\n        resp = self._request(\"GET\", \"/1.1/space/locations\").json()\n        out = []\n        for x in resp:\n            if x[\"lid\"] in LOCATION_BLACKLIST:\n                continue\n            if x[\"public\"] == 1:\n                del x[\"public\"]\n                x[\"service\"] = \"libcal\"\n                out.append(x)\n        return out", "response": "Returns a list of location IDs and names."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_rooms(self, lid, start=None, end=None):\n        range_str = \"availability\"\n        if start:\n            start_datetime = datetime.datetime.combine(datetime.datetime.strptime(start, \"%Y-%m-%d\").date(), datetime.datetime.min.time())\n            range_str += \"=\" + start\n            if end and not start == end:\n                range_str += \",\" + end\n        else:\n            start_datetime = None\n\n        resp = self._request(\"GET\", \"/1.1/space/categories/{}\".format(lid)).json()\n        if \"error\" in resp:\n            raise APIError(resp[\"error\"])\n        output = {\"id\": lid, \"categories\": []}\n\n        # if there aren't any rooms associated with this location, return\n        if len(resp) < 1:\n            return output\n\n        if \"error\" in resp[0]:\n            raise APIError(resp[0][\"error\"])\n\n        if \"categories\" not in resp[0]:\n            return output\n\n        categories = resp[0][\"categories\"]\n        id_to_category = {i[\"cid\"]: i[\"name\"] for i in categories}\n        categories = \",\".join([str(x[\"cid\"]) for x in categories])\n        resp = self._request(\"GET\", \"/1.1/space/category/{}\".format(categories))\n        for category in resp.json():\n            cat_out = {\"cid\": category[\"cid\"], \"name\": id_to_category[category[\"cid\"]], \"rooms\": []}\n\n            # ignore equipment categories\n            if cat_out[\"name\"].endswith(\"Equipment\"):\n                continue\n\n            items = category[\"items\"]\n            items = \",\".join([str(x) for x in items])\n            resp = self._request(\"GET\", \"/1.1/space/item/{}?{}\".format(items, range_str))\n            for room in resp.json():\n                if room[\"id\"] in ROOM_BLACKLIST:\n                    continue\n                # prepend protocol to urls\n                if \"image\" in room and room[\"image\"]:\n                    if not room[\"image\"].startswith(\"http\"):\n                        room[\"image\"] = \"https:\" + room[\"image\"]\n                # convert html descriptions to text\n                if \"description\" in room:\n                    description = room[\"description\"].replace(u'\\xa0', u' ')\n                    room[\"description\"] = BeautifulSoup(description, \"html.parser\").text.strip()\n                # remove extra fields\n                if \"formid\" in room:\n                    del room[\"formid\"]\n                # enforce date filter\n                # API returns dates outside of the range, fix this manually\n                if start_datetime:\n                    out_times = []\n                    for time in room[\"availability\"]:\n                        parsed_start = datetime.datetime.strptime(time[\"from\"][:-6], \"%Y-%m-%dT%H:%M:%S\")\n                        if parsed_start >= start_datetime:\n                            out_times.append(time)\n                    room[\"availability\"] = out_times\n                cat_out[\"rooms\"].append(room)\n            if cat_out[\"rooms\"]:\n                output[\"categories\"].append(cat_out)\n        return output", "response": "Returns a list of rooms and their availabilities grouped by category."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbooking a room given the required information.", "response": "def book_room(self, item, start, end, fname, lname, email, nickname, custom={}, test=False):\n        \"\"\"Books a room given the required information.\n\n        :param item:\n            The ID of the room to book.\n        :type item: int\n        :param start:\n            The start time range of when to book the room, in the format returned by the LibCal API.\n        :type start: str\n        :param end:\n            The end time range of when to book the room, in the format returned by the LibCal API.\n        :type end: str\n        :param fname:\n            The first name of the user booking the room.\n        :type fname: str\n        :param lname:\n            The last name of the user booking the room.\n        :type lname: str\n        :param email:\n            The email of the user booking the room.\n        :type email: str\n        :param nickname:\n            The name of the reservation.\n        :type nickname: str\n        :param custom:\n            Any other custom fields required to book the room.\n        :type custom: dict\n        :param test:\n            If this is set to true, don't actually book the room. Default is false.\n        :type test: bool\n        :returns:\n            Dictionary containing a success and error field.\n        \"\"\"\n        data = {\n            \"start\": start,\n            \"fname\": fname,\n            \"lname\": lname,\n            \"email\": email,\n            \"nickname\": nickname,\n            \"bookings\": [\n                {\n                    \"id\": item,\n                    \"to\": end\n                }\n            ],\n            \"test\": test\n        }\n        data.update(custom)\n        resp = self._request(\"POST\", \"/1.1/space/reserve\", json=data)\n        out = resp.json()\n        if \"errors\" in out and \"error\" not in out:\n            errors = out[\"errors\"]\n            if isinstance(errors, list):\n                errors = \" \".join(errors)\n            out[\"error\"] = BeautifulSoup(errors.replace(\"\\n\", \" \"), \"html.parser\").text.strip()\n            del out[\"errors\"]\n        if \"results\" not in out:\n            if \"error\" not in out:\n                out[\"error\"] = None\n                out[\"results\"] = True\n            else:\n                out[\"results\"] = False\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncanceling a room given a booking id.", "response": "def cancel_room(self, booking_id):\n        \"\"\"Cancel a room given a booking id.\n\n        :param booking_id: A booking id or a list of booking ids (separated by commas) to cancel.\n        :type booking_id: str\n        \"\"\"\n        resp = self._request(\"POST\", \"/1.1/space/cancel/{}\".format(booking_id))\n        return resp.json()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the reservations for a given email.", "response": "def get_reservations(self, email, date, timeout=None):\n        \"\"\"Gets reservations for a given email.\n\n        :param email: the email of the user who's reservations are to be fetched\n        :type email: str\n        \"\"\"\n        try:\n            resp = self._request(\"GET\", \"/1.1/space/bookings?email={}&date={}&limit=100\".format(email, date), timeout=timeout)\n        except resp.exceptions.HTTPError as error:\n            raise APIError(\"Server Error: {}\".format(error))\n        except requests.exceptions.ConnectTimeout:\n            raise APIError(\"Timeout Error\")\n        return resp.json()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the booking information for a given list of booking ids.", "response": "def get_reservations_for_booking_ids(self, booking_ids):\n        \"\"\"Gets booking information for a given list of booking ids.\n\n        :param booking_ids: a booking id or a list of room ids (comma separated).\n        :type booking_ids: string\n        \"\"\"\n        try:\n            resp = self._request(\"GET\", \"/1.1/space/booking/{}\".format(booking_ids))\n        except resp.exceptions.HTTPError as error:\n            raise APIError(\"Server Error: {}\".format(error))\n        return resp.json()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the room information for a given list of ids.", "response": "def get_room_info(self, room_ids):\n        \"\"\"Gets room information for a given list of ids.\n\n        :param room_ids: a room id or a list of room ids (comma separated).\n        :type room_ids: string\n        \"\"\"\n        try:\n            resp = self._request(\"GET\", \"/1.1/space/item/{}\".format(room_ids))\n            rooms = resp.json()\n            for room in rooms:\n                if not room[\"image\"].startswith(\"http\"):\n                    room[\"image\"] = \"https:\" + room[\"image\"]\n\n                if \"description\" in room:\n                    description = room[\"description\"].replace(u'\\xa0', u' ')\n                    room[\"description\"] = BeautifulSoup(description, \"html.parser\").text.strip()\n        except resp.exceptions.HTTPError as error:\n            raise APIError(\"Server Error: {}\".format(error))\n        return rooms"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_iso8601(self):\n        if self.__time is None:\n            return None\n\n        return \"%s:%s:%s0Z\" % (self.__time[:2], self.__time[2:4], self.__time[4:])", "response": "returns ISO 8601 time string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate user in the current language", "response": "def create_user(request, ulogin_response):\n    \"\"\"\n    Creates user\n    \"\"\"\n    # Custom behaviour\n    if s.CREATE_USER_CALLBACK is not None:\n        callback = import_by_path(s.CREATE_USER_CALLBACK)\n\n        if callable(callback):\n            return callback(request=request,\n                            ulogin_response=ulogin_response)\n\n        raise ImproperlyConfigured(\n            \"The ULOGIN_CREATE_USER_CALLBACK isn't a callable\"\n        )\n\n    # Default behavior\n    User = get_user_model()\n\n    return User.objects.create_user(\n        username=uuid.uuid4().hex[:30],\n        password=get_random_string(10, '0123456789abcdefghijklmnopqrstuvwxyz'),\n        email=''\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvisits a ShapeDefinition node by traversing all of its children and adding the shape definition information to the instance variables.", "response": "def visitShapeDefinition(self, ctx: ShExDocParser.ShapeDefinitionContext):\n        \"\"\" shapeDefinition: qualifier* '{' oneOfShape? '}' annotation* semanticActions \"\"\"\n        if ctx.qualifier():\n            for q in ctx.qualifier():\n                self.visit(q)\n        if ctx.oneOfShape():\n            oneof_parser = ShexOneOfShapeParser(self.context)\n            oneof_parser.visit(ctx.oneOfShape())\n            self.shape.expression = oneof_parser.expression\n        if ctx.annotation() or ctx.semanticActions():\n            ansem_parser = ShexAnnotationAndSemactsParser(self.context)\n            for annot in ctx.annotation():\n                ansem_parser.visit(annot)\n            ansem_parser.visit(ctx.semanticActions())\n            if ansem_parser.semacts:\n                self.shape.semActs = ansem_parser.semacts\n            if ansem_parser.annotations:\n                self.shape.annotations = ansem_parser.annotations"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvisit inline shape definition.", "response": "def visitInlineShapeDefinition(self, ctx: ShExDocParser.InlineShapeDefinitionContext):\n        \"\"\" shapeDefinition: qualifier* '{' oneOfShape? '}' \"\"\"\n        if ctx.qualifier():\n            for q in ctx.qualifier():\n                self.visit(q)\n        if ctx.oneOfShape():\n            oneof_parser = ShexOneOfShapeParser(self.context)\n            oneof_parser.visit(ctx.oneOfShape())\n            self.shape.expression = oneof_parser.expression"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvisit Qualifier | qualifier|", "response": "def visitQualifier(self, ctx: ShExDocParser.QualifierContext):\n        \"\"\" qualifier: includeSet | extraPropertySet | KW_CLOSED \"\"\"\n        if ctx.includeSet():\n            if self.shape.inherit is None:\n                self.shape.inherit = []\n            self.shape.inherit += [self.context.tripleexprlabel_to_iriref(tel)\n                                   for tel in ctx.includeSet().tripleExpressionLabel()]\n        elif ctx.extraPropertySet():\n            if self.shape.extra is None:\n                self.shape.extra = []\n            self.shape.extra += [self.context.predicate_to_IRI(p) for p in ctx.extraPropertySet().predicate()]\n\n        elif ctx.KW_CLOSED():\n            self.shape.closed = True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reconstruct_ancestral_states(tree, character, states, prediction_method=MPPA, model=F81,\n                                 params=None, avg_br_len=None, num_nodes=None, num_tips=None,\n                                 force_joint=True):\n    \"\"\"\n    Reconstructs ancestral states for the given character on the given tree.\n\n    :param character: character whose ancestral states are to be reconstructed.\n    :type character: str\n    :param tree: tree whose ancestral state are to be reconstructed,\n        annotated with the feature specified as `character` containing node states when known.\n    :type tree: ete3.Tree\n    :param states: possible character states.\n    :type states: numpy.array\n    :param avg_br_len: (optional) average non-zero branch length for this tree. If not specified, will be calculated.\n    :type avg_br_len: float\n    :param model: (optional, default is F81) state evolution model to be used by PASTML.\n    :type model: str\n    :param prediction_method: (optional, default is MPPA) ancestral state prediction method to be used by PASTML.\n    :type prediction_method: str\n    :param num_nodes: (optional) total number of nodes in the given tree (including tips).\n        If not specified, will be calculated.\n    :type num_nodes: int\n    :param num_tips: (optional) total number of tips in the given tree.\n        If not specified, will be calculated.\n    :type num_tips: int\n    :param params: an optional way to fix some parameters,\n        must be in a form {param: value},\n        where param can be a state (then the value should specify its frequency between 0 and 1),\n        or \"scaling factor\" (then the value should be the scaling factor for three branches,\n        e.g. set to 1 to keep the original branches). Could also be in a form path_to_param_file.\n        Only makes sense for ML methods.\n    :type params: dict or str\n\n    :return: ACR result dictionary whose values depend on the prediction method.\n    :rtype: dict\n    \"\"\"\n\n    logging.getLogger('pastml').debug('ACR settings for {}:\\n\\tMethod:\\t{}{}.'\n                                      .format(character, prediction_method,\n                                              '\\n\\tModel:\\t{}'.format(model)\n                                              if model and is_ml(prediction_method) else ''))\n    if COPY == prediction_method:\n        return {CHARACTER: character, STATES: states, METHOD: prediction_method}\n    if not num_nodes:\n        num_nodes = sum(1 for _ in tree.traverse())\n    if not num_tips:\n        num_tips = len(tree)\n    if is_ml(prediction_method):\n        if avg_br_len is None:\n            avg_br_len = np.mean(n.dist for n in tree.traverse() if n.dist)\n        freqs, sf, kappa = None, None, None\n        if params is not None:\n            freqs, sf, kappa = _parse_pastml_parameters(params, states)\n        return ml_acr(tree=tree, character=character, prediction_method=prediction_method, model=model, states=states,\n                      avg_br_len=avg_br_len, num_nodes=num_nodes, num_tips=num_tips, freqs=freqs, sf=sf, kappa=kappa,\n                      force_joint=force_joint)\n    if is_parsimonious(prediction_method):\n        return parsimonious_acr(tree, character, prediction_method, states, num_nodes, num_tips)\n\n    raise ValueError('Method {} is unknown, should be one of ML ({}), one of MP ({}) or {}'\n                     .format(prediction_method, ', '.join(ML_METHODS), ', '.join(MP_METHODS), COPY))", "response": "Reconstructs the ancestral states for a given character on the given tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef acr(tree, df, prediction_method=MPPA, model=F81, column2parameters=None, force_joint=True):\n    for c in df.columns:\n        df[c] = df[c].apply(lambda _: '' if pd.isna(_) else _.encode('ASCII', 'replace').decode())\n    columns = preannotate_tree(df, tree)\n    name_tree(tree)\n    collapse_zero_branches(tree, features_to_be_merged=df.columns)\n\n    avg_br_len, num_nodes, num_tips = get_tree_stats(tree)\n\n    logging.getLogger('pastml').debug('\\n=============ACR===============================')\n\n    column2parameters = column2parameters if column2parameters else {}\n\n    def _work(args):\n        return reconstruct_ancestral_states(*args, avg_br_len=avg_br_len, num_nodes=num_nodes, num_tips=num_tips,\n                                            force_joint=force_joint)\n\n    prediction_methods = value2list(len(columns), prediction_method, MPPA)\n    models = value2list(len(columns), model, F81)\n\n    def get_states(method, model, column):\n        df_states = [_ for _ in df[column].unique() if pd.notnull(_) and _ != '']\n        if not is_ml(method) or model not in {HKY, JTT}:\n            return np.sort(df_states)\n        states = HKY_STATES if HKY == model else JTT_STATES\n        if not set(df_states) & set(states):\n            raise ValueError('The allowed states for model {} are {}, '\n                             'but your annotation file specifies {} as states in column {}.'\n                             .format(model, ', '.join(states), ', '.join(df_states), column))\n        state_set = set(states)\n        df[column] = df[column].apply(lambda _: _ if _ in state_set else '')\n        return states\n\n    with ThreadPool() as pool:\n        acr_results = \\\n            pool.map(func=_work, iterable=((tree, column, get_states(method, model, column), method, model,\n                                            column2parameters[column] if column in column2parameters else None)\n                                           for (column, method, model) in zip(columns, prediction_methods, models)))\n\n    result = []\n    for acr_res in acr_results:\n        if isinstance(acr_res, list):\n            result.extend(acr_res)\n        else:\n            result.append(acr_res)\n\n    return result", "response": "Reconstructs ancestral states for the given tree and a given annotation dataframe."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying PASTML to the given tree.", "response": "def pastml_pipeline(tree, data, data_sep='\\t', id_index=0,\n                    columns=None, prediction_method=MPPA, model=F81, parameters=None,\n                    name_column=None, date_column=None, tip_size_threshold=REASONABLE_NUMBER_OF_TIPS,\n                    out_data=None, html_compressed=None, html=None, work_dir=None,\n                    verbose=False, forced_joint=False, upload_to_itol=False, itol_id=None, itol_project=None,\n                    itol_tree_name=None):\n    \"\"\"\n    Applies PASTML to the given tree with the specified states and visualizes the result (as html maps).\n\n    :param tree: path to the input tree in newick format (must be rooted).\n    :type tree: str\n\n    :param data: path to the annotation file in tab/csv format with the first row containing the column names.\n    :type data: str\n    :param data_sep: (optional, by default '\\t') column separator for the annotation table.\n        By default is set to tab, i.e. for tab-delimited file. Set it to ',' if your file is csv.\n    :type data_sep: char\n    :param id_index: (optional, by default is 0) index of the column in the annotation table\n        that contains the tree tip names, indices start from zero.\n    :type id_index: int\n\n    :param columns: (optional) name(s) of the annotation table column(s) that contain character(s)\n        to be analysed. If not specified all annotation table columns will be considered.\n    :type columns: str or list(str)\n    :param prediction_method: (optional, default is pastml.ml.MPPA) ancestral character reconstruction method(s),\n        can be one of the max likelihood (ML) methods: pastml.ml.MPPA, pastml.ml.MAP, pastml.ml.JOINT,\n        one of the max parsimony (MP) methods: pastml.parsimony.ACCTRAN, pastml.parsimony.DELTRAN,\n        pastml.parsimony.DOWNPASS; or pastml.acr.COPY to keep the annotated character states as-is without inference.\n        One can also specify one of the meta-methods: pastml.ml.ALL, pastml.ml.ML, pastml.parsimony.MP,\n        that would perform ACR with multiple methods (all of them for pastml.ml.ALL,\n        all the ML methods for pastml.ml.ML, or all the MP methods for pastml.parsimony.MP)\n        and save/visualise the results as multiple characters suffixed with the corresponding method.\n        When multiple ancestral characters are specified (with ``columns`` argument),\n        the same method can be used for all of them (if only one method is specified),\n        or different methods can be used (specified in the same order as ``columns``).\n        If multiple methods are given, but not for all the characters,\n        for the rest of them the default method (pastml.ml.MPPA) is chosen.'\n    :type prediction_method: str or list(str)\n    :param forced_joint: (optional, default is False) add JOINT state to the MPPA state selection\n        even if it is not selected by Brier score.\n    :type forced_joint: bool\n    :param model: (optional, default is pastml.models.f81_like.F81) evolutionary model(s) for ML methods\n        (ignored by MP methods).\n        When multiple ancestral characters are specified (with ``columns`` argument),\n        the same model can be used for all of them (if only one model is specified),\n        or different models can be used (specified in the same order as ``columns``).\n        If multiple models are given, but not for all the characters,\n        for the rest of them the default model (pastml.models.f81_like.F81) is chosen.\n    :type model: str or list(str)\n    :param parameters: optional way to fix some of the ML-method parameters.\n        Could be specified as\n        (1a) a dict {column: {param: value}},\n        where column corresponds to the character for which these parameters should be used,\n        or (1b) in a form {column: path_to_param_file};\n        or (2) as a list of paths to parameter files\n        (in the same order as ``columns`` argument that specifies characters)\n        possibly given only for the first few characters;\n        or (3) as a path to parameter file (only for the first character).\n        Each file should be tab-delimited, with two columns: the first one containing parameter names,\n        and the second, named \"value\", containing parameter values.\n        Parameters can include character state frequencies (parameter name should be the corresponding state,\n        and parameter value - the float frequency value, between 0 and 1),\n        and tree branch scaling factor (parameter name pastml.ml.SCALING_FACTOR).\n    :type parameters: str or list(str) or dict\n\n    :param name_column: (optional) name of the annotation table column to be used for node names\n        in the compressed map visualisation\n        (must be one of those specified in ``columns``, if ``columns`` are specified).\n        If the annotation table contains only one column, it will be used by default.\n    :type name_column: str\n    :param date_column: (optional) name of the annotation table column that contains tip dates,\n        if specified it is used to add a time slider to the visualisation.\n    :type date_column: str\n    :param tip_size_threshold: (optional, by default is 15) recursively remove the tips\n        of size less than threshold-th largest tip from the compressed map (set to 1e10 to keep all).\n        The larger it is the less tips will be trimmed.\n    :type tip_size_threshold: int\n\n    :param out_data: path to the output annotation file with the reconstructed ancestral character states.\n    :type out_data: str\n    :param html_compressed: path to the output compressed visualisation file (html).\n    :type html_compressed: str\n    :param html: (optional) path to the output tree visualisation file (html).\n    :type html: str\n    :param work_dir: (optional) path to the folder where pastml parameter, named tree\n        and marginal probability (for marginal ML methods (pastml.ml.MPPA, pastml.ml.MAP) only) files are to be stored.\n        Default is <path_to_input_file>/<input_file_name>_pastml. If the folder does not exist, it will be created.\n    :type work_dir: str\n\n    :param verbose: (optional, default is False) print information on the progress of the analysis.\n    :type verbose: bool\n\n    :param upload_to_itol: (optional, default is False) whether the annotated tree should be uploaded to iTOL\n        (https://itol.embl.de/)\n    :type upload_to_itol: bool\n    :param itol_id: (optional) iTOL user batch upload ID that enables uploading to your iTOL account\n        (see https://itol.embl.de/help.cgi#batch). If not specified, the tree will not be associated to any account.\n    :type itol_id: str\n    :param itol_project: (optional) iTOL project the annotated tree should be uploaded to\n        (must exist, and itol_id must be specified). If not specified, the tree will not be associated to any project.\n    :type itol_project: str\n    :param itol_tree_name: (optional) name for the tree uploaded to iTOL.\n    :type itol_tree_name: str\n\n    :return: void\n    \"\"\"\n    logger = _set_up_pastml_logger(verbose)\n\n    root, df, years, tip2date, name_column = \\\n        _validate_input(columns, data, data_sep, date_column, html, html_compressed, id_index, name_column, tree,\n                        copy_only=COPY == prediction_method or (isinstance(prediction_method, list)\n                                                                and all(COPY == _ for _ in prediction_method)))\n\n    if not date_column:\n        date_column = 'Dist. to root'\n\n    if parameters:\n        if isinstance(parameters, str):\n            parameters = [parameters]\n        if isinstance(parameters, list):\n            parameters = dict(zip(df.columns, parameters))\n        elif isinstance(parameters, dict):\n            parameters = {col_name2cat(col): params for (col, params) in parameters.items()}\n        else:\n            raise ValueError('Parameters should be either a list or a dict, got {}.'.format(type(parameters)))\n    else:\n        parameters = {}\n\n    if not work_dir:\n        work_dir = get_pastml_work_dir(tree)\n    os.makedirs(work_dir, exist_ok=True)\n\n    acr_results = acr(root, df, prediction_method=prediction_method, model=model, column2parameters=parameters,\n                      force_joint=forced_joint)\n    column2states = {acr_result[CHARACTER]: acr_result[STATES] for acr_result in acr_results}\n\n    if not out_data:\n        out_data = os.path.join(work_dir, get_combined_ancestral_state_file())\n    state_df = _serialize_predicted_states(sorted(column2states.keys()), out_data, root)\n\n    # a meta-method would have added a suffix to the name feature\n    if html_compressed and name_column and name_column not in column2states:\n        ml_name_column = get_personalized_feature_name(name_column, get_default_ml_method())\n        name_column = ml_name_column if ml_name_column in column2states \\\n            else get_personalized_feature_name(name_column, get_default_mp_method())\n\n    itol_result = None\n    pool = ThreadPool()\n    new_tree = os.path.join(work_dir, get_named_tree_file(tree))\n    root.write(outfile=new_tree, format_root_node=True, format=3)\n    async_result = pool.map_async(func=_serialize_acr, iterable=((acr_res, work_dir) for acr_res in acr_results))\n    if upload_to_itol:\n        itol_result = pool.apply_async(func=generate_itol_annotations,\n                                       args=(column2states, work_dir, acr_results, state_df, date_column, tip2date,\n                                             new_tree, itol_id, itol_project,\n                                             itol_tree_name))\n\n    if html or html_compressed:\n        logger.debug('\\n=============VISUALISATION=====================')\n        visualize(root, column2states=column2states,\n                  html=html, html_compressed=html_compressed, years=years, tip2date=tip2date,\n                  name_column=name_column, tip_size_threshold=tip_size_threshold, date_column=date_column)\n\n    async_result.wait()\n    if itol_result:\n        itol_result.wait()\n    pool.close()\n\n    return root"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute correction factors for 2D rhizotron geometries following Weigand and Kemna 2017 2017", "response": "def compute_correction_factors(data, true_conductivity, elem_file, elec_file):\n    \"\"\"Compute correction factors for 2D rhizotron geometries, following\n    Weigand and Kemna, 2017, Biogeosciences\n\n    https://doi.org/10.5194/bg-14-921-2017\n\n    Parameters\n    ----------\n    data : :py:class:`pandas.DataFrame`\n        measured data\n    true_conductivity : float\n        Conductivity in S/m\n    elem_file : string\n        path to CRTomo FE mesh file (elem.dat)\n    elec_file : string\n        path to CRTomo FE electrode file (elec.dat)\n\n    Returns\n    -------\n    correction_factors : Nx5 :py:class.`numpy.ndarray`\n        measurement configurations and correction factors\n        (a,b,m,n,correction_factor)\n    \"\"\"\n    settings = {\n        'rho': 100,\n        'pha': 0,\n        'elem': 'elem.dat',\n        'elec': 'elec.dat',\n        '2D': True,\n        'sink_node': 100,\n\n    }\n    K = geometric_factors.compute_K_numerical(data, settings=settings)\n\n    data = geometric_factors.apply_K(data, K)\n    data = fixK.fix_sign_with_K(data)\n\n    frequency = 100\n\n    data_onef = data.query('frequency == {}'.format(frequency))\n    rho_measured = data_onef['r'] * data_onef['k']\n\n    rho_true = 1 / true_conductivity * 1e4\n    correction_factors = rho_true / rho_measured\n\n    collection = np.hstack((\n        data_onef[['a', 'b', 'm', 'n']].values,\n        np.abs(correction_factors)[:, np.newaxis]\n    ))\n\n    return collection"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_resistor_board_measurements(data_file, reference_data_file=None,\n                                      create_plot=True, **kwargs):\n    \"\"\" To check basic system function a test board was built with multiple\n    resistors attached to for connectors each. Measurements can thus be\n    validated against known electrical (ohmic) resistances.\n\n    Note that the normal-reciprocal difference is not yet analyzed!\n\n    The referenc_data_file should have the following structure:\n    The file contains the four-point spreads to be imported from\n    the measurement. This file is a text file with four columns (A, B, M, N),\n    separated by spaces or tabs. Each line denotes one measurement and its\n    expected resistance, the allowed variation, and its allow difference\n    towards its reciprocal counterpart: ::\n\n        1   2   4   3   1000    1    20\n        4   3   2   1   1000    1    20\n\n    Parameters\n    ----------\n    data_file : string\n        path to mnu0 data file\n    reference_data_file: string, optional\n        path to reference data file with structure as describe above. Default\n        data is used if set to None\n    create_plot : bool, optional\n        if True, create a plot with measured and expected resistances\n    **kwargs : dict, optional\n        **kwargs will be redirected to the sEIT.import_eit_fzj call\n\n    Returns\n    -------\n    fig : figure object, optional\n        if create_plot is True, return a matplotlib figure\n    \"\"\"\n    # reference_data = np.loadtxt(reference_data_file)\n    # configs = reference_data[:, 0:4]\n    column_names = [\n        'a', 'b', 'm', 'n', 'expected_r', 'variation_r', 'variation_diffr'\n    ]\n    if reference_data_file is None:\n        ref_data = pd.DataFrame(_resistor_data, columns=column_names)\n    else:\n        ref_data = pd.read_csv(\n            reference_data_file,\n            names=column_names,\n            delim_whitespace=True,\n        )\n    print(ref_data)\n    configs = ref_data[['a', 'b', 'm', 'n']].values.astype(int)\n\n    seit = reda.sEIT()\n    seit.import_eit_fzj(data_file, configs, **kwargs)\n    seit.data = seit.data.merge(ref_data, on=('a', 'b', 'm', 'n'))\n\n    # iterate through the test configurations\n    test_frequency = 1\n    failing = []\n    for nr, row in enumerate(ref_data.values):\n        print(nr, row)\n        key = tuple(row[0:4].astype(int))\n        item = seit.abmn.get_group(key)\n        expected_r = row[4]\n        allowed_variation = row[5]\n        # expected_r_diff = row[6]\n\n        measured_r, measured_rdiff = item.query(\n            'frequency == {}'.format(test_frequency)\n        )[['r', 'rdiff']].values.squeeze()\n        minr = expected_r - allowed_variation\n        maxr = expected_r + allowed_variation\n        if not (minr <= measured_r and maxr >= measured_r):\n            print('    ', 'not passing', row)\n            print('    ', minr, maxr)\n            print('    ', measured_r)\n            failing.append((nr, measured_r))\n    if len(failing) == 0:\n        failing = None\n    else:\n        failing = np.atleast_2d(np.array(failing))\n\n    if create_plot:\n        fig, ax = plt.subplots(1, 1, figsize=(16 / 2.54, 8 / 2.54))\n        data = seit.data.query('frequency == 1')\n        x = np.arange(0, data.shape[0])\n\n        ax.plot(\n            x,\n            data['r'],\n            '.-',\n            label='data',\n        )\n        ax.fill_between(\n            x,\n            data['expected_r'] - data['variation_r'],\n            data['expected_r'] + data['variation_r'],\n            color='green',\n            alpha=0.8,\n            label='allowed limits',\n        )\n        if failing is not None:\n            ax.scatter(\n                failing[:, 0],\n                failing[:, 1],\n                color='r',\n                label='not passing',\n                s=40,\n            )\n\n        ax.legend()\n        ax.set_xticks(x)\n        xticklabels = [\n            '{}-{} {}-{}'.format(*row) for row\n            in data[['a', 'b', 'm', 'n']].values.astype(int)\n        ]\n        ax.set_xticklabels(xticklabels, rotation=45)\n\n        ax.set_ylabel('resistance $[\\Omega]$')\n        ax.set_xlabel('configuration a-b m-n')\n        if failing is None:\n            suffix = ' PASSED'\n        else:\n            suffix = ''\n        ax.set_title('Resistor-check for FZJ-EIT systems' + suffix)\n\n        fig.tight_layout()\n        # fig.savefig('out.pdf')\n        return fig", "response": "This function checks the basic system function of the resistor boards for resistor boards that are not yet built."}
